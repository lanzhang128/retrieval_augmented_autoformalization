{
    "0": {
        "type": "lemma",
        "text": "text\\<open>Some useful rearrangements for two elements of a group.\\<close>\n",
        "assumes": "assumes A1:\"P {is commutative on} G\"\n  and A2: \"a\\<in>G\" \"b\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "IsCommutative_def",
            "group_inv_of_two",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_4_L4:\n  assumes A1:\"P {is commutative on} G\"\n  and A2: \"a\\<in>G\" \"b\\<in>G\"\n  shows \n  \"b\\<inverse>\\<cdot>a\\<inverse> = a\\<inverse>\\<cdot>b\\<inverse>\" \n  \"(a\\<cdot>b)\\<inverse> = a\\<inverse>\\<cdot>b\\<inverse>\" \n  \"(a\\<cdot>b\\<inverse>)\\<inverse> = a\\<inverse>\\<cdot>b\"\n",
        "proof": "proof -\n  from A2 have T1: \"b\\<inverse>\\<in>G\" \"a\\<inverse>\\<in>G\" using inverse_in_group by auto\n  with A1 show \"b\\<inverse>\\<cdot>a\\<inverse> = a\\<inverse>\\<cdot>b\\<inverse>\" using IsCommutative_def by simp\n  with A2 show \"(a\\<cdot>b)\\<inverse> = a\\<inverse>\\<cdot>b\\<inverse>\" using group_inv_of_two by simp\n  from A2 T1 have \"(a\\<cdot>b\\<inverse>)\\<inverse> = (b\\<inverse>)\\<inverse>\\<cdot>a\\<inverse>\" using group_inv_of_two by simp\n  with A1 A2 T1 show \"(a\\<cdot>b\\<inverse>)\\<inverse> = a\\<inverse>\\<cdot>b\" \n    using group_inv_of_inv IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 2
    },
    "1": {
        "type": "lemma",
        "text": "text\\<open>Another bunch of useful rearrangements with three elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "IsCommutative_def",
            "group_op_closed",
            "group_oper_assoc",
            "inverse_in_group",
            "group_inv_of_two",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_4_L4A: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<cdot>c = c\\<cdot>a\\<cdot>b\" \n  \"a\\<inverse>\\<cdot>(b\\<inverse>\\<cdot>c\\<inverse>)\\<inverse> = (a\\<cdot>(b\\<cdot>c)\\<inverse>)\\<inverse>\" \n  \"a\\<cdot>(b\\<cdot>c)\\<inverse> = a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\" \n  \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<inverse> = a\\<cdot>b\\<inverse>\\<cdot>c\" \n  \"a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse> = a\\<cdot>c\\<inverse>\\<cdot>b\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>b\\<cdot>c = c\\<cdot>(a\\<cdot>b)\"\n    using IsCommutative_def group_op_closed\n    by simp\n  with A2 show \"a\\<cdot>b\\<cdot>c = c\\<cdot>a\\<cdot>b\" using\n     group_op_closed group_oper_assoc\n    by simp\n  from A2 have T: \n    \"b\\<inverse>\\<in>G\"  \"c\\<inverse>\\<in>G\"  \"b\\<inverse>\\<cdot>c\\<inverse> \\<in> G\"  \"a\\<cdot>b \\<in> G\"\n    using inverse_in_group group_op_closed\n    by auto\n  with A1 A2 show \"a\\<inverse>\\<cdot>(b\\<inverse>\\<cdot>c\\<inverse>)\\<inverse> = (a\\<cdot>(b\\<cdot>c)\\<inverse>)\\<inverse>\"\n    using group_inv_of_two IsCommutative_def \n    by simp\n  from A1 A2 T have \"a\\<cdot>(b\\<cdot>c)\\<inverse> = a\\<cdot>(b\\<inverse>\\<cdot>c\\<inverse>)\"\n    using group_inv_of_two IsCommutative_def by simp\n  with A2 T show \"a\\<cdot>(b\\<cdot>c)\\<inverse> = a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\"\n    using group_oper_assoc by simp\n  from A1 A2 T have \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<inverse> = a\\<cdot>(b\\<inverse>\\<cdot>(c\\<inverse>)\\<inverse>)\"\n    using group_inv_of_two IsCommutative_def by simp\n  with A2 T show \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<inverse> = a\\<cdot>b\\<inverse>\\<cdot>c\"\n    using group_oper_assoc group_inv_of_inv by simp\n  from A1 A2 T have \"a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse> = a\\<cdot>(c\\<inverse>\\<cdot>b\\<inverse>)\"\n    using group_oper_assoc IsCommutative_def by simp\n  with A2 T show \"a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse> = a\\<cdot>c\\<inverse>\\<cdot>b\\<inverse>\"\n    using group_oper_assoc by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 3
    },
    "2": {
        "type": "lemma",
        "text": "text\\<open>Another useful rearrangement.\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\"\n  and \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "assms",
            "inverse_in_group",
            "group_op_closed",
            "group0_4_L4",
            "group_oper_assoc",
            "inv_cancel_two"
        ],
        "statement": "lemma (in group0) group0_4_L4B: \n  assumes \"P {is commutative on} G\"\n  and \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \"a\\<cdot>b\\<inverse>\\<cdot>(b\\<cdot>c\\<inverse>) = a\\<cdot>c\\<inverse>\"  \n  ",
        "proof": "using assms inverse_in_group group_op_closed \n    group0_4_L4 group_oper_assoc inv_cancel_two by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 4
    },
    "3": {
        "type": "lemma",
        "text": "text\\<open>A couple of permutations of order for three alements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\"\n  ",
        "using": [
            "group0_4_L4A",
            "IsCommutative_def",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) group0_4_L4C: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\"\n  shows\n  \"a\\<cdot>b\\<cdot>c = c\\<cdot>a\\<cdot>b\"\n  \"a\\<cdot>b\\<cdot>c = a\\<cdot>(c\\<cdot>b)\"\n  \"a\\<cdot>b\\<cdot>c = c\\<cdot>(a\\<cdot>b)\"\n  \"a\\<cdot>b\\<cdot>c = c\\<cdot>b\\<cdot>a\"\n",
        "proof": "proof -\n  from A1 A2 show I: \"a\\<cdot>b\\<cdot>c = c\\<cdot>a\\<cdot>b\"\n    using group0_4_L4A by simp\n  also from A1 A2 have \"c\\<cdot>a\\<cdot>b = a\\<cdot>c\\<cdot>b\"\n    using IsCommutative_def by simp\n  also from A2 have \"a\\<cdot>c\\<cdot>b = a\\<cdot>(c\\<cdot>b)\"\n    using group_oper_assoc by simp\n  finally show \"a\\<cdot>b\\<cdot>c = a\\<cdot>(c\\<cdot>b)\" by simp\n  from A2 I show \"a\\<cdot>b\\<cdot>c = c\\<cdot>(a\\<cdot>b)\"\n    using group_oper_assoc by simp\n  also from A1 A2 have \"c\\<cdot>(a\\<cdot>b) = c\\<cdot>(b\\<cdot>a)\"\n    using IsCommutative_def by simp\n  also from A2 have \"c\\<cdot>(b\\<cdot>a) = c\\<cdot>b\\<cdot>a\"\n    using group_oper_assoc by simp\n  finally show \"a\\<cdot>b\\<cdot>c = c\\<cdot>b\\<cdot>a\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 5
    },
    "4": {
        "type": "lemma",
        "text": "text\\<open>Some rearangement with three elements and inverse.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group0_4_L4A",
            "group_inv_of_three",
            "group_inv_of_inv",
            "group0_4_L4C"
        ],
        "statement": "lemma (in group0) group0_4_L4D:\n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \n  \"a\\<inverse>\\<cdot>b\\<inverse>\\<cdot>c = c\\<cdot>a\\<inverse>\\<cdot>b\\<inverse>\"\n  \"b\\<inverse>\\<cdot>a\\<inverse>\\<cdot>c = c\\<cdot>a\\<inverse>\\<cdot>b\\<inverse>\"\n  \"(a\\<inverse>\\<cdot>b\\<cdot>c)\\<inverse> = a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\"\n",
        "proof": "proof -\n  from A2 have T: \n    \"a\\<inverse> \\<in> G\"  \"b\\<inverse> \\<in> G\"  \"c\\<inverse>\\<in>G\"\n    using inverse_in_group by auto\n  with A1 A2 show \n    \"a\\<inverse>\\<cdot>b\\<inverse>\\<cdot>c = c\\<cdot>a\\<inverse>\\<cdot>b\\<inverse>\"\n    \"b\\<inverse>\\<cdot>a\\<inverse>\\<cdot>c = c\\<cdot>a\\<inverse>\\<cdot>b\\<inverse>\"\n    using  group0_4_L4A by auto\n  from A1 A2 T show \"(a\\<inverse>\\<cdot>b\\<cdot>c)\\<inverse> = a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\"\n    using group_inv_of_three group_inv_of_inv group0_4_L4C\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 6
    },
    "5": {
        "type": "lemma",
        "text": "text\\<open>Another rearrangement lemma with three elements and equation.\\<close>\n",
        "assumes": "assumes A1:\"P {is commutative on} G\" \n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  and A3: \"c = a\\<cdot>b\\<inverse>\"\n  ",
        "using": [
            "inverse_in_group",
            "group0_2_L18",
            "group_inv_of_inv",
            "IsCommutative_def"
        ],
        "statement": "lemma (in group0) group0_4_L5: assumes A1:\"P {is commutative on} G\" \n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  and A3: \"c = a\\<cdot>b\\<inverse>\"\n  shows \"a = b\\<cdot>c\"\n",
        "proof": "proof - \n  from A2 A3 have \"c\\<cdot>(b\\<inverse>)\\<inverse> = a\"\n    using inverse_in_group group0_2_L18\n    by simp\n  with A1 A2 show ?thesis using \n     group_inv_of_inv IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 7
    },
    "6": {
        "type": "lemma",
        "text": "text\\<open>In abelian groups we can cancel an element with its inverse\n  even if separated by another element.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group0_4_L4A",
            "group0_2_L6",
            "group0_2_L2",
            "group_oper_assoc",
            "IsCommutative_def",
            "inv_cancel_two"
        ],
        "statement": "lemma (in group0) group0_4_L6A: assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<cdot>a\\<inverse> = b\"\n  \"a\\<inverse>\\<cdot>b\\<cdot>a = b\"\n  \"a\\<inverse>\\<cdot>(b\\<cdot>a) = b\"\n  \"a\\<cdot>(b\\<cdot>a\\<inverse>) = b\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"a\\<cdot>b\\<cdot>a\\<inverse> = a\\<inverse>\\<cdot>a\\<cdot>b\"\n    using inverse_in_group group0_4_L4A by blast\n  also from A2 have \"\\<dots> = b\"\n    using group0_2_L6 group0_2_L2 by simp\n  finally show \"a\\<cdot>b\\<cdot>a\\<inverse> = b\" by simp\n  from A1 A2 have \n    \"a\\<inverse>\\<cdot>b\\<cdot>a = a\\<cdot>a\\<inverse>\\<cdot>b\"\n    using inverse_in_group group0_4_L4A by blast\n  also from A2 have \"\\<dots> = b\"\n    using group0_2_L6 group0_2_L2 by simp\n  finally show \"a\\<inverse>\\<cdot>b\\<cdot>a = b\" by simp\n  moreover from A2 have \"a\\<inverse>\\<cdot>b\\<cdot>a = a\\<inverse>\\<cdot>(b\\<cdot>a)\"\n    using inverse_in_group group_oper_assoc by simp\n  ultimately show \"a\\<inverse>\\<cdot>(b\\<cdot>a) = b\" by simp\n  from A1 A2 show \"a\\<cdot>(b\\<cdot>a\\<inverse>) = b\"\n     using inverse_in_group IsCommutative_def inv_cancel_two\n     by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 8
    },
    "7": {
        "type": "lemma",
        "text": "text\\<open>Another lemma about cancelling with two elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "assms",
            "inverse_in_group",
            "group0_4_L6A"
        ],
        "statement": "lemma (in group0) group0_4_L6AA: \n  assumes A1: \"P {is commutative on} G\" and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a\\<cdot>b\\<inverse>\\<cdot>a\\<inverse> = b\\<inverse>\"\n  ",
        "proof": "using assms inverse_in_group group0_4_L6A\n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 9
    },
    "8": {
        "type": "lemma",
        "text": "text\\<open>Another lemma about cancelling with two elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "group_inv_of_two",
            "inverse_in_group",
            "group_oper_assoc",
            "group0_4_L6AA",
            "IsCommutative_def",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_4_L6AB: \n  assumes A1: \"P {is commutative on} G\" and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \n  \"a\\<cdot>(a\\<cdot>b)\\<inverse> = b\\<inverse>\"\n  \"a\\<cdot>(b\\<cdot>a\\<inverse>) = b\"\n",
        "proof": "proof -\n    from A2 have \"a\\<cdot>(a\\<cdot>b)\\<inverse> = a\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>)\"\n      using group_inv_of_two by simp\n    also from A2 have \"\\<dots> = a\\<cdot>b\\<inverse>\\<cdot>a\\<inverse>\"\n      using inverse_in_group group_oper_assoc by simp\n    also from A1 A2 have \"\\<dots> =  b\\<inverse>\"\n      using group0_4_L6AA by simp\n    finally show \"a\\<cdot>(a\\<cdot>b)\\<inverse> = b\\<inverse>\" by simp\n    from A1 A2 have \"a\\<cdot>(b\\<cdot>a\\<inverse>) = a\\<cdot>(a\\<inverse>\\<cdot>b)\"\n      using inverse_in_group IsCommutative_def by simp\n    also from A2 have \"\\<dots> = b\"\n      using inverse_in_group group_oper_assoc group0_2_L6 group0_2_L2\n      by simp\n    finally show \"a\\<cdot>(b\\<cdot>a\\<inverse>) = b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 10
    },
    "9": {
        "type": "lemma",
        "text": "text\\<open>In abelian groups we can cancel an element with its inverse\n  even if separated by two other elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \n  ",
        "using": [
            "group_op_closed",
            "group_oper_assoc",
            "inverse_in_group",
            "group0_4_L6A"
        ],
        "statement": "lemma (in group0) group0_4_L6B: assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \n  shows \n  \"a\\<cdot>b\\<cdot>c\\<cdot>a\\<inverse> = b\\<cdot>c\"\n  \"a\\<inverse>\\<cdot>b\\<cdot>c\\<cdot>a = b\\<cdot>c\"\n",
        "proof": "proof -\n   from A2 have \n     \"a\\<cdot>b\\<cdot>c\\<cdot>a\\<inverse> = a\\<cdot>(b\\<cdot>c)\\<cdot>a\\<inverse>\"\n     \"a\\<inverse>\\<cdot>b\\<cdot>c\\<cdot>a = a\\<inverse>\\<cdot>(b\\<cdot>c)\\<cdot>a\"\n    using group_op_closed group_oper_assoc inverse_in_group\n    by auto\n  with A1 A2 show\n    \"a\\<cdot>b\\<cdot>c\\<cdot>a\\<inverse> = b\\<cdot>c\"\n    \"a\\<inverse>\\<cdot>b\\<cdot>c\\<cdot>a = b\\<cdot>c\"\n    using group_op_closed group0_4_L6A\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 12
    },
    "10": {
        "type": "lemma",
        "text": "text\\<open>In abelian groups we can cancel an element with its inverse\n  even if separated by three other elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\" \"d\\<in>G\"\n  ",
        "using": [
            "group_op_closed",
            "group_oper_assoc",
            "group0_4_L6A"
        ],
        "statement": "lemma (in group0) group0_4_L6C: assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\" \"d\\<in>G\"\n  shows \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>a\\<inverse> = b\\<cdot>c\\<cdot>d\" \n",
        "proof": "proof -\n  from A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>a\\<inverse> = a\\<cdot>(b\\<cdot>c\\<cdot>d)\\<cdot>a\\<inverse>\"\n    using group_op_closed group_oper_assoc\n    by simp\n  with A1 A2 show ?thesis \n    using group_op_closed group0_4_L6A \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 13
    },
    "11": {
        "type": "lemma",
        "text": "text\\<open>Another couple of useful rearrangements of three elements\n  and cancelling.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "group0_2_L12",
            "group_oper_assoc",
            "group0_4_L6B",
            "IsCommutative_def",
            "group_inv_of_two",
            "group0_4_L6A",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_4_L6D: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<inverse>\\<cdot>(a\\<cdot>c\\<inverse>)\\<inverse> = c\\<cdot>b\\<inverse>\"\n  \"(a\\<cdot>c)\\<inverse>\\<cdot>(b\\<cdot>c) = a\\<inverse>\\<cdot>b\"\n  \"a\\<cdot>(b\\<cdot>(c\\<cdot>a\\<inverse>\\<cdot>b\\<inverse>)) = c\"\n  \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>(c\\<cdot>a\\<inverse>) = b\"\n",
        "proof": "proof -\n  from A2 have T: \n    \"a\\<inverse> \\<in> G\"  \"b\\<inverse> \\<in> G\"  \"c\\<inverse> \\<in> G\" \n    \"a\\<cdot>b \\<in> G\"  \"a\\<cdot>b\\<inverse> \\<in> G\"  \"c\\<inverse>\\<cdot>a\\<inverse> \\<in> G\"  \"c\\<cdot>a\\<inverse> \\<in> G\"\n    using inverse_in_group group_op_closed by auto\n  with A1 A2 show \"a\\<cdot>b\\<inverse>\\<cdot>(a\\<cdot>c\\<inverse>)\\<inverse> = c\\<cdot>b\\<inverse>\"\n    using group0_2_L12 group_oper_assoc group0_4_L6B\n    IsCommutative_def by simp\n  from A2 T have \"(a\\<cdot>c)\\<inverse>\\<cdot>(b\\<cdot>c) = c\\<inverse>\\<cdot>a\\<inverse>\\<cdot>b\\<cdot>c\"\n    using group_inv_of_two group_oper_assoc by simp\n  also from A1 A2 T have \"\\<dots> = a\\<inverse>\\<cdot>b\"\n    using group0_4_L6B by simp\n  finally show \"(a\\<cdot>c)\\<inverse>\\<cdot>(b\\<cdot>c) = a\\<inverse>\\<cdot>b\"\n    by simp\n  from A1 A2 T show \"a\\<cdot>(b\\<cdot>(c\\<cdot>a\\<inverse>\\<cdot>b\\<inverse>)) = c\"\n    using group_oper_assoc group0_4_L6B group0_4_L6A\n    by simp\n  from T have \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>(c\\<cdot>a\\<inverse>) = a\\<cdot>b\\<cdot>(c\\<inverse>\\<cdot>(c\\<cdot>a\\<inverse>))\"\n    using group_oper_assoc by simp\n  also from A1 A2 T have \"\\<dots> = b\"\n    using group_oper_assoc group0_2_L6 group0_2_L2 group0_4_L6A\n    by simp\n  finally show \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>(c\\<cdot>a\\<inverse>) = b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 14
    },
    "12": {
        "type": "lemma",
        "text": "text\\<open>Another useful rearrangement of three elements\n  and cancelling.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group0_4_L6D",
            "group_inv_of_inv",
            "IsCommutative_def"
        ],
        "statement": "lemma (in group0) group0_4_L6E: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<cdot>(a\\<cdot>c)\\<inverse> = b\\<cdot>c\\<inverse>\"\n",
        "proof": "proof -\n  from A2 have T: \"b\\<inverse> \\<in> G\"  \"c\\<inverse> \\<in> G\"\n    using inverse_in_group by auto\n  with A1 A2 have\n    \"a\\<cdot>(b\\<inverse>)\\<inverse>\\<cdot>(a\\<cdot>(c\\<inverse>)\\<inverse>)\\<inverse> = c\\<inverse>\\<cdot>(b\\<inverse>)\\<inverse>\"\n    using group0_4_L6D by simp\n  with A1 A2 T show \"a\\<cdot>b\\<cdot>(a\\<cdot>c)\\<inverse> = b\\<cdot>c\\<inverse>\"\n    using group_inv_of_inv IsCommutative_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 15
    },
    "13": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement with two elements and canceelling,\n  special case of \\<open>group0_4_L6D\\<close> when $c=b^{-1}$.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group0_4_L6D",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_4_L6F: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a\\<cdot>b\\<inverse>\\<cdot>(a\\<cdot>b)\\<inverse> = b\\<inverse>\\<cdot>b\\<inverse>\"\n",
        "proof": "proof -\n  from A2 have \"b\\<inverse> \\<in> G\" \n    using inverse_in_group by simp\n  with A1 A2 have \"a\\<cdot>b\\<inverse>\\<cdot>(a\\<cdot>(b\\<inverse>)\\<inverse>)\\<inverse> = b\\<inverse>\\<cdot>b\\<inverse>\"\n    using group0_4_L6D by simp\n  with A2 show \"a\\<cdot>b\\<inverse>\\<cdot>(a\\<cdot>b)\\<inverse> = b\\<inverse>\\<cdot>b\\<inverse>\"\n    using group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 16
    },
    "14": {
        "type": "lemma",
        "text": "text\\<open>Some rearrangements with four elements and inverse\n  that are applications of \\<open>rearr_ab_gr_4_elem\\<close> \n\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "rearr_ab_gr_4_elemA"
        ],
        "statement": "lemma (in group0) rearr_ab_gr_4_elemB:\n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\\<cdot>d\\<inverse> = a\\<cdot>d\\<inverse>\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\"\n  \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<inverse> = a\\<cdot>d\\<inverse>\\<cdot>b\\<cdot>c\"\n  \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>d\\<inverse> =  a\\<cdot>c\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\"\n",
        "proof": "proof -\n  from A2 have T: \"b\\<inverse> \\<in> G\"  \"c\\<inverse> \\<in> G\"  \"d\\<inverse> \\<in> G\"\n    using inverse_in_group by auto\n  with A1 A2 show \n    \"a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\\<cdot>d\\<inverse> = a\\<cdot>d\\<inverse>\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>\"\n    \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<inverse> = a\\<cdot>d\\<inverse>\\<cdot>b\\<cdot>c\"\n    \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>d\\<inverse> =  a\\<cdot>c\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\"\n    using rearr_ab_gr_4_elemA by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 18
    },
    "15": {
        "type": "lemma",
        "text": "text\\<open>Some rearrangement lemmas with four elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "group_op_closed",
            "inverse_in_group",
            "group_oper_assoc",
            "group0_4_L4A",
            "group_inv_of_two",
            "inv_cancel_two",
            "IsCommutative_def"
        ],
        "statement": "lemma (in group0) group0_4_L7: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<inverse> = a\\<cdot>d\\<inverse>\\<cdot> b\\<cdot>c\" \n  \"a\\<cdot>d\\<cdot>(b\\<cdot>d\\<cdot>(c\\<cdot>d))\\<inverse> = a\\<cdot>(b\\<cdot>c)\\<inverse>\\<cdot>d\\<inverse>\"\n  \"a\\<cdot>(b\\<cdot>c)\\<cdot>d = a\\<cdot>b\\<cdot>d\\<cdot>c\"\n",
        "proof": "proof -\n  from A2 have T:\n    \"b\\<cdot>c \\<in> G\" \"d\\<inverse> \\<in> G\" \"b\\<inverse>\\<in>G\" \"c\\<inverse>\\<in>G\" \n    \"d\\<inverse>\\<cdot>b \\<in> G\" \"c\\<inverse>\\<cdot>d \\<in> G\" \"(b\\<cdot>c)\\<inverse> \\<in> G\"\n    \"b\\<cdot>d \\<in> G\"  \"b\\<cdot>d\\<cdot>c \\<in> G\"  \"(b\\<cdot>d\\<cdot>c)\\<inverse> \\<in> G\"\n    \"a\\<cdot>d \\<in> G\"  \"b\\<cdot>c \\<in> G\"\n    using group_op_closed inverse_in_group \n    by auto\n  with A1 A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<inverse> = a\\<cdot>(d\\<inverse>\\<cdot>b\\<cdot>c)\"\n    using group_oper_assoc group0_4_L4A by simp\n  also from A2 T have \"a\\<cdot>(d\\<inverse>\\<cdot>b\\<cdot>c) = a\\<cdot>d\\<inverse>\\<cdot>b\\<cdot>c\"\n    using group_oper_assoc by simp \n  finally show \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<inverse> = a\\<cdot>d\\<inverse>\\<cdot> b\\<cdot>c\" by simp\n  from A2 T have \"a\\<cdot>d\\<cdot>(b\\<cdot>d\\<cdot>(c\\<cdot>d))\\<inverse> = a\\<cdot>d\\<cdot>(d\\<inverse>\\<cdot>(b\\<cdot>d\\<cdot>c)\\<inverse>)\"\n    using group_oper_assoc group_inv_of_two by simp\n  also from A2 T have \"\\<dots> = a\\<cdot>(b\\<cdot>d\\<cdot>c)\\<inverse>\"\n    using group_oper_assoc inv_cancel_two by simp\n  also from A1 A2 have \"\\<dots> =  a\\<cdot>(d\\<cdot>(b\\<cdot>c))\\<inverse>\"\n    using IsCommutative_def group_oper_assoc by simp\n  also from A2 T have \"\\<dots> = a\\<cdot>((b\\<cdot>c)\\<inverse>\\<cdot>d\\<inverse>)\"\n    using group_inv_of_two by simp\n  also from A2 T have \"\\<dots> =  a\\<cdot>(b\\<cdot>c)\\<inverse>\\<cdot>d\\<inverse>\"\n    using group_oper_assoc by simp\n  finally show \"a\\<cdot>d\\<cdot>(b\\<cdot>d\\<cdot>(c\\<cdot>d))\\<inverse> = a\\<cdot>(b\\<cdot>c)\\<inverse>\\<cdot>d\\<inverse>\"\n    by simp\n  from A2 have \"a\\<cdot>(b\\<cdot>c)\\<cdot>d = a\\<cdot>(b\\<cdot>(c\\<cdot>d))\"\n    using group_op_closed group_oper_assoc by simp\n  also from A1 A2 have \"\\<dots> =  a\\<cdot>(b\\<cdot>(d\\<cdot>c))\"\n    using IsCommutative_def group_op_closed by simp\n  also from A2 have \"\\<dots> =  a\\<cdot>b\\<cdot>d\\<cdot>c\"\n    using group_op_closed group_oper_assoc by simp\n  finally show \"a\\<cdot>(b\\<cdot>c)\\<cdot>d = a\\<cdot>b\\<cdot>d\\<cdot>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 19
    },
    "16": {
        "type": "lemma",
        "text": "text\\<open>Some other rearrangements with four elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "group_op_closed",
            "inverse_in_group",
            "group0_2_L14A",
            "IsCommutative_def",
            "group_oper_assoc",
            "group0_4_L7",
            "group_inv_of_two",
            "group0_2_L12",
            "group0_2_L6",
            "group0_2_L2",
            "inv_cancel_two"
        ],
        "statement": "lemma (in group0) group0_4_L8: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \n  \"a\\<cdot>(b\\<cdot>c)\\<inverse> = (a\\<cdot>d\\<inverse>\\<cdot>c\\<inverse>)\\<cdot>(d\\<cdot>b\\<inverse>)\"\n  \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = c\\<cdot>a\\<cdot>(b\\<cdot>d)\"\n  \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n  \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<cdot>d = a\\<cdot>b\\<cdot>d\\<cdot>c\\<inverse>\"\n  \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\\<inverse> = a\\<cdot>c\\<inverse>\"\n",
        "proof": "proof -\n  from A2 have T:\n    \"b\\<cdot>c \\<in> G\" \"a\\<cdot>b \\<in> G\" \"d\\<inverse> \\<in> G\" \"b\\<inverse>\\<in>G\" \"c\\<inverse>\\<in>G\" \n    \"d\\<inverse>\\<cdot>b \\<in> G\" \"c\\<inverse>\\<cdot>d \\<in> G\" \"(b\\<cdot>c)\\<inverse> \\<in> G\"\n    \"a\\<cdot>b \\<in> G\"  \"(c\\<cdot>d)\\<inverse> \\<in> G\"  \"(b\\<cdot>d\\<inverse>)\\<inverse> \\<in> G\"  \"d\\<cdot>b\\<inverse> \\<in> G\"\n    using group_op_closed inverse_in_group \n    by auto\n  from A2 have \"a\\<cdot>(b\\<cdot>c)\\<inverse> = a\\<cdot>c\\<inverse>\\<cdot>b\\<inverse>\" using group0_2_L14A by blast\n  moreover from A2 have \"a\\<cdot>c\\<inverse> = (a\\<cdot>d\\<inverse>)\\<cdot>(d\\<cdot>c\\<inverse>)\" using group0_2_L14A\n    by blast\n  ultimately have \"a\\<cdot>(b\\<cdot>c)\\<inverse> = (a\\<cdot>d\\<inverse>)\\<cdot>(d\\<cdot>c\\<inverse>)\\<cdot>b\\<inverse>\" by simp\n  with A1 A2 T have \"a\\<cdot>(b\\<cdot>c)\\<inverse>= a\\<cdot>d\\<inverse>\\<cdot>(c\\<inverse>\\<cdot>d)\\<cdot>b\\<inverse>\"\n    using IsCommutative_def by simp\n  with A2 T show \"a\\<cdot>(b\\<cdot>c)\\<inverse> = (a\\<cdot>d\\<inverse>\\<cdot>c\\<inverse>)\\<cdot>(d\\<cdot>b\\<inverse>)\"\n    using group_op_closed group_oper_assoc by simp\n  from A2 T have \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>b\\<cdot>c\\<cdot>d\"\n    using group_oper_assoc by simp\n  also have \"a\\<cdot>b\\<cdot>c\\<cdot>d = c\\<cdot>a\\<cdot>b\\<cdot>d\"\n  proof -\n    from A1 A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d = c\\<cdot>(a\\<cdot>b)\\<cdot>d\"\n      using IsCommutative_def group_op_closed\n      by simp\n    also from A2 have \"\\<dots> = c\\<cdot>a\\<cdot>b\\<cdot>d\"\n      using group_op_closed group_oper_assoc\n      by simp\n    finally show ?thesis by simp\n  qed\n  also from A2 have \"c\\<cdot>a\\<cdot>b\\<cdot>d =  c\\<cdot>a\\<cdot>(b\\<cdot>d)\"\n    using group_op_closed group_oper_assoc\n    by simp\n  finally show \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = c\\<cdot>a\\<cdot>(b\\<cdot>d)\" by simp\n  with A1 A2 show \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n    using IsCommutative_def by simp\n  from A1 A2 T show \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<cdot>d = a\\<cdot>b\\<cdot>d\\<cdot>c\\<inverse>\"\n    using group0_4_L7 by simp\n  from T have \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\\<inverse> = (a\\<cdot>b)\\<cdot>((c\\<cdot>d)\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\\<inverse>)\"\n    using group_oper_assoc by simp\n  also from A1 A2 T have \"\\<dots> = (a\\<cdot>b)\\<cdot>(c\\<inverse>\\<cdot>d\\<inverse>\\<cdot>(d\\<cdot>b\\<inverse>))\"\n    using group_inv_of_two group0_2_L12 IsCommutative_def\n    by simp\n  also from T have \"\\<dots> = (a\\<cdot>b)\\<cdot>(c\\<inverse>\\<cdot>(d\\<inverse>\\<cdot>(d\\<cdot>b\\<inverse>)))\"\n    using group_oper_assoc by simp\n  also from A1 A2 T have \"\\<dots> = a\\<cdot>c\\<inverse>\"\n    using group_oper_assoc group0_2_L6 group0_2_L2 IsCommutative_def\n    inv_cancel_two by simp\n  finally show \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\\<inverse> = a\\<cdot>c\\<inverse>\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 20
    },
    "17": {
        "type": "lemma",
        "text": "text\\<open>Some other rearrangements with four elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) group0_4_L8A: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<inverse>\\<cdot>(c\\<cdot>d\\<inverse>) = a\\<cdot>c\\<cdot>(b\\<inverse>\\<cdot>d\\<inverse>)\"\n  \"a\\<cdot>b\\<inverse>\\<cdot>(c\\<cdot>d\\<inverse>) = a\\<cdot>c\\<cdot>b\\<inverse>\\<cdot>d\\<inverse>\"\n",
        "proof": "proof -\n  from A2 have \n    T: \"a\\<in>G\"  \"b\\<inverse> \\<in> G\"  \"c\\<in>G\"  \"d\\<inverse> \\<in> G\"\n    using inverse_in_group by auto\n  with A1 show \"a\\<cdot>b\\<inverse>\\<cdot>(c\\<cdot>d\\<inverse>) = a\\<cdot>c\\<cdot>(b\\<inverse>\\<cdot>d\\<inverse>)\"\n    by (rule group0_4_L8)\n  with A2 T show  \"a\\<cdot>b\\<inverse>\\<cdot>(c\\<cdot>d\\<inverse>) = a\\<cdot>c\\<cdot>b\\<inverse>\\<cdot>d\\<inverse>\"\n    using group_op_closed group_oper_assoc\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 21
    },
    "18": {
        "type": "lemma",
        "text": "text\\<open>Some rearrangements with an equation.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  and A3: \"a = b\\<cdot>c\\<inverse>\\<cdot>d\\<inverse>\"\n  ",
        "using": [
            "group_op_closed",
            "inverse_in_group",
            "group0_2_L18",
            "group_inv_of_inv",
            "group_oper_assoc",
            "IsCommutative_def",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_4_L9:\n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  and A3: \"a = b\\<cdot>c\\<inverse>\\<cdot>d\\<inverse>\"\n  shows \n  \"d = b\\<cdot>a\\<inverse>\\<cdot>c\\<inverse>\"\n  \"d = a\\<inverse>\\<cdot>b\\<cdot>c\\<inverse>\"\n  \"b = a\\<cdot>d\\<cdot>c\"\n",
        "proof": "proof -\n  from A2 have T: \n    \"a\\<inverse> \\<in> G\"  \"c\\<inverse> \\<in> G\"  \"d\\<inverse> \\<in> G\"  \"b\\<cdot>c\\<inverse> \\<in> G\"\n    using group_op_closed inverse_in_group \n    by auto\n  with A2 A3 have \"a\\<cdot>(d\\<inverse>)\\<inverse> =  b\\<cdot>c\\<inverse>\"\n    using group0_2_L18 by simp\n  with A2 have \"b\\<cdot>c\\<inverse> = a\\<cdot>d\"\n    using group_inv_of_inv by simp\n  with A2 T have I: \"a\\<inverse>\\<cdot>(b\\<cdot>c\\<inverse>) = d\"\n    using group0_2_L18 by simp\n  with A1 A2 T show \n    \"d = b\\<cdot>a\\<inverse>\\<cdot>c\\<inverse>\"\n    \"d = a\\<inverse>\\<cdot>b\\<cdot>c\\<inverse>\"\n    using group_oper_assoc IsCommutative_def by auto\n  from A3 have \"a\\<cdot>d\\<cdot>c = (b\\<cdot>c\\<inverse>\\<cdot>d\\<inverse>)\\<cdot>d\\<cdot>c\" by simp\n  also from A2 T have \"\\<dots> = b\\<cdot>c\\<inverse>\\<cdot>(d\\<inverse>\\<cdot>d)\\<cdot>c\"\n    using group_oper_assoc by simp\n  also from A2 T have \"\\<dots> =  b\\<cdot>c\\<inverse>\\<cdot>c\"\n    using group0_2_L6 group0_2_L2 by simp\n  also from A2 T have \"\\<dots> =  b\\<cdot>(c\\<inverse>\\<cdot>c)\"\n    using group_oper_assoc by simp\n  also from A2 have \"\\<dots> = b\"\n    using group0_2_L6 group0_2_L2 by simp\n  finally have \"a\\<cdot>d\\<cdot>c = b\" by simp\n  thus \"b = a\\<cdot>d\\<cdot>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 22
    },
    "19": {
        "type": "definition",
        "text": "text\\<open>There exist cardinals which are the successor of another cardinal,\nbut; as happens with ordinals, there are cardinals which are limit cardinal.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n    \"LimitC(i) \\<equiv> Card(i) \\<and> 0<i \\<and> (\\<forall>y. (y<i\\<and>Card(y)) \\<longrightarrow> csucc(y)<i)\"\n",
        "proof": "",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 23
    },
    "20": {
        "type": "lemma",
        "text": "text\\<open>Simple fact used a couple of times in proofs.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and \"InfCard(X)\" ",
        "using": [
            "lt_def",
            "InfCard_def",
            "lt_trans2"
        ],
        "statement": "lemma nat_less_infty: assumes \"n\\<in>nat\" and \"InfCard(X)\" shows \"n<X\"\n",
        "proof": "proof -\n  from assms have \"n<nat\" and \"nat\\<le>X\" using lt_def InfCard_def by auto\n  then show \"n<X\" using lt_trans2 by blast\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 24
    },
    "21": {
        "type": "lemma",
        "text": "text\\<open>There are three types of cardinals, the zero one, the succesors\nof other cardinals and the limit cardinals.\\<close>\n",
        "assumes": "assumes \"Card(i)\" \n  ",
        "using": [
            "Card_is_Ord",
            "Ord_0_lt",
            "LimitC_def",
            "not_lt_imp_le",
            "lt_Ord",
            "Card_csucc",
            "csucc_le",
            "le_anti_sym"
        ],
        "statement": "lemma Card_cases_disj: \n  assumes \"Card(i)\" \n  shows \"i=0 | (\\<exists>j. Card(j) \\<and> i=csucc(j)) | LimitC(i)\"\n",
        "proof": "proof-\n  from assms have D: \"Ord(i)\" using Card_is_Ord by auto\n  {\n    assume F: \"i\\<noteq>0\"\n    assume Contr: \"~LimitC(i)\"\n    from F D have \"0<i\" using Ord_0_lt by auto\n    with Contr assms have \"\\<exists>y. y < i \\<and> Card(y) \\<and> \\<not> csucc(y) < i\" \n      using LimitC_def by blast\n    then obtain y where \" y < i \\<and> Card(y) \\<and> \\<not> csucc(y) < i\"  by blast\n    with D have \" y < i\" \" i\\<le>csucc(y)\" and O: \"Card(y)\"\n      using not_lt_imp_le lt_Ord Card_csucc Card_is_Ord\n      by auto\n    with assms have \"csucc(y)\\<le>i\"\"i\\<le>csucc(y)\" using csucc_le by auto\n    then have \"i=csucc(y)\" using le_anti_sym by auto\n    with O have \"\\<exists>j. Card(j) \\<and> i=csucc(j)\" by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 25
    },
    "22": {
        "type": "lemma",
        "text": "text\\<open>Given an ordinal bounded by a cardinal in ordinal order, we can change\nto the order of sets.\\<close>\n",
        "assumes": "assumes \"Card(Q)\"\n  ",
        "using": [
            "le_iff",
            "eqpoll_refl",
            "lt_Card_imp_lesspoll",
            "lesspoll_def",
            "eqpoll_imp_lepoll"
        ],
        "statement": "lemma le_imp_lesspoll:\n  assumes \"Card(Q)\"\n  shows \"A \\<le> Q \\<Longrightarrow> A \\<lesssim> Q\"\n",
        "proof": "proof -\n  assume \"A \\<le> Q\"\n  then have \"A<Q\\<or>A=Q\" using le_iff by auto\n  then have \"A\\<approx>Q\\<or>A< Q\" using eqpoll_refl by auto\n  with assms have \"A\\<approx>Q\\<or>A\\<prec> Q\" using lt_Card_imp_lesspoll by auto\n  then show \"A\\<lesssim>Q\" using lesspoll_def eqpoll_imp_lepoll by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 26
    },
    "23": {
        "type": "lemma",
        "text": "text\\<open>There are two types of infinite cardinals, the natural numbers\nand those that have at least one infinite strictly smaller cardinal.\\<close>\n",
        "assumes": "assumes \"InfCard(Q)\"\n  ",
        "using": [
            "InfCard_nat",
            "le_imp_lesspoll",
            "InfCard_is_Card",
            "not_le_iff_lt",
            "Card_is_Ord",
            "Card_csucc",
            "Card_nat",
            "Card_lt_csucc_iff",
            "InfCard_def",
            "le_anti_sym"
        ],
        "statement": "lemma InfCard_cases_disj:\n  assumes \"InfCard(Q)\"\n  shows \"Q=nat \\<or> (\\<exists>j. csucc(j)\\<lesssim>Q \\<and> InfCard(j))\"\n",
        "proof": "proof-\n  {\n    assume \"\\<forall>j. \\<not> csucc(j) \\<lesssim> Q \\<or> \\<not> InfCard(j)\"\n    then have D: \"\\<not> csucc(nat) \\<lesssim> Q\" using InfCard_nat by auto\n    with D assms have \"\\<not>(csucc(nat) \\<le> Q)\" using le_imp_lesspoll InfCard_is_Card \n      by auto\n    with assms have \"Q<(csucc(nat))\" \n      using not_le_iff_lt Card_is_Ord Card_csucc Card_is_Ord\n        Card_is_Ord InfCard_is_Card Card_nat by auto  \n    with assms have \"Q\\<le>nat\" using Card_lt_csucc_iff InfCard_is_Card Card_nat \n      by auto\n    with assms have \"Q=nat\" using InfCard_def le_anti_sym by auto\n  }\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 27
    },
    "24": {
        "type": "lemma",
        "text": "text\\<open>A more readable version of standard Isabelle/ZF \\<open>Ord_linear_lt\\<close>\\<close>\n",
        "assumes": "assumes \"Ord(i)\" \"Ord(j)\"\n  ",
        "using": [
            "assms",
            "lt_def",
            "Ord_linear",
            "disjE"
        ],
        "statement": "lemma Ord_linear_lt_IML: assumes \"Ord(i)\" \"Ord(j)\"\n  shows \"i<j \\<or> i=j \\<or> j<i\"\n  ",
        "proof": "using assms lt_def Ord_linear disjE by simp \n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 28
    },
    "25": {
        "type": "lemma",
        "text": "text\\<open>A set is injective and not bijective to the successor of a cardinal\nif and only if it is injective and possibly bijective to the cardinal.\\<close>\n",
        "assumes": "assumes \"Card(m)\"\n  ",
        "using": [
            "Card_csucc",
            "Card_is_Ord",
            "assms",
            "lesspoll_imp_eqpoll",
            "lesspoll_def",
            "lepoll_cardinal_le",
            "Card_def",
            "Card_cardinal",
            "le_imp_not_lt",
            "Ord_linear_lt_IML",
            "Card_lt_csucc_iff",
            "le_iff",
            "eqpoll_refl",
            "lt_Card_imp_lesspoll",
            "eqpoll_imp_lepoll",
            "eqpoll_sym",
            "lt_csucc",
            "lesspoll_trans1"
        ],
        "statement": "lemma Card_less_csucc_eq_le: \n  assumes \"Card(m)\"\n  shows \"A \\<prec> csucc(m) \\<longleftrightarrow> A \\<lesssim> m\"\n",
        "proof": "proof\n  have S: \"Ord(csucc(m))\" using Card_csucc Card_is_Ord assms by auto\n  {\n    assume A: \"A \\<prec> csucc(m)\"\n    with S have \"|A|\\<approx>A\" using lesspoll_imp_eqpoll by auto\n    also from A have \"\\<dots>\\<prec> csucc(m)\" by auto\n    finally have \"|A|\\<prec> csucc(m)\" by auto\n    then have \"|A|\\<lesssim>csucc(m)\"\"~(|A|\\<approx>csucc(m))\" using lesspoll_def by auto\n    with S have \"||A||\\<le>csucc(m)\"\"|A|\\<noteq>csucc(m)\" using lepoll_cardinal_le by auto\n    then have \"|A|\\<le>csucc(m)\" \"|A|\\<noteq>csucc(m)\" using Card_def Card_cardinal by auto\n    then have I: \"~(csucc(m)<|A|)\" \"|A|\\<noteq>csucc(m)\" using le_imp_not_lt by auto\n    from S have \"csucc(m)<|A| \\<or> |A|=csucc(m) \\<or> |A|<csucc(m)\"\n      using Card_cardinal Card_is_Ord Ord_linear_lt_IML by auto \n    with I have \"|A|<csucc(m)\" by simp     \n    with assms have \"|A|\\<le>m\" using Card_lt_csucc_iff Card_cardinal\n      by auto\n    then have \"|A|=m\\<or> |A|< m\" using le_iff by auto\n    then have \"|A|\\<approx>m\\<or>|A|< m\" using eqpoll_refl by auto\n    then have \"|A|\\<approx>m\\<or>|A|\\<prec> m\" using lt_Card_imp_lesspoll assms by auto\n    then have T:\"|A|\\<lesssim>m\" using lesspoll_def eqpoll_imp_lepoll by auto\n    from A S have \"A\\<approx>|A|\" using lesspoll_imp_eqpoll eqpoll_sym by auto\n    also from T have \"\\<dots>\\<lesssim>m\" by auto\n    finally show \"A\\<lesssim>m\" by simp\n  }\n  {\n    assume A: \"A\\<lesssim>m\"\n    from assms have \"m\\<prec>csucc(m)\" using lt_Card_imp_lesspoll Card_csucc Card_is_Ord\n      lt_csucc by auto\n    with A show \"A\\<prec>csucc(m)\" using lesspoll_trans1 by auto\n  }\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 29
    },
    "26": {
        "type": "lemma",
        "text": "text\\<open>If the successor of a cardinal is infinite, so is the original\ncardinal.\\<close>\n",
        "assumes": "assumes \"Card(j)\" and \"InfCard(csucc(j))\"\n  ",
        "using": [
            "Finite_def",
            "cardinal_cong",
            "nat_into_Card",
            "Card_def",
            "nat_succI",
            "Card_is_Ord",
            "lt_trans1",
            "csucc_def",
            "lt_def",
            "Card_nat",
            "InfCard_def",
            "lt_trans2",
            "Inf_Card_is_InfCard"
        ],
        "statement": "lemma csucc_inf_imp_inf:\n  assumes \"Card(j)\" and \"InfCard(csucc(j))\"\n  shows \"InfCard(j)\"\n",
        "proof": "proof-\n  {\n    assume f:\"Finite (j)\"\n    then obtain n where \"n\\<in>nat\" \"j\\<approx>n\" using Finite_def by auto\n    with assms(1) have TT: \"j=n\" \"n\\<in>nat\" \n      using cardinal_cong nat_into_Card Card_def by auto\n    then have Q:\"succ(j)\\<in>nat\" using nat_succI by auto\n    with f TT have T: \"Finite(succ(j))\" \"Card(succ(j))\" \n      using nat_into_Card nat_succI by auto \n    from T(2) have \"Card(succ(j))\\<and> j<succ(j)\" using Card_is_Ord by auto\n    moreover from this have \"Ord(succ(j))\" using Card_is_Ord by auto\n    moreover\n    { fix x\n      assume A: \"x<succ(j)\"\n      {\n        assume \"Card(x)\\<and> j<x\"\n        with A have \"False\" using lt_trans1 by auto\n      }\n      hence \"~(Card(x)\\<and> j<x)\" by auto\n    } \n    ultimately have \"(\\<mu> L. Card(L) \\<and> j < L)=succ(j)\"\n      by (rule Least_equality)\n    then have \"csucc(j)=succ(j)\" using csucc_def by auto\n    with Q have \"csucc(j)\\<in>nat\" by auto\n    then have \"csucc(j)<nat\" using lt_def Card_nat Card_is_Ord by auto\n    with assms(2) have \"False\" using InfCard_def lt_trans2 by auto\n  }\n  then have \"~(Finite (j))\" by auto\n  with assms(1) show ?thesis using Inf_Card_is_InfCard by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 30
    },
    "27": {
        "type": "corollary",
        "text": "text\\<open>Since all the cardinals previous to \\<open>nat\\<close>\nare finite, it cannot be a successor cardinal; hence it is \na \\<open>LimitC\\<close> cardinal.\\<close>\n",
        "assumes": "",
        "using": [
            "lt_def",
            "Card_csucc",
            "InfCard_def",
            "csucc_inf_imp_inf",
            "lt_trans2",
            "not_le_iff_lt",
            "Ord_nat",
            "Cacsucc",
            "Card_is_Ord",
            "LimitC_def"
        ],
        "statement": "corollary LimitC_nat:\n  shows \"LimitC(nat)\"\n",
        "proof": "proof-\n  note Card_nat\n  moreover have \"0<nat\" using lt_def by auto\n  moreover\n  {\n    fix y\n    assume AS: \"y<nat\"\"Card(y)\"\n    then have ord: \"Ord(y)\" unfolding lt_def by auto\n    then have Cacsucc: \"Card(csucc(y))\" using Card_csucc by auto\n    {\n      assume \"nat\\<le>csucc(y)\"\n      with Cacsucc have \"InfCard(csucc(y))\" using InfCard_def by auto\n      with AS(2) have \"InfCard(y)\" using csucc_inf_imp_inf by auto\n      then have \"nat\\<le>y\" using InfCard_def by auto\n      with AS(1) have \"False\" using lt_trans2 by auto\n    }\n    hence \"~(nat\\<le>csucc(y))\" by auto\n    then have \"csucc(y)<nat\" using not_le_iff_lt Ord_nat Cacsucc Card_is_Ord by auto\n  }\n  ultimately show ?thesis using LimitC_def by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 31
    },
    "28": {
        "type": "definition",
        "text": "text\\<open>The first predicate we define states that the axiom of $Q$-choice holds for subsets of $K$ if \n  we can find a choice function for every family of subsets of $K$ whose (that family's) \n  cardinality does not exceed $Q$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  AxiomCardinalChoice (\"{the axiom of}_{choice holds for subsets}_\") where\n  \"{the axiom of} Q {choice holds for subsets}K \\<equiv> Card(Q) \\<and> (\\<forall> M N. (M \\<lesssim>Q \\<and>  (\\<forall>t\\<in>M. N`t\\<noteq>0 \\<and> N`t\\<subseteq>K)) \\<longrightarrow> (\\<exists>f. f:Pi(M,\\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. f`t\\<in>N`t)))\"\n",
        "proof": "",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 32
    },
    "29": {
        "type": "definition",
        "text": "text\\<open>Next we define a general form of $Q$ choice where we don't require a collection of files\n  to be included in a file.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  AxiomCardinalChoiceGen (\"{the axiom of}_{choice holds}\") where\n  \"{the axiom of} Q {choice holds} \\<equiv> Card(Q) \\<and> (\\<forall> M N. (M \\<lesssim>Q \\<and>  (\\<forall>t\\<in>M. N`t\\<noteq>0)) \\<longrightarrow> (\\<exists>f. f:Pi(M,\\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. f`t\\<in>N`t)))\"\n",
        "proof": "",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 33
    },
    "30": {
        "type": "theorem",
        "text": "text\\<open>The axiom of finite choice always holds.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\"\n  ",
        "using": [
            "lepoll_0_is_0",
            "AxiomCardinalChoiceGen_def",
            "nat_into_Card",
            "eqpoll_sym",
            "eqpoll_def",
            "bij_restrict_rem",
            "mem_not_refl",
            "eqpoll_imp_lepoll",
            "bij_def",
            "inj_def",
            "apply_funtype",
            "apply_Pair",
            "apply_equality",
            "PP",
            "g(2)",
            "as(1)",
            "ass(1)",
            "lepoll_succ_disj",
            "nat_succI"
        ],
        "statement": "theorem finite_choice:\n  assumes \"n\\<in>nat\"\n  shows \"{the axiom of} n {choice holds}\"\n",
        "proof": "proof -\n  note assms(1)\n  moreover\n  {\n    fix M N assume \"M\\<lesssim>0\" \"\\<forall>t\\<in>M. N`t\\<noteq>0\"\n    then have \"M=0\" using lepoll_0_is_0 by auto\n    then have \"{\\<langle>t,0\\<rangle>. t\\<in>M}:Pi(M,\\<lambda>t. N`t)\" unfolding Pi_def domain_def function_def Sigma_def by auto\n    moreover from \\<open>M=0\\<close> have \"\\<forall>t\\<in>M. {\\<langle>t,0\\<rangle>. t\\<in>M}`t\\<in>N`t\" by auto\n    ultimately have \"(\\<exists>f. f:Pi(M,\\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. f`t\\<in>N`t))\" by auto\n  }\n  then have \"(\\<forall> M N. (M \\<lesssim>0 \\<and>  (\\<forall>t\\<in>M. N`t\\<noteq>0)) \\<longrightarrow> (\\<exists>f. f:Pi(M,\\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. f`t\\<in>N`t)))\" \n    by auto\n  then have \"{the axiom of} 0 {choice holds}\" using AxiomCardinalChoiceGen_def nat_into_Card \n    by auto\n  moreover { \n    fix x\n    assume as: \"x\\<in>nat\" \"{the axiom of} x {choice holds}\"\n    {\n      fix M N assume ass: \"M\\<lesssim>succ(x)\" \"\\<forall>t\\<in>M. N`t\\<noteq>0\"\n      {\n        assume \"M\\<lesssim>x\"\n        from as(2) ass(2) have \n          \"(M \\<lesssim> x \\<and> (\\<forall>t\\<in>M. N ` t \\<noteq> 0)) \\<longrightarrow> (\\<exists>f. f \\<in> Pi(M,\\<lambda>t. N ` t) \\<and> (\\<forall>t\\<in>M. f ` t \\<in> N ` t))\" \n            unfolding AxiomCardinalChoiceGen_def by auto\n        with \\<open>M\\<lesssim>x\\<close> ass(2) have \"(\\<exists>f. f \\<in> Pi(M,\\<lambda>t. N ` t) \\<and> (\\<forall>t\\<in>M. f ` t \\<in> N ` t))\" \n          by auto\n      }\n      moreover\n      {\n        assume \"M\\<approx>succ(x)\"\n        then obtain f where f:\"f\\<in>bij(succ(x),M)\" using eqpoll_sym eqpoll_def by blast \n        moreover\n        have \"x\\<in>succ(x)\" unfolding succ_def by auto\n        ultimately have \"restrict(f,succ(x)-{x})\\<in>bij(succ(x)-{x},M-{f`x})\" using bij_restrict_rem \n          by auto \n        moreover\n        have \"x\\<notin>x\" using mem_not_refl by auto\n        then have \"succ(x)-{x}=x\" unfolding succ_def by auto\n        ultimately have \"restrict(f,x)\\<in>bij(x,M-{f`x})\" by auto\n        then have \"x\\<approx>M-{f`x}\" unfolding eqpoll_def by auto\n        then have \"M-{f`x}\\<approx>x\" using eqpoll_sym by auto\n        then have \"M-{f`x}\\<lesssim>x\" using eqpoll_imp_lepoll by auto\n        with as(2) ass(2) have \"(\\<exists>g. g \\<in> Pi(M-{f`x},\\<lambda>t. N ` t) \\<and> (\\<forall>t\\<in>M-{f`x}. g ` t \\<in> N ` t))\" \n          unfolding AxiomCardinalChoiceGen_def by auto\n        then obtain g where g: \"g\\<in> Pi(M-{f`x},\\<lambda>t. N ` t)\" \"\\<forall>t\\<in>M-{f`x}. g ` t \\<in> N ` t\" \n          by auto\n        from f have ff: \"f`x\\<in>M\" using bij_def inj_def apply_funtype by auto\n        with ass(2) have \"N`(f`x)\\<noteq>0\" by auto\n        then obtain y where y: \"y\\<in>N`(f`x)\" by auto\n        from g(1) have gg: \"g\\<subseteq>Sigma(M-{f`x},(`)(N))\" unfolding Pi_def by auto\n        with y ff have \"g \\<union>{\\<langle>f`x, y\\<rangle>}\\<subseteq>Sigma(M, (`)(N))\" unfolding Sigma_def by auto \n        moreover\n        from g(1) have dom: \"M-{f`x}\\<subseteq>domain(g)\" unfolding Pi_def by auto\n        then have \"M\\<subseteq>domain(g \\<union>{\\<langle>f`x, y\\<rangle>})\" unfolding domain_def by auto \n        moreover\n        from gg g(1) have noe: \"~(\\<exists>t. \\<langle>f`x,t\\<rangle>\\<in>g)\" and \"function(g)\"\n          unfolding domain_def Pi_def Sigma_def by auto  \n        with dom have fg: \"function(g \\<union>{\\<langle>f`x, y\\<rangle>})\" unfolding function_def by blast \n        ultimately have PP: \"g \\<union>{\\<langle>f`x, y\\<rangle>}\\<in>Pi(M,\\<lambda>t. N ` t)\" unfolding Pi_def by auto\n        have \"\\<langle>f`x, y\\<rangle> \\<in> g \\<union>{\\<langle>f`x, y\\<rangle>}\" by auto\n        from this fg have \"(g \\<union>{\\<langle>f`x, y\\<rangle>})`(f`x)=y\" by (rule function_apply_equality)\n        with y have \"(g \\<union>{\\<langle>f`x, y\\<rangle>})`(f`x)\\<in>N`(f`x)\" by auto \n        moreover\n        {\n          fix t assume A:\"t\\<in>M-{f`x}\"\n          with g(1) have \"\\<langle>t,g`t\\<rangle>\\<in>g\" using apply_Pair by auto\n          then have \"\\<langle>t,g`t\\<rangle>\\<in>(g \\<union>{\\<langle>f`x, y\\<rangle>})\" by auto\n          then have \"(g \\<union>{\\<langle>f`x, y\\<rangle>})`t=g`t\" using apply_equality PP by auto\n          with A have \"(g \\<union>{\\<langle>f`x, y\\<rangle>})`t\\<in>N`t\" using g(2) by auto\n        }\n        ultimately have \"\\<forall>t\\<in>M. (g \\<union>{\\<langle>f`x, y\\<rangle>})`t\\<in>N`t\" by auto\n        with PP have \"\\<exists>g. g\\<in>Pi(M,\\<lambda>t. N ` t) \\<and> (\\<forall>t\\<in>M. g`t\\<in>N`t)\" by auto\n      }\n    ultimately have \"\\<exists>g. g \\<in> Pi(M, \\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. g ` t \\<in> N ` t)\" using as(1) ass(1)\n      lepoll_succ_disj by auto\n    }\n    then have \"\\<forall>M N. M \\<lesssim> succ(x)\\<and>(\\<forall>t\\<in>M. N`t\\<noteq>0)\\<longrightarrow>(\\<exists>g. g \\<in> Pi(M,\\<lambda>t. N ` t) \\<and> (\\<forall>t\\<in>M. g ` t \\<in> N ` t))\" \n      by auto\n    then have \"{the axiom of}succ(x){choice holds}\" \n      using AxiomCardinalChoiceGen_def nat_into_Card as(1) nat_succI by auto\n  }\n  ultimately show ?thesis by (rule nat_induct)\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 34
    },
    "31": {
        "type": "lemma",
        "text": "text\\<open>The axiom of choice holds if and only if the \\<open>AxiomCardinalChoice\\<close>\nholds for every couple of a cardinal \\<open>Q\\<close> and a set \\<open>K\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma choice_subset_imp_choice:\n  shows \"{the axiom of} Q {choice holds} \\<longleftrightarrow> (\\<forall> K. {the axiom of} Q {choice holds for subsets}K)\"\n  unfolding AxiomCardinalChoice_def AxiomCardinalChoiceGen_def by blast\n",
        "proof": "",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 35
    },
    "32": {
        "type": "lemma",
        "text": "text\\<open>A choice axiom for greater cardinality implies one for \nsmaller cardinality\\<close>\n",
        "assumes": "assumes \"Q\\<lesssim>Q1\" \"Card(Q)\"\n  ",
        "using": [
            "assms",
            "AxiomCardinalChoiceGen_def",
            "lepoll_trans"
        ],
        "statement": "lemma greater_choice_imp_smaller_choice:\n  assumes \"Q\\<lesssim>Q1\" \"Card(Q)\"\n  shows \"{the axiom of} Q1 {choice holds} \\<longrightarrow> ({the axiom of} Q {choice holds})\" ",
        "proof": "using assms\n  AxiomCardinalChoiceGen_def lepoll_trans by auto   \n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 36
    },
    "33": {
        "type": "lemma",
        "text": "text\\<open>If we have a surjective function from a set which is injective to a set \n  of ordinals, then we can find an injection which goes the other way.\\<close>\n",
        "assumes": "assumes \"f \\<in> surj(A,B)\" \"A\\<subseteq>Q\" \"Ord(Q)\"\n  ",
        "using": [
            "lam_is_fun_range",
            "range_image_domain",
            "lt_def",
            "Ord_in_Ord",
            "LeastI",
            "fun_weaken_type",
            "apply_equality",
            "fun2"
        ],
        "statement": "lemma surj_fun_inv:\n  assumes \"f \\<in> surj(A,B)\" \"A\\<subseteq>Q\" \"Ord(Q)\"\n  shows \"B\\<lesssim>A\"\n",
        "proof": "proof-\n  let ?g = \"{\\<langle>m,\\<mu> j. j\\<in>A \\<and> f`(j)=m\\<rangle>. m\\<in>B}\" \n  have \"?g:B\\<rightarrow>range(?g)\" using lam_is_fun_range by simp\n  then have fun: \"?g:B\\<rightarrow>?g``(B)\" using range_image_domain by simp\n  from assms(2,3) have OA: \"\\<forall>j\\<in>A. Ord(j)\" using lt_def Ord_in_Ord by auto\n  {\n    fix x\n    assume \"x\\<in>?g``(B)\"\n    then have \"x\\<in>range(?g)\" and \"\\<exists>y\\<in>B. \\<langle>y,x\\<rangle>\\<in>?g\" by auto\n    then obtain y where T: \"x=(\\<mu> j. j\\<in>A\\<and> f`(j)=y)\" and \"y\\<in>B\" by auto\n    with assms(1) OA obtain z where P: \"z\\<in>A \\<and> f`(z)=y\" \"Ord(z)\" unfolding surj_def \n      by auto\n    with T have \"x\\<in>A \\<and> f`(x)=y\" using LeastI by simp  \n    hence \"x\\<in>A\" by simp\n  }\n  then have \"?g``(B) \\<subseteq> A\" by auto\n  with fun have fun2: \"?g:B\\<rightarrow>A\" using fun_weaken_type by auto\n  then have \"?g\\<in>inj(B,A)\" \n  proof -\n    {\n      fix w x\n      assume AS: \"?g`w=?g`x\" \"w\\<in>B\" \"x\\<in>B\"\n      from assms(1) OA AS(2,3) obtain wz xz where \n        P1: \"wz\\<in>A \\<and> f`(wz)=w\"  \"Ord(wz)\" and P2: \"xz\\<in>A \\<and> f`(xz)=x\"  \"Ord(xz)\" \n        unfolding surj_def by blast\n      from P1 have \"(\\<mu> j. j\\<in>A\\<and> f`j=w) \\<in> A \\<and> f`(\\<mu> j. j\\<in>A\\<and> f`j=w)=w\" \n        by (rule LeastI)\n      moreover from P2 have \"(\\<mu> j. j\\<in>A\\<and> f`j=x) \\<in> A \\<and> f`(\\<mu> j. j\\<in>A\\<and> f`j=x)=x\"\n        by (rule LeastI) \n      ultimately have R: \"f`(\\<mu> j. j\\<in>A\\<and> f`j=w)=w\" \"f`(\\<mu> j. j\\<in>A\\<and> f`j=x)=x\" \n        by auto\n      from AS have \"(\\<mu> j. j\\<in>A\\<and> f`(j)=w)=(\\<mu> j. j\\<in>A \\<and> f`(j)=x)\" \n        using apply_equality fun2 by auto\n      hence \"f`(\\<mu> j. j\\<in>A \\<and> f`(j)=w) = f`(\\<mu> j. j\\<in>A \\<and> f`(j)=x)\" by auto\n      with R(1) have \"w = f`(\\<mu> j. j\\<in>A\\<and> f`j=x)\" by auto\n      with R(2) have \"w=x\" by auto\n    }\n    hence \"\\<forall>w\\<in>B. \\<forall>x\\<in>B. ?g`(w) = ?g`(x) \\<longrightarrow> w = x\" \n      by auto \n    with fun2 show \"?g\\<in>inj(B,A)\" unfolding inj_def by auto     \n  qed\n  then show ?thesis unfolding lepoll_def by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 37
    },
    "34": {
        "type": "theorem",
        "text": "text\\<open>The difference with the previous result is that in this one\n\\<open>A\\<close> is not a subset of an ordinal, it is only injective\nwith one.\\<close>\n",
        "assumes": "assumes \"f:surj(A,B)\" \"A\\<lesssim>Q\" \"Ord(Q)\"\n  ",
        "using": [
            "lepoll_def",
            "inj_bij_range",
            "bij_converse_bij",
            "bij_def",
            "comp_surj",
            "surj_def",
            "h_def",
            "inj_def",
            "surj_fun_inv",
            "assms(3)",
            "bij",
            "eqpoll_def",
            "eqpoll_sym",
            "lepoll_eq_trans"
        ],
        "statement": "theorem surj_fun_inv_2:\n  assumes \"f:surj(A,B)\" \"A\\<lesssim>Q\" \"Ord(Q)\"\n  shows \"B\\<lesssim>A\"\n",
        "proof": "proof-\n  from assms(2) obtain h where h_def: \"h\\<in>inj(A,Q)\" using lepoll_def by auto\n  then have bij: \"h\\<in>bij(A,range(h))\" using inj_bij_range by auto\n  then obtain h1 where \"h1\\<in>bij(range(h),A)\" using bij_converse_bij by auto\n  then have \"h1 \\<in> surj(range(h),A)\" using bij_def by auto\n  with assms(1) have \"(f O h1)\\<in>surj(range(h),B)\" using comp_surj by auto\n  moreover\n  {\n    fix x\n    assume p: \"x\\<in>range(h)\"\n    from bij have \"h\\<in>surj(A,range(h))\" using bij_def by auto\n    with p obtain q where \"q\\<in>A\" and \"h`(q)=x\" using surj_def by auto\n    then have \"x\\<in>Q\" using h_def inj_def by auto\n  }\n  then have \"range(h)\\<subseteq>Q\" by auto\n  ultimately have \"B\\<lesssim>range(h)\" using surj_fun_inv assms(3) by auto\n  moreover have \"range(h)\\<approx>A\" using bij eqpoll_def eqpoll_sym by blast\n  ultimately show \"B\\<lesssim>A\" using lepoll_eq_trans by auto\nqed\n",
        "imports": [
            "ZF.CardinalArith",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Cardinal_ZF.thy",
        "id": 38
    },
    "35": {
        "type": "definition",
        "text": "text\\<open>We define the sum of values of a function $a: X\\rightarrow G$\n  over a set $\\Lambda$ as the only element of the set of sums of lists \n  that are bijections between the number of values in $\\Lambda$ \n  (which is a natural number $n = \\{0,1, .. , n-1\\}$ if $\\Lambda$\n  is finite) and $\\Lambda$. The notion of \\<open>Fold1(f,c)\\<close> \n  is defined in \\<open>Semigroup_ZF\\<close> as the fold (sum) of the list\n  $c$ starting from the first element of that list. The intention\n  is to use the fact that since the result of summing up a list\n  does not depend on the order, the set \n  \\<open>{Fold1(f,a O b). b \\<in> bij( |\\<Lambda>|, \\<Lambda>)}\\<close> is a singleton\n  and we can extract its only value by taking its union.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"CommSetFold(f,a,\\<Lambda>) = \\<Union>{Fold1(f,a O b). b \\<in> bij(|\\<Lambda>|, \\<Lambda>)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/CommutativeSemigroup_ZF.thy",
        "id": 39
    },
    "36": {
        "type": "lemma",
        "text": "text\\<open>Definition of a sum of function over a set in \n  notation defined in the \\<open>commsemigr\\<close> locale.\\<close>\n",
        "assumes": "",
        "using": [
            "CommSetFold_def"
        ],
        "statement": "lemma (in commsemigr) CommSetFolddef: \n  shows \"(\\<ssum>(A,a)) = (\\<Union>{\\<Sum>(a O b). b \\<in> bij(|A|, A)})\"\n  ",
        "proof": "using CommSetFold_def by simp\n",
        "imports": [
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/CommutativeSemigroup_ZF.thy",
        "id": 40
    },
    "37": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states that the result of a sum does not depend\n  on the order we calculate it. This is similar to lemma \n  \\<open>prod_order_irr\\<close> in the \\<open>Semigroup\\<close> theory,\n  except that the \\<open>semigr1\\<close> locale assumes\n  that the domain of the function we sum up is linearly\n  ordered, while in \\<open>commsemigr\\<close> we don't have\n  this assumption.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and A2: \"b \\<in> bij(|A|,A)\" \n  ",
        "using": [
            "csgassoc",
            "semigr0_def",
            "bij_converse_bij",
            "card_fin_is_nat",
            "natord_lin_on_each_nat",
            "ind_rel_pres_lin",
            "FinPow_def",
            "csgaisfun",
            "restrict_fun",
            "semigr1_axioms.intro",
            "semigr1_def",
            "csgcomm",
            "bij_def",
            "surj_def",
            "comp_restrict",
            "CommSetFolddef"
        ],
        "statement": "lemma (in commsemigr) sum_over_set_bij: \n  assumes A1: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and A2: \"b \\<in> bij(|A|,A)\" \n  shows \"(\\<ssum>(A,a)) = (\\<Sum> (a O b))\"\n",
        "proof": "proof -\n  have \n    \"\\<forall>c \\<in> bij(|A|,A). \\<forall> d \\<in> bij(|A|,A). (\\<Sum>(a O c)) = (\\<Sum>(a O d))\"\n  proof -\n    { fix c assume \"c \\<in> bij(|A|,A)\"\n      fix d assume \"d \\<in> bij(|A|,A)\"\n      let ?r = \"InducedRelation(converse(c), Le)\"\n      have \"semigr1(G,f,A,?r,restrict(a, A))\"\n      proof -\n\thave \"semigr0(G,f)\" using csgassoc semigr0_def by simp\n\tmoreover from A1 \\<open>c \\<in> bij(|A|,A)\\<close> have \"IsLinOrder(A,?r)\" \n\t  using bij_converse_bij card_fin_is_nat \n            natord_lin_on_each_nat ind_rel_pres_lin by simp\n\tmoreover from A1 have \"restrict(a, A) : A \\<rightarrow> G\"\n\t  using FinPow_def csgaisfun restrict_fun by simp\n\tultimately show ?thesis using semigr1_axioms.intro semigr1_def \n\t  by simp\n      qed\n      moreover have \"f {is commutative on} G\" using csgcomm\n\tby simp\n      moreover from A1 have \"A \\<in>  FinPow(A)\" \"A \\<noteq> 0\"\n\tusing FinPow_def by auto\n      moreover note \\<open>c \\<in> bij(|A|,A)\\<close> \\<open>d \\<in> bij(|A|,A)\\<close>\n      ultimately have \n\t\"Fold1(f,restrict(a,A) O c) = Fold1(f,restrict(a,A) O d)\"\n\tby (rule semigr1.prod_bij_same)\n      hence \"(\\<Sum> (restrict(a,A) O c)) = (\\<Sum> (restrict(a,A) O d))\"\n\tby simp\n      moreover from A1 \\<open>c \\<in> bij(|A|,A)\\<close> \\<open>d \\<in> bij(|A|,A)\\<close>\n      have \n\t\"restrict(a,A) O c = a O c\" and \"restrict(a,A) O d = a O d\"\n\tusing bij_def surj_def csgaisfun FinPow_def comp_restrict\n\tby auto\n      ultimately have \"(\\<Sum>(a O c)) = (\\<Sum>(a O d))\" by simp\n      } thus ?thesis by blast\n    qed\n  with A2 have \"(\\<Union>{\\<Sum>(a O b). b \\<in> bij(|A|, A)}) = (\\<Sum> (a O b))\"\n    by (rule singleton_comprehension)\n  then show ?thesis using CommSetFolddef by simp\nqed\n",
        "imports": [
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/CommutativeSemigroup_ZF.thy",
        "id": 41
    },
    "38": {
        "type": "lemma",
        "text": "text\\<open>The result of a sum is in the semigroup. Also, as the second\n  assertion we show that every semigroup valued function\n  generates a homomorphism between the finite subsets of a semigroup \n  and the semigroup. Adding an element to a set coresponds to adding a \n  value.\\<close>\n",
        "assumes": "assumes  A1: \"A \\<in> FinPow(X)\"  \"A \\<noteq> 0\" \n  ",
        "using": [
            "fin_bij_card",
            "sum_over_set_bij",
            "card_fin_is_nat",
            "csgassoc",
            "semigr0_def",
            "card_non_empty_succ",
            "bij_def",
            "inj_def",
            "FinPow_def",
            "comp_fun_subset",
            "csgaisfun",
            "singleton_in_finpow",
            "union_finpow",
            "card_fin_add_one",
            "list_compose_append",
            "apply_funtype"
        ],
        "statement": "lemma (in commsemigr) sum_over_set_add_point: \n  assumes  A1: \"A \\<in> FinPow(X)\"  \"A \\<noteq> 0\" \n  shows \"\\<ssum>(A,a) \\<in> G\" and\n  \"\\<forall>x \\<in> X-A. \\<ssum>(A \\<union> {x},a) = (\\<ssum>(A,a)) \\<ra> a`(x)\"\n",
        "proof": "proof -\n  from A1 obtain b where \"b \\<in> bij(|A|,A)\"\n    using fin_bij_card by auto\n  with A1 have \"\\<ssum>(A,a) = (\\<Sum> (a O b))\"\n    using sum_over_set_bij by simp\n  from A1 have \"|A| \\<in> nat\" using card_fin_is_nat by simp\n  have \"semigr0(G,f)\" using csgassoc semigr0_def by simp\n  moreover\n  from A1 obtain n where \"n \\<in> nat\" and \"|A| = succ(n)\"\n    using card_non_empty_succ by auto\n  with A1  \\<open>b \\<in> bij(|A|,A)\\<close> have \n    \"n \\<in> nat\" and \"a O b : succ(n) \\<rightarrow> G\"\n    using bij_def inj_def FinPow_def comp_fun_subset csgaisfun \n    by auto\n  ultimately have \"Fold1(f,a O b) \\<in> G\" by (rule semigr0.prod_type)\n  with \\<open>\\<ssum>(A,a) = (\\<Sum> (a O b))\\<close> show \"\\<ssum>(A,a) \\<in> G\"\n    by simp\n  { fix x assume \"x \\<in> X-A\"\n    with A1 have \"(A \\<union> {x}) \\<in> FinPow(X)\" and \"A \\<union> {x} \\<noteq> 0\"\n      using singleton_in_finpow union_finpow by auto\n    moreover have \"Append(b,x) \\<in> bij(|A \\<union> {x}|, A \\<union> {x})\"\n    proof -\n      note \\<open>|A| \\<in> nat\\<close> \\<open>b \\<in> bij(|A|,A)\\<close>\n      moreover from \\<open>x \\<in> X-A\\<close> have \"x \\<notin> A\" by simp\n      ultimately have \"Append(b,x) \\<in> bij(succ(|A|), A \\<union> {x})\"\n\tby (rule bij_append_point)\n      with A1 \\<open>x \\<in> X-A\\<close> show ?thesis\n\tusing card_fin_add_one by auto\n    qed\n    ultimately have \"(\\<ssum>(A \\<union> {x},a)) =  (\\<Sum> (a O Append(b,x)))\"\n      using sum_over_set_bij by simp\n    also have \"\\<dots> = (\\<Sum> Append(a O b, a`(x)))\"\n    proof -\n      note \\<open>|A| \\<in> nat\\<close>\n      moreover \n      from A1 \\<open>b \\<in> bij(|A|, A)\\<close> have \n\t\"b : |A| \\<rightarrow> A\" and \"A \\<subseteq> X\"\n\tusing bij_def inj_def using FinPow_def by auto\n      then have \"b : |A| \\<rightarrow> X\" by (rule func1_1_L1B)\n      moreover from \\<open>x \\<in> X-A\\<close> have \"x \\<in> X\" and \"a : X \\<rightarrow> G\"\n\tusing csgaisfun by auto\n      ultimately show ?thesis using list_compose_append\n\tby simp\n    qed\n    also have \"\\<dots> =  (\\<ssum>(A,a)) \\<ra> a`(x)\" \n    proof -\n      note \\<open>semigr0(G,f)\\<close>  \\<open>n \\<in> nat\\<close>  \\<open>a O b : succ(n) \\<rightarrow> G\\<close>\n      moreover from \\<open>x \\<in> X-A\\<close> have \"a`(x) \\<in> G\"\n\tusing csgaisfun apply_funtype by simp\n      ultimately have \n\t\"Fold1(f,Append(a O b, a`(x))) = f`\\<langle>Fold1(f,a O b),a`(x)\\<rangle>\"\n\tby (rule semigr0.prod_append)\n      with A1 \\<open>b \\<in> bij(|A|,A)\\<close> show ?thesis\n\tusing sum_over_set_bij by simp\n    qed\n    finally have \"(\\<ssum>(A \\<union> {x},a)) = (\\<ssum>(A,a)) \\<ra> a`(x)\"\n      by simp\n  } thus \"\\<forall>x \\<in> X-A. \\<ssum>(A \\<union> {x},a) = (\\<ssum>(A,a)) \\<ra> a`(x)\"\n    by simp\nqed  \n",
        "imports": [
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/CommutativeSemigroup_ZF.thy",
        "id": 42
    },
    "39": {
        "type": "definition",
        "text": "text\\<open>An expression representing the imaginary part of the sum\n  of two complex numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ImCxAdd(R,A,a,b) \\<equiv> A`\\<langle>snd(a),snd(b)\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 44
    },
    "40": {
        "type": "definition",
        "text": "text\\<open>The set (function) that is the binary operation that adds complex numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"CplxAdd(R,A) \\<equiv> \n  {\\<langle>p, \\<langle> ReCxAdd(R,A,fst(p),snd(p)),ImCxAdd(R,A,fst(p),snd(p)) \\<rangle> \\<rangle>. \n  p\\<in>(R\\<times>R)\\<times>(R\\<times>R)}\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 45
    },
    "41": {
        "type": "definition",
        "text": "text\\<open>The expression representing the imaginary part of the\n  product of complex numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ImCxMul(R,A,M,a,b) \\<equiv> A`\\<langle>M`\\<langle>fst(a),snd(b)\\<rangle>, M`\\<langle>snd(a),fst(b)\\<rangle> \\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 46
    },
    "42": {
        "type": "definition",
        "text": "text\\<open>The expression representing the real part of the\n  product of complex numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ReCxMul(R,A,M,a,b) \\<equiv> \n  A`\\<langle>M`\\<langle>fst(a),fst(b)\\<rangle>,GroupInv(R,A)`(M`\\<langle>snd(a),snd(b)\\<rangle>)\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 47
    },
    "43": {
        "type": "definition",
        "text": "text\\<open>The function (set) that represents the binary operation of \n  multiplication of complex numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"CplxMul(R,A,M) \\<equiv> \n  { \\<langle>p, \\<langle>ReCxMul(R,A,M,fst(p),snd(p)),ImCxMul(R,A,M,fst(p),snd(p))\\<rangle> \\<rangle>. \n  p \\<in> (R\\<times>R)\\<times>(R\\<times>R)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 48
    },
    "44": {
        "type": "definition",
        "text": "text\\<open>The definition real numbers embedded in the complex plane.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ComplexReals(R,A) \\<equiv> R\\<times>{TheNeutralElement(R,A)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 49
    },
    "45": {
        "type": "definition",
        "text": "text\\<open>Definition of order relation on the real line.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"CplxROrder(R,A,r) \\<equiv> \n  InducedRelation(SliceProjection(ComplexReals(R,A)),r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 50
    },
    "46": {
        "type": "lemma",
        "text": "text\\<open>The next lemma lists some contexts that are valid in the \\<open>complex0\\<close>\n  context.\\<close>\n",
        "assumes": "",
        "using": [
            "IsAmodelOfReals_def",
            "OrdField_ZF_1_L2",
            "field1.axioms",
            "ring1_def",
            "field1.OrdField_ZF_1_L1B",
            "ring1.OrdRing_ZF_1_L4",
            "field0.Field_ZF_1_L1",
            "IsAfield_def",
            "ring0_def",
            "ring0.Ring_ZF_1_L1"
        ],
        "statement": "lemma (in complex0) valid_cntxts: shows\n  \"field1(R,A,M,r)\"\n  \"field0(R,A,M)\"\n  \"ring1(R,A,M,r)\"\n  \"group3(R,A,r)\"\n  \"ring0(R,A,M)\"\n  \"M {is commutative on} R\"\n  \"group0(R,A)\"\n",
        "proof": "proof -\n  from R_are_reals have I: \"IsAnOrdField(R,A,M,r)\"\n    using IsAmodelOfReals_def by simp\n  then show \"field1(R,A,M,r)\" using OrdField_ZF_1_L2 by simp\n  then show \"ring1(R,A,M,r)\" and I: \"field0(R,A,M)\"\n    using field1.axioms ring1_def field1.OrdField_ZF_1_L1B\n    by auto\n  then show \"group3(R,A,r)\" using ring1.OrdRing_ZF_1_L4\n    by simp\n  from I have \"IsAfield(R,A,M)\" using field0.Field_ZF_1_L1\n    by simp\n  then have \"IsAring(R,A,M)\" and \"M {is commutative on} R\"\n    using IsAfield_def by auto\n  then show \"ring0(R,A,M)\" and \"M {is commutative on} R\" \n    using ring0_def by auto\n  then show \"group0(R,A)\" using ring0.Ring_ZF_1_L1\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 51
    },
    "47": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows the definition of real and imaginary part of\n  complex sum and product in a more readable form using notation defined\n  in \\<open>complex0\\<close> locale.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in complex0) cplx_mul_add_defs: shows\n  \"ReCxAdd(R,A,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) = a \\<ra> c\"\n  \"ImCxAdd(R,A,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) = b \\<ra> d\"\n  \"ImCxMul(R,A,M,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) = a\\<rmu>d \\<ra> b\\<rmu>c\"\n  \"ReCxMul(R,A,M,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) =  a\\<rmu>c \\<ra> (\\<rm>b\\<rmu>d)\"\n",
        "proof": "proof -\n  let ?z\\<^sub>1 = \"\\<langle>a,b\\<rangle>\"\n  let ?z\\<^sub>2 = \"\\<langle>c,d\\<rangle>\"\n  have \"ReCxAdd(R,A,?z\\<^sub>1,?z\\<^sub>2) \\<equiv>  A`\\<langle>fst(?z\\<^sub>1),fst(?z\\<^sub>2)\\<rangle>\"\n   by (rule ReCxAdd_def)\n  moreover have \"ImCxAdd(R,A,?z\\<^sub>1,?z\\<^sub>2) \\<equiv>  A`\\<langle>snd(?z\\<^sub>1),snd(?z\\<^sub>2)\\<rangle>\"\n    by (rule ImCxAdd_def)\n  moreover have \n    \"ImCxMul(R,A,M,?z\\<^sub>1,?z\\<^sub>2) \\<equiv> A`\\<langle>M`<fst(?z\\<^sub>1),snd(?z\\<^sub>2)>,M`<snd(?z\\<^sub>1),fst(?z\\<^sub>2)>\\<rangle>\"\n    by (rule ImCxMul_def)\n  moreover have\n    \"ReCxMul(R,A,M,?z\\<^sub>1,?z\\<^sub>2) \\<equiv> \n    A`\\<langle>M`<fst(?z\\<^sub>1),fst(?z\\<^sub>2)>,GroupInv(R,A)`(M`\\<langle>snd(?z\\<^sub>1),snd(?z\\<^sub>2)\\<rangle>)\\<rangle>\"\n    by (rule ReCxMul_def)\n  ultimately show \n    \"ReCxAdd(R,A,?z\\<^sub>1,?z\\<^sub>2) =  a \\<ra> c\"\n    \"ImCxAdd(R,A,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) = b \\<ra> d\"\n    \"ImCxMul(R,A,M,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) = a\\<rmu>d \\<ra> b\\<rmu>c\"\n    \"ReCxMul(R,A,M,\\<langle>a,b\\<rangle>,\\<langle>c,d\\<rangle>) =  a\\<rmu>c \\<ra> (\\<rm>b\\<rmu>d)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 52
    },
    "48": {
        "type": "lemma",
        "text": "text\\<open>Real and imaginary parts of sums and products of complex numbers\n  are real.\\<close>\n",
        "assumes": "assumes A1: \"z\\<^sub>1 \\<in> \\<complex>\"   \"z\\<^sub>2 \\<in> \\<complex>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4",
            "cplx_mul_add_defs"
        ],
        "statement": "lemma (in complex0) cplx_mul_add_types: \n  assumes A1: \"z\\<^sub>1 \\<in> \\<complex>\"   \"z\\<^sub>2 \\<in> \\<complex>\"\n  shows \n  \"ReCxAdd(R,A,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n  \"ImCxAdd(R,A,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n  \"ImCxMul(R,A,M,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n  \"ReCxMul(R,A,M,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n",
        "proof": "proof -\n  let ?a = \"fst(z\\<^sub>1)\"\n  let ?b = \"snd(z\\<^sub>1)\"\n  let ?c = \"fst(z\\<^sub>2)\"\n  let ?d = \"snd(z\\<^sub>2)\"\n  from A1 have \"?a \\<in> R\"  \"?b \\<in> R\"  \"?c \\<in> R\"  \"?d \\<in> R\"\n    by auto\n  then have \n    \"?a \\<ra> ?c \\<in> R\"\n    \"?b \\<ra> ?d \\<in> R\"\n    \"?a\\<rmu>?d \\<ra> ?b\\<rmu>?c \\<in> R\"\n    \"?a\\<rmu>?c \\<ra> (\\<rm> ?b\\<rmu>?d) \\<in> R\"\n    using valid_cntxts ring0.Ring_ZF_1_L4 by auto\n  with A1 show \n    \"ReCxAdd(R,A,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n    \"ImCxAdd(R,A,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n    \"ImCxMul(R,A,M,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n    \"ReCxMul(R,A,M,z\\<^sub>1,z\\<^sub>2) \\<in> R\"\n    using cplx_mul_add_defs by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 53
    },
    "49": {
        "type": "lemma",
        "text": "text\\<open>Complex reals are complex. Recall the definition of \\<open>\\<real>\\<close>\n  in the \\<open>complex0\\<close> locale.\\<close>\n",
        "assumes": "",
        "using": [
            "valid_cntxts",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in complex0) axresscn: shows \"\\<real> \\<subseteq> \\<complex>\"\n  ",
        "proof": "using valid_cntxts group0.group0_2_L2 by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 54
    },
    "50": {
        "type": "lemma",
        "text": "text\\<open>Complex $1$ is not complex $0$.\\<close>\n",
        "assumes": "",
        "using": [
            "valid_cntxts",
            "field0.Field_ZF_1_L1",
            "IsAfield_def"
        ],
        "statement": "lemma (in complex0) ax1ne0: shows \"\\<one> \\<noteq> \\<zero>\"\n",
        "proof": "proof -\n  have \"IsAfield(R,A,M)\" using valid_cntxts field0.Field_ZF_1_L1\n    by simp\n  then show \"\\<one> \\<noteq> \\<zero>\" using IsAfield_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 55
    },
    "51": {
        "type": "lemma",
        "text": "text\\<open>Complex addition is a complex valued binary\n  operation on complex numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "cplx_mul_add_types",
            "CplxAdd_def"
        ],
        "statement": "lemma (in complex0) axaddopr: shows \"CplxAdd(R,A): \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\"\n",
        "proof": "proof -\n  have \"\\<forall>p \\<in> \\<complex>\\<times>\\<complex>. \n    \\<langle>ReCxAdd(R,A,fst(p),snd(p)),ImCxAdd(R,A,fst(p),snd(p))\\<rangle> \\<in> \\<complex>\"\n    using cplx_mul_add_types by simp\n  then have \n    \"{\\<langle>p,\\<langle>ReCxAdd(R,A,fst(p),snd(p)),ImCxAdd(R,A,fst(p),snd(p))\\<rangle> \\<rangle>. \n    p \\<in> \\<complex>\\<times>\\<complex>}: \\<complex>\\<times>\\<complex> \\<rightarrow> \\<complex>\"\n    by (rule ZF_fun_from_total)\n  then show \"CplxAdd(R,A): \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\" using CplxAdd_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 56
    },
    "52": {
        "type": "lemma",
        "text": "text\\<open>Complex multiplication is a complex valued binary\n  operation on complex numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "cplx_mul_add_types",
            "CplxMul_def"
        ],
        "statement": "lemma (in complex0) axmulopr: shows \"CplxMul(R,A,M): \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\"\n",
        "proof": "proof -\n  have \"\\<forall>p \\<in> \\<complex>\\<times>\\<complex>. \n    \\<langle>ReCxMul(R,A,M,fst(p),snd(p)),ImCxMul(R,A,M,fst(p),snd(p))\\<rangle> \\<in> \\<complex>\"\n    using cplx_mul_add_types by simp\n  then have\n   \"{\\<langle>p,\\<langle>ReCxMul(R,A,M,fst(p),snd(p)),ImCxMul(R,A,M,fst(p),snd(p))\\<rangle>\\<rangle>. \n    p \\<in> \\<complex>\\<times>\\<complex>}: \\<complex>\\<times>\\<complex> \\<rightarrow> \\<complex>\" by (rule ZF_fun_from_total)\n  then show \"CplxMul(R,A,M): \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\" using CplxMul_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 57
    },
    "53": {
        "type": "lemma",
        "text": "text\\<open>What are the values of omplex addition and multiplication\n  in terms of their real and imaginary parts?\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"\n  ",
        "using": [
            "axaddopr",
            "CplxAdd_def",
            "cplx_mul_add_defs",
            "axmulopr",
            "CplxMul_def"
        ],
        "statement": "lemma (in complex0) cplx_mul_add_vals: \n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"\n  shows \n  \"\\<langle>a,b\\<rangle> \\<ca> \\<langle>c,d\\<rangle> = \\<langle>a \\<ra> c, b \\<ra> d\\<rangle>\"\n  \"\\<langle>a,b\\<rangle> \\<cdot> \\<langle>c,d\\<rangle> = \\<langle>a\\<rmu>c \\<ra> (\\<rm>b\\<rmu>d), a\\<rmu>d \\<ra> b\\<rmu>c\\<rangle>\"\n",
        "proof": "proof -\n  let ?S = \"CplxAdd(R,A)\" \n  let ?P = \"CplxMul(R,A,M)\"\n  let ?p = \"\\<langle> \\<langle>a,b\\<rangle>, \\<langle>c,d\\<rangle> \\<rangle>\"\n  from A1 have \"?S : \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\" and \"?p \\<in> \\<complex> \\<times> \\<complex>\" \n    using axaddopr by auto\n  moreover have\n    \"?S = {\\<langle>p, <ReCxAdd(R,A,fst(p),snd(p)),ImCxAdd(R,A,fst(p),snd(p))>\\<rangle>. \n    p \\<in> \\<complex> \\<times> \\<complex>}\"\n    using CplxAdd_def by simp\n  ultimately have \"?S`(?p) = \\<langle>ReCxAdd(R,A,fst(?p),snd(?p)),ImCxAdd(R,A,fst(?p),snd(?p))\\<rangle>\"\n    by (rule ZF_fun_from_tot_val)\n  then show \"\\<langle>a,b\\<rangle> \\<ca> \\<langle>c,d\\<rangle> = \\<langle>a \\<ra> c, b \\<ra> d\\<rangle>\"\n    using cplx_mul_add_defs by simp\n  from A1 have \"?P : \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\" and \"?p \\<in> \\<complex> \\<times> \\<complex>\" \n    using axmulopr by auto\n  moreover have \n    \"?P = {\\<langle>p, \\<langle>ReCxMul(R,A,M,fst(p),snd(p)),ImCxMul(R,A,M,fst(p),snd(p))\\<rangle> \\<rangle>. \n    p \\<in> \\<complex> \\<times> \\<complex>}\"\n    using CplxMul_def by simp\n  ultimately have \n    \"?P`(?p) = \\<langle>ReCxMul(R,A,M,fst(?p),snd(?p)),ImCxMul(R,A,M,fst(?p),snd(?p))\\<rangle>\"\n    by (rule ZF_fun_from_tot_val)\n  then show \"\\<langle>a,b\\<rangle> \\<cdot> \\<langle>c,d\\<rangle> = \\<langle>a\\<rmu>c \\<ra> (\\<rm>b\\<rmu>d), a\\<rmu>d \\<ra> b\\<rmu>c\\<rangle>\"\n    using cplx_mul_add_defs by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 58
    },
    "54": {
        "type": "lemma",
        "text": "text\\<open>Complex multiplication is commutative.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  ",
        "using": [
            "assms",
            "cplx_mul_add_vals",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4",
            "field0.field_mult_comm"
        ],
        "statement": "lemma (in complex0) axmulcom: assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  shows \"a\\<cdot>b = b\\<cdot>a\"\n  ",
        "proof": "using assms cplx_mul_add_vals valid_cntxts ring0.Ring_ZF_1_L4 \n      field0.field_mult_comm by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 59
    },
    "55": {
        "type": "lemma",
        "text": "text\\<open>A product of complex numbers is complex.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  ",
        "using": [
            "assms",
            "axmulopr",
            "apply_funtype"
        ],
        "statement": "lemma (in complex0) axmulcl: assumes \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  shows  \"a\\<cdot>b \\<in> \\<complex>\"\n  ",
        "proof": "using assms axmulopr apply_funtype by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 61
    },
    "56": {
        "type": "lemma",
        "text": "text\\<open>Multiplication is distributive with respect to\n  addition.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"  \"c \\<in> \\<complex>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_2_L6"
        ],
        "statement": "lemma (in complex0) axdistr: \n  assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"  \"c \\<in> \\<complex>\"\n  shows \"a\\<cdot>(b \\<ca> c) = a\\<cdot>b \\<ca> a\\<cdot>c\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?a\\<^sub>i = \"snd(a)\"\n  let ?b\\<^sub>r = \"fst(b)\"\n  let ?b\\<^sub>i = \"snd(b)\"\n  let ?c\\<^sub>r = \"fst(c)\"\n  let ?c\\<^sub>i = \"snd(c)\"  \n  from A1 have T: \n    \"?a\\<^sub>r \\<in> R\"  \"?a\\<^sub>i \\<in> R\"  \"?b\\<^sub>r \\<in> R\"  \"?b\\<^sub>i \\<in> R\"  \"?c\\<^sub>r \\<in> R\"  \"?c\\<^sub>i \\<in> R\"\n    \"?b\\<^sub>r\\<ra>?c\\<^sub>r \\<in> R\"  \"?b\\<^sub>i\\<ra>?c\\<^sub>i \\<in> R\"\n    \"?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i) \\<in> R\"\n    \"?a\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?c\\<^sub>i) \\<in> R\"\n    \"?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r \\<in> R\"\n    \"?a\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?c\\<^sub>r \\<in> R\"\n    using valid_cntxts ring0.Ring_ZF_1_L4 by auto\n  with A1 have \"a\\<cdot>(b \\<ca> c) = \n    \\<langle>?a\\<^sub>r\\<rmu>(?b\\<^sub>r\\<ra>?c\\<^sub>r) \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>(?b\\<^sub>i\\<ra>?c\\<^sub>i)),?a\\<^sub>r\\<rmu>(?b\\<^sub>i\\<ra>?c\\<^sub>i) \\<ra> ?a\\<^sub>i\\<rmu>(?b\\<^sub>r\\<ra>?c\\<^sub>r)\\<rangle>\"\n    using cplx_mul_add_vals by auto\n  moreover from T have\n    \"?a\\<^sub>r\\<rmu>(?b\\<^sub>r\\<ra>?c\\<^sub>r) \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>(?b\\<^sub>i\\<ra>?c\\<^sub>i)) =\n    ?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i) \\<ra> (?a\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?c\\<^sub>i))\"\n    and\n    \"?a\\<^sub>r\\<rmu>(?b\\<^sub>i\\<ra>?c\\<^sub>i) \\<ra> ?a\\<^sub>i\\<rmu>(?b\\<^sub>r\\<ra>?c\\<^sub>r) =\n    ?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r \\<ra> (?a\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?c\\<^sub>r)\"\n    using valid_cntxts ring0.Ring_ZF_2_L6 by auto\n  moreover from A1 T have \n    \"\\<langle>?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i) \\<ra> (?a\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?c\\<^sub>i)),\n    ?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r \\<ra> (?a\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?c\\<^sub>r)\\<rangle> =\n    a\\<cdot>b \\<ca> a\\<cdot>c\"\n    using cplx_mul_add_vals by auto\n  ultimately show \"a\\<cdot>(b \\<ca> c) = a\\<cdot>b \\<ca> a\\<cdot>c\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 62
    },
    "57": {
        "type": "lemma",
        "text": "text\\<open>Complex addition is commutative.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  ",
        "using": [
            "assms",
            "cplx_mul_add_vals",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4"
        ],
        "statement": "lemma (in complex0) axaddcom: assumes \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  shows \"a\\<ca>b = b\\<ca>a\"\n  ",
        "proof": "using assms cplx_mul_add_vals valid_cntxts ring0.Ring_ZF_1_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 63
    },
    "58": {
        "type": "lemma",
        "text": "text\\<open>Complex addition is associative.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"  \"c \\<in> \\<complex>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_1_L11"
        ],
        "statement": "lemma (in complex0) axaddass: assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"  \"c \\<in> \\<complex>\"\n  shows \"a \\<ca> b \\<ca> c = a \\<ca> (b \\<ca> c)\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?a\\<^sub>i = \"snd(a)\"\n  let ?b\\<^sub>r = \"fst(b)\"\n  let ?b\\<^sub>i = \"snd(b)\"\n  let ?c\\<^sub>r = \"fst(c)\"\n  let ?c\\<^sub>i = \"snd(c)\"  \n  from A1 have T: \n    \"?a\\<^sub>r \\<in> R\"  \"?a\\<^sub>i \\<in> R\"  \"?b\\<^sub>r \\<in> R\"  \"?b\\<^sub>i \\<in> R\"  \"?c\\<^sub>r \\<in> R\"  \"?c\\<^sub>i \\<in> R\"\n    \"?a\\<^sub>r\\<ra>?b\\<^sub>r \\<in> R\"  \"?a\\<^sub>i\\<ra>?b\\<^sub>i \\<in> R\"  \n    \"?b\\<^sub>r\\<ra>?c\\<^sub>r \\<in> R\"  \"?b\\<^sub>i\\<ra>?c\\<^sub>i \\<in> R\"\n    using valid_cntxts ring0.Ring_ZF_1_L4 by auto\n  with A1 have \"a \\<ca> b \\<ca> c = \\<langle>?a\\<^sub>r\\<ra>?b\\<^sub>r\\<ra>?c\\<^sub>r,?a\\<^sub>i\\<ra>?b\\<^sub>i\\<ra>?c\\<^sub>i\\<rangle>\"\n    using cplx_mul_add_vals by auto\n  also from A1 T have \"\\<dots> = a \\<ca> (b \\<ca> c)\"\n    using valid_cntxts ring0.Ring_ZF_1_L11 cplx_mul_add_vals\n    by auto\n  finally show \"a \\<ca> b \\<ca> c = a \\<ca> (b \\<ca> c)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 64
    },
    "59": {
        "type": "lemma",
        "text": "text\\<open>Complex multiplication is associative.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"  \"c \\<in> \\<complex>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_2_L6"
        ],
        "statement": "lemma (in complex0) axmulass: assumes A1: \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"  \"c \\<in> \\<complex>\"\n  shows \"a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?a\\<^sub>i = \"snd(a)\"\n  let ?b\\<^sub>r = \"fst(b)\"\n  let ?b\\<^sub>i = \"snd(b)\"\n  let ?c\\<^sub>r = \"fst(c)\"\n  let ?c\\<^sub>i = \"snd(c)\"\n  from A1 have T:\n    \"?a\\<^sub>r \\<in> R\"  \"?a\\<^sub>i \\<in> R\"  \"?b\\<^sub>r \\<in> R\"  \"?b\\<^sub>i \\<in> R\"  \"?c\\<^sub>r \\<in> R\"  \"?c\\<^sub>i \\<in> R\"\n    \"?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i) \\<in> R\"  \n    \"?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r \\<in> R\"\n    \"?b\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?b\\<^sub>i\\<rmu>?c\\<^sub>i) \\<in> R\"\n    \"?b\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?b\\<^sub>i\\<rmu>?c\\<^sub>r \\<in> R\" \n    using valid_cntxts ring0.Ring_ZF_1_L4  by auto\n  with A1 have \"a \\<cdot> b \\<cdot> c = \n    \\<langle>(?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i))\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>(?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r)\\<rmu>?c\\<^sub>i),\n    (?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i))\\<rmu>?c\\<^sub>i \\<ra> (?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r)\\<rmu>?c\\<^sub>r\\<rangle>\"\n    using cplx_mul_add_vals by auto\n  moreover from A1 T have \n    \"\\<langle>?a\\<^sub>r\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?b\\<^sub>i\\<rmu>?c\\<^sub>i)) \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?b\\<^sub>i\\<rmu>?c\\<^sub>r)),\n    ?a\\<^sub>r\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?b\\<^sub>i\\<rmu>?c\\<^sub>r) \\<ra> ?a\\<^sub>i\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?b\\<^sub>i\\<rmu>?c\\<^sub>i))\\<rangle> = \n    a \\<cdot> (b \\<cdot> c)\"\n    using cplx_mul_add_vals by auto\n  moreover from T have\n    \"?a\\<^sub>r\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?b\\<^sub>i\\<rmu>?c\\<^sub>i)) \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?b\\<^sub>i\\<rmu>?c\\<^sub>r)) =\n    (?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i))\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>(?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r)\\<rmu>?c\\<^sub>i)\"\n    and\n    \"?a\\<^sub>r\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>i \\<ra> ?b\\<^sub>i\\<rmu>?c\\<^sub>r) \\<ra> ?a\\<^sub>i\\<rmu>(?b\\<^sub>r\\<rmu>?c\\<^sub>r \\<ra> (\\<rm>?b\\<^sub>i\\<rmu>?c\\<^sub>i)) =\n    (?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<ra> (\\<rm>?a\\<^sub>i\\<rmu>?b\\<^sub>i))\\<rmu>?c\\<^sub>i \\<ra> (?a\\<^sub>r\\<rmu>?b\\<^sub>i \\<ra> ?a\\<^sub>i\\<rmu>?b\\<^sub>r)\\<rmu>?c\\<^sub>r\"\n    using valid_cntxts ring0.Ring_ZF_2_L6 by auto\n  ultimately show \"a \\<cdot> b \\<cdot> c = a \\<cdot> (b \\<cdot> c)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 65
    },
    "60": {
        "type": "lemma",
        "text": "text\\<open>Complex $1$ is real. This really means that the pair \n  $\\langle 1,0 \\rangle$ is on the real axis.\\<close>\n",
        "assumes": "",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2"
        ],
        "statement": "lemma (in complex0) ax1re: shows \"\\<one> \\<in> \\<real>\"\n  ",
        "proof": "using valid_cntxts ring0.Ring_ZF_1_L2 by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 66
    },
    "61": {
        "type": "lemma",
        "text": "text\\<open>The imaginary unit is a \"square root\" of $-1$ (that is, $i^2 +1 =0$). \n\\<close>\n",
        "assumes": "",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2",
            "ring0.Ring_ZF_1_L3",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_1_L6",
            "group0.group0_2_L6"
        ],
        "statement": "lemma (in complex0) axi2m1: shows \"\\<i>\\<cdot>\\<i> \\<ca> \\<one> = \\<zero>\"\n  ",
        "proof": "using valid_cntxts ring0.Ring_ZF_1_L2 ring0.Ring_ZF_1_L3\n  cplx_mul_add_vals ring0.Ring_ZF_1_L6 group0.group0_2_L6 \n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 67
    },
    "62": {
        "type": "lemma",
        "text": "text\\<open>$0$ is the neutral element of complex addition.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<complex>\"\n  ",
        "using": [
            "assms",
            "cplx_mul_add_vals",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2",
            "ring0.Ring_ZF_1_L3"
        ],
        "statement": "lemma (in complex0) ax0id: assumes \"a \\<in> \\<complex>\"\n  shows \"a \\<ca> \\<zero> = a\"\n  ",
        "proof": "using assms cplx_mul_add_vals valid_cntxts \n    ring0.Ring_ZF_1_L2 ring0.Ring_ZF_1_L3\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 68
    },
    "63": {
        "type": "lemma",
        "text": "text\\<open>The imaginary unit is a complex number.\\<close>\n",
        "assumes": "",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2"
        ],
        "statement": "lemma (in complex0) axicn: shows \"\\<i> \\<in> \\<complex>\"\n  ",
        "proof": "using valid_cntxts ring0.Ring_ZF_1_L2 by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 69
    },
    "64": {
        "type": "lemma",
        "text": "text\\<open>All complex numbers have additive inverses.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L3",
            "cplx_mul_add_vals"
        ],
        "statement": "lemma (in complex0) axnegex: assumes A1: \"a \\<in> \\<complex>\"\n  shows \"\\<exists>x\\<in>\\<complex>. a \\<ca> x  = \\<zero>\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?a\\<^sub>i = \"snd(a)\"\n  let ?x = \"\\<langle>\\<rm>?a\\<^sub>r, \\<rm>?a\\<^sub>i\\<rangle>\"\n  from A1 have T: \n    \"?a\\<^sub>r \\<in> R\"   \"?a\\<^sub>i \\<in> R\"   \"(\\<rm>?a\\<^sub>r) \\<in> R\"   \"(\\<rm>?a\\<^sub>r) \\<in> R\"\n    using valid_cntxts ring0.Ring_ZF_1_L3 by auto\n  then have \"?x \\<in> \\<complex>\" using valid_cntxts ring0.Ring_ZF_1_L3\n    by auto\n  moreover from A1 T have \"a \\<ca> ?x = \\<zero>\"\n    using cplx_mul_add_vals valid_cntxts ring0.Ring_ZF_1_L3\n    by auto\n  ultimately show \"\\<exists>x\\<in>\\<complex>. a \\<ca> x  = \\<zero>\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 70
    },
    "65": {
        "type": "lemma",
        "text": "text\\<open>A non-zero complex number has a multiplicative inverse.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\" and A2: \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "valid_cntxts",
            "field1.OrdField_ZF_1_L10",
            "ring0.Ring_ZF_1_L4",
            "ring0.Ring_ZF_1_L3",
            "cplx_mul_add_vals",
            "ring0.ring_rearr_3_elemA"
        ],
        "statement": "lemma (in complex0) axrecex: assumes A1: \"a \\<in> \\<complex>\" and A2: \"a\\<noteq>\\<zero>\"\n  shows \"\\<exists>x\\<in>\\<complex>. a\\<cdot>x = \\<one>\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?a\\<^sub>i = \"snd(a)\"\n  let ?m = \"?a\\<^sub>r\\<rmu>?a\\<^sub>r \\<ra> ?a\\<^sub>i\\<rmu>?a\\<^sub>i\"\n  from A1 have T1: \"?a\\<^sub>r \\<in> R\"   \"?a\\<^sub>i \\<in> R\" by auto\n  moreover from A1 A2 have \"?a\\<^sub>r \\<noteq> \\<zero>\\<^sub>R \\<or> ?a\\<^sub>i \\<noteq> \\<zero>\\<^sub>R\" \n    by auto\n  ultimately have \"\\<exists>c\\<in>R. ?m\\<rmu>c = \\<one>\\<^sub>R\"\n    using valid_cntxts field1.OrdField_ZF_1_L10\n    by auto\n  then obtain c where I: \"c\\<in>R\" and II: \"?m\\<rmu>c = \\<one>\\<^sub>R\"\n    by auto\n  let ?x = \"\\<langle>?a\\<^sub>r\\<rmu>c, \\<rm>?a\\<^sub>i\\<rmu>c\\<rangle>\"\n  from T1 I have T2: \"?a\\<^sub>r\\<rmu>c \\<in> R\"  \"(\\<rm>?a\\<^sub>i\\<rmu>c) \\<in> R\"\n    using valid_cntxts ring0.Ring_ZF_1_L4 ring0.Ring_ZF_1_L3\n    by auto\n  then have \"?x \\<in> \\<complex>\" by auto\n  moreover from A1 T1 T2 I II have \"a\\<cdot>?x = \\<one>\"\n    using cplx_mul_add_vals valid_cntxts ring0.ring_rearr_3_elemA\n    by auto\n  ultimately show \"\\<exists>x\\<in>\\<complex>. a\\<cdot>x = \\<one>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 71
    },
    "66": {
        "type": "lemma",
        "text": "text\\<open>Complex $1$ is a right neutral element for multiplication.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<complex>\"\n  ",
        "using": [
            "assms",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_1_L3",
            "ring0.Ring_ZF_1_L6"
        ],
        "statement": "lemma (in complex0) ax1id: assumes A1: \"a \\<in> \\<complex>\"\n  shows \"a\\<cdot>\\<one> = a\"\n  ",
        "proof": "using assms valid_cntxts ring0.Ring_ZF_1_L2 cplx_mul_add_vals\n    ring0.Ring_ZF_1_L3 ring0.Ring_ZF_1_L6 by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 72
    },
    "67": {
        "type": "lemma",
        "text": "text\\<open>A formula for sum of (complex) real numbers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_1_L3"
        ],
        "statement": "lemma (in complex0) sum_of_reals: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  shows \n  \"a \\<ca> b = \\<langle>fst(a) \\<ra> fst(b),\\<zero>\\<^sub>R\\<rangle>\"\n  ",
        "proof": "using assms valid_cntxts ring0.Ring_ZF_1_L2 cplx_mul_add_vals\n    ring0.Ring_ZF_1_L3 by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 73
    },
    "68": {
        "type": "lemma",
        "text": "text\\<open>The sum of real numbers is real.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "sum_of_reals",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4"
        ],
        "statement": "lemma (in complex0) axaddrcl: assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  shows \"a \\<ca> b \\<in> \\<real>\" \n  ",
        "proof": "using assms sum_of_reals valid_cntxts ring0.Ring_ZF_1_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 74
    },
    "69": {
        "type": "lemma",
        "text": "text\\<open>The formula for the product of (complex) real numbers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L2",
            "ring0.Ring_ZF_1_L4",
            "cplx_mul_add_vals",
            "ring0.Ring_ZF_1_L6",
            "ring0.Ring_ZF_1_L3"
        ],
        "statement": "lemma (in complex0) prod_of_reals: assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  shows \"a \\<cdot> b = \\<langle>fst(a)\\<rmu>fst(b),\\<zero>\\<^sub>R\\<rangle>\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?b\\<^sub>r = \"fst(b)\"\n  from A1 have T: \n    \"?a\\<^sub>r \\<in> R\" \"?b\\<^sub>r \\<in> R\"  \"\\<zero>\\<^sub>R \\<in> R\"  \"?a\\<^sub>r\\<rmu>?b\\<^sub>r \\<in> R\"\n    using valid_cntxts ring0.Ring_ZF_1_L2 ring0.Ring_ZF_1_L4 \n    by auto\n  with A1 show \"a \\<cdot> b = \\<langle>?a\\<^sub>r\\<rmu>?b\\<^sub>r,\\<zero>\\<^sub>R\\<rangle>\"\n    using cplx_mul_add_vals valid_cntxts ring0.Ring_ZF_1_L2 \n      ring0.Ring_ZF_1_L6 ring0.Ring_ZF_1_L3 by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 75
    },
    "70": {
        "type": "lemma",
        "text": "text\\<open>The product of (complex) real numbers is real.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "prod_of_reals",
            "valid_cntxts",
            "ring0.Ring_ZF_1_L4"
        ],
        "statement": "lemma (in complex0) axmulrcl: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  shows \"a \\<cdot> b \\<in> \\<real>\"\n  ",
        "proof": "using assms prod_of_reals valid_cntxts ring0.Ring_ZF_1_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 76
    },
    "71": {
        "type": "lemma",
        "text": "text\\<open>The existence of a real negative of a real number.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "valid_cntxts",
            "ring0.Ring_ZF_1_L3",
            "ring0.Ring_ZF_1_L2",
            "cplx_mul_add_vals"
        ],
        "statement": "lemma (in complex0) axrnegex: assumes A1: \"a\\<in>\\<real>\"\n  shows \"\\<exists> x \\<in> \\<real>. a \\<ca> x = \\<zero>\"\n",
        "proof": "proof -\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?x = \"\\<langle>\\<rm>?a\\<^sub>r,\\<zero>\\<^sub>R\\<rangle>\"\n  from A1 have T: \n    \"?a\\<^sub>r \\<in> R\"  \"(\\<rm>?a\\<^sub>r) \\<in> R\"  \"\\<zero>\\<^sub>R \\<in> R\" \n    using valid_cntxts ring0.Ring_ZF_1_L3 ring0.Ring_ZF_1_L2 \n    by auto\n  then have \"?x\\<in> \\<real>\" by auto\n  moreover from A1 T have \"a \\<ca> ?x = \\<zero>\"\n    using cplx_mul_add_vals valid_cntxts ring0.Ring_ZF_1_L3\n    by auto\n  ultimately show \"\\<exists>x\\<in>\\<real>. a \\<ca> x = \\<zero>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 77
    },
    "72": {
        "type": "lemma",
        "text": "text\\<open>Each nonzero real number has a real inverse\\<close>\n",
        "assumes": "assumes A1:  \"a \\<in> \\<real>\"   \"a \\<noteq> \\<zero>\"\n  ",
        "using": [
            "valid_cntxts",
            "field0.Field_ZF_1_L5",
            "prod_of_reals",
            "field0.Field_ZF_1_L6"
        ],
        "statement": "lemma (in complex0) axrrecex: \n  assumes A1:  \"a \\<in> \\<real>\"   \"a \\<noteq> \\<zero>\"\n  shows \"\\<exists>x\\<in>\\<real>. a \\<cdot> x = \\<one>\"\n",
        "proof": "proof -\n  let ?R\\<^sub>0 = \"R-{\\<zero>\\<^sub>R}\"\n  let ?a\\<^sub>r = \"fst(a)\"\n  let ?y = \"GroupInv(?R\\<^sub>0,restrict(M,?R\\<^sub>0\\<times>?R\\<^sub>0))`(?a\\<^sub>r)\"\n  from A1 have T: \"\\<langle>?y,\\<zero>\\<^sub>R\\<rangle> \\<in> \\<real>\" using valid_cntxts field0.Field_ZF_1_L5\n    by auto\n  moreover from A1 T have \"a \\<cdot> \\<langle>?y,\\<zero>\\<^sub>R\\<rangle> = \\<one>\"\n    using prod_of_reals valid_cntxts\n    field0.Field_ZF_1_L5 field0.Field_ZF_1_L6 by auto\n  ultimately show \"\\<exists> x \\<in> \\<real>. a \\<cdot> x = \\<one>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 78
    },
    "73": {
        "type": "lemma",
        "text": "text\\<open>The \\<open>CplxROrder\\<close> thing is a relation on the complex reals.\n\\<close>\n",
        "assumes": "",
        "using": [
            "ComplexReals_def",
            "slice_proj_bij",
            "real_means_real_axis",
            "CplxROrder_def",
            "InducedRelation_def"
        ],
        "statement": "lemma (in complex0) cplx_ord_on_cplx_reals:\n  shows \"CplxROrder(R,A,r) \\<subseteq> \\<real>\\<times>\\<real>\"\n  ",
        "proof": "using ComplexReals_def slice_proj_bij real_means_real_axis\n    CplxROrder_def InducedRelation_def by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 80
    },
    "74": {
        "type": "lemma",
        "text": "text\\<open>The strict version of the complex relation is a \n  relation on complex reals.\\<close>\n",
        "assumes": "",
        "using": [
            "cplx_ord_on_cplx_reals",
            "strict_ver_rel"
        ],
        "statement": "lemma (in complex0) cplx_strict_ord_on_cplx_reals:\n  shows \"StrictVersion(CplxROrder(R,A,r)) \\<subseteq> \\<real>\\<times>\\<real>\"\n  ",
        "proof": "using cplx_ord_on_cplx_reals strict_ver_rel by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 81
    },
    "75": {
        "type": "lemma",
        "text": "text\\<open>The \\<open>CplxROrder\\<close> thing is a relation on the complex reals.\n  Here this is formulated as a statement that in \\<open>complex0\\<close> context\n  $a<b$ implies that $a,b$ are complex reals\\<close>\n",
        "assumes": "assumes \"a \\<lsr> b\"\n  ",
        "using": [
            "assms",
            "CplxROrder_def",
            "def_of_strict_ver",
            "InducedRelation_def",
            "slice_proj_bij",
            "ComplexReals_def",
            "real_means_real_axis"
        ],
        "statement": "lemma (in complex0) strict_cplx_ord_type: assumes \"a \\<lsr> b\"\n  shows \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "proof": "using assms CplxROrder_def def_of_strict_ver InducedRelation_def \n    slice_proj_bij ComplexReals_def real_means_real_axis \n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 82
    },
    "76": {
        "type": "lemma",
        "text": "text\\<open>A more readable version of the definition of the strict order\n  relation on the real axis. Recall that in the \\<open>complex0\\<close>\n  context $r$ denotes the (non-strict) order relation on the underlying\n  model of real numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "CplxROrder_def",
            "def_of_strict_ver",
            "def_of_ind_relA",
            "strict_cplx_ord_type",
            "slice_proj_bij",
            "ComplexReals_def",
            "real_means_real_axis",
            "valid_cntxts",
            "ring1.OrdRing_ZF_1_L3",
            "def_of_ind_relB"
        ],
        "statement": "lemma (in complex0) def_of_real_axis_order: shows \n  \"\\<langle>x,\\<zero>\\<^sub>R\\<rangle> \\<lsr> \\<langle>y,\\<zero>\\<^sub>R\\<rangle> \\<longleftrightarrow> \\<langle>x,y\\<rangle> \\<in> r \\<and> x\\<noteq>y\"\n",
        "proof": "proof\n  let ?f = \"SliceProjection(ComplexReals(R,A))\"\n  assume A1: \"\\<langle>x,\\<zero>\\<^sub>R\\<rangle> \\<lsr> \\<langle>y,\\<zero>\\<^sub>R\\<rangle>\"\n  then have \"\\<langle> ?f`\\<langle>x,\\<zero>\\<^sub>R\\<rangle>, ?f`\\<langle>y,\\<zero>\\<^sub>R\\<rangle> \\<rangle> \\<in> r \\<and> x \\<noteq> y\"\n    using CplxROrder_def def_of_strict_ver def_of_ind_relA\n    by simp\n  moreover from A1 have \"\\<langle>x,\\<zero>\\<^sub>R\\<rangle> \\<in> \\<real>\"  \"\\<langle>y,\\<zero>\\<^sub>R\\<rangle> \\<in> \\<real>\"\n    using strict_cplx_ord_type by auto\n  ultimately show \"\\<langle>x,y\\<rangle> \\<in> r \\<and> x\\<noteq>y\"\n    using slice_proj_bij ComplexReals_def by simp\nnext assume A1: \"\\<langle>x,y\\<rangle> \\<in> r \\<and> x\\<noteq>y\"\n  let ?f = \"SliceProjection(ComplexReals(R,A))\"\n  have \"?f : \\<real> \\<rightarrow> R\"\n    using ComplexReals_def slice_proj_bij real_means_real_axis\n    by simp\n  moreover from A1 have T: \"\\<langle>x,\\<zero>\\<^sub>R\\<rangle> \\<in> \\<real>\"   \"\\<langle>y,\\<zero>\\<^sub>R\\<rangle> \\<in> \\<real>\"\n    using valid_cntxts ring1.OrdRing_ZF_1_L3 by auto\n  moreover from A1 T have \"\\<langle> ?f`\\<langle>x,\\<zero>\\<^sub>R\\<rangle>, ?f`\\<langle>y,\\<zero>\\<^sub>R\\<rangle> \\<rangle> \\<in> r\"\n    using slice_proj_bij ComplexReals_def by simp\n  ultimately have \"\\<langle> \\<langle>x,\\<zero>\\<^sub>R\\<rangle>, \\<langle>y,\\<zero>\\<^sub>R\\<rangle> \\<rangle> \\<in> InducedRelation(?f,r)\"\n    using def_of_ind_relB by simp\n  with A1 show \"\\<langle>x,\\<zero>\\<^sub>R\\<rangle> \\<lsr> \\<langle>y,\\<zero>\\<^sub>R\\<rangle>\"\n    using CplxROrder_def def_of_strict_ver\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 83
    },
    "77": {
        "type": "lemma",
        "text": "text\\<open>The (non strict) order on complex reals is antisymmetric,\n  transitive and total.\\<close>\n",
        "assumes": "",
        "using": [
            "ComplexReals_def",
            "slice_proj_bij",
            "real_means_real_axis",
            "bij_is_ord_iso",
            "CplxROrder_def",
            "cplx_ord_on_cplx_reals",
            "valid_cntxts",
            "ring1.OrdRing_ZF_1_L1",
            "IsAnOrdRing_def",
            "IsLinOrder_def",
            "ord_iso_pres_antsym",
            "ord_iso_pres_tot",
            "ord_iso_pres_trans"
        ],
        "statement": "lemma (in complex0) cplx_ord_antsym_trans_tot: shows\n  \"antisym(CplxROrder(R,A,r))\"\n  \"trans(CplxROrder(R,A,r))\"\n  \"CplxROrder(R,A,r) {is total on} \\<real>\"\n",
        "proof": "proof -\n  let ?f = \"SliceProjection(ComplexReals(R,A))\"\n  have \"?f \\<in> ord_iso(\\<real>,CplxROrder(R,A,r),R,r)\"\n    using ComplexReals_def slice_proj_bij real_means_real_axis \n      bij_is_ord_iso CplxROrder_def by simp\n  moreover have \"CplxROrder(R,A,r) \\<subseteq> \\<real>\\<times>\\<real>\"\n    using cplx_ord_on_cplx_reals by simp\n  moreover have I:\n    \"antisym(r)\"   \"r {is total on} R\"   \"trans(r)\"\n    using valid_cntxts ring1.OrdRing_ZF_1_L1 IsAnOrdRing_def \n      IsLinOrder_def by auto\n  ultimately show \n    \"antisym(CplxROrder(R,A,r))\"\n    \"trans(CplxROrder(R,A,r))\"\n    \"CplxROrder(R,A,r) {is total on} \\<real>\"\n    using ord_iso_pres_antsym ord_iso_pres_tot ord_iso_pres_trans\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 84
    },
    "78": {
        "type": "lemma",
        "text": "text\\<open>The trichotomy law for the strict order on the complex \n  reals.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<real>\"  \"b \\<in> \\<real>\"\n  ",
        "using": [
            "assms",
            "cplx_ord_antsym_trans_tot",
            "strict_ans_tot_trich"
        ],
        "statement": "lemma (in complex0) cplx_strict_ord_trich: \n  assumes \"a \\<in> \\<real>\"  \"b \\<in> \\<real>\"\n  shows \"Exactly_1_of_3_holds(a\\<lsr>b, a=b, b\\<lsr>a)\"\n  ",
        "proof": "using assms cplx_ord_antsym_trans_tot strict_ans_tot_trich\n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 85
    },
    "79": {
        "type": "lemma",
        "text": "text\\<open>The strict order on the complex reals is kind of \n  antisymetric.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<real>\"   \"b \\<in> \\<real>\"\n  ",
        "using": [],
        "statement": "lemma (in complex0) pre_axlttri: assumes A1: \"a \\<in> \\<real>\"   \"b \\<in> \\<real>\"\n  shows \"a \\<lsr> b \\<longleftrightarrow> \\<not>(a=b \\<or> b \\<lsr> a)\"\n",
        "proof": "proof -\n  from A1 have \"Exactly_1_of_3_holds(a\\<lsr>b, a=b, b\\<lsr>a)\"\n    by (rule cplx_strict_ord_trich)\n  then show \"a \\<lsr> b \\<longleftrightarrow> \\<not>(a=b \\<or> b \\<lsr> a)\"\n    by (rule Fol1_L8A)\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 86
    },
    "80": {
        "type": "lemma",
        "text": "text\\<open>The strict order on complex reals is transitive.\\<close>\n",
        "assumes": "",
        "using": [
            "cplx_ord_antsym_trans_tot",
            "strict_of_transB"
        ],
        "statement": "lemma (in complex0) cplx_strict_ord_trans: \n  shows \"trans(StrictVersion(CplxROrder(R,A,r)))\"\n  ",
        "proof": "using cplx_ord_antsym_trans_tot strict_of_transB by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 87
    },
    "81": {
        "type": "lemma",
        "text": "text\\<open>The strict order on complex reals is transitive - the explicit version\n  of \\<open>cplx_strict_ord_trans\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"a \\<lsr> b\"   \"b \\<lsr> c\"\n  ",
        "using": [
            "cplx_strict_ord_trans"
        ],
        "statement": "lemma (in complex0) pre_axlttrn: \n  assumes A1: \"a \\<lsr> b\"   \"b \\<lsr> c\"\n  shows \"a \\<lsr> c\"\n",
        "proof": "proof -\n  let ?s = \"StrictVersion(CplxROrder(R,A,r))\"\n  from A1 have \n    \"trans(?s)\"   \"\\<langle>a,b\\<rangle> \\<in> ?s \\<and> \\<langle>b,c\\<rangle> \\<in> ?s\"\n    using cplx_strict_ord_trans by auto\n  then have \"\\<langle>a,c\\<rangle> \\<in> ?s\" by (rule Fol1_L3)\n  then show \"a \\<lsr> c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 88
    },
    "82": {
        "type": "lemma",
        "text": "text\\<open>The strict order on complex reals is preserved by translations.\\<close>\n",
        "assumes": "assumes A1: \"a \\<lsr> b\" and A2: \"c \\<in> \\<real>\"\n  ",
        "using": [
            "strict_cplx_ord_type",
            "def_of_real_axis_order",
            "valid_cntxts",
            "group3.group_strict_ord_transl_inv",
            "sum_of_reals"
        ],
        "statement": "lemma (in complex0) pre_axltadd: \n  assumes A1: \"a \\<lsr> b\" and A2: \"c \\<in> \\<real>\"\n  shows \"c\\<ca>a \\<lsr> c\\<ca>b\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" using strict_cplx_ord_type\n    by auto\n  with A1 A2 show \"c\\<ca>a \\<lsr> c\\<ca>b\" \n    using def_of_real_axis_order valid_cntxts \n      group3.group_strict_ord_transl_inv sum_of_reals \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 89
    },
    "83": {
        "type": "lemma",
        "text": "text\\<open>The set of positive complex reals is closed with respect to \n  multiplication.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero> \\<lsr> a\"   \"\\<zero> \\<lsr> b\"\n  ",
        "using": [
            "strict_cplx_ord_type",
            "def_of_real_axis_order",
            "valid_cntxts",
            "field1.pos_mul_closed",
            "prod_of_reals"
        ],
        "statement": "lemma (in complex0) pre_axmulgt0: assumes A1: \"\\<zero> \\<lsr> a\"   \"\\<zero> \\<lsr> b\"\n  shows \"\\<zero> \\<lsr> a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" using strict_cplx_ord_type\n    by auto\n  with A1 show \"\\<zero> \\<lsr> a\\<cdot>b\"\n    using def_of_real_axis_order valid_cntxts field1.pos_mul_closed\n      def_of_real_axis_order prod_of_reals\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 90
    },
    "84": {
        "type": "lemma",
        "text": "text\\<open>The order on complex reals is linear and complete.\\<close>\n",
        "assumes": "",
        "using": [
            "slice_proj_bij",
            "ComplexReals_def",
            "real_means_real_axis",
            "valid_cntxts",
            "ring1.OrdRing_ZF_1_L1",
            "IsAnOrdRing_def",
            "IsAmodelOfReals_def",
            "CplxROrder_def",
            "ind_rel_pres_compl",
            "ind_rel_pres_lin"
        ],
        "statement": "lemma (in complex0) cmplx_reals_ord_lin_compl: shows\n  \"CplxROrder(R,A,r) {is complete}\"\n  \"IsLinOrder(\\<real>,CplxROrder(R,A,r))\"\n",
        "proof": "proof -\n  have \"SliceProjection(\\<real>) \\<in> bij(\\<real>,R)\"\n    using slice_proj_bij ComplexReals_def real_means_real_axis \n    by simp\n  moreover have \"r \\<subseteq> R\\<times>R\" using valid_cntxts ring1.OrdRing_ZF_1_L1\n    IsAnOrdRing_def by simp\n  moreover from R_are_reals have \n    \"r {is complete}\" and \"IsLinOrder(R,r)\"\n    using IsAmodelOfReals_def valid_cntxts ring1.OrdRing_ZF_1_L1\n    IsAnOrdRing_def by auto\n  ultimately show \n    \"CplxROrder(R,A,r) {is complete}\"\n    \"IsLinOrder(\\<real>,CplxROrder(R,A,r))\"\n    using CplxROrder_def real_means_real_axis ind_rel_pres_compl \n      ind_rel_pres_lin by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 91
    },
    "85": {
        "type": "lemma",
        "text": "text\\<open>The property of the strict order on complex reals\n  that corresponds to completeness.\\<close>\n",
        "assumes": "assumes A1: \"X \\<subseteq> \\<real>\"   \"X \\<noteq> 0\" and\n  A2: \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>X. y \\<lsr> x\"\n  ",
        "using": [
            "cplx_ord_on_cplx_reals",
            "cmplx_reals_ord_lin_compl"
        ],
        "statement": "lemma (in complex0) pre_axsup: assumes A1: \"X \\<subseteq> \\<real>\"   \"X \\<noteq> 0\" and\n  A2: \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>X. y \\<lsr> x\"\n  shows \n  \"\\<exists>x\\<in>\\<real>. (\\<forall>y\\<in>X. \\<not>(x \\<lsr> y)) \\<and> (\\<forall>y\\<in>\\<real>. (y \\<lsr> x \\<longrightarrow> (\\<exists>z\\<in>X. y \\<lsr> z)))\"\n",
        "proof": "proof -\n  let ?s = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \n    \"CplxROrder(R,A,r) \\<subseteq> \\<real>\\<times>\\<real>\"\n    \"IsLinOrder(\\<real>,CplxROrder(R,A,r))\"\n    \"CplxROrder(R,A,r) {is complete}\"\n    using cplx_ord_on_cplx_reals cmplx_reals_ord_lin_compl\n    by auto\n  moreover note A1\n  moreover have \"?s = StrictVersion(CplxROrder(R,A,r))\"\n    by simp\n  moreover from A2 have \"\\<exists>u\\<in>\\<real>. \\<forall>y\\<in>X. \\<langle>y,u\\<rangle> \\<in> ?s\"\n    by simp\n  ultimately have\n    \"\\<exists>x\\<in>\\<real>. ( \\<forall>y\\<in>X. \\<langle>x,y\\<rangle> \\<notin> ?s ) \\<and> \n    (\\<forall>y\\<in>\\<real>. \\<langle>y,x\\<rangle> \\<in> ?s \\<longrightarrow> (\\<exists>z\\<in>X. \\<langle>y,z\\<rangle> \\<in> ?s))\"\n    by (rule strict_of_compl)\n  then show \"(\\<exists>x\\<in>\\<real>. (\\<forall>y\\<in>X. \\<not>(x \\<lsr> y)) \\<and> \n    (\\<forall>y\\<in>\\<real>. (y \\<lsr> x \\<longrightarrow> (\\<exists>z\\<in>X. y \\<lsr> z))))\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 92
    },
    "86": {
        "type": "definition",
        "text": "text\\<open>Given $(G,\\cdot)$  and $(H,\\circ)$\n  a new operation $(G\\times H, \\times )$ is defined as\n  $(g, h) \\times (g', h') = (g \\cdot g', h \\circ h')$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"DirectProduct(P,Q,G,H) \\<equiv> \n  {\\<langle>x,\\<langle>P`\\<langle>fst(fst(x)),fst(snd(x))\\<rangle> , Q`\\<langle>snd(fst(x)),snd(snd(x))\\<rangle>\\<rangle>\\<rangle>.\n  x \\<in> (G\\<times>H)\\<times>(G\\<times>H)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/DirectProduct_ZF.thy",
        "id": 93
    },
    "87": {
        "type": "lemma",
        "text": "text\\<open>The direct product of binary operations is a binary operation.\\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_total",
            "DirectProduct_def"
        ],
        "statement": "lemma (in direct0) DirectProduct_ZF_1_L1:\n  shows \"R : (G\\<times>H)\\<times>(G\\<times>H)\\<rightarrow>G\\<times>H\"\n",
        "proof": "proof -\n  from Pfun Qfun have \"\\<forall>x\\<in>(G\\<times>H)\\<times>(G\\<times>H).\n    \\<langle>P`\\<langle>fst(fst(x)),fst(snd(x))\\<rangle>,Q`\\<langle>snd(fst(x)),snd(snd(x))\\<rangle>\\<rangle> \\<in> G\\<times>H\"\n    by auto\n  then show ?thesis using ZF_fun_from_total DirectProduct_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/DirectProduct_ZF.thy",
        "id": 94
    },
    "88": {
        "type": "lemma",
        "text": "text\\<open>And it has the intended value.\\<close>\n",
        "assumes": "",
        "using": [
            "DirectProduct_def",
            "DirectProduct_ZF_1_L1",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma (in direct0) DirectProduct_ZF_1_L2:\n  shows \"\\<forall>x\\<in>(G\\<times>H). \\<forall>y\\<in>(G\\<times>H). \n  R`\\<langle>x,y\\<rangle> = \\<langle>P`\\<langle>fst(x),fst(y)\\<rangle>,Q`\\<langle>snd(x),snd(y)\\<rangle>\\<rangle>\"\n  ",
        "proof": "using DirectProduct_def DirectProduct_ZF_1_L1 ZF_fun_from_tot_val \n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/DirectProduct_ZF.thy",
        "id": 95
    },
    "89": {
        "type": "lemma",
        "text": "text\\<open>And the value belongs to the set the operation is defined on.\\<close>\n",
        "assumes": "",
        "using": [
            "DirectProduct_ZF_1_L1"
        ],
        "statement": "lemma (in direct0) DirectProduct_ZF_1_L3:\n  shows \"\\<forall>x\\<in>(G\\<times>H). \\<forall>y\\<in>(G\\<times>H). R`\\<langle>x,y\\<rangle> \\<in> G\\<times>H\"\n  ",
        "proof": "using DirectProduct_ZF_1_L1 by simp\n",
        "imports": [
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/DirectProduct_ZF.thy",
        "id": 96
    },
    "90": {
        "type": "lemma",
        "text": "text\\<open>Direct product of commutative operations is commutative.\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\" and \"Q {is commutative on} H\"\n  ",
        "using": [
            "DirectProduct_ZF_1_L2",
            "IsCommutative_def"
        ],
        "statement": "lemma (in direct0) DirectProduct_ZF_2_L1:\n  assumes \"P {is commutative on} G\" and \"Q {is commutative on} H\"\n  shows \"R {is commutative on} G\\<times>H\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>x\\<in>(G\\<times>H). \\<forall>y\\<in>(G\\<times>H). R`\\<langle>x,y\\<rangle> = R`\\<langle>y,x\\<rangle>\"\n    using DirectProduct_ZF_1_L2 IsCommutative_def by simp\n  then show ?thesis using IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/DirectProduct_ZF.thy",
        "id": 97
    },
    "91": {
        "type": "lemma",
        "text": "text\\<open>Direct product of associative operations is associative.\\<close>\n",
        "assumes": "assumes \"P {is associative on} G\" and \"Q {is associative on} H\"\n  ",
        "using": [
            "DirectProduct_ZF_1_L2",
            "DirectProduct_ZF_1_L3",
            "assms",
            "IsAssociative_def",
            "DirectProduct_ZF_1_L1"
        ],
        "statement": "lemma (in direct0) DirectProduct_ZF_2_L2:\n  assumes \"P {is associative on} G\" and \"Q {is associative on} H\"\n  shows \"R {is associative on} G\\<times>H\"\n",
        "proof": "proof -\n  have \"\\<forall>x\\<in>G\\<times>H. \\<forall>y\\<in>G\\<times>H. \\<forall>z\\<in>G\\<times>H. R`\\<langle>R`\\<langle>x,y\\<rangle>,z\\<rangle> =\n    \\<langle>P`\\<langle>P`\\<langle>fst(x),fst(y)\\<rangle>,fst(z)\\<rangle>,Q`\\<langle>Q`\\<langle>snd(x),snd(y)\\<rangle>,snd(z)\\<rangle>\\<rangle>\"\n    using DirectProduct_ZF_1_L2 DirectProduct_ZF_1_L3 \n    by auto\n  moreover have \"\\<forall>x\\<in>G\\<times>H. \\<forall>y\\<in>G\\<times>H. \\<forall>z\\<in>G\\<times>H. R`\\<langle>x,R`\\<langle>y,z\\<rangle>\\<rangle> =\n    \\<langle>P`\\<langle>fst(x),P`\\<langle>fst(y),fst(z)\\<rangle>\\<rangle>,Q`\\<langle>snd(x),Q`\\<langle>snd(y),snd(z)\\<rangle>\\<rangle>\\<rangle>\"\n    using DirectProduct_ZF_1_L2 DirectProduct_ZF_1_L3 by auto\n  ultimately have \"\\<forall>x\\<in>G\\<times>H. \\<forall>y\\<in>G\\<times>H. \\<forall>z\\<in>G\\<times>H. R`\\<langle>R`\\<langle>x,y\\<rangle>,z\\<rangle> = R`\\<langle>x,R`\\<langle>y,z\\<rangle>\\<rangle>\"\n    using assms IsAssociative_def by simp\n  then show ?thesis\n    using DirectProduct_ZF_1_L1 IsAssociative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/DirectProduct_ZF.thy",
        "id": 98
    },
    "92": {
        "type": "definition",
        "text": "text\\<open>We define enumeration as the only order isomorphism beween \n  a set $A$ and the number of its elements. We are using \n  the formula $\\bigcup \\{x\\} = x$ to extract the only element\n  from a singleton. \\<open>Le\\<close> is the (natural) order on natural \n  numbers, defined is \\<open>Nat_ZF\\<close> theory in the standard \n  Isabelle library.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Enumeration(A,r) \\<equiv> \\<Union> ord_iso(|A|,Le,A,r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 99
    },
    "93": {
        "type": "lemma",
        "text": "text\\<open>A special case of the existence and uniqueess \n  of the order isomorphism for finite sets\n  when the first set is a natural number.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" and \"n \\<in> nat\" and \"A \\<approx> n\"\n  ",
        "using": [
            "assms",
            "NatOrder_ZF_1_L2",
            "linord",
            "nat_finpow_nat",
            "fin_ord_iso_ex_uniq"
        ],
        "statement": "lemma (in enums) ord_iso_nat_fin:  \n  assumes \"A \\<in> FinPow(X)\" and \"n \\<in> nat\" and \"A \\<approx> n\"\n  shows \"\\<exists>!f. f \\<in> ord_iso(n,Le,A,r)\"\n  ",
        "proof": "using assms NatOrder_ZF_1_L2 linord nat_finpow_nat \n    fin_ord_iso_ex_uniq by simp\n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 100
    },
    "94": {
        "type": "lemma",
        "text": "text\\<open>An enumeration is an order isomorhism, a bijection, and a list.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\"\n  ",
        "using": [
            "NatOrder_ZF_1_L2",
            "card_fin_is_nat",
            "nat_finpow_nat",
            "linord",
            "fin_ord_iso_ex_uniq",
            "singleton_extract",
            "Enumeration_def",
            "ord_iso_def",
            "bij_def",
            "surj_def"
        ],
        "statement": "lemma (in enums) enum_props: assumes \"A \\<in> FinPow(X)\"\n  shows \n  \"\\<sigma>(A) \\<in> ord_iso(|A|,Le, A,r)\"\n  \"\\<sigma>(A) \\<in> bij(|A|,A)\"\n  \"\\<sigma>(A) : |A| \\<rightarrow> A\"\n",
        "proof": "proof -\n  from assms have\n    \"IsLinOrder(nat,Le)\" and \"|A| \\<in> FinPow(nat)\" and  \"A \\<approx> |A|\"\n    using NatOrder_ZF_1_L2 card_fin_is_nat nat_finpow_nat \n    by auto\n  with assms show \"\\<sigma>(A) \\<in> ord_iso(|A|,Le, A,r)\"\n    using linord fin_ord_iso_ex_uniq singleton_extract \n      Enumeration_def by simp\n  then show \"\\<sigma>(A) \\<in> bij(|A|,A)\" and \"\\<sigma>(A) : |A| \\<rightarrow> A\"\n    using ord_iso_def bij_def surj_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 101
    },
    "95": {
        "type": "lemma",
        "text": "text\\<open>A corollary from \\<open>enum_props\\<close>. Could have been attached as \n  another assertion, but this slows down verification of some other proofs.\n\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\"\n  ",
        "using": [
            "enum_props",
            "FinPow_def"
        ],
        "statement": "lemma (in enums) enum_fun: assumes \"A \\<in> FinPow(X)\"\n  shows \"\\<sigma>(A) : |A| \\<rightarrow> X\"\n",
        "proof": "proof -\n  from assms have \"\\<sigma>(A) : |A| \\<rightarrow> A\" and \"A\\<subseteq>X\"\n    using enum_props  FinPow_def by auto\n  then show \"\\<sigma>(A) : |A| \\<rightarrow> X\" by (rule func1_1_L1B)\nqed  \n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 102
    },
    "96": {
        "type": "lemma",
        "text": "text\\<open>What is the enumeration of the empty set?\\<close>\n",
        "assumes": "",
        "using": [
            "empty_in_finpow",
            "empty_ord_iso_empty",
            "ord_iso_enum"
        ],
        "statement": "lemma (in enums) empty_enum: shows \"\\<sigma>(0) = 0\"\n",
        "proof": "proof -\n  have \n    \"0 \\<in> FinPow(X)\" and \"0 \\<in> nat\" and \"0 \\<in> ord_iso(0,Le,0,r)\"\n    using empty_in_finpow empty_ord_iso_empty \n    by auto\n  then show \"\\<sigma>(0) = 0\" using ord_iso_enum \n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 104
    },
    "97": {
        "type": "lemma",
        "text": "text\\<open>Adding a new maximum to a set appends it to the enumeration.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" and A2: \"b \\<in> X-A\" and \n  A3: \"\\<forall>a\\<in>A. a\\<lsq>b\"\n  ",
        "using": [
            "card_fin_is_nat",
            "singleton_in_finpow",
            "union_finpow",
            "enum_props",
            "mem_not_refl",
            "elem_nat_is_nat",
            "linord",
            "NatOrder_ZF_1_L2",
            "IsLinOrder_def",
            "total_is_refl",
            "refl_def",
            "card_fin_add_one",
            "ord_iso_enum",
            "Append_def",
            "func1_1_L1"
        ],
        "statement": "lemma (in enums) enum_append: \n  assumes A1: \"A \\<in> FinPow(X)\" and A2: \"b \\<in> X-A\" and \n  A3: \"\\<forall>a\\<in>A. a\\<lsq>b\"\n  shows \" \\<sigma>(A \\<union> {b}) = \\<sigma>(A)\\<hookleftarrow> b\"\n",
        "proof": "proof -\n  let ?f = \"\\<sigma>(A) \\<union> {\\<langle>|A|,b\\<rangle>}\"\n  from A1 have \"|A| \\<in> nat\" using card_fin_is_nat\n    by simp\n  from A1 A2 have \"A \\<union> {b} \\<in> FinPow(X)\"\n    using singleton_in_finpow union_finpow by simp\n  moreover from this have \"|A \\<union> {b}| \\<in> nat\" \n    using card_fin_is_nat by simp\n  moreover have \"?f \\<in> ord_iso(|A \\<union> {b}| , Le, A \\<union> {b} ,r)\"\n  proof -\n    from A1 A2 have \n      \"\\<sigma>(A) \\<in> ord_iso(|A|,Le, A,r)\" and \n      \"|A| \\<notin> |A|\" and \"b \\<notin> A\"\n      using enum_props  mem_not_refl by auto\n    moreover from \\<open>|A| \\<in> nat\\<close> have \n      \"\\<forall>k \\<in> |A|. \\<langle>k, |A|\\<rangle> \\<in> Le\" \n      using elem_nat_is_nat by blast\n    moreover from A3 have \"\\<forall>a\\<in>A. \\<langle>a,b\\<rangle> \\<in> r\" by simp\n    moreover have \"antisym(Le)\" and \"antisym(r)\"\n      using linord NatOrder_ZF_1_L2 IsLinOrder_def by auto\n    moreover\n    from  A2 \\<open>|A| \\<in> nat\\<close> have\n      \"\\<langle>|A|,|A|\\<rangle> \\<in> Le\" and  \"\\<langle>b,b\\<rangle> \\<in> r\"\n      using linord NatOrder_ZF_1_L2 IsLinOrder_def \n\ttotal_is_refl refl_def by auto\n    hence \"\\<langle>|A|,|A|\\<rangle> \\<in> Le \\<longleftrightarrow> \\<langle>b,b\\<rangle> \\<in> r\" by simp\n    ultimately have \"?f \\<in> ord_iso(|A| \\<union> {|A|} , Le, A \\<union> {b} ,r)\"\n      by (rule ord_iso_extend)\n    with A1 A2 show \"?f \\<in> ord_iso(|A \\<union> {b}| , Le, A \\<union> {b} ,r)\"\n      using card_fin_add_one by simp\n  qed\n  ultimately have \"?f = \\<sigma>(A \\<union> {b})\"\n    using ord_iso_enum by simp\n  moreover have \"\\<sigma>(A)\\<hookleftarrow> b = ?f\"\n  proof -\n    have \"\\<sigma>(A)\\<hookleftarrow> b = \\<sigma>(A) \\<union> {\\<langle>domain(\\<sigma>(A)),b\\<rangle>}\"\n      using Append_def by simp\n    moreover from A1 have \"domain(\\<sigma>(A)) = |A|\"\n      using enum_props func1_1_L1 by blast\n    ultimately show \"\\<sigma>(A)\\<hookleftarrow> b = ?f\" by simp\n  qed\n  ultimately show \"\\<sigma>(A \\<union> {b}) = \\<sigma>(A)\\<hookleftarrow> b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 105
    },
    "98": {
        "type": "lemma",
        "text": "text\\<open>What is the enumeration of a singleton?\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>X\" ",
        "using": [
            "empty_in_finpow",
            "empty_enum",
            "empty_append1"
        ],
        "statement": "lemma (in enums) enum_singleton: \n  assumes A1: \"x\\<in>X\" shows \"\\<sigma>({x}): 1 \\<rightarrow> X\" and \"\\<sigma>({x})`(0) = x\"\n  ",
        "proof": "proof -\n    from A1 have \n      \"0 \\<in> FinPow(X)\" and \"x \\<in> (X - 0)\" and \"\\<forall>a\\<in>0. a\\<lsq>x\"\n      using empty_in_finpow by auto\n    then have \"\\<sigma>(0 \\<union> {x}) = \\<sigma>(0)\\<hookleftarrow> x\" by (rule enum_append)\n    with A1 show \"\\<sigma>({x}): 1 \\<rightarrow> X\" and \"\\<sigma>({x})`(0) = x\"\n      using empty_enum empty_append1 by auto\nqed\n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 106
    },
    "99": {
        "type": "definition",
        "text": "text\\<open>Now we will define the projection of\n  a function onto the quotient space. In standard math the equivalence class\n  of $x$ with respect to relation $r$ is usually denoted $[x]_r$. Here we reuse\n  notation $r\\{ x\\}$ instead. This means the image of the set $\\{ x\\}$ \n  with respect to the relation, which, for equivalence relations is \n  exactly its equivalence class if you think about it.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ProjFun(A,r,f) \\<equiv>\n  {\\<langle>c,\\<Union>x\\<in>c. r``{f`(x)}\\<rangle>. c \\<in> (A//r)}\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 108
    },
    "100": {
        "type": "lemma",
        "text": "text\\<open>Elements of equivalence classes belong to the set.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"C \\<in> A//r\" and A3: \"x\\<in>C\"\n  ",
        "using": [
            "Union_quotient"
        ],
        "statement": "lemma EquivClass_1_L1: \n  assumes A1: \"equiv(A,r)\" and A2: \"C \\<in> A//r\" and A3: \"x\\<in>C\"\n  shows \"x\\<in>A\"\n",
        "proof": "proof -\n  from A2 have \"C \\<subseteq> \\<Union> (A//r)\" by auto\n  with A1 A3 show \"x\\<in>A\"\n    using Union_quotient by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 109
    },
    "101": {
        "type": "lemma",
        "text": "text\\<open>The image of a subset of $X$ under projection is a subset\n  of $A/r$.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\" ",
        "using": [
            "assms",
            "quotientI"
        ],
        "statement": "lemma EquivClass_1_L1A: \n  assumes \"A\\<subseteq>X\" shows \"{r``{x}. x\\<in>A} \\<subseteq> X//r\"\n  ",
        "proof": "using assms quotientI by auto\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 110
    },
    "102": {
        "type": "lemma",
        "text": "text\\<open>If an element belongs to an equivalence class, then its image\n  under relation is this equivalence class.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\"  \"C \\<in> A//r\" and A2: \"x\\<in>C\"\n  ",
        "using": [
            "EquivClass_1_L1",
            "equiv_class_self",
            "quotientI",
            "quotient_disj"
        ],
        "statement": "lemma EquivClass_1_L2: \n  assumes A1: \"equiv(A,r)\"  \"C \\<in> A//r\" and A2: \"x\\<in>C\"\n  shows \"r``{x} = C\"\n",
        "proof": "proof -\n  from A1 A2 have \"x \\<in> r``{x}\" \n    using EquivClass_1_L1  equiv_class_self by simp\n  with A2 have I: \"r``{x}\\<inter>C \\<noteq> 0\" by auto\n  from A1 A2 have \"r``{x} \\<in> A//r\"\n    using EquivClass_1_L1 quotientI by simp\n  with A1 I show ?thesis\n    using quotient_disj by blast\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 111
    },
    "103": {
        "type": "lemma",
        "text": "text\\<open>Elements that belong to the same equivalence class are equivalent.\\<close>\n",
        "assumes": "assumes \"equiv(A,r)\"  \"C \\<in> A//r\"  \"x\\<in>C\"  \"y\\<in>C\"\n  ",
        "using": [
            "assms",
            "EquivClass_1_L2",
            "EquivClass_1_L1",
            "equiv_class_eq_iff"
        ],
        "statement": "lemma EquivClass_1_L2A:\n  assumes \"equiv(A,r)\"  \"C \\<in> A//r\"  \"x\\<in>C\"  \"y\\<in>C\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> r\" \n  ",
        "proof": "using assms EquivClass_1_L2 EquivClass_1_L1 equiv_class_eq_iff\n  by simp\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 112
    },
    "104": {
        "type": "lemma",
        "text": "text\\<open>Elements that have the same image under an equivalence relation are equivalent.\n  This is the same as \\<open>eq_equiv_class\\<close> from standard Isabelle/ZF's \\<open>EquivClass\\<close> theory, \n  just copied here to be easier to find.\\<close>\n",
        "assumes": "assumes \"equiv(A,r)\" \"y\\<in>A\" \"r``{x} = r``{y}\"\n  ",
        "using": [
            "assms",
            "eq_equiv_class"
        ],
        "statement": "lemma same_image_equiv: \n  assumes \"equiv(A,r)\" \"y\\<in>A\" \"r``{x} = r``{y}\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> r\" ",
        "proof": "using assms eq_equiv_class by simp\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 113
    },
    "105": {
        "type": "lemma",
        "text": "text\\<open>Every $x$ is in the class of $y$, then they are equivalent.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"y\\<in>A\" and A3: \"x \\<in> r``{y}\"\n  ",
        "using": [
            "quotientI",
            "EquivClass_1_L1",
            "equiv_class_self",
            "equiv_class_nondisjoint"
        ],
        "statement": "lemma EquivClass_1_L2B: \n  assumes A1: \"equiv(A,r)\" and A2: \"y\\<in>A\" and A3: \"x \\<in> r``{y}\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A2 have  \"r``{y} \\<in> A//r\"\n    using quotientI by simp\n  with A1 A3 show ?thesis using\n    EquivClass_1_L1 equiv_class_self equiv_class_nondisjoint by blast\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 114
    },
    "106": {
        "type": "lemma",
        "text": "text\\<open>If a function is congruent then the equivalence classes of the values\n  that come from the arguments from the same class are the same.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent(r,f)\" \n  and A3: \"C \\<in> A//r\"  \"x\\<in>C\"  \"y\\<in>C\" \n  ",
        "using": [
            "EquivClass_1_L2A",
            "Congruent_def",
            "equiv_class_eq"
        ],
        "statement": "lemma EquivClass_1_L3: \n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent(r,f)\" \n  and A3: \"C \\<in> A//r\"  \"x\\<in>C\"  \"y\\<in>C\" \n  shows \"r``{f`(x)} = r``{f`(y)}\"\n",
        "proof": "proof -\n  from A1 A3 have \"\\<langle>x,y\\<rangle> \\<in> r\"\n    using EquivClass_1_L2A by simp\n  with A2 have  \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> r\"\n    using Congruent_def by simp\n  with A1 show ?thesis using equiv_class_eq by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 115
    },
    "107": {
        "type": "lemma",
        "text": "text\\<open>The values of congruent functions are in the space.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"C \\<in> A//r\"  \"x\\<in>C\"\n  and A3: \"Congruent(r,f)\"\n  ",
        "using": [
            "EquivClass_1_L1",
            "equiv_def",
            "refl_def",
            "Congruent_def",
            "equiv_type"
        ],
        "statement": "lemma EquivClass_1_L4:\n  assumes A1: \"equiv(A,r)\" and A2: \"C \\<in> A//r\"  \"x\\<in>C\"\n  and A3: \"Congruent(r,f)\"\n  shows \"f`(x) \\<in> A\"\n",
        "proof": "proof -\n  from A1 A2 have \"x\\<in>A\"\n    using EquivClass_1_L1 by simp\n  with A1 have \"\\<langle>x,x\\<rangle> \\<in> r\"\n    using equiv_def refl_def by simp\n  with A3 have  \"\\<langle>f`(x),f`(x)\\<rangle> \\<in> r\"\n    using Congruent_def by simp\n  with A1 show ?thesis using equiv_type by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 116
    },
    "108": {
        "type": "lemma",
        "text": "text\\<open>Equivalence classes are not empty.\\<close>\n",
        "assumes": "assumes A1: \"refl(A,r)\" and A2: \"C \\<in> A//r\"\n  ",
        "using": [
            "quotient_def",
            "refl_def"
        ],
        "statement": "lemma EquivClass_1_L5: \n  assumes A1: \"refl(A,r)\" and A2: \"C \\<in> A//r\"\n  shows \"C\\<noteq>0\"\n",
        "proof": "proof -\n  from A2 obtain x where I: \"C = r``{x}\" and \"x\\<in>A\"\n    using quotient_def by auto\n  from A1 \\<open>x\\<in>A\\<close> have \"x \\<in> r``{x}\" using refl_def by auto\n  with I show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 117
    },
    "109": {
        "type": "lemma",
        "text": "text\\<open>Congruent functions can be projected.\\<close>\n",
        "assumes": "assumes \"equiv(A,r)\"  \"Congruent(r,f)\"\n  ",
        "using": [
            "assms",
            "EquivClass_1_L6",
            "ProjFun_def",
            "ZF_fun_from_total"
        ],
        "statement": "lemma EquivClass_1_T0: \n  assumes \"equiv(A,r)\"  \"Congruent(r,f)\"\n  shows \"ProjFun(A,r,f) : A//r \\<rightarrow> A//r\"\n  ",
        "proof": "using assms EquivClass_1_L6 ProjFun_def ZF_fun_from_total\n  by simp\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 119
    },
    "110": {
        "type": "definition",
        "text": "text\\<open>We now define congruent functions of two variables (binary funtions). \n  The predicate \\<open>Congruent2\\<close> corresponds to \\<open>congruent2\\<close> \n  in Isabelle's standard \\<open>EquivClass\\<close> theory, \n  but uses ZF-functions rather than meta-functions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Congruent2(r,f) \\<equiv>\n  (\\<forall>x\\<^sub>1 x\\<^sub>2 y\\<^sub>1 y\\<^sub>2. \\<langle>x\\<^sub>1,x\\<^sub>2\\<rangle> \\<in> r \\<and> \\<langle>y\\<^sub>1,y\\<^sub>2\\<rangle> \\<in> r  \\<longrightarrow> \n  \\<langle>f`\\<langle>x\\<^sub>1,y\\<^sub>1\\<rangle>, f`\\<langle>x\\<^sub>2,y\\<^sub>2\\<rangle> \\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 120
    },
    "111": {
        "type": "definition",
        "text": "text\\<open>Next we define the notion of projecting a binary operation\n  to the quotient space. This is a very important concept that\n  allows to define quotient groups, among other things.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"ProjFun2(A,r,f) \\<equiv>\n  {\\<langle>p,\\<Union> z \\<in> fst(p)\\<times>snd(p). r``{f`(z)}\\<rangle>. p \\<in> (A//r)\\<times>(A//r) }\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 121
    },
    "112": {
        "type": "lemma",
        "text": "text\\<open>The following lemma is a two-variables equivalent \n  of \\<open>EquivClass_1_L3\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"C\\<^sub>1 \\<in> A//r\"  \"C\\<^sub>2 \\<in> A//r\" \n  and A4: \"z\\<^sub>1 \\<in> C\\<^sub>1\\<times>C\\<^sub>2\"  \"z\\<^sub>2 \\<in> C\\<^sub>1\\<times>C\\<^sub>2\"\n  ",
        "using": [
            "EquivClass_1_L2A",
            "Congruent2_def",
            "equiv_class_eq"
        ],
        "statement": "lemma EquivClass_1_L7: \n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"C\\<^sub>1 \\<in> A//r\"  \"C\\<^sub>2 \\<in> A//r\" \n  and A4: \"z\\<^sub>1 \\<in> C\\<^sub>1\\<times>C\\<^sub>2\"  \"z\\<^sub>2 \\<in> C\\<^sub>1\\<times>C\\<^sub>2\"\n  shows \"r``{f`(z\\<^sub>1)} = r``{f`(z\\<^sub>2)}\"\n",
        "proof": "proof -\n  from A4 obtain x\\<^sub>1 y\\<^sub>1 x\\<^sub>2 y\\<^sub>2 where \n    \"x\\<^sub>1\\<in>C\\<^sub>1\" and \"y\\<^sub>1\\<in>C\\<^sub>2\" and \"z\\<^sub>1 = \\<langle>x\\<^sub>1,y\\<^sub>1\\<rangle>\" and \n    \"x\\<^sub>2\\<in>C\\<^sub>1\" and \"y\\<^sub>2\\<in>C\\<^sub>2\" and \"z\\<^sub>2 = \\<langle>x\\<^sub>2,y\\<^sub>2\\<rangle>\" \n    by auto\n  with A1 A3 have \"\\<langle>x\\<^sub>1,x\\<^sub>2\\<rangle> \\<in> r\" and \"\\<langle>y\\<^sub>1,y\\<^sub>2\\<rangle> \\<in> r\"\n    using EquivClass_1_L2A by auto\n  with A2 have \"\\<langle>f`\\<langle>x\\<^sub>1,y\\<^sub>1\\<rangle>,f`\\<langle>x\\<^sub>2,y\\<^sub>2\\<rangle>\\<rangle> \\<in> r\"\n    using Congruent2_def by simp\n  with A1 \\<open>z\\<^sub>1 = \\<langle>x\\<^sub>1,y\\<^sub>1\\<rangle>\\<close> \\<open>z\\<^sub>2 = \\<langle>x\\<^sub>2,y\\<^sub>2\\<rangle>\\<close> show ?thesis \n    using equiv_class_eq by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 122
    },
    "113": {
        "type": "lemma",
        "text": "text\\<open>The values of congruent functions are in the space. Note that\n  although this lemma is intended to be used with functions, we don't\n  need to assume that $f$ is a function.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"x\\<in>A\"  \"y\\<in>A\"\n  and A3: \"Congruent2(r,f)\"\n  ",
        "using": [
            "equiv_class_self",
            "quotientI",
            "EquivClass_1_L8"
        ],
        "statement": "lemma EquivClass_1_L8A:\n  assumes A1: \"equiv(A,r)\" and A2: \"x\\<in>A\"  \"y\\<in>A\"\n  and A3: \"Congruent2(r,f)\"\n  shows \"f`\\<langle>x,y\\<rangle> \\<in> A\"\n",
        "proof": "proof -\n  from A1 A2 have \"r``{x} \\<in> A//r\" \"r``{y} \\<in> A//r\" \n    \"\\<langle>x,y\\<rangle> \\<in> r``{x}\\<times>r``{y}\"\n    using equiv_class_self quotientI by auto\n  with A1 A3 show ?thesis using EquivClass_1_L8 by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 124
    },
    "114": {
        "type": "lemma",
        "text": "text\\<open>The following lemma is a two-variables equivalent of \n  \\<open>EquivClass_1_L6\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\" \n  and A3: \"p \\<in> (A//r)\\<times>(A//r)\"\n  ",
        "using": [
            "EquivClass_1_L8",
            "equiv_def",
            "EquivClass_1_L5",
            "Sigma_empty_iff",
            "quotientI",
            "EquivClass_1_L7"
        ],
        "statement": "lemma EquivClass_1_L9:\n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\" \n  and A3: \"p \\<in> (A//r)\\<times>(A//r)\"\n  shows \"(\\<Union> z \\<in> fst(p)\\<times>snd(p). r``{f`(z)}) \\<in> A//r\"\n",
        "proof": "proof -\n  from A3 have \"fst(p) \\<in> A//r\" and \"snd(p) \\<in> A//r\"\n    by auto\n  with A1 A2 have \n    I: \"\\<forall>z \\<in> fst(p)\\<times>snd(p). f`(z) \\<in> A\"\n    using EquivClass_1_L8 by simp\n  from A3 A1 have \"fst(p)\\<times>snd(p) \\<noteq> 0\" \n    using equiv_def EquivClass_1_L5 Sigma_empty_iff\n    by auto\n  moreover from A1 I have \n    \"\\<forall>z \\<in> fst(p)\\<times>snd(p). r``{f`(z)} \\<in> A//r\"\n    using quotientI by simp\n  moreover from A1 A2 \\<open>fst(p) \\<in> A//r\\<close> \\<open>snd(p) \\<in> A//r\\<close> have\n    \"\\<forall>z\\<^sub>1 z\\<^sub>2. z\\<^sub>1 \\<in> fst(p)\\<times>snd(p) \\<and> z\\<^sub>2 \\<in> fst(p)\\<times>snd(p) \\<longrightarrow> \n    r``{f`(z\\<^sub>1)} = r``{f`(z\\<^sub>2)}\"\n    using EquivClass_1_L7 by blast\n   ultimately show ?thesis by (rule ZF1_1_L2)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 125
    },
    "115": {
        "type": "theorem",
        "text": "text\\<open>Congruent functions of two variables can be projected.\\<close>\n",
        "assumes": "assumes \"equiv(A,r)\"  \"Congruent2(r,f)\"\n  ",
        "using": [
            "assms",
            "EquivClass_1_L9",
            "ProjFun2_def",
            "ZF_fun_from_total"
        ],
        "statement": "theorem EquivClass_1_T1: \n  assumes \"equiv(A,r)\"  \"Congruent2(r,f)\"\n  shows \"ProjFun2(A,r,f) : (A//r)\\<times>(A//r) \\<rightarrow> A//r\"\n  ",
        "proof": "using assms EquivClass_1_L9 ProjFun2_def ZF_fun_from_total \n  by simp\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 126
    },
    "116": {
        "type": "lemma",
        "text": "text\\<open>The projection diagram commutes. I wish I knew how to draw this diagram\n  in LaTeX.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\" \n  and A3: \"x\\<in>A\"  \"y\\<in>A\"\n  ",
        "using": [
            "quotientI",
            "equiv_def",
            "EquivClass_1_L5",
            "Sigma_empty_iff",
            "equiv_class_self",
            "EquivClass_1_L7",
            "EquivClass_1_T1",
            "ProjFun2_def",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma EquivClass_1_L10: \n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\" \n  and A3: \"x\\<in>A\"  \"y\\<in>A\"\n  shows \"ProjFun2(A,r,f)`\\<langle>r``{x},r``{y}\\<rangle> = r``{f`\\<langle>x,y\\<rangle>}\"\n",
        "proof": "proof -\n  from A3 A1 have \"r``{x} \\<times> r``{y} \\<noteq> 0\"\n    using quotientI equiv_def EquivClass_1_L5 Sigma_empty_iff\n    by auto\n  moreover have \n    \"\\<forall>z \\<in> r``{x}\\<times>r``{y}.  r``{f`(z)} = r``{f`\\<langle>x,y\\<rangle>}\"\n  proof\n    fix z assume A4: \"z \\<in> r``{x}\\<times>r``{y}\"\n    from A1 A3 have \n      \"r``{x} \\<in> A//r\" \"r``{y} \\<in> A//r\"\n      \"\\<langle>x,y\\<rangle> \\<in> r``{x}\\<times>r``{y}\"\n      using quotientI equiv_class_self by auto\n    with A1 A2 A4 show\n      \"r``{f`(z)} = r``{f`\\<langle>x,y\\<rangle>}\"\n      using EquivClass_1_L7 by blast\n  qed\n  ultimately have \n    \"(\\<Union>z \\<in> r``{x}\\<times>r``{y}. r``{f`(z)}) =  r``{f`\\<langle>x,y\\<rangle>}\"\n    by (rule ZF1_1_L1)\n  moreover have \n    \"ProjFun2(A,r,f)`\\<langle>r``{x},r``{y}\\<rangle> = (\\<Union>z \\<in> r``{x}\\<times>r``{y}. r``{f`(z)})\"\n    proof -\n      from assms have \n\t\"ProjFun2(A,r,f) : (A//r)\\<times>(A//r) \\<rightarrow> A//r\"\n\t\"\\<langle>r``{x},r``{y}\\<rangle> \\<in> (A//r)\\<times>(A//r)\"\n\tusing EquivClass_1_T1 quotientI by auto\n      then show ?thesis using ProjFun2_def ZF_fun_from_tot_val\n\tby auto\n    qed\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 127
    },
    "117": {
        "type": "lemma",
        "text": "text\\<open>The projection of commutative operation is commutative.\\<close>\n",
        "assumes": "assumes \n  A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"f {is commutative on} A\"\n  and A4: \"c1 \\<in> A//r\"  \"c2 \\<in> A//r\"\n  ",
        "using": [
            "quotient_def",
            "EquivClass_1_L10",
            "IsCommutative_def"
        ],
        "statement": "lemma EquivClass_2_L1: assumes \n  A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"f {is commutative on} A\"\n  and A4: \"c1 \\<in> A//r\"  \"c2 \\<in> A//r\"\n  shows \"ProjFun2(A,r,f)`\\<langle>c1,c2\\<rangle> = ProjFun2(A,r,f)`\\<langle>c2,c1\\<rangle>\"\n",
        "proof": "proof -\n  from A4 obtain x y where D1:\n    \"c1 = r``{x}\"  \"c2 = r``{y}\"\n    \"x\\<in>A\"  \"y\\<in>A\"\n    using quotient_def by auto\n  with A1 A2 have \"ProjFun2(A,r,f)`\\<langle>c1,c2\\<rangle> = r``{f`\\<langle>x,y\\<rangle>}\"\n    using EquivClass_1_L10 by simp\n  also from A3 D1 have\n    \"r``{f`\\<langle>x,y\\<rangle>} = r``{f`\\<langle>y,x\\<rangle>}\"\n    using IsCommutative_def by simp\n  also from A1 A2 D1 have\n    \"r``{f`\\<langle>y,x\\<rangle>} = ProjFun2(A,r,f)` \\<langle>c2,c1\\<rangle>\"\n    using EquivClass_1_L10 by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 128
    },
    "118": {
        "type": "theorem",
        "text": "text\\<open>The projection of commutative operation is commutative.\\<close>\n",
        "assumes": "assumes \"equiv(A,r)\" and \"Congruent2(r,f)\"\n  and \"f {is commutative on} A\"\n  ",
        "using": [
            "assms",
            "IsCommutative_def",
            "EquivClass_2_L1"
        ],
        "statement": "theorem EquivClass_2_T1:\n  assumes \"equiv(A,r)\" and \"Congruent2(r,f)\"\n  and \"f {is commutative on} A\"\n  shows \"ProjFun2(A,r,f) {is commutative on} A//r\"\n  ",
        "proof": "using assms IsCommutative_def EquivClass_2_L1 by simp\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 129
    },
    "119": {
        "type": "lemma",
        "text": "text\\<open>The projection of an associative operation is associative.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"f {is associative on} A\"\n  and A4: \"c1 \\<in> A//r\"  \"c2 \\<in> A//r\"  \"c3 \\<in> A//r\"\n  and A5: \"g = ProjFun2(A,r,f)\"\n  ",
        "using": [
            "quotient_def",
            "IsAssociative_def",
            "apply_type",
            "EquivClass_1_L10"
        ],
        "statement": "lemma EquivClass_2_L2: \n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"f {is associative on} A\"\n  and A4: \"c1 \\<in> A//r\"  \"c2 \\<in> A//r\"  \"c3 \\<in> A//r\"\n  and A5: \"g = ProjFun2(A,r,f)\"\n  shows \"g`\\<langle>g`\\<langle>c1,c2\\<rangle>,c3\\<rangle> = g`\\<langle>c1,g`\\<langle>c2,c3\\<rangle>\\<rangle>\"\n",
        "proof": "proof -\n  from A4 obtain x y z where D1:\n    \"c1 = r``{x}\"  \"c2 = r``{y}\"  \"c3 = r``{z}\"\n    \"x\\<in>A\"  \"y\\<in>A\"  \"z\\<in>A\"\n    using quotient_def by auto\n  with A3 have T1:\"f`\\<langle>x,y\\<rangle> \\<in> A\"  \"f`\\<langle>y,z\\<rangle> \\<in> A\"\n    using IsAssociative_def apply_type by auto\n  with A1 A2 D1 A5 have \n    \"g`\\<langle>g`\\<langle>c1,c2\\<rangle>,c3\\<rangle> =  r``{f`\\<langle>f`\\<langle>x,y\\<rangle>,z\\<rangle>}\"\n    using EquivClass_1_L10 by simp\n  also from D1 A3 have \n    \"\\<dots> = r``{f`\\<langle>x,f`\\<langle>y,z\\<rangle> \\<rangle>}\"\n    using IsAssociative_def by simp\n  also from T1 A1 A2 D1 A5 have\n    \"\\<dots> = g`\\<langle>c1,g`\\<langle>c2,c3\\<rangle>\\<rangle>\"\n    using EquivClass_1_L10 by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 130
    },
    "120": {
        "type": "theorem",
        "text": "text\\<open>The projection of an associative operation is associative on the\n  quotient.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"f {is associative on} A\"\n  ",
        "using": [
            "EquivClass_1_T1",
            "EquivClass_2_L2",
            "IsAssociative_def"
        ],
        "statement": "theorem EquivClass_2_T2:\n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"f {is associative on} A\"\n  shows \"ProjFun2(A,r,f) {is associative on} A//r\"\n",
        "proof": "proof -\n  let ?g = \"ProjFun2(A,r,f)\"\n  from A1 A2 have \n    \"?g \\<in> (A//r)\\<times>(A//r) \\<rightarrow> A//r\"\n    using EquivClass_1_T1 by simp\n  moreover from A1 A2 A3 have\n    \"\\<forall>c1 \\<in> A//r.\\<forall>c2 \\<in> A//r.\\<forall>c3 \\<in> A//r.\n    ?g`\\<langle>?g`\\<langle>c1,c2\\<rangle>,c3\\<rangle> = ?g`\\<langle>c1,?g`\\<langle>c2,c3\\<rangle>\\<rangle>\"\n    using EquivClass_2_L2 by simp\n  ultimately show ?thesis\n    using IsAssociative_def by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 131
    },
    "121": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that distributivity is preserved by \n  projections to quotient spaces, provided both operations are congruent\n  with respect to the equivalence relation.\\<close>\n",
        "assumes": "assumes A1: \"IsDistributive(X,A,M)\"\n  and A2: \"equiv(X,r)\" \n  and A3: \"Congruent2(r,A)\" \"Congruent2(r,M)\"\n  and A4: \"a \\<in> X//r\"  \"b \\<in> X//r\"  \"c \\<in> X//r\"\n  and A5: \"A\\<^sub>p = ProjFun2(X,r,A)\" \"M\\<^sub>p = ProjFun2(X,r,M)\"\n  ",
        "using": [
            "quotient_def",
            "EquivClass_1_L8A",
            "EquivClass_1_L10",
            "IsDistributive_def"
        ],
        "statement": "lemma EquivClass_2_L3: \n  assumes A1: \"IsDistributive(X,A,M)\"\n  and A2: \"equiv(X,r)\" \n  and A3: \"Congruent2(r,A)\" \"Congruent2(r,M)\"\n  and A4: \"a \\<in> X//r\"  \"b \\<in> X//r\"  \"c \\<in> X//r\"\n  and A5: \"A\\<^sub>p = ProjFun2(X,r,A)\" \"M\\<^sub>p = ProjFun2(X,r,M)\"\n  shows \"M\\<^sub>p`\\<langle>a,A\\<^sub>p`\\<langle>b,c\\<rangle>\\<rangle> = A\\<^sub>p`\\<langle> M\\<^sub>p`\\<langle>a,b\\<rangle>,M\\<^sub>p`\\<langle>a,c\\<rangle>\\<rangle> \\<and> \n  M\\<^sub>p`\\<langle> A\\<^sub>p`\\<langle>b,c\\<rangle>,a \\<rangle> = A\\<^sub>p`\\<langle> M\\<^sub>p`\\<langle>b,a\\<rangle>, M\\<^sub>p`\\<langle>c,a\\<rangle>\\<rangle>\"\n",
        "proof": "proof\n  from A4 obtain x y z where \"x\\<in>X\"  \"y\\<in>X\"  \"z\\<in>X\"\n    \"a = r``{x}\"  \"b = r``{y}\"  \"c = r``{z}\"   \n    using quotient_def by auto\n  with A1 A2 A3 A5 show \n    \"M\\<^sub>p`\\<langle>a,A\\<^sub>p`\\<langle>b,c\\<rangle>\\<rangle> = A\\<^sub>p`\\<langle> M\\<^sub>p`\\<langle>a,b\\<rangle>,M\\<^sub>p`\\<langle>a,c\\<rangle>\\<rangle>\" and\n    \"M\\<^sub>p`\\<langle> A\\<^sub>p`\\<langle>b,c\\<rangle>,a \\<rangle> = A\\<^sub>p`\\<langle> M\\<^sub>p`\\<langle>b,a\\<rangle>, M\\<^sub>p`\\<langle>c,a\\<rangle>\\<rangle>\"  \n    using EquivClass_1_L8A EquivClass_1_L10 IsDistributive_def\n    by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 132
    },
    "122": {
        "type": "lemma",
        "text": "text\\<open>Distributivity is preserved by \n  projections to quotient spaces, provided both operations are congruent\n  with respect to the equivalence relation.\\<close>\n",
        "assumes": "assumes A1: \"IsDistributive(X,A,M)\"\n  and A2: \"equiv(X,r)\" \n  and A3: \"Congruent2(r,A)\" \"Congruent2(r,M)\"\n  ",
        "using": [
            "EquivClass_2_L3",
            "IsDistributive_def"
        ],
        "statement": "lemma EquivClass_2_L4: assumes A1: \"IsDistributive(X,A,M)\"\n  and A2: \"equiv(X,r)\" \n  and A3: \"Congruent2(r,A)\" \"Congruent2(r,M)\"\n  shows \"IsDistributive(X//r,ProjFun2(X,r,A),ProjFun2(X,r,M))\"\n",
        "proof": "proof-\n let ?A\\<^sub>p = \"ProjFun2(X,r,A)\" \n let ?M\\<^sub>p = \"ProjFun2(X,r,M)\"\n from A1 A2 A3 have\n   \"\\<forall>a\\<in>X//r.\\<forall>b\\<in>X//r.\\<forall>c\\<in>X//r.\n   ?M\\<^sub>p`\\<langle>a,?A\\<^sub>p`\\<langle>b,c\\<rangle>\\<rangle> = ?A\\<^sub>p`\\<langle>?M\\<^sub>p`\\<langle>a,b\\<rangle>,?M\\<^sub>p`\\<langle>a,c\\<rangle>\\<rangle> \\<and> \n   ?M\\<^sub>p`\\<langle>?A\\<^sub>p`\\<langle>b,c\\<rangle>,a\\<rangle> = ?A\\<^sub>p`\\<langle>?M\\<^sub>p`\\<langle>b,a\\<rangle>,?M\\<^sub>p`\\<langle>c,a\\<rangle>\\<rangle>\"\n   using EquivClass_2_L3 by simp\n then show ?thesis using IsDistributive_def by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 133
    },
    "123": {
        "type": "definition",
        "text": "text\\<open>The following defines the notion of a saturated set. \n  Recall that in Isabelle \n  \\<open>r-``(A)\\<close> is the inverse image of $A$ with respect to relation $r$. \n  This definition is not specific to equivalence relations.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsSaturated(r,A) \\<equiv> A = r-``(r``(A))\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 134
    },
    "124": {
        "type": "lemma",
        "text": "text\\<open>For equivalence relations a set is saturated iff it is an image \n  of itself.\\<close>\n",
        "assumes": "assumes A1: \"equiv(X,r)\"\n  ",
        "using": [
            "IsSaturated_def",
            "vimage_def",
            "image_comp",
            "equiv_comp_eq"
        ],
        "statement": "lemma EquivClass_3_L1: assumes A1: \"equiv(X,r)\"\n  shows \"IsSaturated(r,A) \\<longleftrightarrow> A = r``(A)\"\n",
        "proof": "proof\n  assume \"IsSaturated(r,A)\"\n  then have \"A = (converse(r) O r)``(A)\"\n    using IsSaturated_def vimage_def image_comp\n    by simp\n  also from A1 have \"\\<dots> = r``(A)\"\n    using equiv_comp_eq by simp\n  finally show \"A = r``(A)\" by simp\nnext assume \"A = r``(A)\"\n  with A1 have \"A = (converse(r) O r)``(A)\"\n    using equiv_comp_eq by simp\n  also have \"\\<dots> =  r-``(r``(A))\"\n    using vimage_def image_comp by simp\n  finally have \"A =  r-``(r``(A))\" by simp\n  then show \"IsSaturated(r,A)\" using IsSaturated_def\n    by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 135
    },
    "125": {
        "type": "lemma",
        "text": "text\\<open>For equivalence relations sets are contained in their images.\\<close> \n",
        "assumes": "assumes A1: \"equiv(X,r)\" and A2: \"A\\<subseteq>X\"\n  ",
        "using": [
            "equiv_class_self"
        ],
        "statement": "lemma EquivClass_3_L2: assumes A1: \"equiv(X,r)\" and A2: \"A\\<subseteq>X\"\n  shows \"A \\<subseteq> r``(A)\"\n",
        "proof": "proof\n  fix a assume \"a\\<in>A\"\n  with A1 A2 have \"a \\<in> r``{a}\"\n    using equiv_class_self by auto\n  with \\<open>a\\<in>A\\<close> show \"a \\<in> r``(A)\" by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 136
    },
    "126": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows that if \"$\\sim$\" \n  is an equivalence relation and a set \n  $A$ is such that $a\\in A$ and $a\\sim b$ implies $b\\in A$, then\n  $A$ is saturated with respect to the relation.\\<close>\n",
        "assumes": "assumes A1: \"equiv(X,r)\"\n  and A2: \"r \\<subseteq> X\\<times>X\" and A3: \"A\\<subseteq>X\"\n  and A4: \"\\<forall>x\\<in>A. \\<forall>y\\<in>X. \\<langle>x,y\\<rangle> \\<in> r \\<longrightarrow> y\\<in>A\"\n  ",
        "using": [
            "image_iff",
            "EquivClass_3_L2",
            "EquivClass_3_L1"
        ],
        "statement": "lemma EquivClass_3_L3: assumes A1: \"equiv(X,r)\"\n  and A2: \"r \\<subseteq> X\\<times>X\" and A3: \"A\\<subseteq>X\"\n  and A4: \"\\<forall>x\\<in>A. \\<forall>y\\<in>X. \\<langle>x,y\\<rangle> \\<in> r \\<longrightarrow> y\\<in>A\"\n  shows \"IsSaturated(r,A)\"\n",
        "proof": "proof -\n  from A2 A4 have \"r``(A) \\<subseteq> A\"\n    using image_iff by blast\n  moreover from A1 A3 have \"A \\<subseteq> r``(A)\"\n    using EquivClass_3_L2 by simp\n  ultimately have \"A = r``(A)\" by auto\n  with A1 show \"IsSaturated(r,A)\" using EquivClass_3_L1\n    by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 137
    },
    "127": {
        "type": "lemma",
        "text": "text\\<open>If $A\\subseteq X$ and $A$ is saturated and $x\\sim y$, then $x\\in A$ iff\n  $y\\in A$. Here we show only one direction.\\<close>\n",
        "assumes": "assumes A1: \"equiv(X,r)\"\n  and A2: \"IsSaturated(r,A)\" and A3: \"A\\<subseteq>X\"\n  and A4: \"\\<langle>x,y\\<rangle> \\<in> r\" \n  and A5: \"x\\<in>X\"  \"y\\<in>A\"\n  ",
        "using": [
            "equiv_class_self",
            "equiv_class_eq",
            "EquivClass_3_L1"
        ],
        "statement": "lemma EquivClass_3_L4: assumes A1: \"equiv(X,r)\"\n  and A2: \"IsSaturated(r,A)\" and A3: \"A\\<subseteq>X\"\n  and A4: \"\\<langle>x,y\\<rangle> \\<in> r\" \n  and A5: \"x\\<in>X\"  \"y\\<in>A\"\n  shows \"x\\<in>A\"\n",
        "proof": "proof -\n  from A1 A5 have \"x \\<in> r``{x}\"\n    using equiv_class_self by simp\n  with A1 A3 A4 A5 have \"x \\<in> r``(A)\"\n    using equiv_class_eq equiv_class_self\n    by auto\n  with A1 A2 show \"x\\<in>A\"\n    using EquivClass_3_L1 by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 138
    },
    "128": {
        "type": "lemma",
        "text": "text\\<open>If $A\\subseteq X$ and $A$ is saturated and $x\\sim y$, then $x\\in A$ iff\n  $y\\in A$.\\<close>\n",
        "assumes": "assumes A1: \"equiv(X,r)\"\n  and A2: \"IsSaturated(r,A)\" and A3: \"A\\<subseteq>X\"\n  and A4: \"x\\<in>X\"  \"y\\<in>X\"\n  and A5: \"\\<langle>x,y\\<rangle> \\<in> r\"\n  ",
        "using": [
            "EquivClass_3_L4",
            "equiv_is_sym"
        ],
        "statement": "lemma EquivClass_3_L5: assumes A1: \"equiv(X,r)\"\n  and A2: \"IsSaturated(r,A)\" and A3: \"A\\<subseteq>X\"\n  and A4: \"x\\<in>X\"  \"y\\<in>X\"\n  and A5: \"\\<langle>x,y\\<rangle> \\<in> r\"\n  shows \"x\\<in>A \\<longleftrightarrow> y\\<in>A\"\n",
        "proof": "proof\n  assume \"y\\<in>A\" \n  with assms show \"x\\<in>A\" using EquivClass_3_L4\n    by simp\nnext assume \"x\\<in>A\"\n  from A1 A5 have \"\\<langle>y,x\\<rangle> \\<in> r\"\n    using equiv_is_sym by blast\n  with A1 A2 A3 A4 \\<open>x\\<in>A\\<close> show \"y\\<in>A\"\n    using EquivClass_3_L4 by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 139
    },
    "129": {
        "type": "lemma",
        "text": "text\\<open>If $A$ is saturated then $x\\in A$ iff its class is in the projection \n  of $A$.\\<close>\n",
        "assumes": "assumes A1: \"equiv(X,r)\"\n  and A2: \"IsSaturated(r,A)\" and A3: \"A\\<subseteq>X\" and A4: \"x\\<in>X\"\n  and A5: \"B = {r``{x}. x\\<in>A}\"\n  ",
        "using": [
            "eq_equiv_class",
            "EquivClass_3_L4"
        ],
        "statement": "lemma EquivClass_3_L6: assumes A1: \"equiv(X,r)\"\n  and A2: \"IsSaturated(r,A)\" and A3: \"A\\<subseteq>X\" and A4: \"x\\<in>X\"\n  and A5: \"B = {r``{x}. x\\<in>A}\"\n  shows \"x\\<in>A \\<longleftrightarrow> r``{x} \\<in> B\"\n",
        "proof": "proof\n  assume \"x\\<in>A\"\n  with A5 show \"r``{x} \\<in> B\" by auto\nnext assume \"r``{x} \\<in> B\"\n  with A5 obtain y where \"y \\<in> A\" and \"r``{x} = r``{y}\"\n    by auto\n  with A1 A3 have \"\\<langle>x,y\\<rangle> \\<in> r\"\n    using eq_equiv_class by auto\n  with A1 A2 A3 A4  \\<open>y \\<in> A\\<close> show \"x\\<in>A\"\n    using EquivClass_3_L4 by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 140
    },
    "130": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma involving a projection of a saturated set and a \n  logical epression with exclusive or. Note that we don't really care \n  what \\<open>Xor\\<close> is here, this is true for any predicate.\\<close>\n",
        "assumes": "assumes \"equiv(X,r)\"\n  and \"IsSaturated(r,A)\" and \"A\\<subseteq>X\"\n  and \"x\\<in>X\"  \"y\\<in>X\"\n  and \"B = {r``{x}. x\\<in>A}\"\n  and \"(x\\<in>A) Xor (y\\<in>A)\"\n  ",
        "using": [
            "assms",
            "EquivClass_3_L6"
        ],
        "statement": "lemma EquivClass_3_L7: assumes \"equiv(X,r)\"\n  and \"IsSaturated(r,A)\" and \"A\\<subseteq>X\"\n  and \"x\\<in>X\"  \"y\\<in>X\"\n  and \"B = {r``{x}. x\\<in>A}\"\n  and \"(x\\<in>A) Xor (y\\<in>A)\"\n  shows \"(r``{x} \\<in> B)  Xor (r``{y} \\<in> B)\"\n  ",
        "proof": "using assms EquivClass_3_L6 by simp\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 141
    },
    "131": {
        "type": "definition",
        "text": "text\\<open>Field is a notrivial commutative ring such that all \n  non-zero elements have an inverse. We define the notion of being a field as\n  a statement about three sets. The first set, denoted \\<open>K\\<close> is the \n  carrier of the field. The second set, denoted \\<open>A\\<close> represents the \n  additive operation on \\<open>K\\<close> (recall that in ZF set theory functions \n  are sets). The third set \\<open>M\\<close> represents the multiplicative operation \n  on \\<open>K\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAfield(K,A,M) \\<equiv> \n  (IsAring(K,A,M) \\<and> (M {is commutative on} K) \\<and>\n  TheNeutralElement(K,A) \\<noteq> TheNeutralElement(K,M) \\<and> \n  (\\<forall>a\\<in>K. a\\<noteq>TheNeutralElement(K,A)\\<longrightarrow>\n  (\\<exists>b\\<in>K. M`\\<langle>a,b\\<rangle> = TheNeutralElement(K,M))))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 142
    },
    "132": {
        "type": "lemma",
        "text": "text\\<open>The next lemma assures us that we are talking fields \n  in the \\<open>field0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "ringAssum",
            "mult_commute",
            "not_triv",
            "inv_exists",
            "IsAfield_def"
        ],
        "statement": "lemma (in field0) Field_ZF_1_L1: shows \"IsAfield(K,A,M)\"\n  ",
        "proof": "using ringAssum mult_commute not_triv inv_exists IsAfield_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 143
    },
    "133": {
        "type": "lemma",
        "text": "text\\<open>We can use theorems proven in the \\<open>field0\\<close> context whenever we\n  talk about a field.\\<close>\n",
        "assumes": "assumes \"IsAfield(K,A,M)\"\n  ",
        "using": [
            "assms",
            "IsAfield_def",
            "field0_axioms.intro",
            "ring0_def",
            "field0_def"
        ],
        "statement": "lemma field_field0: assumes \"IsAfield(K,A,M)\"\n  shows \"field0(K,A,M)\"\n  ",
        "proof": "using assms IsAfield_def field0_axioms.intro ring0_def field0_def \n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 144
    },
    "134": {
        "type": "lemma",
        "text": "text\\<open>Let's have an explicit statement that the multiplication\n  in fields is commutative.\\<close>\n",
        "assumes": "assumes \"a\\<in>K\"  \"b\\<in>K\"\n  ",
        "using": [
            "mult_commute",
            "assms",
            "IsCommutative_def"
        ],
        "statement": "lemma (in field0) field_mult_comm: assumes \"a\\<in>K\"  \"b\\<in>K\"\n  shows \"a\\<cdot>b = b\\<cdot>a\"\n  ",
        "proof": "using mult_commute assms IsCommutative_def by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 145
    },
    "135": {
        "type": "lemma",
        "text": "text\\<open>Fields do not have zero divisors.\\<close>\n",
        "assumes": "",
        "using": [
            "Ring_ZF_1_L11",
            "Ring_ZF_1_L6",
            "Ring_ZF_1_L3",
            "HasNoZeroDivs_def"
        ],
        "statement": "lemma (in field0) field_has_no_zero_divs: shows \"HasNoZeroDivs(K,A,M)\"\n",
        "proof": "proof -\n  { fix a b assume A1: \"a\\<in>K\"  \"b\\<in>K\" and A2: \"a\\<cdot>b = \\<zero>\"  and A3: \"b\\<noteq>\\<zero>\"\n    from inv_exists A1 A3 obtain c where I: \"c\\<in>K\" and II: \"b\\<cdot>c = \\<one>\"\n      by auto\n    from A2 have \"a\\<cdot>b\\<cdot>c = \\<zero>\\<cdot>c\" by simp\n    with A1 I have \"a\\<cdot>(b\\<cdot>c) = \\<zero>\" \n      using Ring_ZF_1_L11 Ring_ZF_1_L6 by simp\n    with A1 II have \"a=\\<zero> \"using Ring_ZF_1_L3 by simp } \n  then have \"\\<forall>a\\<in>K.\\<forall>b\\<in>K. a\\<cdot>b = \\<zero> \\<longrightarrow> a=\\<zero> \\<or> b=\\<zero>\" by auto\n    then show ?thesis using HasNoZeroDivs_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 146
    },
    "136": {
        "type": "lemma",
        "text": "text\\<open>$K_0$ (the set of nonzero field elements is closed with respect\n  to multiplication.\\<close>\n",
        "assumes": "",
        "using": [
            "Ring_ZF_1_L4",
            "field_has_no_zero_divs",
            "Ring_ZF_1_L12",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in field0) Field_ZF_1_L2: \n  shows \"K\\<^sub>0 {is closed under} M\"\n  ",
        "proof": "using Ring_ZF_1_L4 field_has_no_zero_divs Ring_ZF_1_L12\n    IsOpClosed_def by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 147
    },
    "137": {
        "type": "lemma",
        "text": "text\\<open>Any nonzero element has a right inverse that is nonzero.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>K\\<^sub>0\"\n  ",
        "using": [
            "Ring_ZF_1_L6"
        ],
        "statement": "lemma (in field0) Field_ZF_1_L3: assumes A1: \"a\\<in>K\\<^sub>0\"\n  shows \"\\<exists>b\\<in>K\\<^sub>0. a\\<cdot>b = \\<one>\"\n",
        "proof": "proof -\n  from inv_exists A1 obtain b where \"b\\<in>K\" and \"a\\<cdot>b = \\<one>\"\n    by auto\n  with not_triv A1 show \"\\<exists>b\\<in>K\\<^sub>0. a\\<cdot>b = \\<one>\"\n    using Ring_ZF_1_L6 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 148
    },
    "138": {
        "type": "theorem",
        "text": "text\\<open>If we remove zero, the field with multiplication\n  becomes a group and we can use all theorems proven in \n  \\<open>group0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "Field_ZF_1_L1",
            "IsAfield_def",
            "IsAring_def",
            "IsAgroup_def",
            "IsAmonoid_def",
            "Field_ZF_1_L2",
            "func_ZF_4_L3",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L3",
            "monoid0_def",
            "Field_ZF_1_L3",
            "group0_def"
        ],
        "statement": "theorem (in field0) Field_ZF_1_L4: shows \n  \"IsAgroup(K\\<^sub>0,restrict(M,K\\<^sub>0\\<times>K\\<^sub>0))\"\n  \"group0(K\\<^sub>0,restrict(M,K\\<^sub>0\\<times>K\\<^sub>0))\"\n  \"\\<one> = TheNeutralElement(K\\<^sub>0,restrict(M,K\\<^sub>0\\<times>K\\<^sub>0))\"\n",
        "proof": "proof-\n  let ?f = \"restrict(M,K\\<^sub>0\\<times>K\\<^sub>0)\"\n  have \n    \"M {is associative on} K\"\n    \"K\\<^sub>0 \\<subseteq> K\"  \"K\\<^sub>0 {is closed under} M\"\n    using Field_ZF_1_L1 IsAfield_def IsAring_def IsAgroup_def \n      IsAmonoid_def Field_ZF_1_L2 by auto\n  then have \"?f {is associative on} K\\<^sub>0\"\n    using func_ZF_4_L3 by simp\n  moreover\n  from not_triv have \n    I: \"\\<one>\\<in>K\\<^sub>0 \\<and> (\\<forall>a\\<in>K\\<^sub>0. ?f`\\<langle>\\<one>,a\\<rangle> = a \\<and>  ?f`\\<langle>a,\\<one>\\<rangle> = a)\"\n    using Ring_ZF_1_L2 Ring_ZF_1_L3 by auto\n  then have \"\\<exists>n\\<in>K\\<^sub>0. \\<forall>a\\<in>K\\<^sub>0. ?f`\\<langle>n,a\\<rangle> = a \\<and>  ?f`\\<langle>a,n\\<rangle> = a\"\n    by blast\n  ultimately have II: \"IsAmonoid(K\\<^sub>0,?f)\" using IsAmonoid_def\n    by simp\n  then have \"monoid0(K\\<^sub>0,?f)\" using monoid0_def by simp\n  moreover note I\n  ultimately show \"\\<one> = TheNeutralElement(K\\<^sub>0,?f)\"\n    by (rule monoid0.group0_1_L4)\n  then have \"\\<forall>a\\<in>K\\<^sub>0.\\<exists>b\\<in>K\\<^sub>0. ?f`\\<langle>a,b\\<rangle> =  TheNeutralElement(K\\<^sub>0,?f)\"\n    using Field_ZF_1_L3 by auto\n  with II show \"IsAgroup(K\\<^sub>0,?f)\" by (rule definition_of_group)\n  then show \"group0(K\\<^sub>0,?f)\" using group0_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 149
    },
    "139": {
        "type": "lemma",
        "text": "text\\<open>The inverse of a nonzero field element is nonzero.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>K\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "Field_ZF_1_L4",
            "group0.inverse_in_group",
            "Field_ZF_1_L2",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in field0) Field_ZF_1_L5: assumes A1: \"a\\<in>K\"  \"a\\<noteq>\\<zero>\"\n  shows \"a\\<inverse> \\<in> K\\<^sub>0\"  \"(a\\<inverse>)\\<^sup>2 \\<in> K\\<^sub>0\"   \"a\\<inverse> \\<in> K\"  \"a\\<inverse> \\<noteq> \\<zero>\"\n",
        "proof": "proof -\n  from A1 have \"a \\<in> K\\<^sub>0\" by simp\n  then show \"a\\<inverse> \\<in> K\\<^sub>0\" using Field_ZF_1_L4 group0.inverse_in_group\n    by auto\n  then show  \"(a\\<inverse>)\\<^sup>2 \\<in> K\\<^sub>0\"  \"a\\<inverse> \\<in> K\"  \"a\\<inverse> \\<noteq> \\<zero>\" \n    using Field_ZF_1_L2 IsOpClosed_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 150
    },
    "140": {
        "type": "lemma",
        "text": "text\\<open>The inverse is really the inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>K\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "Field_ZF_1_L4",
            "Field_ZF_1_L5"
        ],
        "statement": "lemma (in field0) Field_ZF_1_L6: assumes A1: \"a\\<in>K\"  \"a\\<noteq>\\<zero>\"\n  shows \"a\\<cdot>a\\<inverse> = \\<one>\"  \"a\\<inverse>\\<cdot>a = \\<one>\"\n",
        "proof": "proof -\n  let ?f = \"restrict(M,K\\<^sub>0\\<times>K\\<^sub>0)\"\n  from A1 have \n    \"group0(K\\<^sub>0,?f)\"\n    \"a \\<in> K\\<^sub>0\"\n    using Field_ZF_1_L4 by auto\n  then have \n    \"?f`\\<langle>a,GroupInv(K\\<^sub>0, ?f)`(a)\\<rangle> = TheNeutralElement(K\\<^sub>0,?f) \\<and>\n    ?f`\\<langle>GroupInv(K\\<^sub>0,?f)`(a),a\\<rangle> = TheNeutralElement(K\\<^sub>0, ?f)\"\n    by (rule group0.group0_2_L6)\n  with A1 show \"a\\<cdot>a\\<inverse> = \\<one>\"  \"a\\<inverse>\\<cdot>a = \\<one>\"\n    using Field_ZF_1_L5 Field_ZF_1_L4 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 151
    },
    "141": {
        "type": "lemma",
        "text": "text\\<open>If we multiply two different numbers by a nonzero number, the results \n  will be different.\\<close>\n",
        "assumes": "assumes \"a\\<in>K\"  \"b\\<in>K\"  \"c\\<in>K\"  \"a\\<noteq>b\"  \"c\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "field_has_no_zero_divs",
            "Field_ZF_1_L5",
            "Ring_ZF_1_L12B"
        ],
        "statement": "lemma (in field0) Field_ZF_2_L2: \n  assumes \"a\\<in>K\"  \"b\\<in>K\"  \"c\\<in>K\"  \"a\\<noteq>b\"  \"c\\<noteq>\\<zero>\"\n  shows \"a\\<cdot>c\\<inverse> \\<noteq> b\\<cdot>c\\<inverse>\"\n  ",
        "proof": "using assms field_has_no_zero_divs Field_ZF_1_L5 Ring_ZF_1_L12B\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 154
    },
    "142": {
        "type": "lemma",
        "text": "text\\<open>We can put a nonzero factor on the other side of non-identity \n  (is this the best way to call it?) changing it to the inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>K\"  \"b\\<in>K\"  \"b\\<noteq>\\<zero>\"  \"c\\<in>K\"   and A2: \"a\\<cdot>b \\<noteq> c\"\n  ",
        "using": [
            "Ring_ZF_1_L4",
            "Field_ZF_2_L2",
            "Field_ZF_1_L7"
        ],
        "statement": "lemma (in field0) Field_ZF_2_L3:\n  assumes A1: \"a\\<in>K\"  \"b\\<in>K\"  \"b\\<noteq>\\<zero>\"  \"c\\<in>K\"   and A2: \"a\\<cdot>b \\<noteq> c\"\n  shows \"a \\<noteq> c\\<cdot>b\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>b\\<cdot>b\\<inverse> \\<noteq> c\\<cdot>b\\<inverse>\" \n    using  Ring_ZF_1_L4 Field_ZF_2_L2 by simp\n  with A1 show \"a \\<noteq> c\\<cdot>b\\<inverse>\" using Field_ZF_1_L7\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 155
    },
    "143": {
        "type": "lemma",
        "text": "text\\<open>If if the inverse of $b$ is different than $a$, then the\n  inverse of $a$ is different than $b$.\\<close>\n",
        "assumes": "assumes \"a\\<in>K\"  \"a\\<noteq>\\<zero>\" and \"b\\<inverse> \\<noteq> a\"\n  ",
        "using": [
            "assms",
            "Field_ZF_1_L4",
            "group0.group0_2_L11B"
        ],
        "statement": "lemma (in field0) Field_ZF_2_L4:\n  assumes \"a\\<in>K\"  \"a\\<noteq>\\<zero>\" and \"b\\<inverse> \\<noteq> a\"\n  shows \"a\\<inverse> \\<noteq> b\"\n  ",
        "proof": "using assms Field_ZF_1_L4 group0.group0_2_L11B\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 156
    },
    "144": {
        "type": "lemma",
        "text": "text\\<open>An identity with two field elements, one and an inverse.\\<close>\n",
        "assumes": "assumes \"a\\<in>K\"  \"b\\<in>K\" \"b\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L4",
            "Field_ZF_1_L5",
            "Ring_ZF_1_L2",
            "ring_oper_distr",
            "Field_ZF_1_L7",
            "Ring_ZF_1_L3"
        ],
        "statement": "lemma (in field0) Field_ZF_2_L5:\n  assumes \"a\\<in>K\"  \"b\\<in>K\" \"b\\<noteq>\\<zero>\"\n  shows \"(\\<one> \\<ra> a\\<cdot>b)\\<cdot>b\\<inverse> = a \\<ra> b\\<inverse>\"\n  ",
        "proof": "using assms Ring_ZF_1_L4 Field_ZF_1_L5 Ring_ZF_1_L2 ring_oper_distr \n    Field_ZF_1_L7 Ring_ZF_1_L3 by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 157
    },
    "145": {
        "type": "lemma",
        "text": "text\\<open>An identity with three field elements, inverse and cancelling.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>K\"  \"b\\<in>K\"  \"b\\<noteq>\\<zero>\"  \"c\\<in>K\"\n  ",
        "using": [
            "Ring_ZF_1_L4",
            "Field_ZF_1_L5",
            "IsCommutative_def",
            "Field_ZF_1_L7"
        ],
        "statement": "lemma (in field0) Field_ZF_2_L6: assumes A1: \"a\\<in>K\"  \"b\\<in>K\"  \"b\\<noteq>\\<zero>\"  \"c\\<in>K\"\n  shows \"a\\<cdot>b\\<cdot>(c\\<cdot>b\\<inverse>) = a\\<cdot>c\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<cdot>b \\<in> K\"  \"b\\<inverse> \\<in> K\"\n    using Ring_ZF_1_L4 Field_ZF_1_L5 by auto\n  with mult_commute A1 have \"a\\<cdot>b\\<cdot>(c\\<cdot>b\\<inverse>) = a\\<cdot>b\\<cdot>(b\\<inverse>\\<cdot>c)\"\n    using IsCommutative_def by simp\n  moreover\n  from A1 T have \"a\\<cdot>b \\<in> K\"  \"b\\<inverse> \\<in> K\"  \"c\\<in>K\"\n    by auto\n  then have \"a\\<cdot>b\\<cdot>b\\<inverse>\\<cdot>c = a\\<cdot>b\\<cdot>(b\\<inverse>\\<cdot>c)\"\n    by (rule Ring_ZF_1_L11)\n  ultimately have \"a\\<cdot>b\\<cdot>(c\\<cdot>b\\<inverse>) = a\\<cdot>b\\<cdot>b\\<inverse>\\<cdot>c\" by simp\n  with A1 show \"a\\<cdot>b\\<cdot>(c\\<cdot>b\\<inverse>) = a\\<cdot>c\" \n    using Field_ZF_1_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 158
    },
    "146": {
        "type": "lemma",
        "text": "text\\<open>Division is a function on $K\\times K_0$ with values in $K$.\\<close>\n",
        "assumes": "",
        "using": [
            "Ring_ZF_1_L4",
            "Field_ZF_1_L5"
        ],
        "statement": "lemma (in fieldd) div_fun: shows \"division: K\\<times>K\\<^sub>0 \\<rightarrow> K\"\n",
        "proof": "proof -\n  have \"\\<forall>p \\<in> K\\<times>K\\<^sub>0. fst(p)\\<cdot>snd(p)\\<inverse> \\<in> K\"\n  proof\n    fix p assume \"p \\<in> K\\<times>K\\<^sub>0\"\n    hence \"fst(p) \\<in> K\" and \"snd(p) \\<in> K\\<^sub>0\" by auto\n    then show  \"fst(p)\\<cdot>snd(p)\\<inverse> \\<in> K\" using Ring_ZF_1_L4 Field_ZF_1_L5 by auto\n  qed\n  then have \"{\\<langle>p,fst(p)\\<cdot>snd(p)\\<inverse>\\<rangle>. p\\<in>K\\<times>K\\<^sub>0}: K\\<times>K\\<^sub>0 \\<rightarrow> K\"\n    by (rule ZF_fun_from_total)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 159
    },
    "147": {
        "type": "theorem",
        "text": "text\\<open>So, really $1/0=0$. The essential lemma is \\<open>apply_0\\<close> from standard\n  Isabelle's \\<open>func.thy\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "div_fun",
            "func1_1_L1",
            "apply_0"
        ],
        "statement": "theorem (in fieldd) one_over_zero: shows \"\\<one>\\<fd>\\<zero> = 0\"\n",
        "proof": "proof-\n  have \"domain(division) = K\\<times>K\\<^sub>0\" using div_fun func1_1_L1\n    by simp\n  hence \"\\<langle>\\<one>,\\<zero>\\<rangle> \\<notin> domain(division)\" by auto\n  then show ?thesis using apply_0 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 160
    },
    "148": {
        "type": "theorem",
        "text": "text\\<open>For total and transitive relations \n  nonempty finite set has a maximum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"B \\<in> FinPow(X)\" and A4: \"B \\<noteq> 0\"\n  ",
        "using": [
            "total_is_refl",
            "Order_ZF_4_L8",
            "FinPow_def",
            "Order_ZF_4_L9"
        ],
        "statement": "theorem fin_has_max: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"B \\<in> FinPow(X)\" and A4: \"B \\<noteq> 0\"\n  shows \"HasAmaximum(r,B)\"\n",
        "proof": "proof -\n  have \"0=0 \\<or> HasAmaximum(r,0)\" by simp\n  moreover have \n    \"\\<forall>A \\<in> FinPow(X). A=0 \\<or> HasAmaximum(r,A) \\<longrightarrow>\n    (\\<forall>x\\<in>X. (A \\<union> {x}) = 0 \\<or> HasAmaximum(r,A \\<union> {x}))\"\n  proof -\n    { fix A \n      assume \"A \\<in> FinPow(X)\"  \"A = 0 \\<or> HasAmaximum(r,A)\"\n      have \"\\<forall>x\\<in>X. (A \\<union> {x}) = 0 \\<or> HasAmaximum(r,A \\<union> {x})\"\n      proof -\n\t{ fix x assume \"x\\<in>X\"\n\t  note \\<open>A = 0 \\<or> HasAmaximum(r,A)\\<close>\n\t  moreover\n\t  { assume \"A = 0\"\n\t    then have \"A\\<union>{x} = {x}\" by simp\n\t    from A1 have \"refl(X,r)\" using total_is_refl \n\t      by simp\n\t    with \\<open>x\\<in>X\\<close> \\<open>A\\<union>{x} = {x}\\<close> have \"HasAmaximum(r,A\\<union>{x})\"\n\t      using Order_ZF_4_L8 by simp }\n\t  moreover\n\t  { assume \"HasAmaximum(r,A)\"\n\t    with A1 A2 \\<open>A \\<in> FinPow(X)\\<close>  \\<open>x\\<in>X\\<close> \n\t    have \"HasAmaximum(r,A\\<union>{x})\" \n\t      using FinPow_def Order_ZF_4_L9 by simp }\n\t  ultimately  have \"A \\<union> {x} = 0 \\<or> HasAmaximum(r,A \\<union> {x})\"\n\t    by auto\n\t} thus \"\\<forall>x\\<in>X. (A \\<union> {x}) = 0 \\<or> HasAmaximum(r,A \\<union> {x})\"\n\t  by simp\n      qed\n    } thus ?thesis by simp\n  qed\n  moreover note A3\n  ultimately have \"B = 0 \\<or>  HasAmaximum(r,B)\"\n    by (rule FinPow_induct)\n  with A4 show \"HasAmaximum(r,B)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 161
    },
    "149": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered nonempty finite sets the \n  maximum is in the set and indeed it is the greatest\n  element of the set.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and\n  A2: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\"\n  ",
        "using": [
            "IsLinOrder_def",
            "fin_has_max",
            "Order_ZF_4_L3",
            "FinPow_def"
        ],
        "statement": "lemma linord_max_props: assumes A1: \"IsLinOrder(X,r)\" and\n  A2: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\"\n  shows\n  \"Maximum(r,A) \\<in> A\"\n  \"Maximum(r,A) \\<in> X\"\n  \"\\<forall>a\\<in>A. \\<langle>a,Maximum(r,A)\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A1 A2 show \n    \"Maximum(r,A) \\<in> A\" and \"\\<forall>a\\<in>A. \\<langle>a,Maximum(r,A)\\<rangle> \\<in> r\"\n    using IsLinOrder_def fin_has_max Order_ZF_4_L3\n    by auto\n  with A2 show \"Maximum(r,A) \\<in> X\" using FinPow_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 162
    },
    "150": {
        "type": "lemma",
        "text": "text\\<open>Every nonempty subset of a natural number has a maximum with expected properties.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"A\\<subseteq>n\" \"A\\<noteq>0\"\n  ",
        "using": [
            "nat_finpow_nat",
            "subset_finpow",
            "NatOrder_ZF_1_L2(4)",
            "linord_max_props(1,2)",
            "linord_max_props"
        ],
        "statement": "lemma nat_max_props: assumes \"n\\<in>nat\" \"A\\<subseteq>n\" \"A\\<noteq>0\"\n  shows\n  \"Maximum(Le,A) \\<in> A\"\n  \"Maximum(Le,A) \\<in> nat\"\n  \"\\<forall>k\\<in>A. k \\<le> Maximum(Le,A)\"\n",
        "proof": "proof -\n  from assms(1,2) have \"A \\<in> FinPow(nat)\" \n    using nat_finpow_nat subset_finpow by blast\n  with assms(3) show \n    \"Maximum(Le,A) \\<in> A\"\n    \"Maximum(Le,A) \\<in> nat\"\n    using NatOrder_ZF_1_L2(4) linord_max_props(1,2) by simp_all\n  from assms(3) \\<open>A \\<in> FinPow(nat)\\<close> have \"\\<forall>k\\<in>A. \\<langle>k,Maximum(Le,A)\\<rangle> \\<in> Le\"\n    using linord_max_props NatOrder_ZF_1_L2(4) by blast\n  then show  \"\\<forall>k\\<in>A. k \\<le> Maximum(Le,A)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 163
    },
    "151": {
        "type": "lemma",
        "text": "text\\<open>Yet another version of induction where the induction step is valid only up to $n\\in \\mathbb{N}$\n  rather than for all natural numbers.\n  This lemma is redundant as it is easier to prove this assertion using lemma \\<open>fin_nat_ind\\<close> \n  from \\<open>Nat_ZF_IML\\<close> which was done in lemma \\<open>fin_nat_ind1\\<close> there. \n  It is left here for now as an alternative proof based on properties of the \n  maximum of a finite set. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and \"P(0)\" and \"\\<forall>j\\<in>n. P(j)\\<longrightarrow>P(j #+ 1)\"\n  ",
        "using": [
            "empty_in_every_succ",
            "succ_add_one(1)",
            "succ_ineq1"
        ],
        "statement": "lemma ind_on_nat2: \n  assumes \"n\\<in>nat\" and \"P(0)\" and \"\\<forall>j\\<in>n. P(j)\\<longrightarrow>P(j #+ 1)\"\n  shows \"\\<forall>j\\<in>n #+ 1. P(j)\" and \"P(n)\"\n",
        "proof": "proof -\n  let ?A = \"{k\\<in>succ(n). \\<forall>j\\<in>succ(k). P(j)}\"\n  let ?M = \"Maximum(Le,?A)\" \n  from assms(1,2) have I: \"succ(n) \\<in> nat\" \"?A\\<subseteq>succ(n)\" \"?A\\<noteq>0\" \n    using empty_in_every_succ by auto \n  then have \"?M \\<in> ?A\" by (rule nat_max_props)\n  have \"n=?M\"\n  proof -\n    from \\<open>?M \\<in> ?A\\<close> have \"?M \\<in> succ(n)\" by blast\n    with assms(1) have \"?M\\<in>n \\<or> ?M=n\" by auto\n    moreover\n    { assume \"?M \\<in> n\"\n      from I have \"?M \\<in> nat\" by (rule nat_max_props)\n      from assms(3) \\<open>?M\\<in>?A\\<close> \\<open>?M\\<in>n\\<close> have \"P(?M #+ 1)\" by blast\n      with \\<open>?M \\<in> nat\\<close> have \"P(succ(?M))\" using succ_add_one(1) by simp\n      with \\<open>?M\\<in>?A\\<close> have \"\\<forall>j\\<in>succ(succ(?M)). P(j)\" by blast\n      moreover from assms(1) \\<open>?M \\<in> n\\<close> have \"succ(?M) \\<in> succ(n)\"\n        using succ_ineq1 by simp\n      moreover from I have \"\\<forall>k\\<in>?A. k \\<le> ?M\"\n        by (rule nat_max_props)\n      ultimately have False by blast\n    }\n    ultimately show \"n=?M\" by auto\n  qed\n  with \\<open>?M \\<in> ?A\\<close> have \"n\\<in>?A\" by (rule eq_mem)\n  with assms(1) show \"\\<forall>j\\<in>n #+ 1. P(j)\" and \"P(n)\" \n    using succ_add_one(1) by simp_all\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 164
    },
    "152": {
        "type": "lemma",
        "text": "text\\<open>Even weirder than \\<open>empty_ord_iso\\<close>\n  The order automorphism of the empty set is unique.\\<close>\n",
        "assumes": "assumes \"f \\<in> ord_iso(0,r,0,R)\"  \"g \\<in> ord_iso(0,r,0,R)\"\n  ",
        "using": [
            "ord_iso_def",
            "bij_def",
            "surj_def"
        ],
        "statement": "lemma empty_ord_iso_uniq: \n  assumes \"f \\<in> ord_iso(0,r,0,R)\"  \"g \\<in> ord_iso(0,r,0,R)\"\n  shows \"f = g\"\n",
        "proof": "proof -\n  from assms have \"f : 0 \\<rightarrow> 0\" and \"g: 0 \\<rightarrow> 0\"\n    using ord_iso_def bij_def surj_def by auto\n    moreover have \"\\<forall>x\\<in>0. f`(x) = g`(x)\" by simp\n    ultimately show \"f = g\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 166
    },
    "153": {
        "type": "lemma",
        "text": "text\\<open>The empty set is the only order automorphism of itself.\\<close>\n",
        "assumes": "",
        "using": [
            "ord_iso_def",
            "bij_def",
            "surj_def",
            "fun_subset_prod",
            "empty_ord_iso_uniq"
        ],
        "statement": "lemma empty_ord_iso_empty: shows \"ord_iso(0,r,0,R) = {0}\"\n",
        "proof": "proof -\n  have \"0 \\<in> ord_iso(0,r,0,R)\"\n  proof -\n    have \"ord_iso(0,r,0,R) \\<noteq> 0\" by (rule empty_ord_iso)\n    then obtain f where \"f \\<in> ord_iso(0,r,0,R)\" by auto\n    then show \"0 \\<in> ord_iso(0,r,0,R)\" \n      using ord_iso_def bij_def surj_def fun_subset_prod\n      by auto\n  qed\n  then show \"ord_iso(0,r,0,R) = {0}\" using empty_ord_iso_uniq\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 167
    },
    "154": {
        "type": "lemma",
        "text": "text\\<open>An induction (or maybe recursion?) scheme for linearly ordered sets.\n  The induction step is that we show that if the property holds\n  when the set is a singleton or for a set with the maximum removed, \n  then it holds for the set. The idea is that since we can build\n  any finite set by adding elements on the right, then if the property\n  holds for the empty set and is invariant with respect to this operation, then\n  it must hold for all finite sets.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and A2: \"P(0)\" and\n  A3: \"\\<forall>A \\<in> FinPow(X). A \\<noteq> 0 \\<longrightarrow> (P(A - {Maximum(r,A)}) \\<longrightarrow> P(A))\"\n  and A4: \"B \\<in> FinPow(X)\" ",
        "using": [
            "IsLinOrder_def",
            "fin_has_max",
            "Order_ZF_4_L3"
        ],
        "statement": "lemma fin_ord_induction:  \n  assumes A1: \"IsLinOrder(X,r)\" and A2: \"P(0)\" and\n  A3: \"\\<forall>A \\<in> FinPow(X). A \\<noteq> 0 \\<longrightarrow> (P(A - {Maximum(r,A)}) \\<longrightarrow> P(A))\"\n  and A4: \"B \\<in> FinPow(X)\" shows \"P(B)\"\n",
        "proof": "proof -\n  note A2\n  moreover have \"\\<forall> A \\<in> FinPow(X). A \\<noteq> 0 \\<longrightarrow> (\\<exists>a\\<in>A. P(A-{a}) \\<longrightarrow> P(A))\"\n  proof -\n    { fix A assume \"A \\<in>  FinPow(X)\" and \"A \\<noteq> 0\"\n      with A1 A3 have \"\\<exists>a\\<in>A. P(A-{a}) \\<longrightarrow> P(A)\"\n\tusing IsLinOrder_def fin_has_max\n\t  IsLinOrder_def Order_ZF_4_L3\n\tby blast\n    } thus ?thesis by simp\n  qed\n  moreover note A4\n  ultimately show \"P(B)\" by (rule FinPow_ind_rem_one)\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 168
    },
    "155": {
        "type": "lemma",
        "text": "text\\<open>A sligltly more complicated version of \\<open>fin_ord_induction\\<close>\n  that allows to prove properties that are not true for the empty set.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and A2: \"\\<forall>A \\<in> FinPow(X). \n  A = 0 \\<or> (A = {Maximum(r,A)} \\<or> P(A - {Maximum(r,A)}) \\<longrightarrow> P(A))\"\n  and A3: \"B \\<in>  FinPow(X)\" and A4: \"B\\<noteq>0\"\n  ",
        "using": [
            "IsLinOrder_def",
            "fin_has_max",
            "Order_ZF_4_L3",
            "FinPow_rem_ind"
        ],
        "statement": "lemma fin_ord_ind:  \n  assumes A1: \"IsLinOrder(X,r)\" and A2: \"\\<forall>A \\<in> FinPow(X). \n  A = 0 \\<or> (A = {Maximum(r,A)} \\<or> P(A - {Maximum(r,A)}) \\<longrightarrow> P(A))\"\n  and A3: \"B \\<in>  FinPow(X)\" and A4: \"B\\<noteq>0\"\n  shows \"P(B)\"\n",
        "proof": "proof -\n  { fix A assume \"A \\<in>  FinPow(X)\" and \"A \\<noteq> 0\"\n    with A1 A2 have\n      \"\\<exists>a\\<in>A. A = {a} \\<or> P(A-{a}) \\<longrightarrow> P(A)\"\n      using IsLinOrder_def fin_has_max\n\tIsLinOrder_def Order_ZF_4_L3\n      by blast\n  } then have \"\\<forall>A \\<in> FinPow(X). \n      A = 0 \\<or> (\\<exists>a\\<in>A. A = {a} \\<or> P(A-{a}) \\<longrightarrow> P(A))\"\n    by auto\n  with A3 A4 show \"P(B)\" using  FinPow_rem_ind\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 169
    },
    "156": {
        "type": "lemma",
        "text": "text\\<open>Yet another induction scheme. We build a linearly ordered\n  set by adding elements that are greater than all elements in the\n  set.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and A2: \"P(0)\" and A3: \"\\<forall> A \\<in> FinPow(X). \n  ( \\<forall> x \\<in> X-A. P(A) \\<and> (\\<forall>a\\<in>A. \\<langle>a,x\\<rangle> \\<in> r ) \\<longrightarrow> P(A \\<union> {x}))\"\n  and A4: \"B \\<in> FinPow(X)\"\n  ",
        "using": [
            "fin_rem_point_fin",
            "linord_max_props"
        ],
        "statement": "lemma fin_ind_add_max: \n  assumes A1: \"IsLinOrder(X,r)\" and A2: \"P(0)\" and A3: \"\\<forall> A \\<in> FinPow(X). \n  ( \\<forall> x \\<in> X-A. P(A) \\<and> (\\<forall>a\\<in>A. \\<langle>a,x\\<rangle> \\<in> r ) \\<longrightarrow> P(A \\<union> {x}))\"\n  and A4: \"B \\<in> FinPow(X)\"\n  shows \"P(B)\"\n",
        "proof": "proof -\n  note A1 A2\n  moreover have\n    \"\\<forall>C \\<in> FinPow(X). C \\<noteq> 0 \\<longrightarrow> (P(C - {Maximum(r,C)}) \\<longrightarrow> P(C))\"\n    proof -\n      { fix C assume \"C \\<in> FinPow(X)\" and \"C \\<noteq> 0\"\n\tlet ?x = \"Maximum(r,C)\"\n\tlet ?A = \"C - {?x}\"\n\tassume \"P(?A)\"\n\tmoreover from \\<open>C \\<in> FinPow(X)\\<close> have \"?A \\<in> FinPow(X)\"\n\t  using fin_rem_point_fin by simp\n\tmoreover from A1 \\<open>C \\<in> FinPow(X)\\<close> \\<open>C \\<noteq> 0\\<close> have \n\t  \"?x \\<in> C\" and \"?x \\<in> X - ?A\" and \"\\<forall>a\\<in>?A. \\<langle>a,?x\\<rangle> \\<in> r\"\n\t  using linord_max_props by auto\n\tmoreover note A3\n\tultimately have \"P(?A \\<union> {?x})\" by auto\n\tmoreover from \\<open>?x \\<in> C\\<close> have \"?A \\<union> {?x} = C\"\n\t  by auto\n\tultimately have \"P(C)\" by simp\n      } thus ?thesis by simp\n    qed\n    moreover note A4\n  ultimately show \"P(B)\" by (rule fin_ord_induction)\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 170
    },
    "157": {
        "type": "theorem",
        "text": "text\\<open>The only order automorphism of a linearly ordered\n  finite set is the identity.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\"\n  and A2: \"B \\<in>  FinPow(X)\" and A3: \"B\\<noteq>0\"\n  ",
        "using": [
            "id_ord_auto_singleton",
            "id_ord_iso",
            "IsLinOrder_def",
            "fin_has_max",
            "ord_iso_rem_max",
            "max_auto_fixpoint",
            "ord_iso_def",
            "bij_is_fun",
            "Order_ZF_4_L3",
            "id_fixpoint_rem"
        ],
        "statement": "theorem fin_ord_auto_id: assumes A1: \"IsLinOrder(X,r)\"\n  and A2: \"B \\<in>  FinPow(X)\" and A3: \"B\\<noteq>0\"\n  shows \"ord_iso(B,r,B,r) = {id(B)}\"\n",
        "proof": "proof -\n  note A1\n  moreover\n  { fix A assume \"A \\<in>  FinPow(X)\" \"A\\<noteq>0\"\n    let ?M = \"Maximum(r,A)\"\n    let ?A\\<^sub>0 = \"A - {?M}\"\n    assume \"A = {?M} \\<or> ord_iso(?A\\<^sub>0,r,?A\\<^sub>0,r) = {id(?A\\<^sub>0)}\"\n    moreover\n    { assume \"A = {?M}\"\n      have \"ord_iso({?M},r,{?M},r) = {id({?M})}\"\n\tusing id_ord_auto_singleton by simp\n      with \\<open>A = {?M}\\<close> have \"ord_iso(A,r,A,r) = {id(A)}\"\n\tby simp }\n    moreover\n    { assume \"ord_iso(?A\\<^sub>0,r,?A\\<^sub>0,r) = {id(?A\\<^sub>0)}\"\n      have \"ord_iso(A,r,A,r) = {id(A)}\"\n      proof\n\tshow \"{id(A)} \\<subseteq> ord_iso(A,r,A,r)\"\n\t  using id_ord_iso by simp\n\t{ fix f assume \"f \\<in> ord_iso(A,r,A,r)\"\n\t  with A1 \\<open>A \\<in>  FinPow(X)\\<close> \\<open>A\\<noteq>0\\<close> have \n\t    \"restrict(f,?A\\<^sub>0) \\<in> ord_iso(?A\\<^sub>0, r, A-{f`(?M)},r)\"\n\t    using IsLinOrder_def fin_has_max ord_iso_rem_max \n\t    by auto\n\t  with A1 \\<open>A \\<in>  FinPow(X)\\<close> \\<open>A\\<noteq>0\\<close> \\<open>f \\<in> ord_iso(A,r,A,r)\\<close>\n\t    \\<open>ord_iso(?A\\<^sub>0,r,?A\\<^sub>0,r) = {id(?A\\<^sub>0)}\\<close>\n\t  have \"restrict(f,?A\\<^sub>0) = id(?A\\<^sub>0)\"\n\t    using IsLinOrder_def fin_has_max max_auto_fixpoint \n\t    by auto\n\t  moreover from A1 \\<open>f \\<in> ord_iso(A,r,A,r)\\<close> \n\t    \\<open>A \\<in>  FinPow(X)\\<close> \\<open>A\\<noteq>0\\<close> have\n\t    \"f : A \\<rightarrow> A\" and \"?M \\<in> A\" and \"f`(?M) = ?M\"\n\t    using ord_iso_def bij_is_fun IsLinOrder_def \n\t      fin_has_max Order_ZF_4_L3 max_auto_fixpoint\n\t    by auto\n\t  ultimately have \"f = id(A)\" using id_fixpoint_rem\n\t    by simp \n\t} then show \"ord_iso(A,r,A,r) \\<subseteq> {id(A)}\"\n\t  by auto\n      qed\n    }\n    ultimately have \"ord_iso(A,r,A,r) = {id(A)}\"\n      by auto\n  } then have \"\\<forall>A \\<in>  FinPow(X). A = 0 \\<or> \n      (A = {Maximum(r,A)} \\<or> \n      ord_iso(A-{Maximum(r,A)},r,A-{Maximum(r,A)},r) = \n      {id(A-{Maximum(r,A)})} \\<longrightarrow>  ord_iso(A,r,A,r) = {id(A)})\"\n    by auto\n  moreover note A2 A3\n  ultimately show \"ord_iso(B,r,B,r) = {id(B)}\"\n    by (rule fin_ord_ind)\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 171
    },
    "158": {
        "type": "lemma",
        "text": "text\\<open>Every two finite linearly ordered sets are order \n  isomorphic. The statement is formulated to make the \n  proof by induction on the size of the set easier, \n  see \\<open>fin_ord_iso_ex\\<close> for an alternative formulation.\n\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and\n  A2: \"n \\<in> nat\" \n  ",
        "using": [
            "eqpoll_0_is_0",
            "empty_ord_iso",
            "eqpoll_succ_imp_not_empty",
            "FinPow_def",
            "ord_linear_subset",
            "IsLinOrder_def",
            "fin_has_max",
            "Order_ZF_4_L3",
            "Diff_sing_eqpoll",
            "fin_rem_point_fin"
        ],
        "statement": "lemma fin_order_iso: \n  assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and\n  A2: \"n \\<in> nat\" \n  shows \"\\<forall>A \\<in> FinPow(X). \\<forall>B \\<in> FinPow(Y).\n  A \\<approx> n \\<and> B \\<approx> n \\<longrightarrow> ord_iso(A,r,B,R) \\<noteq> 0\"\n",
        "proof": "proof -\n  note A2\n  moreover have \"\\<forall>A \\<in> FinPow(X). \\<forall>B \\<in> FinPow(Y).\n    A \\<approx> 0 \\<and> B \\<approx> 0 \\<longrightarrow> ord_iso(A,r,B,R) \\<noteq> 0\"\n    using eqpoll_0_is_0 empty_ord_iso by blast\n  moreover have \"\\<forall>k \\<in> nat.\n    (\\<forall>A \\<in> FinPow(X). \\<forall>B \\<in> FinPow(Y). \n    A \\<approx> k \\<and> B \\<approx> k \\<longrightarrow> ord_iso(A,r,B,R) \\<noteq> 0) \\<longrightarrow>\n    (\\<forall>C \\<in> FinPow(X). \\<forall>D \\<in> FinPow(Y). \n    C \\<approx> succ(k) \\<and> D \\<approx> succ(k) \\<longrightarrow> ord_iso(C,r,D,R) \\<noteq> 0)\"\n  proof -\n    { fix k assume \"k \\<in> nat\"\n      assume A3: \"\\<forall>A \\<in> FinPow(X). \\<forall>B \\<in> FinPow(Y). \n\tA \\<approx> k \\<and> B \\<approx> k \\<longrightarrow> ord_iso(A,r,B,R) \\<noteq> 0\"\n      have \"\\<forall>C \\<in> FinPow(X). \\<forall>D \\<in> FinPow(Y). \n\tC \\<approx> succ(k) \\<and> D \\<approx> succ(k) \\<longrightarrow> ord_iso(C,r,D,R) \\<noteq> 0\"\n      proof -\n\t{ fix C assume \"C \\<in> FinPow(X)\"\n\t  fix D assume \"D \\<in> FinPow(Y)\"\n\t  assume \"C \\<approx> succ(k)\"  \"D \\<approx> succ(k)\"\n\t  then have \"C \\<noteq> 0\" and \"D\\<noteq> 0\"\n\t    using eqpoll_succ_imp_not_empty by auto\n\t  let ?M\\<^sub>C = \"Maximum(r,C)\"\n\t  let ?M\\<^sub>D = \"Maximum(R,D)\"\n\t  let ?C\\<^sub>0 = \"C - {?M\\<^sub>C}\"\n\t  let ?D\\<^sub>0 = \"D - {?M\\<^sub>D}\"\n\t  from \\<open>C \\<in> FinPow(X)\\<close> have \"C \\<subseteq> X\"\n\t    using FinPow_def by simp\n\t  with A1 have \"IsLinOrder(C,r)\"\n\t    using ord_linear_subset by blast\n\t  from \\<open>D \\<in> FinPow(Y)\\<close> have \"D \\<subseteq> Y\"\n\t    using FinPow_def by simp\n\t  with A1 have \"IsLinOrder(D,R)\"\n\t    using ord_linear_subset by blast \n\t  from A1 \\<open>C \\<in> FinPow(X)\\<close> \\<open>D \\<in> FinPow(Y)\\<close>  \n\t    \\<open>C \\<noteq> 0\\<close> \\<open>D\\<noteq> 0\\<close> have \n\t    \"HasAmaximum(r,C)\" and \"HasAmaximum(R,D)\"\n\t    using IsLinOrder_def fin_has_max \n\t    by auto\n\t  with A1 have \"?M\\<^sub>C \\<in> C\" and \"?M\\<^sub>D \\<in> D\"\n\t    using IsLinOrder_def Order_ZF_4_L3 by auto\n\t  with \\<open>C \\<approx> succ(k)\\<close>  \\<open>D \\<approx> succ(k)\\<close> have \n\t    \"?C\\<^sub>0  \\<approx> k\" and \"?D\\<^sub>0 \\<approx> k\" using Diff_sing_eqpoll by auto\n\t  from \\<open>C \\<in> FinPow(X)\\<close> \\<open>D \\<in> FinPow(Y)\\<close>\n\t  have \"?C\\<^sub>0 \\<in>  FinPow(X)\" and \"?D\\<^sub>0 \\<in>  FinPow(Y)\"\n\t    using fin_rem_point_fin by auto\n\t  with A3 \\<open>?C\\<^sub>0  \\<approx> k\\<close> \\<open>?D\\<^sub>0 \\<approx> k\\<close> have\n\t    \"ord_iso(?C\\<^sub>0,r,?D\\<^sub>0,R) \\<noteq> 0\" by simp\n\t  with \\<open>IsLinOrder(C,r)\\<close>  \\<open>IsLinOrder(D,R)\\<close> \n\t    \\<open>HasAmaximum(r,C)\\<close> \\<open>HasAmaximum(R,D)\\<close>\n\t  have \"ord_iso(C,r,D,R) \\<noteq> 0\"\n\t    by (rule rem_max_ord_iso)\n\t} thus ?thesis by simp\n      qed\n    } thus ?thesis by blast\n  qed\n  ultimately show ?thesis by (rule ind_on_nat)\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 172
    },
    "159": {
        "type": "lemma",
        "text": "text\\<open>Every two finite linearly ordered sets are order \n  isomorphic.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and\n  A2: \"A \\<in> FinPow(X)\" \"B \\<in> FinPow(Y)\" and A3: \"B \\<approx> A\"\n  ",
        "using": [
            "finpow_decomp",
            "fin_order_iso"
        ],
        "statement": "lemma fin_ord_iso_ex: \n  assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and\n  A2: \"A \\<in> FinPow(X)\" \"B \\<in> FinPow(Y)\" and A3: \"B \\<approx> A\"\n  shows \"ord_iso(A,r,B,R) \\<noteq> 0\"\n",
        "proof": "proof -\n  from A2 obtain n where \"n \\<in> nat\" and \"A \\<approx> n\"\n    using finpow_decomp by auto\n  from  A3 \\<open>A \\<approx> n\\<close> have \"B \\<approx> n\" by (rule eqpoll_trans)\n  with A1 A2 \\<open>A \\<approx> n\\<close> \\<open>n \\<in> nat\\<close> show \"ord_iso(A,r,B,R) \\<noteq> 0\"\n    using fin_order_iso by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 173
    },
    "160": {
        "type": "theorem",
        "text": "text\\<open>Existence and uniqueness of order isomorphism for two\n  linearly ordered sets with the same number of elements.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and\n  A2: \"A \\<in> FinPow(X)\" \"B \\<in> FinPow(Y)\" and A3: \"B \\<approx> A\"\n  ",
        "using": [
            "fin_ord_iso_ex",
            "ord_iso_sym",
            "fin_ord_auto_id",
            "ord_iso_def",
            "comp_inv_id_eq_bij",
            "eqpoll_0_iff"
        ],
        "statement": "theorem fin_ord_iso_ex_uniq: \n  assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and\n  A2: \"A \\<in> FinPow(X)\" \"B \\<in> FinPow(Y)\" and A3: \"B \\<approx> A\"\n  shows \"\\<exists>!f. f \\<in> ord_iso(A,r,B,R)\"\n",
        "proof": "proof\n  from assms show \"\\<exists>f. f \\<in> ord_iso(A,r,B,R)\"\n    using fin_ord_iso_ex by blast\n  fix f g \n  assume A4: \"f \\<in> ord_iso(A,r,B,R)\"  \"g \\<in> ord_iso(A,r,B,R)\"\n  then have \"converse(g) \\<in> ord_iso(B,R,A,r)\"\n    using ord_iso_sym by simp\n  with \\<open>f \\<in> ord_iso(A,r,B,R)\\<close> have \n    I: \"converse(g) O f \\<in>  ord_iso(A,r,A,r)\"\n    by (rule ord_iso_trans)\n  { assume \"A \\<noteq> 0\"\n    with A1 A2 I have \"converse(g) O f = id(A)\"\n      using fin_ord_auto_id by auto\n    with A4 have \"f = g\" \n      using ord_iso_def comp_inv_id_eq_bij by auto }\n  moreover\n  { assume \"A = 0\"\n    then have \"A \\<approx> 0\" using eqpoll_0_iff\n      by simp\n    with A3 have \"B \\<approx> 0\" by (rule eqpoll_trans)\n    with A4 \\<open>A = 0\\<close> have\n      \"f \\<in> ord_iso(0,r,0,R)\" and  \"g \\<in> ord_iso(0,r,0,R)\"\n      using eqpoll_0_iff by auto\n    then have \"f = g\" by (rule empty_ord_iso_uniq) }\n  ultimately show \"f = g\" \n    using ord_iso_def comp_inv_id_eq_bij\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 174
    },
    "161": {
        "type": "definition",
        "text": "text\\<open>Support of a function is the subset of its domain where the values \n  are not zero.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Supp(f,G,A) \\<equiv> {x \\<in> domain(f). f`(x) \\<noteq> TheNeutralElement(G,A)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 175
    },
    "162": {
        "type": "definition",
        "text": "text\\<open>A finitely supported function is such that its support \n  is in the finite powerset of its domain.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"FinSupp(X,G,A) \\<equiv> {f \\<in> X\\<rightarrow>G. Supp(f,G,A) \\<in> FinPow(X)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 176
    },
    "163": {
        "type": "lemma",
        "text": "text\\<open>We can use theorems proven in the \\<open>monoid0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "monoidAsssum",
            "monoid0_def"
        ],
        "statement": "lemma (in finsupp) monoid0_valid: shows \"monoid0(M,A)\"\n  ",
        "proof": "using monoidAsssum monoid0_def by simp\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 177
    },
    "164": {
        "type": "lemma",
        "text": "text\\<open>The sum of monoid valued functions is a monoid valued function.\\<close>\n",
        "assumes": "assumes \"f:X \\<rightarrow>M\"  \"g:X \\<rightarrow>M\" \n  ",
        "using": [
            "monoid0_valid",
            "monoid0.Group_ZF_2_1_L0A"
        ],
        "statement": "lemma (in finsupp) lifted_op_closed: \n  assumes \"f:X \\<rightarrow>M\"  \"g:X \\<rightarrow>M\" \n  shows \"f\\<oplus>g : X\\<rightarrow>M\"\n",
        "proof": "proof -\n  have \"\\<A> : (X\\<rightarrow>M)\\<times>(X\\<rightarrow>M)\\<rightarrow>(X\\<rightarrow>M)\"\n    using monoid0_valid monoid0.Group_ZF_2_1_L0A\n    by simp\n  with assms show \"f\\<oplus>g : X\\<rightarrow>M\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 178
    },
    "165": {
        "type": "lemma",
        "text": "text\\<open>What is the value of a sum of monoid-valued functions?\\<close>\n",
        "assumes": "assumes \"f:X \\<rightarrow>M\"  \"g:X \\<rightarrow>M\" and \"x \\<in> X\"\n  ",
        "using": [
            "assms",
            "monoid0_valid",
            "monoid0.lifted_val"
        ],
        "statement": "lemma (in finsupp) finsupp_sum_val: \n  assumes \"f:X \\<rightarrow>M\"  \"g:X \\<rightarrow>M\" and \"x \\<in> X\"\n  shows \"(f\\<oplus>g)`(x) = f`(x) \\<ra> g`(x)\"\n  ",
        "proof": "using assms monoid0_valid monoid0.lifted_val\n  by simp  \n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 179
    },
    "166": {
        "type": "lemma",
        "text": "text\\<open>The support of the sum of functions is contained in the union of\n  supports.\\<close>\n",
        "assumes": "assumes \"f:X \\<rightarrow>M\"  \"g:X \\<rightarrow>M\"\n  ",
        "using": [
            "lifted_op_closed",
            "func1_1_L1",
            "Supp_def",
            "finsupp_sum_val",
            "monoid0_valid",
            "monoid0.sum_nonzero_elmnt_nonzero"
        ],
        "statement": "lemma (in finsupp) supp_sum_union: assumes \"f:X \\<rightarrow>M\"  \"g:X \\<rightarrow>M\"\n  shows \"supp(f\\<oplus>g) \\<subseteq> supp(f) \\<union> supp(g)\"\n",
        "proof": "proof -\n  { fix x assume \"x \\<in> supp(f\\<oplus>g)\"\n    from assms have  \"f\\<oplus>g : X\\<rightarrow>M\" using lifted_op_closed\n      by simp\n    with assms \\<open>x \\<in> supp(f\\<oplus>g)\\<close> have  \n      \"x\\<in>X\" and \"f`(x) \\<ra> g`(x) \\<noteq> \\<zero>\"\n      using func1_1_L1 Supp_def finsupp_sum_val by auto\n    with assms have \"x \\<in> (supp(f) \\<union> supp(g))\"\n      using monoid0_valid monoid0.sum_nonzero_elmnt_nonzero\n\tfunc1_1_L1 Supp_def by simp\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 180
    },
    "167": {
        "type": "lemma",
        "text": "text\\<open>The sum of finitely supported functions is \n  finitely supported.\\<close>\n",
        "assumes": "assumes \"f \\<in> \\<M>\"  \"g \\<in> \\<M>\"\n  ",
        "using": [
            "FinSupp_def",
            "union_finpow",
            "supp_sum_union",
            "lifted_op_closed"
        ],
        "statement": "lemma (in finsupp) sum_finsupp: \n  assumes \"f \\<in> \\<M>\"  \"g \\<in> \\<M>\"\n  shows \"f\\<oplus>g \\<in>\\<M> \"\n",
        "proof": "proof -\n  from assms have \n    I: \"f: X\\<rightarrow>M\"  \"g: X\\<rightarrow>M\" and\n    \"supp(f) \\<in> FinPow(X)\" \"supp(g) \\<in> FinPow(X)\"\n    using FinSupp_def by auto\n  then have\n    \"supp(f) \\<union> supp(g) \\<in>  FinPow(X)\" and\n    \"supp(f\\<oplus>g) \\<subseteq> supp(f) \\<union> supp(g)\"\n    using union_finpow supp_sum_union by auto\n  then have \"supp(f\\<oplus>g) \\<in>  FinPow(X)\"\n    by (rule subset_finpow)\n  with I show \"f\\<oplus>g \\<in> \\<M>\" \n    using lifted_op_closed FinSupp_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 181
    },
    "168": {
        "type": "lemma",
        "text": "text\\<open>The neutral element of the lifted (pointwise) \n  operation is the function equal zero everywhere.\n  In the next lemma we show that this is a finitely\n  supported function.\\<close>\n",
        "assumes": "",
        "using": [
            "monoidAsssum",
            "Group_ZF_2_1_L2",
            "monoid0_valid",
            "monoid0.unit_is_neutral",
            "func1_3_L1",
            "func1_3_L2",
            "func1_1_L1",
            "Supp_def",
            "empty_in_finpow",
            "FinSupp_def"
        ],
        "statement": "lemma (in finsupp) const_zero_fin_supp:\n  shows \"TheNeutralElement(X\\<rightarrow>M, \\<A>) \\<in> \\<M>\"\n  ",
        "proof": "using  monoidAsssum Group_ZF_2_1_L2 \n    monoid0_valid monoid0.unit_is_neutral \n    func1_3_L1 func1_3_L2 func1_1_L1 \n    Supp_def empty_in_finpow FinSupp_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 182
    },
    "169": {
        "type": "theorem",
        "text": "text\\<open>Finitely supported functions form a submonoid\n  of all functions with pointwise operation.\\<close>\n",
        "assumes": "",
        "using": [
            "monoid0_valid",
            "monoid0.Group_ZF_2_1_T1",
            "monoid0_def",
            "sum_finsupp",
            "IsOpClosed_def",
            "FinSupp_def",
            "const_zero_fin_supp",
            "monoid0.group0_1_T1"
        ],
        "statement": "theorem (in finsupp) fin_supp_monoid:\n  shows \"IsAmonoid(\\<M>,restrict(\\<A>,\\<M>\\<times>\\<M>))\"\n",
        "proof": "proof -\n  have \"monoid0(X\\<rightarrow>M,\\<A>)\"\n    using monoid0_valid monoid0.Group_ZF_2_1_T1\n      monoid0_def by simp\n  moreover have \n    \"\\<M> {is closed under} \\<A>\"\n    \"\\<M> \\<subseteq> (X\\<rightarrow>M)\"\n    \"TheNeutralElement(X\\<rightarrow>M, \\<A>) \\<in> \\<M>\"\n    using sum_finsupp IsOpClosed_def FinSupp_def\n      const_zero_fin_supp by auto\n  ultimately show ?thesis\n    using monoid0.group0_1_T1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 183
    },
    "170": {
        "type": "lemma",
        "text": "text\\<open>With this additional assumption $(M,A)$ becomes a group\n  and we can use theorems proven in ine \\<open>group0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "monoidAsssum",
            "rinverse",
            "IsAgroup_def",
            "group0_def"
        ],
        "statement": "lemma (in finsupp1) group0_valid: shows \n  \"IsAgroup(M,A)\" and \"group0(M,A)\"\n  ",
        "proof": "using monoidAsssum rinverse  \n    IsAgroup_def group0_def by auto\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 184
    },
    "171": {
        "type": "lemma",
        "text": "text\\<open>Recall from \\<open>Group_ZF_2\\<close> that the function space \n  of $G$ valued functions is also a group.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_valid",
            "group0.Group_ZF_2_1_T2",
            "group0_def"
        ],
        "statement": "lemma (in finsupp1) fungroup0_valid: shows\n  \"IsAgroup(X\\<rightarrow>M,\\<A>)\" and \"group0(X\\<rightarrow>M,\\<A>)\"\n  ",
        "proof": "using group0_valid group0.Group_ZF_2_1_T2\n    group0_def by auto\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 185
    },
    "172": {
        "type": "lemma",
        "text": "text\\<open>The negative of a function with a finite support\n  is a function with a finite support.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<M>\"\n  ",
        "using": [
            "FinSupp_def",
            "func1_1_L1",
            "fungroup0_valid",
            "group0.inverse_in_group",
            "finsupp_neg"
        ],
        "statement": "lemma (in finsupp1) finsupp_neg_finsupp: assumes A1: \"f \\<in> \\<M>\"\n  shows \"GroupInv(X\\<rightarrow>M,\\<A>)`(f) \\<in> \\<M>\"\n",
        "proof": "proof -\n  let ?g = \"GroupInv(X\\<rightarrow>M,\\<A>)`(f)\"\n  from A1 have I: \"f: X\\<rightarrow>M\"  \"supp(f) \\<in> FinPow(X)\"\n    using FinSupp_def func1_1_L1 by auto\n  then have \"?g \\<in> X\\<rightarrow>M\" using \n    fungroup0_valid group0.inverse_in_group by simp\n  moreover from I have \"supp(?g) \\<in> FinPow(X)\"\n    using finsupp_neg by simp\n  ultimately show ?thesis using FinSupp_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 187
    },
    "173": {
        "type": "theorem",
        "text": "text\\<open>Finitely supported functions form a subgroup\n  with pointwise addition of group-valued functions.\n\\<close>\n",
        "assumes": "",
        "using": [
            "const_zero_fin_supp",
            "FinSupp_def",
            "sum_finsupp",
            "IsOpClosed_def",
            "finsupp_neg_finsupp",
            "fungroup0_valid",
            "group0.group0_3_T3"
        ],
        "statement": "theorem (in finsupp1) fin_sup_group:\n  shows \"IsAsubgroup(\\<M>,\\<A>)\"\n",
        "proof": "proof -\n  have \n    \"\\<M> \\<noteq> 0\" and\n    \"\\<M> \\<subseteq> X\\<rightarrow>M\" and\n    \"\\<M> {is closed under} \\<A>\" and\n    \"\\<forall>f\\<in>\\<M>. GroupInv(X\\<rightarrow>M,\\<A>)`(f) \\<in> \\<M>\"\n    using const_zero_fin_supp FinSupp_def\n      sum_finsupp IsOpClosed_def finsupp_neg_finsupp\n    by auto\n  then show \"IsAsubgroup(\\<M>,\\<A>)\"\n    using fungroup0_valid group0.group0_3_T3 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 188
    },
    "174": {
        "type": "definition",
        "text": "text\\<open>In \\<open>Topology_ZF\\<close> theory we consider \n  induced topology that is \n  obtained by taking a subset of a topological space. To show that a topology \n  restricted to a subset is also a topology \n  on that subset we may need a fact that \n  if $T$ is a collection of sets and $A$ is a set then every finite collection\n  $\\{ V_i \\}$ is of the form $V_i=U_i \\cap A$, where $\\{U_i\\}$ is a finite \n  subcollection of $T$. This is one of those trivial \n  facts that require suprisingly \n  long formal proof. \n  Actually, the need for this fact is avoided by requiring intersection \n  two open sets to be open (rather than intersection of \n  a finite number of open sets). \n  Still, the fact is left here as an example of a proof by induction.\n  We will use \\<open>Fin_induct\\<close> lemma from Finite.thy. \n  First we define a property of\n  finite sets that we want to show.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Prfin(T,A,M) \\<equiv> ( (M = 0) | (\\<exists>N\\<in> Fin(T). \\<forall>V\\<in> M. \\<exists> U\\<in> N. (V = U\\<inter>A)))\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 189
    },
    "175": {
        "type": "lemma",
        "text": "text\\<open>Now we show the main induction step in a separate lemma. This will make \n  the proof of the theorem FinRestr below look short and nice. \n  The premises of the \\<open>ind_step\\<close> lemma are those needed by \n  the main induction step in \n  lemma \\<open>Fin_induct\\<close> (see standard Isabelle's Finite.thy).\\<close>\n",
        "assumes": "assumes  A: \"\\<forall> V\\<in> TA. \\<exists> U\\<in>T. V=U\\<inter>A\" \n  and A1: \"W\\<in>TA\" and A2: \"M\\<in> Fin(TA)\" \n  and A3: \"W\\<notin>M\" and A4: \"Prfin(T,A,M)\" \n  ",
        "using": [
            "Prfin_def"
        ],
        "statement": "lemma ind_step: assumes  A: \"\\<forall> V\\<in> TA. \\<exists> U\\<in>T. V=U\\<inter>A\" \n  and A1: \"W\\<in>TA\" and A2: \"M\\<in> Fin(TA)\" \n  and A3: \"W\\<notin>M\" and A4: \"Prfin(T,A,M)\" \n  shows \"Prfin(T,A,cons(W,M))\"\n",
        "proof": "proof -\n  { assume A7: \"M=0\" have \"Prfin(T, A, cons(W, M))\"\n    proof-\n      from A1 A obtain U where A5: \"U\\<in>T\" and A6: \"W=U\\<inter>A\" by fast\n      let ?N = \"{U}\"\n      from A5 have T1: \"?N \\<in> Fin(T)\" by simp\n      from A7 A6 have T2: \"\\<forall>V\\<in> cons(W,M). \\<exists> U\\<in>?N. V=U\\<inter>A\" by simp\n      from A7 T1 T2 show  \"Prfin(T, A, cons(W, M))\" \n\tusing Prfin_def by auto   \n    qed }\n  moreover\n  { assume A8:\"M\\<noteq>0\" have \"Prfin(T, A, cons(W, M))\"\n    proof-\n      from A1 A obtain U where A5: \"U\\<in>T\" and A6:\"W=U\\<inter>A\" by fast\n      from A8 A4 obtain N0 \n\twhere A9: \"N0\\<in> Fin(T)\" and A10: \"\\<forall>V\\<in> M. \\<exists> U0\\<in> N0. (V = U0\\<inter>A)\" \n\tusing Prfin_def by auto\n      let ?N = \"cons(U,N0)\"\n      from A5 A9 have \"?N \\<in> Fin(T)\" by simp\n      moreover from A10 A6 have \"\\<forall>V\\<in> cons(W,M). \\<exists> U\\<in>?N. V=U\\<inter>A\" by simp\n      ultimately have \"\\<exists> N\\<in> Fin(T).\\<forall>V\\<in> cons(W,M). \\<exists> U\\<in>N. V=U\\<inter>A\" by auto\n      with A8 show \"Prfin(T, A, cons(W, M))\" \n\tusing Prfin_def by simp\n    qed }\n  ultimately show ?thesis by auto \nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 190
    },
    "176": {
        "type": "theorem",
        "text": "text\\<open>Now we are ready to prove the statement we need.\\<close>\n",
        "assumes": "assumes A: \"\\<forall> V \\<in> TA. \\<exists> U\\<in> T. V=U\\<inter>A\"\n  ",
        "using": [
            "Prfin_def"
        ],
        "statement": "theorem FinRestr0: assumes A: \"\\<forall> V \\<in> TA. \\<exists> U\\<in> T. V=U\\<inter>A\"\n  shows \"\\<forall> M\\<in> Fin(TA). Prfin(T,A,M)\"\n",
        "proof": "proof -\n  { fix M\n    assume \"M \\<in> Fin(TA)\"\n    moreover have \"Prfin(T,A,0)\" using Prfin_def by simp\n    moreover\n    { fix W M assume \"W\\<in>TA\" \"M\\<in> Fin(TA)\" \"W\\<notin>M\" \"Prfin(T,A,M)\"\n      with A have \"Prfin(T,A,cons(W,M))\" by (rule ind_step) }\n    ultimately have \"Prfin(T,A,M)\" by (rule Fin_induct)\n  } thus ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 191
    },
    "177": {
        "type": "theorem",
        "text": "text\\<open>This is a different form of the above theorem:\\<close>\n",
        "assumes": "assumes A1:\"M\\<in> Fin(TA)\" and A2: \"M\\<noteq>0\" \n  and A3: \"\\<forall> V\\<in> TA. \\<exists> U\\<in> T. V=U\\<inter>A\"\n  ",
        "using": [
            "FinRestr0",
            "A2",
            "Prfin_def"
        ],
        "statement": "theorem ZF1FinRestr: \n  assumes A1:\"M\\<in> Fin(TA)\" and A2: \"M\\<noteq>0\" \n  and A3: \"\\<forall> V\\<in> TA. \\<exists> U\\<in> T. V=U\\<inter>A\"\n  shows \"\\<exists>N\\<in> Fin(T). (\\<forall>V\\<in> M. \\<exists> U\\<in> N. (V = U\\<inter>A)) \\<and> N\\<noteq>0\"\n",
        "proof": "proof -\n  from A3 A1 have \"Prfin(T,A,M)\" using FinRestr0 by blast\n  then have \"\\<exists>N\\<in> Fin(T). \\<forall>V\\<in> M. \\<exists> U\\<in> N. (V = U\\<inter>A)\" \n    using A2 Prfin_def by simp\n  then obtain N where \n    D1:\"N\\<in> Fin(T) \\<and> (\\<forall>V\\<in> M. \\<exists> U\\<in> N. (V = U\\<inter>A))\" by auto\n  with A2 have \"N\\<noteq>0\" by auto\n  with D1 show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 192
    },
    "178": {
        "type": "lemma",
        "text": "text\\<open>Purely technical lemma used in \\<open>Topology_ZF_1\\<close> to show \n  that if a topology is $T_2$, then it is $T_1$.\\<close>\n",
        "assumes": "assumes A:\"\\<exists>U V. (U\\<in>T \\<and> V\\<in>T \\<and> x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0)\"\n  ",
        "using": [],
        "statement": "lemma Finite1_L2: \n  assumes A:\"\\<exists>U V. (U\\<in>T \\<and> V\\<in>T \\<and> x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0)\"\n  shows \"\\<exists>U\\<in>T. (x\\<in>U \\<and> y\\<notin>U)\"\n",
        "proof": "proof -\n  from A obtain U V where D1:\"U\\<in>T \\<and> V\\<in>T \\<and> x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n  with D1 show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 193
    },
    "179": {
        "type": "lemma",
        "text": "text\\<open>A collection closed with respect to taking a union of two sets \n  is closed under taking finite unions. Proof by induction with \n  the induction step formulated in a separate lemma.\\<close>\n",
        "assumes": "assumes A1:\"\\<forall>A B. ((A\\<in>C \\<and> B\\<in>C) \\<longrightarrow> A\\<union>B\\<in>C)\" \n  and A2: \"A\\<in>C\" and A3: \"N\\<in>Fin(C)\" and A4:\"A\\<notin>N\" and A5:\"\\<Union>N \\<in> C\" \n  ",
        "using": [],
        "statement": "lemma Finite1_L3_IndStep: \n  assumes A1:\"\\<forall>A B. ((A\\<in>C \\<and> B\\<in>C) \\<longrightarrow> A\\<union>B\\<in>C)\" \n  and A2: \"A\\<in>C\" and A3: \"N\\<in>Fin(C)\" and A4:\"A\\<notin>N\" and A5:\"\\<Union>N \\<in> C\" \n  shows \"\\<Union>cons(A,N) \\<in> C\"\n",
        "proof": "proof -\n  have \"\\<Union> cons(A,N) = A\\<union> \\<Union>N\" by blast\n  with A1 A2 A5 show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 194
    },
    "180": {
        "type": "lemma",
        "text": "text\\<open>The lemma: a collection closed with respect to taking a union of two sets \n  is closed under taking finite unions.\\<close>\n",
        "assumes": "assumes A1: \"0 \\<in> C\" and A2: \"\\<forall>A B. ((A\\<in>C \\<and> B\\<in>C) \\<longrightarrow> A\\<union>B\\<in>C)\" and \n  A3: \"N\\<in> Fin(C)\"\n  ",
        "using": [],
        "statement": "lemma Finite1_L3:\n  assumes A1: \"0 \\<in> C\" and A2: \"\\<forall>A B. ((A\\<in>C \\<and> B\\<in>C) \\<longrightarrow> A\\<union>B\\<in>C)\" and \n  A3: \"N\\<in> Fin(C)\"\n  shows \"\\<Union>N\\<in>C\"\n",
        "proof": "proof -\n  note A3\n  moreover from A1 have \"\\<Union>0 \\<in> C\" by simp\n  moreover \n  { fix A N \n    assume \"A\\<in>C\" \"N\\<in>Fin(C)\" \"A\\<notin>N\" \"\\<Union>N \\<in> C\" \n    with A2 have \"\\<Union>cons(A,N) \\<in> C\" by (rule Finite1_L3_IndStep) } \n  ultimately show \"\\<Union>N\\<in> C\" by (rule Fin_induct)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 195
    },
    "181": {
        "type": "definition",
        "text": "text\\<open>A collection closed with respect to taking a intersection of two sets \n  is closed under taking finite intersections. \n  Proof by induction with \n  the induction step formulated in a separate lemma. This is sligltly more \n  involved than the union case in \\<open>Finite1_L3\\<close>, because the intersection\n  of empty collection is undefined (or should be treated as such). \n  To simplify notation we define the property to be proven for finite sets \n  as a separate notion.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IntPr(T,N) \\<equiv> (N = 0 | \\<Inter>N \\<in> T)\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 196
    },
    "182": {
        "type": "lemma",
        "text": "text\\<open>The induction step.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>A B. ((A\\<in>T \\<and> B\\<in>T) \\<longrightarrow> A\\<inter>B\\<in>T)\"\n  and A2: \"A\\<in>T\" and A3:\"N\\<in>Fin(T)\" and A4:\"A\\<notin>N\" and A5:\"IntPr(T,N)\"\n  ",
        "using": [
            "IntPr_def"
        ],
        "statement": "lemma Finite1_L4_IndStep:\n  assumes A1: \"\\<forall>A B. ((A\\<in>T \\<and> B\\<in>T) \\<longrightarrow> A\\<inter>B\\<in>T)\"\n  and A2: \"A\\<in>T\" and A3:\"N\\<in>Fin(T)\" and A4:\"A\\<notin>N\" and A5:\"IntPr(T,N)\"\n  shows \"IntPr(T,cons(A,N))\"\n",
        "proof": "proof -\n  { assume A6: \"N=0\" \n    with A2 have \"IntPr(T,cons(A,N))\"\n      using IntPr_def by simp }\n  moreover\n  { assume A7: \"N\\<noteq>0\" have \"IntPr(T, cons(A, N))\"\n    proof -\n      from A7 A5 A2 A1 have \"\\<Inter>N \\<inter> A \\<in> T\" using IntPr_def by simp\n      moreover from A7 have \"\\<Inter>cons(A, N) = \\<Inter>N \\<inter> A\" by auto\n      ultimately show \"IntPr(T, cons(A, N))\" using IntPr_def by simp\n    qed }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 197
    },
    "183": {
        "type": "lemma",
        "text": "text\\<open>The lemma.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>A B. A\\<in>T \\<and> B\\<in>T \\<longrightarrow> A\\<inter>B \\<in> T\"\n  and A2: \"N\\<in>Fin(T)\"\n  ",
        "using": [
            "IntPr_def"
        ],
        "statement": "lemma Finite1_L4:  \n  assumes A1: \"\\<forall>A B. A\\<in>T \\<and> B\\<in>T \\<longrightarrow> A\\<inter>B \\<in> T\"\n  and A2: \"N\\<in>Fin(T)\"\n  shows \"IntPr(T,N)\"\n",
        "proof": "proof -\n  note A2\n  moreover have \"IntPr(T,0)\" using IntPr_def by simp\n  moreover \n  { fix A N \n    assume \"A\\<in>T\" \"N\\<in>Fin(T)\" \"A\\<notin>N\" \"IntPr(T,N)\"\n    with A1 have  \"IntPr(T,cons(A,N))\" by (rule Finite1_L4_IndStep) }\n  ultimately show \"IntPr(T,N)\" by (rule Fin_induct)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 198
    },
    "184": {
        "type": "lemma",
        "text": "text\\<open>Next is a restatement of the above lemma that \n  does not depend on the IntPr meta-function.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>A B. ((A\\<in>T \\<and> B\\<in>T) \\<longrightarrow> A\\<inter>B\\<in>T)\" \n  and A2: \"N\\<noteq>0\" and A3: \"N\\<in>Fin(T)\"\n  ",
        "using": [
            "Finite1_L4",
            "IntPr_def"
        ],
        "statement": "lemma Finite1_L5: \n  assumes A1: \"\\<forall>A B. ((A\\<in>T \\<and> B\\<in>T) \\<longrightarrow> A\\<inter>B\\<in>T)\" \n  and A2: \"N\\<noteq>0\" and A3: \"N\\<in>Fin(T)\"\n  shows \"\\<Inter>N \\<in> T\"\n",
        "proof": "proof -\n  from A1 A3 have \"IntPr(T,N)\" using Finite1_L4 by simp\n  with A2 show ?thesis using IntPr_def by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 199
    },
    "185": {
        "type": "lemma",
        "text": "text\\<open>The images of finite subsets by a meta-function are finite. \n  For example in topology if we have a finite collection of sets, then closing \n  each of them results in a finite collection of closed sets. This is a very \n  useful lemma with many unexpected applications.\n  The proof is by induction. The next lemma is the induction step.\\<close>\n",
        "assumes": "assumes \"\\<forall>V\\<in>B. K(V)\\<in>C\"\n  and \"U\\<in>B\" and \"N\\<in>Fin(B)\" and \"U\\<notin>N\" and \"{K(V). V\\<in>N}\\<in>Fin(C)\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma fin_image_fin_IndStep: \n  assumes \"\\<forall>V\\<in>B. K(V)\\<in>C\"\n  and \"U\\<in>B\" and \"N\\<in>Fin(B)\" and \"U\\<notin>N\" and \"{K(V). V\\<in>N}\\<in>Fin(C)\"\n  shows \"{K(V). V\\<in>cons(U,N)} \\<in> Fin(C)\"\n  ",
        "proof": "using assms by simp\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 200
    },
    "186": {
        "type": "lemma",
        "text": "text\\<open>The lemma:\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>V\\<in>B. K(V)\\<in>C\" and A2: \"N\\<in>Fin(B)\"\n  ",
        "using": [],
        "statement": "lemma fin_image_fin: \n  assumes A1: \"\\<forall>V\\<in>B. K(V)\\<in>C\" and A2: \"N\\<in>Fin(B)\"\n  shows \"{K(V). V\\<in>N} \\<in> Fin(C)\"\n",
        "proof": "proof -\n  note A2\n  moreover have \"{K(V). V\\<in>0} \\<in> Fin(C)\" by simp\n  moreover\n  { fix U N\n    assume \"U\\<in>B\" \"N\\<in>Fin(B)\" \"U\\<notin>N\" \"{K(V). V\\<in>N}\\<in>Fin(C)\"\n    with A1 have \"{K(V). V\\<in>cons(U,N)} \\<in> Fin(C)\"\n      by (rule fin_image_fin_IndStep) }\n  ultimately show ?thesis by (rule Fin_induct)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 201
    },
    "187": {
        "type": "lemma",
        "text": "text\\<open>The image of a finite set is finite.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"N \\<in> Fin(X)\"\n  ",
        "using": [
            "apply_type",
            "FinD",
            "func_imagedef"
        ],
        "statement": "lemma Finite1_L6A: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"N \\<in> Fin(X)\"\n  shows \"f``(N) \\<in> Fin(Y)\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>x\\<in>X. f`(x) \\<in> Y\" \n    using apply_type by simp\n  moreover note A2\n  ultimately have \"{f`(x). x\\<in>N} \\<in> Fin(Y)\"\n    by (rule fin_image_fin)\n  with A1 A2 show ?thesis\n    using FinD func_imagedef by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 202
    },
    "188": {
        "type": "lemma",
        "text": "text\\<open>If the set defined by a meta-function is finite, then every set \n  defined by a composition of this meta function with another one is finite.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>X. a(x) \\<in> Y\" and A2: \"{b(y).y\\<in>Y} \\<in> Fin(Z)\"\n  ",
        "using": [
            "Fin_subset_lemma"
        ],
        "statement": "lemma Finite1_L6B: \n  assumes A1: \"\\<forall>x\\<in>X. a(x) \\<in> Y\" and A2: \"{b(y).y\\<in>Y} \\<in> Fin(Z)\"\n  shows \"{b(a(x)).x\\<in>X} \\<in> Fin(Z)\"\n",
        "proof": "proof -\n  from A1 have \"{b(a(x)).x\\<in>X} \\<subseteq> {b(y).y\\<in>Y}\" by auto\n  with A2 show ?thesis using Fin_subset_lemma by blast\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 203
    },
    "189": {
        "type": "lemma",
        "text": "text\\<open>Cartesian product of finite sets is finite.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> Fin(A)\" and A2: \"B \\<in> Fin(B)\"\n  ",
        "using": [
            "Fin_UnionI"
        ],
        "statement": "lemma Finite1_L12: assumes A1: \"A \\<in> Fin(A)\" and A2: \"B \\<in> Fin(B)\"\n  shows \"A\\<times>B \\<in> Fin(A\\<times>B)\"\n",
        "proof": "proof -\n  have T1:\"\\<forall>a\\<in>A. \\<forall>b\\<in>B. {\\<langle> a,b\\<rangle>} \\<in> Fin(A\\<times>B)\" by simp\n  have \"\\<forall>a\\<in>A. {{\\<langle> a,b\\<rangle>}. b \\<in> B} \\<in> Fin(Fin(A\\<times>B))\"\n  proof\n    fix a assume A3: \"a \\<in> A\"\n    with T1 have \"\\<forall>b\\<in>B. {\\<langle> a,b\\<rangle>} \\<in> Fin(A\\<times>B)\" \n      by simp\n    moreover note A2\n    ultimately show \"{{\\<langle> a,b\\<rangle>}. b \\<in> B} \\<in> Fin(Fin(A\\<times>B))\"\n      by (rule fin_image_fin)\n  qed\n  then have \"\\<forall>a\\<in>A. \\<Union> {{\\<langle> a,b\\<rangle>}. b \\<in> B} \\<in> Fin(A\\<times>B)\"\n    using Fin_UnionI by simp\n  moreover have \n    \"\\<forall>a\\<in>A. \\<Union> {{\\<langle> a,b\\<rangle>}. b \\<in> B} = {a}\\<times> B\" by blast\n  ultimately have \"\\<forall>a\\<in>A. {a}\\<times> B \\<in> Fin(A\\<times>B)\" by simp\n  moreover note A1 \n  ultimately have \"{{a}\\<times> B. a\\<in>A} \\<in> Fin(Fin(A\\<times>B))\"\n    by (rule fin_image_fin)\n  then have \"\\<Union>{{a}\\<times> B. a\\<in>A} \\<in> Fin(A\\<times>B)\"\n    using Fin_UnionI by simp\n  moreover have \"\\<Union>{{a}\\<times> B. a\\<in>A} = A\\<times>B\" by blast\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 205
    },
    "190": {
        "type": "definition",
        "text": "text\\<open>We define the characterisic meta-function that is the identity\n  on a set and assigns a default value everywhere else.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Characteristic(A,default,x) \\<equiv> (if x\\<in>A then x else default)\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 206
    },
    "191": {
        "type": "lemma",
        "text": "text\\<open>A finite subset is a finite subset of itself.\\<close>\n",
        "assumes": "assumes A1:\"A \\<in> Fin(X)\" ",
        "using": [
            "Characteristic_def"
        ],
        "statement": "lemma Finite1_L13: \n  assumes A1:\"A \\<in> Fin(X)\" shows \"A \\<in> Fin(A)\"\n",
        "proof": "proof -\n  { assume \"A=0\" hence \"A \\<in> Fin(A)\" by simp }\n  moreover\n  { assume A2: \"A\\<noteq>0\" then obtain c where D1:\"c\\<in>A\" \n      by auto\n    then have \"\\<forall>x\\<in>X. Characteristic(A,c,x) \\<in> A\"\n      using Characteristic_def by simp\n    moreover note A1\n    ultimately have \n      \"{Characteristic(A,c,x). x\\<in>A} \\<in> Fin(A)\" by (rule fin_image_fin)\n    moreover from D1 have \n      \"{Characteristic(A,c,x). x\\<in>A} = A\" using Characteristic_def by simp\n    ultimately have \"A \\<in> Fin(A)\" by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 207
    },
    "192": {
        "type": "lemma",
        "text": "text\\<open>Cartesian product of finite subsets is a finite subset of \n  cartesian product.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> Fin(X)\" \"B \\<in> Fin(Y)\"\n  ",
        "using": [
            "FinD",
            "Fin_mono",
            "Finite1_L13",
            "Finite1_L12"
        ],
        "statement": "lemma Finite1_L14: assumes A1: \"A \\<in> Fin(X)\" \"B \\<in> Fin(Y)\"\n  shows \"A\\<times>B \\<in> Fin(X\\<times>Y)\"\n",
        "proof": "proof -\n  from A1 have \"A\\<times>B \\<subseteq> X\\<times>Y\" using FinD by auto\n  then have \"Fin(A\\<times>B) \\<subseteq> Fin(X\\<times>Y)\" using Fin_mono by simp\n  moreover from A1 have \"A\\<times>B \\<in> Fin(A\\<times>B)\"\n    using Finite1_L13 Finite1_L12 by simp\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 208
    },
    "193": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is needed in the \\<open>Group_ZF_3\\<close> theory in a \n  couple of places.\\<close>\n",
        "assumes": "assumes A1: \"{b(x). x\\<in>A} \\<in> Fin(B)\"  \"{c(x). x\\<in>A} \\<in> Fin(C)\"\n  and A2: \"f : B\\<times>C\\<rightarrow>E\"\n  ",
        "using": [
            "Finite1_L14",
            "Finite1_L6A",
            "FinD",
            "func1_1_L17"
        ],
        "statement": "lemma Finite1_L15: \n  assumes A1: \"{b(x). x\\<in>A} \\<in> Fin(B)\"  \"{c(x). x\\<in>A} \\<in> Fin(C)\"\n  and A2: \"f : B\\<times>C\\<rightarrow>E\"\n  shows \"{f`\\<langle> b(x),c(x)\\<rangle>. x\\<in>A} \\<in> Fin(E)\"\n",
        "proof": "proof -\n  from A1 have \"{b(x). x\\<in>A}\\<times>{c(x). x\\<in>A} \\<in> Fin(B\\<times>C)\"\n    using Finite1_L14 by simp\n  moreover have \n    \"{\\<langle> b(x),c(x)\\<rangle>. x\\<in>A} \\<subseteq> {b(x). x\\<in>A}\\<times>{c(x). x\\<in>A}\" \n    by blast\n  ultimately have T0: \"{\\<langle> b(x),c(x)\\<rangle>. x\\<in>A} \\<in> Fin(B\\<times>C)\"\n    by (rule Fin_subset_lemma)\n  with A2 have T1: \"f``{\\<langle> b(x),c(x)\\<rangle>. x\\<in>A} \\<in> Fin(E)\"\n    using Finite1_L6A by auto\n  from T0 have \"\\<forall>x\\<in>A. \\<langle> b(x),c(x)\\<rangle> \\<in> B\\<times>C\"\n    using FinD by auto\n  with A2 have \n    \"f``{\\<langle> b(x),c(x)\\<rangle>. x\\<in>A} = {f`\\<langle> b(x),c(x)\\<rangle>. x\\<in>A}\"\n    using func1_1_L17 by simp\n  with T1 show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 209
    },
    "194": {
        "type": "lemma",
        "text": "text\\<open>Singletons are in the finite powerset.\\<close>\n",
        "assumes": "assumes \"x\\<in>X\" ",
        "using": [
            "assms",
            "emptyI",
            "consI"
        ],
        "statement": "lemma Finite1_L16: assumes \"x\\<in>X\" shows \"{x} \\<in> Fin(X)\"\n  ",
        "proof": "using assms emptyI consI by simp\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 210
    },
    "195": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>Finite1_L15\\<close> where the second\n  set is a singleton. In \\<open>Group_ZF_3\\<close> theory this corresponds \n  to the situation where we multiply by a constant.\\<close>\n",
        "assumes": "assumes \"{b(x). x\\<in>A} \\<in> Fin(B)\" \n  and \"c\\<in>C\" and \"f : B\\<times>C\\<rightarrow>E\"\n  ",
        "using": [
            "apply_funtype"
        ],
        "statement": "lemma Finite1_L16AA: assumes \"{b(x). x\\<in>A} \\<in> Fin(B)\" \n  and \"c\\<in>C\" and \"f : B\\<times>C\\<rightarrow>E\"\n  shows \"{f`\\<langle> b(x),c\\<rangle>. x\\<in>A} \\<in> Fin(E)\"\n",
        "proof": "proof -\n  from assms have \n    \"\\<forall>y\\<in>B. f`\\<langle>y,c\\<rangle> \\<in> E\"\n    \"{b(x). x\\<in>A} \\<in> Fin(B)\"\n    using apply_funtype by auto\n  then show ?thesis by (rule Finite1_L6C)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 211
    },
    "196": {
        "type": "lemma",
        "text": "text\\<open>First order version of the induction for the finite powerset.\\<close>\n",
        "assumes": "assumes A1: \"P(0)\" and A2: \"B\\<in>Fin(X)\"\n  and A3: \"\\<forall>A\\<in>Fin(X).\\<forall>x\\<in>X. x\\<notin>A \\<and> P(A)\\<longrightarrow>P(A\\<union>{x})\"\n  ",
        "using": [],
        "statement": "lemma Finite1_L16B: assumes A1: \"P(0)\" and A2: \"B\\<in>Fin(X)\"\n  and A3: \"\\<forall>A\\<in>Fin(X).\\<forall>x\\<in>X. x\\<notin>A \\<and> P(A)\\<longrightarrow>P(A\\<union>{x})\"\n  shows \"P(B)\"\n",
        "proof": "proof -\n  note \\<open>B\\<in>Fin(X)\\<close> and \\<open>P(0)\\<close>\n  moreover\n  { fix A x\n    assume  \"x \\<in> X\"  \"A \\<in> Fin(X)\"  \"x \\<notin> A\"  \"P(A)\"\n    moreover have \"cons(x,A) = A\\<union>{x}\" by auto\n    moreover note A3\n    ultimately have \"P(cons(x,A))\" by simp }\n  ultimately show  \"P(B)\" by (rule Fin_induct)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 212
    },
    "197": {
        "type": "definition",
        "text": "text\\<open>Definition of finite range functions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"FinRangeFunctions(X,Y) \\<equiv> {f:X\\<rightarrow>Y. f``(X) \\<in> Fin(Y)}\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 213
    },
    "198": {
        "type": "lemma",
        "text": "text\\<open>Constant functions have finite range.\\<close>\n",
        "assumes": "assumes \"c\\<in>Y\" and \"X\\<noteq>0\"\n  ",
        "using": [
            "assms",
            "func1_3_L1",
            "func_imagedef",
            "func1_3_L2",
            "Finite1_L16",
            "FinRangeFunctions_def"
        ],
        "statement": "lemma Finite1_L17: assumes \"c\\<in>Y\" and \"X\\<noteq>0\"\n  shows \"ConstantFunction(X,c) \\<in> FinRangeFunctions(X,Y)\"\n  ",
        "proof": "using assms  func1_3_L1 func_imagedef func1_3_L2 Finite1_L16 \n    FinRangeFunctions_def by simp\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 214
    },
    "199": {
        "type": "lemma",
        "text": "text\\<open>Finite range functions have finite range.\\<close>\n",
        "assumes": "assumes \"f \\<in> FinRangeFunctions(X,Y)\"\n  ",
        "using": [
            "assms",
            "FinRangeFunctions_def",
            "func_imagedef"
        ],
        "statement": "lemma Finite1_L18: assumes \"f \\<in> FinRangeFunctions(X,Y)\"\n  shows \"{f`(x). x\\<in>X} \\<in> Fin(Y)\"\n  ",
        "proof": "using assms FinRangeFunctions_def func_imagedef by simp\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 215
    },
    "200": {
        "type": "lemma",
        "text": "text\\<open>An alternative form of the definition of finite range functions.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\"\n  and \"{f`(x). x\\<in>X} \\<in> Fin(Y)\"\n  ",
        "using": [
            "assms",
            "func_imagedef",
            "FinRangeFunctions_def"
        ],
        "statement": "lemma Finite1_L19: assumes \"f:X\\<rightarrow>Y\"\n  and \"{f`(x). x\\<in>X} \\<in> Fin(Y)\"\n  shows \"f \\<in> FinRangeFunctions(X,Y)\"\n  ",
        "proof": "using assms func_imagedef FinRangeFunctions_def by simp\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 216
    },
    "201": {
        "type": "lemma",
        "text": "text\\<open>A composition of a finite range function with another function is \n  a finite range function.\\<close>\n",
        "assumes": "assumes A1:\"f \\<in> FinRangeFunctions(X,Y)\"\n  and A2: \"g : Y\\<rightarrow>Z\"\n  ",
        "using": [
            "Finite1_L18",
            "Finite1_L6A",
            "FinRangeFunctions_def",
            "apply_funtype",
            "func1_1_L17",
            "comp_fun_apply",
            "comp_fun",
            "Finite1_L19"
        ],
        "statement": "lemma Finite1_L20: assumes A1:\"f \\<in> FinRangeFunctions(X,Y)\"\n  and A2: \"g : Y\\<rightarrow>Z\"\n  shows \"g O f \\<in> FinRangeFunctions(X,Z)\"\n",
        "proof": "proof - \n  from A1 A2 have \"g``{f`(x). x\\<in>X} \\<in> Fin(Z)\"\n    using Finite1_L18 Finite1_L6A\n    by simp\n  with A1 A2 have \"{(g O f)`(x). x\\<in>X} \\<in> Fin(Z)\"\n    using FinRangeFunctions_def apply_funtype \n      func1_1_L17 comp_fun_apply by auto\n  with A1 A2 show ?thesis using \n    FinRangeFunctions_def comp_fun Finite1_L19\n    by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 217
    },
    "202": {
        "type": "lemma",
        "text": "text\\<open>Image of any subset of the domain of a finite range function is finite.\\<close>\n",
        "assumes": "assumes \"f \\<in> FinRangeFunctions(X,Y)\" and \"A\\<subseteq>X\"\n  ",
        "using": [
            "FinRangeFunctions_def",
            "func1_1_L8",
            "Fin_subset_lemma"
        ],
        "statement": "lemma Finite1_L21: \n  assumes \"f \\<in> FinRangeFunctions(X,Y)\" and \"A\\<subseteq>X\"\n  shows \"f``(A) \\<in> Fin(Y)\" \n",
        "proof": "proof -\n  from assms have \"f``(X) \\<in> Fin(Y)\"  \"f``(A) \\<subseteq> f``(X)\"\n    using FinRangeFunctions_def func1_1_L8\n    by auto\n  then show \"f``(A) \\<in> Fin(Y)\" using Fin_subset_lemma\n    by blast\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 218
    },
    "203": {
        "type": "definition",
        "text": "text\\<open>We define the set of lists with values in set $X$ as \\<open>Lists(X)\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Lists(X) \\<equiv> \\<Union>n\\<in>nat.(n\\<rightarrow>X)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 219
    },
    "204": {
        "type": "definition",
        "text": "text\\<open>The set of nonempty $X$-value listst will be called \\<open>NELists(X)\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"NELists(X) \\<equiv> \\<Union>n\\<in>nat.(succ(n)\\<rightarrow>X)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 220
    },
    "205": {
        "type": "definition",
        "text": "text\\<open>We first define the shift that moves the second sequence\n  to the domain $\\{n,..,n+k-1\\}$, where $n,k$ are the lengths of the first \n  and the second sequence, resp.  \n  To understand the notation in the definitions below recall that in Isabelle/ZF \n  \\<open>pred(n)\\<close> is the previous natural number and  \n   denotes the difference between natural numbers $n$ and $k$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ShiftedSeq(b,n) \\<equiv> {\\<langle>j, b`(j #- n)\\<rangle>. j \\<in> NatInterval(n,domain(b))}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 221
    },
    "206": {
        "type": "definition",
        "text": "text\\<open>For a finite sequence we define the sequence of all elements \n  except the first one. This corresponds to the \"tail\" function in Haskell.\n  We call it \\<open>Tail\\<close> here as well.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition  \n  \"Tail(a) \\<equiv> {\\<langle>k, a`(succ(k))\\<rangle>. k \\<in> pred(domain(a))}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 223
    },
    "207": {
        "type": "definition",
        "text": "text\\<open>A dual notion to \\<open>Tail\\<close> is the list\n  of all elements of a list except the last one. Borrowing\n  the terminology from Haskell again, we will call this \\<open>Init\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Init(a) \\<equiv> restrict(a,pred(domain(a)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 224
    },
    "208": {
        "type": "definition",
        "text": "text\\<open>Another obvious operation we can talk about is appending an element\n  at the end of a sequence. This is called \\<open>Append\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Append(a,x) \\<equiv> a \\<union> {\\<langle>domain(a),x\\<rangle>}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 225
    },
    "209": {
        "type": "definition",
        "text": "text\\<open>If lists are modeled as finite sequences (i.e. functions on natural \n  intervals $\\{0,1,..,n-1\\} = n$) it is easy to get the first element\n  of a list as the value of the sequence at $0$. The last element is the\n  value at $n-1$. To hide this behind a familiar name we define the \\<open>Last\\<close>\n  element of a list.\\<close> \n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Last(a) \\<equiv> a`(pred(domain(a)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 226
    },
    "210": {
        "type": "lemma",
        "text": "text\\<open>A formula for tail of a finite list.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"a: n #+ 1 \\<rightarrow> X\"\n  ",
        "using": [
            "assms",
            "func1_1_L1",
            "elem_nat_is_nat(2)",
            "succ_add_one(1)",
            "Tail_def"
        ],
        "statement": "lemma tail_as_set: assumes \"n \\<in> nat\" and \"a: n #+ 1 \\<rightarrow> X\"\n  shows \"Tail(a) = {\\<langle>k,a`(k #+ 1)\\<rangle>. k\\<in>n}\"\n  ",
        "proof": "using assms func1_1_L1 elem_nat_is_nat(2) succ_add_one(1) \n  unfolding Tail_def by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 227
    },
    "211": {
        "type": "lemma",
        "text": "text\\<open>Codomain of a nonempty list is nonempty.\\<close>\n",
        "assumes": "assumes \"a:succ(n)\\<rightarrow>Y\"\n  ",
        "using": [
            "assms",
            "codomain_nonempty"
        ],
        "statement": "lemma nelist_vals_nonempty: assumes \"a:succ(n)\\<rightarrow>Y\"\n  shows \"Y\\<noteq>0\" ",
        "proof": "using assms codomain_nonempty by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 229
    },
    "212": {
        "type": "lemma",
        "text": "text\\<open>Shifted sequence is a function on a the interval of natural numbers.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and A2: \"b:k\\<rightarrow>X\"\n  ",
        "using": [
            "func1_1_L1",
            "inter_diff_in_len",
            "apply_funtype",
            "ShiftedSeq_def",
            "elem_nat_is_nat",
            "diff_add_inverse",
            "NatInterval_def"
        ],
        "statement": "lemma shifted_seq_props: \n  assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and A2: \"b:k\\<rightarrow>X\"\n  shows \n  \"ShiftedSeq(b,n): NatInterval(n,k) \\<rightarrow> X\"\n  \"\\<forall>i \\<in> NatInterval(n,k). ShiftedSeq(b,n)`(i) = b`(i #- n)\"\n  \"\\<forall>j\\<in>k. ShiftedSeq(b,n)`(n #+ j) = b`(j)\"   \n",
        "proof": "proof -\n  let ?I = \"NatInterval(n,domain(b))\"\n  from A2 have Fact: \"?I = NatInterval(n,k)\" using func1_1_L1 by simp\n  with A1 A2 have \"\\<forall>j\\<in> ?I. b`(j #- n) \\<in> X\" \n    using inter_diff_in_len apply_funtype by simp\n  then have \n    \"{\\<langle>j, b`(j #- n)\\<rangle>. j \\<in> ?I} : ?I \\<rightarrow> X\" by (rule ZF_fun_from_total)\n  with Fact show thesis_1: \"ShiftedSeq(b,n): NatInterval(n,k) \\<rightarrow> X\"\n    using ShiftedSeq_def by simp\n  { fix i \n    from Fact thesis_1 have  \"ShiftedSeq(b,n): ?I \\<rightarrow> X\" by simp\n    moreover \n    assume \"i \\<in> NatInterval(n,k)\"\n    with Fact have \"i \\<in> ?I\" by simp\n    moreover from Fact have \n      \"ShiftedSeq(b,n) = {\\<langle>i, b`(i #- n)\\<rangle>. i \\<in> ?I}\"\n      using ShiftedSeq_def by simp\n    ultimately have \"ShiftedSeq(b,n)`(i) =  b`(i #- n)\"\n      by (rule ZF_fun_from_tot_val)\n  } then show thesis1: \n      \"\\<forall>i \\<in> NatInterval(n,k). ShiftedSeq(b,n)`(i) = b`(i #- n)\"\n    by simp\n  { fix j \n    let ?i = \"n #+ j\"\n    assume A3: \"j\\<in>k\"\n    with A1 have \"j \\<in> nat\" using elem_nat_is_nat by blast\n    then have \"?i #- n = j\" using diff_add_inverse by simp\n    with A3 thesis1 have \"ShiftedSeq(b,n)`(?i) = b`(j)\"\n      using NatInterval_def by auto\n  } then show \"\\<forall>j\\<in>k. ShiftedSeq(b,n)`(n #+ j) = b`(j)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 230
    },
    "213": {
        "type": "theorem",
        "text": "text\\<open>Basis properties of the contatenation of two finite sequences.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"\n  ",
        "using": [
            "shifted_seq_props",
            "length_start_decomp",
            "func1_1_L1",
            "Concat_def",
            "fun_disjoint_apply1",
            "fun_disjoint_apply2",
            "elem_nat_is_nat",
            "diff_add_inverse",
            "NatInterval_def"
        ],
        "statement": "theorem concat_props:\n  assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"\n  shows\n  \"Concat(a,b): n #+ k \\<rightarrow> X\"\n  \"\\<forall>i\\<in>n. Concat(a,b)`(i) = a`(i)\"\n  \"\\<forall>i \\<in> NatInterval(n,k). Concat(a,b)`(i) =  b`(i #- n)\"\n  \"\\<forall>j \\<in> k. Concat(a,b)`(n #+ j) = b`(j)\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"a:n\\<rightarrow>X\"  and I: \"ShiftedSeq(b,n): NatInterval(n,k) \\<rightarrow> X\"\n    and \"n \\<inter> NatInterval(n,k) = 0\"\n    using shifted_seq_props length_start_decomp by auto\n  then have \n    \"a \\<union> ShiftedSeq(b,n): n \\<union> NatInterval(n,k) \\<rightarrow> X \\<union> X\"\n    by (rule fun_disjoint_Un)\n  with A1 A2 show \"Concat(a,b): n #+ k \\<rightarrow> X\"\n    using func1_1_L1 Concat_def length_start_decomp by auto\n  { fix i assume \"i \\<in> n\"\n    with A1 I have \"i \\<notin> domain(ShiftedSeq(b,n))\"\n      using length_start_decomp func1_1_L1 by auto\n    with A2 have \"Concat(a,b)`(i) = a`(i)\"\n      using func1_1_L1 fun_disjoint_apply1 Concat_def by simp\n  } thus \"\\<forall>i\\<in>n. Concat(a,b)`(i) = a`(i)\" by simp\n  { fix i assume A3: \"i \\<in> NatInterval(n,k)\"\n    with A1 A2 have \"i \\<notin> domain(a)\" \n      using length_start_decomp func1_1_L1 by auto\n    with A1 A2 A3 have \"Concat(a,b)`(i) =  b`(i #- n)\"\n      using func1_1_L1 fun_disjoint_apply2 Concat_def shifted_seq_props\n      by simp\n  } thus II: \"\\<forall>i \\<in> NatInterval(n,k). Concat(a,b)`(i) =  b`(i #- n)\"\n    by simp\n  { fix j\n    let ?i = \"n #+ j\"\n    assume A3: \"j\\<in>k\"\n    with A1 have \"j \\<in> nat\" using elem_nat_is_nat by blast\n    then have \"?i #- n = j\" using diff_add_inverse by simp\n     with A3 II have \"Concat(a,b)`(?i) = b`(j)\"\n      using NatInterval_def by auto\n  } thus \"\\<forall>j \\<in> k. Concat(a,b)`(n #+ j) = b`(j)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 231
    },
    "214": {
        "type": "lemma",
        "text": "text\\<open>Properties of concatenating three lists.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\" and\n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"  \"c:m\\<rightarrow>X\" and\n  A3: \"d = Concat(Concat(a,b),c)\"\n  ",
        "using": [
            "concat_props",
            "add_nat_le",
            "add_lt_mono"
        ],
        "statement": "lemma concat_concat_list: \n  assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\" and\n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"  \"c:m\\<rightarrow>X\" and\n  A3: \"d = Concat(Concat(a,b),c)\"\n  shows\n  \"d : n #+ k #+ m \\<rightarrow> X\"\n  \"\\<forall>j \\<in> n. d`(j) = a`(j)\"\n  \"\\<forall>j \\<in> k. d`(n #+ j) = b`(j)\"\n  \"\\<forall>j \\<in> m. d`(n #+ k #+ j) = c`(j)\"\n",
        "proof": "proof -\n  from A1 A2 have I:\n    \"n #+ k \\<in> nat\"   \"m \\<in> nat\"\n    \"Concat(a,b): n #+ k \\<rightarrow> X\"   \"c:m\\<rightarrow>X\"\n    using concat_props by auto\n  with A3 show \"d: n #+k #+ m \\<rightarrow> X\"\n    using concat_props by simp\n  from I have II: \"\\<forall>i \\<in> n #+ k. \n    Concat(Concat(a,b),c)`(i) = Concat(a,b)`(i)\"\n    by (rule concat_props)\n  { fix j assume A4: \"j \\<in> n\"\n    moreover from A1 have \"n \\<subseteq> n #+ k\" using add_nat_le by simp\n    ultimately have \"j \\<in> n #+ k\" by auto\n    with A3 II have \"d`(j) =  Concat(a,b)`(j)\" by simp\n    with A1 A2 A4 have \"d`(j) = a`(j)\"\n      using concat_props by simp\n  } thus \"\\<forall>j \\<in> n. d`(j) = a`(j)\" by simp\n  { fix j assume A5: \"j \\<in> k\"\n    with A1 A3 II have \"d`(n #+ j) = Concat(a,b)`(n #+ j)\"\n      using add_lt_mono by simp\n    also from A1 A2 A5 have \"\\<dots> = b`(j)\"\n      using concat_props by simp\n    finally have \"d`(n #+ j) = b`(j)\" by simp\n  } thus \"\\<forall>j \\<in> k. d`(n #+ j) = b`(j)\" by simp\n  from I have \"\\<forall>j \\<in> m. Concat(Concat(a,b),c)`(n #+ k #+ j) = c`(j)\"\n    by (rule concat_props)\n  with A3 show \"\\<forall>j \\<in> m. d`(n #+ k #+ j) = c`(j)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 232
    },
    "215": {
        "type": "lemma",
        "text": "text\\<open>Properties of concatenating a list with a concatenation\n  of two other lists.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\" and\n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"  \"c:m\\<rightarrow>X\" and\n  A3: \"e = Concat(a, Concat(b,c))\"\n  ",
        "using": [
            "concat_props",
            "add_assoc",
            "add_nat_le",
            "add_lt_mono"
        ],
        "statement": "lemma concat_list_concat: \n  assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\" and\n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"  \"c:m\\<rightarrow>X\" and\n  A3: \"e = Concat(a, Concat(b,c))\"\n  shows \n  \"e : n #+ k #+ m \\<rightarrow> X\"\n  \"\\<forall>j \\<in> n. e`(j) = a`(j)\"\n  \"\\<forall>j \\<in> k. e`(n #+ j) = b`(j)\"\n  \"\\<forall>j \\<in> m. e`(n #+ k #+ j) = c`(j)\"\n",
        "proof": "proof -\n  from A1 A2 have I: \n    \"n \\<in> nat\"  \"k #+ m \\<in> nat\"\n    \"a:n\\<rightarrow>X\"  \"Concat(b,c): k #+ m \\<rightarrow> X\"\n    using concat_props by auto\n  with A3 show  \"e : n #+k #+ m \\<rightarrow> X\"\n    using concat_props add_assoc by simp\n  from I have \"\\<forall>j \\<in> n. Concat(a, Concat(b,c))`(j) = a`(j)\"\n    by (rule concat_props)\n  with A3 show \"\\<forall>j \\<in> n. e`(j) = a`(j)\" by simp\n  from I have II:\n    \"\\<forall>j \\<in> k #+ m. Concat(a, Concat(b,c))`(n #+ j) = Concat(b,c)`(j)\"\n    by (rule concat_props)\n  { fix j assume A4: \"j \\<in> k\"\n    moreover from A1 have \"k \\<subseteq> k #+ m\" using add_nat_le by simp\n    ultimately have \"j \\<in> k #+ m\" by auto\n    with A3 II have \"e`(n #+ j) =  Concat(b,c)`(j)\" by simp\n    also from A1 A2 A4 have \"\\<dots> = b`(j)\"\n      using concat_props by simp\n    finally have \"e`(n #+ j) = b`(j)\" by simp\n  } thus \"\\<forall>j \\<in> k. e`(n #+ j) = b`(j)\" by simp\n  { fix j assume A5: \"j \\<in> m\"\n    with A1 II A3 have \"e`(n #+ k #+ j) = Concat(b,c)`(k #+ j)\"\n      using add_lt_mono add_assoc by simp\n    also from A1 A2 A5 have \"\\<dots> = c`(j)\"\n      using concat_props by simp\n    finally have \"e`(n #+ k #+ j) = c`(j)\" by simp\n  } then show \"\\<forall>j \\<in> m. e`(n #+ k #+ j) = c`(j)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 233
    },
    "216": {
        "type": "theorem",
        "text": "text\\<open>Concatenation is associative.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\" and\n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"   \"c:m\\<rightarrow>X\"\n  ",
        "using": [
            "concat_concat_list",
            "concat_list_concat",
            "adjacent_intervals3",
            "NatInterval_def"
        ],
        "statement": "theorem concat_assoc: \n  assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\" and\n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"   \"c:m\\<rightarrow>X\"\n  shows \"Concat(Concat(a,b),c) =  Concat(a, Concat(b,c))\"\n",
        "proof": "proof -\n  let ?d = \"Concat(Concat(a,b),c)\"\n  let ?e = \"Concat(a, Concat(b,c))\"\n  from A1 A2 have\n    \"?d : n #+k #+ m \\<rightarrow> X\" and \"?e : n #+k #+ m \\<rightarrow> X\"\n    using concat_concat_list concat_list_concat by auto\n  moreover have \"\\<forall>i \\<in>  n #+k #+ m. ?d`(i) = ?e`(i)\"\n  proof -\n    { fix i assume \"i \\<in> n #+k #+ m\"\n      moreover from A1 have \n\t\"n #+k #+ m = n \\<union> NatInterval(n,k) \\<union> NatInterval(n #+ k,m)\"\n\tusing adjacent_intervals3 by simp\n      ultimately have \n\t\"i \\<in> n \\<or> i \\<in> NatInterval(n,k) \\<or> i \\<in> NatInterval(n #+ k,m)\"\n\tby simp\n      moreover\n      { assume \"i \\<in> n\"\n\twith A1 A2 have \"?d`(i) = ?e`(i)\"\n\tusing concat_concat_list concat_list_concat by simp }\n      moreover\n      { assume \"i \\<in> NatInterval(n,k)\"\n\tthen obtain j where \"j\\<in>k\" and \"i = n #+ j\"\n\t  using NatInterval_def by auto\n\twith A1 A2 have \"?d`(i) = ?e`(i)\"\n\t  using concat_concat_list concat_list_concat by simp }\n      moreover\n      { assume \"i \\<in> NatInterval(n #+ k,m)\"\n\tthen obtain j where \"j \\<in> m\" and \"i = n #+ k #+ j\"\n\t  using NatInterval_def by auto\n\twith A1 A2 have \"?d`(i) = ?e`(i)\"\n\t  using concat_concat_list concat_list_concat by simp }\n      ultimately have \"?d`(i) = ?e`(i)\" by auto\n    } thus ?thesis by simp\n  qed\n  ultimately show \"?d = ?e\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 234
    },
    "217": {
        "type": "theorem",
        "text": "text\\<open>Properties of \\<open>Tail\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"a: succ(n) \\<rightarrow> X\"\n  ",
        "using": [
            "succ_ineq",
            "apply_funtype",
            "func1_1_L1",
            "pred_succ_eq",
            "Tail_def"
        ],
        "statement": "theorem tail_props: \n  assumes A1: \"n \\<in> nat\" and A2: \"a: succ(n) \\<rightarrow> X\"\n  shows\n  \"Tail(a) : n \\<rightarrow> X\"\n  \"\\<forall>k \\<in> n. Tail(a)`(k) = a`(succ(k))\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<forall>k \\<in> n. a`(succ(k)) \\<in> X\"\n    using succ_ineq apply_funtype by simp\n  then have \"{\\<langle>k, a`(succ(k))\\<rangle>. k \\<in> n} : n \\<rightarrow> X\"\n    by (rule ZF_fun_from_total)\n  with A2 show I: \"Tail(a) : n \\<rightarrow> X\"\n    using func1_1_L1 pred_succ_eq Tail_def by simp\n  moreover from A2 have \"Tail(a) = {\\<langle>k, a`(succ(k))\\<rangle>. k \\<in> n}\"\n    using func1_1_L1 pred_succ_eq Tail_def by simp\n  ultimately show \"\\<forall>k \\<in> n. Tail(a)`(k) = a`(succ(k))\"\n    by (rule ZF_fun_from_tot_val0)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 235
    },
    "218": {
        "type": "lemma",
        "text": "text\\<open>Essentially the second assertion of \\<open>tail_props\\<close> but formulated using notation \n  $n+1$ instead of \\<open>succ(n)\\<close>:\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"a: n #+ 1 \\<rightarrow> X\" \"k\\<in>n\"\n  ",
        "using": [
            "assms",
            "succ_add_one(1)",
            "tail_props(2)",
            "elem_nat_is_nat(2)"
        ],
        "statement": "lemma tail_props2: assumes \"n \\<in> nat\" \"a: n #+ 1 \\<rightarrow> X\" \"k\\<in>n\"\n  shows \"Tail(a)`(k) = a`(k #+ 1)\"\n  ",
        "proof": "using assms succ_add_one(1) tail_props(2) elem_nat_is_nat(2)\n  by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 236
    },
    "219": {
        "type": "lemma",
        "text": "text\\<open>A nonempty list can be decomposed into concatenation of its first element and \n  the tail.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"a:succ(n)\\<rightarrow>X\"\n  ",
        "using": [
            "empty_in_every_succ",
            "apply_funtype",
            "pair_func_singleton",
            "one_is_nat",
            "tail_props(1)",
            "concat_props(1)",
            "succ_add_one(3)",
            "concat_props(2)",
            "pair_val",
            "elem_nat_is_nat(2)",
            "Nat_ZF_1_L3",
            "succ_mem",
            "concat_props(4)",
            "tail_props(2)"
        ],
        "statement": "lemma first_concat_tail: assumes \"n\\<in>nat\" \"a:succ(n)\\<rightarrow>X\"\n  shows \"a = Concat({\\<langle>0,a`(0)\\<rangle>},Tail(a))\"\n",
        "proof": "proof -\n  let ?b = \"Concat({\\<langle>0,a`(0)\\<rangle>},Tail(a))\"\n  have \"?b:succ(n)\\<rightarrow>X\" and \"\\<forall>k\\<in>succ(n). a`(k) = ?b`(k)\"\n  proof -\n    from assms(1) have \"0\\<in>succ(n)\" using empty_in_every_succ by simp\n    with assms(2) have \"a`(0) \\<in> X\" using apply_funtype by simp\n    then have I: \"{\\<langle>0,a`(0)\\<rangle>}:{0}\\<rightarrow>X\" using pair_func_singleton by simp\n    have \"{0}\\<in>nat\" using one_is_nat by simp\n    from assms have \"Tail(a): n \\<rightarrow> X\" using tail_props(1) by simp\n    with assms(1) \\<open>{0}\\<in>nat\\<close> I have \"?b:{0} #+ n \\<rightarrow> X\"\n      using concat_props(1) by simp\n    with assms(1) show \"?b:succ(n) \\<rightarrow> X\" using succ_add_one(3) by simp\n    { fix k assume \"k\\<in>succ(n)\"\n      { assume \"k=0\"\n        with assms(1) \\<open>{0}\\<in>nat\\<close> I \\<open>Tail(a): n \\<rightarrow> X\\<close>\n        have \"a`(k) = ?b`(k)\" using concat_props(2) pair_val\n          by simp          \n      }\n      moreover\n      { assume \"k\\<noteq>0\"\n        from assms(1) \\<open>k\\<in>succ(n)\\<close> have \"k\\<in>nat\"\n          using elem_nat_is_nat(2) by blast\n        with \\<open>k\\<noteq>0\\<close> obtain m where \"m\\<in>nat\" and \"k=succ(m)\"\n          using Nat_ZF_1_L3 by blast\n        with assms(1) \\<open>k\\<in>succ(n)\\<close> have \"m\\<in>n\" using succ_mem \n          by simp\n        with \\<open>{0}\\<in>nat\\<close> assms(1) I \\<open>Tail(a): n \\<rightarrow> X\\<close>\n        have \"?b`({0} #+ m) = Tail(a)`(m)\"\n          using concat_props(4) by simp\n        with assms \\<open>m\\<in>nat\\<close> \\<open>k\\<in>succ(n)\\<close> \\<open>k=succ(m)\\<close> \\<open>m\\<in>n\\<close>\n        have \"a`(k) = ?b`(k)\"\n          using succ_add_one(3) tail_props(2) by simp\n      }\n      ultimately have \"a`(k) = ?b`(k)\" by blast\n    } thus \"\\<forall>k\\<in>succ(n). a`(k) = ?b`(k)\" by simp\n  qed\n  with assms(2) show ?thesis by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 237
    },
    "220": {
        "type": "theorem",
        "text": "text\\<open>Properties of \\<open>Append\\<close>. It is a bit surprising that\n  the we don't need to assume that $n$ is a natural number.\\<close>\n",
        "assumes": "assumes A1: \"a: n \\<rightarrow> X\" and A2: \"x\\<in>X\" and A3: \"b = Append(a,x)\"\n  ",
        "using": [
            "mem_not_refl",
            "func1_1_L1",
            "Append_def",
            "succ_explained",
            "set_elem_add",
            "func1_1_L11D"
        ],
        "statement": "theorem append_props:\n  assumes A1: \"a: n \\<rightarrow> X\" and A2: \"x\\<in>X\" and A3: \"b = Append(a,x)\"\n  shows \n  \"b : succ(n) \\<rightarrow> X\"\n  \"\\<forall>k\\<in>n. b`(k) = a`(k)\"\n  \"b`(n) = x\"\n",
        "proof": "proof -\n  note A1\n  moreover have I: \"n \\<notin> n\" using mem_not_refl by simp\n  moreover from A1 A3 have II: \"b = a \\<union> {\\<langle>n,x\\<rangle>}\"\n    using func1_1_L1 Append_def by simp\n  ultimately have \"b : n \\<union> {n} \\<rightarrow> X \\<union> {x}\"\n    by (rule func1_1_L11D)\n  with A2 show \"b : succ(n) \\<rightarrow> X\"\n    using succ_explained set_elem_add by simp\n  from A1 I II show \"\\<forall>k\\<in>n. b`(k) = a`(k)\" and \"b`(n) = x\"\n    using func1_1_L11D by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 238
    },
    "221": {
        "type": "theorem",
        "text": "text\\<open>\\<open>Tail\\<close> commutes with \\<open>Append\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"a: succ(n) \\<rightarrow> X\" and A3: \"x\\<in>X\"\n  ",
        "using": [
            "tail_props",
            "append_props",
            "succ_ineq"
        ],
        "statement": "theorem tail_append_commute: \n  assumes A1: \"n \\<in> nat\" and A2: \"a: succ(n) \\<rightarrow> X\" and A3: \"x\\<in>X\"\n  shows \"Append(Tail(a),x) = Tail(Append(a,x))\"\n",
        "proof": "proof -\n  let ?b = \"Append(Tail(a),x)\"\n  let ?c = \"Tail(Append(a,x))\"\n  from A1 A2 have I: \"Tail(a) : n \\<rightarrow> X\" using tail_props\n    by simp\n  from A1 A2 A3 have \n    \"succ(n) \\<in> nat\" and \"Append(a,x) : succ(succ(n)) \\<rightarrow> X\"\n    using append_props by auto\n  then have II: \"\\<forall>k \\<in> succ(n). ?c`(k) = Append(a,x)`(succ(k))\"\n    by (rule tail_props)\n  from assms have \n    \"?b : succ(n) \\<rightarrow> X\" and \"?c : succ(n) \\<rightarrow> X\"\n    using tail_props append_props by auto\n  moreover have \"\\<forall>k \\<in> succ(n). ?b`(k) = ?c`(k)\"\n  proof -\n    { fix k assume \"k \\<in> succ(n)\"\n      hence \"k \\<in> n \\<or> k = n\" by auto\n      moreover\n      { assume A4: \"k \\<in> n\"\n\twith assms II have \"?c`(k) = a`(succ(k))\"\n\t  using succ_ineq append_props by simp\n\tmoreover\n\tfrom A3 I have \"\\<forall>k\\<in>n. ?b`(k) = Tail(a)`(k)\"\n\t  using append_props by simp\n\twith A1 A2 A4 have \"?b`(k) =  a`(succ(k))\"\n\t  using tail_props by simp\n\tultimately have \"?b`(k) = ?c`(k)\" by simp }\n      moreover\n      { assume A5: \"k = n\"\n\twith A2 A3 I II have \"?b`(k) = ?c`(k)\"\n\t  using append_props by auto }\n      ultimately have \"?b`(k) = ?c`(k)\" by auto\n    } thus ?thesis by simp\n  qed\n  ultimately show \"?b = ?c\" by (rule func_eq)\nqed  \n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 240
    },
    "222": {
        "type": "lemma",
        "text": "text\\<open>@{term NELists} are non-empty lists\\<close>\n",
        "assumes": "",
        "using": [
            "Nat_ZF_1_L3",
            "domain_of_fun",
            "nat_succI"
        ],
        "statement": "lemma non_zero_List_func_is_NEList:\n  shows \"NELists(X) = {a\\<in>Lists(X). a\\<noteq>0}\"\n",
        "proof": "proof-\n  { fix a assume as: \"a\\<in>{a\\<in>Lists(X). a\\<noteq>0}\"\n    from as obtain n where a: \"n\\<in>nat\" \"a:n\\<rightarrow> X\" unfolding Lists_def \n      by auto\n    { assume \"n=0\"\n      with a(2) have \"a=0\" unfolding Pi_def by auto\n      with as have False by auto\n    }\n    hence \"n\\<noteq>0\" by auto\n    with a(1) obtain k where \"k\\<in>nat\" \"n=succ(k)\" using Nat_ZF_1_L3 \n      by auto\n    with a(2) have \"a \\<in> NELists(X)\" unfolding NELists_def by auto\n  } moreover\n  { fix a assume as: \"a\\<in>NELists(X)\"\n    then obtain k where k: \"a:succ(k)\\<rightarrow>X\" \"k\\<in>nat\"\n      unfolding NELists_def by auto\n    { assume \"a=0\"\n      hence \"domain(a) = 0\" by auto\n      with k(1) have \"succ(k) = 0\" using domain_of_fun by auto\n      hence False by auto\n    } moreover\n    { from k(2) have \"succ(k)\\<in>nat\" using nat_succI by auto\n      with k(1) have \"a\\<in>Lists(X)\" unfolding Lists_def by auto\n    } ultimately\n    have \"a\\<in>{a\\<in>Lists(X). a\\<noteq>0}\" by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 241
    },
    "223": {
        "type": "theorem",
        "text": "text\\<open>Properties of \\<open>Init\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"a: succ(n) \\<rightarrow> X\"\n  ",
        "using": [
            "restrict_type2",
            "func1_1_L1",
            "pred_succ_eq",
            "Init_def",
            "restrict",
            "apply_funtype"
        ],
        "statement": "theorem init_props: \n  assumes A1: \"n \\<in> nat\" and A2: \"a: succ(n) \\<rightarrow> X\"\n  shows \n  \"Init(a) : n \\<rightarrow> X\"\n  \"\\<forall>k\\<in>n. Init(a)`(k) = a`(k)\"\n  \"a = Append(Init(a), a`(n))\"\n",
        "proof": "proof -\n  have \"n \\<subseteq> succ(n)\" by auto\n  with A2 have \"restrict(a,n): n \\<rightarrow> X\"\n    using restrict_type2 by simp\n  moreover from A1 A2 have I: \"restrict(a,n) = Init(a)\"\n    using func1_1_L1 pred_succ_eq Init_def by simp\n  ultimately show thesis1: \"Init(a) : n \\<rightarrow> X\" by simp\n  { fix k assume \"k\\<in>n\"\n    then have \"restrict(a,n)`(k) = a`(k)\"\n      using restrict by simp\n    with I have \"Init(a)`(k) = a`(k)\" by simp\n  } then show thesis2: \"\\<forall>k\\<in>n. Init(a)`(k) = a`(k)\" by simp\n  let ?b = \"Append(Init(a), a`(n))\"\n  from A2 thesis1 have II:\n    \"Init(a) : n \\<rightarrow> X\"   \"a`(n) \\<in> X\"\n    \"?b = Append(Init(a), a`(n))\"\n    using apply_funtype by auto\n  note A2\n  moreover from II have \"?b : succ(n) \\<rightarrow> X\"\n    by (rule append_props)\n  moreover have \"\\<forall>k \\<in> succ(n). a`(k) = ?b`(k)\"\n  proof -\n    { fix k assume A3: \"k \\<in> n\"\n      from II have \"\\<forall>j\\<in>n. ?b`(j) = Init(a)`(j)\"\n\tby (rule append_props)\n      with thesis2 A3 have \"a`(k) = ?b`(k)\" by simp }\n    moreover \n    from II have \"?b`(n) = a`(n)\"\n      by (rule append_props)\n    hence \" a`(n) = ?b`(n)\" by simp\n    ultimately show \"\\<forall>k \\<in> succ(n). a`(k) = ?b`(k)\"\n      by simp\n  qed\n  ultimately show \"a = ?b\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 242
    },
    "224": {
        "type": "theorem",
        "text": "text\\<open>The initial part of a non-empty list\n  is a list, and the domain of the original list\n  is the successor of its initial part.\\<close>\n",
        "assumes": "assumes \"a \\<in> NELists(X)\"\n  ",
        "using": [
            "init_props(1)",
            "domain_of_fun"
        ],
        "statement": "theorem init_NElist: \n  assumes \"a \\<in> NELists(X)\"\n  shows \"Init(a) \\<in> Lists(X)\" and \"succ(domain(Init(a))) = domain(a)\"\n",
        "proof": "proof -\n  from assms obtain n where n: \"n\\<in>nat\" \"a:succ(n) \\<rightarrow> X\" \n    unfolding NELists_def by auto\n  then have tailF: \"Init(a):n \\<rightarrow> X\" using init_props(1) by auto\n  with n(1) show \"Init(a) \\<in> Lists(X)\" unfolding Lists_def by auto\n  from tailF have \"domain(Init(a)) = n\" using domain_of_fun by auto\n  moreover from n(2) have \"domain(a) = succ(n)\" using domain_of_fun \n    by auto\n  ultimately show \"succ(domain(Init(a))) = domain(a)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 243
    },
    "225": {
        "type": "lemma",
        "text": "text\\<open>If we take init of the result of append, we get back the same list.\\<close> \n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"a:n\\<rightarrow>X\" and A3: \"x \\<in> X\"\n  ",
        "using": [
            "append_props",
            "init_props"
        ],
        "statement": "lemma init_append: assumes A1: \"n \\<in> nat\" and A2: \"a:n\\<rightarrow>X\" and A3: \"x \\<in> X\"\n  shows \"Init(Append(a,x)) = a\"\n",
        "proof": "proof -\n  from A2 A3 have \"Append(a,x): succ(n)\\<rightarrow>X\" using append_props by simp\n  with A1 have \"Init(Append(a,x)):n\\<rightarrow>X\" and \"\\<forall>k\\<in>n. Init(Append(a,x))`(k) = Append(a,x)`(k)\"  \n    using init_props by auto\n  with A2 A3 have \"\\<forall>k\\<in>n. Init(Append(a,x))`(k) = a`(k)\" using append_props by simp\n  with \\<open>Init(Append(a,x)):n\\<rightarrow>X\\<close> A2 show ?thesis by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 244
    },
    "226": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of definition of \\<open>Init\\<close>.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"a:succ(n)\\<rightarrow>X\"\n  ",
        "using": [
            "assms",
            "func1_1_L1",
            "Init_def"
        ],
        "statement": "lemma init_def: assumes \"n \\<in> nat\" and \"a:succ(n)\\<rightarrow>X\"\n  shows \"Init(a) = restrict(a,n)\"\n  ",
        "proof": "using assms func1_1_L1 Init_def by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 245
    },
    "227": {
        "type": "lemma",
        "text": "text\\<open>Another reformulation of the definition of \\<open>Init\\<close>, starting with the\n  expression defining the list.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> X\"\n  ",
        "using": [
            "succ_add_one(1)",
            "init_def"
        ],
        "statement": "lemma init_def_alt: assumes \"n\\<in>nat\" and \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> X\"\n  shows \"Init({\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}) = {\\<langle>k,q(k)\\<rangle>. k\\<in>n}\"\n",
        "proof": "proof -\n  let ?a = \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}\"\n  from assms(2) have \"?a:n #+ 1\\<rightarrow>X\" by (rule ZF_fun_from_total)\n  moreover from assms(1) have \"n #+ 1 = succ(n)\" using succ_add_one(1)\n    by simp\n  ultimately have \"?a:succ(n)\\<rightarrow>X\" by simp\n  with assms(1) have \"Init(?a) = restrict(?a,n)\" using init_def by simp\n  moreover\n  from assms(1) have \"n \\<subseteq> n #+ 1\" by auto\n  then have \"restrict(?a,n) = {\\<langle>k,q(k)\\<rangle>. k\\<in>n}\"\n    by (rule restrict_def_alt)\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 246
    },
    "228": {
        "type": "lemma",
        "text": "text\\<open>A lemma about extending a finite sequence by one more value. This is \n  just a more explicit version of \\<open>append_props\\<close>.\\<close>\n",
        "assumes": "assumes  \"a:n\\<rightarrow>X\"   \"y\\<in>X\"   \"b = a \\<union> {\\<langle>n,y\\<rangle>}\"\n  ",
        "using": [
            "assms",
            "Append_def",
            "func1_1_L1",
            "append_props"
        ],
        "statement": "lemma finseq_extend: \n  assumes  \"a:n\\<rightarrow>X\"   \"y\\<in>X\"   \"b = a \\<union> {\\<langle>n,y\\<rangle>}\"\n  shows\n  \"b: succ(n) \\<rightarrow> X\"\n  \"\\<forall>k\\<in>n. b`(k) = a`(k)\"\n  \"b`(n) = y\"\n  ",
        "proof": "using assms Append_def func1_1_L1 append_props by auto\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 247
    },
    "229": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is a bit displaced as it is mainly \n  about finite sets. It is proven here because it uses\n  the notion of \\<open>Append\\<close>.\n  Suppose we have a list of element of $A$ is a bijection.\n  Then for every element that does not belong to $A$ \n  we can we can construct \n  a bijection for the set $A \\cup \\{ x\\}$ by appending $x$.\n  This is just a specialised version of lemma \\<open>bij_extend_point\\<close>\n  from \\<open>func1.thy\\<close>.\n\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"b \\<in> bij(n,X)\" and A3: \"x \\<notin> X\"\n  ",
        "using": [
            "mem_not_refl",
            "bij_extend_point",
            "bij_def",
            "surj_def",
            "func1_1_L1B",
            "Append_def",
            "func1_1_L1",
            "succ_explained"
        ],
        "statement": "lemma bij_append_point: \n  assumes A1: \"n \\<in> nat\" and A2: \"b \\<in> bij(n,X)\" and A3: \"x \\<notin> X\"\n  shows \"Append(b,x) \\<in> bij(succ(n), X \\<union> {x})\"\n",
        "proof": "proof -\n  from A2 A3 have \"b \\<union> {\\<langle>n,x\\<rangle>} \\<in> bij(n \\<union> {n},X \\<union> {x})\"\n    using mem_not_refl bij_extend_point by simp\n  moreover have \"Append(b,x) = b \\<union> {\\<langle>n,x\\<rangle>}\"\n  proof -\n    from A2 have \"b:n\\<rightarrow>X\"\n      using bij_def surj_def by simp\n    then have \"b : n \\<rightarrow> X \\<union> {x}\" using func1_1_L1B\n      by blast\n    then show \"Append(b,x) = b \\<union> {\\<langle>n,x\\<rangle>}\"\n      using Append_def func1_1_L1 by simp\n  qed\n  ultimately show ?thesis using succ_explained by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 248
    },
    "230": {
        "type": "lemma",
        "text": "text\\<open>The next lemma rephrases the definition of \\<open>Last\\<close>.\n  Recall that in ZF we have $\\{0,1,2,..,n\\} = n+1=$\\<open>succ\\<close>$(n)$.\\<close>\n",
        "assumes": "assumes \"a: succ(n) \\<rightarrow> X\" ",
        "using": [
            "assms",
            "func1_1_L1",
            "pred_succ_eq",
            "Last_def"
        ],
        "statement": "lemma last_seq_elem: assumes \"a: succ(n) \\<rightarrow> X\" shows \"Last(a) = a`(n)\"\n  ",
        "proof": "using assms func1_1_L1 pred_succ_eq Last_def by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 249
    },
    "231": {
        "type": "lemma",
        "text": "text\\<open>The last element of a non-empty list valued in $X$ is in $X$.\\<close>\n",
        "assumes": "assumes \"a \\<in> NELists(X)\" ",
        "using": [
            "assms",
            "last_seq_elem",
            "apply_funtype",
            "NELists_def"
        ],
        "statement": "lemma last_type: assumes \"a \\<in> NELists(X)\" shows \"Last(a) \\<in> X\"\n  ",
        "proof": "using assms last_seq_elem apply_funtype unfolding NELists_def \n  by auto\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 250
    },
    "232": {
        "type": "lemma",
        "text": "text\\<open>If two finite sequences are the same when restricted to domain one \n  shorter than the original and have the same value on the last element, \n  then they are equal.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and \n  A2: \"a: succ(n) \\<rightarrow> X\"  \"b: succ(n) \\<rightarrow> X\" and\n  A3: \"restrict(a,n) = restrict(b,n)\" and\n  A4: \"a`(n) = b`(n)\"\n  ",
        "using": [
            "restrict"
        ],
        "statement": "lemma finseq_restr_eq: assumes A1: \"n \\<in> nat\" and \n  A2: \"a: succ(n) \\<rightarrow> X\"  \"b: succ(n) \\<rightarrow> X\" and\n  A3: \"restrict(a,n) = restrict(b,n)\" and\n  A4: \"a`(n) = b`(n)\"\n  shows \"a = b\"\n",
        "proof": "proof -\n  { fix k assume \"k \\<in> succ(n)\"\n    then have \"k \\<in> n \\<or> k = n\" by auto\n    moreover\n    { assume \"k \\<in> n\"  \n      then have \n\t\"restrict(a,n)`(k) = a`(k)\" and \"restrict(b,n)`(k) = b`(k)\"\n\tusing restrict by auto\n      with A3 have \"a`(k) = b`(k)\" by simp }\n    moreover\n    { assume \"k = n\"\n      with A4 have \"a`(k) = b`(k)\" by simp }\n    ultimately have \"a`(k) = b`(k)\" by auto\n  } then have \"\\<forall> k \\<in> succ(n). a`(k) = b`(k)\" by simp\n  with A2 show \"a = b\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 252
    },
    "233": {
        "type": "lemma",
        "text": "text\\<open>Concatenating a list of length $1$ is the same as appending its\n  first (and only) element. Recall that in ZF set theory \n  $1 = \\{ 0 \\} $.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and \n  A2: \"a: n \\<rightarrow> X\"  and A3: \"b : 1 \\<rightarrow> X\"\n  ",
        "using": [
            "apply_funtype",
            "append_props"
        ],
        "statement": "lemma append_1elem: assumes A1: \"n \\<in> nat\" and \n  A2: \"a: n \\<rightarrow> X\"  and A3: \"b : 1 \\<rightarrow> X\"\n  shows \"Concat(a,b) = Append(a,b`(0))\"\n",
        "proof": "proof -\n  let ?C = \"Concat(a,b)\"\n  let ?A = \"Append(a,b`(0))\"\n  from A1 A2 A3 have I:\n    \"n \\<in> nat\"  \"1 \\<in> nat\"\n    \"a:n\\<rightarrow>X\"   \"b:1\\<rightarrow>X\" by auto\n  have \"?C : succ(n) \\<rightarrow> X\"\n  proof -\n    from I have \"?C : n #+ 1 \\<rightarrow> X\"\n      by (rule concat_props)\n    with A1 show \"?C : succ(n) \\<rightarrow> X\" by simp\n  qed\n  moreover from A2 A3 have \"?A : succ(n) \\<rightarrow> X\"\n    using apply_funtype append_props by simp\n  moreover have \"\\<forall>k \\<in> succ(n). ?C`(k) = ?A`(k)\"\n  proof\n    fix k assume \"k \\<in> succ(n)\"\n    moreover\n    { assume \"k \\<in> n\"\n      moreover from I have \"\\<forall>i \\<in> n. ?C`(i) = a`(i)\"\n\tby (rule concat_props)\n      moreover from A2 A3 have \"\\<forall>i\\<in>n. ?A`(i) = a`(i)\"\n\tusing apply_funtype append_props by simp\n      ultimately have \"?C`(k) =  ?A`(k)\" by simp }\n    moreover have \"?C`(n) = ?A`(n)\"\n    proof -\n      from I have \"\\<forall>j \\<in> 1. ?C`(n #+ j) = b`(j)\"\n\tby (rule concat_props)\n      with A1 A2 A3 show \"?C`(n) = ?A`(n)\"\n\tusing apply_funtype append_props by simp\n    qed\n    ultimately show \"?C`(k) = ?A`(k)\" by auto\n  qed\n  ultimately show \"?C = ?A\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 253
    },
    "234": {
        "type": "lemma",
        "text": "text\\<open>If $x\\in X$ then the singleton set with the pair $\\langle 0,x\\rangle$\n  as the only element is a list of length 1 and hence a nonempty list. \\<close>\n",
        "assumes": "assumes \"x\\<in>X\" \n  ",
        "using": [
            "pair_func_singleton"
        ],
        "statement": "lemma list_len1_singleton: assumes \"x\\<in>X\" \n  shows \"{\\<langle>0,x\\<rangle>} : 1 \\<rightarrow> X\" and \"{\\<langle>0,x\\<rangle>} \\<in> NELists(X)\"\n",
        "proof": "proof -\n  from assms have \"{\\<langle>0,x\\<rangle>} : {0} \\<rightarrow> X\" using pair_func_singleton\n    by simp\n  moreover have \"{0} = 1\" by auto\n  ultimately show \"{\\<langle>0,x\\<rangle>} : 1 \\<rightarrow> X\" and \"{\\<langle>0,x\\<rangle>} \\<in> NELists(X)\" \n    unfolding NELists_def by auto  \nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 254
    },
    "235": {
        "type": "lemma",
        "text": "text\\<open>A singleton list is in fact a singleton set with a pair as the only element.\\<close>\n",
        "assumes": "assumes A1: \"x:1\\<rightarrow>X\" ",
        "using": [],
        "statement": "lemma list_singleton_pair: assumes A1: \"x:1\\<rightarrow>X\" shows \"x = {\\<langle>0,x`(0)\\<rangle>}\"\n",
        "proof": "proof -\n  from A1 have \"x = {\\<langle>t,x`(t)\\<rangle>. t\\<in>1}\" by (rule fun_is_set_of_pairs)\n  hence \"x = {\\<langle>t,x`(t)\\<rangle>. t\\<in>{0} }\" by simp\n  thus ?thesis by simp\nqed  \n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 255
    },
    "236": {
        "type": "lemma",
        "text": "text\\<open>When we append an element to the empty list we get\n  a list with length $1$.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>X\"\n  ",
        "using": [
            "Append_def",
            "list_len1_singleton",
            "pair_func_singleton"
        ],
        "statement": "lemma empty_append1: assumes A1: \"x\\<in>X\"\n  shows \"Append(0,x): 1 \\<rightarrow> X\" and \"Append(0,x)`(0) = x\"\n",
        "proof": "proof -\n  let ?a = \"Append(0,x)\"\n  have \"?a = {\\<langle>0,x\\<rangle>}\" using Append_def by auto\n  with A1 show \"?a : 1 \\<rightarrow> X\" and \"?a`(0) = x\"\n    using list_len1_singleton pair_func_singleton\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 256
    },
    "237": {
        "type": "lemma",
        "text": "text\\<open>Appending an element is the same as concatenating\n  with certain pair.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"a: n \\<rightarrow> X\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "list_len1_singleton",
            "append_1elem",
            "pair_val"
        ],
        "statement": "lemma append_concat_pair: \n  assumes \"n \\<in> nat\" and \"a: n \\<rightarrow> X\" and \"x\\<in>X\"\n  shows \"Append(a,x) = Concat(a,{\\<langle>0,x\\<rangle>})\"\n  ",
        "proof": "using assms list_len1_singleton append_1elem pair_val\n  by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 257
    },
    "238": {
        "type": "lemma",
        "text": "text\\<open>An associativity property involving concatenation \n  and appending. For proof we just convert appending to\n  concatenation and use \\<open>concat_assoc\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and \n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\" and A3: \"x \\<in> X\"\n  ",
        "using": [
            "concat_props",
            "list_len1_singleton",
            "append_1elem",
            "pair_val"
        ],
        "statement": "lemma concat_append_assoc: assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and \n  A2: \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\" and A3: \"x \\<in> X\"\n  shows \"Append(Concat(a,b),x) = Concat(a, Append(b,x))\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \n    \"n #+ k \\<in> nat\"   \"Concat(a,b) : n #+ k \\<rightarrow> X\"   \"x \\<in> X\"\n    using concat_props by auto\n  then have \n    \"Append(Concat(a,b),x) =  Concat(Concat(a,b),{\\<langle>0,x\\<rangle>})\"\n    by (rule append_concat_pair)\n  moreover\n  from A1 A2 A3 have\n    \"n \\<in> nat\"  \"k \\<in> nat\"  \"1 \\<in> nat\"\n     \"a:n\\<rightarrow>X\"   \"b:k\\<rightarrow>X\"  \"{\\<langle>0,x\\<rangle>} :  1 \\<rightarrow> X\"\n    using list_len1_singleton by auto\n  then have\n    \"Concat(Concat(a,b),{\\<langle>0,x\\<rangle>}) = Concat(a, Concat(b,{\\<langle>0,x\\<rangle>}))\"\n    by (rule concat_assoc)\n  moreover from A1 A2 A3 have \"Concat(b,{\\<langle>0,x\\<rangle>}) =  Append(b,x)\"\n    using list_len1_singleton append_1elem pair_val by simp\n  ultimately show \"Append(Concat(a,b),x) = Concat(a, Append(b,x))\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 258
    },
    "239": {
        "type": "lemma",
        "text": "text\\<open>An identity involving concatenating with init\n  and appending the last element.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"  \"k \\<in> nat\" and \n  \"a: n \\<rightarrow> X\"  and \"b : succ(k) \\<rightarrow> X\"\n  ",
        "using": [
            "assms",
            "init_props",
            "apply_funtype",
            "concat_append_assoc"
        ],
        "statement": "lemma concat_init_last_elem: \n  assumes \"n \\<in> nat\"  \"k \\<in> nat\" and \n  \"a: n \\<rightarrow> X\"  and \"b : succ(k) \\<rightarrow> X\"\n  shows \"Append(Concat(a,Init(b)),b`(k)) = Concat(a,b)\"\n  ",
        "proof": "using assms init_props apply_funtype concat_append_assoc\n  by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 259
    },
    "240": {
        "type": "lemma",
        "text": "text\\<open>A lemma about creating lists by composition and how\n  \\<open>Append\\<close> behaves in such case.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"a : n \\<rightarrow> X\" and \n  A3: \"x \\<in> X\" and A4: \"c : X \\<rightarrow> Y\"\n  ",
        "using": [
            "comp_fun",
            "append_props",
            "apply_funtype",
            "comp_fun_apply"
        ],
        "statement": "lemma list_compose_append: \n  assumes A1: \"n \\<in> nat\" and A2: \"a : n \\<rightarrow> X\" and \n  A3: \"x \\<in> X\" and A4: \"c : X \\<rightarrow> Y\"\n  shows\n  \"c O Append(a,x) : succ(n) \\<rightarrow> Y\"\n  \"c O Append(a,x) = Append(c O a, c`(x))\"\n",
        "proof": "proof -\n  let ?b = \"Append(a,x)\"\n  let ?d = \"Append(c O a, c`(x))\"\n  from A2 A4 have \"c O a : n \\<rightarrow> Y\"\n    using comp_fun by simp\n  from A2 A3 have \"?b : succ(n) \\<rightarrow> X\"\n    using append_props by simp\n  with A4 show \"c O ?b : succ(n) \\<rightarrow> Y\"\n    using comp_fun by simp\n  moreover from A3 A4 \\<open>c O a : n \\<rightarrow> Y\\<close> have \n    \"?d: succ(n) \\<rightarrow> Y\"\n    using apply_funtype append_props by simp\n  moreover have \"\\<forall>k \\<in> succ(n). (c O ?b) `(k) = ?d`(k)\"\n  proof -\n    { fix k assume \"k \\<in> succ(n)\"\n      with \\<open>?b : succ(n) \\<rightarrow> X\\<close> have \n\t\"(c O ?b) `(k) = c`(?b`(k))\"\n\tusing comp_fun_apply by simp\n      with A2 A3 A4 \\<open>c O a : n \\<rightarrow> Y\\<close> \\<open>c O a : n \\<rightarrow> Y\\<close> \\<open>k \\<in> succ(n)\\<close>\n      have \"(c O ?b) `(k) = ?d`(k)\"\n\tusing append_props comp_fun_apply apply_funtype\n\tby auto\n    } thus ?thesis by simp\n  qed\n  ultimately show \"c O ?b = ?d\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 260
    },
    "241": {
        "type": "lemma",
        "text": "text\\<open>A lemma about appending an element to a list defined by set\n  comprehension.\\<close>\n",
        "assumes": "assumes \n  A1: \"\\<forall>i \\<in> succ(k). b(i) \\<in> X\" and\n  A2: \"a = {\\<langle>i,b(i)\\<rangle>. i \\<in> succ(k)}\"\n  ",
        "using": [
            "func1_1_L1",
            "Append_def"
        ],
        "statement": "lemma set_list_append: assumes \n  A1: \"\\<forall>i \\<in> succ(k). b(i) \\<in> X\" and\n  A2: \"a = {\\<langle>i,b(i)\\<rangle>. i \\<in> succ(k)}\"\n  shows \n  \"a: succ(k) \\<rightarrow> X\"\n  \"{\\<langle>i,b(i)\\<rangle>. i \\<in> k}: k \\<rightarrow> X\" \n  \"a = Append({\\<langle>i,b(i)\\<rangle>. i \\<in> k},b(k))\"\n",
        "proof": "proof -\n  from A1 have \"{\\<langle>i,b(i)\\<rangle>. i \\<in> succ(k)} : succ(k) \\<rightarrow> X\" \n    by (rule ZF_fun_from_total)\n  with A2 show \"a: succ(k) \\<rightarrow> X\" by simp\n  from A1 have \"\\<forall>i \\<in> k. b(i) \\<in> X\"\n    by simp\n  then show \"{\\<langle>i,b(i)\\<rangle>. i \\<in> k}: k \\<rightarrow> X\"\n    by (rule ZF_fun_from_total)\n  with A2 show \"a = Append({\\<langle>i,b(i)\\<rangle>. i \\<in> k},b(k))\"\n    using func1_1_L1 Append_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 261
    },
    "242": {
        "type": "lemma",
        "text": "text\\<open>A version of \\<open>set_list_append\\<close> using $n+1$ instead of \\<open>succ(n)\\<close>. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> X\"\n  defines \"a\\<equiv>{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}\"\n  ",
        "using": [
            "succ_add_one(1)",
            "set_list_append(1,2)",
            "init_def_alt",
            "set_list_append(3)"
        ],
        "statement": "lemma set_list_append1: \n  assumes \"n\\<in>nat\" and \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> X\"\n  defines \"a\\<equiv>{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}\"\n  shows\n  \"a: n #+ 1 \\<rightarrow> X\"\n  \"{\\<langle>k,q(k)\\<rangle>. k \\<in> n}: n \\<rightarrow> X\"\n  \"Init(a) = {\\<langle>k,q(k)\\<rangle>. k \\<in> n}\"\n  \"a = Append({\\<langle>k,q(k)\\<rangle>. k \\<in> n},q(n))\"\n  \"a = Append(Init(a), q(n))\"\n  \"a = Append(Init(a), a`(n))\"\n",
        "proof": "proof -\n  from assms(1) have I: \"n #+ 1 = succ(n)\" using succ_add_one(1) \n    by simp\n  with assms show \n    \"a: n #+ 1 \\<rightarrow> X\" and \"{\\<langle>k,q(k)\\<rangle>. k \\<in> n}: n \\<rightarrow> X\" \n    and II: \"Init(a) = {\\<langle>k,q(k)\\<rangle>. k \\<in> n}\"\n    using set_list_append(1,2) init_def_alt by simp_all\n  from assms(2,3) I have \n    \"\\<forall>k\\<in>succ(n). q(k) \\<in> X\" and \"a = {\\<langle>k,q(k)\\<rangle>. k \\<in> succ(n)}\"\n    by simp_all\n  then show \"a = Append({\\<langle>k,q(k)\\<rangle>. k \\<in> n},q(n))\"  \n    using set_list_append(3) by simp\n  with II show \"a = Append(Init(a), q(n))\" by simp\n  from I have \"n \\<in> n #+ 1\" by simp\n  then have \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}`(n) = q(n)\"\n    by (rule ZF_fun_from_tot_val1)\n  with assms(3) \\<open>a = Append(Init(a), q(n))\\<close> show \"a = Append(Init(a), a`(n))\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 262
    },
    "243": {
        "type": "lemma",
        "text": "text\\<open>An induction theorem for lists.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>b\\<in>1\\<rightarrow>X. P(b)\" and \n  A2: \"\\<forall>b\\<in>NELists(X). P(b) \\<longrightarrow> (\\<forall>x\\<in>X. P(Append(b,x)))\" and\n  A3: \"d \\<in> NELists(X)\"\n  ",
        "using": [
            "init_props",
            "NELists_def",
            "apply_funtype"
        ],
        "statement": "lemma list_induct: assumes A1: \"\\<forall>b\\<in>1\\<rightarrow>X. P(b)\" and \n  A2: \"\\<forall>b\\<in>NELists(X). P(b) \\<longrightarrow> (\\<forall>x\\<in>X. P(Append(b,x)))\" and\n  A3: \"d \\<in> NELists(X)\"\n  shows \"P(d)\"\n",
        "proof": "proof -\n  { fix n \n    assume \"n\\<in>nat\"\n    moreover from A1 have \"\\<forall>b\\<in>succ(0)\\<rightarrow>X. P(b)\" by simp \n    moreover have \"\\<forall>k\\<in>nat. ((\\<forall>b\\<in>succ(k)\\<rightarrow>X. P(b)) \\<longrightarrow> (\\<forall>c\\<in>succ(succ(k))\\<rightarrow>X. P(c)))\"\n    proof -\n      { fix k assume \"k \\<in> nat\" assume \"\\<forall>b\\<in>succ(k)\\<rightarrow>X. P(b)\"\n        have \"\\<forall>c\\<in>succ(succ(k))\\<rightarrow>X. P(c)\"\n        proof\n          fix c assume \"c: succ(succ(k))\\<rightarrow>X\"\n          let ?b = \"Init(c)\"\n          let ?x = \"c`(succ(k))\"\n          from \\<open>k \\<in> nat\\<close> \\<open>c: succ(succ(k))\\<rightarrow>X\\<close> have \"?b:succ(k)\\<rightarrow>X\"\n            using init_props by simp\n          with A2 \\<open>k \\<in> nat\\<close> \\<open>\\<forall>b\\<in>succ(k)\\<rightarrow>X. P(b)\\<close> have \"\\<forall>x\\<in>X. P(Append(?b,x))\"\n            using NELists_def by auto \n          with \\<open>c: succ(succ(k))\\<rightarrow>X\\<close> have \"P(Append(?b,?x))\" using apply_funtype by simp \n          with \\<open>k \\<in> nat\\<close> \\<open>c: succ(succ(k))\\<rightarrow>X\\<close> show \"P(c)\"\n            using init_props by simp \n        qed\n      } thus ?thesis by simp \n    qed\n    ultimately have \"\\<forall>b\\<in>succ(n)\\<rightarrow>X. P(b)\" by (rule ind_on_nat)\n  } with A3 show ?thesis using NELists_def by auto \nqed \n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 263
    },
    "244": {
        "type": "definition",
        "text": "text\\<open>A dual notion to \\<open>Append\\<close> is \\<open>Prepend\\<close> where we add an element to the list at the beginning of the\n  list. We define the value of the list $a$ prepended by an element $x$ as \n  $x$ if index is 0 and $a(k-1)$ otherwise.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Prepend(a,x) \\<equiv> {\\<langle>k,if k = 0 then x else a`(k #- 1)\\<rangle>. k\\<in>domain(a) #+ 1}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 264
    },
    "245": {
        "type": "lemma",
        "text": "text\\<open>If $a:n\\rightarrow X$ is a list, then $a$ with prepended $x\\in X$ is a list as well and\n  its first element is $x$. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"a:n\\<rightarrow>X\" \"x\\<in>X\"\n  ",
        "using": [
            "elem_nat_is_nat(2)",
            "succ_add_one(1)",
            "pred_succ_mem",
            "pred_minus_one",
            "apply_funtype",
            "func1_1_L1",
            "Prepend_def",
            "empty_in_every_succ"
        ],
        "statement": "lemma prepend_props: \n  assumes \"n\\<in>nat\" \"a:n\\<rightarrow>X\" \"x\\<in>X\"\n  shows \"Prepend(a,x):(n #+ 1)\\<rightarrow>X\" and \"Prepend(a,x)`(0) = x\"\n",
        "proof": "proof -\n  let ?b = \"{\\<langle>k,if k = 0 then x else a`(k #- 1)\\<rangle>. k\\<in>n #+ 1}\"\n  have \"\\<forall>k\\<in>n #+ 1. (if k = 0 then x else a`(k #- 1)) \\<in> X\"\n  proof -\n    { fix k assume \"k \\<in> n #+ 1\"\n      let ?v = \"if k = 0 then x else a`(k #- 1)\"\n      { assume \"k\\<noteq>0\"\n        with \\<open>k \\<in> n #+ 1\\<close> have \"n\\<noteq>0\" by auto\n        from assms(1) \\<open>k \\<in> n #+ 1\\<close> have \"k \\<in> nat\" \n          using elem_nat_is_nat(2) by blast\n        from assms(1) have \"succ(n) = n #+ 1\"\n          using succ_add_one(1) by simp\n        with \\<open>k \\<in> n #+ 1\\<close> have \"k\\<in>succ(n)\" by simp\n        with assms(1) \\<open>n\\<noteq>0\\<close> have \"pred(k) \\<in> n\"\n          using pred_succ_mem by simp\n        with assms(2) \\<open>k \\<in> nat\\<close> \\<open>k\\<noteq>0\\<close> have \"?v\\<in>X\"\n          using pred_minus_one apply_funtype by simp\n      }\n      with assms(3) have \"?v \\<in> X\" by simp\n    } thus ?thesis by simp\n  qed\n  then have \"?b: (n #+ 1)\\<rightarrow>X\" by (rule ZF_fun_from_total)\n  with assms(2) show \"Prepend(a,x):(n #+ 1)\\<rightarrow>X\"\n    using func1_1_L1 unfolding Prepend_def by simp\n  from assms(1) have \"0 \\<in> n #+ 1\"\n    using succ_add_one(1) empty_in_every_succ by simp\n  then have \"?b`(0) = (if 0 = 0 then x else a`(0 #- 1))\" \n    by (rule ZF_fun_from_tot_val1)\n  with assms(2) show  \"Prepend(a,x)`(0) = x\"\n    using func1_1_L1 unfolding Prepend_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 265
    },
    "246": {
        "type": "lemma",
        "text": "text\\<open>When prepending an element to a list the values at positive indices do not change.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"a:n\\<rightarrow>X\" \"x\\<in>X\" \"k\\<in>n\"\n  ",
        "using": [
            "elem_nat_is_nat(2)",
            "succ_add_one(1)",
            "succ_ineq",
            "func1_1_L1",
            "Prepend_def"
        ],
        "statement": "lemma prepend_val: assumes \"n\\<in>nat\" \"a:n\\<rightarrow>X\" \"x\\<in>X\" \"k\\<in>n\"\n  shows \"Prepend(a,x)`(k #+ 1) = a`(k)\"\n",
        "proof": "proof -\n  let ?b = \"{\\<langle>k,if k = 0 then x else a`(k #- 1)\\<rangle>. k\\<in>n #+ 1}\"\n  from assms(1,4) have \"k\\<in>nat\"\n    using elem_nat_is_nat(2) by simp\n  with assms(1) have \"succ(n) = n #+ 1\" and \"succ(k) = k #+ 1\"\n    using succ_add_one(1) by auto\n  with assms(1,4) have \"k #+ 1 \\<in> n #+ 1\"\n    using succ_ineq by simp\n  from \\<open>k #+ 1 \\<in> n #+ 1\\<close> have \n    \"?b`(k #+ 1) = (if k #+ 1 = 0 then x else a`((k #+ 1) #- 1))\"\n    by (rule ZF_fun_from_tot_val1)\n  with assms(2) \\<open>k\\<in>nat\\<close> show ?thesis\n    using func1_1_L1 unfolding Prepend_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 266
    },
    "247": {
        "type": "lemma",
        "text": "text\\<open>There is a natural bijection between the space $(n+1)\\rightarrow X$ of lists of length \n$n+1$ of elements of $X$ and the cartesian product $(n\\rightarrow X)\\times X$.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"\n  ",
        "using": [
            "init_props",
            "succ_iff",
            "apply_funtype",
            "ZF_fun_from_tot_val",
            "init_def",
            "finseq_restr_eq",
            "append_props",
            "init_append",
            "inj_def",
            "surj_def",
            "bij_def"
        ],
        "statement": "lemma lists_cart_prod: assumes \"n \\<in> nat\"\n  shows \"{\\<langle>x,\\<langle>Init(x),x`(n)\\<rangle>\\<rangle>. x \\<in> succ(n)\\<rightarrow>X} \\<in> bij(succ(n)\\<rightarrow>X,(n\\<rightarrow>X)\\<times>X)\"\n",
        "proof": "proof -\n  let ?f = \"{\\<langle>x,\\<langle>Init(x),x`(n)\\<rangle>\\<rangle>. x \\<in> succ(n)\\<rightarrow>X}\"\n  from assms have \"\\<forall>x \\<in> succ(n)\\<rightarrow>X. \\<langle>Init(x),x`(n)\\<rangle> \\<in> (n\\<rightarrow>X)\\<times>X\"\n    using init_props succ_iff apply_funtype by simp\n  then have I: \"?f: (succ(n)\\<rightarrow>X)\\<rightarrow>((n\\<rightarrow>X)\\<times>X)\" by (rule ZF_fun_from_total)\n  moreover from assms I have \"\\<forall>x\\<in>succ(n)\\<rightarrow>X.\\<forall>y\\<in>succ(n)\\<rightarrow>X. ?f`(x)=?f`(y) \\<longrightarrow> x=y\"\n    using ZF_fun_from_tot_val init_def finseq_restr_eq by auto\n  moreover have \"\\<forall>p\\<in>(n\\<rightarrow>X)\\<times>X.\\<exists>x\\<in>succ(n)\\<rightarrow>X. ?f`(x) = p\"\n  proof\n    fix p assume \"p \\<in> (n\\<rightarrow>X)\\<times>X\"\n    let ?x = \"Append(fst(p),snd(p))\"\n    from assms \\<open>p \\<in> (n\\<rightarrow>X)\\<times>X\\<close> have \"?x:succ(n)\\<rightarrow>X\" using append_props by simp\n    with I have \"?f`(?x) = \\<langle>Init(?x),?x`(n)\\<rangle>\" using succ_iff ZF_fun_from_tot_val by simp\n    moreover from assms \\<open>p \\<in> (n\\<rightarrow>X)\\<times>X\\<close> have \"Init(?x) = fst(p)\" and \"?x`(n) = snd(p)\"\n      using init_append append_props by auto\n    ultimately have \"?f`(?x) = \\<langle>fst(p),snd(p)\\<rangle>\" by auto\n    with \\<open>p \\<in> (n\\<rightarrow>X)\\<times>X\\<close> \\<open>?x:succ(n)\\<rightarrow>X\\<close> show \"\\<exists>x\\<in>succ(n)\\<rightarrow>X. ?f`(x) = p\" by auto\n  qed\n  ultimately show ?thesis using inj_def surj_def bij_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 267
    },
    "248": {
        "type": "lemma",
        "text": "text\\<open>We can identify a set of $X$-valued lists of length with $X$.\\<close>\n",
        "assumes": "",
        "using": [
            "singleton_list_bij",
            "pair_func_singleton",
            "ZF_fun_from_total",
            "bij_def",
            "inj_def",
            "ZF_fun_from_tot_val",
            "apply_funtype",
            "func_singleton_pair",
            "comp_conv_id"
        ],
        "statement": "lemma list_singleton_bij: shows \n  \"{\\<langle>x,{\\<langle>0,x\\<rangle>}\\<rangle>.x\\<in>X} \\<in> bij(X,1\\<rightarrow>X)\" and \n  \"{\\<langle>y,y`(0)\\<rangle>. y\\<in>1\\<rightarrow>X} = converse({\\<langle>x,{\\<langle>0,x\\<rangle>}\\<rangle>.x\\<in>X})\" and\n  \"{\\<langle>x,{\\<langle>0,x\\<rangle>}\\<rangle>.x\\<in>X} = converse({\\<langle>y,y`(0)\\<rangle>. y\\<in>1\\<rightarrow>X})\"\n",
        "proof": "proof -\n  let ?f = \"{\\<langle>y,y`(0)\\<rangle>. y\\<in>1\\<rightarrow>X}\"\n  let ?g = \"{\\<langle>x,{\\<langle>0,x\\<rangle>}\\<rangle>.x\\<in>X}\"\n  have \"1 = {0}\" by auto\n  then have \"?f \\<in> bij(1\\<rightarrow>X,X)\" and \"?g:X\\<rightarrow>(1\\<rightarrow>X)\" \n    using singleton_list_bij pair_func_singleton ZF_fun_from_total  \n    by auto\n  moreover have \"\\<forall>y\\<in>1\\<rightarrow>X.?g`(?f`(y)) = y\"\n  proof\n    fix y assume \"y:1\\<rightarrow>X\"\n    have \"?f:(1\\<rightarrow>X)\\<rightarrow>X\" using singleton_list_bij bij_def inj_def by simp\n    with \\<open>1 = {0}\\<close> \\<open>y:1\\<rightarrow>X\\<close> \\<open>?g:X\\<rightarrow>(1\\<rightarrow>X)\\<close> show \"?g`(?f`(y)) = y\" \n      using ZF_fun_from_tot_val apply_funtype func_singleton_pair\n      by simp \n  qed\n  ultimately show \"?g \\<in> bij(X,1\\<rightarrow>X)\" and \"?f = converse(?g)\" and \"?g = converse(?f)\"\n    using comp_conv_id by auto\nqed \n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 269
    },
    "249": {
        "type": "lemma",
        "text": "text\\<open>What is the inverse image of a set by the natural bijection between $X$-valued \n  singleton lists and $X$?\\<close>\n",
        "assumes": "assumes \"U\\<subseteq>X\" ",
        "using": [
            "func_singleton_pair",
            "pair_func_singleton"
        ],
        "statement": "lemma singleton_vimage: assumes \"U\\<subseteq>X\" shows \"{x\\<in>1\\<rightarrow>X. x`(0) \\<in> U} = { {\\<langle>0,y\\<rangle>}. y\\<in>U}\"\n",
        "proof": "proof\n  have \"1 = {0}\" by auto \n  { fix x assume \"x \\<in> {x\\<in>1\\<rightarrow>X. x`(0) \\<in> U}\"\n    with \\<open>1 = {0}\\<close> have \"x = {\\<langle>0, x`(0)\\<rangle>}\" using func_singleton_pair by auto   \n  } thus \"{x\\<in>1\\<rightarrow>X. x`(0) \\<in> U} \\<subseteq> { {\\<langle>0,y\\<rangle>}. y\\<in>U}\" by auto\n  { fix x assume \"x \\<in> { {\\<langle>0,y\\<rangle>}. y\\<in>U}\"\n    then obtain y where \"x = {\\<langle>0,y\\<rangle>}\" and \"y\\<in>U\" by auto\n    with \\<open>1 = {0}\\<close> assms have \"x:1\\<rightarrow>X\" using pair_func_singleton by auto\n  } thus \"{ {\\<langle>0,y\\<rangle>}. y\\<in>U} \\<subseteq> {x\\<in>1\\<rightarrow>X. x`(0) \\<in> U}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 270
    },
    "250": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about extending a list by values from a set.\\<close> \n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"U \\<subseteq> n\\<rightarrow>X\" and A3: \"V \\<subseteq> X\"\n  ",
        "using": [
            "init_props",
            "append_props",
            "init_append"
        ],
        "statement": "lemma list_append_from: assumes A1: \"n \\<in> nat\" and A2: \"U \\<subseteq> n\\<rightarrow>X\" and A3: \"V \\<subseteq> X\"\n  shows \n  \"{x \\<in> succ(n)\\<rightarrow>X. Init(x) \\<in> U \\<and> x`(n) \\<in> V} = (\\<Union>y\\<in>V.{Append(x,y).x\\<in>U})\"\n",
        "proof": "proof -\n  { fix x assume \"x \\<in> {x \\<in> succ(n)\\<rightarrow>X. Init(x) \\<in> U \\<and> x`(n) \\<in> V}\"\n    then have \"x \\<in> succ(n)\\<rightarrow>X\" and \"Init(x) \\<in> U\" and I: \"x`(n) \\<in> V\"\n      by auto\n    let ?y = \"x`(n)\"\n    from A1 and \\<open>x \\<in> succ(n)\\<rightarrow>X\\<close>  have \"x = Append(Init(x),?y)\"\n      using init_props by simp\n    with I and \\<open>Init(x) \\<in> U\\<close> have \"x \\<in> (\\<Union>y\\<in>V.{Append(a,y).a\\<in>U})\" by auto\n  }\n  moreover\n  { fix x assume \"x \\<in> (\\<Union>y\\<in>V.{Append(a,y).a\\<in>U})\"\n    then obtain a y where \"y\\<in>V\" and \"a\\<in>U\" and \"x = Append(a,y)\" by auto\n    with A2 A3 have \"x: succ(n)\\<rightarrow>X\" using append_props by blast \n    from A2 A3 \\<open>y\\<in>V\\<close> \\<open>a\\<in>U\\<close> have \"a:n\\<rightarrow>X\" and \"y\\<in>X\" by auto\n    with A1 \\<open>a\\<in>U\\<close>  \\<open>y\\<in>V\\<close> \\<open>x = Append(a,y)\\<close> have \"Init(x) \\<in> U\" and  \"x`(n) \\<in> V\"\n      using append_props init_append by auto    \n    with \\<open>x: succ(n)\\<rightarrow>X\\<close> have \"x \\<in> {x \\<in> succ(n)\\<rightarrow>X. Init(x) \\<in> U \\<and> x`(n) \\<in> V}\"\n      by auto\n  }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 271
    },
    "251": {
        "type": "theorem",
        "text": "text\\<open>First, a transitive closure variation on @{thm rtrancl_unfold}.\\<close>\n",
        "assumes": "",
        "using": [
            "rtrancl_unfold[of",
            "\"converse(r)\"]",
            "rtrancl_converse",
            "converse_comp",
            "converse_converse[OF",
            "rtrancl_type]",
            "rtrancl_type",
            "comp_def",
            "converse_converse[of",
            "\"id(field(r))\\<union>(r^*",
            "O",
            "r)\"",
            "\"field(r)\"",
            "\"\\<lambda>_.",
            "field(r)\"]"
        ],
        "statement": "theorem rtrancl_rev:\n  shows \"r^* = id(field(r)) \\<union> (r^* O r)\"\n",
        "proof": "proof-\n  have \"converse(r)^* = id(field(converse(r))) \\<union> (converse(r) O converse(r)^*)\"\n    using rtrancl_unfold[of \"converse(r)\"] by auto\n  then have \"converse(r^*) = id(field(r)) \\<union> (converse(r) O converse(r^*))\"\n    using rtrancl_converse by auto\n  then have \"converse(r^*) = id(field(r)) \\<union> (converse(r^* O r))\"\n    using converse_comp by auto moreover\n  {\n    fix t assume t:\"t\\<in>id(field(r)) \\<union> (converse(r^* O r))\"\n    {\n      assume \"t\\<in>id(field(r))\"\n      then have \"t\\<in>converse(id(field(r)) \\<union> (r^* O r))\" by auto\n    } moreover\n    {\n      assume \"t\\<notin>id(field(r))\"\n      with t have \"t\\<in>converse(r^* O r)\" by auto\n      then have \"t\\<in>converse(id(field(r)) \\<union> (r^* O r))\" by auto\n    }\n    ultimately have \"t\\<in>converse(id(field(r)) \\<union> (r^* O r))\" by auto\n  }\n  moreover\n  {\n    fix t assume t:\"t\\<in>converse(id(field(r)) \\<union> (r^* O r))\"\n    then obtain t1 t2 where t12:\"t=\\<langle>t1,t2\\<rangle>\" \"\\<langle>t2,t1\\<rangle>\\<in>id(field(r)) \\<union> (r^* O r)\"\n      by auto\n    {\n      assume \"\\<langle>t2,t1\\<rangle>\\<in>id(field(r))\"\n      with t12(1) have \"t\\<in>id(field(r))\" by auto\n      then have \"t\\<in>id(field(r)) \\<union> converse(r^* O r)\" by auto\n    } moreover\n    {\n      assume \"\\<langle>t2,t1\\<rangle>\\<notin>id(field(r))\"\n      with t12(2) have \"\\<langle>t2,t1\\<rangle>\\<in>(r^* O r)\" by auto\n      with t12(1) have \"t\\<in>converse(r^* O r)\" by auto\n      then have \"t\\<in>id(field(r)) \\<union> converse(r^* O r)\" by auto\n    }\n    ultimately have \"t\\<in>id(field(r)) \\<union> converse(r^* O r)\" by auto\n  }\n  ultimately have \"converse(id(field(r)) \\<union> (r^* O r)) = converse(r^*)\" by auto\n  then have \"converse(converse(id(field(r)) \\<union> (r^* O r))) = r^*\" using converse_converse[OF rtrancl_type]\n    by auto moreover\n  {\n    fix t assume t:\"t\\<in>id(field(r)) \\<union> (r^* O r)\"\n    {\n      assume \"t\\<in>id(field(r))\"\n      then have \"t:field(r)*field(r)\" by auto\n    } moreover\n    {\n      assume \"t\\<notin>id(field(r))\"\n      with t have \"t\\<in>r^* O r\" by auto\n      then have \"t:field(r)*field(r)\" using rtrancl_type unfolding comp_def by auto\n    } ultimately\n    have \"t\\<in>field(r)*field(r)\" by auto\n  }\n  ultimately show ?thesis using converse_converse[of \"id(field(r))\\<union>(r^* O r)\" \"field(r)\" \"\\<lambda>_. field(r)\"] by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 272
    },
    "252": {
        "type": "definition",
        "text": "text\\<open>A language is a subset of words.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  IsALanguage (\"_{is a language with alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> L {is a language with alphabet} \\<Sigma> \\<equiv> L \\<subseteq> Lists(\\<Sigma>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 273
    },
    "253": {
        "type": "lemma",
        "text": "text\\<open>The set of all words, and the set of no words are languages.\\<close>\n",
        "assumes": "assumes \"Finite(\\<Sigma>)\"\n  ",
        "using": [],
        "statement": "lemma full_empty_language:\n  assumes \"Finite(\\<Sigma>)\"\n  shows \"Lists(\\<Sigma>) {is a language with alphabet} \\<Sigma>\"\n  and \"0 {is a language with alphabet} \\<Sigma>\"\n  unfolding IsALanguage_def[OF assms] by auto\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 274
    },
    "254": {
        "type": "definition",
        "text": "text\\<open>A deterministic finite state automaton is defined\nas a finite set of states, an initial state, \na transition function from state to state based on\nthe word and a set of final states.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  DFSA (\"'(_,_,_,_'){is an DFSA for alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an DFSA for alphabet}\\<Sigma> \\<equiv> Finite(S) \\<and> s\\<^sub>0 \\<in> S \\<and> F \\<subseteq> S \\<and> t:S\\<times>\\<Sigma> \\<rightarrow> S\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 275
    },
    "255": {
        "type": "lemma",
        "text": "text\\<open>Destruction lemma about deterministic finite\nstate automata.\\<close>\n",
        "assumes": "",
        "using": [
            "DFSA",
            "DFSA_def[OF",
            "finite_alphabet]"
        ],
        "statement": "lemma (in DetFinStateAuto) DFSA_dest:\n  shows \"s\\<^sub>0\\<in>S\" \"F\\<subseteq>S\" \"t:S\\<times>\\<Sigma> \\<rightarrow> S\" \"Finite(S)\" ",
        "proof": "using DFSA unfolding DFSA_def[OF finite_alphabet] by auto\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 277
    },
    "256": {
        "type": "lemma",
        "text": "text\\<open>The set of words that reduce to final states forms a language.\nThis is by definition.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in DetFinStateAuto) DFSA_language:\n  shows \"{i\\<in>Lists(\\<Sigma>). i <-D (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>} {is a language with alphabet}\\<Sigma>\"\n  unfolding IsALanguage_def[OF finite_alphabet] by auto\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 278
    },
    "257": {
        "type": "lemma",
        "text": "text\\<open>The relation is an actual relation, but even\nmore it is a function (hence the adjective deterministic).\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in DetFinStateAuto) reduce_is_relation_function:\n  shows \"relation(r\\<^sub>D)\" \"function(r\\<^sub>D)\" unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA]\n   relation_def function_def by auto\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 279
    },
    "258": {
        "type": "lemma",
        "text": "text\\<open>The relation, that is actually a function\nhas the following domain and range:\\<close>\n",
        "assumes": "",
        "using": [
            "init_NElist(1)",
            "last_type",
            "apply_type[OF",
            "T]"
        ],
        "statement": "lemma (in DetFinStateAuto) reduce_function:\nshows \"r\\<^sub>D:NELists(\\<Sigma>)\\<times>S\\<rightarrow>Lists(\\<Sigma>)\\<times>S\"\n",
        "proof": "proof-\n  from DFSA have T:\"t:S\\<times>\\<Sigma> \\<rightarrow> S\" unfolding DFSA_def[OF finite_alphabet] by auto\n  {\n    fix x assume \"x\\<in>r\\<^sub>D\"\n    then obtain l s where x:\"l \\<in> NELists(\\<Sigma>)\" \"s \\<in> S\" \"x = \\<langle>\\<langle>l,s\\<rangle>,\\<langle>Init(l),t`\\<langle>s,Last(l)\\<rangle>\\<rangle>\\<rangle>\" unfolding\n      DFSAExecutionRelation_def[OF finite_alphabet DFSA] by auto\n    from x(1) have \"Init(l) \\<in> Lists(\\<Sigma>)\" using init_NElist(1) by auto moreover\n    from x(1) have \"Last(l) \\<in> \\<Sigma>\" using last_type by auto\n    with x(2) have \"t`\\<langle>s,Last(l)\\<rangle> \\<in> S\" using apply_type[OF T] by auto\n    moreover note x\n    ultimately have \"x\\<in>(NELists(\\<Sigma>)\\<times>S)\\<times>(Lists(\\<Sigma>)\\<times>S)\" by auto\n  }\n  then have r:\"r\\<^sub>D\\<in>Pow((NELists(\\<Sigma>)\\<times>S)\\<times>(Lists(\\<Sigma>)\\<times>S))\" by auto moreover\n  {\n    fix x assume \"x\\<in>NELists(\\<Sigma>)\\<times>S\"\n    then obtain l s where x:\"l\\<in>NELists(\\<Sigma>)\" \"s\\<in>S\" \"x=\\<langle>l,s\\<rangle>\" by auto\n    then have \"\\<langle>\\<langle>l,s\\<rangle>,\\<langle>Init(l),t`\\<langle>s,Last(l)\\<rangle>\\<rangle>\\<rangle>\\<in>r\\<^sub>D\" unfolding\n      DFSAExecutionRelation_def[OF finite_alphabet DFSA] by auto\n    with x(3) have \"x\\<in>domain(r\\<^sub>D)\" unfolding domain_def by auto\n  }\n  then have \"NELists(\\<Sigma>)\\<times>S \\<subseteq> domain(r\\<^sub>D)\" by auto moreover\n  note reduce_is_relation_function(2)\n  ultimately show ?thesis unfolding Pi_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 280
    },
    "259": {
        "type": "corollary",
        "text": "text\\<open>The field of the relation contains all pairs\nwith non-empty\nwords, but we cannot assume that it contains all pairs.\\<close>\n",
        "assumes": "",
        "using": [
            "init_NElist(1)",
            "last_type",
            "apply_type[OF",
            "T]",
            "domain_of_fun[OF",
            "reduce_function]",
            "field_def"
        ],
        "statement": "corollary (in DetFinStateAuto) reduce_field:\nshows \"field(r\\<^sub>D) \\<subseteq> Lists(\\<Sigma>)\\<times>S\" \"NELists(\\<Sigma>)\\<times>S \\<subseteq> field(r\\<^sub>D)\"\n",
        "proof": "proof-\n  from DFSA have T:\"t:S\\<times>\\<Sigma> \\<rightarrow> S\" unfolding DFSA_def[OF finite_alphabet] by auto\n  {\n    fix x assume \"x\\<in>field(r\\<^sub>D)\"\n    then have E:\"\\<exists>y. \\<langle>x,y\\<rangle>\\<in>r\\<^sub>D \\<or> \\<langle>y,x\\<rangle>\\<in>r\\<^sub>D\" unfolding domain_def range_def field_def by auto\n    {\n      assume \"\\<exists>y. \\<langle>x,y\\<rangle>\\<in>r\\<^sub>D\"\n      then have \"x\\<in>NELists(\\<Sigma>)\\<times>S\" unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA]\n        by auto\n      then have \"x\\<in>Lists(\\<Sigma>)\\<times>S\" unfolding Lists_def NELists_def by auto\n    } moreover\n    {\n      assume \"\\<not>(\\<exists>y. \\<langle>x,y\\<rangle>\\<in>r\\<^sub>D)\"\n      with E have \"\\<exists>y.\\<langle>y,x\\<rangle>\\<in>r\\<^sub>D\" by auto\n      then obtain u v where y:\"u\\<in>NELists(\\<Sigma>)\" \"v\\<in>S\" \"x=\\<langle>Init(u),t`\\<langle>v,Last(u)\\<rangle>\\<rangle>\"\n        unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA] by auto\n      from y(1) have \"Init(u) \\<in> Lists(\\<Sigma>)\" using init_NElist(1) by auto moreover\n      from y(1) have \"Last(u) \\<in> \\<Sigma>\" using last_type by auto\n      with y(2) have \"t`\\<langle>v,Last(u)\\<rangle> \\<in> S\" using apply_type[OF T] by auto\n      moreover note y(3) ultimately have \"x\\<in>Lists(\\<Sigma>)\\<times>S\" by auto\n    }\n    ultimately have \"x\\<in>Lists(\\<Sigma>)\\<times>S\" by auto\n  }\n  then show \"field(r\\<^sub>D) \\<subseteq> Lists(\\<Sigma>)\\<times>S\" by auto\n  show \"NELists(\\<Sigma>)\\<times>S \\<subseteq> field(r\\<^sub>D)\"\n    using domain_of_fun[OF reduce_function] unfolding field_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 281
    },
    "260": {
        "type": "lemma",
        "text": "text\\<open>If a word is a reduced version of an other,\nthen it can be encoded as a restriction.\\<close>\n",
        "assumes": "assumes \"\\<langle>\\<langle>w,s\\<rangle>,\\<langle>u,v\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\"\n  ",
        "using": [
            "rtrancl_field[of",
            "r\\<^sub>D]",
            "relation_field_times_field[OF",
            "relation_rtrancl[of",
            "r\\<^sub>D]]",
            "reduce_field(1)",
            "restrict_idem",
            "Pi_def",
            "domain_of_fun",
            "init_NElist(2)",
            "restrict_restrict",
            "NELists_def",
            "pred_succ_eq",
            "domain_of_fun[of",
            "y1",
            "_",
            "\"\\<lambda>_.",
            "\\<Sigma>\"]",
            "\"Init(y1)\""
        ],
        "statement": "lemma (in DetFinStateAuto) seq_is_restriction:\n  fixes w s u v\n  assumes \"\\<langle>\\<langle>w,s\\<rangle>,\\<langle>u,v\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\"\n  shows \"restrict(w,domain(u)) = u\"\n",
        "proof": "proof-\n  from assms have \"\\<langle>w,s\\<rangle>\\<in>field(r\\<^sub>D)\" using rtrancl_field[of r\\<^sub>D] relation_field_times_field[OF relation_rtrancl[of r\\<^sub>D]] by auto\n  then have \"w\\<in>Lists(\\<Sigma>)\" using reduce_field(1) by auto\n  then obtain n where \"w:n\\<rightarrow>\\<Sigma>\" unfolding Lists_def by auto\n  then have \"restrict(w,n) = w\" \"w:n\\<rightarrow>\\<Sigma>\" using restrict_idem unfolding Pi_def by auto\n  then have base:\"restrict(w,domain(w)) = w\" using domain_of_fun by auto\n  {\n    fix y z\n    assume as:\"\\<langle>\\<langle>w, s\\<rangle>, y\\<rangle> \\<in> r\\<^sub>D^*\" \"\\<langle>y, z\\<rangle> \\<in> r\\<^sub>D\" \"restrict(w, domain(fst(y))) = fst(y)\"\n    from as(1) have \"y:field(r\\<^sub>D)\"  using rtrancl_field[of r\\<^sub>D] relation_field_times_field[OF relation_rtrancl[of r\\<^sub>D]] by auto\n    then obtain y1 y2 where y:\"y=\\<langle>y1,y2\\<rangle>\" \"y1\\<in>Lists(\\<Sigma>)\" \"y2\\<in>S\" using reduce_field(1)\n      by auto\n    with as(2) have z:\"z=\\<langle>Init(y1),t`\\<langle>y2,Last(y1)\\<rangle>\\<rangle>\" \"y1\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA]\n      by auto\n    then have \"fst(z) = Init(y1)\" by auto\n    with z(2) have S:\"succ(domain(fst(z))) = domain(y1)\" using init_NElist(2) by auto\n    from as(3) y(1) have \"restrict(w,domain(y1)) = y1\" by auto\n    then have \"restrict(restrict(w,domain(y1)),pred(domain(y1))) = Init(y1)\" unfolding Init_def by auto\n    then have w:\"restrict(w,domain(y1)\\<inter>pred(domain(y1))) = Init(y1)\" using restrict_restrict by auto\n    from z(2) obtain q where q:\"domain(y1) = succ(q)\" \"q\\<in>nat\" using domain_of_fun unfolding NELists_def by auto\n    then have \"pred(domain(y1)) \\<subseteq> domain(y1)\" using pred_succ_eq by auto\n    then have \"domain(y1) \\<inter> pred(domain(y1)) = pred(domain(y1))\" by auto\n    with w have \"restrict(w,pred(domain(y1))) = Init(y1)\" by auto moreover\n    from q z(2) init_props(1)[of _ y1 \\<Sigma>] have \"domain(Init(y1)) = pred(domain(y1))\" \n      using domain_of_fun[of y1 _ \"\\<lambda>_. \\<Sigma>\"] domain_of_fun[of \"Init(y1)\" _ \"\\<lambda>_. \\<Sigma>\"] \n      unfolding NELists_def by auto ultimately\n    have \"restrict(w,domain(Init(y1))) = Init(y1)\" by auto\n    with z(1) have \"restrict(w,domain(fst(z))) = fst(z)\" by auto\n  }\n  then have reg:\"\\<forall>y z. \\<langle>\\<langle>w, s\\<rangle>, y\\<rangle> \\<in> r\\<^sub>D^* \\<longrightarrow>\n             (\\<langle>y, z\\<rangle> \\<in> r\\<^sub>D \\<longrightarrow>\n             (restrict(w, domain(fst(y))) = fst(y) \\<longrightarrow>\n             restrict(w, domain(fst(z))) = fst(z)))\" by auto\n  have \"restrict(w, domain(fst(\\<langle>u, v\\<rangle>))) = fst(\\<langle>u, v\\<rangle>)\"\n  proof(rule rtrancl_induct[of \"\\<langle>w,s\\<rangle>\" \"\\<langle>u,v\\<rangle>\" r\\<^sub>D \"\\<lambda>q. restrict(w,domain(fst(q))) = fst(q)\"])\n    from base show \"restrict(w,domain(fst(\\<langle>w,s\\<rangle>))) = fst(\\<langle>w,s\\<rangle>)\" by auto\n    from assms show \"\\<langle>\\<langle>w, s\\<rangle>, u, v\\<rangle> \\<in> r\\<^sub>D^*\" by auto\n    {\n      fix y z\n      assume as:\"\\<langle>\\<langle>w, s\\<rangle>, y\\<rangle> \\<in> r\\<^sub>D^*\" \"\\<langle>y, z\\<rangle> \\<in> r\\<^sub>D\" \"restrict(w, domain(fst(y))) = fst(y)\"\n      from as(1) have \"y:field(r\\<^sub>D)\"  using rtrancl_field[of r\\<^sub>D] relation_field_times_field[OF relation_rtrancl[of r\\<^sub>D]] by auto\n      then obtain y1 y2 where y:\"y=\\<langle>y1,y2\\<rangle>\" \"y1\\<in>Lists(\\<Sigma>)\" \"y2\\<in>S\" using reduce_field(1)\n        by auto\n      with as(2) have z:\"z=\\<langle>Init(y1),t`\\<langle>y2,Last(y1)\\<rangle>\\<rangle>\" \"y1\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA]\n        by auto\n      then have \"fst(z) = Init(y1)\" by auto\n      with z(2) have S:\"succ(domain(fst(z))) = domain(y1)\" using init_NElist(2) by auto\n      from as(3) y(1) have \"restrict(w,domain(y1)) = y1\" by auto\n      then have \"restrict(restrict(w,domain(y1)),pred(domain(y1))) = Init(y1)\" unfolding Init_def by auto\n      then have w:\"restrict(w,domain(y1)\\<inter>pred(domain(y1))) = Init(y1)\" using restrict_restrict by auto\n      from z(2) obtain q where q:\"domain(y1) = succ(q)\" \"q\\<in>nat\" using domain_of_fun unfolding NELists_def by auto\n      then have \"pred(domain(y1)) \\<subseteq> domain(y1)\" using pred_succ_eq by auto\n      then have \"domain(y1) \\<inter> pred(domain(y1)) = pred(domain(y1))\" by auto\n      with w have \"restrict(w,pred(domain(y1))) = Init(y1)\" by auto moreover\n      from q z(2) init_props(1)[of _ y1 \\<Sigma>] have \"domain(Init(y1)) = pred(domain(y1))\" \n        using domain_of_fun[of y1 _ \"\\<lambda>_. \\<Sigma>\"] domain_of_fun[of \"Init(y1)\" _ \"\\<lambda>_. \\<Sigma>\"] \n        unfolding NELists_def by auto ultimately\n      have \"restrict(w,domain(Init(y1))) = Init(y1)\" by auto\n      with z(1) show \"restrict(w,domain(fst(z))) = fst(z)\" by auto\n    }\n  qed\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 282
    },
    "261": {
        "type": "lemma",
        "text": "text\\<open>Any non-empty word can be reduced to the empty\nstring, but it does not always end in a final state.\\<close>\n",
        "assumes": "assumes \"w\\<in>NELists(\\<Sigma>)\"\n  ",
        "using": [
            "domain_of_fun",
            "init_NElist",
            "pred_succ_eq",
            "r_into_rtrancl",
            "apply_type[OF",
            "DFSA_dest(3)]",
            "last_type[OF",
            "y]",
            "last_type",
            "rtrancl_into_trancl2",
            "trancl_into_rtrancl",
            "d",
            "assms",
            "NELists_def",
            "nat_induct[of",
            "_",
            "?P,",
            "OF",
            "dom",
            "base]",
            "non_zero_List_func_is_NEList",
            "DFSA_dest(1)"
        ],
        "statement": "lemma (in DetFinStateAuto) endpoint_exists:\n  assumes \"w\\<in>NELists(\\<Sigma>)\"\n  shows \"\\<exists>q \\<in> S. \\<langle>\\<langle>w,s\\<^sub>0\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle> \\<in> r\\<^sub>D^*\"\n",
        "proof": "proof-\n  let ?P=\"\\<lambda>k. \\<forall>y\\<in>Lists(\\<Sigma>). domain(y) = k \\<longrightarrow> y=0 \\<or> (\\<forall>ss\\<in>S. (\\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*))\"\n  {\n    fix y assume \"y\\<in>Lists(\\<Sigma>)\" \"domain(y) = 0\"\n    with assms have \"y=0\" unfolding Lists_def using domain_of_fun by auto\n    then have \"y=0 \\<or> (\\<forall>ss\\<in>S. (\\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*))\" by auto\n  }\n  then have base:\"?P(0)\" by auto\n  {\n    fix k assume hyp:\"?P(k)\" \"k\\<in>nat\"\n    {\n      fix y assume as:\"y\\<in>Lists(\\<Sigma>)\" \"domain(y) = succ(k)\"\n      from as have \"y:succ(k)\\<rightarrow>\\<Sigma>\" unfolding Lists_def using domain_of_fun by auto\n      with hyp(2) have y:\"y:NELists(\\<Sigma>)\" unfolding NELists_def by auto\n      then have \"Init(y):Lists(\\<Sigma>)\" \"succ(domain(Init(y))) = domain(y)\" using init_NElist by auto\n      with as(2) have D:\"Init(y):Lists(\\<Sigma>)\" \"domain(Init(y)) = k\" using pred_succ_eq by auto\n      with hyp(1) have d:\"Init(y) = 0 \\<or> (\\<forall>ss\\<in>S. (\\<exists>q\\<in>S. \\<langle>\\<langle>Init(y),ss\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*))\" by auto\n      {\n        assume iy0:\"Init(y) = 0\"\n        {\n          fix ss assume \"ss\\<in>S\"\n          with iy0 y have \"\\<langle>\\<langle>y,ss\\<rangle>,0,t`\\<langle>ss,Last(y)\\<rangle>\\<rangle>\\<in>r\\<^sub>D\" unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA]\n            by auto\n          then have \"\\<langle>\\<langle>y,ss\\<rangle>,0,t`\\<langle>ss,Last(y)\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\" using r_into_rtrancl by auto\n          moreover from `ss\\<in>S` have \"t`\\<langle>ss,Last(y)\\<rangle> \\<in>S\" using apply_type[OF DFSA_dest(3)]\n            last_type[OF y] by auto\n          ultimately have \"\\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,0,q\\<rangle>:r\\<^sub>D^*\" by auto\n        }\n        then have \"\\<forall>ss\\<in>S. \\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,0,q\\<rangle>:r\\<^sub>D^*\" by auto\n        then have \"y = 0 \\<or> (\\<forall>ss\\<in>S. \\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,0,q\\<rangle>:r\\<^sub>D^*)\" by auto\n      } moreover\n      {\n        assume qS:\"\\<forall>ss\\<in>S. \\<exists>q\\<in>S. \\<langle>\\<langle>Init(y),ss\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\"\n        {\n          fix ss assume \"ss\\<in>S\"\n          with y have \"\\<langle>\\<langle>y,ss\\<rangle>,Init(y),t`\\<langle>ss,Last(y)\\<rangle>\\<rangle>\\<in>r\\<^sub>D\" unfolding DFSAExecutionRelation_def[OF finite_alphabet DFSA]\n            by auto\n          moreover from `ss\\<in>S` y have \"t`\\<langle>ss,Last(y)\\<rangle> \\<in>S\" using apply_type[OF DFSA_dest(3)]\n            last_type by auto\n          with qS have \"\\<exists>q\\<in>S. \\<langle>\\<langle>Init(y),t`\\<langle>ss,Last(y)\\<rangle>\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\" by auto\n          then obtain q where \"q\\<in>S\" \"\\<langle>\\<langle>Init(y),t`\\<langle>ss,Last(y)\\<rangle>\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\" by auto\n          ultimately have \"\\<langle>\\<langle>y,ss\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\" \"q\\<in>S\" using rtrancl_into_trancl2\n            trancl_into_rtrancl by auto\n          then have \"\\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>D^*\" by auto\n        }\n        then have \"y = 0 \\<or> (\\<forall>ss\\<in>S. \\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,0,q\\<rangle>:r\\<^sub>D^*)\"  by auto\n      } ultimately\n      have \"y = 0 \\<or> (\\<forall>ss\\<in>S. \\<exists>q\\<in>S. \\<langle>\\<langle>y,ss\\<rangle>,0,q\\<rangle>:r\\<^sub>D^*)\" using d by auto\n    }\n    then have \"?P(succ(k))\" by auto\n  }\n  then have ind:\"\\<And>k. k\\<in>nat \\<Longrightarrow> ?P(k) \\<Longrightarrow> ?P(succ(k))\" by blast\n  have dom:\"domain(w) \\<in> nat\" using assms unfolding NELists_def using domain_of_fun by auto\n  from ind have \"?P(domain(w))\" using nat_induct[of _ ?P, OF dom base] by auto\n  with assms have \"(\\<forall>ss\\<in>S. \\<exists>q\\<in>S. \\<langle>\\<langle>w, ss\\<rangle>, 0, q\\<rangle> \\<in> r\\<^sub>D^*)\" \n    using non_zero_List_func_is_NEList by auto\n  then show ?thesis using DFSA_dest(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 283
    },
    "262": {
        "type": "definition",
        "text": "text\\<open>Empty state\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition empty where\n  \"empty \\<equiv> 2\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 284
    },
    "263": {
        "type": "definition",
        "text": "text\\<open>The string starts with $0$ state\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition ends0 where\n  \"ends0 \\<equiv> succ(2)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 285
    },
    "264": {
        "type": "definition",
        "text": "text\\<open>The string ends with $1$ state\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition starts1 where\n  \"starts1 \\<equiv> 1\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 286
    },
    "265": {
        "type": "definition",
        "text": "text\\<open>The string ends with $0$ state\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition starts0 where\n  \"starts0 \\<equiv> 0\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 287
    },
    "266": {
        "type": "definition",
        "text": "text\\<open>The states are the previous 4 states.\nThey are encoded as natural numbers to make\nit easier to reason about them, and as human\nreadable variable names to make it easier to\nunderstand.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition states where\n  \"states \\<equiv> {empty, starts0, starts1, ends0}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 288
    },
    "267": {
        "type": "definition",
        "text": "text\\<open>The final state is @{term starts0}\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition finalStates where\n\"finalStates \\<equiv> {starts0}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 289
    },
    "268": {
        "type": "lemma",
        "text": "text\\<open>If the string starts in $0$ and has\nreached states @{term starts0} or @{term starts1};\nthen it reduces to @{term starts0}.\\<close>\n",
        "assumes": "assumes \"w\\<in>NELists(2)\" \"w`0 = 0\"\n  ",
        "using": [
            "domain_of_fun",
            "nat_into_Finite[of",
            "2]",
            "funT",
            "apply_equality[of",
            "\"\\<langle>starts0,0\\<rangle>\"",
            "starts0",
            "transFun",
            "\"states\\<times>2\"",
            "\"\\<lambda>_.",
            "states\"]",
            "\"\\<langle>starts1,0\\<rangle>\"",
            "\"\\<langle>starts0,1\\<rangle>\"",
            "starts1",
            "\"\\<langle>starts1,1\\<rangle>\"",
            "last_seq_elem",
            "apply_type[OF",
            "s(1),",
            "of",
            "s]",
            "pred_succ_eq",
            "y(2)",
            "Last_def",
            "y(1)",
            "init_props(1)[OF",
            "s(2,1)]",
            "domain_of_fun[OF",
            "s(1)]",
            "r_into_rtrancl",
            "y(1,2)",
            "Nat_ZF_1_L3",
            "succ_inject",
            "s(2,1)].",
            "ultimately",
            "have",
            "yu:\"Init(y):succ(u)\\<rightarrow>2\"",
            "NELists_def",
            "init_props(2)[OF",
            "nat_succI[OF",
            "u(2)],",
            "y",
            "s(1)",
            "`s=succ(u)`",
            "empty_in_every_succ[OF",
            "u(2)]",
            "DFSAExecutionRelation_def[OF",
            "finA",
            "dfsaFrom0To1.DFSA]",
            "rtrancl_into_trancl2",
            "trancl_into_rtrancl",
            "assms(2,1)"
        ],
        "statement": "lemma invariant_state_0_1:\n  fixes w\n  assumes \"w\\<in>NELists(2)\" \"w`0 = 0\"\n  shows \"\\<langle>\\<langle>w,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" \"\\<langle>\\<langle>w,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\"\n",
        "proof": "proof-\n  from assms(1) obtain n where w:\"n:nat\" \"w:succ(n)\\<rightarrow>2\" unfolding NELists_def by auto\n  then have dom:\"domain(w)\\<in>nat\" using domain_of_fun by auto\n  {\n    fix q assume \"q\\<in>NELists(2)\"\n    then obtain m where \"m\\<in>nat\" \"q:succ(m)\\<rightarrow>2\" unfolding NELists_def by auto\n    then have \"domain(q)\\<noteq>0\" using domain_of_fun by auto\n  }\n  then have base:\"\\<forall>w. w \\<in> NELists(2) \\<and> w`0 = 0 \\<and> domain(w) = 0 \\<longrightarrow>\n        \\<langle>\\<langle>w, starts0\\<rangle>, 0, starts0\\<rangle> \\<in> r{0.*1}^* \\<and> \\<langle>\\<langle>w, starts1\\<rangle>, 0, starts0\\<rangle> \\<in> r{0.*1}^*\" by auto\n  from w(2) have domN0:\"domain(w)\\<noteq> 0\" using domain_of_fun by auto\n  have finA:\"Finite(2)\" using nat_into_Finite[of 2] by auto  \n  have funT:\"transFun:states\\<times>2\\<rightarrow>states\" unfolding Pi_def function_def by auto\n  have t00:\"transFun`\\<langle>starts0,0\\<rangle> = starts0\" using funT apply_equality[of \"\\<langle>starts0,0\\<rangle>\" starts0 transFun \"states\\<times>2\" \"\\<lambda>_. states\"] by auto      \n  have t01:\"transFun`\\<langle>starts1,0\\<rangle> = starts0\" using funT apply_equality[of \"\\<langle>starts1,0\\<rangle>\" starts0 transFun \"states\\<times>2\" \"\\<lambda>_. states\"] by auto\n  have t10:\"transFun`\\<langle>starts0,1\\<rangle> = starts1\" using funT apply_equality[of \"\\<langle>starts0,1\\<rangle>\" starts1 transFun \"states\\<times>2\" \"\\<lambda>_. states\"] by auto\n  have t11:\"transFun`\\<langle>starts1,1\\<rangle> = starts1\" using funT apply_equality[of \"\\<langle>starts1,1\\<rangle>\" starts1 transFun \"states\\<times>2\" \"\\<lambda>_. states\"] by auto\n  {\n    fix ka assume kaNat:\"ka:nat\"\n    assume k:\"\\<forall>w. w \\<in> NELists(2) \\<and> w`0 = 0 \\<and> domain(w) = ka \\<longrightarrow> (\\<langle>\\<langle>w,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^* \\<and> \\<langle>\\<langle>w,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*)\"\n    {\n      fix y assume y:\"y\\<in>NELists(2)\" \"y`0 = 0\" \"domain(y) = succ(ka)\"\n      from y(1) obtain s where s:\"y:succ(s)\\<rightarrow>2\" \"s\\<in>nat\" unfolding NELists_def by auto\n      then have L:\"Last(y) = y`s\" using last_seq_elem by auto\n      then have last_2:\"Last(y) \\<in> 2\" using apply_type[OF s(1), of s] by auto\n      {\n        assume ka:\"ka =0\"\n        with y(3) have \"pred(domain(y)) = 0\" using pred_succ_eq by auto\n        then have y00:\"y`0 = 0\" using y(2) unfolding Last_def by auto\n        then have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),transFun`\\<langle>starts0,Last(y)\\<rangle>\\<rangle>\\<rangle>\\<in>r{0.*1}\" unfolding\n          DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] \n          using y(1) by auto\n        with last_2 t00 t10 have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),Last(y)\\<rangle>\\<rangle>\\<in>r{0.*1}\" by auto moreover\n        from ka y(3) s(1) have \"Init(y):0\\<rightarrow>2\" using init_props(1)[OF s(2,1)]\n          domain_of_fun[OF s(1)] by auto\n        then have y0:\"Init(y) = 0\" unfolding Pi_def by auto moreover\n        from ka s(1) y(3) have \"s=0\" using domain_of_fun by auto\n        with L have LL:\"y`0 = Last(y)\" by auto moreover note y(2)\n        ultimately have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}\" by auto\n        then have A:\"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using r_into_rtrancl by auto\n        note t01 moreover have \"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>Init(y),transFun`\\<langle>starts1,Last(y)\\<rangle>\\<rangle>\\<rangle> \\<in> r{0.*1}\"\n          unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] using y(1,2) by auto\n        moreover note t11 last_2 y0 LL y(2) ultimately have \"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> r{0.*1}\" by auto\n        then have B:\"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using r_into_rtrancl by auto\n        with A have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^* \\<and> \\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" by auto\n      } moreover\n      {\n        assume ka:\"ka\\<noteq>0\"\n        with kaNat obtain u where u:\"ka=succ(u)\" \"u\\<in>nat\" using Nat_ZF_1_L3 by auto\n        from y(3) s(1) kaNat s(2) have \"s=ka\" using domain_of_fun succ_inject by auto\n        with u(1) have \"s=succ(u)\" by auto moreover\n        have \"Init(y):s\\<rightarrow>2\" using init_props(1)[OF s(2,1)].\n        ultimately have yu:\"Init(y):succ(u)\\<rightarrow>2\" by auto\n        with u have \"Init(y)\\<in>NELists(2)\" \"domain(Init(y)) = ka\"\n          using domain_of_fun unfolding NELists_def by auto\n        moreover from yu have \"Init(y)`0 = 0\" using init_props(2)[OF nat_succI[OF u(2)], of y 2]\n          s(1) `s=succ(u)` empty_in_every_succ[OF u(2)] y(2) by auto\n        moreover note k ultimately have \"\\<langle>\\<langle>Init(y),starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" \n          \"\\<langle>\\<langle>Init(y),starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" by auto\n        then have A:\"\\<forall>x\\<in>{starts0, starts1}. \\<langle>\\<langle>Init(y),x\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" by auto\n        have Q:\"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),transFun`\\<langle>starts0,Last(y)\\<rangle>\\<rangle>\\<rangle>\\<in>r{0.*1}\" using y(2)\n          unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] using y(1) by auto\n        {\n          assume as:\"Last(y) = 0\"\n          with Q t00 have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),starts0\\<rangle>\\<rangle>\\<in>r{0.*1}\" by auto\n        } moreover\n        {\n          assume as:\"Last(y) = 1\"\n          with Q t10 have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),starts1\\<rangle>\\<rangle>\\<in>r{0.*1}\" by auto\n        }\n        moreover note last_2 ultimately have\n        \"(\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),starts0\\<rangle>\\<rangle>\\<in>r{0.*1}) \\<or> (\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>Init(y),starts1\\<rangle>\\<rangle>\\<in>r{0.*1})\" by auto\n        with A have B:\"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using rtrancl_into_trancl2 trancl_into_rtrancl by auto\n        have Q:\"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>Init(y),transFun`\\<langle>starts1,Last(y)\\<rangle>\\<rangle>\\<rangle>\\<in>r{0.*1}\" using y(2)\n          unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] using y(1) by auto\n        {\n          assume as:\"Last(y) = 0\"\n          with Q t01 have \"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>Init(y),starts0\\<rangle>\\<rangle>\\<in>r{0.*1}\" by auto\n        } moreover\n        {\n          assume as:\"Last(y) = 1\"\n          with Q t11 have \"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>Init(y),starts1\\<rangle>\\<rangle>\\<in>r{0.*1}\" by auto\n        }\n        moreover note last_2 ultimately have\n        \"(\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>Init(y),starts0\\<rangle>\\<rangle>\\<in>r{0.*1}) \\<or> (\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>Init(y),starts1\\<rangle>\\<rangle>\\<in>r{0.*1})\" by auto\n        with A have \"\\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using rtrancl_into_trancl2 trancl_into_rtrancl by auto\n        with B have rr:\"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^* \\<and> \\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" by auto\n      }\n      ultimately have \"\\<langle>\\<langle>y,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^* \\<and> \\<langle>\\<langle>y,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" by auto\n    }\n    then have \"\\<forall>w. w \\<in> NELists(2) \\<and> w`0 = 0 \\<and> domain(w) = succ(ka) \\<longrightarrow> (\\<langle>\\<langle>w,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^* \\<and> \\<langle>\\<langle>w,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*)\" by auto\n  }\n  then have rule:\"\\<forall>k\\<in>nat.\n       (\\<forall>w. w \\<in> NELists(2) \\<and> w`0 = 0 \\<and> domain(w) = k \\<longrightarrow>\n            \\<langle>\\<langle>w, starts0\\<rangle>, 0, starts0\\<rangle> \\<in> r{0.*1}^* \\<and> \\<langle>\\<langle>w, starts1\\<rangle>, 0, starts0\\<rangle> \\<in> r{0.*1}^*) \\<longrightarrow>\n       (\\<forall>w. w \\<in> NELists(2) \\<and> w`0 = 0 \\<and> domain(w) = succ(k) \\<longrightarrow>\n            \\<langle>\\<langle>w, starts0\\<rangle>, 0, starts0\\<rangle> \\<in> r{0.*1}^* \\<and> \\<langle>\\<langle>w, starts1\\<rangle>, 0, starts0\\<rangle> \\<in> r{0.*1}^*)\" by blast \n  from ind_on_nat[of \"domain(w)\" \"\\<lambda>t . \\<forall>w. w\\<in>NELists(2) \\<and> w`0 =0 \\<and> domain(w) = t \\<longrightarrow> (\\<langle>\\<langle>w,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^* \\<and> \\<langle>\\<langle>w,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*)\", OF dom base rule]\n  show R:\"\\<langle>\\<langle>w,starts0\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" \"\\<langle>\\<langle>w,starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using assms(2,1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 291
    },
    "269": {
        "type": "theorem",
        "text": "text\\<open>Any list starting with $0$ and ending in $1$\nreduces.\\<close>\n",
        "assumes": "assumes \"i\\<in>Lists(2)\" and \"i`0=0\" and \"Last(i) = 1\"\n  ",
        "using": [
            "domain_of_fun",
            "t",
            "Nat_ZF_1_L3",
            "nat_into_Finite[of",
            "2]",
            "iList",
            "DFSAExecutionRelation_def[OF",
            "finA",
            "dfsaFrom0To1.DFSA]",
            "apply_equality[OF",
            "_",
            "funT]",
            "assms(3)",
            "fun_is_set_of_pairs[of",
            "i",
            "1",
            "pred_succ_eq",
            "assms(2)",
            "y(2)",
            "init_props(1)",
            "nat_succI[OF",
            "yy(2)]",
            "yy(2)",
            "empty_in_every_succ",
            "init_props(2)[of",
            "\"succ(k)\"",
            "invariant_state_0_1",
            "rtrancl_into_trancl2[THEN",
            "trancl_into_rtrancl]",
            "DFSASatisfy_def[OF",
            "dfsaFrom0To1.DFSA",
            "assms(1)]"
        ],
        "statement": "theorem starts1ends0_DFSA_reduce:\n  fixes i\n  assumes \"i\\<in>Lists(2)\" and \"i`0=0\" and \"Last(i) = 1\"\n  shows \"i{reduces in 0.*1}\"\n",
        "proof": "proof-\n  from assms(1) obtain tt where t:\"tt\\<in>nat\" \"i:tt\\<rightarrow>2\" unfolding Lists_def by auto\n  then have domNat:\"domain(i) = tt\" using domain_of_fun by auto\n  {\n    assume \"domain(i) = 0\" moreover\n    from assms(3) have \"\\<Union>(i``{Arith.pred(domain(i))})=1\" unfolding Last_def apply_def by auto\n    then have \"i\\<noteq>0\" by auto\n    ultimately have False using t domain_of_fun by auto\n  }\n  with domNat t(1) obtain y where y:\"domain(i) = succ(y)\" \"y\\<in>nat\" using Nat_ZF_1_L3 by auto\n  with domNat t(2) have iList:\"i\\<in>NELists(2)\" unfolding NELists_def by auto\n  have finA:\"Finite(2)\" using nat_into_Finite[of 2] by auto  \n  have funT:\"transFun:states\\<times>2\\<rightarrow>states\" unfolding Pi_def function_def by auto\n  have \"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>Init(i),transFun`\\<langle>empty,Last(i)\\<rangle>\\<rangle>\\<rangle>:r{0.*1}\" using iList unfolding\n      DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] by auto\n  moreover have \"transFun`\\<langle>empty,Last(i)\\<rangle> = 1\" using apply_equality[OF _ funT] assms(3)\n    by auto\n  ultimately have U:\"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>Init(i),starts1\\<rangle>\\<rangle>:r{0.*1}\" by auto\n  {\n    assume \"y = 0\"\n    with y(1) t(2) have iFun:\"i:1\\<rightarrow>2\" using domain_of_fun by auto\n    then have \"i = {\\<langle>0,i`0\\<rangle>}\" using fun_is_set_of_pairs[of i 1 2] by auto\n    with assms(2) have ii:\"i={\\<langle>0,0\\<rangle>}\" by auto\n    then have \"\\<forall>y. \\<exists>x\\<in>{Arith.pred(domain(i))}. \\<langle>x, y\\<rangle> \\<in> i \\<longrightarrow> y=0\" by auto\n    moreover from assms(3) have eq:\"1 = i`pred(domain(i))\" unfolding Last_def by auto\n    from iFun have \"domain(i) = 1\" using domain_of_fun by auto\n    then have \"pred(domain(i)) = 0\" using pred_succ_eq by auto\n    then have \"i`pred(domain(i)) = i`0\" by auto\n    with eq have \"1 = i`0\" by auto\n    then have False using assms(2) by auto\n  }\n  then have \"y\\<noteq>0\" by auto\n  then obtain k where yy:\"y= succ(k)\" \"k\\<in>nat\" using Nat_ZF_1_L3 y(2) by auto\n  with iList y(1) have iss:\"i:succ(succ(k)) \\<rightarrow> 2\" unfolding NELists_def using domain_of_fun by auto\n  then have \"Init(i):succ(k) \\<rightarrow> 2\" using init_props(1) nat_succI[OF yy(2)] by auto\n  then have \"Init(i)\\<in>NELists(2)\" unfolding NELists_def using yy(2) by auto moreover\n  have \"0\\<in>succ(k)\" using empty_in_every_succ yy(2) by auto\n  with iss assms(2) have \"Init(i)`0 = 0\" using init_props(2)[of \"succ(k)\" i 2] nat_succI[OF yy(2)]\n    by auto\n  ultimately have \"\\<langle>\\<langle>Init(i),starts1\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using invariant_state_0_1\n    by auto\n  with U have \"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle>\\<in>r{0.*1}^*\" using rtrancl_into_trancl2[THEN trancl_into_rtrancl] by auto\n  then have \"\\<exists>q\\<in>finalStates. \\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle> \\<in> r{0.*1}^*\" by auto\n  then show ?thesis using DFSASatisfy_def[OF finA dfsaFrom0To1.DFSA assms(1)] by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 292
    },
    "270": {
        "type": "theorem",
        "text": "text\\<open>Any list that reduces starts with 0 and ends in 1\\<close>\n",
        "assumes": "assumes \"i\\<in>Lists(2)\" and \"i {reduces in 0.*1}\"\n  ",
        "using": [
            "nat_into_Finite[of",
            "2]",
            "rtrancl_unfold[of",
            "\"r{0.*1}\"]",
            "domainI[of",
            "_",
            "DFSAExecutionRelation_def[OF",
            "finA",
            "dfsaFrom0To1.DFSA]",
            "id_iff",
            "dfsaFrom0To1.seq_is_restriction",
            "init_props(1)",
            "domain_of_fun",
            "empty_in_every_succ",
            "restrict",
            "apply_type[of",
            "q1",
            "1",
            "\"\\<lambda>_.",
            "2\"]",
            "empty_in_every_succ[OF",
            "nat_0I]",
            "apply_Pair[OF",
            "funT,",
            "of",
            "\"\\<langle>q2,Last(q1)\\<rangle>\"]",
            "q10",
            "rtrancl_rev",
            "rtrancl_type[of",
            "dfsaFrom0To1.reduce_field(1)",
            "apply_equality[OF",
            "funT]",
            "invariant_state_3",
            "last_type[of",
            "i"
        ],
        "statement": "theorem starts1ends0_DFSA_reduce_rev:\n  fixes i\n  assumes \"i\\<in>Lists(2)\" and \"i {reduces in 0.*1}\"\n  shows \"i`0=0\" and \"Last(i) = 1\"\n",
        "proof": "proof-\n  have finA:\"Finite(2)\" using nat_into_Finite[of 2] by auto  \n  have funT:\"transFun:states\\<times>2\\<rightarrow>states\" unfolding Pi_def function_def by auto\n  from assms(2) have \"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> r{0.*1}^*\" \n    unfolding DFSASatisfy_def[OF finA dfsaFrom0To1.DFSA assms(1)]\n    by auto\n  then have \"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> id(field(r{0.*1})) \\<union> (r{0.*1} O r{0.*1}^*)\" using rtrancl_unfold[of \"r{0.*1}\"] by auto\n  then have k:\"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> id(field(r{0.*1})) \\<or> \\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> (r{0.*1} O r{0.*1}^*)\" by auto\n  have d:\"domain(r{0.*1}) = NELists(2)\\<times>states\"\n    using domainI[of _ _ \"r{0.*1}\"]\n    unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA]\n    by auto\n  from k have \"\\<langle>i,empty\\<rangle> = \\<langle>0,starts0\\<rangle> \\<or> \\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> (r{0.*1} O r{0.*1}^*)\" using id_iff by auto\n  then have \"(i=0 \\<and> empty=starts0) \\<or> (\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> r{0.*1} O r{0.*1}^*)\" by auto\n  then have \"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> r{0.*1} O r{0.*1}^*\" by auto\n  then obtain q where q:\"\\<langle>q,\\<langle>0,starts0\\<rangle>\\<rangle> \\<in> r{0.*1}\" \"\\<langle>\\<langle>i,empty\\<rangle>,q\\<rangle>\\<in>r{0.*1}^*\" unfolding comp_def by auto\n  from q(1) have \"q \\<in> domain(r{0.*1})\" unfolding domain_def by auto\n  with d have \"q \\<in> NELists(2)\\<times>states\" by auto\n  then obtain q1 q2 where qq:\"q=\\<langle>q1,q2\\<rangle>\" \"q1\\<in>NELists(2)\" \"q2\\<in>states\" by auto\n  from q(1) qq(1) have A:\"0 = Init(q1)\" \"0 = transFun`\\<langle>q2,Last(q1)\\<rangle>\"\n    unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] by auto\n  from qq(1) q(2) have \"restrict(i,domain(q1)) = q1\" \n    using dfsaFrom0To1.seq_is_restriction\n    by auto\n  then have iRes:\"restrict(i,domain(q1))`0 = q1`0\" by auto\n  from qq(2) obtain k where k:\"q1:succ(k)\\<rightarrow>2\" \"k\\<in>nat\" unfolding NELists_def by auto\n  then have \"Init(q1):k\\<rightarrow>2\" using init_props(1) by auto\n  with A(1) have \"k=0\" unfolding Pi_def by auto\n  with k(1) have qfun:\"q1:1\\<rightarrow>2\" by auto\n  from qfun have q10:\"Last(q1) = q1`0\" unfolding Last_def using domain_of_fun by auto\n  from k have \"0\\<in>domain(q1)\" using domain_of_fun empty_in_every_succ by auto\n  with iRes have \"i`0 = q1`0\" using restrict by auto\n  from qfun have \"q1`0\\<in>2\" using apply_type[of q1 1 \"\\<lambda>_. 2\"] empty_in_every_succ[OF nat_0I] by auto\n  with qq(3) A(2) have \"\\<langle>\\<langle>q2,Last(q1)\\<rangle>,0\\<rangle> \\<in> transFun\" using apply_Pair[OF funT, of \"\\<langle>q2,Last(q1)\\<rangle>\"] q10 by auto\n  then have \"q2\\<in>2\" \"Last(q1) = 0\" by auto\n  with `0\\<in>domain(q1)` iRes q10 show \"i`0 = 0\" using restrict by auto\n  from q(2) qq(1) have \"\\<langle>\\<langle>i,empty\\<rangle>,\\<langle>q1,q2\\<rangle>\\<rangle> \\<in> r{0.*1}^*\" by auto\n  then have \"\\<langle>\\<langle>i,2\\<rangle>,\\<langle>q1,q2\\<rangle>\\<rangle> \\<in> id(field(r{0.*1})) \\<union> (r{0.*1}^* O r{0.*1})\" using rtrancl_rev by auto\n  moreover\n  {\n    assume \"\\<langle>\\<langle>i,2\\<rangle>,\\<langle>q1,q2\\<rangle>\\<rangle> \\<in> id(field(r{0.*1}))\"\n    then have \"i=q1 \\<and> q2=2\" by auto\n    with `q2\\<in>2` have False by auto\n  } ultimately\n  have \"\\<langle>\\<langle>i,2\\<rangle>,\\<langle>q1,q2\\<rangle>\\<rangle> \\<in> (r{0.*1}^* O r{0.*1})\" by auto\n  then obtain z where z:\"\\<langle>\\<langle>i,2\\<rangle>,z\\<rangle> :r{0.*1}\" \"\\<langle>z,\\<langle>q1,q2\\<rangle>\\<rangle>:r{0.*1}^*\" unfolding comp_def by auto\n  from z(2) have \"z\\<in>field(r{0.*1})\" using rtrancl_type[of \"r{0.*1}\"] by auto\n  then obtain z1 z2 where zz:\"z=\\<langle>z1,z2\\<rangle>\" \"z1\\<in>Lists(2)\" \"z2\\<in>states\" using dfsaFrom0To1.reduce_field(1)\n    by blast\n  from zz(1) z(1) have zzz:\"z1=Init(i)\" \"z2=transFun`\\<langle>2,Last(i)\\<rangle>\" \n    unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA] by auto\n  {\n    assume \"Last(i) = 0\"\n    with zzz(2) have \"z2 = succ(2)\" using apply_equality[OF _ funT] by auto\n    with zz(1) z(2) have \"q2= succ(2)\" using invariant_state_3 by auto\n    with `q2\\<in>2` have False by auto\n  }\n  with z(1) show \"Last(i) = 1\" using last_type[of i 2] \n    unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA]\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 293
    },
    "271": {
        "type": "theorem",
        "text": "text\\<open>We conclude that this example constitutes\nthe language of binary strings starting in $0$\nand ending in $1$\\<close>\n",
        "assumes": "",
        "using": [
            "starts1ends0_DFSA_reduce_rev",
            "starts1ends0_DFSA_reduce"
        ],
        "statement": "theorem determine_strings:\n  shows \"dfsaFrom0To1.LanguageDFSA = {i\\<in>Lists(2). i`0 = 0 \\<and> Last(i) = 1}\"\n  ",
        "proof": "using starts1ends0_DFSA_reduce_rev\n  starts1ends0_DFSA_reduce by blast\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 294
    },
    "272": {
        "type": "definition",
        "text": "text\\<open>We define the languages determined by a deterministic\nfinite state automaton as \\textbf{regular}.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsRegularLanguage (\"_{is a regular language on}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> L{is a regular language on}\\<Sigma> \\<equiv> \\<exists>S s t F. ((S,s,t,F){is an DFSA for alphabet}\\<Sigma>) \\<and> L=DetFinStateAuto.LanguageDFSA(S,s,t,F,\\<Sigma>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 295
    },
    "273": {
        "type": "corollary",
        "text": "text\\<open>By definition, the language in the locale\nis regular.\\<close>\n",
        "assumes": "",
        "using": [
            "IsRegularLanguage_def",
            "finite_alphabet",
            "DFSA"
        ],
        "statement": "corollary (in DetFinStateAuto) regular_intersect:\n  shows \"LanguageDFSA{is a regular language on}\\<Sigma>\"\n  ",
        "proof": "using IsRegularLanguage_def finite_alphabet DFSA by auto\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 296
    },
    "274": {
        "type": "lemma",
        "text": "text\\<open>A regular language is a language.\\<close>\n",
        "assumes": "assumes \"Finite(\\<Sigma>)\"\n  and \"L{is a regular language on}\\<Sigma>\"\n  ",
        "using": [
            "assms(1)"
        ],
        "statement": "lemma regular_is_language:\n  assumes \"Finite(\\<Sigma>)\"\n  and \"L{is a regular language on}\\<Sigma>\"\n  shows \"L{is a language with alphabet}\\<Sigma>\" unfolding IsALanguage_def[OF assms(1)]\n",
        "proof": "proof-\n  from assms(2) obtain S s t F where \"(S,s,t,F){is an DFSA for alphabet}\\<Sigma>\" \"L=DetFinStateAuto.LanguageDFSA(S,s,t,F,\\<Sigma>)\"\n    unfolding IsRegularLanguage_def[OF assms(1)] by auto\n  then show \"L\\<subseteq> Lists(\\<Sigma>)\"\n    unfolding DetFinStateAuto_def using assms(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 297
    },
    "275": {
        "type": "theorem",
        "text": "text\\<open>The intersection of two regular languages\nis a regular language.\\<close>\n",
        "assumes": "assumes \"Finite(\\<Sigma>)\"\n  and \"L1{is a regular language on}\\<Sigma>\"\n  and \"L2{is a regular language on}\\<Sigma>\"\n",
        "using": [
            "IsRegularLanguage_def",
            "DetFinStateAuto_def",
            "assms(1)",
            "l1(1)",
            "l2(1)",
            "DFSA_def[OF",
            "assms(1)]",
            "apply_type",
            "Finite1_L12[of",
            "S1",
            "S2]",
            "Fin_into_Finite",
            "Finite_into_Fin",
            "DetFinStateAuto.reduce_field(2)[of",
            "s1",
            "t1",
            "F1",
            "\\<Sigma>]",
            "S2",
            "s2",
            "t2",
            "F2",
            "rtrancl_refl",
            "fieldI1[of",
            "bb",
            "cc",
            "?r]",
            "fieldI2[of",
            "DetFinStateAuto.reduce_field(1)[OF",
            "DFSA0]",
            "last_type[of",
            "bbL",
            "apply_equality[of",
            "\"\\<langle>\\<langle>bb1,bb2\\<rangle>,Last(bbL)\\<rangle>\"",
            "_",
            "?t]",
            "D",
            "rtrancl_into_trancl1[of",
            "?r2,",
            "THEN",
            "trancl_into_rtrancl]",
            "?r1,",
            "bbcc(2)",
            "m0",
            "DFSASatisfy_def[OF",
            "M(1)]",
            "rtrancl_induct[of",
            "\"\\<langle>0,?s\\<rangle>\"",
            "\"\\<langle>0,yy,zz\\<rangle>\"",
            "?r",
            "\"\\<lambda>q.",
            "q=\\<langle>0,?s\\<rangle>\"]",
            "non_zero_List_func_is_NEList",
            "RR",
            "l1(2)",
            "l2(2)",
            "\"\\<langle>m,s1\\<rangle>\"",
            "\"\\<langle>0,f1\\<rangle>\"",
            "?r1",
            "q=\\<langle>0,s1\\<rangle>\"]",
            "\"\\<langle>m,s2\\<rangle>\"",
            "\"\\<langle>0,f2\\<rangle>\"",
            "?r2",
            "q=\\<langle>0,s2\\<rangle>\"]",
            "rtrancl_type",
            "DetFinStateAuto.reduce_field(1)[of",
            "DetFinStateAuto.reduce_field(2)[OF",
            "\"\\<langle>\\<langle>y1,ff2\\<rangle>,Last(yL)\\<rangle>\"",
            "?t",
            "\"?S\\<times>\\<Sigma>\"",
            "\"\\<lambda>_.",
            "?S\"]",
            "last_type",
            "rtrancl_into_rtrancl",
            "apply_type[of",
            "\"S2\\<times>\\<Sigma>\"",
            "S2\"]",
            "last_type[OF",
            "y(3)]",
            "sf(1)",
            "\\<exists>f2\\<in>S2.",
            "\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(q),snd(q),f2\\<rangle>\\<rangle>:?r^*\"]",
            "\"\\<langle>\\<langle>ff2,y1\\<rangle>,Last(yL)\\<rangle>\"",
            "\"S1\\<times>\\<Sigma>\"",
            "S1\"]",
            "\\<exists>f1\\<in>S1.",
            "\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(q),f1,snd(q)\\<rangle>\\<rangle>:?r^*\"]",
            "DetFinStateAuto.relation_deteministic[OF",
            "DFSA0,",
            "of",
            "m",
            "?s",
            "0",
            "]",
            "exI[of",
            "\"\\<lambda>h.",
            "((?S,?s,?t,h){is",
            "an",
            "DFSA",
            "for",
            "alphabet}\\<Sigma>)",
            "\\<and>",
            "L1\\<inter>L2",
            "=",
            "DetFinStateAuto.LanguageDFSA(?S,?s,?t,h,\\<Sigma>)\"",
            "?F]",
            "\"\\<lambda>m.",
            "\\<exists>h.",
            "((?S,?s,m,h){is",
            "DetFinStateAuto.LanguageDFSA(?S,?s,m,h,\\<Sigma>)\"",
            "\"\\<lambda>n.",
            "\\<exists>m",
            "h.",
            "((?S,n,m,h){is",
            "DetFinStateAuto.LanguageDFSA(?S,n,m,h,\\<Sigma>)\"",
            "?s]",
            "\"\\<lambda>p.",
            "\\<exists>n",
            "((p,n,m,h){is",
            "DetFinStateAuto.LanguageDFSA(p,n,m,h,\\<Sigma>)\"",
            "?S]"
        ],
        "statement": "theorem regular_intersect:\n  assumes \"Finite(\\<Sigma>)\"\n  and \"L1{is a regular language on}\\<Sigma>\"\n  and \"L2{is a regular language on}\\<Sigma>\"\nshows \"(L1\\<inter>L2) {is a regular language on}\\<Sigma>\"\n",
        "proof": "proof-\n  from assms(1,2) obtain S1 s1 t1 F1 where l1:\"(S1,s1,t1,F1){is an DFSA for alphabet}\\<Sigma>\" \n    \"L1 = DetFinStateAuto.LanguageDFSA(S1,s1,t1,F1,\\<Sigma>)\"\n    using IsRegularLanguage_def by auto\n  then have l1:\"(S1,s1,t1,F1){is an DFSA for alphabet}\\<Sigma>\" \n    \"L1 = {i\\<in>Lists(\\<Sigma>). i <-D (S1,s1,t1,F1){in alphabet}\\<Sigma>}\"\n    using DetFinStateAuto_def assms(1) l1(1) by auto\n  from assms(1,3) obtain S2 s2 t2 F2 where l2:\"(S2,s2,t2,F2){is an DFSA for alphabet}\\<Sigma>\" \n    \"L2= DetFinStateAuto.LanguageDFSA(S2,s2,t2,F2,\\<Sigma>)\"\n    using IsRegularLanguage_def by auto\n  then have l2:\"(S2,s2,t2,F2){is an DFSA for alphabet}\\<Sigma>\" \n    \"L2 = {i\\<in>Lists(\\<Sigma>). i <-D (S2,s2,t2,F2){in alphabet}\\<Sigma>}\"\n    using DetFinStateAuto_def assms(1) l2(1) by auto\n  let ?S = \"S1\\<times>S2\"\n  let ?s = \"\\<langle>s1,s2\\<rangle>\"\n  let ?t = \"{\\<langle>\\<langle>\\<langle>x1,x2\\<rangle>,y\\<rangle>,\\<langle>t1`\\<langle>x1,y\\<rangle>,t2`\\<langle>x2,y\\<rangle>\\<rangle>\\<rangle>. \\<langle>\\<langle>x1,x2\\<rangle>,y\\<rangle> \\<in> ?S\\<times>\\<Sigma>}\"\n  let ?F = \"F1\\<times>F2\"\n  let ?r = \"DetFinStateAuto.r\\<^sub>D(?S,?s,?t,\\<Sigma>)\"\n  let ?r1 = \"DetFinStateAuto.r\\<^sub>D(S1,s1,t1,\\<Sigma>)\"\n  let ?r2 = \"DetFinStateAuto.r\\<^sub>D(S2,s2,t2,\\<Sigma>)\"\n  have D:\"(?S,?s,?t,?F){is an DFSA for alphabet}\\<Sigma>\"\n  proof-\n    have A:\"?s\\<in>?S\" using l1(1) l2(1) unfolding DFSA_def[OF assms(1)] by auto\n    have B:\"?F \\<subseteq> ?S\" using l1(1) l2(1) unfolding DFSA_def[OF assms(1)] by auto\n    have \"function(?t)\" unfolding function_def by auto\n    moreover have \"?S\\<times>\\<Sigma> \\<subseteq> domain(?t)\" by auto\n    moreover\n    {\n      fix x1 x2 y assume as:\"\\<langle>\\<langle>x1,x2\\<rangle>,y\\<rangle> \\<in> ?S \\<times> \\<Sigma>\"\n      then have \"t1`\\<langle>x1,y\\<rangle>\\<in>S1\" \"t2`\\<langle>x2,y\\<rangle>\\<in>S2\" using apply_type\n        l1(1) l2(1) unfolding DFSA_def[OF assms(1)] by auto\n      then have \"\\<langle>t1`\\<langle>x1,y\\<rangle>,t2`\\<langle>x2,y\\<rangle>\\<rangle>\\<in>?S\" by auto\n    }\n    then have \"{\\<langle>\\<langle>\\<langle>x1,x2\\<rangle>,y\\<rangle>,\\<langle>t1`\\<langle>x1,y\\<rangle>,t2`\\<langle>x2,y\\<rangle>\\<rangle>\\<rangle>. \\<langle>\\<langle>x1,x2\\<rangle>,y\\<rangle> \\<in> (S1 \\<times> S2) \\<times> \\<Sigma>} \\<in> Pow((?S\\<times>\\<Sigma>)\\<times>?S)\" by auto\n    ultimately have C:\"?t:?S\\<times>\\<Sigma> \\<rightarrow> ?S\" unfolding Pi_def by auto\n    have \"Finite(?S)\" using Finite1_L12[of S1 S2] Fin_into_Finite Finite_into_Fin\n      l1(1) l2(1) unfolding DFSA_def[OF assms(1)] by auto\n    with A B C show ?thesis unfolding DFSA_def[OF assms(1)] by auto\n  qed\n  then have DFSA0:\"DetFinStateAuto(?S,?s,?t,?F,\\<Sigma>)\" unfolding DetFinStateAuto_def using assms(1) by auto\n  have RR:\"\\<And>m yy zz. m\\<in>NELists(\\<Sigma>) \\<Longrightarrow> \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,yy,zz\\<rangle>\\<rangle>:?r^* \\<Longrightarrow> \\<langle>\\<langle>m,s1\\<rangle>,\\<langle>0,yy\\<rangle>\\<rangle>:?r1^* \\<and> \\<langle>\\<langle>m,s2\\<rangle>,\\<langle>0,zz\\<rangle>\\<rangle>:?r2^*\"\n    proof\n      fix m yy zz\n      assume as:\"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,yy,zz\\<rangle>\\<rangle>:?r^*\" \"m\\<in>NELists(\\<Sigma>)\"\n      note as(2)\n      moreover have \"s1\\<in>S1\" \"s2\\<in>S2\" using l1(1) l2(1) unfolding DFSA_def[OF assms(1)] by auto\n      ultimately have \"\\<langle>m,s1\\<rangle> : field(?r1)\" \"\\<langle>m,s2\\<rangle> : field(?r2)\" using DetFinStateAuto.reduce_field(2)[of S1 s1 t1 F1 \\<Sigma>] assms(1) l1(1) l2(1)\n        DetFinStateAuto.reduce_field(2)[of S2 s2 t2 F2 \\<Sigma>] unfolding DetFinStateAuto_def by auto\n      then have \"\\<langle>\\<langle>m,s1\\<rangle>,\\<langle>m,s1\\<rangle>\\<rangle>:?r1^*\" \"\\<langle>\\<langle>m,s2\\<rangle>,\\<langle>m,s2\\<rangle>\\<rangle>:?r2^*\" using rtrancl_refl by auto moreover\n      {\n        fix bb cc assume as:\"\\<langle>\\<langle>m,s1,s2\\<rangle>,bb\\<rangle>:?r^*\" \"\\<langle>bb,cc\\<rangle>:?r\" \"\\<langle>\\<langle>m,s1\\<rangle>,fst(bb),fst(snd(bb))\\<rangle>:?r1^* \\<and> \\<langle>\\<langle>m,s2\\<rangle>,fst(bb),snd(snd(bb))\\<rangle>:?r2^*\"\n        from this(2) have \"bb\\<in>field(?r)\" \"cc\\<in>field(?r)\" using\n            fieldI1[of bb cc ?r] fieldI2[of bb cc ?r] by auto\n        then obtain bbL bb1 bb2 ccL cc1 cc2 where bbcc:\"bb=\\<langle>bbL,bb1,bb2\\<rangle>\" \"cc=\\<langle>ccL,cc1,cc2\\<rangle>\"\n          \"bbL\\<in>Lists(\\<Sigma>)\" \"ccL\\<in>Lists(\\<Sigma>)\" \"cc1\\<in>S1\" \"cc2\\<in>S2\" \"bb1\\<in>S1\" \"bb2\\<in>S2\"\n          using DetFinStateAuto.reduce_field(1)[OF DFSA0] by blast\n        with as(3) have \"\\<langle>\\<langle>m,s1\\<rangle>,bbL,bb1\\<rangle>:?r1^*\" by auto\n        from as(2) bbcc have C:\"ccL=Init(bbL)\" \"\\<langle>cc1,cc2\\<rangle>=?t`\\<langle>\\<langle>bb1,bb2\\<rangle>,Last(bbL)\\<rangle>\" \"bbL:NELists(\\<Sigma>)\"\n          unfolding DFSAExecutionRelation_def[OF assms(1) D] by auto\n        from this(2,3) bbcc(8,7) have \"\\<langle>cc1,cc2\\<rangle>=\\<langle>t1`\\<langle>bb1,Last(bbL)\\<rangle>,t2`\\<langle>bb2,Last(bbL)\\<rangle>\\<rangle>\" using last_type[of bbL \\<Sigma>]\n          apply_equality[of \"\\<langle>\\<langle>bb1,bb2\\<rangle>,Last(bbL)\\<rangle>\" _ ?t] D\n          unfolding DFSA_def[OF assms(1)] by auto\n        then have \"cc1=t1`\\<langle>bb1,Last(bbL)\\<rangle>\" \"cc2=t2`\\<langle>bb2,Last(bbL)\\<rangle>\" by auto\n        with C(1,3) bbcc(8,7) have \"\\<langle>\\<langle>bbL,bb1\\<rangle>,\\<langle>ccL,cc1\\<rangle>\\<rangle>:?r1\" \"\\<langle>\\<langle>bbL,bb2\\<rangle>,\\<langle>ccL,cc2\\<rangle>\\<rangle>:?r2\"\n          unfolding DFSAExecutionRelation_def[OF assms(1) l1(1)]\n              DFSAExecutionRelation_def[OF assms(1) l2(1)] by auto\n        with as(3) bbcc(1,2) have \"\\<langle>\\<langle>m,s1\\<rangle>,\\<langle>ccL,cc1\\<rangle>\\<rangle>\\<in>?r1^*\" \"\\<langle>\\<langle>m,s2\\<rangle>,\\<langle>ccL,cc2\\<rangle>\\<rangle>\\<in>?r2^*\"\n          using rtrancl_into_trancl1[of _ _ ?r2, THEN trancl_into_rtrancl]\n          rtrancl_into_trancl1[of _ _ ?r1, THEN trancl_into_rtrancl]\n          by auto\n        then have \"\\<langle>\\<langle>m,s1\\<rangle>,\\<langle>fst(cc),fst(snd(cc))\\<rangle>\\<rangle>:?r1^* \\<and> \\<langle>\\<langle>m,s2\\<rangle>,\\<langle>fst(cc),snd(snd(cc))\\<rangle>\\<rangle>:?r2^*\"\n          using bbcc(2) by auto\n      } moreover note as\n      rtrancl_induct[of \"\\<langle>m,s1,s2\\<rangle>\" \"\\<langle>0,yy,zz\\<rangle>\" \"?r\" \"\\<lambda>b. \\<langle>\\<langle>m,s1\\<rangle>,\\<langle>fst(b),fst(snd(b))\\<rangle>\\<rangle>:?r1^* \\<and> \\<langle>\\<langle>m,s2\\<rangle>,\\<langle>fst(b),snd(snd(b))\\<rangle>\\<rangle>:?r2^*\"]\n      ultimately show \"\\<langle>\\<langle>m, s1\\<rangle>, 0, yy\\<rangle> \\<in> ?r1^*\" \"\\<langle>\\<langle>m, s2\\<rangle>, 0, zz\\<rangle> \\<in> ?r2^*\" by auto\n    qed\n  {\n    fix m assume \"m\\<in>{i\\<in>Lists(\\<Sigma>). i <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>}\"\n    then have M:\"m\\<in>Lists(\\<Sigma>)\" \"m <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>\" by auto\n    {\n      assume m0:\"m=0\"\n      from m0 M have \"0 <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>\" by auto\n      then obtain yy zz where \"\\<langle>\\<langle>0,s1,s2\\<rangle>,\\<langle>0,yy,zz\\<rangle>\\<rangle>:?r^* \\<or> ?s:?F\" \"\\<langle>yy,zz\\<rangle>:?F\" using m0\n        DFSASatisfy_def[OF assms(1) D M(1)] by auto moreover\n      {\n        fix y z\n        assume \"\\<langle>\\<langle>0,s1,s2\\<rangle>,y\\<rangle> \\<in> ?r^*\" \"\\<langle>y,z\\<rangle> \\<in> ?r\" \"y = \\<langle>0,s1,s2\\<rangle>\"\n        from this(2,3) have \"0\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF assms(1) D]\n          by auto\n        then have False unfolding NELists_def Pi_def by auto\n        then have \"z=\\<langle>0,s1,s2\\<rangle>\" by auto\n      }\n      ultimately have \"?s:?F\" using rtrancl_induct[of \"\\<langle>0,?s\\<rangle>\" \"\\<langle>0,yy,zz\\<rangle>\" ?r\n        \"\\<lambda>q. q=\\<langle>0,?s\\<rangle>\"] by auto\n      then have \"m <-D (S1,s1,t1,F1){in alphabet}\\<Sigma>\" \"m <-D (S2,s2,t2,F2){in alphabet}\\<Sigma>\"\n        using DFSASatisfy_def[OF assms(1) l1(1) M(1)] DFSASatisfy_def[OF assms(1) l2(1) M(1)]\n        using m0 by auto\n    } moreover\n    {\n      assume m0:\"m\\<noteq>0\"\n      with M(2) obtain yy zz where F:\"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,yy,zz\\<rangle>\\<rangle>:?r^*\" \"\\<langle>yy,zz\\<rangle>:?F\" using\n        DFSASatisfy_def[OF assms(1) D M(1)] by auto\n      from m0 M(1) have \"m\\<in>NELists(\\<Sigma>)\" using non_zero_List_func_is_NEList by auto\n      then have RR:\"\\<And>yy zz. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,yy,zz\\<rangle>\\<rangle>:?r^* \\<Longrightarrow> \\<langle>\\<langle>m,s1\\<rangle>,\\<langle>0,yy\\<rangle>\\<rangle>:?r1^* \\<and> \\<langle>\\<langle>m,s2\\<rangle>,\\<langle>0,zz\\<rangle>\\<rangle>:?r2^*\"\n        using RR by auto\n      with F have \"\\<exists>q\\<in>F1.  \\<langle>\\<langle>m, s1\\<rangle>, 0,q\\<rangle>\\<in>?r1^*\" \"\\<exists>q\\<in>F2.  \\<langle>\\<langle>m, s2\\<rangle>, 0,q\\<rangle>\\<in>?r2^*\" by auto\n      then have \"m <-D (S1,s1,t1,F1){in alphabet}\\<Sigma>\" \"m <-D (S2,s2,t2,F2){in alphabet}\\<Sigma>\"\n        using DFSASatisfy_def[OF assms(1) l1(1) M(1)] DFSASatisfy_def[OF assms(1) l2(1) M(1)]\n        using m0 by auto\n    }\n    ultimately have \"m <-D (S1,s1,t1,F1){in alphabet}\\<Sigma>\" \"m <-D (S2,s2,t2,F2){in alphabet}\\<Sigma>\" by auto\n  }\n  then have S1:\"{i \\<in> Lists(\\<Sigma>). i <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>} \\<subseteq> L1\\<inter>L2\" using l1(2) l2(2) by auto\n  {\n    fix m assume \"m\\<in>L1\\<inter>L2\"\n    with l1(2) l2(2) have M:\"m\\<in>Lists(\\<Sigma>)\" \"m <-D (S1,s1,t1,F1){in alphabet}\\<Sigma>\" \"m <-D (S2,s2,t2,F2){in alphabet}\\<Sigma>\"\n      by auto\n    then obtain f1 f2 where ff:\"f1\\<in>F1\" \"f2\\<in>F2\" \"\\<langle>\\<langle>m,s1\\<rangle>,0,f1\\<rangle>\\<in>?r1^* \\<or> (m=0 \\<and> s1\\<in>F1)\" \"\\<langle>\\<langle>m,s2\\<rangle>,0,f2\\<rangle>\\<in>?r2^* \\<or> (m=0 \\<and> s2\\<in>F2)\"\n      unfolding DFSASatisfy_def[OF assms(1) l1(1) M(1)] DFSASatisfy_def[OF assms(1) l2(1) M(1)] by auto\n    {\n      fix y z\n      assume \"\\<langle>\\<langle>0,s1\\<rangle>,y\\<rangle> \\<in> ?r1^*\" \"\\<langle>y,z\\<rangle> \\<in> ?r1\" \"y = \\<langle>0,s1\\<rangle>\"\n      from this(2,3) have \"0\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF assms(1) l1(1)]\n        by auto\n      then have False unfolding NELists_def Pi_def by auto\n      then have \"z=\\<langle>0,s1\\<rangle>\" by auto\n    }\n    with ff(1,3) have \"m=0 \\<longrightarrow> s1\\<in>F1\" using rtrancl_induct[of \"\\<langle>m,s1\\<rangle>\" \"\\<langle>0,f1\\<rangle>\" ?r1 \"\\<lambda>q. q=\\<langle>0,s1\\<rangle>\"] by auto\n    moreover\n    {\n      fix y z\n      assume \"\\<langle>\\<langle>0,s2\\<rangle>,y\\<rangle> \\<in> ?r2^*\" \"\\<langle>y,z\\<rangle> \\<in> ?r2\" \"y = \\<langle>0,s2\\<rangle>\"\n      from this(2,3) have \"0\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF assms(1) l2(1)]\n        by auto\n      then have False unfolding NELists_def Pi_def by auto\n      then have \"z=\\<langle>0,s2\\<rangle>\" by auto\n    }\n    with ff(2,4) have \"m=0 \\<longrightarrow> s2\\<in>F2\" using rtrancl_induct[of \"\\<langle>m,s2\\<rangle>\" \"\\<langle>0,f2\\<rangle>\" ?r2 \"\\<lambda>q. q=\\<langle>0,s2\\<rangle>\"] by auto\n    moreover\n    {\n      assume m0:\"m\\<noteq>0\"\n      with ff(3,4) have A:\"\\<langle>\\<langle>m,s1\\<rangle>,0,f1\\<rangle>:?r1^*\" \"\\<langle>\\<langle>m,s2\\<rangle>,0,f2\\<rangle>:?r2^*\" by auto\n      from this(1) have \"\\<langle>m,s1\\<rangle>:field(?r1)\" using rtrancl_type by auto\n      then have \"\\<langle>m,s1\\<rangle>:Lists(\\<Sigma>)\\<times>S1\" using DetFinStateAuto.reduce_field(1)[of S1 s1 t1 F1 \\<Sigma>] l1(1) unfolding DetFinStateAuto_def\n        using assms(1) by auto\n      with m0 have \"m\\<in>NELists(\\<Sigma>)\" \"s1\\<in>S1\" \"s2\\<in>S2\" using l1(1) l2(1) non_zero_List_func_is_NEList\n        unfolding DFSA_def[OF assms(1)] by auto\n      then have \"\\<langle>m,s1,s2\\<rangle>:NELists(\\<Sigma>)\\<times>?S\" by auto\n      then have \"\\<langle>m,s1,s2\\<rangle>:field(?r)\" using DetFinStateAuto.reduce_field(2)[OF DFSA0] by auto\n      then have K:\"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>m,s1,s2\\<rangle>\\<rangle>:?r^*\" using rtrancl_refl by auto\n      with `s2\\<in>S2` have \"\\<exists>f2\\<in>S2. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>m,s1,f2\\<rangle>\\<rangle>:?r^*\" by auto moreover\n      {\n        fix y z\n        assume as:\"\\<langle>\\<langle>m,s1\\<rangle>,y\\<rangle>:?r1^*\" \"\\<langle>y,z\\<rangle>:?r1\" \"\\<exists>f2\\<in>S2. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(y),snd(y),f2\\<rangle>\\<rangle>:?r^*\"\n        from as(2) obtain yL y1 where y:\"y=\\<langle>yL,y1\\<rangle>\" \"z=\\<langle>Init(yL),t1`\\<langle>y1,Last(yL)\\<rangle>\\<rangle>\"\n          \"yL\\<in>NELists(\\<Sigma>)\" \"y1:S1\" unfolding DFSAExecutionRelation_def[OF assms(1) l1(1)] by auto\n        with as(3) obtain ff2 where sf:\"ff2\\<in>S2\" \"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>yL,y1,ff2\\<rangle>\\<rangle>:?r^*\" by auto\n        from this(1) y(3,4) have \"\\<langle>\\<langle>yL,y1,ff2\\<rangle>,\\<langle>Init(yL),?t`\\<langle>\\<langle>y1,ff2\\<rangle>,Last(yL)\\<rangle>\\<rangle>\\<rangle> \\<in> ?r\"\n          unfolding DFSAExecutionRelation_def[OF assms(1) D] by auto moreover\n        have funT:\"?t:?S\\<times>\\<Sigma> \\<rightarrow> ?S\" using D unfolding DFSA_def[OF assms(1)] by auto\n        with y(3,4) sf(1) have \"?t`\\<langle>\\<langle>y1,ff2\\<rangle>,Last(yL)\\<rangle> =\\<langle>t1`\\<langle>y1,Last(yL)\\<rangle>,t2`\\<langle>ff2,Last(yL)\\<rangle>\\<rangle>\"\n          using apply_equality[of \"\\<langle>\\<langle>y1,ff2\\<rangle>,Last(yL)\\<rangle>\" _ ?t \"?S\\<times>\\<Sigma>\" \"\\<lambda>_. ?S\"] last_type by auto\n        ultimately have \"\\<langle>\\<langle>yL,y1,ff2\\<rangle>,\\<langle>Init(yL),\\<langle>t1`\\<langle>y1,Last(yL)\\<rangle>,t2`\\<langle>ff2,Last(yL)\\<rangle>\\<rangle>\\<rangle>\\<rangle> \\<in> ?r\" by auto\n        with y(2) have \"\\<langle>\\<langle>yL,y1,ff2\\<rangle>,\\<langle>fst(z),\\<langle>snd(z),t2`\\<langle>ff2,Last(yL)\\<rangle>\\<rangle>\\<rangle>\\<rangle> \\<in> ?r\" by auto\n        with sf(2) have \"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(z),\\<langle>snd(z),t2`\\<langle>ff2,Last(yL)\\<rangle>\\<rangle>\\<rangle>\\<rangle>:?r^*\" using\n          rtrancl_into_rtrancl by auto\n        moreover from sf(1) have \"t2`\\<langle>ff2,Last(yL)\\<rangle> \\<in> S2\" using l2(1)\n          apply_type[of t2 \"S2\\<times>\\<Sigma>\" \"\\<lambda>_. S2\"] last_type[OF y(3)] unfolding DFSA_def[OF assms(1)]\n          by auto\n        ultimately have \"\\<exists>f2\\<in>S2. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(z),\\<langle>snd(z),f2\\<rangle>\\<rangle>\\<rangle>:?r^*\"\n          using sf(1) by auto\n      } moreover note A(1)\n      ultimately have \"\\<exists>f2\\<in>S2. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,\\<langle>f1,f2\\<rangle>\\<rangle>\\<rangle>:?r^*\"\n        using rtrancl_induct[of \"\\<langle>m,s1\\<rangle>\" \"\\<langle>0,f1\\<rangle>\" ?r1 \"\\<lambda>q. \\<exists>f2\\<in>S2. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(q),snd(q),f2\\<rangle>\\<rangle>:?r^*\"]\n        by auto\n      then obtain uu where uu:\"uu\\<in>S2\" \"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,\\<langle>f1,uu\\<rangle>\\<rangle>\\<rangle>:?r^*\" by auto\n      from K `s1\\<in>S1` have \"\\<exists>f1\\<in>S1. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>m,f1,s2\\<rangle>\\<rangle>:?r^*\" by auto moreover\n      {\n        fix y z\n        assume as:\"\\<langle>\\<langle>m,s2\\<rangle>,y\\<rangle>:?r2^*\" \"\\<langle>y,z\\<rangle>:?r2\" \"\\<exists>f1\\<in>S1. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(y),f1,snd(y)\\<rangle>\\<rangle>:?r^*\"\n        from as(2) obtain yL y1 where y:\"y=\\<langle>yL,y1\\<rangle>\" \"z=\\<langle>Init(yL),t2`\\<langle>y1,Last(yL)\\<rangle>\\<rangle>\"\n          \"yL\\<in>NELists(\\<Sigma>)\" \"y1:S2\" unfolding DFSAExecutionRelation_def[OF assms(1) l2(1)] by auto\n        with as(3) obtain ff2 where sf:\"ff2\\<in>S1\" \"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>yL,ff2,y1\\<rangle>\\<rangle>:?r^*\" by auto\n        from this(1) y(3,4) have \"\\<langle>\\<langle>yL,ff2,y1\\<rangle>,\\<langle>Init(yL),?t`\\<langle>\\<langle>ff2,y1\\<rangle>,Last(yL)\\<rangle>\\<rangle>\\<rangle> \\<in> ?r\"\n          unfolding DFSAExecutionRelation_def[OF assms(1) D] by auto moreover\n        have funT:\"?t:?S\\<times>\\<Sigma> \\<rightarrow> ?S\" using D unfolding DFSA_def[OF assms(1)] by auto\n        with y(3,4) sf(1) have \"?t`\\<langle>\\<langle>ff2,y1\\<rangle>,Last(yL)\\<rangle> =\\<langle>t1`\\<langle>ff2,Last(yL)\\<rangle>,t2`\\<langle>y1,Last(yL)\\<rangle>\\<rangle>\"\n          using apply_equality[of \"\\<langle>\\<langle>ff2,y1\\<rangle>,Last(yL)\\<rangle>\" _ ?t \"?S\\<times>\\<Sigma>\" \"\\<lambda>_. ?S\"] last_type by auto\n        ultimately have \"\\<langle>\\<langle>yL,ff2,y1\\<rangle>,\\<langle>Init(yL),\\<langle>t1`\\<langle>ff2,Last(yL)\\<rangle>,t2`\\<langle>y1,Last(yL)\\<rangle>\\<rangle>\\<rangle>\\<rangle> \\<in> ?r\" by auto\n        with y(2) have \"\\<langle>\\<langle>yL,ff2,y1\\<rangle>,\\<langle>fst(z),\\<langle>t1`\\<langle>ff2,Last(yL)\\<rangle>,snd(z)\\<rangle>\\<rangle>\\<rangle> \\<in> ?r\" by auto\n        with sf(2) have \"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(z),\\<langle>t1`\\<langle>ff2,Last(yL)\\<rangle>,snd(z)\\<rangle>\\<rangle>\\<rangle>:?r^*\" using\n          rtrancl_into_rtrancl by auto\n        moreover from sf(1) have \"t1`\\<langle>ff2,Last(yL)\\<rangle> \\<in> S1\" using l1(1)\n          apply_type[of t1 \"S1\\<times>\\<Sigma>\" \"\\<lambda>_. S1\"] last_type[OF y(3)] unfolding DFSA_def[OF assms(1)]\n          by auto\n        ultimately have \"\\<exists>f2\\<in>S1. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(z),\\<langle>f2,snd(z)\\<rangle>\\<rangle>\\<rangle>:?r^*\"\n          using sf(1) by auto\n      } moreover note A(2)\n      ultimately have \"\\<exists>f1\\<in>S1. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,\\<langle>f1,f2\\<rangle>\\<rangle>\\<rangle>:?r^*\"\n        using rtrancl_induct[of \"\\<langle>m,s2\\<rangle>\" \"\\<langle>0,f2\\<rangle>\" ?r2 \"\\<lambda>q. \\<exists>f1\\<in>S1. \\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>fst(q),f1,snd(q)\\<rangle>\\<rangle>:?r^*\"]\n        by auto\n      then obtain vv where vv:\"vv\\<in>S1\" \"\\<langle>\\<langle>m,s1,s2\\<rangle>,\\<langle>0,\\<langle>vv,f2\\<rangle>\\<rangle>\\<rangle>:?r^*\" by auto\n      from uu(2) vv(2) have \"f1=vv\" \"uu=f2\" using DetFinStateAuto.relation_deteministic[OF DFSA0,\n            of m ?s 0 ] by auto\n      from this(1) vv(2) ff(1,2) have \"m <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>\"\n        unfolding DFSASatisfy_def[OF assms(1) D M(1)] by auto\n    }\n    ultimately have \"m <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>\"\n      unfolding DFSASatisfy_def[OF assms(1) D M(1)] by auto\n  }\n  with l1(2) l2(2) have \"L1\\<inter>L2 \\<subseteq> {i \\<in> Lists(\\<Sigma>). i <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>}\" by auto\n  with S1 have \"{i \\<in> Lists(\\<Sigma>). i <-D (?S,?s,?t,?F){in alphabet}\\<Sigma>} = L1\\<inter>L2\" by auto\n  then have \"L1\\<inter>L2 = DetFinStateAuto.LanguageDFSA(?S,?s,?t,?F,\\<Sigma>)\" by auto\n  with D have \"\\<exists>S s t F. ((S,s,t,F){is an DFSA for alphabet}\\<Sigma>) \\<and> L1\\<inter>L2 = DetFinStateAuto.LanguageDFSA(S,s,t,F,\\<Sigma>)\"\n    using exI[of \"\\<lambda>h. ((?S,?s,?t,h){is an DFSA for alphabet}\\<Sigma>) \\<and> L1\\<inter>L2 = DetFinStateAuto.LanguageDFSA(?S,?s,?t,h,\\<Sigma>)\" ?F]\n    using exI[of \"\\<lambda>m. \\<exists>h. ((?S,?s,m,h){is an DFSA for alphabet}\\<Sigma>) \\<and> L1\\<inter>L2 = DetFinStateAuto.LanguageDFSA(?S,?s,m,h,\\<Sigma>)\" ?t]\n    using exI[of \"\\<lambda>n. \\<exists>m h. ((?S,n,m,h){is an DFSA for alphabet}\\<Sigma>) \\<and> L1\\<inter>L2 = DetFinStateAuto.LanguageDFSA(?S,n,m,h,\\<Sigma>)\" ?s]\n    using exI[of \"\\<lambda>p. \\<exists>n m h. ((p,n,m,h){is an DFSA for alphabet}\\<Sigma>) \\<and> L1\\<inter>L2 = DetFinStateAuto.LanguageDFSA(p,n,m,h,\\<Sigma>)\" ?S]\n    by auto\n  with assms(2,3) show ?thesis unfolding IsRegularLanguage_def[OF assms(1)] IsALanguage_def[OF assms(1)] by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 298
    },
    "276": {
        "type": "theorem",
        "text": "text\\<open>The complement of a regular language\nis a regular language.\\<close>\n",
        "assumes": "assumes \"Finite(\\<Sigma>)\"\n  and \"L{is a regular language on}\\<Sigma>\"\n  ",
        "using": [
            "DetFinStateAuto_def",
            "assms(1)",
            "l(1)",
            "rtrancl_induct[of",
            "\"\\<langle>0,s\\<rangle>\"",
            "\"\\<langle>0,yy\\<rangle>\"",
            "?r",
            "\"\\<lambda>q.",
            "q=\\<langle>0,s\\<rangle>\"]",
            "DetFinStateAuto.relation_deteministic[OF",
            "D0,",
            "of",
            "m",
            "s",
            "0]",
            "M(1)",
            "l(2)",
            "non_zero_List_func_is_NEList",
            "DetFinStateAuto.endpoint_exists[OF",
            "D0]",
            "DetFinStateAuto.DFSA_dest(1)[OF",
            "D"
        ],
        "statement": "theorem regular_opp:\n  assumes \"Finite(\\<Sigma>)\"\n  and \"L{is a regular language on}\\<Sigma>\"\n  shows \"(Lists(\\<Sigma>)-L) {is a regular language on}\\<Sigma>\"\n",
        "proof": "proof-\n  from assms(1,2) obtain S s t F where l:\"(S,s,t,F){is an DFSA for alphabet}\\<Sigma>\" \n    \"L=DetFinStateAuto.LanguageDFSA(S,s,t,F,\\<Sigma>)\" unfolding IsRegularLanguage_def[OF assms(1)] by auto\n  then have l:\"(S,s,t,F){is an DFSA for alphabet}\\<Sigma>\"\n    \"L={i\\<in>Lists(\\<Sigma>). i <-D (S,s,t,F){in alphabet}\\<Sigma>}\"\n    using DetFinStateAuto_def assms(1) l(1) by auto\n  have \"Lists(\\<Sigma>)-L \\<subseteq> Lists(\\<Sigma>)\" by auto\n  then have \"(Lists(\\<Sigma>)-L) {is a language with alphabet} \\<Sigma>\"\n    unfolding IsALanguage_def[OF assms(1)] by auto\n  let ?F = \"S-F\"\n  let ?r = \"DetFinStateAuto.r\\<^sub>D(S,s,t,\\<Sigma>)\"\n  from l(1) have D:\"(S,s,t,?F){is an DFSA for alphabet}\\<Sigma>\" unfolding DFSA_def[OF assms(1)]\n    by auto\n  with assms(1) have D0:\"DetFinStateAuto(S,s,t,?F,\\<Sigma>)\" unfolding DetFinStateAuto_def by auto\n  {\n    fix m assume \"m\\<in>{i\\<in>Lists(\\<Sigma>). i <-D (S,s,t,?F){in alphabet}\\<Sigma>}\"\n    then have M:\"m\\<in>Lists(\\<Sigma>)\" \"m <-D (S,s,t,?F){in alphabet}\\<Sigma>\" by auto\n    {\n      assume \"m\\<in>L\"\n      with l(2) have MM:\"m <-D (S,s,t,F){in alphabet}\\<Sigma>\" by auto\n      {\n        assume as:\"m=0\"\n        from MM(1) as(1) obtain yy where \"\\<langle>\\<langle>0,s\\<rangle>,\\<langle>0,yy\\<rangle>\\<rangle>:?r^* \\<or> s:F\" \"yy\\<in>F\" unfolding\n          DFSASatisfy_def[OF assms(1) l(1) M(1)] by auto moreover\n        {\n          fix y z\n          assume \"\\<langle>\\<langle>0,s\\<rangle>,y\\<rangle> \\<in> ?r^*\" \"\\<langle>y,z\\<rangle> \\<in> ?r\" \"y = \\<langle>0,s\\<rangle>\"\n          from this(2,3) have \"0\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF assms(1) l(1)]\n            by auto\n          then have False unfolding NELists_def Pi_def by auto\n          then have \"z=\\<langle>0,s\\<rangle>\" by auto\n        }\n        ultimately have sf:\"s:F\" using rtrancl_induct[of \"\\<langle>0,s\\<rangle>\" \"\\<langle>0,yy\\<rangle>\" ?r \"\\<lambda>q. q=\\<langle>0,s\\<rangle>\"] by auto\n        from M(2) as(1) obtain yy where \"\\<langle>\\<langle>0,s\\<rangle>,\\<langle>0,yy\\<rangle>\\<rangle>:?r^* \\<or> s:S-F\" \"yy\\<in>S-F\" unfolding\n          DFSASatisfy_def[OF assms(1) D M(1)] by auto moreover\n        {\n          fix y z\n          assume \"\\<langle>\\<langle>0,s\\<rangle>,y\\<rangle> \\<in> ?r^*\" \"\\<langle>y,z\\<rangle> \\<in> ?r\" \"y = \\<langle>0,s\\<rangle>\"\n          from this(2,3) have \"0\\<in>NELists(\\<Sigma>)\" unfolding DFSAExecutionRelation_def[OF assms(1) D]\n            by auto\n          then have False unfolding NELists_def Pi_def by auto\n          then have \"z=\\<langle>0,s\\<rangle>\" by auto\n        }\n        ultimately have \"s:S-F\" using rtrancl_induct[of \"\\<langle>0,s\\<rangle>\" \"\\<langle>0,yy\\<rangle>\" ?r \"\\<lambda>q. q=\\<langle>0,s\\<rangle>\"] by auto\n        with sf have False by auto\n      }\n      then have m0:\"m\\<noteq>0\" by auto\n      with MM obtain q1 where q1:\"q1\\<in>F\" \"\\<langle>\\<langle>m, s\\<rangle>, 0, q1\\<rangle> \\<in> ?r^*\" \n        unfolding DFSASatisfy_def[OF assms(1) l(1) M(1)] by auto\n      from m0 M(2) obtain q2 where q2:\"q2\\<in>S-F\" \"\\<langle>\\<langle>m, s\\<rangle>, 0, q2\\<rangle> \\<in> ?r^*\" \n        unfolding DFSASatisfy_def[OF assms(1) D M(1)] by auto\n      from q1(2) q2(2) have \"q1=q2\" using DetFinStateAuto.relation_deteministic[OF D0,\n            of m s 0] by auto\n      with q1(1) q2(1) have False by auto\n    }\n    then have \"m\\<in>Lists(\\<Sigma>) - L\" using M(1) by auto\n  }\n  then have S:\"{i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>} \\<subseteq> Lists(\\<Sigma>) - L\" by auto\n  {\n    fix m assume \"m\\<in>Lists(\\<Sigma>)-L\"\n    then have m:\"m\\<in>Lists(\\<Sigma>)\" \"m <-D (S,s,t,F){in alphabet}\\<Sigma> \\<Longrightarrow> False\" using l(2)\n      by auto\n    from this(1) have R:\"m = 0 \\<or> (\\<exists>q\\<in>S. \\<langle>\\<langle>m,s\\<rangle>,0,q\\<rangle> \\<in> ?r^*)\" \n      using non_zero_List_func_is_NEList \n        DetFinStateAuto.endpoint_exists[OF D0] by auto\n    {\n      assume as:\"m=0\" \"s\\<in>F\"\n      with m(1) have \"m <-D (S,s,t,F){in alphabet}\\<Sigma>\" unfolding\n        DFSASatisfy_def[OF assms(1) l(1) m(1)] by auto\n      with m(2) have False by auto\n      then have \"m\\<in>{i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto\n    } moreover\n    {\n      assume as:\"m=0\" \"s\\<notin>F\"\n      then have \"m=0\" \"s\\<in>S-F\" using DetFinStateAuto.DFSA_dest(1)[OF D0] by auto\n      then have \"m <-D (S,s,t,S - F){in alphabet}\\<Sigma>\" unfolding DFSASatisfy_def[OF assms(1) D m(1)] by auto\n      with m(1) have \"m\\<in>{i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto\n    } ultimately\n    have \"m =0 \\<longrightarrow> m\\<in>{i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto moreover\n    {\n      assume \"\\<exists>q\\<in>S. \\<langle>\\<langle>m,s\\<rangle>,0,q\\<rangle> \\<in> ?r^*\"\n      then obtain q where q:\"\\<langle>\\<langle>m,s\\<rangle>,0,q\\<rangle> \\<in> ?r^*\" \"q\\<in>S\" by auto\n      {\n        assume \"q\\<in>F\"\n        with q(1) have \"m <-D (S,s,t,F){in alphabet}\\<Sigma>\" unfolding DFSASatisfy_def[OF assms(1) l(1) m(1)] by auto\n        with m(2) have False by auto\n      }\n      with q have \"\\<exists>q\\<in>S-F. \\<langle>\\<langle>m,s\\<rangle>,0,q\\<rangle> \\<in> ?r^*\" by auto\n      then have \"m <-D (S,s,t,S-F){in alphabet}\\<Sigma>\" unfolding DFSASatisfy_def[OF assms(1) D m(1)] by auto\n      with m(1) have \"m\\<in>{i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto\n    } moreover note R\n    ultimately have \"m\\<in>{i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto\n  }\n  then have \"Lists(\\<Sigma>) -L \\<subseteq> {i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto\n  with S have \"Lists(\\<Sigma>) -L = {i \\<in> Lists(\\<Sigma>) . i <-D (S,s,t,S - F){in alphabet}\\<Sigma>}\" by auto\n  then have \"Lists(\\<Sigma>) -L = DetFinStateAuto.LanguageDFSA(S,s,t,S-F,\\<Sigma>)\" .\n  then show ?thesis unfolding IsRegularLanguage_def[OF assms(1)] using D by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 299
    },
    "277": {
        "type": "definition",
        "text": "text\\<open>Another natural operation on words is concatenation,\nhence we can defined the concatenated language as\nthe set of concatenations of words of one language \nwith words of another.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition concat where\n  \"L1 {is a language with alphabet}\\<Sigma> \\<Longrightarrow> L2 {is a language with alphabet}\\<Sigma>\n    \\<Longrightarrow> concat(L1,L2) = {Concat(w1,w2). \\<langle>w1,w2\\<rangle>\\<in>L1\\<times>L2}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 301
    },
    "278": {
        "type": "lemma",
        "text": "text\\<open>The result of concatenating two languages is a language.\\<close>\n",
        "assumes": "assumes \"Finite(\\<Sigma>)\"\n  and \"L1 {is a language with alphabet}\\<Sigma>\"\n  and \"L2 {is a language with alphabet}\\<Sigma>\"\n",
        "using": [
            "concat_props(1)"
        ],
        "statement": "lemma concat_language:\n  assumes \"Finite(\\<Sigma>)\"\n  and \"L1 {is a language with alphabet}\\<Sigma>\"\n  and \"L2 {is a language with alphabet}\\<Sigma>\"\nshows \"concat(L1,L2) {is a language with alphabet}\\<Sigma>\"\n",
        "proof": "proof-\n  {\n    fix w assume \"w\\<in>concat(L1,L2)\"\n    then obtain w1 w2 where w:\"w=Concat(w1,w2)\" \"w1\\<in>L1\" \"w2\\<in>L2\" unfolding concat_def[OF assms(2,3)]\n      by auto\n    from this(2,3) assms(2,3) obtain n1 n2 where \"n1\\<in>nat\" \"n2\\<in>nat\" \"w1:n1\\<rightarrow>\\<Sigma>\" \"w2:n2\\<rightarrow>\\<Sigma>\"\n      unfolding IsALanguage_def[OF assms(1)] Lists_def by blast\n    then have \"Concat(w1,w2):n1#+n2 \\<rightarrow> \\<Sigma>\" \"n1#+n2 \\<in>nat\" using concat_props(1) by auto\n    with w(1) have \"w\\<in>Lists(\\<Sigma>)\" unfolding Lists_def by auto\n  }\n  then show ?thesis unfolding IsALanguage_def[OF assms(1)] by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 302
    },
    "279": {
        "type": "definition",
        "text": "text\\<open>The non-determinism is introduced by allowing\nthe transition function to return not just a state,\nbut more than one or even none.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  NFSA (\"'(_,_,_,_'){is an NFSA for alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an NFSA for alphabet}\\<Sigma> \\<equiv> Finite(S) \\<and> s\\<^sub>0\\<in>S \\<and> F\\<subseteq>S \\<and> t:S\\<times>\\<Sigma>\\<rightarrow>Pow(S)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 303
    },
    "280": {
        "type": "definition",
        "text": "text\\<open>The transition relation is then realized by considering\nall possible steps the transition function returns.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  NFSAExecutionRelation (\"{reduce N-relation} '(_,_,_'){in alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an NFSA for alphabet}\\<Sigma> \\<Longrightarrow> \n  {reduce N-relation}(S,s\\<^sub>0,t){in alphabet}\\<Sigma> \\<equiv> {\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>Init(w),\\<Union>{t`\\<langle>s,Last(w)\\<rangle>. s\\<in>Q}\\<rangle>\\<rangle>. \\<langle>w,Q\\<rangle>\\<in>NELists(\\<Sigma>)\\<times>Pow(S)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 304
    },
    "281": {
        "type": "definition",
        "text": "text\\<open>An extra generalization can be consider\nif we allow the transition relation to go forward\nwithout consuming elements from the word. This\nis implemented as allowing @{term \\<Sigma>} to symbolize\nan step without the word being touched. We might\ncall it a @{term \\<Sigma>} transition or a $\\varepsilon$-transition.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  FullNFSA (\"'(_,_,_,_'){is an \\<epsilon>-NFSA for alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an \\<epsilon>-NFSA for alphabet}\\<Sigma> \\<equiv> Finite(S) \\<and> s\\<^sub>0\\<in>S \\<and> F\\<subseteq>S \\<and> t:S\\<times>succ(\\<Sigma>)\\<rightarrow>Pow(S)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 306
    },
    "282": {
        "type": "definition",
        "text": "text\\<open>The closure of a set of states can then be\nviewed as all the states reachable from that set\nwith a transition of type @{term \\<Sigma>}.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  EpsilonClosure (\"\\<epsilon>-cl\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an \\<epsilon>-NFSA for alphabet}\\<Sigma> \\<Longrightarrow> E\\<subseteq>S\n    \\<Longrightarrow> \\<epsilon>-cl(S,t,\\<Sigma>,E) \\<equiv> \\<Union>{P\\<in>Pow(S). \\<langle>E,P\\<rangle>\\<in>({\\<langle>Q,{s\\<in>S. \\<exists>q\\<in>Q. t`\\<langle>q,\\<Sigma>\\<rangle> = s}\\<rangle>. Q\\<in>Pow(S)}^*)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 307
    },
    "283": {
        "type": "definition",
        "text": "text\\<open>The reduction relation is then extended\nby considering any such transitions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  FullNFSAExecutionRelation (\"{reduce \\<epsilon>-N-relation} '(_,_,_'){in alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an \\<epsilon>-NFSA for alphabet}\\<Sigma> \\<Longrightarrow> \n  {reduce \\<epsilon>-N-relation}(S,s\\<^sub>0,t){in alphabet}\\<Sigma> \\<equiv> {\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>Init(w),\\<epsilon>-cl(S,t,\\<Sigma>,\\<Union>{t`\\<langle>s,Last(w)\\<rangle>. s\\<in>Q})\\<rangle>\\<rangle>. \\<langle>w,Q\\<rangle>\\<in>NELists(\\<Sigma>)\\<times>Pow(S)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 308
    },
    "284": {
        "type": "definition",
        "text": "text\\<open>The full reduction of a word is similar to that\nof the automata without $\\varepsilon$-transitions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  FullNFSASatisfy (\"_ <-\\<epsilon>-N '(_,_,_,_'){in alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an \\<epsilon>-NFSA for alphabet}\\<Sigma> \\<Longrightarrow> i\\<in>Lists(\\<Sigma>) \\<Longrightarrow> \n  i <-\\<epsilon>-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma> \\<equiv> (\\<exists>q\\<in>Pow(S). (q\\<inter>F\\<noteq>0 \\<and> \\<langle>\\<langle>i,{s\\<^sub>0}\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in> ({reduce \\<epsilon>-N-relation}(S,s\\<^sub>0,t){in alphabet}\\<Sigma>)^*)) \\<or> (i = 0 \\<and> s\\<^sub>0\\<in>F)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 309
    },
    "285": {
        "type": "definition",
        "text": "text\\<open>The transition function of the deterministic\nautomata we will construct\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in NonDetFinStateAuto) tPow where\n  \"tPow \\<equiv> {\\<langle>\\<langle>U,u\\<rangle>,(\\<Union>v\\<in>U. t ` \\<langle>v, u\\<rangle>)\\<rangle>. \\<langle>U,u\\<rangle>\\<in>Pow(S)\\<times>\\<Sigma>}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 310
    },
    "286": {
        "type": "definition",
        "text": "text\\<open>The transition relation of the deterministic\nautomata we will construct\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in NonDetFinStateAuto) rPow where\n  \"rPow \\<equiv> DetFinStateAuto.r\\<^sub>D(Pow(S),{s\\<^sub>0},tPow,\\<Sigma>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 311
    },
    "287": {
        "type": "lemma",
        "text": "text\\<open>First, we show that if the non-deterministic\nautomaton produces a reduction step to a word, then the deterministic one\nwe constructed does the same reduction step.\\<close>\n",
        "assumes": "assumes \"\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>u,G\\<rangle>\\<rangle>\\<in>r\\<^sub>N\"\n  ",
        "using": [
            "last_type[OF",
            "w(1)]",
            "w(3)",
            "tPow_def",
            "apply_equality[OF",
            "_",
            "dfsa.DFSA_dest(3),",
            "of",
            "\"\\<langle>Q,Last(w)\\<rangle>\"",
            "\"\\<Union>s\\<in>Q.",
            "t`\\<langle>s,Last(w)\\<rangle>\"]"
        ],
        "statement": "lemma (in NonDetFinStateAuto) nd_impl_det:\n  assumes \"\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>u,G\\<rangle>\\<rangle>\\<in>r\\<^sub>N\"\n  shows \"\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>u,G\\<rangle>\\<rangle>\\<in>rPow\"\n",
        "proof": "proof-\n  from assms have w:\"w\\<in>NELists(\\<Sigma>)\" \"u=Init(w)\" \"Q\\<in>Pow(S)\" \"G=(\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>)\"\n    unfolding NFSAExecutionRelation_def[OF finite_alphabet NFSA] by auto\n  then have \"tPow`\\<langle>Q,Last(w)\\<rangle> = (\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>) \\<Longrightarrow> ?thesis\"\n    unfolding DFSAExecutionRelation_def[OF finite_alphabet dfsa.DFSA] rPow_def\n    by auto\n  moreover have \"\\<langle>\\<langle>Q,Last(w)\\<rangle>,\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>\\<rangle>:tPow\" using last_type[OF w(1)] w(3)\n    unfolding tPow_def by auto\n  ultimately show ?thesis using apply_equality[OF _ dfsa.DFSA_dest(3), of \"\\<langle>Q,Last(w)\\<rangle>\" \"\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>\"]\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 312
    },
    "288": {
        "type": "lemma",
        "text": "text\\<open>Next, we show that if the deterministic\nautomaton produces a reduction step to a word, then the non-deterministic one\nwe constructed does the same reduction step.\\<close>\n",
        "assumes": "assumes \"\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>u,G\\<rangle>\\<rangle>\\<in>rPow\"\n  ",
        "using": [
            "last_type[OF",
            "w(1)]",
            "w(3)",
            "apply_equality[OF",
            "_",
            "dfsa.DFSA_dest(3),",
            "of",
            "\"\\<langle>Q,Last(w)\\<rangle>\"",
            "\"\\<Union>s\\<in>Q.",
            "t`\\<langle>s,Last(w)\\<rangle>\"]"
        ],
        "statement": "lemma (in NonDetFinStateAuto) det_impl_nd:\n  assumes \"\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>u,G\\<rangle>\\<rangle>\\<in>rPow\"\n  shows \"\\<langle>\\<langle>w,Q\\<rangle>,\\<langle>u,G\\<rangle>\\<rangle>\\<in>r\\<^sub>N\"\n",
        "proof": "proof-\n  from assms have w:\"w\\<in>NELists(\\<Sigma>)\" \"u=Init(w)\" \"Q\\<in>Pow(S)\" \"G=tPow ` \\<langle>Q, Last(w)\\<rangle>\"\n    unfolding DFSAExecutionRelation_def[OF finite_alphabet dfsa.DFSA] rPow_def by auto\n  then have \"tPow`\\<langle>Q,Last(w)\\<rangle> = (\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>) \\<Longrightarrow> ?thesis\" \n    unfolding NFSAExecutionRelation_def[OF finite_alphabet NFSA] by auto\n  moreover have \"\\<langle>\\<langle>Q,Last(w)\\<rangle>,\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>\\<rangle>:tPow\" unfolding tPow_def using last_type[OF w(1)] w(3) by auto\n  ultimately show ?thesis using apply_equality[OF _ dfsa.DFSA_dest(3), of \"\\<langle>Q,Last(w)\\<rangle>\" \"\\<Union>s\\<in>Q. t`\\<langle>s,Last(w)\\<rangle>\"]\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 313
    },
    "289": {
        "type": "corollary",
        "text": "text\\<open>Since both are relations, they are equal\\<close>\n",
        "assumes": "",
        "using": [
            "nd_impl_det",
            "det_impl_nd",
            "DFSAExecutionRelation_def[OF",
            "finite_alphabet",
            "dfsa.DFSA]",
            "NFSAExecutionRelation_def[OF",
            "NFSA]",
            "rPow_def"
        ],
        "statement": "corollary (in NonDetFinStateAuto) relation_NFSA_to_DFSA:\n  shows \"r\\<^sub>N = rPow\" ",
        "proof": "using nd_impl_det det_impl_nd\n  unfolding DFSAExecutionRelation_def[OF finite_alphabet dfsa.DFSA]\n  NFSAExecutionRelation_def[OF finite_alphabet NFSA] rPow_def\n  by auto\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 314
    },
    "290": {
        "type": "theorem",
        "text": "text\\<open>As a consequence, by the definition of a language\ngenerated by an automaton, both languages are equal.\\<close>\n",
        "assumes": "",
        "using": [
            "DFSASatisfy_def[OF",
            "finite_alphabet",
            "dfsa.DFSA",
            "i(1)]",
            "rPow_def",
            "tPow_def",
            "relation_NFSA_to_DFSA",
            "NFSA",
            "NFSA_def[OF",
            "finite_alphabet]"
        ],
        "statement": "theorem (in NonDetFinStateAuto) language_nfsa:\n  shows \"dfsa.LanguageDFSA = LanguageNFSA\"\n",
        "proof": "proof-\n  let ?S = \"Pow(S)\"\n  let ?s = \"{s\\<^sub>0}\"\n  let ?f = \"{\\<langle>\\<langle>U, u\\<rangle>, \\<Union>v\\<in>U. t ` \\<langle>v, u\\<rangle>\\<rangle> . \\<langle>U, u\\<rangle> \\<in> Pow(S) \\<times> \\<Sigma>}\"\n  let ?F = \"{Q \\<in> Pow(S) . Q \\<inter> F \\<noteq> 0}\"\n  {\n    fix i assume i:\"i\\<in>Lists(\\<Sigma>)\" \"i <-D (?S,?s,?f,?F){in alphabet}\\<Sigma>\"\n    {\n      assume \"i=0\" \"?s\\<in>?F\"\n      then have \"i=0\" \"s\\<^sub>0\\<in>F\" by auto\n      then have \"i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>\" \n        unfolding NFSASatisfy_def[OF finite_alphabet NFSA i(1)] by auto\n    } moreover\n    {\n      assume \"\\<not>(i=0 \\<and> ?s\\<in>?F)\"\n      with i(2) obtain q where q:\"q\\<in>?F\" \"\\<langle>\\<langle>i,?s\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>rPow^*\" \n        using DFSASatisfy_def[OF finite_alphabet dfsa.DFSA i(1)]\n        unfolding rPow_def tPow_def by auto\n      then have \"\\<langle>\\<langle>i,?s\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>N^*\" using relation_NFSA_to_DFSA\n        by auto\n      with q(1) have \"i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>\"\n      unfolding NFSASatisfy_def[OF finite_alphabet NFSA i(1)] by auto\n    } ultimately\n    have \"i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>\" by auto\n  }\n  then have A:\"{i \\<in> Lists(\\<Sigma>) . dfsa.reduce(i)} \\<subseteq> {i \\<in> Lists(\\<Sigma>) . i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>}\"\n    unfolding rPow_def tPow_def by auto\n  {\n    fix i assume i:\"i\\<in>Lists(\\<Sigma>)\" \"i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>\"\n    {\n      assume \"i=0\" \"s\\<^sub>0\\<in>F\"\n      then have \"i=0\" \"?s\\<in>?F\" using NFSA\n        unfolding NFSA_def[OF finite_alphabet] by auto\n      then have \"i <-D (?S,?s,?f,?F){in alphabet}\\<Sigma>\" \n        using DFSASatisfy_def[OF finite_alphabet dfsa.DFSA i(1)]\n        unfolding tPow_def rPow_def by auto\n    } moreover\n    {\n      assume \"\\<not>(i=0 \\<and> s\\<^sub>0\\<in>F)\"\n      with i(2) obtain q where q:\"q\\<in>Pow(S)\" \"q\\<inter>F\\<noteq>0\" \"\\<langle>\\<langle>i,?s\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>r\\<^sub>N^*\" \n        unfolding NFSASatisfy_def[OF finite_alphabet NFSA i(1)] by auto\n      then have \"\\<langle>\\<langle>i,?s\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in>rPow^*\" using relation_NFSA_to_DFSA\n        by auto\n      with q(1,2) have \"i <-D (?S,?s,?f,?F){in alphabet}\\<Sigma>\"\n        using DFSASatisfy_def[OF finite_alphabet dfsa.DFSA i(1)]\n      unfolding tPow_def rPow_def by auto\n    } ultimately\n    have \"i <-D (?S,?s,?f,?F){in alphabet}\\<Sigma>\" by auto\n  }\n  then have B:\"{i \\<in> Lists(\\<Sigma>) . i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma>}\\<subseteq>\n    {i \\<in> Lists(\\<Sigma>) . dfsa.reduce(i)}\" unfolding tPow_def rPow_def by auto\n  with A show \"dfsa.LanguageDFSA = LanguageNFSA\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 315
    },
    "291": {
        "type": "corollary",
        "text": "text\\<open>The language of a non-deterministic finite\nstate automaton is regular.\\<close>\n",
        "assumes": "",
        "using": [
            "language_nfsa",
            "dfsa.DFSA"
        ],
        "statement": "corollary (in NonDetFinStateAuto) lang_is_regular:\n  shows \"LanguageNFSA{is a regular language on}\\<Sigma>\"\n  unfolding IsRegularLanguage_def[OF finite_alphabet]\n  apply (rule exI[of _ \"Pow(S)\"],\n         rule exI[of _ \"{s\\<^sub>0}\"],\n         rule exI[of _ tPow],\n         rule exI[of _ \"{Q \\<in> Pow(S). Q \\<inter> F \\<noteq> 0}\"])\n  ",
        "proof": "using language_nfsa dfsa.DFSA by auto\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 316
    },
    "292": {
        "type": "definition",
        "text": "text\\<open>We defined the finite powerset \\<open>FinPow(X)\\<close> as those elements \n  of the powerset that are finite.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"FinPow(X) \\<equiv> {A \\<in> Pow(X). Finite(A)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 317
    },
    "293": {
        "type": "lemma",
        "text": "text\\<open>The cardinality of an element of finite powerset is a natural number.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" \n  ",
        "using": [
            "assms",
            "FinPow_def",
            "Finite_def",
            "cardinal_cong",
            "nat_into_Card",
            "Card_cardinal_eq"
        ],
        "statement": "lemma card_fin_is_nat: assumes \"A \\<in> FinPow(X)\" \n  shows \"|A| \\<in> nat\" and \"A \\<approx> |A|\"\n  ",
        "proof": "using assms FinPow_def Finite_def cardinal_cong nat_into_Card \n    Card_cardinal_eq by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 318
    },
    "294": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of \\<open>card_fin_is_nat\\<close>: for a finit\n  set $A$ there is a bijection between $|A|$ and $A$.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\"\n  ",
        "using": [
            "card_fin_is_nat",
            "eqpoll_sym",
            "eqpoll_def"
        ],
        "statement": "lemma fin_bij_card: assumes A1: \"A \\<in> FinPow(X)\"\n  shows \"\\<exists>b. b \\<in> bij(|A|, A)\"\n",
        "proof": "proof -\n  from A1 have \"|A| \\<approx> A\" using card_fin_is_nat eqpoll_sym\n    by blast\n  then show ?thesis using eqpoll_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 319
    },
    "295": {
        "type": "lemma",
        "text": "text\\<open>If a set has the same number of elements as $n \\in \\mathbb{N}$, \n  then its cardinality is $n$. Recall that in set theory a natural number\n  $n$ is a set that has $n$ elements.\\<close>\n",
        "assumes": "assumes \"A \\<approx> n\" and \"n \\<in> nat\"\n  ",
        "using": [
            "assms",
            "cardinal_cong",
            "nat_into_Card",
            "Card_cardinal_eq"
        ],
        "statement": "lemma card_card: assumes \"A \\<approx> n\" and \"n \\<in> nat\"\n  shows \"|A| = n\"\n  ",
        "proof": "using assms cardinal_cong nat_into_Card Card_cardinal_eq\n  by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 320
    },
    "296": {
        "type": "lemma",
        "text": "text\\<open>If we add a point to a finite set, the cardinality \n  increases by one. To understand the second assertion\n  $| A \\cup \\{ a\\}| = |A| \\cup \\{ |A|\\} $ recall that\n  the cardinality $|A|$ of $A$ is a natural number\n  and for natural numbers we have $n+1 = n \\cup \\{ n\\}$. \n\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" and A2: \"a \\<in> X-A\"\n  ",
        "using": [
            "card_fin_is_nat",
            "mem_not_refl",
            "cons_eqpoll_cong",
            "succ_explained",
            "card_card"
        ],
        "statement": "lemma card_fin_add_one: assumes A1: \"A \\<in> FinPow(X)\" and A2: \"a \\<in> X-A\"\n  shows \n  \"|A \\<union> {a}| = succ( |A| )\"\n  \"|A \\<union> {a}| = |A| \\<union> {|A|}\"\n",
        "proof": "proof -\n  from A1 A2 have \"cons(a,A) \\<approx> cons( |A|, |A| )\"\n    using card_fin_is_nat mem_not_refl cons_eqpoll_cong\n    by auto\n  moreover have  \"cons(a,A) = A \\<union> {a}\" by (rule consdef) \n  moreover have \"cons( |A|, |A| ) = |A| \\<union> {|A|}\"\n    by (rule consdef)\n  ultimately have \"A\\<union>{a} \\<approx> succ( |A| )\" using succ_explained\n    by simp\n  with A1 show \n    \"|A \\<union> {a}| = succ( |A| )\" and \"|A \\<union> {a}| = |A| \\<union> {|A|}\"\n    using card_fin_is_nat card_card by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 321
    },
    "297": {
        "type": "lemma",
        "text": "text\\<open>We can decompose the finite powerset into collection of\n  sets of the same natural cardinalities.\\<close>\n",
        "assumes": "",
        "using": [
            "Finite_def",
            "FinPow_def"
        ],
        "statement": "lemma finpow_decomp: \n  shows \"FinPow(X) = (\\<Union>n \\<in> nat. {A \\<in> Pow(X). A \\<approx> n})\"\n  ",
        "proof": "using Finite_def FinPow_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 322
    },
    "298": {
        "type": "lemma",
        "text": "text\\<open>Finite powerset is the union of sets of cardinality\n  bounded by natural numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "finpow_decomp",
            "FinPow_def",
            "eqpoll_imp_lepoll",
            "lepoll_nat_imp_Finite"
        ],
        "statement": "lemma finpow_union_card_nat: \n  shows \"FinPow(X) = (\\<Union>n \\<in> nat. {A \\<in> Pow(X). A \\<lesssim> n})\"\n",
        "proof": "proof -\n  have \"FinPow(X) \\<subseteq> (\\<Union>n \\<in> nat. {A \\<in> Pow(X). A \\<lesssim> n})\"\n    using finpow_decomp FinPow_def eqpoll_imp_lepoll\n    by auto\n  moreover have \n    \"(\\<Union>n \\<in> nat. {A \\<in> Pow(X). A \\<lesssim> n}) \\<subseteq> FinPow(X)\"\n    using lepoll_nat_imp_Finite FinPow_def by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 323
    },
    "299": {
        "type": "lemma",
        "text": "text\\<open>A different form of \\<open>finpow_union_card_nat\\<close> (see above) -\n  a subset that has not more elements than a given natural number \n  is in the finite powerset.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"   \"A \\<subseteq> X\"  \"A \\<lesssim> n\"\n  ",
        "using": [
            "assms",
            "finpow_union_card_nat"
        ],
        "statement": "lemma lepoll_nat_in_finpow: \n  assumes \"n \\<in> nat\"   \"A \\<subseteq> X\"  \"A \\<lesssim> n\"\n  shows \"A \\<in> FinPow(X)\"\n  ",
        "proof": "using assms finpow_union_card_nat by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 324
    },
    "300": {
        "type": "lemma",
        "text": "text\\<open>Natural numbers are finite subsets of the set of natural numbers.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" ",
        "using": [
            "assms",
            "nat_into_Finite",
            "nat_subset_nat",
            "FinPow_def"
        ],
        "statement": "lemma nat_finpow_nat: assumes \"n \\<in> nat\" shows \"n \\<in> FinPow(nat)\"\n  ",
        "proof": "using assms nat_into_Finite nat_subset_nat FinPow_def\n  by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 325
    },
    "301": {
        "type": "lemma",
        "text": "text\\<open>A finite subset is a finite subset of itself.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" ",
        "using": [
            "assms",
            "FinPow_def"
        ],
        "statement": "lemma fin_finpow_self: assumes \"A \\<in> FinPow(X)\" shows \"A \\<in> FinPow(A)\"\n  ",
        "proof": "using assms FinPow_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 326
    },
    "302": {
        "type": "lemma",
        "text": "text\\<open>If we remove an element and put it back we get the set back.\n\\<close>\n",
        "assumes": "assumes \"a\\<in>A\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma rem_add_eq: assumes \"a\\<in>A\" shows \"(A-{a}) \\<union> {a} = A\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 327
    },
    "303": {
        "type": "theorem",
        "text": "text\\<open>Induction for finite powerset. This is smilar to the\n  standard Isabelle's \\<open>Fin_induct\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"P(0)\" and\n  A2: \"\\<forall>A \\<in> FinPow(X). P(A) \\<longrightarrow> (\\<forall>a\\<in>X. P(A \\<union> {a}))\" and\n  A3: \"B \\<in> FinPow(X)\"\n  ",
        "using": [
            "lepoll_0_is_0",
            "lepoll_0_iff",
            "Diff_sing_lepoll",
            "lepoll_nat_in_finpow",
            "finpow_decomp",
            "finpow_union_card_nat"
        ],
        "statement": "theorem FinPow_induct: assumes A1: \"P(0)\" and\n  A2: \"\\<forall>A \\<in> FinPow(X). P(A) \\<longrightarrow> (\\<forall>a\\<in>X. P(A \\<union> {a}))\" and\n  A3: \"B \\<in> FinPow(X)\"\n  shows \"P(B)\"\n",
        "proof": "proof -\n  { fix n assume \"n \\<in> nat\"\n    moreover from A1 have I: \"\\<forall>B\\<in>Pow(X). B \\<lesssim> 0 \\<longrightarrow> P(B)\"\n      using lepoll_0_is_0 by auto\n    moreover have \"\\<forall> k \\<in> nat. \n      (\\<forall>B \\<in> Pow(X). (B \\<lesssim> k \\<longrightarrow> P(B))) \\<longrightarrow> \n      (\\<forall>B \\<in> Pow(X). (B \\<lesssim> succ(k) \\<longrightarrow> P(B)))\"\n    proof -\n      { fix k assume A4: \"k \\<in> nat\"\n\tassume A5: \"\\<forall> B \\<in> Pow(X). (B \\<lesssim> k \\<longrightarrow> P(B))\"\n\tfix B assume A6: \"B \\<in> Pow(X)\"  \"B \\<lesssim> succ(k)\"\n\thave \"P(B)\"\n\tproof -\n\t  have \"B = 0 \\<longrightarrow> P(B)\"\n\t  proof -\n\t    { assume \"B = 0\"\n\t      then have \"B \\<lesssim> 0\" using lepoll_0_iff\n\t\tby simp\n\t      with I A6 have \"P(B)\" by simp \n\t    } thus \"B = 0 \\<longrightarrow> P(B)\" by simp\n\t  qed\n\t  moreover have \"B\\<noteq>0 \\<longrightarrow> P(B)\"\n\t  proof -\n\t    { assume \"B \\<noteq> 0\"\n\t      then obtain a where II: \"a\\<in>B\" by auto\n\t      let ?A = \"B - {a}\"\n\t      from A6 II have \"?A \\<subseteq> X\" and \"?A \\<lesssim> k\" \n\t\tusing Diff_sing_lepoll by auto\n\t      with A4 A5 have \"?A \\<in> FinPow(X)\" and \"P(?A)\" \n\t\tusing lepoll_nat_in_finpow finpow_decomp \n\t\tby auto\n\t      with A2 A6 II have \" P(?A \\<union> {a})\"\n\t\tby auto\n\t      moreover from II have \"?A \\<union> {a} = B\"\n\t\tby auto\n\t      ultimately have \"P(B)\" by simp \n\t    } thus \"B\\<noteq>0 \\<longrightarrow> P(B)\" by simp\n\t  qed\n\t  ultimately show \"P(B)\" by auto\n\tqed\n      } thus ?thesis by blast\n    qed\n    ultimately have \"\\<forall>B \\<in> Pow(X). (B \\<lesssim> n \\<longrightarrow> P(B))\"\n      by (rule ind_on_nat)\n  } then have \"\\<forall>n \\<in> nat. \\<forall>B \\<in> Pow(X). (B \\<lesssim> n \\<longrightarrow> P(B))\"\n    by auto\n  with A3 show \"P(B)\" using finpow_union_card_nat\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 328
    },
    "304": {
        "type": "lemma",
        "text": "text\\<open>A subset of a finite subset is a finite subset.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" and \"B \\<subseteq> A\"\n  ",
        "using": [
            "assms",
            "FinPow_def",
            "subset_Finite"
        ],
        "statement": "lemma subset_finpow: assumes \"A \\<in> FinPow(X)\" and \"B \\<subseteq> A\"\n  shows \"B \\<in> FinPow(X)\"\n  ",
        "proof": "using assms FinPow_def subset_Finite by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 329
    },
    "305": {
        "type": "lemma",
        "text": "text\\<open>If we subtract anything from a finite set, \n  the resulting set is finite.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" ",
        "using": [
            "assms",
            "subset_finpow"
        ],
        "statement": "lemma diff_finpow: \n  assumes \"A \\<in> FinPow(X)\" shows \"A-B \\<in> FinPow(X)\"\n  ",
        "proof": "using assms subset_finpow by blast\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 330
    },
    "306": {
        "type": "corollary",
        "text": "text\\<open>If we remove a point from a finites subset,\n  we get a finite subset.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\"\n  ",
        "using": [
            "assms",
            "diff_finpow"
        ],
        "statement": "corollary fin_rem_point_fin: assumes \"A \\<in> FinPow(X)\"\n  shows \"A - {a} \\<in> FinPow(X)\"\n  ",
        "proof": "using assms diff_finpow by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 331
    },
    "307": {
        "type": "lemma",
        "text": "text\\<open>Cardinality of a nonempty finite set is a successsor\n  of some natural number.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" and A2: \"A \\<noteq> 0\"\n  ",
        "using": [
            "FinPow_def",
            "fin_rem_point_fin",
            "card_fin_add_one",
            "card_fin_is_nat"
        ],
        "statement": "lemma card_non_empty_succ: \n  assumes A1: \"A \\<in> FinPow(X)\" and A2: \"A \\<noteq> 0\"\n  shows \"\\<exists>n \\<in> nat. |A| = succ(n)\"\n",
        "proof": "proof -\n  from A2 obtain a where \"a \\<in> A\" by auto\n  let ?B = \"A - {a}\"\n  from A1 \\<open>a \\<in> A\\<close> have \n    \"?B \\<in> FinPow(X)\" and \"a \\<in> X - ?B\"\n    using FinPow_def fin_rem_point_fin by auto\n  then have \"|?B \\<union> {a}| = succ( |?B| )\"\n    using card_fin_add_one by auto\n  moreover from \\<open>a \\<in> A\\<close> \\<open>?B \\<in> FinPow(X)\\<close> have \n    \"A = ?B \\<union> {a}\" and \"|?B| \\<in> nat\"\n    using card_fin_is_nat by auto\n  ultimately show \"\\<exists>n \\<in> nat. |A| = succ(n)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 332
    },
    "308": {
        "type": "theorem",
        "text": "text\\<open>Another variation on the induction theme:\n  If we can show something holds for the empty set and\n  if it holds for all finite sets with \n  at most $k$ elements then it holds for all \n  finite sets with at most $k+1$\n  elements, the it holds for all finite sets.\\<close>\n",
        "assumes": "assumes A1: \"P(0)\" and\n  A2: \"\\<forall>k\\<in>nat.\n  (\\<forall>A \\<in> FinPow(X). A \\<lesssim> k \\<longrightarrow> P(A)) \\<longrightarrow>\n  (\\<forall>A \\<in> FinPow(X). A \\<lesssim> succ(k) \\<longrightarrow> P(A))\"\n  and A3: \"A \\<in>  FinPow(X)\" ",
        "using": [
            "card_fin_is_nat",
            "eqpoll_imp_lepoll",
            "lepoll_0_is_0"
        ],
        "statement": "theorem FinPow_card_ind: assumes A1: \"P(0)\" and\n  A2: \"\\<forall>k\\<in>nat.\n  (\\<forall>A \\<in> FinPow(X). A \\<lesssim> k \\<longrightarrow> P(A)) \\<longrightarrow>\n  (\\<forall>A \\<in> FinPow(X). A \\<lesssim> succ(k) \\<longrightarrow> P(A))\"\n  and A3: \"A \\<in>  FinPow(X)\" shows \"P(A)\"\n",
        "proof": "proof -\n  from A3 have \"|A| \\<in> nat\" and \"A \\<in>  FinPow(X)\" and \"A \\<lesssim> |A|\"\n    using card_fin_is_nat eqpoll_imp_lepoll by auto\n  moreover have \"\\<forall>n \\<in> nat. (\\<forall>A \\<in> FinPow(X).\n    A \\<lesssim> n \\<longrightarrow> P(A))\"\n  proof\n    fix n assume \"n \\<in> nat\"\n    moreover from A1 have \"\\<forall>A \\<in> FinPow(X). A \\<lesssim> 0 \\<longrightarrow> P(A)\"\n      using lepoll_0_is_0 by auto\n    moreover note A2\n    ultimately show\n      \"\\<forall>A \\<in> FinPow(X). A \\<lesssim> n \\<longrightarrow> P(A)\"\n      by (rule ind_on_nat)\n  qed\n  ultimately show \"P(A)\" by simp\nqed  \n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 334
    },
    "309": {
        "type": "lemma",
        "text": "text\\<open>Another type of induction (or, maybe recursion).\n  In the induction step  we try to find a point in the set that\n  if we remove it, the fact that the property holds for the \n  smaller set implies that the property holds for the whole set. \n\\<close>\n",
        "assumes": "assumes A1: \"P(0)\" and \n  A2: \"\\<forall> A \\<in> FinPow(X). A \\<noteq> 0 \\<longrightarrow> (\\<exists>a\\<in>A. P(A-{a}) \\<longrightarrow> P(A))\"\n  and A3: \"B \\<in>  FinPow(X)\"\n  ",
        "using": [
            "Diff_sing_lepoll",
            "fin_rem_point_fin"
        ],
        "statement": "lemma FinPow_ind_rem_one: assumes A1: \"P(0)\" and \n  A2: \"\\<forall> A \\<in> FinPow(X). A \\<noteq> 0 \\<longrightarrow> (\\<exists>a\\<in>A. P(A-{a}) \\<longrightarrow> P(A))\"\n  and A3: \"B \\<in>  FinPow(X)\"\n  shows \"P(B)\"\n",
        "proof": "proof -\n  note A1\n  moreover have \"\\<forall>k\\<in>nat.\n  (\\<forall>B \\<in> FinPow(X). B \\<lesssim> k \\<longrightarrow> P(B)) \\<longrightarrow>\n  (\\<forall>C \\<in> FinPow(X). C \\<lesssim> succ(k) \\<longrightarrow> P(C))\"\n  proof -\n    { fix k assume \"k \\<in> nat\"\n      assume A4: \"\\<forall>B \\<in> FinPow(X). B \\<lesssim> k \\<longrightarrow> P(B)\"\n      have \"\\<forall>C \\<in> FinPow(X). C \\<lesssim> succ(k) \\<longrightarrow> P(C)\"\n      proof -\n\t{ fix C assume \"C \\<in> FinPow(X)\"\n\t  assume \"C \\<lesssim> succ(k)\"\n\t  note A1\n\t  moreover\n\t  { assume \"C \\<noteq> 0\"\n\t    with A2 \\<open>C \\<in> FinPow(X)\\<close> obtain a where\n\t      \"a\\<in>C\" and \"P(C-{a}) \\<longrightarrow> P(C)\"\n\t      by auto\n\t    with A4 \\<open>C \\<in> FinPow(X)\\<close> \\<open>C \\<lesssim> succ(k)\\<close>\n\t    have \"P(C)\" using Diff_sing_lepoll fin_rem_point_fin\n\t      by simp }\n\t  ultimately have \"P(C)\" by auto\n\t} thus ?thesis by simp\n      qed\n    } thus ?thesis by blast\n  qed\n  moreover note A3\n  ultimately show \"P(B)\" by (rule FinPow_card_ind)\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 335
    },
    "310": {
        "type": "lemma",
        "text": "text\\<open>Yet another induction theorem. This is similar, but \n  slightly more complicated than \\<open>FinPow_ind_rem_one\\<close>.\n  The difference is in the treatment of the empty set to allow \n  to show properties that are not true for empty set.\n\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>A \\<in> FinPow(X). \n  A = 0 \\<or> (\\<exists>a\\<in>A. A = {a} \\<or> P(A-{a}) \\<longrightarrow> P(A))\"\n  and A2: \"A \\<in>  FinPow(X)\" and A3: \"A\\<noteq>0\"\n  ",
        "using": [
            "Diff_sing_lepoll",
            "fin_rem_point_fin"
        ],
        "statement": "lemma FinPow_rem_ind: assumes A1: \"\\<forall>A \\<in> FinPow(X). \n  A = 0 \\<or> (\\<exists>a\\<in>A. A = {a} \\<or> P(A-{a}) \\<longrightarrow> P(A))\"\n  and A2: \"A \\<in>  FinPow(X)\" and A3: \"A\\<noteq>0\"\n  shows \"P(A)\"\n",
        "proof": "proof -\n  have \"0 = 0 \\<or> P(0)\" by simp\n  moreover have\n    \"\\<forall>k\\<in>nat.\n    (\\<forall>B \\<in> FinPow(X). B \\<lesssim> k \\<longrightarrow> (B=0 \\<or> P(B))) \\<longrightarrow>\n    (\\<forall>A \\<in> FinPow(X). A \\<lesssim> succ(k) \\<longrightarrow> (A=0 \\<or> P(A)))\"\n  proof -\n    { fix k assume \"k \\<in> nat\"\n      assume A4: \"\\<forall>B \\<in> FinPow(X). B \\<lesssim> k \\<longrightarrow> (B=0 \\<or> P(B))\"\n      have \"\\<forall>A \\<in> FinPow(X). A \\<lesssim> succ(k) \\<longrightarrow> (A=0 \\<or> P(A))\"\n      proof -\n\t{ fix A assume \"A \\<in> FinPow(X)\"\n\t  assume \"A \\<lesssim> succ(k)\"  \"A\\<noteq>0\"\n\t  from A1 \\<open>A \\<in> FinPow(X)\\<close> \\<open>A\\<noteq>0\\<close> obtain a \n\t    where \"a\\<in>A\" and \"A = {a} \\<or> P(A-{a}) \\<longrightarrow> P(A)\"\n\t    by auto\n\t  let ?B = \"A-{a}\"\n\t  from A4 \\<open>A \\<in> FinPow(X)\\<close> \\<open>A \\<lesssim> succ(k)\\<close> \\<open>a\\<in>A\\<close>\n\t  have \"?B = 0 \\<or> P(?B)\" \n\t    using Diff_sing_lepoll fin_rem_point_fin\n\t    by simp\n\t  with \\<open>a\\<in>A\\<close> \\<open>A = {a} \\<or> P(A-{a}) \\<longrightarrow> P(A)\\<close>\n\t  have \"P(A)\" by auto\n\t} thus  ?thesis by auto\n      qed\t  \n    } thus ?thesis by blast\n  qed\n  moreover note A2\n  ultimately have \"A=0 \\<or> P(A)\" by (rule FinPow_card_ind)\n  with A3 show \"P(A)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 336
    },
    "311": {
        "type": "lemma",
        "text": "text\\<open>If a family of sets is closed with respect to taking intersections\n  of two sets then it is closed with respect to taking intersections \n  of any nonempty finite collection.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>V\\<in>T. \\<forall>W\\<in>T. V \\<inter> W \\<in> T\" and\n  A2: \"N \\<noteq> 0\" and A3: \"N \\<in> FinPow(T)\"\n  ",
        "using": [],
        "statement": "lemma inter_two_inter_fin: \n  assumes A1: \"\\<forall>V\\<in>T. \\<forall>W\\<in>T. V \\<inter> W \\<in> T\" and\n  A2: \"N \\<noteq> 0\" and A3: \"N \\<in> FinPow(T)\"\n  shows \"(\\<Inter>N \\<in> T)\"\n",
        "proof": "proof -\n  have \"0 = 0 \\<or> (\\<Inter>0 \\<in> T)\" by simp\n  moreover have \"\\<forall>M \\<in> FinPow(T). (M = 0 \\<or> \\<Inter>M \\<in> T) \\<longrightarrow> \n    (\\<forall>W \\<in> T. M\\<union>{W} = 0 \\<or> \\<Inter>(M \\<union> {W}) \\<in> T)\"\n  proof -\n    { fix M assume \"M \\<in> FinPow(T)\"\n      assume A4: \"M = 0 \\<or> \\<Inter>M \\<in> T\"\n      { assume \"M = 0\"\n\thence \"\\<forall>W \\<in> T. M\\<union>{W} = 0 \\<or> \\<Inter>(M \\<union> {W}) \\<in> T\"\n\t  by auto }\n      moreover\n      { assume \"M \\<noteq> 0\" \n\twith A4 have \"\\<Inter>M \\<in> T\" by simp\n\t{ fix W assume \"W \\<in> T\"\n\t  from \\<open>M \\<noteq> 0\\<close> have \"\\<Inter>(M \\<union> {W}) = (\\<Inter>M) \\<inter> W\" \n\t    by auto\n\t  with A1 \\<open>\\<Inter>M \\<in> T\\<close> \\<open>W \\<in> T\\<close> have \"\\<Inter>(M \\<union> {W}) \\<in> T\"\n\t    by simp\n\t} hence \"\\<forall>W \\<in> T. M\\<union>{W} = 0 \\<or> \\<Inter>(M \\<union> {W}) \\<in> T\"\n\t  by simp }\n      ultimately have \"\\<forall>W \\<in> T. M\\<union>{W} = 0 \\<or> \\<Inter>(M \\<union> {W}) \\<in> T\"\n\tby blast\n    } thus ?thesis by simp\n  qed\n  moreover note \\<open>N \\<in> FinPow(T)\\<close>\n  ultimately have \"N = 0 \\<or> (\\<Inter>N \\<in> T)\"\n    by (rule FinPow_induct)\n  with A2 show \"(\\<Inter>N \\<in> T)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 337
    },
    "312": {
        "type": "lemma",
        "text": "text\\<open>If a family of sets contains the empty set and\n  is closed with respect to taking unions\n  of two sets then it is closed with respect to taking unions \n  of any finite collection.\\<close>\n",
        "assumes": "assumes A1: \"0 \\<in> C\" and A2: \"\\<forall>A\\<in>C. \\<forall>B\\<in>C. A\\<union>B \\<in> C\" and \n  A3: \"N \\<in> FinPow(C)\"\n  ",
        "using": [],
        "statement": "lemma union_two_union_fin:\n  assumes A1: \"0 \\<in> C\" and A2: \"\\<forall>A\\<in>C. \\<forall>B\\<in>C. A\\<union>B \\<in> C\" and \n  A3: \"N \\<in> FinPow(C)\"\n  shows \"\\<Union>N \\<in> C\"\n",
        "proof": "proof -\n  from \\<open>0 \\<in> C\\<close> have \"\\<Union>0 \\<in> C\" by simp\n  moreover have \"\\<forall>M \\<in> FinPow(C). \\<Union>M \\<in> C \\<longrightarrow> (\\<forall>A\\<in>C. \\<Union>(M \\<union> {A}) \\<in> C)\"\n  proof -\n    { fix M assume \"M \\<in> FinPow(C)\"\n      assume \"\\<Union>M \\<in> C\"\n      fix A assume \"A\\<in>C\"\n      have \"\\<Union>(M \\<union> {A}) = (\\<Union>M) \\<union> A\" by auto\n      with A2 \\<open>\\<Union>M \\<in> C\\<close>  \\<open>A\\<in>C\\<close> have  \"\\<Union>(M \\<union> {A}) \\<in> C\"\n\tby simp\n    } thus ?thesis by simp\n  qed\n  moreover note \\<open>N \\<in> FinPow(C)\\<close>\n  ultimately show \"\\<Union>N \\<in> C\" by (rule FinPow_induct)\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 338
    },
    "313": {
        "type": "lemma",
        "text": "text\\<open>Empty set is in finite power set.\\<close>\n",
        "assumes": "",
        "using": [
            "FinPow_def"
        ],
        "statement": "lemma empty_in_finpow: shows \"0 \\<in> FinPow(X)\"\n  ",
        "proof": "using FinPow_def by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 339
    },
    "314": {
        "type": "lemma",
        "text": "text\\<open>Singleton is in the finite powerset.\\<close>\n",
        "assumes": "assumes \"x \\<in> X\"\n  ",
        "using": [
            "assms",
            "FinPow_def"
        ],
        "statement": "lemma singleton_in_finpow: assumes \"x \\<in> X\"\n  shows \"{x} \\<in> FinPow(X)\" ",
        "proof": "using assms FinPow_def by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 340
    },
    "315": {
        "type": "lemma",
        "text": "text\\<open>Union of two finite subsets is a finite subset.\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" and \"B \\<in> FinPow(X)\"\n  ",
        "using": [
            "assms",
            "FinPow_def"
        ],
        "statement": "lemma union_finpow: assumes \"A \\<in> FinPow(X)\" and \"B \\<in> FinPow(X)\"\n  shows \"A \\<union> B \\<in> FinPow(X)\"\n  ",
        "proof": "using assms FinPow_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 341
    },
    "316": {
        "type": "lemma",
        "text": "text\\<open>Union of finite number of finite sets is finite.\\<close>\n",
        "assumes": "assumes \"M \\<in> FinPow(FinPow(X))\"\n  ",
        "using": [
            "assms",
            "empty_in_finpow",
            "union_finpow",
            "union_two_union_fin"
        ],
        "statement": "lemma fin_union_finpow: assumes \"M \\<in> FinPow(FinPow(X))\"\n  shows \"\\<Union>M \\<in> FinPow(X)\"\n  ",
        "proof": "using assms empty_in_finpow union_finpow union_two_union_fin\n  by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 342
    },
    "317": {
        "type": "lemma",
        "text": "text\\<open>If a set is finite after removing one element, then it is finite.\\<close>\n",
        "assumes": "assumes A1: \"x \\<in> X\" and A2: \"A - {x} \\<in> FinPow(X)\"\n  ",
        "using": [
            "singleton_in_finpow",
            "union_finpow",
            "FinPow_def",
            "subset_Finite"
        ],
        "statement": "lemma rem_point_fin_fin: \n  assumes A1: \"x \\<in> X\" and A2: \"A - {x} \\<in> FinPow(X)\"\n  shows \"A \\<in> FinPow(X)\"\n",
        "proof": "proof -\n  from assms have \"(A - {x}) \\<union> {x} \\<in> FinPow(X)\"\n    using singleton_in_finpow union_finpow by simp\n  moreover have \"A \\<subseteq> (A - {x}) \\<union> {x}\" by auto\n  ultimately show \"A \\<in> FinPow(X)\" \n    using FinPow_def subset_Finite by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 343
    },
    "318": {
        "type": "lemma",
        "text": "text\\<open>An image of a finite set is finite.\\<close>\n",
        "assumes": "assumes \"\\<forall>V\\<in>B. K(V)\\<in>C\" and \"N \\<in> FinPow(B)\"\n  ",
        "using": [
            "FinPow_def",
            "singleton_in_finpow",
            "union_finpow"
        ],
        "statement": "lemma fin_image_fin: assumes \"\\<forall>V\\<in>B. K(V)\\<in>C\" and \"N \\<in> FinPow(B)\"\n  shows \"{K(V). V\\<in>N} \\<in> FinPow(C)\"\n",
        "proof": "proof -\n  have \"{K(V). V\\<in>0} \\<in> FinPow(C)\" using FinPow_def\n    by auto\n  moreover have \"\\<forall>A \\<in> FinPow(B). \n    {K(V). V\\<in>A} \\<in> FinPow(C) \\<longrightarrow> (\\<forall>a\\<in>B. {K(V). V \\<in> (A \\<union> {a})} \\<in> FinPow(C))\"\n  proof -\n    { fix A assume \"A \\<in> FinPow(B)\"\n      assume  \"{K(V). V\\<in>A} \\<in> FinPow(C)\"\n      fix a assume \"a\\<in>B\"\n      have  \"{K(V). V \\<in> (A \\<union> {a})} \\<in> FinPow(C)\"\n      proof -\n\thave \"{K(V). V \\<in> (A \\<union> {a})} = {K(V). V\\<in>A} \\<union> {K(a)}\"\n\t  by auto\n\tmoreover note \\<open>{K(V). V\\<in>A} \\<in> FinPow(C)\\<close>\n\tmoreover from \\<open>\\<forall>V\\<in>B. K(V) \\<in> C\\<close>  \\<open>a\\<in>B\\<close> have \"{K(a)} \\<in>  FinPow(C)\"\n\t  using singleton_in_finpow by simp\n\tultimately show ?thesis using union_finpow by simp\n      qed\n    } thus ?thesis by simp\n  qed\n  moreover note \\<open>N \\<in> FinPow(B)\\<close>\n  ultimately show \"{K(V). V\\<in>N} \\<in> FinPow(C)\"\n    by (rule FinPow_induct)\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 344
    },
    "319": {
        "type": "lemma",
        "text": "text\\<open>Union of a finite indexed family of finite sets is finite.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"\\<forall>k \\<in> n. N(k) \\<in> FinPow(X)\"\n  ",
        "using": [
            "nat_finpow_nat",
            "fin_finpow_self",
            "fin_union_finpow"
        ],
        "statement": "lemma union_fin_list_fin: \n  assumes A1: \"n \\<in> nat\" and A2: \"\\<forall>k \\<in> n. N(k) \\<in> FinPow(X)\"\n  shows \n  \"{N(k). k \\<in> n} \\<in>  FinPow(FinPow(X))\" and \"(\\<Union>k \\<in> n. N(k)) \\<in> FinPow(X)\"\n",
        "proof": "proof -\n  from A1 have \"n \\<in> FinPow(n)\" \n    using nat_finpow_nat fin_finpow_self by auto\n  with A2 show \"{N(k). k \\<in> n} \\<in>  FinPow(FinPow(X))\"\n    by (rule fin_image_fin)\n  then show \"(\\<Union>k \\<in> n. N(k)) \\<in> FinPow(X)\"\n    using fin_union_finpow by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 345
    },
    "320": {
        "type": "lemma",
        "text": "text\\<open>Finite set has a maximum - induction step.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<in>Fin(X)\" and A4: \"x\\<in>X\" and A5: \"A=0 \\<or> HasAmaximum(r,A)\"\n  ",
        "using": [
            "total_is_refl",
            "Order_ZF_4_L8",
            "FinD",
            "Order_ZF_4_L9"
        ],
        "statement": "lemma Finite_ZF_1_1_L1: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<in>Fin(X)\" and A4: \"x\\<in>X\" and A5: \"A=0 \\<or> HasAmaximum(r,A)\"\n  shows \"A\\<union>{x} = 0 \\<or> HasAmaximum(r,A\\<union>{x})\"\n",
        "proof": "proof -\n  { assume \"A=0\" then have T1: \"A\\<union>{x} = {x}\" by simp\n    from A1 have \"refl(X,r)\" using total_is_refl by simp\n    with T1 A4 have \"A\\<union>{x} = 0 \\<or> HasAmaximum(r,A\\<union>{x})\" \n      using Order_ZF_4_L8 by simp }\n  moreover \n  { assume \"A\\<noteq>0\" \n    with A1 A2 A3 A4 A5 have \"A\\<union>{x} = 0 \\<or> HasAmaximum(r,A\\<union>{x})\" \n      using FinD Order_ZF_4_L9 by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 346
    },
    "321": {
        "type": "theorem",
        "text": "text\\<open>For total and transitive relations finite set has a maximum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"B\\<in>Fin(X)\"\n  ",
        "using": [
            "Finite_ZF_1_1_L1"
        ],
        "statement": "theorem Finite_ZF_1_1_T1A: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"B\\<in>Fin(X)\"\n  shows \"B=0 \\<or> HasAmaximum(r,B)\"\n",
        "proof": "proof -\n  have \"0=0 \\<or> HasAmaximum(r,0)\" by simp\n  moreover note A3\n  moreover from A1 A2 have \"\\<forall>A\\<in>Fin(X). \\<forall>x\\<in>X. \n    x\\<notin>A \\<and> (A=0 \\<or> HasAmaximum(r,A)) \\<longrightarrow> (A\\<union>{x}=0 \\<or> HasAmaximum(r,A\\<union>{x}))\"\n    using Finite_ZF_1_1_L1 by simp\n  ultimately show  \"B=0 \\<or> HasAmaximum(r,B)\" by (rule Finite1_L16B)\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 347
    },
    "322": {
        "type": "lemma",
        "text": "text\\<open>Finite set has a minimum - induction step.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<in>Fin(X)\" and A4: \"x\\<in>X\" and A5: \"A=0 \\<or> HasAminimum(r,A)\"\n  ",
        "using": [
            "total_is_refl",
            "Order_ZF_4_L8",
            "FinD",
            "Order_ZF_4_L10"
        ],
        "statement": "lemma Finite_ZF_1_1_L2: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<in>Fin(X)\" and A4: \"x\\<in>X\" and A5: \"A=0 \\<or> HasAminimum(r,A)\"\n  shows \"A\\<union>{x} = 0 \\<or> HasAminimum(r,A\\<union>{x})\"\n",
        "proof": "proof -\n  { assume \"A=0\" then have T1: \"A\\<union>{x} = {x}\" by simp\n    from A1 have \"refl(X,r)\" using total_is_refl by simp\n    with T1 A4 have \"A\\<union>{x} = 0 \\<or> HasAminimum(r,A\\<union>{x})\"  \n      using Order_ZF_4_L8 by simp }\n  moreover\n  { assume \"A\\<noteq>0\" \n    with A1 A2 A3 A4 A5 have \"A\\<union>{x} = 0 \\<or> HasAminimum(r,A\\<union>{x})\" \n      using FinD Order_ZF_4_L10 by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 348
    },
    "323": {
        "type": "theorem",
        "text": "text\\<open>For total and transitive relations finite set has a minimum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"B \\<in> Fin(X)\"\n  ",
        "using": [
            "Finite_ZF_1_1_L2"
        ],
        "statement": "theorem Finite_ZF_1_1_T1B: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"B \\<in> Fin(X)\"\n  shows \"B=0 \\<or> HasAminimum(r,B)\"\n",
        "proof": "proof -\n  have \"0=0 \\<or> HasAminimum(r,0)\" by simp\n  moreover note A3\n  moreover from A1 A2 have \"\\<forall>A\\<in>Fin(X). \\<forall>x\\<in>X. \n    x\\<notin>A \\<and> (A=0 \\<or> HasAminimum(r,A)) \\<longrightarrow> (A\\<union>{x}=0 \\<or> HasAminimum(r,A\\<union>{x}))\"\n    using Finite_ZF_1_1_L2 by simp\n  ultimately show  \"B=0 \\<or> HasAminimum(r,B)\" by (rule Finite1_L16B)\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 349
    },
    "324": {
        "type": "theorem",
        "text": "text\\<open>For transitive and total relations finite sets are bounded.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"  \n  and A3: \"B\\<in>Fin(X)\"\n  ",
        "using": [
            "Finite_ZF_1_1_T1A",
            "Finite_ZF_1_1_T1B",
            "Order_ZF_4_L7",
            "Order_ZF_4_L8A",
            "IsBounded_def",
            "IsBoundedBelow_def",
            "IsBoundedAbove_def"
        ],
        "statement": "theorem Finite_ZF_1_T1: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"  \n  and A3: \"B\\<in>Fin(X)\"\n  shows \"IsBounded(B,r)\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \"B=0 \\<or> HasAminimum(r,B)\" \"B=0 \\<or> HasAmaximum(r,B)\"\n    using Finite_ZF_1_1_T1A Finite_ZF_1_1_T1B by auto\n  then have \n    \"B = 0 \\<or> IsBoundedBelow(B,r)\" \"B = 0 \\<or> IsBoundedAbove(B,r)\"\n    using Order_ZF_4_L7 Order_ZF_4_L8A by auto\n  then show \"IsBounded(B,r)\" using \n    IsBounded_def IsBoundedBelow_def IsBoundedAbove_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 350
    },
    "325": {
        "type": "theorem",
        "text": "text\\<open>For linearly ordered finite sets maximum and minimum have desired \n  properties. The reason we need linear order is that we need the order\n  to be total and transitive for the finite sets to have a maximum and minimum\n  and then we also need antisymmetry for the maximum and minimum to be unique.\n\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and A2: \"A \\<in> Fin(X)\" and A3: \"A\\<noteq>0\"\n  ",
        "using": [
            "IsLinOrder_def",
            "Finite_ZF_1_1_T1A",
            "Finite_ZF_1_1_T1B",
            "Order_ZF_4_L3",
            "Order_ZF_4_L4"
        ],
        "statement": "theorem Finite_ZF_1_T2:\n  assumes A1: \"IsLinOrder(X,r)\" and A2: \"A \\<in> Fin(X)\" and A3: \"A\\<noteq>0\"\n  shows \n  \"Maximum(r,A) \\<in> A\" \n  \"Minimum(r,A) \\<in> A\"\n  \"\\<forall>x\\<in>A. \\<langle>x,Maximum(r,A)\\<rangle> \\<in> r\" \n  \"\\<forall>x\\<in>A. \\<langle>Minimum(r,A),x\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A1 have T1: \"r {is total on} X\" \"trans(r)\" \"antisym(r)\"\n    using IsLinOrder_def by auto\n  moreover from T1 A2 A3 have \"HasAmaximum(r,A)\" \n    using Finite_ZF_1_1_T1A by auto\n  moreover from T1 A2 A3 have \"HasAminimum(r,A)\"\n    using Finite_ZF_1_1_T1B by auto\n  ultimately show \n    \"Maximum(r,A) \\<in> A\" \n    \"Minimum(r,A) \\<in> A\"\n    \"\\<forall>x\\<in>A. \\<langle>x,Maximum(r,A)\\<rangle> \\<in> r\" \"\\<forall>x\\<in>A. \\<langle>Minimum(r,A),x\\<rangle> \\<in> r\"\n    using Order_ZF_4_L3 Order_ZF_4_L4 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 351
    },
    "326": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>Finite_ZF_1_T2\\<close> when the set has three\n  elements.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and A2: \"a\\<in>X\"  \"b\\<in>X\"  \"c\\<in>X\"\n  ",
        "using": [],
        "statement": "corollary Finite_ZF_1_L2A: \n  assumes A1: \"IsLinOrder(X,r)\" and A2: \"a\\<in>X\"  \"b\\<in>X\"  \"c\\<in>X\"\n  shows \n  \"Maximum(r,{a,b,c}) \\<in> {a,b,c}\" \n  \"Minimum(r,{a,b,c}) \\<in> {a,b,c}\"\n  \"Maximum(r,{a,b,c}) \\<in> X\" \n  \"Minimum(r,{a,b,c}) \\<in> X\"\n  \"\\<langle>a,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n  \"\\<langle>b,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n  \"\\<langle>c,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A2 have I: \"{a,b,c} \\<in> Fin(X)\"  \"{a,b,c} \\<noteq> 0\"\n    by auto\n  with A1 show II: \"Maximum(r,{a,b,c}) \\<in> {a,b,c}\" \n    by (rule Finite_ZF_1_T2)\n  moreover from A1 I show III: \"Minimum(r,{a,b,c}) \\<in> {a,b,c}\"\n    by (rule Finite_ZF_1_T2)\n  moreover from A2 have \"{a,b,c} \\<subseteq> X\"\n    by auto\n  ultimately show  \n    \"Maximum(r,{a,b,c}) \\<in> X\" \n    \"Minimum(r,{a,b,c}) \\<in> X\"\n    by auto\n  from A1 I have \"\\<forall>x\\<in>{a,b,c}. \\<langle>x,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n    by (rule Finite_ZF_1_T2)\n  then show \n    \"\\<langle>a,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n    \"\\<langle>b,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n    \"\\<langle>c,Maximum(r,{a,b,c})\\<rangle> \\<in> r\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 352
    },
    "327": {
        "type": "lemma",
        "text": "text\\<open>If for every element of $X$ we can find one in $A$ \n  that is greater, then the $A$ can not be finite. Works for relations\n  that are total, transitive and antisymmetric.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" \n  and A2: \"trans(r)\" and A3: \"antisym(r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\" and A5: \"X\\<noteq>0\" \n  and A6: \"\\<forall>x\\<in>X. \\<exists>a\\<in>A. x\\<noteq>a \\<and> \\<langle>x,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "Order_ZF_3_L14",
            "IsBounded_def",
            "Finite_ZF_1_T1"
        ],
        "statement": "lemma Finite_ZF_1_1_L3: \n  assumes A1: \"r {is total on} X\" \n  and A2: \"trans(r)\" and A3: \"antisym(r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\" and A5: \"X\\<noteq>0\" \n  and A6: \"\\<forall>x\\<in>X. \\<exists>a\\<in>A. x\\<noteq>a \\<and> \\<langle>x,a\\<rangle> \\<in> r\"\n  shows \"A \\<notin> Fin(X)\"\n",
        "proof": "proof -\n  from assms have \"\\<not>IsBounded(A,r)\"\n    using Order_ZF_3_L14 IsBounded_def\n    by simp\n  with A1 A2 show \"A \\<notin> Fin(X)\"\n    using Finite_ZF_1_T1 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite1",
            "IsarMathLib.Order_ZF_1a"
        ],
        "source": "IsarMathLib/Finite_ZF_1.thy",
        "id": 353
    },
    "328": {
        "type": "lemma",
        "text": "text\\<open>The next lemma serves as a workaround to problems with applying \n  the definition of transitivity (of a relation) in our coding style \n  (any attempt to do\n  something like \\<open>using trans_def\\<close> puts Isabelle in an \n  infinite loop).\\<close>\n",
        "assumes": "assumes \n  A1: \"\\<forall> x y z. \\<langle>x, y\\<rangle> \\<in> r \\<and> \\<langle>y, z\\<rangle> \\<in> r \\<longrightarrow> \\<langle>x, z\\<rangle> \\<in> r\"\n  ",
        "using": [
            "imp_conj"
        ],
        "statement": "lemma Fol1_L2: assumes \n  A1: \"\\<forall> x y z. \\<langle>x, y\\<rangle> \\<in> r \\<and> \\<langle>y, z\\<rangle> \\<in> r \\<longrightarrow> \\<langle>x, z\\<rangle> \\<in> r\"\n  shows \"trans(r)\"\n",
        "proof": "proof -\n  from A1 have\n    \"\\<forall> x y z. \\<langle>x, y\\<rangle> \\<in> r \\<longrightarrow> \\<langle>y, z\\<rangle> \\<in> r \\<longrightarrow> \\<langle>x, z\\<rangle> \\<in> r\"\n    using imp_conj by blast\n  then show ?thesis unfolding trans_def by blast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 354
    },
    "329": {
        "type": "lemma",
        "text": "text\\<open>There is a problem with application of the definition of asymetry for\n  relations. The next lemma is a workaround.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"\\<langle> a,b\\<rangle> \\<in> r\"   \"\\<langle> b,a\\<rangle> \\<in> r\"  \n  ",
        "using": [
            "imp_conj"
        ],
        "statement": "lemma Fol1_L4: \n  assumes A1: \"antisym(r)\" and A2: \"\\<langle> a,b\\<rangle> \\<in> r\"   \"\\<langle> b,a\\<rangle> \\<in> r\"  \n  shows \"a=b\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall> x y. \\<langle> x,y\\<rangle> \\<in> r \\<longrightarrow> \\<langle> y,x\\<rangle> \\<in> r \\<longrightarrow> x=y\"\n    unfolding antisym_def by blast\n  with A2 show \"a=b\" using imp_conj by fast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 356
    },
    "330": {
        "type": "definition",
        "text": "text\\<open>The definition below implements a common idiom that states that \n  (perhaps under some assumptions) exactly one of given three statements \n  is true.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Exactly_1_of_3_holds(p,q,r) \\<equiv> \n  (p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n",
        "proof": "",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 357
    },
    "331": {
        "type": "lemma",
        "text": "text\\<open>The next lemma allows to prove statements of the form \n  \\<open>Exactly_1_of_3_holds(p,q,r)\\<close>.\\<close>\n",
        "assumes": "assumes \"p\\<or>q\\<or>r\"\n  and \"p \\<longrightarrow> \\<not>q \\<and> \\<not>r\"\n  and \"q \\<longrightarrow> \\<not>p \\<and> \\<not>r\"\n  and \"r \\<longrightarrow> \\<not>p \\<and> \\<not>q\"\n  ",
        "using": [],
        "statement": "lemma Fol1_L5:\n  assumes \"p\\<or>q\\<or>r\"\n  and \"p \\<longrightarrow> \\<not>q \\<and> \\<not>r\"\n  and \"q \\<longrightarrow> \\<not>p \\<and> \\<not>r\"\n  and \"r \\<longrightarrow> \\<not>p \\<and> \\<not>q\"\n  shows \"Exactly_1_of_3_holds(p,q,r)\"\n",
        "proof": "proof -\n  from assms have\n    \"(p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n    by blast\n  then show \"Exactly_1_of_3_holds (p,q,r)\"\n    unfolding Exactly_1_of_3_holds_def by fast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 358
    },
    "332": {
        "type": "lemma",
        "text": "text\\<open>If exactly one of $p,q,r$ holds and $q$ is true, then \n  $r$ can not be true.\\<close>\n",
        "assumes": "assumes A1: \"q\" and A2: \"Exactly_1_of_3_holds(p,q,r)\"\n  ",
        "using": [],
        "statement": "lemma Fol1_L7:\n  assumes A1: \"q\" and A2: \"Exactly_1_of_3_holds(p,q,r)\"\n  shows \"\\<not>r\"\n",
        "proof": "proof -\n   from A2 have  \n    \"(p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n    unfolding Exactly_1_of_3_holds_def by fast\n  with A1 show \"\\<not>r\" by blast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 360
    },
    "333": {
        "type": "lemma",
        "text": "text\\<open>The next lemma demonstrates an elegant form of the \n  \\<open>Exactly_1_of_3_holds(p,q,r)\\<close> predicate.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma Fol1_L8: \n  shows \"Exactly_1_of_3_holds(p,q,r) \\<longleftrightarrow> (p\\<longleftrightarrow>q\\<longleftrightarrow>r) \\<and> \\<not>(p\\<and>q\\<and>r)\"\n",
        "proof": "proof\n  assume \"Exactly_1_of_3_holds(p,q,r)\"\n  then have \n    \"(p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n    unfolding Exactly_1_of_3_holds_def by fast\n  thus \"(p\\<longleftrightarrow>q\\<longleftrightarrow>r) \\<and> \\<not>(p\\<and>q\\<and>r)\" by blast\nnext assume \"(p\\<longleftrightarrow>q\\<longleftrightarrow>r) \\<and> \\<not>(p\\<and>q\\<and>r)\" \n  hence\n    \"(p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n    by auto\n  then show \"Exactly_1_of_3_holds(p,q,r)\"\n    unfolding Exactly_1_of_3_holds_def by fast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 361
    },
    "334": {
        "type": "lemma",
        "text": "text\\<open>A property of the \\<open>Exactly_1_of_3_holds\\<close> predicate.\\<close>\n",
        "assumes": "assumes A1: \"Exactly_1_of_3_holds(p,q,r)\"\n  ",
        "using": [],
        "statement": "lemma Fol1_L8A: assumes A1: \"Exactly_1_of_3_holds(p,q,r)\"\n  shows \"p \\<longleftrightarrow> \\<not>(q \\<or> r)\"\n",
        "proof": "proof -\n  from A1 have \"(p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n    unfolding Exactly_1_of_3_holds_def by fast\n  then show \"p \\<longleftrightarrow> \\<not>(q \\<or> r)\" by blast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 362
    },
    "335": {
        "type": "definition",
        "text": "text\\<open>Exclusive or definition. There is one also defined in the standard \n  Isabelle, denoted \\<open>xor\\<close>, but it relates to boolean values, \n  which are sets. Here we define a logical functor.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  Xor (infixl \"Xor\" 66) where\n  \"p Xor q \\<equiv> (p\\<or>q) \\<and> \\<not>(p \\<and> q)\"\n",
        "proof": "",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 363
    },
    "336": {
        "type": "lemma",
        "text": "text\\<open>The \"exclusive or\" is the same as negation of equivalence.\\<close>\n",
        "assumes": "",
        "using": [
            "Xor_def"
        ],
        "statement": "lemma Fol1_L9: shows \"p Xor q \\<longleftrightarrow> \\<not>(p\\<longleftrightarrow>q)\"\n  ",
        "proof": "using Xor_def by auto\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 364
    },
    "337": {
        "type": "lemma",
        "text": "text\\<open>Equivalence relations are symmetric.\\<close>\n",
        "assumes": "assumes A1: \"equiv(X,r)\" and A2: \"\\<langle>x,y\\<rangle> \\<in> r\"\n  ",
        "using": [
            "equiv_def"
        ],
        "statement": "lemma equiv_is_sym: assumes A1: \"equiv(X,r)\" and A2: \"\\<langle>x,y\\<rangle> \\<in> r\"\n  shows  \"\\<langle>y,x\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A1 have \"sym(r)\" using equiv_def by simp\n  then have \"\\<forall>x y. \\<langle>x,y\\<rangle> \\<in> r \\<longrightarrow> \\<langle>y,x\\<rangle> \\<in> r\"\n    unfolding sym_def by fast\n  with A2 show \"\\<langle>y,x\\<rangle> \\<in> r\" by blast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 365
    },
    "338": {
        "type": "definition",
        "text": "text\\<open>Definition that specifies how to convert a sequence $a$ \n  of elements of $Y$ into a sequence of transformations of $X$, given a binary operation\n  $f :X\\times Y \\rightarrow X$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Seq2TrSeq(f,a) \\<equiv> {\\<langle>k,Fix2ndVar(f,a`(k))\\<rangle>. k \\<in> domain(a)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 366
    },
    "339": {
        "type": "definition",
        "text": "text\\<open>Definition of a sequence of partial folds.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"FoldSeq(f,x,a) \\<equiv> \n  InductiveSeqVarFN(x,fstdom(f),Seq2TrSeq(f,a),domain(a))\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 367
    },
    "340": {
        "type": "definition",
        "text": "text\\<open>Definition of a fold.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Fold(f,x,a) \\<equiv> Last(FoldSeq(f,x,a))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 368
    },
    "341": {
        "type": "lemma",
        "text": "text\\<open>If $X$ is a set with a binary operation $f:X\\times Y \\rightarrow X$ then \n  \\<open>Seq2TransSeqN(f,a)\\<close> converts a sequence $a$ of elements of $Y$  \n  into the sequence of corresponding transformations of $X$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"f : X\\<times>Y \\<rightarrow> X\" and A3: \"a:n\\<rightarrow>Y\" and\n  A4: \"T = Seq2TrSeq(f,a)\"\n  ",
        "using": [
            "func1_1_L1",
            "apply_funtype",
            "fix_2nd_var_fun",
            "ZF_fun_from_total",
            "Seq2TrSeq_def",
            "ZF_fun_from_tot_val0",
            "fix_var_val"
        ],
        "statement": "lemma seq2trans_seq_props:\n  assumes A1: \"n \\<in> nat\" and A2: \"f : X\\<times>Y \\<rightarrow> X\" and A3: \"a:n\\<rightarrow>Y\" and\n  A4: \"T = Seq2TrSeq(f,a)\"\n  shows\n  \"T : n \\<rightarrow> (X\\<rightarrow>X)\" and\n  \"\\<forall>k\\<in>n. \\<forall>x\\<in>X. (T`(k))`(x) = f`\\<langle>x,a`(k)\\<rangle>\"\n",
        "proof": "proof -\n  from \\<open>a:n\\<rightarrow>Y\\<close> have D: \"domain(a) = n\" using func1_1_L1 by simp\n  with A2 A3 A4 show \"T : n \\<rightarrow> (X\\<rightarrow>X)\"\n    using apply_funtype fix_2nd_var_fun ZF_fun_from_total Seq2TrSeq_def\n    by simp\n  with A4 D have I: \"\\<forall>k \\<in> n. T`(k) = Fix2ndVar(f,a`(k))\"\n    using Seq2TrSeq_def ZF_fun_from_tot_val0 by simp\n  { fix k fix x assume A5: \"k\\<in>n\"  \"x\\<in>X\"\n    with A1 A3 have \"a`(k) \\<in> Y\" using apply_funtype\n      by auto\n    with A2 A5 I have \"(T`(k))`(x) = f`\\<langle>x,a`(k)\\<rangle>\"\n      using fix_var_val by simp\n  } thus \"\\<forall>k\\<in>n. \\<forall>x\\<in>X. (T`(k))`(x) = f`\\<langle>x,a`(k)\\<rangle>\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 369
    },
    "342": {
        "type": "theorem",
        "text": "text\\<open>Basic properties of the sequence of partial folds of a sequence \n  $a = \\{y_k\\}_{k\\in \\{0,..,n\\} }$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"f : X\\<times>Y \\<rightarrow> X\" and \n  A3: \"y:n\\<rightarrow>Y\" and A4: \"x\\<in>X\" and A5: \"Y\\<noteq>0\" and \n  A6: \"F = FoldSeq(f,x,y)\"\n  ",
        "using": [
            "func1_1_L1",
            "fstdomdef",
            "seq2trans_seq_props",
            "FoldSeq_def",
            "fin_indseq_var_f_props",
            "apply_funtype"
        ],
        "statement": "theorem fold_seq_props:\n  assumes A1: \"n \\<in> nat\" and A2: \"f : X\\<times>Y \\<rightarrow> X\" and \n  A3: \"y:n\\<rightarrow>Y\" and A4: \"x\\<in>X\" and A5: \"Y\\<noteq>0\" and \n  A6: \"F = FoldSeq(f,x,y)\"\n  shows \n  \"F: succ(n) \\<rightarrow> X\"\n  \"F`(0) = x\" and\n  \"\\<forall>k\\<in>n. F`(succ(k)) = f`\\<langle>F`(k), y`(k)\\<rangle>\"\n",
        "proof": "proof -\n  let ?T = \"Seq2TrSeq(f,y)\"\n  from A1 A3 have D: \"domain(y) = n\"\n    using func1_1_L1 by simp\n  from \\<open>f : X\\<times>Y \\<rightarrow> X\\<close>  \\<open>Y\\<noteq>0\\<close> have I: \"fstdom(f) = X\" \n    using fstdomdef by simp\n  with A1 A2 A3 A4 A6 D show \n    II: \"F: succ(n) \\<rightarrow> X\"  and \"F`(0) = x\"  \n    using seq2trans_seq_props FoldSeq_def fin_indseq_var_f_props\n    by auto\n  from A1 A2 A3 A4 A6 I D have \"\\<forall>k\\<in>n. F`(succ(k)) = ?T`(k)`(F`(k))\"\n    using seq2trans_seq_props FoldSeq_def fin_indseq_var_f_props \n    by simp\n  moreover\n  { fix k assume A5: \"k\\<in>n\" hence \"k \\<in> succ(n)\" by auto\n    with A1 A2 A3 II A5 have \"(?T`(k))`(F`(k)) = f`\\<langle>F`(k),y`(k)\\<rangle>\"\n      using apply_funtype seq2trans_seq_props by simp }\n  ultimately show \"\\<forall>k\\<in>n. F`(succ(k)) = f`\\<langle>F`(k), y`(k)\\<rangle>\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 370
    },
    "343": {
        "type": "lemma",
        "text": "text\\<open>A consistency condition: if we make the list shorter, then we get a shorter\n  sequence of partial folds with the same values as in the original sequence. \n  This can be proven as a special case of \\<open>fin_indseq_var_f_restrict\\<close>\n  but a proof using \\<open>fold_seq_props\\<close> and induction turns out to be \n  shorter.\\<close>\n",
        "assumes": "assumes \n  \"n \\<in> nat\"   \"k \\<in> succ(n)\" and \n  \"i \\<in> nat\"  \"f : X\\<times>Y \\<rightarrow> X\"  \"a : n \\<rightarrow> Y\"  \"b : i \\<rightarrow> Y\" and\n  \"n \\<subseteq> i\"   \"\\<forall>j \\<in> n. b`(j) = a`(j)\"   \"x \\<in> X\"   \"Y \\<noteq> 0\"\n  ",
        "using": [
            "fold_seq_props"
        ],
        "statement": "lemma foldseq_restrict: assumes \n  \"n \\<in> nat\"   \"k \\<in> succ(n)\" and \n  \"i \\<in> nat\"  \"f : X\\<times>Y \\<rightarrow> X\"  \"a : n \\<rightarrow> Y\"  \"b : i \\<rightarrow> Y\" and\n  \"n \\<subseteq> i\"   \"\\<forall>j \\<in> n. b`(j) = a`(j)\"   \"x \\<in> X\"   \"Y \\<noteq> 0\"\n  shows \"FoldSeq(f,x,b)`(k) = FoldSeq(f,x,a)`(k)\"\n",
        "proof": "proof -\n  let ?P = \"FoldSeq(f,x,a)\"\n  let ?Q = \"FoldSeq(f,x,b)\"\n  from assms have\n    \"n \\<in> nat\"   \"k \\<in> succ(n)\"\n    \"?Q`(0) = ?P`(0)\" and\n    \"\\<forall>j \\<in> n. ?Q`(j) = ?P`(j) \\<longrightarrow> ?Q`(succ(j)) = ?P`(succ(j))\"\n    using fold_seq_props by auto\n  then show  \"?Q`(k) = ?P`(k)\" by (rule fin_nat_ind)\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 371
    },
    "344": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>foldseq_restrict\\<close> when the longer\n  sequence is created from the shorter one by appending\n  one element.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"   \"f : X\\<times>Y \\<rightarrow> X\"   \"a:n \\<rightarrow> Y\" and\n  \"x\\<in>X\"   \"k \\<in> succ(n)\"   \"y\\<in>Y\" \n  ",
        "using": [
            "append_props",
            "foldseq_restrict"
        ],
        "statement": "corollary fold_seq_append: \n  assumes \"n \\<in> nat\"   \"f : X\\<times>Y \\<rightarrow> X\"   \"a:n \\<rightarrow> Y\" and\n  \"x\\<in>X\"   \"k \\<in> succ(n)\"   \"y\\<in>Y\" \n  shows \"FoldSeq(f,x,Append(a,y))`(k) = FoldSeq(f,x,a)`(k)\"\n",
        "proof": "proof -\n  let ?b = \"Append(a,y)\"\n  from assms have \"?b : succ(n) \\<rightarrow> Y\"  \"\\<forall>j \\<in> n. ?b`(j) = a`(j)\"\n    using append_props by auto\n  with assms show ?thesis using foldseq_restrict by blast\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 372
    },
    "345": {
        "type": "theorem",
        "text": "text\\<open>What we really will be using is the notion of the fold\n  of a sequence, which we define as the last element of\n  (inductively defined) sequence of partial folds. The next theorem \n  lists some properties of the product of the fold operation.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and \n  A2: \"f : X\\<times>Y \\<rightarrow> X\"  \"a:n \\<rightarrow> Y\"  \"x\\<in>X\"  \"Y\\<noteq>0\"\n  ",
        "using": [
            "fold_seq_props",
            "last_seq_elem",
            "apply_funtype",
            "Fold_def"
        ],
        "statement": "theorem fold_props: \n  assumes A1: \"n \\<in> nat\" and \n  A2: \"f : X\\<times>Y \\<rightarrow> X\"  \"a:n \\<rightarrow> Y\"  \"x\\<in>X\"  \"Y\\<noteq>0\"\n  shows\n  \"Fold(f,x,a) =  FoldSeq(f,x,a)`(n)\" and\n  \"Fold(f,x,a) \\<in> X\"\n",
        "proof": "proof -\n  from assms have \" FoldSeq(f,x,a) : succ(n) \\<rightarrow> X\"\n    using  fold_seq_props by simp\n  with A1 show \n    \"Fold(f,x,a) =  FoldSeq(f,x,a)`(n)\" and \"Fold(f,x,a) \\<in> X\"\n    using last_seq_elem apply_funtype Fold_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 373
    },
    "346": {
        "type": "theorem",
        "text": "text\\<open>A corner case: what happens when we fold an empty list?\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> X\" and \n  A2: \"a:0\\<rightarrow>Y\"  \"x\\<in>X\"  \"Y\\<noteq>0\"\n  ",
        "using": [],
        "statement": "theorem fold_empty: assumes A1: \"f : X\\<times>Y \\<rightarrow> X\" and \n  A2: \"a:0\\<rightarrow>Y\"  \"x\\<in>X\"  \"Y\\<noteq>0\"\n  shows \"Fold(f,x,a) = x\"\n",
        "proof": "proof -\n  let ?F = \"FoldSeq(f,x,a)\"\n  from assms have I:\n    \"0 \\<in> nat\"  \"f : X\\<times>Y \\<rightarrow> X\"  \"a:0\\<rightarrow>Y\"  \"x\\<in>X\"  \"Y\\<noteq>0\"\n    by auto\n  then have \"Fold(f,x,a) = ?F`(0)\" by (rule fold_props)\n  moreover \n  from I have\n    \"0 \\<in> nat\"  \"f : X\\<times>Y \\<rightarrow> X\"  \"a:0\\<rightarrow>Y\"  \"x\\<in>X\"  \"Y\\<noteq>0\" and\n    \"?F = FoldSeq(f,x,a)\" by auto\n  then have \"?F`(0) = x\" by (rule fold_seq_props)\n  ultimately show \"Fold(f,x,a) = x\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 374
    },
    "347": {
        "type": "theorem",
        "text": "text\\<open>The next theorem tells us what happens to the fold of a sequence\n  when we add one more element to it.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and  A2: \"f : X\\<times>Y \\<rightarrow> X\" and\n  A3: \"a:n\\<rightarrow>Y\" and A4: \"x\\<in>X\" and A5: \"y\\<in>Y\"\n  ",
        "using": [
            "fold_seq_append",
            "fold_props",
            "append_props",
            "last_seq_elem",
            "Fold_def"
        ],
        "statement": "theorem fold_append:  \n  assumes A1: \"n \\<in> nat\" and  A2: \"f : X\\<times>Y \\<rightarrow> X\" and\n  A3: \"a:n\\<rightarrow>Y\" and A4: \"x\\<in>X\" and A5: \"y\\<in>Y\"\n  shows \n  \"FoldSeq(f,x,Append(a,y))`(n) = Fold(f,x,a)\" and\n  \"Fold(f,x,Append(a,y)) = f`\\<langle>Fold(f,x,a), y\\<rangle>\"\n",
        "proof": "proof -\n  let ?b = \"Append(a,y)\"\n  let ?P = \"FoldSeq(f,x,?b)\"\n  from A5 have I: \"Y \\<noteq> 0\" by auto\n  with assms show thesis1: \"?P`(n) = Fold(f,x,a)\"\n    using fold_seq_append fold_props by simp\n  from assms I have II:\n    \"succ(n) \\<in> nat\"   \"f : X\\<times>Y \\<rightarrow> X\"\n    \"?b : succ(n) \\<rightarrow> Y\"   \"x\\<in>X\"  \"Y \\<noteq> 0\"\n    \"?P = FoldSeq(f,x,?b)\"\n    using append_props by auto\n  then have \n    \"\\<forall>k \\<in> succ(n). ?P`(succ(k)) =  f`\\<langle>?P`(k), ?b`(k)\\<rangle>\"\n    by (rule fold_seq_props) \n  with A3 A5 thesis1 have \"?P`(succ(n)) =  f`\\<langle> Fold(f,x,a), y\\<rangle>\"\n    using append_props by auto\n  moreover\n  from II have \"?P : succ(succ(n)) \\<rightarrow> X\"\n    by (rule fold_seq_props)\n  then have \"Fold(f,x,?b) = ?P`(succ(n))\" \n    using last_seq_elem Fold_def by simp\n  ultimately show \"Fold(f,x,Append(a,y)) = f`\\<langle>Fold(f,x,a), y\\<rangle>\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 375
    },
    "348": {
        "type": "lemma",
        "text": "text\\<open>Another way of formulating information contained in \\<open>fold_append\\<close> is to start\n  with a longer sequence $a:n+1\\rightarrow X$ and then detach the last element from it.\n  This provides an identity between the fold of the longer sequence \n  and the value of the folding function on the fold of the shorter sequence and the last element\n  of the longer one. \\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"f : X\\<times>Y \\<rightarrow> X\" \"x\\<in>X\" \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> Y\"\n  ",
        "using": [
            "ZF_fun_from_total",
            "fold_append(2)",
            "set_list_append1(4)"
        ],
        "statement": "lemma fold_detach_last: \n  assumes \"n \\<in> nat\" \"f : X\\<times>Y \\<rightarrow> X\" \"x\\<in>X\" \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> Y\"\n  shows \"Fold(f,x,{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}) = f`\\<langle>Fold(f,x,{\\<langle>k,q(k)\\<rangle>. k\\<in>n}), q(n)\\<rangle>\"\n",
        "proof": "proof -\n  let ?a = \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}\"\n  let ?b = \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n}\"\n  from assms have\n    \"Fold(f,x,Append(?b,q(n))) = f`\\<langle>Fold(f,x,?b), q(n)\\<rangle>\"\n    using ZF_fun_from_total fold_append(2) by simp_all\n  moreover from assms(1,4) have \"?a = Append(?b,q(n))\"\n    using set_list_append1(4) by simp\n  ultimately show \"Fold(f,x,?a) = f`\\<langle>Fold(f,x,?b), q(n)\\<rangle>\"\n    by simp\nqed  \n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 376
    },
    "349": {
        "type": "lemma",
        "text": "text\\<open>The tail of the sequence of partial folds defined by the folding function $f$, \n  starting point $x$ and a sequence $y$ is the same as the sequence of partial\n  folds starting from $f(x,y(0))$.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"f : X\\<times>Y \\<rightarrow> X\" \"y:succ(n)\\<rightarrow>Y\" \"x\\<in>X\"\n  ",
        "using": [
            "empty_in_every_succ",
            "apply_funtype",
            "fold_seq_props(1)",
            "tail_props(1)",
            "nelist_vals_nonempty",
            "seq2trans_seq_props",
            "tail_props(2)",
            "fold_seq_props(3)",
            "fold_seq_props(2)",
            "succ_ineq",
            "seq2trans_seq_props(2)",
            "fstdomdef",
            "func1_1_L1"
        ],
        "statement": "lemma fold_seq_detach_first: \n  assumes \"n \\<in> nat\" \"f : X\\<times>Y \\<rightarrow> X\" \"y:succ(n)\\<rightarrow>Y\" \"x\\<in>X\"\n  shows \"FoldSeq(f,f`\\<langle>x,y`(0)\\<rangle>,Tail(y)) = Tail(FoldSeq(f,x,y))\"\n",
        "proof": "proof -\n  let ?F = \"FoldSeq(f,x,y)\"\n  let ?T = \"Tail(?F)\" \n  let ?S = \"Seq2TrSeq(f,Tail(y))\"\n  from assms(1,3) have \"succ(n) \\<in> nat\" \"0 \\<in> succ(n)\" \"y`(0)\\<in>Y\"\n    using empty_in_every_succ apply_funtype by simp_all\n  have \"n \\<in> nat\" \"f`\\<langle>x,y`(0)\\<rangle> \\<in> X\" \"?S:n\\<rightarrow>(X\\<rightarrow>X)\" \n    and \"?T:succ(n) \\<rightarrow> X\" \"?T`(0) = f`\\<langle>x,y`(0)\\<rangle>\"\n    and \"\\<forall>k\\<in>n. ?T`(succ(k)) = (?S`(k))`(?T`(k))\"\n  proof -\n    from assms(1) show \"n \\<in> nat\" by simp\n    from assms \\<open>succ(n) \\<in> nat\\<close> show \"?T:succ(n) \\<rightarrow> X\"\n      using fold_seq_props(1) tail_props(1) nelist_vals_nonempty by simp\n    from assms(2,4) \\<open>y`(0)\\<in>Y\\<close> show \"f`\\<langle>x,y`(0)\\<rangle> \\<in> X\"\n      using apply_funtype by simp\n    from assms(1,2,3) show \"?S:n\\<rightarrow>(X\\<rightarrow>X)\"\n      using tail_props(1) seq2trans_seq_props by simp\n    from assms  have I: \"?F:succ(succ(n)) \\<rightarrow> X\"\n      using fold_seq_props(1) nelist_vals_nonempty by simp\n    show \"?T`(0) = f`\\<langle>x,y`(0)\\<rangle>\"\n    proof -\n      from \\<open>succ(n) \\<in> nat\\<close> \\<open>0 \\<in> succ(n)\\<close> I \n        have \"?T`(0) = ?F`(succ(0))\"\n        using tail_props(2) by blast\n      moreover from assms  \\<open>0 \\<in> succ(n)\\<close> \n        have \"?F`(succ(0)) = f`\\<langle>?F`(0), y`(0)\\<rangle>\"\n        using fold_seq_props(3) nelist_vals_nonempty by blast\n      moreover from assms  have \"?F`(0) = x\" \n        using fold_seq_props(2) nelist_vals_nonempty by blast\n      ultimately show \"?T`(0) = f`\\<langle>x,y`(0)\\<rangle>\" by simp\n    qed\n    show \"\\<forall>k\\<in>n. ?T`(succ(k)) = (?S`(k))`(?T`(k))\"\n    proof -\n      { fix k assume \"k\\<in>n\"\n        with assms(1) have \n          \"succ(k) \\<in> succ(n)\" \"k\\<in>succ(n)\" \"succ(k) \\<in> succ(succ(n))\" \n          using succ_ineq by auto\n        with \\<open>succ(n) \\<in> nat\\<close> I have \"?T`(succ(k)) = ?F`(succ(succ(k)))\"\n          using tail_props(2) by blast\n        moreover from assms \\<open>succ(k) \\<in> succ(n)\\<close>\n          have \"?F`(succ(succ(k))) = f`\\<langle>?F`(succ(k)), y`(succ(k))\\<rangle>\"\n            using fold_seq_props(3) nelist_vals_nonempty by blast\n        moreover from assms(1,3) \\<open>k\\<in>n\\<close> have \"y`(succ(k)) = (Tail(y))`(k)\"\n          using tail_props(2) by simp\n        moreover from assms \\<open>k\\<in>n\\<close> I \\<open>succ(k) \\<in> succ(succ(n))\\<close> \n          have \"f`\\<langle>?F`(succ(k)),(Tail(y))`(k)\\<rangle> = (?S`(k))`(?F`(succ(k)))\"\n            using tail_props(1) seq2trans_seq_props(2) apply_funtype\n            by simp\n        moreover from \\<open>succ(n) \\<in> nat\\<close> I \\<open>k\\<in>succ(n)\\<close> \n          have \"?T`(k) = ?F`(succ(k))\"\n            using tail_props(2) by blast \n        ultimately have \"?T`(succ(k)) = (?S`(k))`(?T`(k))\" by simp\n      } thus ?thesis by simp\n    qed\n  qed\n  then have \"?T = InductiveSeqVarFN(f`\\<langle>x,y`(0)\\<rangle>,X,?S,n)\"\n    by (rule is_fin_indseq_var_f)\n  moreover have \"fstdom(f) = X\" and \"domain(Tail(y)) = n\"\n  proof -\n    from assms(2,3) show \"fstdom(f) = X\"\n      using fstdomdef nelist_vals_nonempty by simp\n    from assms(1,3) show \"domain(Tail(y)) = n\"\n      using tail_props(1) func1_1_L1 by blast\n  qed\n  ultimately show ?thesis unfolding FoldSeq_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 377
    },
    "350": {
        "type": "lemma",
        "text": "text\\<open>Taking a fold of a sequence $y$ with a function $f$ with the starting point $x$ \n  is the same as the fold starting from $f\\langle x,y(0)\\rangle$ of the tail of $y$. \\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"f : X\\<times>Y \\<rightarrow> X\" \"y:succ(n)\\<rightarrow>Y\" \"x\\<in>X\"\n  ",
        "using": [
            "fold_seq_props(1)",
            "nelist_vals_nonempty",
            "last_tail_last",
            "fold_seq_detach_first",
            "Fold_def"
        ],
        "statement": "lemma fold_detach_first: \n  assumes \"n \\<in> nat\" \"f : X\\<times>Y \\<rightarrow> X\" \"y:succ(n)\\<rightarrow>Y\" \"x\\<in>X\"\n  shows \"Fold(f,x,y) = Fold(f,f`\\<langle>x,y`(0)\\<rangle>,Tail(y))\"\n",
        "proof": "proof -\n  from assms have \"FoldSeq(f,x,y):succ(succ(n))\\<rightarrow>X\"\n    using fold_seq_props(1) nelist_vals_nonempty by simp\n  with assms show ?thesis\n    using last_tail_last fold_seq_detach_first unfolding Fold_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/Fold_ZF.thy",
        "id": 378
    },
    "351": {
        "type": "definition",
        "text": "text\\<open>We define the \\<open>small2\\<close> set as the range of \\<open>embed\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization) \"small2 \\<equiv> range(embed)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 379
    },
    "352": {
        "type": "definition",
        "text": "text\\<open>We define \\<open>spec\\<close> as the converse of \\<open>embed\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization) \"spec \\<equiv> converse(embed)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 380
    },
    "353": {
        "type": "lemma",
        "text": "text\\<open>Spec is an injection from range of \\<open>embed\\<close> to \\<open>small\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "embed_inj",
            "inj_converse_inj",
            "small2_def",
            "spec_def"
        ],
        "statement": "lemma (in generalization) spec_inj: shows \"spec \\<in> inj(small2, small)\"\n  ",
        "proof": "using embed_inj inj_converse_inj small2_def spec_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 381
    },
    "354": {
        "type": "lemma",
        "text": "text\\<open>Spec maps range of \\<open>embed\\<close> to \\<open>small\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "embed_inj",
            "inj_converse_fun",
            "small2_def",
            "spec_def"
        ],
        "statement": "lemma (in generalization) spec_fun: shows \"spec: small2\\<rightarrow>small\"\n  ",
        "proof": "using embed_inj inj_converse_fun small2_def spec_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 382
    },
    "355": {
        "type": "lemma",
        "text": "text\\<open>Embed maps \\<open>small\\<close>small to \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "embed_inj",
            "inj_is_fun"
        ],
        "statement": "lemma (in generalization) embed_fun: shows \"embed: small\\<rightarrow>big\"\n  ",
        "proof": "using  embed_inj inj_is_fun by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 383
    },
    "356": {
        "type": "lemma",
        "text": "text\\<open>Embed is a surjection from \\<open>small\\<close> to \\<open>small2\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "fun_is_surj",
            "embed_fun",
            "small2_def"
        ],
        "statement": "lemma (in generalization) embed_surj: shows \"embed \\<in> surj(small, small2)\"\n  ",
        "proof": "using fun_is_surj embed_fun small2_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 384
    },
    "357": {
        "type": "theorem",
        "text": "text\\<open>Embed is a bijection between \\<open>small\\<close> and \\<open>small2\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "embed_inj",
            "inj_bij_range",
            "small2_def"
        ],
        "statement": "theorem (in generalization) embed_bij: shows \"embed \\<in> bij(small, small2)\"\n  ",
        "proof": "using embed_inj inj_bij_range small2_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 385
    },
    "358": {
        "type": "theorem",
        "text": "text\\<open>\\<open>small2\\<close> (i.e. range of \\<open>embed\\<close>) is a \n  subset of \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "embed_fun",
            "func1_1_L5B",
            "small2_def"
        ],
        "statement": "theorem (in generalization) small2_sub_big: shows \"small2 \\<subseteq> big\"\n  ",
        "proof": "using embed_fun func1_1_L5B small2_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 386
    },
    "359": {
        "type": "theorem",
        "text": "text\\<open>\\<open>spec\\<close> is a bijection beween \\<open>small2\\<close> and \\<open>small\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "bij_converse_bij",
            "embed_bij",
            "spec_def"
        ],
        "statement": "theorem (in generalization) spec_bij: shows \"spec \\<in> bij(small2, small)\"\n  ",
        "proof": "using bij_converse_bij embed_bij spec_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 387
    },
    "360": {
        "type": "definition",
        "text": "text\\<open>in \\<open>generalization1\\<close> context we define \\<open>ret\\<close> \n  as the converse of \\<open>move\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization1) \"ret \\<equiv> converse(move)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 388
    },
    "361": {
        "type": "lemma",
        "text": "text\\<open>\\<open>move\\<close> is a map from \\<open>big\\<close> to \\<open>newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "move_bij",
            "bij_is_fun"
        ],
        "statement": "lemma (in generalization1) move_fun: shows \"move: big\\<rightarrow>newbig\" \n  ",
        "proof": "using move_bij bij_is_fun by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 389
    },
    "362": {
        "type": "lemma",
        "text": "text\\<open>Move is a surjection \\<open>big\\<close> to \\<open>newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "move_bij",
            "bij_is_surj"
        ],
        "statement": "lemma (in generalization1) move_surj: shows \"move\\<in>surj(big, newbig)\" \n  ",
        "proof": "using move_bij bij_is_surj by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 391
    },
    "363": {
        "type": "lemma",
        "text": "text\\<open>\\<open>big\\<close> is the domain of \\<open>move\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "domain_of_fun",
            "move_fun"
        ],
        "statement": "lemma (in generalization1) move_domain: shows \"domain(move) = big\" \n  ",
        "proof": "using domain_of_fun move_fun by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 392
    },
    "364": {
        "type": "theorem",
        "text": "text\\<open>Composing \\<open>move\\<close> with \\<open>embed\\<close> takes elements of \n  \\<open>small\\<close> to themselves.\\<close>\n",
        "assumes": "assumes \"x\\<in>small\" \n  ",
        "using": [
            "embed_fun",
            "comp_fun_apply",
            "move_embed"
        ],
        "statement": "theorem (in generalization1) move_embed_plain: assumes \"x\\<in>small\" \n  shows \"move`(embed`(x)) = x\"\n",
        "proof": "proof -\n  from assms have \"move`(embed`(x)) = (move O embed)`(x)\"\n    using embed_fun comp_fun_apply by simp\n  with assms show ?thesis using move_embed by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 393
    },
    "365": {
        "type": "lemma",
        "text": "text\\<open>\\<open>ret\\<close> is a bijection from \\<open>newbig\\<close>newbig to \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "move_bij",
            "ret_def"
        ],
        "statement": "lemma (in generalization1) ret_bij: shows \"ret\\<in>bij(newbig, big)\" \n  ",
        "proof": "using move_bij ret_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 394
    },
    "366": {
        "type": "lemma",
        "text": "text\\<open>\\<open>ret\\<close> is a injection from \\<open>newbig\\<close> onto \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "ret_bij",
            "bij_is_inj"
        ],
        "statement": "lemma (in generalization1) ret_inj: shows \"ret \\<in> inj(newbig,big)\" \n  ",
        "proof": "using ret_bij bij_is_inj by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 395
    },
    "367": {
        "type": "lemma",
        "text": "text\\<open>\\<open>ret\\<close> is a surjection from \\<open>newbig\\<close> onto \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "ret_bij",
            "bij_is_surj"
        ],
        "statement": "lemma (in generalization1) ret_surj: shows \"ret \\<in> surj(newbig,big)\" \n  ",
        "proof": "using ret_bij bij_is_surj by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 396
    },
    "368": {
        "type": "lemma",
        "text": "text\\<open>\\<open>embed\\<close> is a restriciton of \\<open>ret\\<close> to \\<open>small\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "fun_is_rel",
            "embed_fun",
            "move_embed",
            "comp_assoc",
            "left_comp_inverse",
            "move_inj",
            "left_comp_id",
            "right_comp_id_any",
            "ret_def"
        ],
        "statement": "lemma (in generalization1) ret_restrict: shows \"embed = restrict(ret, small)\"\n",
        "proof": "proof -\n  have \"embed\\<subseteq>small\\<times>big\" \n    using fun_is_rel embed_fun by auto\n  moreover\n  have \"(converse(move) O move) O embed = converse(move) O id(small)\" \n    using  move_embed comp_assoc by auto\n  then have a: \"id(big) O embed = converse(move) O id(small)\"\n    using left_comp_inverse move_inj by simp\n  ultimately show ?thesis using left_comp_id right_comp_id_any ret_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 397
    },
    "369": {
        "type": "lemma",
        "text": "text\\<open>We will need this lemma to assert that ZF generalization \n  is an arbitrary generalization:\\<close>\n",
        "assumes": "",
        "using": [
            "foundation"
        ],
        "statement": "lemma mem_not_refl_2: shows \"{t} \\<notin> t\"\n  ",
        "proof": "using foundation by auto\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 398
    },
    "370": {
        "type": "definition",
        "text": "text\\<open>Definition of token.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization) \"token \\<equiv> Pow(\\<Union>(\\<Union>(small)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 399
    },
    "371": {
        "type": "definition",
        "text": "text\\<open>Definition of function moving the \\<open>small\\<close> set into \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization) \n  \"zf_move_fun(x) \\<equiv> if x\\<in>small2 then spec`(x) else \\<langle>token,x\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 400
    },
    "372": {
        "type": "definition",
        "text": "text\\<open>Definition of \\<open>zf_newbig\\<close> as the range of \\<open>zf_move\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization) \"zf_newbig \\<equiv> range(zf_move)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 402
    },
    "373": {
        "type": "lemma",
        "text": "text\\<open>\\<open>zf_move\\<close> is a function that maps \\<open>big\\<close> to \\<open>newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "lam_is_fun_range",
            "zf_move_def",
            "zf_newbig_def"
        ],
        "statement": "lemma (in generalization) zf_move_fun: shows \"zf_move: big\\<rightarrow>zf_newbig\"\n  ",
        "proof": "using lam_is_fun_range zf_move_def zf_newbig_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 403
    },
    "374": {
        "type": "lemma",
        "text": "text\\<open>\\<open>token\\<close> is not in \\<open>small\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "token_def",
            "Pair_def",
            "mem_not_refl_2"
        ],
        "statement": "lemma (in generalization) token_not_small: shows \"\\<langle>token,x\\<rangle>\\<notin>small\"\n",
        "proof": "proof\n  assume \"\\<langle>token,x\\<rangle>\\<in>small\"\n  then have \"{token}\\<in>token\" using token_def Pair_def by auto\n  then show False using mem_not_refl_2 by blast\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 404
    },
    "375": {
        "type": "lemma",
        "text": "text\\<open>Domain of \\<open>zf_move\\<close> is \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "zf_move_fun",
            "func1_1_L1"
        ],
        "statement": "lemma (in generalization) zf_move_domain: shows \"domain(zf_move) = big\"\n  ",
        "proof": "using  zf_move_fun func1_1_L1 by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 405
    },
    "376": {
        "type": "theorem",
        "text": "text\\<open>\\<open>small\\<close> is a subset of \\<open>big\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "embed_fun",
            "apply_rangeI",
            "small2_def",
            "small2_sub_big",
            "ZF_fun_from_tot_val",
            "zf_move_fun",
            "embed_inj",
            "left_inverse",
            "spec_def",
            "zf_move_def",
            "zf_move_fun_def",
            "zf_newbig_def"
        ],
        "statement": "theorem (in generalization) small_less_zf_newbig: \n  shows \"small \\<subseteq> zf_newbig\"\n",
        "proof": "proof\n  fix x\n  assume s: \"x \\<in> small\"\n  then have s1: \"embed`(x) \\<in> small2\" \n    using embed_fun apply_rangeI small2_def\n    by simp\n  then have s2: \"embed`(x)\\<in>big\" using small2_sub_big by auto\n  with s1 s have x_val: \"zf_move`(embed`(x)) = x\" \n    using ZF_fun_from_tot_val zf_move_fun embed_inj \n      left_inverse spec_def zf_move_def zf_move_fun_def \n    by simp\n  from s2 have \"zf_move`(embed`(x))\\<in>range(zf_move)\" \n    using zf_move_fun apply_rangeI by simp\n  with x_val show \"x \\<in> zf_newbig\" using zf_newbig_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 406
    },
    "377": {
        "type": "theorem",
        "text": "text\\<open>\\<open>zf_move\\<close> is an injection from \\<open>big\\<close>\n  to \\<open>zf_newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_tot_val1",
            "zf_move_fun_def",
            "zf_move_def",
            "spec_inj",
            "apply_funtype",
            "token_not_small",
            "inj_def"
        ],
        "statement": "theorem (in generalization) zf_move_inj: shows \"zf_move\\<in>inj(big, zf_newbig)\"\n",
        "proof": "proof -\n  have \"\\<forall>a\\<in>big. \\<forall>b\\<in>big. \n    zf_move`(a) = zf_move`(b) \\<longrightarrow> a=b\"\n  proof -\n    {\n      fix a b\n      assume \"a\\<in>big\" and \"b\\<in>big\"\n      then have spec1_a: \"a\\<in>small2  \\<longrightarrow>  zf_move`(a) = spec`(a)\" and\n        spec2_a: \"a\\<notin>small2 \\<longrightarrow> zf_move`a = \\<langle>token,a\\<rangle>\" and\n        spec1_b: \"b\\<in>small2  \\<longrightarrow> zf_move`(b) = spec`(b)\" and\n        spec2_b: \"b\\<notin>small2 \\<longrightarrow> zf_move`(b) = \\<langle>token,b\\<rangle>\"\n        using ZF_fun_from_tot_val1 zf_move_fun_def zf_move_def \n        by auto\n      assume move_eq: \"zf_move`(a) = zf_move`(b)\"\n      have \"a=b\"\n      proof -\n        { assume \"a\\<in>small2\" and \"b\\<in>small2\"\n          with \\<open>a\\<in>small2\\<close> spec1_a \\<open>b\\<in>small2\\<close> spec1_b move_eq\n          have I: \"spec`(a) = spec`(b)\" by simp\n          have \"spec \\<in> inj(small2,small)\"\n            using spec_inj by simp\n          then have \"spec \\<in> \n            {f:small2 \\<rightarrow> small. \\<forall>w\\<in>small2. \\<forall>x\\<in>small2. f`(w)=f`(x) \\<longrightarrow> w=x}\"\n            unfolding inj_def by auto\n          hence \"\\<forall>w\\<in>small2. \\<forall>x\\<in>small2. spec`(w)=spec`(x) \\<longrightarrow> w=x\" by auto\n          with \\<open>a\\<in>small2\\<close> \\<open>b\\<in>small2\\<close> I have \"a=b\" by auto\n        }\n        moreover\n        { assume \"a\\<in>small2\" \"b\\<notin>small2\"\n          with spec1_a spec_fun have ma_s: \"zf_move`a\\<in>small\"\n            using apply_funtype by auto\n          from \\<open>b\\<notin>small2\\<close> spec2_b have \"zf_move`b\\<notin>small\"\n            using token_not_small by auto\n           with move_eq ma_s have False by auto\n        }\n        moreover\n        { assume \"a\\<notin>small2\" and \"b\\<in>small2\"\n          with spec1_b spec_fun have mb_s: \"zf_move`(b)\\<in>small\" \n            using apply_funtype by auto\n          from \\<open>a\\<notin>small2\\<close> spec2_a  have \"zf_move`(a)\\<notin>small\"\n            using token_not_small by auto\n          with move_eq mb_s have False by auto\n        }\n        moreover\n        { assume \"a\\<notin>small2\" and \"b\\<notin>small2\"\n          with spec2_a spec2_b have \n            \"zf_move`(a) = \\<langle>token,a\\<rangle>\" and\n            \"zf_move`(b) = \\<langle>token,b\\<rangle>\"\n            by auto\n          with move_eq have \"a=b\" by auto \n        }\n        ultimately show \"a=b\" by auto\n      qed\n    }\n    thus ?thesis by auto\n  qed\n  with zf_move_fun show ?thesis using inj_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 407
    },
    "378": {
        "type": "theorem",
        "text": "text\\<open>\\<open>zf_move\\<close> is a surjection of \\<open>big\\<close> onto  \\<open>zf_newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "zf_move_fun",
            "fun_is_surj",
            "zf_newbig_def"
        ],
        "statement": "theorem (in generalization) zf_move_surj: \n  shows \"zf_move \\<in> surj(big,zf_newbig)\"\n  ",
        "proof": "using zf_move_fun fun_is_surj zf_newbig_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 408
    },
    "379": {
        "type": "theorem",
        "text": "text\\<open>\\<open>zf_move\\<close> is a bijection from \\<open>big\\<close> to  \\<open>zf_newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "zf_move_inj",
            "inj_bij_range",
            "zf_newbig_def"
        ],
        "statement": "theorem (in generalization) zf_move_bij: shows \"zf_move \\<in> bij(big, zf_newbig)\"\n  ",
        "proof": "using zf_move_inj inj_bij_range zf_newbig_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 409
    },
    "380": {
        "type": "theorem",
        "text": "text\\<open>The essential condition to prove that composition of \\<open>zf_move\\<close> \n  and \\<open>embed\\<close> is identity.\\<close>\n",
        "assumes": "assumes \"x \\<in> small\" ",
        "using": [
            "assms",
            "embed_fun",
            "apply_rangeI",
            "small2_sub_big",
            "ZF_fun_from_tot_val1",
            "embed_inj",
            "small2_def",
            "spec_def",
            "zf_move_def",
            "zf_move_fun_def"
        ],
        "statement": "theorem (in generalization) zf_move_embed: \n  assumes \"x \\<in> small\" shows \"zf_move`(embed`(x)) = x\"\n  ",
        "proof": "using assms embed_fun apply_rangeI small2_sub_big ZF_fun_from_tot_val1\n    embed_inj small2_def spec_def zf_move_def zf_move_fun_def by auto\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 410
    },
    "381": {
        "type": "theorem",
        "text": "text\\<open>Composition of \\<open>zf_move\\<close>  and \\<open>embed\\<close> is identity.\\<close>\n",
        "assumes": "",
        "using": [
            "zf_move_embed",
            "embed_fun",
            "zf_move_fun",
            "comp_eq_id_iff1"
        ],
        "statement": "theorem (in generalization) zf_embed_move: shows \"zf_move O embed = id(small)\"\n",
        "proof": "proof -\n  have \"\\<forall>y\\<in>small. zf_move`(embed`y) = y\" and \n     \"embed: small\\<rightarrow>big\" and \"zf_move: big\\<rightarrow>zf_newbig\"\n    using zf_move_embed embed_fun zf_move_fun by auto\n  then show ?thesis using comp_eq_id_iff1 by blast\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 411
    },
    "382": {
        "type": "definition",
        "text": "text\\<open>We define the group inverse as the set\n  $\\{\\langle x,y \\rangle \\in G\\times G: x\\cdot y = e \\}$, where $e$ is the\n  neutral element of the group. This set (which can be written as \n  $(\\cdot)^{-1}\\{ e\\}$) is a certain relation on the group (carrier). \n  Since, as we show later, for every $x\\in G$ there is exactly one $y\\in G$\n  such that $x \\cdot y = e$  this relation is in fact a function from $G$ to $G$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"GroupInv(G,f) \\<equiv> {\\<langle>x,y\\<rangle> \\<in> G\\<times>G. f`\\<langle>x,y\\<rangle> = TheNeutralElement(G,f)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 413
    },
    "383": {
        "type": "lemma",
        "text": "text\\<open>First we show a lemma that says that we can use theorems proven in\n  the \\<open>monoid0\\<close> context (locale).\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "IsAgroup_def",
            "monoid0_def"
        ],
        "statement": "lemma (in group0) group0_2_L1: shows \"monoid0(G,P)\"\n  ",
        "proof": "using groupAssum IsAgroup_def monoid0_def by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 414
    },
    "384": {
        "type": "lemma",
        "text": "text\\<open>In some strange cases Isabelle has difficulties with applying\n  the definition of a group. The next lemma defines a rule to be applied\n  in such cases.\\<close>\n",
        "assumes": "assumes \"IsAmonoid(G,f)\" \n  and \"\\<forall>g\\<in>G. \\<exists>b\\<in>G. f`\\<langle>g,b\\<rangle> = TheNeutralElement(G,f)\"\n  ",
        "using": [
            "assms",
            "IsAgroup_def"
        ],
        "statement": "lemma definition_of_group: assumes \"IsAmonoid(G,f)\" \n  and \"\\<forall>g\\<in>G. \\<exists>b\\<in>G. f`\\<langle>g,b\\<rangle> = TheNeutralElement(G,f)\"\n  shows \"IsAgroup(G,f)\" \n  ",
        "proof": "using assms IsAgroup_def by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 415
    },
    "385": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma that allows to use $1$ as the neutral element of \n  the group without referencing a list of lemmas and definitions.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L1",
            "monoid.unit_is_neutral"
        ],
        "statement": "lemma (in group0) group0_2_L2: \n  shows \"\\<one>\\<in>G \\<and> (\\<forall>g\\<in>G.(\\<one>\\<cdot>g = g \\<and> g\\<cdot>\\<one> = g))\"\n  ",
        "proof": "using group0_2_L1 monoid.unit_is_neutral by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 416
    },
    "386": {
        "type": "lemma",
        "text": "text\\<open>The group is closed under the group operation. Used all the time,\n  useful to have handy.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "assms",
            "monoid.group0_1_L1"
        ],
        "statement": "lemma (in group0) group_op_closed: assumes \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a\\<cdot>b \\<in> G\" ",
        "proof": "using assms monoid.group0_1_L1 \n  by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 417
    },
    "387": {
        "type": "lemma",
        "text": "text\\<open>The group operation is associative. This is another technical lemma \n  that allows to shorten the list of referenced lemmas in some proofs.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" ",
        "using": [
            "groupAssum",
            "assms",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "group_op_closed"
        ],
        "statement": "lemma (in group0) group_oper_assoc: \n  assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" shows \"a\\<cdot>(b\\<cdot>c) = a\\<cdot>b\\<cdot>c\"\n  ",
        "proof": "using groupAssum assms IsAgroup_def IsAmonoid_def \n    IsAssociative_def group_op_closed by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 418
    },
    "388": {
        "type": "lemma",
        "text": "text\\<open>The group operation maps $G\\times G$ into $G$. It is conveniet to have\n  this fact easily accessible in the \\<open>group0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def"
        ],
        "statement": "lemma (in group0) group_oper_fun: shows \"P : G\\<times>G\\<rightarrow>G\"\n  ",
        "proof": "using groupAssum IsAgroup_def IsAmonoid_def IsAssociative_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 419
    },
    "389": {
        "type": "lemma",
        "text": "text\\<open>For every element of a group there is only one inverse.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>G\" ",
        "using": [
            "IsAgroup_def",
            "group0_2_T1",
            "group0_2_L2",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) group0_2_L4: \n  assumes A1: \"x\\<in>G\" shows \"\\<exists>!y. y\\<in>G \\<and> x\\<cdot>y = \\<one>\"\n",
        "proof": "proof\n  from A1 groupAssum show \"\\<exists>y. y\\<in>G \\<and>  x\\<cdot>y = \\<one>\" \n    using IsAgroup_def by auto\n  fix y n\n  assume A2: \"y\\<in>G \\<and>  x\\<cdot>y = \\<one>\" and A3:\"n\\<in>G \\<and> x\\<cdot>n = \\<one>\" show \"y=n\"\n  proof -\n    from A1 A2 have T1: \"y\\<cdot>x = \\<one>\"\n      using group0_2_T1 by simp\n    from A2 A3 have \"y = y\\<cdot>(x\\<cdot>n)\" \n      using group0_2_L2 by simp\n    also from A1 A2 A3 have \"\\<dots> = (y\\<cdot>x)\\<cdot>n\" \n      using group_oper_assoc by blast\n    also from T1 A3 have \"\\<dots> = n\" \n      using group0_2_L2 by simp\n    finally show \"y=n\" by simp\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 421
    },
    "390": {
        "type": "theorem",
        "text": "text\\<open>The group inverse is a function that maps G into G.\\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,f)\" ",
        "using": [
            "GroupInv_def",
            "group0_def",
            "group0.group0_2_L4",
            "func1_1_L11"
        ],
        "statement": "theorem group0_2_T2: \n  assumes A1: \"IsAgroup(G,f)\" shows \"GroupInv(G,f) : G\\<rightarrow>G\"\n",
        "proof": "proof -\n  have \"GroupInv(G,f) \\<subseteq> G\\<times>G\" using GroupInv_def by auto\n  moreover from A1 have\n    \"\\<forall>x\\<in>G. \\<exists>!y. y\\<in>G \\<and> \\<langle>x,y\\<rangle> \\<in> GroupInv(G,f)\"\n    using group0_def group0.group0_2_L4 GroupInv_def by simp\n  ultimately show ?thesis using func1_1_L11 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 422
    },
    "391": {
        "type": "theorem",
        "text": "text\\<open>We can think about the group inverse (the function) \n  as the inverse image of the neutral element. Recall that\n  in Isabelle \\<open>f-``(A)\\<close> denotes the inverse image of\n  the set $A$.\\<close>\n",
        "assumes": "",
        "using": [
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "func1_1_L14",
            "GroupInv_def"
        ],
        "statement": "theorem (in group0) group0_2_T3: shows \"P-``{\\<one>} = GroupInv(G,P)\"\n",
        "proof": "proof -\n  from groupAssum have \"P : G\\<times>G \\<rightarrow> G\" \n    using IsAgroup_def IsAmonoid_def IsAssociative_def \n    by simp\n  then show \"P-``{\\<one>} = GroupInv(G,P)\"\n    using func1_1_L14 GroupInv_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 423
    },
    "392": {
        "type": "lemma",
        "text": "text\\<open>The inverse is in the group.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>G\" ",
        "using": [
            "group0_2_T2",
            "apply_type"
        ],
        "statement": "lemma (in group0) inverse_in_group: assumes A1: \"x\\<in>G\" shows \"x\\<inverse>\\<in>G\"\n",
        "proof": "proof -\n  from groupAssum have \"GroupInv(G,P) : G\\<rightarrow>G\" using group0_2_T2 by simp\n  with A1 show ?thesis using apply_type by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 424
    },
    "393": {
        "type": "lemma",
        "text": "text\\<open>The next two lemmas state that unless we multiply by \n  the neutral element, the result is always \n  different than any of the operands.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" and A3: \"a\\<cdot>b = a\"\n  ",
        "using": [
            "inverse_in_group",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_2_L7: \n  assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" and A3: \"a\\<cdot>b = a\"\n  shows \"b=\\<one>\"\n",
        "proof": "proof -\n  from A3 have \"a\\<inverse> \\<cdot> (a\\<cdot>b) = a\\<inverse>\\<cdot>a\" by simp\n  with A1 A2 show ?thesis using\n    inverse_in_group group_oper_assoc group0_2_L6 group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 426
    },
    "394": {
        "type": "lemma",
        "text": "text\\<open>The inverse of the neutral element is the neutral element.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L2",
            "inverse_in_group",
            "group0_2_L6",
            "group0_2_L7"
        ],
        "statement": "lemma (in group0) group_inv_of_one: shows \"\\<one>\\<inverse> = \\<one>\"\n  ",
        "proof": "using group0_2_L2 inverse_in_group group0_2_L6 group0_2_L7 by blast\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 428
    },
    "395": {
        "type": "lemma",
        "text": "text\\<open>if $a^{-1} = 1$, then $a=1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"a\\<inverse> = \\<one>\"\n  ",
        "using": [
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_2_L8A:  \n  assumes A1: \"a\\<in>G\" and A2: \"a\\<inverse> = \\<one>\"\n  shows \"a = \\<one>\"\n",
        "proof": "proof -\n  from A1 have \"a\\<cdot>a\\<inverse> = \\<one>\" using group0_2_L6 by simp\n  with A1 A2 show \"a = \\<one>\" using group0_2_L2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 429
    },
    "396": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is not a unit, then its inverse is not a unit either.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\" and \"a \\<noteq> \\<one>\"\n  ",
        "using": [
            "assms",
            "group0_2_L8A"
        ],
        "statement": "lemma (in group0) group0_2_L8B:\n  assumes \"a\\<in>G\" and \"a \\<noteq> \\<one>\"\n  shows \"a\\<inverse> \\<noteq> \\<one>\" ",
        "proof": "using assms group0_2_L8A by auto\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 430
    },
    "397": {
        "type": "lemma",
        "text": "text\\<open>If $a^{-1}$ is not a unit, then a is not a unit either.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\" and \"a\\<inverse> \\<noteq> \\<one>\"\n  ",
        "using": [
            "assms",
            "group0_2_L8A",
            "group_inv_of_one"
        ],
        "statement": "lemma (in group0) group0_2_L8C:\n  assumes \"a\\<in>G\" and \"a\\<inverse> \\<noteq> \\<one>\"\n  shows \"a\\<noteq>\\<one>\"\n  ",
        "proof": "using assms group0_2_L8A group_inv_of_one by auto\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 431
    },
    "398": {
        "type": "lemma",
        "text": "text\\<open>If a product of two elements of a group is equal to the neutral\nelement then they are inverses of each other.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" and A3: \"a\\<cdot>b = \\<one>\" \n  ",
        "using": [
            "inverse_in_group",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_2_L9: \n  assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" and A3: \"a\\<cdot>b = \\<one>\" \n  shows \"a = b\\<inverse>\" and \"b = a\\<inverse>\"\n",
        "proof": "proof -\n  from A3 have \"a\\<cdot>b\\<cdot>b\\<inverse> = \\<one>\\<cdot>b\\<inverse>\" by simp \n  with A1 A2 have \"a\\<cdot>(b\\<cdot>b\\<inverse>) = \\<one>\\<cdot>b\\<inverse>\" using\n    inverse_in_group group_oper_assoc by simp\n  with A1 A2 show \"a = b\\<inverse>\" using\n    group0_2_L6 inverse_in_group group0_2_L2 by simp\n  from A3 have \"a\\<inverse>\\<cdot>(a\\<cdot>b) = a\\<inverse>\\<cdot>\\<one>\" by simp\n  with A1 A2 show \"b = a\\<inverse>\" using \n    inverse_in_group group_oper_assoc group0_2_L6 group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 432
    },
    "399": {
        "type": "lemma",
        "text": "text\\<open>It happens quite often that we know what is (have a meta-function for) \n  the right inverse in a group. The next lemma shows that the value \n  of the group inverse (function) is equal to the right inverse \n  (meta-function).\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>g\\<in>G. b(g) \\<in> G \\<and> g\\<cdot>b(g) = \\<one>\"\n  ",
        "using": [],
        "statement": "lemma (in group0) group0_2_L9A: \n  assumes A1: \"\\<forall>g\\<in>G. b(g) \\<in> G \\<and> g\\<cdot>b(g) = \\<one>\"\n  shows \"\\<forall>g\\<in>G. b(g) = g\\<inverse>\"\n",
        "proof": "proof\n  fix g assume \"g\\<in>G\"\n  moreover from A1 \\<open>g\\<in>G\\<close> have \"b(g) \\<in> G\" by simp\n  moreover from A1 \\<open>g\\<in>G\\<close> have \"g\\<cdot>b(g) = \\<one>\" by simp\n  ultimately show \"b(g) = g\\<inverse>\" by (rule group0_2_L9)\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 433
    },
    "400": {
        "type": "lemma",
        "text": "text\\<open>What is the inverse of a product?\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" \n  ",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2",
            "group0_2_L9"
        ],
        "statement": "lemma (in group0) group_inv_of_two:\n  assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" \n  shows \" b\\<inverse>\\<cdot>a\\<inverse> = (a\\<cdot>b)\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"b\\<inverse>\\<in>G\"  \"a\\<inverse>\\<in>G\"  \"a\\<cdot>b\\<in>G\"  \"b\\<inverse>\\<cdot>a\\<inverse> \\<in> G\"\n    using inverse_in_group group_op_closed \n    by auto\n  from A1 A2 \\<open>b\\<inverse>\\<cdot>a\\<inverse> \\<in> G\\<close>  have \"a\\<cdot>b\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>) = a\\<cdot>(b\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>))\"\n    using group_oper_assoc by simp\n  moreover from A2 \\<open>b\\<inverse>\\<in>G\\<close> \\<open>a\\<inverse>\\<in>G\\<close> have \"b\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>) = b\\<cdot>b\\<inverse>\\<cdot>a\\<inverse>\"\n    using group_oper_assoc by simp\n  moreover from A2 \\<open>a\\<inverse>\\<in>G\\<close> have \"b\\<cdot>b\\<inverse>\\<cdot>a\\<inverse> = a\\<inverse>\"\n     using group0_2_L6 group0_2_L2 by simp\n  ultimately have \"a\\<cdot>b\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>) = a\\<cdot>a\\<inverse>\"\n    by simp\n  with A1 have \"a\\<cdot>b\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>) = \\<one>\"\n    using group0_2_L6 by simp\n  with \\<open>a\\<cdot>b \\<in> G\\<close>  \\<open>b\\<inverse>\\<cdot>a\\<inverse> \\<in> G\\<close> show \"b\\<inverse>\\<cdot>a\\<inverse> = (a\\<cdot>b)\\<inverse>\"\n    using group0_2_L9 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 434
    },
    "401": {
        "type": "lemma",
        "text": "text\\<open>What is the inverse of a product of three elements?\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "group_op_closed",
            "inverse_in_group",
            "group_inv_of_two",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) group_inv_of_three:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows\n  \"(a\\<cdot>b\\<cdot>c)\\<inverse> = c\\<inverse>\\<cdot>(a\\<cdot>b)\\<inverse>\"\n  \"(a\\<cdot>b\\<cdot>c)\\<inverse> = c\\<inverse>\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>)\"\n  \"(a\\<cdot>b\\<cdot>c)\\<inverse> = c\\<inverse>\\<cdot>b\\<inverse>\\<cdot>a\\<inverse>\"\n",
        "proof": "proof -\n  from A1 have T: \n    \"a\\<cdot>b \\<in> G\"  \"a\\<inverse> \\<in> G\"  \"b\\<inverse> \\<in> G\"   \"c\\<inverse> \\<in> G\"  \n    using group_op_closed inverse_in_group by auto\n  with A1 show \n    \"(a\\<cdot>b\\<cdot>c)\\<inverse> = c\\<inverse>\\<cdot>(a\\<cdot>b)\\<inverse>\" and \"(a\\<cdot>b\\<cdot>c)\\<inverse> = c\\<inverse>\\<cdot>(b\\<inverse>\\<cdot>a\\<inverse>)\"\n     using group_inv_of_two by auto\n   with T show \"(a\\<cdot>b\\<cdot>c)\\<inverse> = c\\<inverse>\\<cdot>b\\<inverse>\\<cdot>a\\<inverse>\" using group_oper_assoc\n     by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 435
    },
    "402": {
        "type": "lemma",
        "text": "text\\<open>The inverse of the inverse is the element.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\" ",
        "using": [
            "assms",
            "inverse_in_group",
            "group0_2_L6",
            "group0_2_L9"
        ],
        "statement": "lemma (in group0) group_inv_of_inv:\n  assumes \"a\\<in>G\" shows \"a = (a\\<inverse>)\\<inverse>\"\n  ",
        "proof": "using assms inverse_in_group group0_2_L6 group0_2_L9 \n  by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 436
    },
    "403": {
        "type": "lemma",
        "text": "text\\<open>Group inverse is nilpotent, therefore a bijection and involution.\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "group0_2_T2",
            "comp_fun",
            "id_type",
            "comp_fun_apply",
            "group_inv_of_inv",
            "id_conv",
            "nilpotent_imp_bijective",
            "comp_id_conv"
        ],
        "statement": "lemma (in group0) group_inv_bij: \n  shows \"GroupInv(G,P) O GroupInv(G,P) = id(G)\" and \"GroupInv(G,P) \\<in> bij(G,G)\" and\n  \"GroupInv(G,P) = converse(GroupInv(G,P))\"\n",
        "proof": "proof -\n  have I: \"GroupInv(G,P): G\\<rightarrow>G\" using groupAssum group0_2_T2 by simp\n  then have \"GroupInv(G,P) O GroupInv(G,P): G\\<rightarrow>G\" and \"id(G):G\\<rightarrow>G\"\n    using comp_fun id_type by auto\n  moreover \n  { fix g assume \"g\\<in>G\"\n    with I have \"(GroupInv(G,P) O GroupInv(G,P))`(g) = id(G)`(g)\"\n      using comp_fun_apply group_inv_of_inv id_conv by simp\n  } hence \"\\<forall>g\\<in>G. (GroupInv(G,P) O GroupInv(G,P))`(g) = id(G)`(g)\" by simp\n  ultimately show \"GroupInv(G,P) O GroupInv(G,P) = id(G)\"\n    by (rule func_eq)\n  with I show \"GroupInv(G,P) \\<in> bij(G,G)\" using nilpotent_imp_bijective\n    by simp\n  with \\<open>GroupInv(G,P) O GroupInv(G,P) = id(G)\\<close> show\n    \"GroupInv(G,P) = converse(GroupInv(G,P))\" using comp_id_conv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 437
    },
    "404": {
        "type": "lemma",
        "text": "text\\<open>A set comprehension form of the image of a set under the group inverse. \\<close>\n",
        "assumes": "assumes \"V\\<subseteq>G\" \n  ",
        "using": [
            "groupAssum",
            "group0_2_T2",
            "func_imagedef",
            "func1_1_L6(2)"
        ],
        "statement": "lemma (in group0) ginv_image: assumes \"V\\<subseteq>G\" \n  shows \"GroupInv(G,P)``(V) \\<subseteq> G\" and \"GroupInv(G,P)``(V) = {g\\<inverse>. g \\<in> V}\"  \n",
        "proof": "proof -\n  from assms have I: \"GroupInv(G,P)``(V) = {GroupInv(G,P)`(g). g\\<in>V}\" \n    using groupAssum group0_2_T2 func_imagedef by blast \n  thus \"GroupInv(G,P)``(V) = {g\\<inverse>. g \\<in> V}\"  by simp\n  show \"GroupInv(G,P)``(V) \\<subseteq> G\" using groupAssum group0_2_T2 func1_1_L6(2) by blast\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 438
    },
    "405": {
        "type": "lemma",
        "text": "text\\<open>Inverse of an element that belongs to the inverse of the set belongs to the set. \\<close>\n",
        "assumes": "assumes \"V\\<subseteq>G\" \"g \\<in> GroupInv(G,P)``(V)\"\n  ",
        "using": [
            "assms",
            "ginv_image",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) ginv_image_el: assumes \"V\\<subseteq>G\" \"g \\<in> GroupInv(G,P)``(V)\"\n  shows \"g\\<inverse> \\<in> V\"\n  ",
        "proof": "using assms ginv_image group_inv_of_inv by auto \n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 439
    },
    "406": {
        "type": "lemma",
        "text": "text\\<open>If the unit is in a set then it is in the inverse of that set.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" and \"\\<one>\\<in>A\"\n  ",
        "using": [
            "groupAssum",
            "group0_2_T2",
            "func_imagedef",
            "group_inv_of_one"
        ],
        "statement": "lemma (in group0) neut_inv_neut: assumes \"A\\<subseteq>G\" and \"\\<one>\\<in>A\"\n  shows \"\\<one> \\<in> GroupInv(G,P)``(A)\"\n",
        "proof": "proof -\n  have \"GroupInv(G,P):G\\<rightarrow>G\" using groupAssum group0_2_T2 by simp\n  with assms have \"\\<one>\\<inverse> \\<in> GroupInv(G,P)``(A)\" using func_imagedef by auto\n  then show ?thesis using group_inv_of_one by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 441
    },
    "407": {
        "type": "lemma",
        "text": "text\\<open>If $a^{-1}\\cdot b=1$, then $a=b$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<inverse>\\<cdot>b = \\<one>\"\n  ",
        "using": [
            "inverse_in_group",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_2_L11:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<inverse>\\<cdot>b = \\<one>\"\n  shows \"a=b\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<inverse> \\<in> G\"  \"b\\<in>G\"  \"a\\<inverse>\\<cdot>b = \\<one>\" \n    using inverse_in_group by auto\n  then have \"b = (a\\<inverse>)\\<inverse>\" by (rule group0_2_L9)\n  with A1 show \"a=b\" using group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 443
    },
    "408": {
        "type": "lemma",
        "text": "text\\<open>If $a\\cdot b^{-1}=1$, then $a=b$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> = \\<one>\"\n  ",
        "using": [
            "inverse_in_group",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_2_L11A: \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> = \\<one>\"\n  shows \"a=b\"\n",
        "proof": "proof -\n  from A1 A2 have \"a \\<in> G\"  \"b\\<inverse>\\<in>G\"  \"a\\<cdot>b\\<inverse> = \\<one>\"\n    using inverse_in_group by auto\n  then have \"a = (b\\<inverse>)\\<inverse>\" by (rule group0_2_L9)\n  with A1 show \"a=b\" using group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 444
    },
    "409": {
        "type": "lemma",
        "text": "text\\<open>If if the inverse of $b$ is different than $a$, then the\n  inverse of $a$ is different than $b$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"b\\<inverse> \\<noteq> a\"\n  ",
        "using": [
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_2_L11B:\n  assumes A1: \"a\\<in>G\" and A2: \"b\\<inverse> \\<noteq> a\"\n  shows \"a\\<inverse> \\<noteq> b\"\n",
        "proof": "proof -\n  { assume \"a\\<inverse> = b\"\n    then have \"(a\\<inverse>)\\<inverse> = b\\<inverse>\" by simp\n    with A1 A2 have False using group_inv_of_inv\n      by simp\n  } then show \"a\\<inverse> \\<noteq> b\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 445
    },
    "410": {
        "type": "lemma",
        "text": "text\\<open>What is the inverse of $ab^{-1}$ ?\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" \n  ",
        "using": [
            "inverse_in_group",
            "group_inv_of_two",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_2_L12:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" \n  shows \n  \"(a\\<cdot>b\\<inverse>)\\<inverse> = b\\<cdot>a\\<inverse>\"\n  \"(a\\<inverse>\\<cdot>b)\\<inverse> = b\\<inverse>\\<cdot>a\"\n",
        "proof": "proof -\n  from A1 have \n    \"(a\\<cdot>b\\<inverse>)\\<inverse> = (b\\<inverse>)\\<inverse>\\<cdot> a\\<inverse>\" and \"(a\\<inverse>\\<cdot>b)\\<inverse> = b\\<inverse>\\<cdot>(a\\<inverse>)\\<inverse>\"\n    using inverse_in_group group_inv_of_two by auto\n  with A1 show  \"(a\\<cdot>b\\<inverse>)\\<inverse> = b\\<cdot>a\\<inverse>\"  \"(a\\<inverse>\\<cdot>b)\\<inverse> = b\\<inverse>\\<cdot>a\"\n    using group_inv_of_inv by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 446
    },
    "411": {
        "type": "lemma",
        "text": "text\\<open>A couple useful rearrangements with three elements: \n  we can insert a $b\\cdot b^{-1}$ \n  between two group elements (another version) and one about a product of \n  an element and inverse of a product, and two others.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "group0_2_L2",
            "group0_2_L6",
            "group_oper_assoc",
            "group_inv_of_two",
            "group_inv_of_three",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_2_L14A:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \n  \"a\\<cdot>c\\<inverse>= (a\\<cdot>b\\<inverse>)\\<cdot>(b\\<cdot>c\\<inverse>)\"\n  \"a\\<inverse>\\<cdot>c = (a\\<inverse>\\<cdot>b)\\<cdot>(b\\<inverse>\\<cdot>c)\"\n  \"a\\<cdot>(b\\<cdot>c)\\<inverse> = a\\<cdot>c\\<inverse>\\<cdot>b\\<inverse>\"\n  \"a\\<cdot>(b\\<cdot>c\\<inverse>) = a\\<cdot>b\\<cdot>c\\<inverse>\"\n  \"(a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>)\\<inverse> = c\\<cdot>b\\<cdot>a\\<inverse>\"\n  \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>(c\\<cdot>b\\<inverse>) = a\"\n  \"a\\<cdot>(b\\<cdot>c)\\<cdot>c\\<inverse> = a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have T: \n    \"a\\<inverse> \\<in> G\"  \"b\\<inverse>\\<in>G\"  \"c\\<inverse>\\<in>G\"  \n    \"a\\<inverse>\\<cdot>b \\<in> G\"  \"a\\<cdot>b\\<inverse> \\<in> G\"  \"a\\<cdot>b \\<in> G\"  \n    \"c\\<cdot>b\\<inverse> \\<in> G\"  \"b\\<cdot>c \\<in> G\"\n    using inverse_in_group group_op_closed\n    by auto\n   from A1 T have \n     \"a\\<cdot>c\\<inverse> =  a\\<cdot>(b\\<inverse>\\<cdot>b)\\<cdot>c\\<inverse>\"\n     \"a\\<inverse>\\<cdot>c =  a\\<inverse>\\<cdot>(b\\<cdot>b\\<inverse>)\\<cdot>c\"\n    using group0_2_L2 group0_2_L6 by auto\n   with A1 T show \n     \"a\\<cdot>c\\<inverse>= (a\\<cdot>b\\<inverse>)\\<cdot>(b\\<cdot>c\\<inverse>)\"\n     \"a\\<inverse>\\<cdot>c = (a\\<inverse>\\<cdot>b)\\<cdot>(b\\<inverse>\\<cdot>c)\"\n     using group_oper_assoc by auto\n  from A1 have \"a\\<cdot>(b\\<cdot>c)\\<inverse> = a\\<cdot>(c\\<inverse>\\<cdot>b\\<inverse>)\"\n    using group_inv_of_two by simp\n  with A1 T show \"a\\<cdot>(b\\<cdot>c)\\<inverse> =a\\<cdot>c\\<inverse>\\<cdot>b\\<inverse>\" \n    using group_oper_assoc by simp\n  from A1 T show \"a\\<cdot>(b\\<cdot>c\\<inverse>) = a\\<cdot>b\\<cdot>c\\<inverse>\"\n    using group_oper_assoc by simp\n  from A1 T show  \"(a\\<cdot>b\\<inverse>\\<cdot>c\\<inverse>)\\<inverse> = c\\<cdot>b\\<cdot>a\\<inverse>\"\n    using group_inv_of_three  group_inv_of_inv\n    by simp\n  from T have \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>(c\\<cdot>b\\<inverse>) = a\\<cdot>b\\<cdot>(c\\<inverse>\\<cdot>(c\\<cdot>b\\<inverse>))\"\n    using group_oper_assoc by simp\n  also from A1 T have \"\\<dots> =  a\\<cdot>b\\<cdot>b\\<inverse>\"\n    using group_oper_assoc group0_2_L6 group0_2_L2\n    by simp\n  also from A1 T have \"\\<dots> = a\\<cdot>(b\\<cdot>b\\<inverse>)\"\n    using group_oper_assoc by simp\n  also from A1 have \"\\<dots> = a\"\n    using group0_2_L6 group0_2_L2 by simp\n  finally show \"a\\<cdot>b\\<cdot>c\\<inverse>\\<cdot>(c\\<cdot>b\\<inverse>) = a\" by simp\n  from A1 T have \"a\\<cdot>(b\\<cdot>c)\\<cdot>c\\<inverse> =  a\\<cdot>(b\\<cdot>(c\\<cdot>c\\<inverse>))\"\n    using group_oper_assoc by simp\n  also from A1 T have \"\\<dots> = a\\<cdot>b\"\n    using  group0_2_L6 group0_2_L2 by simp\n  finally show \"a\\<cdot>(b\\<cdot>c)\\<cdot>c\\<inverse> = a\\<cdot>b\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 447
    },
    "412": {
        "type": "lemma",
        "text": "text\\<open> A simple equation to solve \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" \"c\\<in>G\" \"a\\<cdot>b\\<inverse> = c\\<inverse>\"\n  ",
        "using": [
            "group0_2_L12(1)",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) simple_equation0: \n  assumes \"a\\<in>G\"  \"b\\<in>G\" \"c\\<in>G\" \"a\\<cdot>b\\<inverse> = c\\<inverse>\"\n  shows \"c = b\\<cdot>a\\<inverse>\" \n",
        "proof": "proof - \n  from assms(4) have \"(a\\<cdot>b\\<inverse>)\\<inverse> = (c\\<inverse>)\\<inverse>\" by simp\n  with assms(1,2,3) show \"c = b\\<cdot>a\\<inverse>\" using group0_2_L12(1) group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 448
    },
    "413": {
        "type": "lemma",
        "text": "text\\<open> Another simple equation \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" \"c\\<in>G\" \"a\\<inverse>\\<cdot>b = c\\<inverse>\"\n  ",
        "using": [
            "group0_2_L12(2)",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) simple_equation1: \n  assumes \"a\\<in>G\"  \"b\\<in>G\" \"c\\<in>G\" \"a\\<inverse>\\<cdot>b = c\\<inverse>\"\n  shows \"c = b\\<inverse>\\<cdot>a\" \n",
        "proof": "proof - \n  from assms(4) have \"(a\\<inverse>\\<cdot>b)\\<inverse> = (c\\<inverse>)\\<inverse>\" by simp\n  with assms(1,2,3) show \"c = b\\<inverse>\\<cdot>a\" using group0_2_L12(2) group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 449
    },
    "414": {
        "type": "lemma",
        "text": "text\\<open>Another lemma about rearranging a product of four group\n  elements.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "group_inv_of_two",
            "group_oper_assoc",
            "group0_2_L14A"
        ],
        "statement": "lemma (in group0) group0_2_L15:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse> = a\\<cdot>(b\\<cdot>d\\<inverse>)\\<cdot>a\\<inverse>\\<cdot>(a\\<cdot>c\\<inverse>)\"\n",
        "proof": "proof -\n  from A1 have T1:\n    \"d\\<inverse>\\<in>G\"  \"c\\<inverse>\\<in>G\" \"a\\<cdot>b\\<in>G\" \"a\\<cdot>(b\\<cdot>d\\<inverse>)\\<in>G\"\n    using inverse_in_group group_op_closed\n    by auto\n  with A1 have \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse> = (a\\<cdot>b)\\<cdot>(d\\<inverse>\\<cdot>c\\<inverse>)\"\n    using group_inv_of_two by simp\n  also from A1 T1 have \"\\<dots> = a\\<cdot>(b\\<cdot>d\\<inverse>)\\<cdot>c\\<inverse>\"\n    using group_oper_assoc by simp\n  also from A1 T1 have \"\\<dots> = a\\<cdot>(b\\<cdot>d\\<inverse>)\\<cdot>a\\<inverse>\\<cdot>(a\\<cdot>c\\<inverse>)\"\n    using group0_2_L14A by blast\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 450
    },
    "415": {
        "type": "lemma",
        "text": "text\\<open>We can cancel an element with its inverse that is written next to it.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) inv_cancel_two:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<inverse>\\<cdot>b = a\"  \n  \"a\\<cdot>b\\<cdot>b\\<inverse> = a\"\n  \"a\\<inverse>\\<cdot>(a\\<cdot>b) = b\"\n  \"a\\<cdot>(a\\<inverse>\\<cdot>b) = b\"\n",
        "proof": "proof -\n  from A1 have \n    \"a\\<cdot>b\\<inverse>\\<cdot>b = a\\<cdot>(b\\<inverse>\\<cdot>b)\"   \"a\\<cdot>b\\<cdot>b\\<inverse> = a\\<cdot>(b\\<cdot>b\\<inverse>)\"\n    \"a\\<inverse>\\<cdot>(a\\<cdot>b) = a\\<inverse>\\<cdot>a\\<cdot>b\"   \"a\\<cdot>(a\\<inverse>\\<cdot>b) = a\\<cdot>a\\<inverse>\\<cdot>b\"\n    using inverse_in_group group_oper_assoc by auto\n  with A1 show\n    \"a\\<cdot>b\\<inverse>\\<cdot>b = a\"\n    \"a\\<cdot>b\\<cdot>b\\<inverse> = a\"\n    \"a\\<inverse>\\<cdot>(a\\<cdot>b) = b\"\n    \"a\\<cdot>(a\\<inverse>\\<cdot>b) = b\"\n    using group0_2_L6 group0_2_L2 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 451
    },
    "416": {
        "type": "lemma",
        "text": "text\\<open>Another lemma about cancelling with two group elements.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "group_inv_of_two",
            "inverse_in_group",
            "inv_cancel_two"
        ],
        "statement": "lemma (in group0) group0_2_L16A:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a\\<cdot>(b\\<cdot>a)\\<inverse> = b\\<inverse>\"\n",
        "proof": "proof -\n  from A1 have \"(b\\<cdot>a)\\<inverse> = a\\<inverse>\\<cdot>b\\<inverse>\"  \"b\\<inverse> \\<in> G\"\n    using group_inv_of_two inverse_in_group by auto\n  with A1 show \"a\\<cdot>(b\\<cdot>a)\\<inverse> = b\\<inverse>\" using inv_cancel_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 452
    },
    "417": {
        "type": "lemma",
        "text": "text\\<open> Some other identities with three element and cancelling. \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" \"c\\<in>G\"\n  ",
        "using": [
            "group_inv_of_two",
            "inverse_in_group",
            "group_oper_assoc",
            "group_op_closed",
            "inv_cancel_two(3)",
            "inv_cancel_two(4)",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) cancel_middle:\n  assumes \"a\\<in>G\"  \"b\\<in>G\" \"c\\<in>G\"\n  shows \n    \"(a\\<cdot>b)\\<inverse>\\<cdot>(a\\<cdot>c) = b\\<inverse>\\<cdot>c\"\n    \"(a\\<cdot>b)\\<cdot>(c\\<cdot>b)\\<inverse> = a\\<cdot>c\\<inverse>\"\n    \"a\\<inverse>\\<cdot>(a\\<cdot>b\\<cdot>c)\\<cdot>c\\<inverse> = b\"\n    \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<cdot>c = a\\<cdot>b\"\n    \"a\\<cdot>b\\<inverse>\\<cdot>(b\\<cdot>c\\<inverse>) = a\\<cdot>c\\<inverse>\"\n",
        "proof": "proof -\n  from assms have \"(a\\<cdot>b)\\<inverse>\\<cdot>(a\\<cdot>c) = b\\<inverse>\\<cdot>(a\\<inverse>\\<cdot>(a\\<cdot>c))\"\n    using group_inv_of_two inverse_in_group group_oper_assoc group_op_closed by auto\n  with assms(1,3) show \"(a\\<cdot>b)\\<inverse>\\<cdot>(a\\<cdot>c) = b\\<inverse>\\<cdot>c\" using inv_cancel_two(3) by simp\n  from assms have \"(a\\<cdot>b)\\<cdot>(c\\<cdot>b)\\<inverse> = a\\<cdot>(b\\<cdot>(b\\<inverse>\\<cdot>c\\<inverse>))\"\n    using group_inv_of_two inverse_in_group group_oper_assoc group_op_closed by auto\n  with assms show \"(a\\<cdot>b)\\<cdot>(c\\<cdot>b)\\<inverse> =a\\<cdot>c\\<inverse>\" using inverse_in_group inv_cancel_two(4) by simp\n  from assms have \"a\\<inverse>\\<cdot>(a\\<cdot>b\\<cdot>c)\\<cdot>c\\<inverse> = (a\\<inverse>\\<cdot>a)\\<cdot>b\\<cdot>(c\\<cdot>c\\<inverse>)\" \n    using inverse_in_group group_oper_assoc group_op_closed by auto\n  with assms show \"a\\<inverse>\\<cdot>(a\\<cdot>b\\<cdot>c)\\<cdot>c\\<inverse> = b\" using group0_2_L6 group0_2_L2 by simp\n  from assms have \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<cdot>c = a\\<cdot>b\\<cdot>(c\\<inverse>\\<cdot>c)\" using inverse_in_group group_oper_assoc group_op_closed\n    by simp\n  with assms show \"a\\<cdot>(b\\<cdot>c\\<inverse>)\\<cdot>c = a\\<cdot>b\" using group_op_closed group0_2_L6 group0_2_L2 by simp\n  from assms have \"a\\<cdot>b\\<inverse>\\<cdot>(b\\<cdot>c\\<inverse>) = a\\<cdot>(b\\<inverse>\\<cdot>b)\\<cdot>c\\<inverse>\" using inverse_in_group group_oper_assoc group_op_closed\n    by simp\n  with assms  show \"a\\<cdot>b\\<inverse>\\<cdot>(b\\<cdot>c\\<inverse>) = a\\<cdot>c\\<inverse>\" using group0_2_L6 group0_2_L2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 453
    },
    "418": {
        "type": "lemma",
        "text": "text\\<open>Adding a neutral element to a set that is \n  closed under the group operation results in a set that is closed under the \n  group operation.\\<close>\n",
        "assumes": "assumes \"H\\<subseteq>G\"\n  and \"H {is closed under} P\"\n  ",
        "using": [
            "assms",
            "IsOpClosed_def",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_2_L17: \n  assumes \"H\\<subseteq>G\"\n  and \"H {is closed under} P\"\n  shows \"(H \\<union> {\\<one>}) {is closed under} P\"\n  ",
        "proof": "using assms IsOpClosed_def group0_2_L2 by auto\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 454
    },
    "419": {
        "type": "lemma",
        "text": "text\\<open>We can put an element on the other side of an equation.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  and A2: \"c = a\\<cdot>b\"\n  ",
        "using": [
            "inverse_in_group",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_2_L18:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  and A2: \"c = a\\<cdot>b\"\n  shows \"c\\<cdot>b\\<inverse> = a\"  \"a\\<inverse>\\<cdot>c = b\" \n",
        "proof": "proof-\n  from A2 A1 have \"c\\<cdot>b\\<inverse> =  a\\<cdot>(b\\<cdot>b\\<inverse>)\"  \"a\\<inverse>\\<cdot>c = (a\\<inverse>\\<cdot>a)\\<cdot>b\"\n    using inverse_in_group group_oper_assoc by auto\n  moreover from A1 have \"a\\<cdot>(b\\<cdot>b\\<inverse>) = a\"  \"(a\\<inverse>\\<cdot>a)\\<cdot>b = b\"\n    using group0_2_L6 group0_2_L2 by auto\n  ultimately show \"c\\<cdot>b\\<inverse> = a\"  \"a\\<inverse>\\<cdot>c = b\" \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 455
    },
    "420": {
        "type": "lemma",
        "text": "text\\<open> We can cancel an element on the right from both sides of an equation. \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \"a\\<cdot>b = c\\<cdot>b\"\n  ",
        "using": [
            "inv_cancel_two(2)"
        ],
        "statement": "lemma (in group0) cancel_right: assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \"a\\<cdot>b = c\\<cdot>b\"\n  shows \"a = c\" \n",
        "proof": "proof -\n  from assms(4) have \"a\\<cdot>b\\<cdot>b\\<inverse> = c\\<cdot>b\\<cdot>b\\<inverse>\" by simp\n  with assms(1,2,3) show ?thesis using inv_cancel_two(2) by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 456
    },
    "421": {
        "type": "lemma",
        "text": "text\\<open> We can cancel an element on the left from both sides of an equation. \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \"a\\<cdot>b = a\\<cdot>c\"\n  ",
        "using": [
            "inv_cancel_two(3)"
        ],
        "statement": "lemma (in group0) cancel_left: assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \"a\\<cdot>b = a\\<cdot>c\"\n  shows \"b=c\"\n",
        "proof": "proof -\n  from assms(4) have \"a\\<inverse>\\<cdot>(a\\<cdot>b) = a\\<inverse>\\<cdot>(a\\<cdot>c)\" by simp\n  with assms(1,2,3) show ?thesis using inv_cancel_two(3) by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 457
    },
    "422": {
        "type": "definition",
        "text": "text\\<open>A pair $(H,P)$ is a subgroup if $H$ forms a group with the \n  operation $P$ restricted to $H\\times H$. It may be surprising that \n  we don't require $H$ to be a subset of $G$. This however can be inferred\n  from the definition if the pair $(G,P)$ is a group, \n  see lemma \\<open>group0_3_L2\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAsubgroup(H,P) \\<equiv> IsAgroup(H, restrict(P,H\\<times>H))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 459
    },
    "423": {
        "type": "lemma",
        "text": "text\\<open>A subgroup is contained in the group.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "IsAsubgroup_def",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "group0_3_L1",
            "func1_1_L5A",
            "restrict_subset",
            "func1_1_L5"
        ],
        "statement": "lemma (in group0) group0_3_L2: \n  assumes A1: \"IsAsubgroup(H,P)\"\n  shows \"H \\<subseteq> G\"\n",
        "proof": "proof\n  fix h assume \"h\\<in>H\"\n  let ?b = \"restrict(P,H\\<times>H)\"\n  let ?n = \"TheNeutralElement(H,restrict(P,H\\<times>H))\"\n   from A1 have \"?b \\<in> H\\<times>H\\<rightarrow>H\" \n    using IsAsubgroup_def IsAgroup_def \n      IsAmonoid_def IsAssociative_def by simp\n  moreover from A1 \\<open>h\\<in>H\\<close> have \"\\<langle> ?n,h\\<rangle> \\<in> H\\<times>H\" \n    using group0_3_L1 by simp\n  moreover from A1 \\<open>h\\<in>H\\<close> have \"h = ?b`\\<langle>?n,h \\<rangle>\" \n    using group0_3_L1 by simp\n  ultimately have \"\\<langle>\\<langle>?n,h\\<rangle>,h\\<rangle> \\<in> ?b\" \n    using func1_1_L5A by blast\n  then have \"\\<langle>\\<langle>?n,h\\<rangle>,h\\<rangle> \\<in> P\" using restrict_subset by auto\n  moreover from groupAssum have \"P:G\\<times>G\\<rightarrow>G\"\n    using IsAgroup_def IsAmonoid_def IsAssociative_def \n    by simp\n  ultimately show \"h\\<in>G\" using func1_1_L5 \n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 460
    },
    "424": {
        "type": "lemma",
        "text": "text\\<open>The group's neutral element (denoted $1$ in the group0 context)\n  is a neutral element for the subgroup with respect to the group action.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "assms",
            "groupAssum",
            "group0_3_L2",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_3_L3:\n  assumes \"IsAsubgroup(H,P)\"\n  shows \"\\<forall>h\\<in>H. \\<one>\\<cdot>h = h \\<and> h\\<cdot>\\<one> = h\"\n  ",
        "proof": "using assms groupAssum group0_3_L2 group0_2_L2\n  by auto\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 461
    },
    "425": {
        "type": "lemma",
        "text": "text\\<open>The neutral element of a subgroup is the same as that of the group.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "group0_3_L1",
            "group0_3_L2",
            "restrict_if",
            "group0_2_L7"
        ],
        "statement": "lemma (in group0) group0_3_L4: assumes A1: \"IsAsubgroup(H,P)\"\n  shows \"TheNeutralElement(H,restrict(P,H\\<times>H)) = \\<one>\"\n",
        "proof": "proof -\n  let ?n = \"TheNeutralElement(H,restrict(P,H\\<times>H))\"\n  from A1 have \"?n \\<in> H\" using group0_3_L1 by simp\n  with groupAssum A1 have \"?n\\<in>G\" using  group0_3_L2 by auto\n  with A1 \\<open>?n \\<in> H\\<close> show ?thesis using \n     group0_3_L1 restrict_if group0_2_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 462
    },
    "426": {
        "type": "lemma",
        "text": "text\\<open>The neutral element of the group (denoted $1$ in the group0 context)\n  belongs to every subgroup.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "group0_3_L1",
            "group0_3_L4"
        ],
        "statement": "lemma (in group0) group0_3_L5: assumes A1: \"IsAsubgroup(H,P)\"\n  shows \"\\<one> \\<in> H\"\n",
        "proof": "proof -\n  from A1 show \"\\<one>\\<in>H\" using group0_3_L1 group0_3_L4 \n    by fast\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 463
    },
    "427": {
        "type": "lemma",
        "text": "text\\<open>Subgroups are closed with respect to the group operation.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\"\n  and A2: \"a\\<in>H\" \"b\\<in>H\"\n  ",
        "using": [
            "IsAsubgroup_def",
            "IsAgroup_def",
            "monoid0_def",
            "monoid0.group0_1_L1",
            "restrict_if"
        ],
        "statement": "lemma (in group0) group0_3_L6: assumes A1: \"IsAsubgroup(H,P)\"\n  and A2: \"a\\<in>H\" \"b\\<in>H\"\n  shows \"a\\<cdot>b \\<in> H\"\n",
        "proof": "proof - \n  let ?f = \"restrict(P,H\\<times>H)\"\n  from A1 have \"monoid0(H,?f)\" using\n    IsAsubgroup_def IsAgroup_def monoid0_def by simp\n  with A2 have \"?f` (\\<langle>a,b\\<rangle>) \\<in> H\" using monoid0.group0_1_L1\n    by blast\n with A2 show \"a\\<cdot>b \\<in> H\" using restrict_if by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 464
    },
    "428": {
        "type": "lemma",
        "text": "text\\<open>A preliminary lemma that we need to show that taking the inverse \n  in the subgroup is the same as taking the inverse\n  in the group.\\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,f)\" \n  and A2: \"IsAsubgroup(H,f)\" and A3: \"g = restrict(f,H\\<times>H)\"\n  ",
        "using": [
            "group0_def",
            "IsAsubgroup_def",
            "group0.group0_3_L4",
            "group0.group0_2_T3",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "group0.group0_3_L2",
            "A3",
            "func1_2_L1"
        ],
        "statement": "lemma group0_3_L7A: \n  assumes A1: \"IsAgroup(G,f)\" \n  and A2: \"IsAsubgroup(H,f)\" and A3: \"g = restrict(f,H\\<times>H)\"\n  shows \"GroupInv(G,f) \\<inter> H\\<times>H = GroupInv(H,g)\"\n",
        "proof": "proof -\n  let ?e = \"TheNeutralElement(G,f)\"\n  let ?e\\<^sub>1 = \"TheNeutralElement(H,g)\"\n  from A1 have \"group0(G,f)\" using group0_def by simp\n  from A2 A3 have \"group0(H,g)\" \n    using IsAsubgroup_def group0_def by simp\n  from \\<open>group0(G,f)\\<close> A2 A3  have \"GroupInv(G,f) = f-``{?e\\<^sub>1}\" \n    using group0.group0_3_L4 group0.group0_2_T3\n    by simp\n  moreover have \"g-``{?e\\<^sub>1} = f-``{?e\\<^sub>1} \\<inter> H\\<times>H\"\n  proof -\n    from A1 have \"f \\<in> G\\<times>G\\<rightarrow>G\" \n      using IsAgroup_def IsAmonoid_def IsAssociative_def \n      by simp\n    moreover from A2 \\<open>group0(G,f)\\<close> have \"H\\<times>H \\<subseteq> G\\<times>G\" \n      using group0.group0_3_L2 by auto\n    ultimately show \"g-``{?e\\<^sub>1} = f-``{?e\\<^sub>1} \\<inter> H\\<times>H\"\n      using A3 func1_2_L1 by simp\n  qed\n  moreover from A3 \\<open>group0(H,g)\\<close> have \"GroupInv(H,g) = g-``{?e\\<^sub>1}\" \n    using group0.group0_2_T3 by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 465
    },
    "429": {
        "type": "theorem",
        "text": "text\\<open>Using the lemma above we can show the actual statement: \n  taking the inverse in the subgroup is the same as taking the inverse\n  in the group.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\" \n  and A2: \"g = restrict(P,H\\<times>H)\"\n  ",
        "using": [
            "group0_2_T2",
            "IsAsubgroup_def",
            "group0_3_L2",
            "group0_3_L7A",
            "func1_2_L3"
        ],
        "statement": "theorem (in group0) group0_3_T1:\n  assumes A1: \"IsAsubgroup(H,P)\" \n  and A2: \"g = restrict(P,H\\<times>H)\"\n  shows \"GroupInv(H,g) = restrict(GroupInv(G,P),H)\"\n",
        "proof": "proof -\n  from groupAssum have \"GroupInv(G,P) : G\\<rightarrow>G\" \n    using group0_2_T2 by simp\n  moreover from A1 A2 have \"GroupInv(H,g) : H\\<rightarrow>H\"\n    using IsAsubgroup_def group0_2_T2 by simp\n  moreover from A1 have \"H \\<subseteq> G\" \n    using group0_3_L2 by simp\n  moreover from groupAssum A1 A2 have \n    \"GroupInv(G,P) \\<inter> H\\<times>H = GroupInv(H,g)\"\n    using group0_3_L7A by simp\n  ultimately show ?thesis\n    using func1_2_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 466
    },
    "430": {
        "type": "theorem",
        "text": "text\\<open>A sligtly weaker, but more convenient in applications,\n  reformulation of the above theorem.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \n  and \"g = restrict(P,H\\<times>H)\"\n  ",
        "using": [
            "assms",
            "group0_3_T1",
            "restrict_if"
        ],
        "statement": "theorem (in group0) group0_3_T2: \n  assumes \"IsAsubgroup(H,P)\" \n  and \"g = restrict(P,H\\<times>H)\"\n  shows \"\\<forall>h\\<in>H. GroupInv(H,g)`(h) = h\\<inverse>\"\n  ",
        "proof": "using assms group0_3_T1 restrict_if by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 467
    },
    "431": {
        "type": "theorem",
        "text": "text\\<open>Subgroups are closed with respect to taking the group inverse.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\" and A2: \"h\\<in>H\"\n  ",
        "using": [
            "IsAsubgroup_def",
            "group0_2_T2",
            "apply_type",
            "group0_3_T2"
        ],
        "statement": "theorem (in group0) group0_3_T3A: \n  assumes A1: \"IsAsubgroup(H,P)\" and A2: \"h\\<in>H\"\n  shows \"h\\<inverse>\\<in> H\"\n",
        "proof": "proof -\n  let ?g = \"restrict(P,H\\<times>H)\"\n  from A1 have  \"GroupInv(H,?g) \\<in> H\\<rightarrow>H\"\n    using IsAsubgroup_def group0_2_T2 by simp\n  with A2 have \"GroupInv(H,?g)`(h) \\<in> H\"\n    using apply_type by simp\n  with A1 A2 show \"h\\<inverse>\\<in> H\" using group0_3_T2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 468
    },
    "432": {
        "type": "theorem",
        "text": "text\\<open>The next theorem states that a nonempty subset of \n  a group $G$ that is closed under the group operation and \n  taking the inverse is a subgroup of the group.\\<close>\n",
        "assumes": "assumes A1: \"H\\<noteq>0\"\n  and A2: \"H\\<subseteq>G\"\n  and A3: \"H {is closed under} P\"\n  and A4: \"\\<forall>x\\<in>H. x\\<inverse> \\<in> H\"\n  ",
        "using": [
            "IsOpClosed_def",
            "group0_2_L6",
            "monoid.group0_1_T1",
            "IsAgroup_def",
            "group0_1_L6",
            "restrict_if",
            "IsAsubgroup_def"
        ],
        "statement": "theorem (in group0) group0_3_T3:\n  assumes A1: \"H\\<noteq>0\"\n  and A2: \"H\\<subseteq>G\"\n  and A3: \"H {is closed under} P\"\n  and A4: \"\\<forall>x\\<in>H. x\\<inverse> \\<in> H\"\n  shows \"IsAsubgroup(H,P)\"\n",
        "proof": "proof -\n  let ?g = \"restrict(P,H\\<times>H)\"\n  let ?n = \"TheNeutralElement(H,?g)\"\n  from A3 have I: \"\\<forall>x\\<in>H.\\<forall>y\\<in>H. x\\<cdot>y \\<in> H\"\n    using IsOpClosed_def by simp\n  from A1 obtain x where \"x\\<in>H\" by auto\n  with A4 I A2 have \"\\<one>\\<in>H\"\n    using group0_2_L6 by blast\n  with A3 A2 have T2: \"IsAmonoid(H,?g)\"\n    using monoid.group0_1_T1\n    by simp\n  moreover have \"\\<forall>h\\<in>H.\\<exists>b\\<in>H. ?g`\\<langle>h,b\\<rangle> = ?n\"\n  proof\n    fix h assume \"h\\<in>H\"\n    with A4 A2 have \"h\\<cdot>h\\<inverse> = \\<one>\"\n      using group0_2_L6 by auto\n    moreover from groupAssum A2 A3 \\<open>\\<one>\\<in>H\\<close> have \"\\<one> = ?n\"\n      using IsAgroup_def group0_1_L6 by auto\n    moreover from A4 \\<open>h\\<in>H\\<close> have \"?g`\\<langle>h,h\\<inverse>\\<rangle> = h\\<cdot>h\\<inverse>\"\n      using restrict_if by simp\n    ultimately have \"?g`\\<langle>h,h\\<inverse>\\<rangle> = ?n\" by simp\n    with A4 \\<open>h\\<in>H\\<close> show \"\\<exists>b\\<in>H. ?g`\\<langle>h,b\\<rangle> = ?n\" by auto\n  qed\n  ultimately show \"IsAsubgroup(H,P)\" using \n    IsAsubgroup_def IsAgroup_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 469
    },
    "433": {
        "type": "corollary",
        "text": "text\\<open>The singleton with the neutral element is a subgroup.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L2",
            "group_inv_of_one",
            "group0_3_T3",
            "IsOpClosed_def"
        ],
        "statement": "corollary (in group0) unit_singl_subgr:\n  shows \"IsAsubgroup({\\<one>},P)\"\n  ",
        "proof": "using group0_2_L2 group_inv_of_one group0_3_T3\n  unfolding IsOpClosed_def \n  by auto\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 470
    },
    "434": {
        "type": "lemma",
        "text": "text\\<open>Intersection of subgroups is a subgroup. This lemma is obsolete and should be replaced by \n  \\<open>subgroup_inter\\<close>. \\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,f)\"\n  and A2: \"IsAsubgroup(H\\<^sub>1,f)\"\n  and A3: \"IsAsubgroup(H\\<^sub>2,f)\"\n  ",
        "using": [
            "group0_def",
            "IsAsubgroup_def",
            "group0.group0_3_L5",
            "group0.group0_3_L6",
            "IsOpClosed_def",
            "func_ZF_4_L7",
            "func_ZF_4_L5",
            "group0.group0_3_T2",
            "group0.group0_3_T3A",
            "group0.group0_3_T3"
        ],
        "statement": "lemma group0_3_L7:\n  assumes A1: \"IsAgroup(G,f)\"\n  and A2: \"IsAsubgroup(H\\<^sub>1,f)\"\n  and A3: \"IsAsubgroup(H\\<^sub>2,f)\"\n  shows \"IsAsubgroup(H\\<^sub>1\\<inter>H\\<^sub>2,restrict(f,H\\<^sub>1\\<times>H\\<^sub>1))\"\n",
        "proof": "proof -\n  let ?e = \"TheNeutralElement(G,f)\"\n  let ?g = \"restrict(f,H\\<^sub>1\\<times>H\\<^sub>1)\"\n  from A1 have I: \"group0(G,f)\"\n    using group0_def by simp\n  from A2 have \"group0(H\\<^sub>1,?g)\"\n    using IsAsubgroup_def group0_def by simp\n  moreover have \"H\\<^sub>1\\<inter>H\\<^sub>2 \\<noteq> 0\"\n  proof -\n    from A1 A2 A3 have \"?e \\<in> H\\<^sub>1\\<inter>H\\<^sub>2\"\n      using group0_def group0.group0_3_L5 by simp\n    thus ?thesis by auto\n  qed\n  moreover have \"H\\<^sub>1\\<inter>H\\<^sub>2 \\<subseteq> H\\<^sub>1\" by auto\n  moreover from A2 A3 I \\<open>H\\<^sub>1\\<inter>H\\<^sub>2 \\<subseteq> H\\<^sub>1\\<close> have \n    \"H\\<^sub>1\\<inter>H\\<^sub>2 {is closed under} ?g\"\n    using group0.group0_3_L6 IsOpClosed_def \n      func_ZF_4_L7 func_ZF_4_L5 by simp\n  moreover from A2 A3 I have \n    \"\\<forall>x \\<in> H\\<^sub>1\\<inter>H\\<^sub>2. GroupInv(H\\<^sub>1,?g)`(x) \\<in> H\\<^sub>1\\<inter>H\\<^sub>2\"\n    using group0.group0_3_T2 group0.group0_3_T3A\n    by simp\n  ultimately show ?thesis\n    using group0.group0_3_T3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 471
    },
    "435": {
        "type": "lemma",
        "text": "text\\<open>Intersection of subgroups is a subgroup.\\<close>\n",
        "assumes": "assumes \"\\<H>\\<noteq>0\"\n  and \"\\<forall>H\\<in>\\<H>. IsAsubgroup(H,P)\"\n  ",
        "using": [
            "group0_3_L5",
            "assms(1)",
            "group0_3_L2",
            "assms(2)",
            "group0_3_L6",
            "group0_3_T3A",
            "group0_3_T3"
        ],
        "statement": "lemma (in group0) subgroup_inter: assumes \"\\<H>\\<noteq>0\"\n  and \"\\<forall>H\\<in>\\<H>. IsAsubgroup(H,P)\"\n  shows \"IsAsubgroup(\\<Inter>\\<H>,P)\"\n",
        "proof": "proof -\n  {\n    fix H assume \"H:\\<H>\"\n    with assms(2) have \"\\<one>:H\" using group0_3_L5 by auto\n  }\n  then have \"\\<Inter>\\<H> \\<noteq> 0\" using assms(1) by auto moreover\n  {\n    fix t assume \"t:\\<Inter>\\<H>\"\n    then have \"\\<forall>H\\<in>\\<H>. t:H\" by auto\n    with assms have \"t:G\" using group0_3_L2 by blast\n  }\n  then have \"\\<Inter>\\<H> \\<subseteq> G\" by auto moreover\n  {\n    fix x y assume xy:\"x:\\<Inter>\\<H>\" \"y:\\<Inter>\\<H>\"\n    {\n      fix J assume J:\"J:\\<H>\"\n      with xy have \"x:J\" \"y:J\" by auto\n      with J have \"P`\\<langle>x,y\\<rangle>:J\" using assms(2) group0_3_L6 by auto\n    }\n    then have \"P`\\<langle>x,y\\<rangle>:\\<Inter>\\<H>\" using assms(1) by auto\n  }\n  then have \"\\<Inter>\\<H> {is closed under} P\" unfolding IsOpClosed_def by simp\n  moreover\n  {\n    fix x assume x:\"x:\\<Inter>\\<H>\"\n    {\n      fix J assume J:\"J:\\<H>\"\n      with x have \"x:J\" by auto\n      with J assms(2) have \"x\\<inverse> \\<in> J\" using group0_3_T3A by auto\n    }\n    then have \"x\\<inverse> \\<in> \\<Inter>\\<H>\" using assms(1) by auto\n  }\n  then have \"\\<forall>x \\<in> \\<Inter>\\<H>. x\\<inverse> \\<in> \\<Inter>\\<H>\" by simp\n  ultimately show ?thesis using group0_3_T3 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 472
    },
    "436": {
        "type": "lemma",
        "text": "text\\<open>The range of the subgroup operation is the whole subgroup.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "IsAsubgroup_def",
            "IsAgroup_def",
            "monoid0_def"
        ],
        "statement": "lemma image_subgr_op: assumes A1: \"IsAsubgroup(H,P)\"\n  shows \"restrict(P,H\\<times>H)``(H\\<times>H) = H\"\n",
        "proof": "proof -\n  from A1 have \"monoid0(H,restrict(P,H\\<times>H))\"\n    using IsAsubgroup_def IsAgroup_def monoid0_def \n    by simp\n  then show ?thesis by (rule monoid0.range_carr)\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 473
    },
    "437": {
        "type": "lemma",
        "text": "text\\<open>If we restrict the inverse to a subgroup, then the restricted \n  inverse is onto the subgroup.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "IsAsubgroup_def",
            "group0_def",
            "group0.group_inv_surj",
            "group0_3_T1"
        ],
        "statement": "lemma (in group0) restr_inv_onto: assumes A1: \"IsAsubgroup(H,P)\"\n  shows \"restrict(GroupInv(G,P),H)``(H) = H\"\n",
        "proof": "proof -\n  from A1 have \"GroupInv(H,restrict(P,H\\<times>H))``(H) = H\"\n    using IsAsubgroup_def group0_def group0.group_inv_surj\n    by simp\n  with A1 show ?thesis using group0_3_T1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 474
    },
    "438": {
        "type": "lemma",
        "text": "text\\<open>A union of two subgroups is a subgroup iff \n  one of the subgroups is a subset of the other subgroup.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H\\<^sub>1,P)\" and \"IsAsubgroup(H\\<^sub>2,P)\"\n  ",
        "using": [
            "group0_3_T3A",
            "group0_3_L6",
            "group0_3_L2",
            "inv_cancel_two(2,3)"
        ],
        "statement": "lemma (in group0) union_subgroups: \n  assumes \"IsAsubgroup(H\\<^sub>1,P)\" and \"IsAsubgroup(H\\<^sub>2,P)\"\n  shows \"IsAsubgroup(H\\<^sub>1\\<union>H\\<^sub>2,P) \\<longleftrightarrow> (H\\<^sub>1\\<subseteq>H\\<^sub>2 \\<or> H\\<^sub>2\\<subseteq>H\\<^sub>1)\"\n",
        "proof": "proof \n  assume \"H\\<^sub>1\\<subseteq>H\\<^sub>2 \\<or> H\\<^sub>2\\<subseteq>H\\<^sub>1\" show \"IsAsubgroup(H\\<^sub>1\\<union>H\\<^sub>2,P)\"\n  proof -\n    from \\<open>H\\<^sub>1\\<subseteq>H\\<^sub>2 \\<or> H\\<^sub>2\\<subseteq>H\\<^sub>1\\<close> have \"H\\<^sub>2 = H\\<^sub>1\\<union>H\\<^sub>2 \\<or> H\\<^sub>1 = H\\<^sub>1\\<union>H\\<^sub>2\" by auto\n    with assms show \"IsAsubgroup(H\\<^sub>1\\<union>H\\<^sub>2,P)\" by auto\n  qed\nnext\n  assume \"IsAsubgroup(H\\<^sub>1\\<union>H\\<^sub>2, P)\" show \"H\\<^sub>1\\<subseteq>H\\<^sub>2 \\<or> H\\<^sub>2\\<subseteq>H\\<^sub>1\"\n  proof -\n    { assume \"\\<not> H\\<^sub>1\\<subseteq>H\\<^sub>2\"\n      then obtain x where \"x\\<in>H\\<^sub>1\" and \"x\\<notin>H\\<^sub>2\" by auto\n      with assms(1) have \"x\\<inverse> \\<in> H\\<^sub>1\" using group0_3_T3A by simp\n      { fix y assume \"y\\<in>H\\<^sub>2\"\n        let ?z = \"x\\<cdot>y\"\n        from \\<open>x\\<in>H\\<^sub>1\\<close> \\<open>y\\<in>H\\<^sub>2\\<close> have \"x \\<in> H\\<^sub>1\\<union>H\\<^sub>2\" and \"y \\<in> H\\<^sub>1\\<union>H\\<^sub>2\" by auto\n        with \\<open>IsAsubgroup(H\\<^sub>1\\<union>H\\<^sub>2,P)\\<close> have \"?z \\<in> H\\<^sub>1\\<union>H\\<^sub>2\" using group0_3_L6 by blast\n        from assms \\<open>x \\<in> H\\<^sub>1\\<union>H\\<^sub>2\\<close>  \\<open>y\\<in>H\\<^sub>2\\<close> have \"x\\<in>G\" \"y\\<in>G\" and \"y\\<inverse>\\<in>H\\<^sub>2\"\n          using group0_3_T3A group0_3_L2 by auto\n        then have \"?z\\<cdot>y\\<inverse> = x\" and \"x\\<inverse>\\<cdot>?z = y\" using inv_cancel_two(2,3) by auto\n        { assume \"?z \\<in> H\\<^sub>2\"\n          with \\<open>IsAsubgroup(H\\<^sub>2,P)\\<close> \\<open>y\\<inverse>\\<in>H\\<^sub>2\\<close> have \"?z\\<cdot>y\\<inverse> \\<in> H\\<^sub>2\" using group0_3_L6 by simp\n          with \\<open>?z\\<cdot>y\\<inverse> = x\\<close> \\<open>x\\<notin>H\\<^sub>2\\<close> have False by auto\n        } hence \"?z \\<notin> H\\<^sub>2\" by auto\n        with assms(1) \\<open>x\\<inverse> \\<in> H\\<^sub>1\\<close> \\<open>?z \\<in> H\\<^sub>1\\<union>H\\<^sub>2\\<close> have \"x\\<inverse>\\<cdot>?z \\<in> H\\<^sub>1\" using group0_3_L6 by simp\n        with \\<open>x\\<inverse>\\<cdot>?z = y\\<close> have \"y\\<in>H\\<^sub>1\" by simp\n      } hence \"H\\<^sub>2\\<subseteq>H\\<^sub>1\" by blast\n    } thus ?thesis by blast\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 475
    },
    "439": {
        "type": "lemma",
        "text": "text\\<open>Transitivity for \"is a subgroup of\" relation. The proof (probably) uses the lemma \n  \\<open>restrict_restrict\\<close> from standard Isabelle/ZF library which states that \n  \\<open>restrict(restrict(f,A),B) = restrict(f,A\\<inter>B)\\<close>. That lemma is added to the simplifier, so it does\n  not have to be referenced explicitly in the proof below. \\<close>\n",
        "assumes": "assumes \"IsAgroup(G\\<^sub>3,P)\" \"IsAsubgroup(G\\<^sub>2,P)\" \"IsAsubgroup(G\\<^sub>1,restrict(P,G\\<^sub>2\\<times>G\\<^sub>2))\"\n  ",
        "using": [
            "group0.group0_3_L2"
        ],
        "statement": "lemma subgroup_transitive: \n  assumes \"IsAgroup(G\\<^sub>3,P)\" \"IsAsubgroup(G\\<^sub>2,P)\" \"IsAsubgroup(G\\<^sub>1,restrict(P,G\\<^sub>2\\<times>G\\<^sub>2))\"\n  shows \"IsAsubgroup(G\\<^sub>1,P)\"\n",
        "proof": "proof -\n  from assms(2) have \"group0(G\\<^sub>2,restrict(P,G\\<^sub>2\\<times>G\\<^sub>2))\" unfolding IsAsubgroup_def group0_def by simp\n  with assms(3) have \"G\\<^sub>1\\<subseteq>G\\<^sub>2\" using group0.group0_3_L2 by simp\n  hence \"G\\<^sub>2\\<times>G\\<^sub>2 \\<inter> G\\<^sub>1\\<times>G\\<^sub>1 = G\\<^sub>1\\<times>G\\<^sub>1\" by auto\n  with assms(3) show \"IsAsubgroup(G\\<^sub>1,P)\" unfolding IsAsubgroup_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 476
    },
    "440": {
        "type": "lemma",
        "text": "text\\<open> Groups have left and right division. \\<close>\n",
        "assumes": "",
        "using": [
            "group_op_closed",
            "inverse_in_group",
            "inv_cancel_two(4)",
            "cancel_left",
            "inv_cancel_two(1)",
            "cancel_right"
        ],
        "statement": "lemma (in group0) gr_has_lr_div: shows \"HasLeftDiv(G,P)\" and \"HasRightDiv(G,P)\"\n",
        "proof": "proof -\n  { fix x y assume \"x\\<in>G\" \"y\\<in>G\" \n    then have \"x\\<inverse>\\<cdot>y \\<in> G \\<and> x\\<cdot>(x\\<inverse>\\<cdot>y) = y\" using group_op_closed inverse_in_group inv_cancel_two(4)\n      by simp\n    hence \"\\<exists>z. z\\<in>G \\<and> x\\<cdot>z =y\" by auto\n    moreover \n    { fix z\\<^sub>1 z\\<^sub>2 assume \"z\\<^sub>1\\<in>G \\<and> x\\<cdot>z\\<^sub>1 =y\" and \"z\\<^sub>2\\<in>G \\<and> x\\<cdot>z\\<^sub>2 =y\"\n      with \\<open>x\\<in>G\\<close> have \"z\\<^sub>1 = z\\<^sub>2\" using cancel_left by blast\n    }\n    ultimately have \"\\<exists>!z. z\\<in>G \\<and> x\\<cdot>z =y\" by auto\n  } then show \"HasLeftDiv(G,P)\" unfolding HasLeftDiv_def by simp\n  { fix x y assume \"x\\<in>G\" \"y\\<in>G\" \n    then have \"y\\<cdot>x\\<inverse> \\<in> G \\<and> (y\\<cdot>x\\<inverse>)\\<cdot>x = y\" using group_op_closed inverse_in_group inv_cancel_two(1)\n      by simp\n    hence \"\\<exists>z. z\\<in>G \\<and> z\\<cdot>x =y\" by auto\n    moreover \n    { fix z\\<^sub>1 z\\<^sub>2 assume \"z\\<^sub>1\\<in>G \\<and> z\\<^sub>1\\<cdot>x =y\" and \"z\\<^sub>2\\<in>G \\<and> z\\<^sub>2\\<cdot>x =y\"\n      with \\<open>x\\<in>G\\<close> have \"z\\<^sub>1 = z\\<^sub>2\" using cancel_right by blast\n    }\n    ultimately have \"\\<exists>!z. z\\<in>G \\<and> z\\<cdot>x =y\" by auto\n  } then show \"HasRightDiv(G,P)\" unfolding HasRightDiv_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 477
    },
    "441": {
        "type": "lemma",
        "text": "text\\<open>A group is a quasigroup and a loop.\\<close>\n",
        "assumes": "",
        "using": [
            "gr_has_lr_div",
            "group_oper_fun",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group_is_loop: shows \"IsAquasigroup(G,P)\" and \"IsAloop(G,P)\"\n",
        "proof": "proof -\n  show \"IsAquasigroup(G,P)\" unfolding IsAquasigroup_def HasLatinSquareProp_def\n    using gr_has_lr_div group_oper_fun by simp\n  then show \"IsAloop(G,P)\" unfolding IsAloop_def using group0_2_L2 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 478
    },
    "442": {
        "type": "theorem",
        "text": "text\\<open> An associative loop is a group.\\<close>\n",
        "assumes": "assumes \"IsAloop(G,P)\" and \"P {is associative on} G\"\n  ",
        "using": [
            "loop_loop0_valid",
            "loop0.lr_inv_props(3,4)"
        ],
        "statement": "theorem assoc_loop_is_gr: assumes \"IsAloop(G,P)\" and \"P {is associative on} G\"\n  shows \"IsAgroup(G,P)\" \n",
        "proof": "proof -\n  from assms(1) have \"\\<exists>e\\<in>G. \\<forall>x\\<in>G. P`\\<langle>e,x\\<rangle> = x \\<and> P`\\<langle>x,e\\<rangle> = x\"\n    unfolding IsAloop_def by simp\n  with assms(2) have \"IsAmonoid(G,P)\" unfolding IsAmonoid_def by simp\n  { fix x assume \"x\\<in>G\" \n    let ?y = \"RightInv(G,P)`(x)\"\n    from assms(1) \\<open>x\\<in>G\\<close> have \"?y \\<in> G\" and \"P`\\<langle>x,?y\\<rangle> = TheNeutralElement(G,P)\"\n      using loop_loop0_valid loop0.lr_inv_props(3,4) by auto\n    hence \"\\<exists>y\\<in>G. P`\\<langle>x,y\\<rangle> = TheNeutralElement(G,P)\" by auto\n  }\n  with \\<open>IsAmonoid(G,P)\\<close> show \"IsAgroup(G,P)\" unfolding IsAgroup_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 479
    },
    "443": {
        "type": "lemma",
        "text": "text\\<open>For groups the left and right inverse are the same as the group inverse. \\<close>\n",
        "assumes": "",
        "using": [
            "group_is_loop",
            "loop_loop0_valid",
            "loop0.lr_inv_fun(1)",
            "group0_2_T2",
            "group_is_loop(2)",
            "loop0.lr_inv_props(1,2)",
            "group0_2_L9(1)",
            "func_eq",
            "loop0.lr_inv_fun(2)",
            "loop0.lr_inv_props(3,4)",
            "group0_2_L9(2)"
        ],
        "statement": "lemma (in group0) lr_inv_gr_inv: \n  shows \"LeftInv(G,P) = GroupInv(G,P)\" and \"RightInv(G,P) = GroupInv(G,P)\"\n",
        "proof": "proof -\n  have \"LeftInv(G,P):G\\<rightarrow>G\" using group_is_loop loop_loop0_valid loop0.lr_inv_fun(1)\n    by simp\n  moreover from groupAssum have \"GroupInv(G,P):G\\<rightarrow>G\" using group0_2_T2 by simp\n  moreover\n  { fix x assume \"x\\<in>G\"\n    let ?y = \"LeftInv(G,P)`(x)\"\n    from \\<open>x\\<in>G\\<close> have \"?y \\<in> G\" and \"?y\\<cdot>x = \\<one>\"\n      using group_is_loop(2) loop_loop0_valid loop0.lr_inv_props(1,2) by auto\n    with \\<open>x\\<in>G\\<close> have \"LeftInv(G,P)`(x) = GroupInv(G,P)`(x)\" using group0_2_L9(1) by simp\n  }\n  ultimately show \"LeftInv(G,P) = GroupInv(G,P)\" using func_eq by blast\n  have \"RightInv(G,P):G\\<rightarrow>G\" using group_is_loop loop_loop0_valid loop0.lr_inv_fun(2)\n    by simp\n  moreover from groupAssum have \"GroupInv(G,P):G\\<rightarrow>G\" using group0_2_T2 by simp\n  moreover\n  { fix x assume \"x\\<in>G\"\n    let ?y = \"RightInv(G,P)`(x)\"\n    from \\<open>x\\<in>G\\<close> have \"?y \\<in> G\" and \"x\\<cdot>?y = \\<one>\"\n      using group_is_loop(2) loop_loop0_valid loop0.lr_inv_props(3,4) by auto\n    with \\<open>x\\<in>G\\<close> have \"RightInv(G,P)`(x) = GroupInv(G,P)`(x)\" using group0_2_L9(2) by simp\n  }\n  ultimately show \"RightInv(G,P) = GroupInv(G,P)\" using func_eq by blast  \nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 480
    },
    "444": {
        "type": "definition",
        "text": "text\\<open>A similar definition of the left translation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"LeftTranslation(G,P,g) \\<equiv> {\\<langle>a,b\\<rangle> \\<in> G\\<times>G. P`\\<langle>g,a\\<rangle> = b}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 482
    },
    "445": {
        "type": "lemma",
        "text": "text\\<open>Translations map $G$ into $G$. Two dimensional translations map\n  $G\\times G$ into itself.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\"\n  ",
        "using": [
            "group_oper_fun",
            "apply_funtype",
            "RightTranslation_def",
            "LeftTranslation_def",
            "func1_1_L11A"
        ],
        "statement": "lemma (in group0) group0_5_L1: assumes A1: \"g\\<in>G\"\n  shows \"RightTranslation(G,P,g) : G\\<rightarrow>G\" and  \"LeftTranslation(G,P,g) : G\\<rightarrow>G\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>a\\<in>G. a\\<cdot>g \\<in> G\" and \"\\<forall>a\\<in>G. g\\<cdot>a \\<in> G\"\n    using group_oper_fun apply_funtype by auto\n  then show \n    \"RightTranslation(G,P,g) : G\\<rightarrow>G\" \n    \"LeftTranslation(G,P,g) : G\\<rightarrow>G\"\n    using RightTranslation_def LeftTranslation_def func1_1_L11A\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 483
    },
    "446": {
        "type": "lemma",
        "text": "text\\<open>The values of the translations are what we expect.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" \"a\\<in>G\"\n  ",
        "using": [
            "assms",
            "group0_5_L1",
            "RightTranslation_def",
            "LeftTranslation_def",
            "func1_1_L11B"
        ],
        "statement": "lemma (in group0) group0_5_L2: assumes \"g\\<in>G\" \"a\\<in>G\"\n  shows \n  \"RightTranslation(G,P,g)`(a) = a\\<cdot>g\"\n  \"LeftTranslation(G,P,g)`(a) = g\\<cdot>a\"\n  ",
        "proof": "using assms group0_5_L1 RightTranslation_def LeftTranslation_def\n    func1_1_L11B by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 484
    },
    "447": {
        "type": "lemma",
        "text": "text\\<open>Composition of right translations is a right translation by \n  the product.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" \"h\\<in>G\" \"a\\<in>G\" and \n  A2: \"T\\<^sub>g = RightTranslation(G,P,g)\"  \"T\\<^sub>h = RightTranslation(G,P,h)\"\n  ",
        "using": [
            "group_oper_fun",
            "apply_funtype",
            "group0_5_L2",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) group0_5_L5: assumes A1: \"g\\<in>G\" \"h\\<in>G\" \"a\\<in>G\" and \n  A2: \"T\\<^sub>g = RightTranslation(G,P,g)\"  \"T\\<^sub>h = RightTranslation(G,P,h)\"\n  shows \n \"T\\<^sub>g`(T\\<^sub>h`(a)) = a\\<cdot>h\\<cdot>g\"\n  \"T\\<^sub>g`(T\\<^sub>h`(a)) = RightTranslation(G,P,h\\<cdot>g)`(a)\"\n",
        "proof": "proof -\n  from A1 have I: \"a\\<cdot>h\\<in>G\" \"h\\<cdot>g \\<in>G\"\n    using group_oper_fun apply_funtype by auto\n  with A1 A2 show \"T\\<^sub>g`(T\\<^sub>h`(a)) = a\\<cdot>h\\<cdot>g\" \n    using group0_5_L2 group_oper_assoc by simp\n  with A1 A2 I show \n    \"T\\<^sub>g`(T\\<^sub>h`(a)) = RightTranslation(G,P,h\\<cdot>g)`(a)\"\n    using group0_5_L2 group_oper_assoc by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 486
    },
    "448": {
        "type": "lemma",
        "text": "text\\<open>Point free version of \\<open>group0_5_L4\\<close> and \\<open>group0_5_L5\\<close>.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" \"h\\<in>G\" ",
        "using": [
            "group0_5_L1",
            "comp_fun",
            "group_op_closed",
            "comp_fun_apply",
            "group0_5_L5",
            "group0_5_L4"
        ],
        "statement": "lemma (in group0) trans_comp: assumes \"g\\<in>G\" \"h\\<in>G\" shows\n  \"RightTranslation(G,P,g) O RightTranslation(G,P,h) = RightTranslation(G,P,h\\<cdot>g)\"\n  \"LeftTranslation(G,P,g) O LeftTranslation(G,P,h) = LeftTranslation(G,P,g\\<cdot>h)\"\n",
        "proof": "proof -\n  let ?T\\<^sub>g = \"RightTranslation(G,P,g)\"\n  let ?T\\<^sub>h = \"RightTranslation(G,P,h)\"\n  from assms have \"?T\\<^sub>g:G\\<rightarrow>G\" and \"?T\\<^sub>h:G\\<rightarrow>G\"\n    using group0_5_L1 by auto\n  then have \"?T\\<^sub>g O ?T\\<^sub>h:G\\<rightarrow>G\" using comp_fun by simp\n  moreover from assms have \"RightTranslation(G,P,h\\<cdot>g):G\\<rightarrow>G\"\n    using group_op_closed group0_5_L1 by simp\n  moreover from assms \\<open>?T\\<^sub>h:G\\<rightarrow>G\\<close> have \n    \"\\<forall>a\\<in>G. (?T\\<^sub>g O ?T\\<^sub>h)`(a) = RightTranslation(G,P,h\\<cdot>g)`(a)\"\n    using comp_fun_apply group0_5_L5 by simp\n  ultimately show \"?T\\<^sub>g O ?T\\<^sub>h =  RightTranslation(G,P,h\\<cdot>g)\"\n    by (rule func_eq)\nnext\n  let ?T\\<^sub>g = \"LeftTranslation(G,P,g)\"\n  let ?T\\<^sub>h = \"LeftTranslation(G,P,h)\"\n  from assms have \"?T\\<^sub>g:G\\<rightarrow>G\" and \"?T\\<^sub>h:G\\<rightarrow>G\"\n    using group0_5_L1 by auto\n  then have \"?T\\<^sub>g O ?T\\<^sub>h:G\\<rightarrow>G\" using comp_fun by simp\n  moreover from assms have \"LeftTranslation(G,P,g\\<cdot>h):G\\<rightarrow>G\"\n    using group_op_closed group0_5_L1 by simp\n  moreover from assms \\<open>?T\\<^sub>h:G\\<rightarrow>G\\<close> have \n    \"\\<forall>a\\<in>G. (?T\\<^sub>g O ?T\\<^sub>h)`(a) = LeftTranslation(G,P,g\\<cdot>h)`(a)\"\n    using comp_fun_apply group0_5_L4 by simp\n  ultimately show \"?T\\<^sub>g O ?T\\<^sub>h =  LeftTranslation(G,P,g\\<cdot>h)\"\n    by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 487
    },
    "449": {
        "type": "lemma",
        "text": "text\\<open>Another form of the image of a set under a composition of translations\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" \"h\\<in>G\" and A2: \"A\\<subseteq>G\" and \n  A3: \"T\\<^sub>g = RightTranslation(G,P,g)\"  \"T\\<^sub>h = RightTranslation(G,P,h)\"\n  ",
        "using": [
            "group0_5_L1",
            "func1_1_L15C",
            "group0_5_L5"
        ],
        "statement": "lemma (in group0) group0_5_L6: \n  assumes A1: \"g\\<in>G\" \"h\\<in>G\" and A2: \"A\\<subseteq>G\" and \n  A3: \"T\\<^sub>g = RightTranslation(G,P,g)\"  \"T\\<^sub>h = RightTranslation(G,P,h)\"\n  shows \"T\\<^sub>g``(T\\<^sub>h``(A)) = {a\\<cdot>h\\<cdot>g. a\\<in>A}\"\n",
        "proof": "proof -\n  from A2 have \"\\<forall>a\\<in>A. a\\<in>G\" by auto\n  from A1 A3 have \"T\\<^sub>g : G\\<rightarrow>G\"  \"T\\<^sub>h : G\\<rightarrow>G\"\n    using group0_5_L1 by auto\n  with assms \\<open>\\<forall>a\\<in>A. a\\<in>G\\<close> show \n    \"T\\<^sub>g``(T\\<^sub>h``(A)) = {a\\<cdot>h\\<cdot>g. a\\<in>A}\"\n    using func1_1_L15C group0_5_L5 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 489
    },
    "450": {
        "type": "lemma",
        "text": "text\\<open>The translation by neutral element is the identity on group.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L2",
            "group0_5_L1",
            "group0_5_L2"
        ],
        "statement": "lemma (in group0) trans_neutral: shows \n  \"RightTranslation(G,P,\\<one>) = id(G)\" and \"LeftTranslation(G,P,\\<one>) = id(G)\"\n",
        "proof": "proof -\n  have \"RightTranslation(G,P,\\<one>):G\\<rightarrow>G\" and \"\\<forall>a\\<in>G. RightTranslation(G,P,\\<one>)`(a) = a\"\n    using group0_2_L2 group0_5_L1 group0_5_L2  by auto\n  then show \"RightTranslation(G,P,\\<one>) = id(G)\" by (rule indentity_fun)\n  have \"LeftTranslation(G,P,\\<one>):G\\<rightarrow>G\" and \"\\<forall>a\\<in>G. LeftTranslation(G,P,\\<one>)`(a) = a\"\n    using group0_2_L2 group0_5_L1 group0_5_L2  by auto\n  then show \"LeftTranslation(G,P,\\<one>) = id(G)\" by (rule indentity_fun)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 490
    },
    "451": {
        "type": "lemma",
        "text": "text\\<open>Translation by neutral element does not move sets. \\<close>\n",
        "assumes": "assumes \"V\\<subseteq>G\"\n  ",
        "using": [
            "assms",
            "trans_neutral",
            "image_id_same"
        ],
        "statement": "lemma (in group0) trans_neutral_image: assumes \"V\\<subseteq>G\"\n  shows \"RightTranslation(G,P,\\<one>)``(V) = V\" and \"LeftTranslation(G,P,\\<one>)``(V) = V\"\n  ",
        "proof": "using assms trans_neutral image_id_same by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 491
    },
    "452": {
        "type": "lemma",
        "text": "text\\<open>Composition of translations by an element and its inverse is identity.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "assms",
            "inverse_in_group",
            "trans_comp",
            "group0_2_L6",
            "trans_neutral"
        ],
        "statement": "lemma (in group0) trans_comp_id: assumes \"g\\<in>G\" shows\n  \"RightTranslation(G,P,g) O RightTranslation(G,P,g\\<inverse>) = id(G)\" and\n  \"RightTranslation(G,P,g\\<inverse>) O RightTranslation(G,P,g) = id(G)\" and\n  \"LeftTranslation(G,P,g) O LeftTranslation(G,P,g\\<inverse>) = id(G)\" and\n  \"LeftTranslation(G,P,g\\<inverse>) O LeftTranslation(G,P,g) = id(G)\"\n  ",
        "proof": "using assms inverse_in_group trans_comp group0_2_L6 trans_neutral by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 492
    },
    "453": {
        "type": "lemma",
        "text": "text\\<open>Translations are bijective.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "inverse_in_group",
            "group0_5_L1",
            "trans_comp_id",
            "fg_imp_bijective"
        ],
        "statement": "lemma (in group0) trans_bij: assumes \"g\\<in>G\" shows\n  \"RightTranslation(G,P,g) \\<in> bij(G,G)\" and \"LeftTranslation(G,P,g) \\<in> bij(G,G)\"\n",
        "proof": "proof-\n  from assms have \n    \"RightTranslation(G,P,g):G\\<rightarrow>G\" and\n    \"RightTranslation(G,P,g\\<inverse>):G\\<rightarrow>G\" and\n    \"RightTranslation(G,P,g) O RightTranslation(G,P,g\\<inverse>) = id(G)\"\n    \"RightTranslation(G,P,g\\<inverse>) O RightTranslation(G,P,g) = id(G)\"\n  using inverse_in_group group0_5_L1 trans_comp_id by auto\n  then show \"RightTranslation(G,P,g) \\<in> bij(G,G)\" using fg_imp_bijective by simp\n  from assms have \n    \"LeftTranslation(G,P,g):G\\<rightarrow>G\" and\n    \"LeftTranslation(G,P,g\\<inverse>):G\\<rightarrow>G\" and\n    \"LeftTranslation(G,P,g) O LeftTranslation(G,P,g\\<inverse>) = id(G)\"\n    \"LeftTranslation(G,P,g\\<inverse>) O LeftTranslation(G,P,g) = id(G)\"\n    using inverse_in_group group0_5_L1 trans_comp_id by auto\n  then show \"LeftTranslation(G,P,g) \\<in> bij(G,G)\" using fg_imp_bijective by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 493
    },
    "454": {
        "type": "lemma",
        "text": "text\\<open>Converse of a translation is translation by the inverse.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "trans_bij",
            "inverse_in_group",
            "trans_comp_id",
            "comp_id_conv"
        ],
        "statement": "lemma (in group0) trans_conv_inv: assumes \"g\\<in>G\" shows\n  \"converse(RightTranslation(G,P,g)) = RightTranslation(G,P,g\\<inverse>)\" and\n  \"converse(LeftTranslation(G,P,g)) = LeftTranslation(G,P,g\\<inverse>)\" and\n  \"LeftTranslation(G,P,g) = converse(LeftTranslation(G,P,g\\<inverse>))\" and\n  \"RightTranslation(G,P,g) = converse(RightTranslation(G,P,g\\<inverse>))\"\n",
        "proof": "proof -\n  from assms have\n    \"RightTranslation(G,P,g) \\<in> bij(G,G)\"  \"RightTranslation(G,P,g\\<inverse>) \\<in> bij(G,G)\" and\n    \"LeftTranslation(G,P,g) \\<in> bij(G,G)\"  \"LeftTranslation(G,P,g\\<inverse>) \\<in> bij(G,G)\"\n    using trans_bij inverse_in_group by auto\n  moreover from assms have\n    \"RightTranslation(G,P,g\\<inverse>) O RightTranslation(G,P,g) = id(G)\" and\n    \"LeftTranslation(G,P,g\\<inverse>) O LeftTranslation(G,P,g) = id(G)\" and\n    \"LeftTranslation(G,P,g) O LeftTranslation(G,P,g\\<inverse>) = id(G)\" and\n    \"LeftTranslation(G,P,g\\<inverse>) O LeftTranslation(G,P,g) = id(G)\"\n    using trans_comp_id by auto\n  ultimately show \n    \"converse(RightTranslation(G,P,g)) = RightTranslation(G,P,g\\<inverse>)\" and\n    \"converse(LeftTranslation(G,P,g)) = LeftTranslation(G,P,g\\<inverse>)\" and  \n    \"LeftTranslation(G,P,g) = converse(LeftTranslation(G,P,g\\<inverse>))\" and\n    \"RightTranslation(G,P,g) = converse(RightTranslation(G,P,g\\<inverse>))\"\n    using comp_id_conv by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 494
    },
    "455": {
        "type": "lemma",
        "text": "text\\<open>The image of a set by translation is the same as the inverse image by\nby the inverse element translation.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "assms",
            "trans_conv_inv",
            "vimage_converse"
        ],
        "statement": "lemma (in group0) trans_image_vimage: assumes \"g\\<in>G\" shows\n  \"LeftTranslation(G,P,g)``(A) = LeftTranslation(G,P,g\\<inverse>)-``(A)\" and\n  \"RightTranslation(G,P,g)``(A) = RightTranslation(G,P,g\\<inverse>)-``(A)\"\n  ",
        "proof": "using assms trans_conv_inv vimage_converse by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 495
    },
    "456": {
        "type": "lemma",
        "text": "text\\<open>Another way of looking at translations is that they are sections\n  of the group operation.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "group0_5_L1",
            "group_oper_fun",
            "fix_2nd_var_fun",
            "group0_5_L2",
            "fix_var_val",
            "fix_1st_var_fun"
        ],
        "statement": "lemma (in group0) trans_eq_section: assumes \"g\\<in>G\" shows\n  \"RightTranslation(G,P,g) = Fix2ndVar(P,g)\" and\n  \"LeftTranslation(G,P,g) =  Fix1stVar(P,g)\"\n",
        "proof": "proof -\n  let ?T = \"RightTranslation(G,P,g)\"\n  let ?F = \"Fix2ndVar(P,g)\"\n  from assms have \"?T: G\\<rightarrow>G\" and \"?F: G\\<rightarrow>G\"\n    using group0_5_L1 group_oper_fun fix_2nd_var_fun by auto\n  moreover from assms have \"\\<forall>a\\<in>G. ?T`(a) = ?F`(a)\"\n    using group0_5_L2 group_oper_fun fix_var_val by simp\n  ultimately show \"?T = ?F\" by (rule func_eq)\nnext\n  let ?T = \"LeftTranslation(G,P,g)\"\n  let ?F = \"Fix1stVar(P,g)\"\n  from assms have \"?T: G\\<rightarrow>G\" and \"?F: G\\<rightarrow>G\"\n    using group0_5_L1 group_oper_fun fix_1st_var_fun by auto\n  moreover from assms have \"\\<forall>a\\<in>G. ?T`(a) = ?F`(a)\"\n    using group0_5_L2 group_oper_fun fix_var_val by simp\n  ultimately show \"?T = ?F\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 496
    },
    "457": {
        "type": "lemma",
        "text": "text\\<open>A lemma demonstrating what is the left translation of a set\\<close>\n",
        "assumes": "assumes A1: \"V\\<subseteq>G\" and A2: \"x\\<in>G\"\n  ",
        "using": [
            "group0_5_L1",
            "func_imagedef",
            "group0_5_L2"
        ],
        "statement": "lemma (in group0) ltrans_image: assumes A1: \"V\\<subseteq>G\" and A2: \"x\\<in>G\"\n  shows \"LeftTranslation(G,P,x)``(V) = {x\\<cdot>v. v\\<in>V}\"\n",
        "proof": "proof -\n  from assms have \"LeftTranslation(G,P,x)``(V) = {LeftTranslation(G,P,x)`(v). v\\<in>V}\"\n    using group0_5_L1 func_imagedef by blast\n  moreover from assms have \"\\<forall>v\\<in>V. LeftTranslation(G,P,x)`(v) = x\\<cdot>v\"\n    using group0_5_L2 by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 497
    },
    "458": {
        "type": "lemma",
        "text": "text\\<open>Right and left translations of a set are subsets of the group. \n  Interestingly, we do not have to assume the set is a subset of the group. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\"\n  ",
        "using": [
            "group0_5_L1",
            "func1_1_L6(2)"
        ],
        "statement": "lemma (in group0) lrtrans_in_group: assumes \"x\\<in>G\"\n  shows \"LeftTranslation(G,P,x)``(V) \\<subseteq> G\" and \"RightTranslation(G,P,x)``(V) \\<subseteq> G\" \n",
        "proof": "proof -\n  from assms have \"LeftTranslation(G,P,x):G\\<rightarrow>G\" and \"RightTranslation(G,P,x):G\\<rightarrow>G\"\n    using group0_5_L1 by auto\n  then show \"LeftTranslation(G,P,x)``(V) \\<subseteq> G\" and \"RightTranslation(G,P,x)``(V) \\<subseteq> G\"\n    using func1_1_L6(2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 499
    },
    "459": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about solving equations with translations.\\<close>\n",
        "assumes": "assumes A1: \"V\\<subseteq>G\" and A2: \"y\\<in>G\" and\n  A3: \"x \\<in> LeftTranslation(G,P,y)``(GroupInv(G,P)``(V))\"\n  ",
        "using": [
            "group0_5_L1",
            "func1_1_L6",
            "groupAssum",
            "group0_2_T2",
            "ltrans_image",
            "func_imagedef",
            "inv_cancel_two"
        ],
        "statement": "lemma (in group0) ltrans_inv_in: assumes A1: \"V\\<subseteq>G\" and A2: \"y\\<in>G\" and\n  A3: \"x \\<in> LeftTranslation(G,P,y)``(GroupInv(G,P)``(V))\"\n  shows \"y \\<in> LeftTranslation(G,P,x)``(V)\"\n",
        "proof": "proof -\n  have \"x\\<in>G\"\n  proof -\n    from A2 have \"LeftTranslation(G,P,y):G\\<rightarrow>G\" using group0_5_L1 by simp\n    then have \"LeftTranslation(G,P,y)``(GroupInv(G,P)``(V)) \\<subseteq> G\"\n      using func1_1_L6 by simp\n    with A3 show \"x\\<in>G\" by auto\n  qed\n  have \"\\<exists>v\\<in>V. x = y\\<cdot>v\\<inverse>\"\n  proof -\n    have \"GroupInv(G,P): G\\<rightarrow>G\" using groupAssum group0_2_T2\n      by simp\n    with assms obtain z where \"z \\<in> GroupInv(G,P)``(V)\" and \"x = y\\<cdot>z\"\n      using func1_1_L6 ltrans_image by auto\n    with A1 \\<open>GroupInv(G,P): G\\<rightarrow>G\\<close> show ?thesis using func_imagedef by auto\n  qed\n  then obtain v where \"v\\<in>V\" and \"x = y\\<cdot>v\\<inverse>\" by auto\n  with A1 A2 have \"y = x\\<cdot>v\" using inv_cancel_two by auto\n  with assms \\<open>x\\<in>G\\<close> \\<open>v\\<in>V\\<close> show ?thesis using ltrans_image by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 500
    },
    "460": {
        "type": "lemma",
        "text": "text\\<open>We can look at the result of interval arithmetic operation as union of\n  left translated sets.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" ",
        "using": [
            "group_oper_fun",
            "lift_subsets_explained",
            "ltrans_image"
        ],
        "statement": "lemma (in group0) image_ltrans_union: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" shows\n  \"(P {lifted to subsets of} G)`\\<langle>A,B\\<rangle> = (\\<Union>a\\<in>A.  LeftTranslation(G,P,a)``(B))\"\n",
        "proof": "proof\n  from assms have I: \"(P {lifted to subsets of} G)`\\<langle>A,B\\<rangle> = {a\\<cdot>b . \\<langle>a,b\\<rangle> \\<in> A\\<times>B}\"\n    using group_oper_fun lift_subsets_explained by simp\n  { fix c assume \"c \\<in> (P {lifted to subsets of} G)`\\<langle>A,B\\<rangle>\"\n    with I obtain a b where \"c = a\\<cdot>b\" and \"a\\<in>A\"  \"b\\<in>B\" by auto\n    hence \"c \\<in> {a\\<cdot>b. b\\<in>B}\" by auto\n    moreover from assms \\<open>a\\<in>A\\<close> have \n      \"LeftTranslation(G,P,a)``(B) = {a\\<cdot>b. b\\<in>B}\" using ltrans_image by auto\n    ultimately have \"c \\<in> LeftTranslation(G,P,a)``(B)\" by simp\n    with \\<open>a\\<in>A\\<close> have \"c \\<in> (\\<Union>a\\<in>A.  LeftTranslation(G,P,a)``(B))\" by auto\n  } thus \"(P {lifted to subsets of} G)`\\<langle>A,B\\<rangle> \\<subseteq> (\\<Union>a\\<in>A.  LeftTranslation(G,P,a)``(B))\"\n    by auto\n  { fix c assume \"c \\<in> (\\<Union>a\\<in>A.  LeftTranslation(G,P,a)``(B))\"\n    then obtain a where \"a\\<in>A\" and \"c \\<in> LeftTranslation(G,P,a)``(B)\"\n      by auto\n    moreover from assms \\<open>a\\<in>A\\<close> have \"LeftTranslation(G,P,a)``(B) = {a\\<cdot>b. b\\<in>B}\"\n      using ltrans_image by auto\n    ultimately obtain b where \"b\\<in>B\" and \"c = a\\<cdot>b\" by auto\n    with I \\<open>a\\<in>A\\<close> have \"c \\<in> (P {lifted to subsets of} G)`\\<langle>A,B\\<rangle>\" by auto\n  } thus \"(\\<Union>a\\<in>A. LeftTranslation(G,P,a)``(B)) \\<subseteq> (P {lifted to subsets of} G)`\\<langle>A,B\\<rangle>\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 501
    },
    "461": {
        "type": "lemma",
        "text": "text\\<open> The right translation version of \\<open>image_ltrans_union\\<close> The proof follows the same schema.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" ",
        "using": [
            "group_oper_fun",
            "lift_subsets_explained",
            "rtrans_image"
        ],
        "statement": "lemma (in group0) image_rtrans_union: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" shows\n  \"(P {lifted to subsets of} G)`\\<langle>A,B\\<rangle> = (\\<Union>b\\<in>B.  RightTranslation(G,P,b)``(A))\"\n",
        "proof": "proof\n  from assms have I: \"(P {lifted to subsets of} G)`\\<langle>A,B\\<rangle> = {a\\<cdot>b . \\<langle>a,b\\<rangle> \\<in> A\\<times>B}\"\n    using group_oper_fun lift_subsets_explained by simp\n  { fix c assume \"c \\<in> (P {lifted to subsets of} G)`\\<langle>A,B\\<rangle>\"\n    with I obtain a b where \"c = a\\<cdot>b\" and \"a\\<in>A\"  \"b\\<in>B\" by auto\n    hence \"c \\<in> {a\\<cdot>b. a\\<in>A}\" by auto\n    moreover from assms \\<open>b\\<in>B\\<close> have \n      \"RightTranslation(G,P,b)``(A) = {a\\<cdot>b. a\\<in>A}\" using rtrans_image by auto\n    ultimately have \"c \\<in> RightTranslation(G,P,b)``(A)\" by simp\n    with \\<open>b\\<in>B\\<close> have \"c \\<in> (\\<Union>b\\<in>B.  RightTranslation(G,P,b)``(A))\" by auto\n  } thus \"(P {lifted to subsets of} G)`\\<langle>A,B\\<rangle> \\<subseteq> (\\<Union>b\\<in>B.  RightTranslation(G,P,b)``(A))\"\n    by auto\n  { fix c assume \"c \\<in> (\\<Union>b\\<in>B.  RightTranslation(G,P,b)``(A))\"\n    then obtain b where \"b\\<in>B\" and \"c \\<in> RightTranslation(G,P,b)``(A)\"\n      by auto\n    moreover from assms \\<open>b\\<in>B\\<close> have \"RightTranslation(G,P,b)``(A) = {a\\<cdot>b. a\\<in>A}\"\n      using rtrans_image by auto\n    ultimately obtain a where \"a\\<in>A\" and \"c = a\\<cdot>b\" by auto\n    with I \\<open>b\\<in>B\\<close> have \"c \\<in> (P {lifted to subsets of} G)`\\<langle>A,B\\<rangle>\" by auto\n  } thus \"(\\<Union>b\\<in>B. RightTranslation(G,P,b)``(A)) \\<subseteq> (P {lifted to subsets of} G)`\\<langle>A,B\\<rangle>\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 502
    },
    "462": {
        "type": "lemma",
        "text": "text\\<open>The neutral element belongs to the translation of a set by the inverse\n  of an element that belongs to it.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>G\" and A2: \"g\\<in>A\"\n  ",
        "using": [
            "inverse_in_group",
            "ltrans_image",
            "group0_2_L6",
            "rtrans_image"
        ],
        "statement": "lemma (in group0) elem_trans_neut: assumes A1: \"A\\<subseteq>G\" and A2: \"g\\<in>A\"\n  shows \"\\<one> \\<in> LeftTranslation(G,P,g\\<inverse>)``(A)\" \"\\<one> \\<in> RightTranslation(G,P,g\\<inverse>)``(A)\"\n",
        "proof": "proof -\n  from assms have ginv:\"g\\<inverse> \\<in> G\" using inverse_in_group by auto\n  with assms have \"g\\<inverse>\\<cdot>g \\<in> LeftTranslation(G,P,g\\<inverse>)``(A)\"\n    using ltrans_image by auto\n  moreover from assms have \"g\\<inverse>\\<cdot>g = \\<one>\" using group0_2_L6 by auto\n  ultimately show \"\\<one> \\<in> LeftTranslation(G,P,g\\<inverse>)``(A)\" by simp\n  from ginv assms have \"g\\<cdot>g\\<inverse> \\<in> RightTranslation(G,P,g\\<inverse>)``(A)\"\n    using rtrans_image by auto\n  moreover from assms have \"g\\<cdot>g\\<inverse> = \\<one>\" using group0_2_L6 by auto\n  ultimately show \"\\<one> \\<in> RightTranslation(G,P,g\\<inverse>)``(A)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 504
    },
    "463": {
        "type": "definition",
        "text": "text\\<open>Odd functions are those that commute with the group inverse:\n  $f(a^{-1}) = (f(a))^{-1}.$\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsOdd(G,P,f) \\<equiv> (\\<forall>a\\<in>G. f`(GroupInv(G,P)`(a)) = GroupInv(G,P)`(f`(a)) )\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 505
    },
    "464": {
        "type": "lemma",
        "text": "text\\<open>Let's see the definition of an odd function in a more readable \n  notation.\\<close>\n",
        "assumes": "",
        "using": [
            "IsOdd_def"
        ],
        "statement": "lemma (in group0) group0_6_L1: \n  shows \"IsOdd(G,P,p) \\<longleftrightarrow> ( \\<forall>a\\<in>G. p`(a\\<inverse>) = (p`(a))\\<inverse> )\"\n  ",
        "proof": "using IsOdd_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 506
    },
    "465": {
        "type": "lemma",
        "text": "text\\<open>We can express the definition of an odd function in two ways.\\<close>\n",
        "assumes": "assumes A1: \"p : G\\<rightarrow>G\" \n  ",
        "using": [
            "apply_funtype",
            "group_inv_of_inv",
            "inverse_in_group"
        ],
        "statement": "lemma (in group0) group0_6_L2:\n  assumes A1: \"p : G\\<rightarrow>G\" \n  shows \n  \"(\\<forall>a\\<in>G. p`(a\\<inverse>) = (p`(a))\\<inverse>) \\<longleftrightarrow> (\\<forall>a\\<in>G. (p`(a\\<inverse>))\\<inverse> = p`(a))\"\n",
        "proof": "proof\n  assume \"\\<forall>a\\<in>G. p`(a\\<inverse>) = (p`(a))\\<inverse>\"\n  with A1 show \"\\<forall>a\\<in>G. (p`(a\\<inverse>))\\<inverse> = p`(a)\"\n    using apply_funtype group_inv_of_inv by simp\nnext assume A2: \"\\<forall>a\\<in>G. (p`(a\\<inverse>))\\<inverse> = p`(a)\"\n  { fix a assume \"a\\<in>G\"\n    with A1 A2  have \n      \"p`(a\\<inverse>) \\<in> G\" and \"((p`(a\\<inverse>))\\<inverse>)\\<inverse> =  (p`(a))\\<inverse>\"\n    using apply_funtype inverse_in_group by auto\n  then have \"p`(a\\<inverse>) = (p`(a))\\<inverse>\"\n    using group_inv_of_inv by simp\n  } then show \"\\<forall>a\\<in>G. p`(a\\<inverse>) = (p`(a))\\<inverse>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 507
    },
    "466": {
        "type": "lemma",
        "text": "text\\<open>An alternative definition of a group inverse of a set.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\"\n  ",
        "using": [
            "group0_2_T2",
            "func_imagedef"
        ],
        "statement": "lemma (in group4) interval_inv: assumes \"A\\<subseteq>G\"\n  shows \"A\\<sinv> = {x\\<inverse>.x\\<in>A}\"\n",
        "proof": "proof -\n  from groupAssum have \"GroupInv(G,P):G\\<rightarrow>G\" using group0_2_T2 by simp\n  with assms show \"A\\<sinv> = {x\\<inverse>.x\\<in>A}\" using func_imagedef by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 510
    },
    "467": {
        "type": "lemma",
        "text": "text\\<open>Group inverse of a set is a subset of the group. \n  Interestingly we don't need to assume the set is a subset of the group.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_T2",
            "func1_1_L6(2)"
        ],
        "statement": "lemma (in group4) interval_inv_cl: shows \"A\\<sinv> \\<subseteq> G\"\n",
        "proof": "proof -\n  from groupAssum have \"GroupInv(G,P):G\\<rightarrow>G\" using group0_2_T2 by simp\n  then show \"A\\<sinv> \\<subseteq> G\" using func1_1_L6(2) by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 511
    },
    "468": {
        "type": "lemma",
        "text": "text\\<open>The product of two subsets of a group is a subset of the group.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\"\n  ",
        "using": [
            "interval_prod",
            "group_op_closed"
        ],
        "statement": "lemma (in group4) interval_prod_closed: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\"\n  shows \"A\\<sdot>B \\<subseteq> G\"\n",
        "proof": "proof\n  fix z assume \"z \\<in> A\\<sdot>B\"\n  with assms obtain x y where \"x\\<in>A\" \"y\\<in>B\" \"z=x\\<cdot>y\" using interval_prod by auto\n  with assms show \"z\\<in>G\" using group_op_closed by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 512
    },
    "469": {
        "type": "lemma",
        "text": "text\\<open> A simple rearrangement following from associativity of the product of sets operation.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"C\\<subseteq>G\" \"D\\<subseteq>G\"\n  ",
        "using": [
            "interval_prod_closed",
            "interval_prod_assoc"
        ],
        "statement": "lemma (in group4) interval_prod_rearr1: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"C\\<subseteq>G\" \"D\\<subseteq>G\"\n  shows \"A\\<sdot>B\\<sdot>(C\\<sdot>D) = A\\<sdot>(B\\<sdot>C)\\<sdot>D\"\n",
        "proof": "proof -\n  from assms(1,2) have \"A\\<sdot>B \\<subseteq> G\" using interval_prod_closed by simp\n  with assms(3,4) have \"A\\<sdot>B\\<sdot>(C\\<sdot>D) = A\\<sdot>B\\<sdot>C\\<sdot>D\"\n    using interval_prod_assoc by simp\n  also from assms(1,2,3) have \"A\\<sdot>B\\<sdot>C\\<sdot>D = A\\<sdot>(B\\<sdot>C)\\<sdot>D\"\n    using interval_prod_assoc by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 514
    },
    "470": {
        "type": "lemma",
        "text": "text\\<open>A subset $A$ of the group is closed with respect to the group operation \n  iff $A\\cdot A \\subseteq A$. \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \n  ",
        "using": [
            "interval_prod"
        ],
        "statement": "lemma (in group4) subset_gr_op_cl: assumes \"A\\<subseteq>G\" \n  shows \"(A {is closed under} P) \\<longleftrightarrow> A\\<sdot>A \\<subseteq> A\"\n",
        "proof": "proof\n  assume \"A {is closed under} P\"\n  { fix z assume \"z \\<in> A\\<sdot>A\"\n    with assms obtain x y where \"x\\<in>A\" \"y\\<in>A\" and \"z=x\\<cdot>y\" using interval_prod by auto\n    with \\<open>A {is closed under} P\\<close> have \"z\\<in>A\" unfolding IsOpClosed_def by simp\n  } thus \"A\\<sdot>A \\<subseteq> A\" by auto\nnext\n  assume \"A\\<sdot>A \\<subseteq> A\"\n  { fix x y assume \"x\\<in>A\" \"y\\<in>A\"\n    with assms have \"x\\<cdot>y \\<in> A\\<sdot>A\" using interval_prod by auto\n    with \\<open>A\\<sdot>A \\<subseteq> A\\<close> have \"x\\<cdot>y \\<in> A\" by auto\n  } then show \"A {is closed under} P\" unfolding IsOpClosed_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 515
    },
    "471": {
        "type": "lemma",
        "text": "text\\<open>Inverse and square of a subgroup is this subgroup.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \n   ",
        "using": [
            "group0_3_L2",
            "interval_inv",
            "group0_3_T3A",
            "group_inv_of_inv",
            "group0_3_L6",
            "IsOpClosed_def",
            "subset_gr_op_cl",
            "group0_3_L5",
            "interval_prod",
            "group0_2_L2"
        ],
        "statement": "lemma (in group4) subgroup_inv_sq: assumes \"IsAsubgroup(H,P)\" \n   shows \"H\\<sinv> = H\" and \"H\\<sdot>H = H\"\n",
        "proof": "proof\n  from assms have \"H\\<subseteq>G\" using group0_3_L2 by simp\n  with assms show \"H\\<sinv> \\<subseteq> H\" using interval_inv group0_3_T3A by auto\n  { fix x assume \"x\\<in>H\"\n    with assms have \"(x\\<inverse>)\\<inverse> \\<in> {y\\<inverse>.y\\<in>H}\" using group0_3_T3A by auto\n    moreover from \\<open>x\\<in>H\\<close> \\<open>H\\<subseteq>G\\<close> have \"(x\\<inverse>)\\<inverse> = x\" using group_inv_of_inv by auto\n    ultimately have \"x \\<in> {y\\<inverse>.y\\<in>H}\" by auto\n    with \\<open>H\\<subseteq>G\\<close> have \"x \\<in> H\\<sinv>\" using interval_inv by simp\n  } thus \"H \\<subseteq> H\\<sinv>\" by auto\n  from assms have \"H {is closed under} P\" using group0_3_L6 unfolding IsOpClosed_def by simp\n  with assms have \"H\\<sdot>H \\<subseteq> H\" using subset_gr_op_cl group0_3_L2 by simp\n  moreover\n  { fix x assume \"x\\<in>H\"\n    with assms have \"x\\<in>G\" using group0_3_L2 by auto\n    from assms \\<open>H\\<subseteq>G\\<close> \\<open>x\\<in>H\\<close> have \"x\\<cdot>\\<one> \\<in> H\\<sdot>H\" using group0_3_L5 interval_prod by auto\n    with \\<open>x\\<in>G\\<close> have \"x \\<in> H\\<sdot>H\" using group0_2_L2 by simp\n  } hence \"H \\<subseteq> H\\<sdot>H\" by auto\n  ultimately show \"H\\<sdot>H = H\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 516
    },
    "472": {
        "type": "lemma",
        "text": "text\\<open>Inverse of a product two sets is a product of inverses with the reversed order.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\"\n  ",
        "using": [
            "interval_prod_closed",
            "interval_inv",
            "interval_prod",
            "group_inv_of_two",
            "interval_inv_cl"
        ],
        "statement": "lemma (in group4) interval_prod_inv: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\"\n  shows \n    \"(A\\<sdot>B)\\<sinv> = {(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n    \"(A\\<sdot>B)\\<sinv> = {y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n    \"(A\\<sdot>B)\\<sinv> = (B\\<sinv>)\\<sdot>(A\\<sinv>)\"\n",
        "proof": "proof -\n  from assms have \"(A\\<sdot>B) \\<subseteq> G\" using interval_prod_closed by simp\n  then have I: \"(A\\<sdot>B)\\<sinv> = {z\\<inverse>.z\\<in>A\\<sdot>B}\" using interval_inv by simp\n  show II: \"(A\\<sdot>B)\\<sinv> = {(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n  proof\n    { fix p assume \"p \\<in> (A\\<sdot>B)\\<sinv>\"\n      with I obtain z where \"p=z\\<inverse>\" and \"z\\<in>A\\<sdot>B\" by auto\n      with assms obtain x y where \"\\<langle>x,y\\<rangle> \\<in> A\\<times>B\" and \"z=x\\<cdot>y\" using interval_prod by auto\n      with \\<open>p=z\\<inverse>\\<close> have \"p\\<in>{(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by auto\n    } thus \"(A\\<sdot>B)\\<sinv> \\<subseteq> {(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by blast\n    { fix p assume \"p\\<in>{(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n      then obtain x y where \"x\\<in>A\" \"y\\<in>B\" and \"p=(x\\<cdot>y)\\<inverse>\" by auto\n      with assms \\<open>(A\\<sdot>B) \\<subseteq> G\\<close> have \"p\\<in>(A\\<sdot>B)\\<sinv>\" using interval_prod interval_inv\n        by auto\n    } thus \"{(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B} \\<subseteq> (A\\<sdot>B)\\<sinv>\" by blast\n  qed\n  have \"{(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B} = {y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n  proof \n    { fix p assume \"p \\<in> {(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n      then obtain x y where \"x\\<in>A\" \"y\\<in>B\" and \"p=(x\\<cdot>y)\\<inverse>\" by auto\n      with assms have \"y\\<inverse>\\<cdot>x\\<inverse> = (x\\<cdot>y)\\<inverse>\" using group_inv_of_two by auto\n      with \\<open>p=(x\\<cdot>y)\\<inverse>\\<close> have \"p = y\\<inverse>\\<cdot>x\\<inverse>\" by simp\n      with \\<open>x\\<in>A\\<close> \\<open>y\\<in>B\\<close> have \"p\\<in>{y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by auto\n    } thus \"{(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B} \\<subseteq> {y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by blast\n    { fix p assume \"p\\<in>{y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n      then obtain x y where \"x\\<in>A\" \"y\\<in>B\" and \"p=y\\<inverse>\\<cdot>x\\<inverse>\" by auto\n      with assms have \"p = (x\\<cdot>y)\\<inverse>\" using group_inv_of_two by auto\n      with \\<open>x\\<in>A\\<close> \\<open>y\\<in>B\\<close> have \"p \\<in> {(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by auto\n    } thus \"{y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B} \\<subseteq> {(x\\<cdot>y)\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by blast\n  qed\n  with II show III: \"(A\\<sdot>B)\\<sinv> = {y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by simp\n  have \"{y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B} = (B\\<sinv>)\\<sdot>(A\\<sinv>)\"\n  proof    \n    { fix p assume \"p\\<in>{y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n      then obtain x y where \"x\\<in>A\" \"y\\<in>B\" and \"p=y\\<inverse>\\<cdot>x\\<inverse>\" by auto\n      with assms have \"y\\<inverse> \\<in> (B\\<sinv>)\" and \"x\\<inverse> \\<in> (A\\<sinv>)\"\n        using interval_inv by auto\n      with \\<open>p=y\\<inverse>\\<cdot>x\\<inverse>\\<close> have \"p \\<in> (B\\<sinv>)\\<sdot>(A\\<sinv>)\" using interval_inv_cl interval_prod\n        by auto\n    } thus \"{y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B} \\<subseteq> (B\\<sinv>)\\<sdot>(A\\<sinv>)\" by blast\n    { fix p assume \"p \\<in> (B\\<sinv>)\\<sdot>(A\\<sinv>)\"\n      then obtain y x where \"y\\<in>B\\<sinv>\" \"x\\<in>A\\<sinv>\" and \"p=y\\<cdot>x\"\n        using interval_inv_cl interval_prod by auto\n      with assms obtain x\\<^sub>1 y\\<^sub>1 where \"x\\<^sub>1 \\<in> A\" \"y\\<^sub>1 \\<in> B\" and \"x=x\\<^sub>1\\<inverse>\" \"y=y\\<^sub>1\\<inverse>\" using interval_inv\n        by auto\n      with \\<open>p=y\\<cdot>x\\<close> have \"p \\<in> {y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by auto \n    } thus \"(B\\<sinv>)\\<sdot>(A\\<sinv>) \\<subseteq> {y\\<inverse>\\<cdot>x\\<inverse>.\\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" by blast\n  qed\n  with III show \"(A\\<sdot>B)\\<sinv> = (B\\<sinv>)\\<sdot>(A\\<sinv>)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 517
    },
    "473": {
        "type": "theorem",
        "text": "text\\<open> If $H,K$ are subgroups then $H\\cdot K$ is a subgroup iff $H\\cdot K = K\\cdot H$. \\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" and \"IsAsubgroup(K,P)\"\n  ",
        "using": [
            "subgroup_inv_sq(1)",
            "group0_3_L2",
            "interval_prod_inv",
            "group0_3_L5",
            "interval_prod",
            "interval_prod_closed",
            "interval_prod_rearr1",
            "subgroup_inv_sq(2)",
            "subset_gr_op_cl",
            "interval_inv",
            "group0_3_T3"
        ],
        "statement": "theorem (in group4) prod_subgr_subgr: \n  assumes \"IsAsubgroup(H,P)\" and \"IsAsubgroup(K,P)\"\n  shows \"IsAsubgroup(H\\<sdot>K,P) \\<longleftrightarrow>  H\\<sdot>K = K\\<sdot>H\"\n",
        "proof": "proof\n  assume \"IsAsubgroup(H\\<sdot>K,P)\"\n  then have \"(H\\<sdot>K)\\<sinv> = H\\<sdot>K\" using subgroup_inv_sq(1) by simp\n  with assms show \"H\\<sdot>K = K\\<sdot>H\" using group0_3_L2 interval_prod_inv subgroup_inv_sq(1)\n    by auto\nnext\n  from assms have \"H\\<subseteq>G\" and \"K\\<subseteq>G\" using group0_3_L2 by auto\n  have I: \"H\\<sdot>K \\<noteq> 0\"\n  proof -\n    let ?x = \"\\<one>\" let ?y = \"\\<one>\"\n    from assms have \"?x\\<cdot>?y \\<in> (H\\<sdot>K)\" using group0_3_L5 group0_3_L2 interval_prod \n      by auto\n    thus ?thesis by auto\n  qed\n  from \\<open>H\\<subseteq>G\\<close> \\<open>K\\<subseteq>G\\<close> have II: \"H\\<sdot>K \\<subseteq> G\" using interval_prod_closed by simp \n  assume \"H\\<sdot>K = K\\<sdot>H\"\n  have III: \"(H\\<sdot>K){is closed under} P\"\n  proof -\n    have \"(H\\<sdot>K)\\<sdot>(H\\<sdot>K) = H\\<sdot>K\"\n    proof -\n      from \\<open>H\\<subseteq>G\\<close> \\<open>K\\<subseteq>G\\<close> have \"(H\\<sdot>K)\\<sdot>(H\\<sdot>K) = H\\<sdot>(K\\<sdot>H)\\<sdot>K\"\n        using interval_prod_rearr1 by simp\n      also from \\<open>H\\<sdot>K = K\\<sdot>H\\<close> have \"... = H\\<sdot>(H\\<sdot>K)\\<sdot>K\" by simp\n      also from \\<open>H\\<subseteq>G\\<close> \\<open>K\\<subseteq>G\\<close> have \"... = (H\\<sdot>H)\\<sdot>(K\\<sdot>K)\"\n        using interval_prod_rearr1 by simp\n      also from assms have \"... = H\\<sdot>K\" using subgroup_inv_sq(2) by simp\n      finally show ?thesis by simp\n    qed\n    with \\<open>H\\<sdot>K \\<subseteq> G\\<close> show ?thesis using subset_gr_op_cl by simp\n  qed\n  have IV: \"\\<forall>x \\<in> H\\<sdot>K. x\\<inverse> \\<in> H\\<sdot>K\"\n  proof -\n    { fix x assume \"x \\<in> H\\<sdot>K\" \n      with \\<open>H\\<sdot>K \\<subseteq> G\\<close> have \"x\\<inverse> \\<in> (H\\<sdot>K)\\<sinv>\" using interval_inv by auto\n      with assms \\<open>H\\<subseteq>G\\<close> \\<open>K\\<subseteq>G\\<close> \\<open>H\\<sdot>K = K\\<sdot>H\\<close> have \"x\\<inverse> \\<in> H\\<sdot>K\"\n        using interval_prod_inv subgroup_inv_sq(1) by simp\n    } thus ?thesis by auto\n  qed\n  from I II III IV show \"IsAsubgroup(H\\<sdot>K,P)\" using group0_3_T3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 518
    },
    "474": {
        "type": "theorem",
        "text": "text\\<open>The next theorem states that a set $G$ with an associative operation \n  that satisfies condition C is a group, as defined in IsarMathLib\n  \\<open>Group_ZF\\<close> theory.\\<close>\n",
        "assumes": "assumes A1: \"G\\<noteq>0\" and A2: \"P {is associative on} G\"\n  and A3: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>x\\<in>G. a\\<cdot>x = b\"\n  and A4: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>y\\<in>G. y\\<cdot>a = b\"\n  ",
        "using": [
            "IsAssociative_def",
            "IsAmonoid_def",
            "monoid0_def",
            "monoid0.unit_is_neutral",
            "IsAgroup_def"
        ],
        "statement": "theorem (in group2) altgroup_is_group: \n  assumes A1: \"G\\<noteq>0\" and A2: \"P {is associative on} G\"\n  and A3: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>x\\<in>G. a\\<cdot>x = b\"\n  and A4: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>y\\<in>G. y\\<cdot>a = b\"\n  shows \"IsAgroup(G,P)\"\n",
        "proof": "proof -\n  from A1 obtain a where \"a\\<in>G\" by auto\n  with A3 obtain x where \"x\\<in>G\" and \"a\\<cdot>x = a\" \n    by auto\n  from A4 \\<open>a\\<in>G\\<close> obtain y where \"y\\<in>G\" and \"y\\<cdot>a = a\"\n    by auto\n  have I: \"\\<forall>b\\<in>G. b = b\\<cdot>x \\<and> b = y\\<cdot>b\"\n  proof\n    fix b assume \"b\\<in>G\"\n     with A4 \\<open>a\\<in>G\\<close> obtain y\\<^sub>b where \"y\\<^sub>b\\<in>G\"  \n      and \"y\\<^sub>b\\<cdot>a = b\" by auto\n    from A3 \\<open>a\\<in>G\\<close> \\<open>b\\<in>G\\<close> obtain x\\<^sub>b where \"x\\<^sub>b\\<in>G\"  \n      and \"a\\<cdot>x\\<^sub>b = b\" by auto\n    from \\<open>a\\<cdot>x = a\\<close> \\<open>y\\<cdot>a = a\\<close> \\<open>y\\<^sub>b\\<cdot>a = b\\<close> \\<open>a\\<cdot>x\\<^sub>b = b\\<close> \n    have \"b = y\\<^sub>b\\<cdot>(a\\<cdot>x)\" and \"b = (y\\<cdot>a)\\<cdot>x\\<^sub>b\" \n      by auto\n    moreover from A2 \\<open>a\\<in>G\\<close> \\<open>x\\<in>G\\<close> \\<open>y\\<in>G\\<close> \\<open>x\\<^sub>b\\<in>G\\<close> \\<open>y\\<^sub>b\\<in>G\\<close> have \n      \"(y\\<cdot>a)\\<cdot>x\\<^sub>b = y\\<cdot>(a\\<cdot>x\\<^sub>b)\"  \"y\\<^sub>b\\<cdot>(a\\<cdot>x) = (y\\<^sub>b\\<cdot>a)\\<cdot>x\"\n      using IsAssociative_def by auto\n    moreover from \\<open>y\\<^sub>b\\<cdot>a = b\\<close> \\<open>a\\<cdot>x\\<^sub>b = b\\<close> have \n      \"(y\\<^sub>b\\<cdot>a)\\<cdot>x = b\\<cdot>x\"  \"y\\<cdot>(a\\<cdot>x\\<^sub>b) = y\\<cdot>b\"\n      by auto\n    ultimately show \"b = b\\<cdot>x \\<and> b = y\\<cdot>b\" by simp\n  qed\n  moreover have \"x = y\"\n  proof -\n    from \\<open>x\\<in>G\\<close> I have \"x = y\\<cdot>x\" by simp  \n    also from \\<open>y\\<in>G\\<close> I have \"y\\<cdot>x = y\" by simp\n    finally show \"x = y\" by simp\n  qed\n  ultimately have \"\\<forall>b\\<in>G. b\\<cdot>x = b \\<and> x\\<cdot>b = b\" by simp\n  with A2 \\<open>x\\<in>G\\<close> have \"IsAmonoid(G,P)\" using IsAmonoid_def by auto\n  with A3 show \"IsAgroup(G,P)\"\n    using monoid0_def monoid0.unit_is_neutral IsAgroup_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1b.thy",
        "id": 519
    },
    "475": {
        "type": "theorem",
        "text": "text\\<open>The converse of \\<open>altgroup_is_group\\<close>: \n  in every (classically defined) group condition C holds.  \n  In informal mathematics we can say \"Obviously\n  condition C holds in any group.\" In formalized mathematics the word \"obviously\" \n  is not in the language. The next theorem is proven in the context called\n  \\<open>group0\\<close> defined in the theory \\<open>Group_ZF.thy\\<close>. Similarly to the\n  \\<open>group2\\<close> that context defines $a\\cdot b$ as $P\\langle a,b\\rangle$ \n  It also defines notation related to the group inverse and \n  adds an assumption that the pair $(G,P)$ is a group \n  to all its theorems. This is why in the next theorem we don't \n  explicitely assume that $(G,P)$ is a group - this assumption \n  is implicit in the context.\\<close>\n",
        "assumes": "",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "inv_cancel_two"
        ],
        "statement": "theorem (in group0) group_is_altgroup: shows \n  \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>x\\<in>G. a\\<cdot>x = b\" and \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>y\\<in>G. y\\<cdot>a = b\"\n",
        "proof": "proof -\n  { fix a b assume \"a\\<in>G\"  \"b\\<in>G\"\n    let ?x = \"a\\<inverse>\\<cdot> b\"\n    let ?y = \"b\\<cdot>a\\<inverse>\"\n    from \\<open>a\\<in>G\\<close>  \\<open>b\\<in>G\\<close>  have \n      \"?x \\<in> G\"  \"?y \\<in> G\"  and  \"a\\<cdot>?x = b\"  \"?y\\<cdot>a = b\"\n      using inverse_in_group group_op_closed inv_cancel_two\n      by auto\n    hence \"\\<exists>x\\<in>G. a\\<cdot>x = b\" and \"\\<exists>y\\<in>G. y\\<cdot>a = b\" by auto\n  } thus \n      \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>x\\<in>G. a\\<cdot>x = b\" and\n      \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. \\<exists>y\\<in>G. y\\<cdot>a = b\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1b.thy",
        "id": 520
    },
    "476": {
        "type": "lemma",
        "text": "text\\<open>The lifted operation is an operation on the function space.\\<close>\n",
        "assumes": "assumes A1: \"F = f {lifted to function space over} X\"\n  ",
        "using": [
            "IsAmonoid_def",
            "IsAssociative_def",
            "func_ZF_1_L3",
            "group0_1_L3B"
        ],
        "statement": "lemma (in monoid0) Group_ZF_2_1_L0A:\n  assumes A1: \"F = f {lifted to function space over} X\"\n  shows \"F : (X\\<rightarrow>G)\\<times>(X\\<rightarrow>G)\\<rightarrow>(X\\<rightarrow>G)\"\n",
        "proof": "proof -\n  from monoidAssum have \"f : G\\<times>G\\<rightarrow>G\"\n    using IsAmonoid_def IsAssociative_def by simp\n  with A1 show ?thesis\n    using func_ZF_1_L3 group0_1_L3B by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 521
    },
    "477": {
        "type": "lemma",
        "text": "text\\<open>The result of the lifted operation is in the function space.\\<close>\n",
        "assumes": "assumes A1:\"F = f {lifted to function space over} X\"\n  and A2:\"s:X\\<rightarrow>G\" \"r:X\\<rightarrow>G\"\n  ",
        "using": [
            "Group_ZF_2_1_L0A",
            "apply_funtype"
        ],
        "statement": "lemma (in monoid0) Group_ZF_2_1_L0: \n  assumes A1:\"F = f {lifted to function space over} X\"\n  and A2:\"s:X\\<rightarrow>G\" \"r:X\\<rightarrow>G\"\n  shows \"F`\\<langle> s,r\\<rangle> : X\\<rightarrow>G\"\n",
        "proof": "proof -\n  from A1 have \"F : (X\\<rightarrow>G)\\<times>(X\\<rightarrow>G)\\<rightarrow>(X\\<rightarrow>G)\"\n    using Group_ZF_2_1_L0A\n    by simp\n  with A2 show ?thesis using apply_funtype\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 522
    },
    "478": {
        "type": "lemma",
        "text": "text\\<open>The lifted monoid operation has a neutral element, namely\n  the constant function with the neutral element as the value.\\<close>\n",
        "assumes": "assumes A1: \"F = f {lifted to function space over} X\"\n  and A2: \"E = ConstantFunction(X,TheNeutralElement(G,f))\"\n  ",
        "using": [
            "unit_is_neutral",
            "func1_3_L1",
            "IsAmonoid_def",
            "IsAssociative_def",
            "Group_ZF_2_1_L0",
            "func_ZF_1_L4",
            "group0_1_L3B",
            "func1_3_L2",
            "apply_type",
            "fun_extension_iff"
        ],
        "statement": "lemma (in monoid0) Group_ZF_2_1_L1: \n  assumes A1: \"F = f {lifted to function space over} X\"\n  and A2: \"E = ConstantFunction(X,TheNeutralElement(G,f))\"\n  shows \"E : X\\<rightarrow>G \\<and> (\\<forall>s\\<in>X\\<rightarrow>G. F`\\<langle> E,s\\<rangle> = s \\<and> F`\\<langle> s,E\\<rangle> = s)\"\n",
        "proof": "proof\n  from A2 show T1:\"E : X\\<rightarrow>G\"\n    using unit_is_neutral func1_3_L1 by simp\n  show \"\\<forall>s\\<in>X\\<rightarrow>G. F`\\<langle> E,s\\<rangle> = s \\<and> F`\\<langle> s,E\\<rangle> = s\"\n  proof\n    fix s assume A3:\"s:X\\<rightarrow>G\"\n    from monoidAssum have T2:\"f : G\\<times>G\\<rightarrow>G\"\n      using IsAmonoid_def IsAssociative_def by simp\n    from A3 A1 T1 have \n      \"F`\\<langle> E,s\\<rangle> : X\\<rightarrow>G\" \"F`\\<langle> s,E\\<rangle> : X\\<rightarrow>G\" \"s : X\\<rightarrow>G\"\n      using Group_ZF_2_1_L0 by auto\n    moreover from T2 A1 T1 A2 A3 have\n      \"\\<forall>x\\<in>X. (F`\\<langle> E,s\\<rangle>)`(x) = s`(x)\"\n      \"\\<forall>x\\<in>X. (F`\\<langle> s,E\\<rangle>)`(x) = s`(x)\"\n      using func_ZF_1_L4 group0_1_L3B func1_3_L2 \n\tapply_type unit_is_neutral by auto\n    ultimately show \n      \"F`\\<langle> E,s\\<rangle> = s \\<and> F`\\<langle> s,E\\<rangle> = s\"\n      using fun_extension_iff by auto\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 523
    },
    "479": {
        "type": "lemma",
        "text": "text\\<open>Monoids can be lifted to a function space.\\<close>\n",
        "assumes": "assumes A1: \"F = f {lifted to function space over} X\"\n  ",
        "using": [
            "IsAmonoid_def",
            "func_ZF_2_L4",
            "group0_1_L3B",
            "Group_ZF_2_1_L1"
        ],
        "statement": "lemma (in monoid0) Group_ZF_2_1_T1: \n  assumes A1: \"F = f {lifted to function space over} X\"\n  shows \"IsAmonoid(X\\<rightarrow>G,F)\"\n",
        "proof": "proof -\n  from monoidAssum A1 have \n    \"F {is associative on} (X\\<rightarrow>G)\"\n    using IsAmonoid_def func_ZF_2_L4 group0_1_L3B\n    by auto\n  moreover from A1 have \n    \"\\<exists> E \\<in> X\\<rightarrow>G. \\<forall>s \\<in> X\\<rightarrow>G. F`\\<langle> E,s\\<rangle> = s \\<and> F`\\<langle> s,E\\<rangle> = s\"\n    using Group_ZF_2_1_L1 by blast\n  ultimately show ?thesis using IsAmonoid_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 524
    },
    "480": {
        "type": "lemma",
        "text": "text\\<open>The constant function with the neutral element as the value is the\n  neutral element of the lifted monoid.\\<close>\n",
        "assumes": "assumes A1: \"IsAmonoid(G,f)\"\n  and A2: \"F = f {lifted to function space over} X\"\n  and A3: \"E = ConstantFunction(X,TheNeutralElement(G,f))\"\n  ",
        "using": [
            "monoid0_def",
            "monoid0.Group_ZF_2_1_T1",
            "monoid0.Group_ZF_2_1_L1",
            "monoid0.group0_1_L4"
        ],
        "statement": "lemma Group_ZF_2_1_L2:\n  assumes A1: \"IsAmonoid(G,f)\"\n  and A2: \"F = f {lifted to function space over} X\"\n  and A3: \"E = ConstantFunction(X,TheNeutralElement(G,f))\"\n  shows \"E = TheNeutralElement(X\\<rightarrow>G,F)\"\n",
        "proof": "proof - \n  from A1 A2 have \n     T1:\"monoid0(G,f)\" and T2:\"monoid0(X\\<rightarrow>G,F)\"\n    using monoid0_def monoid0.Group_ZF_2_1_T1\n    by auto\n  from T1 A2 A3 have \n    \"E : X\\<rightarrow>G \\<and> (\\<forall>s\\<in>X\\<rightarrow>G. F`\\<langle> E,s\\<rangle> = s \\<and> F`\\<langle> s,E\\<rangle> = s)\"\n    using monoid0.Group_ZF_2_1_L1 by simp\n  with T2 show ?thesis\n    using monoid0.group0_1_L4 by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 525
    },
    "481": {
        "type": "lemma",
        "text": "text\\<open>The lifted operation acts on the functions in a natural way defined\n  by the monoid operation.\\<close>\n",
        "assumes": "assumes \"F = f {lifted to function space over} X\"\n  and \"s:X\\<rightarrow>G\"  \"r:X\\<rightarrow>G\"\n  and \"x\\<in>X\"\n  ",
        "using": [
            "monoidAssum",
            "assms",
            "IsAmonoid_def",
            "IsAssociative_def",
            "group0_1_L3B",
            "func_ZF_1_L4"
        ],
        "statement": "lemma (in monoid0) lifted_val:\n  assumes \"F = f {lifted to function space over} X\"\n  and \"s:X\\<rightarrow>G\"  \"r:X\\<rightarrow>G\"\n  and \"x\\<in>X\"\n  shows \"(F`\\<langle>s,r\\<rangle>)`(x) = s`(x) \\<oplus> r`(x)\"\n  ",
        "proof": "using monoidAssum assms IsAmonoid_def IsAssociative_def\n      group0_1_L3B func_ZF_1_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 526
    },
    "482": {
        "type": "lemma",
        "text": "text\\<open>The lifted operation acts on the functions in a natural way defined\n  by the group operation. This is the same as \\<open>lifted_val\\<close>, but\n  in the \\<open>group0\\<close> context.\\<close>\n",
        "assumes": "assumes \"F = P {lifted to function space over} X\"\n  and \"s:X\\<rightarrow>G\" \"r:X\\<rightarrow>G\"\n  and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "group0_2_L1",
            "monoid0.lifted_val"
        ],
        "statement": "lemma (in group0) Group_ZF_2_1_L3:\n  assumes \"F = P {lifted to function space over} X\"\n  and \"s:X\\<rightarrow>G\" \"r:X\\<rightarrow>G\"\n  and \"x\\<in>X\"\n  shows \"(F`\\<langle>s,r\\<rangle>)`(x) = s`(x)\\<cdot>r`(x)\"\n  ",
        "proof": "using assms group0_2_L1 monoid0.lifted_val by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 527
    },
    "483": {
        "type": "lemma",
        "text": "text\\<open>In the group0 context we can apply theorems proven in monoid0 context\n  to the lifted monoid.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  ",
        "using": [
            "group0_2_L1",
            "monoid0.Group_ZF_2_1_T1",
            "monoid0_def"
        ],
        "statement": "lemma (in group0) Group_ZF_2_1_L4:\n  assumes A1: \"F = P {lifted to function space over} X\"\n  shows \"monoid0(X\\<rightarrow>G,F)\"\n",
        "proof": "proof -\n  from A1 show ?thesis\n    using group0_2_L1 monoid0.Group_ZF_2_1_T1 monoid0_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 528
    },
    "484": {
        "type": "lemma",
        "text": "text\\<open>The compostion of a function $f:X\\rightarrow G$ with the group inverse\n  is a right inverse for the lifted group.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  and A2: \"s : X\\<rightarrow>G\"\n  and A3: \"i = GroupInv(G,P) O s\"\n  ",
        "using": [
            "group0_2_L2",
            "func1_3_L1",
            "group0_2_T2",
            "comp_fun",
            "Group_ZF_2_1_L4",
            "monoid0.group0_1_L1",
            "Group_ZF_2_1_L3",
            "comp_fun_apply",
            "apply_funtype",
            "group0_2_L6",
            "func1_3_L2",
            "IsAgroup_def",
            "Group_ZF_2_1_L2",
            "fun_extension_iff"
        ],
        "statement": "lemma (in group0) Group_ZF_2_1_L5: \n  assumes A1: \"F = P {lifted to function space over} X\"\n  and A2: \"s : X\\<rightarrow>G\"\n  and A3: \"i = GroupInv(G,P) O s\"\n  shows \"i: X\\<rightarrow>G\" and \"F`\\<langle> s,i\\<rangle> = TheNeutralElement(X\\<rightarrow>G,F)\"\n",
        "proof": "proof -\n  let ?E = \"ConstantFunction(X,\\<one>)\"\n  have \"?E : X\\<rightarrow>G\" \n    using group0_2_L2 func1_3_L1 by simp\n  moreover from groupAssum A2 A3 A1 have\n    \"F`\\<langle> s,i\\<rangle> :  X\\<rightarrow>G\" using group0_2_T2 comp_fun \n      Group_ZF_2_1_L4 monoid0.group0_1_L1\n    by simp\n  moreover from groupAssum A2 A3 A1 have \n    \"\\<forall>x\\<in>X. (F`\\<langle> s,i\\<rangle>)`(x) = ?E`(x)\"\n    using group0_2_T2 comp_fun Group_ZF_2_1_L3 \n      comp_fun_apply apply_funtype group0_2_L6 func1_3_L2\n    by simp\n  moreover from groupAssum A1 have\n    \"?E = TheNeutralElement(X\\<rightarrow>G,F)\"\n    using IsAgroup_def Group_ZF_2_1_L2 by simp\n  ultimately show \"F`\\<langle> s,i\\<rangle> = TheNeutralElement(X\\<rightarrow>G,F)\"\n    using fun_extension_iff IsAgroup_def Group_ZF_2_1_L2\n    by simp\n  from groupAssum A2 A3 show \"i: X\\<rightarrow>G\" \n    using group0_2_T2 comp_fun by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 529
    },
    "485": {
        "type": "theorem",
        "text": "text\\<open>Groups can be lifted to the function space.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  ",
        "using": [
            "group0_2_L1",
            "monoid0.Group_ZF_2_1_T1",
            "group0_2_T2",
            "comp_fun",
            "Group_ZF_2_1_L5",
            "IsAgroup_def"
        ],
        "statement": "theorem (in group0) Group_ZF_2_1_T2:\n  assumes A1: \"F = P {lifted to function space over} X\"\n  shows \"IsAgroup(X\\<rightarrow>G,F)\"\n",
        "proof": "proof -\n  from A1 have \"IsAmonoid(X\\<rightarrow>G,F)\"\n    using group0_2_L1 monoid0.Group_ZF_2_1_T1\n    by simp\n  moreover have \n    \"\\<forall>s\\<in>X\\<rightarrow>G. \\<exists>i\\<in>X\\<rightarrow>G. F`\\<langle> s,i\\<rangle> = TheNeutralElement(X\\<rightarrow>G,F)\"\n  proof\n    fix s assume A2: \"s : X\\<rightarrow>G\"\n    let ?i = \"GroupInv(G,P) O s\"\n    from groupAssum A2 have \"?i:X\\<rightarrow>G\"\n      using group0_2_T2 comp_fun by simp\n    moreover from A1 A2 have \n      \"F`\\<langle> s,?i\\<rangle> = TheNeutralElement(X\\<rightarrow>G,F)\"\n      using Group_ZF_2_1_L5 by fast\n   ultimately show \"\\<exists>i\\<in>X\\<rightarrow>G. F`\\<langle> s,i\\<rangle> = TheNeutralElement(X\\<rightarrow>G,F)\" \n      by auto\n  qed\n  ultimately show ?thesis using IsAgroup_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 530
    },
    "486": {
        "type": "lemma",
        "text": "text\\<open>What is the group inverse for the lifted group?\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  ",
        "using": [
            "group0_def",
            "Group_ZF_2_1_T2",
            "Group_ZF_2_1_L5"
        ],
        "statement": "lemma (in group0) Group_ZF_2_1_L6: \n  assumes A1: \"F = P {lifted to function space over} X\"\n  shows \"\\<forall>s\\<in>(X\\<rightarrow>G). GroupInv(X\\<rightarrow>G,F)`(s) = GroupInv(G,P) O s\"\n",
        "proof": "proof -\n  from A1 have  \"group0(X\\<rightarrow>G,F)\"\n    using group0_def Group_ZF_2_1_T2 \n    by simp\n  moreover from A1 have \"\\<forall>s\\<in>X\\<rightarrow>G. GroupInv(G,P) O s : X\\<rightarrow>G \\<and> \n    F`\\<langle> s,GroupInv(G,P) O s\\<rangle> = TheNeutralElement(X\\<rightarrow>G,F)\"\n    using Group_ZF_2_1_L5 by simp\n  ultimately have \n    \"\\<forall>s\\<in>(X\\<rightarrow>G).  GroupInv(G,P) O s = GroupInv(X\\<rightarrow>G,F)`(s)\"\n    by (rule group0.group0_2_L9A)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 531
    },
    "487": {
        "type": "corollary",
        "text": "text\\<open>What is the value of the group inverse for the lifted group?\\<close>\n",
        "assumes": "assumes \"F = P {lifted to function space over} X\" and\n  \"s : X\\<rightarrow>G\" and \"x\\<in>X\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "Group_ZF_2_1_L6",
            "group0_2_T2",
            "comp_fun_apply"
        ],
        "statement": "corollary (in group0) lift_gr_inv_val:  \n  assumes \"F = P {lifted to function space over} X\" and\n  \"s : X\\<rightarrow>G\" and \"x\\<in>X\"\n  shows  \"(GroupInv(X\\<rightarrow>G,F)`(s))`(x) = (s`(x))\\<inverse>\"\n  ",
        "proof": "using groupAssum assms Group_ZF_2_1_L6 group0_2_T2 comp_fun_apply\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 532
    },
    "488": {
        "type": "lemma",
        "text": "text\\<open>What is the group inverse in a subgroup of the lifted group?\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  and A2: \"IsAsubgroup(H,F)\"\n  and A3: \"g = restrict(F,H\\<times>H)\"\n  and A4: \"s\\<in>H\"\n  ",
        "using": [
            "group0_def",
            "Group_ZF_2_1_T2",
            "group0.group0_3_T1",
            "restrict",
            "group0.group0_3_L2",
            "Group_ZF_2_1_L6"
        ],
        "statement": "lemma (in group0) Group_ZF_2_1_L6A:\n  assumes A1: \"F = P {lifted to function space over} X\"\n  and A2: \"IsAsubgroup(H,F)\"\n  and A3: \"g = restrict(F,H\\<times>H)\"\n  and A4: \"s\\<in>H\"\n  shows \"GroupInv(H,g)`(s) = GroupInv(G,P) O s\"\n",
        "proof": "proof -\n  from A1 have T1: \"group0(X\\<rightarrow>G,F)\"\n    using group0_def Group_ZF_2_1_T2 \n    by simp\n  with A2 A3 A4 have \"GroupInv(H,g)`(s) = GroupInv(X\\<rightarrow>G,F)`(s)\"\n    using group0.group0_3_T1 restrict by simp\n  moreover from T1 A1 A2 A4 have\n    \"GroupInv(X\\<rightarrow>G,F)`(s) = GroupInv(G,P) O s\"\n    using group0.group0_3_L2 Group_ZF_2_1_L6 by blast\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 533
    },
    "489": {
        "type": "lemma",
        "text": "text\\<open>If a group is abelian, then its lift to a function space is also \n  abelian.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  and A2: \"P {is commutative on} G\"\n  ",
        "using": [
            "group_oper_fun",
            "func_ZF_2_L2",
            "group0_2_L1",
            "monoid0.group0_1_L3B"
        ],
        "statement": "lemma (in group0) Group_ZF_2_1_L7: \n  assumes A1: \"F = P {lifted to function space over} X\"\n  and A2: \"P {is commutative on} G\"\n  shows \"F {is commutative on} (X\\<rightarrow>G)\"\n",
        "proof": "proof-\n  from A1 A2  have\n    \"F {is commutative on} (X\\<rightarrow>range(P))\"\n    using group_oper_fun func_ZF_2_L2\n    by simp\n  moreover from groupAssum have \"range(P) = G\"\n    using group0_2_L1 monoid0.group0_1_L3B\n    by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 534
    },
    "490": {
        "type": "lemma",
        "text": "text\\<open>The neutral element class is neutral in the projection.\\<close>\n",
        "assumes": "assumes A1: \"equiv(G,r)\" and A2:\"Congruent2(r,f)\"\n  and A3: \"F = ProjFun2(G,r,f)\" \n  and A4: \"e = TheNeutralElement(G,f)\"\n  ",
        "using": [
            "unit_is_neutral",
            "quotientI",
            "quotient_def",
            "EquivClass_1_L10"
        ],
        "statement": "lemma (in monoid0) Group_ZF_2_2_L1: \n  assumes A1: \"equiv(G,r)\" and A2:\"Congruent2(r,f)\"\n  and A3: \"F = ProjFun2(G,r,f)\" \n  and A4: \"e = TheNeutralElement(G,f)\"\n  shows \"r``{e} \\<in> G//r \\<and> \n  (\\<forall>c \\<in> G//r. F`\\<langle> r``{e},c\\<rangle> = c \\<and>  F`\\<langle> c,r``{e}\\<rangle> = c)\"\n",
        "proof": "proof\n  from A4 show T1:\"r``{e} \\<in> G//r\"\n    using unit_is_neutral quotientI\n    by simp\n  show \n    \"\\<forall>c \\<in> G//r. F`\\<langle> r``{e},c\\<rangle> = c \\<and>  F`\\<langle> c,r``{e}\\<rangle> = c\"\n  proof\n    fix c assume A5:\"c \\<in> G//r\"\n    then obtain g where D1:\"g\\<in>G\" \"c = r``{g}\"\n      using quotient_def by auto\n    with A1 A2 A3 A4 D1 show \n      \"F`\\<langle> r``{e},c\\<rangle> = c \\<and>  F`\\<langle> c,r``{e}\\<rangle> = c\"\n      using unit_is_neutral EquivClass_1_L10 \n      by simp\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 535
    },
    "491": {
        "type": "theorem",
        "text": "text\\<open>The projected structure is a monoid.\\<close>\n",
        "assumes": "assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"F = ProjFun2(G,r,f)\"\n  ",
        "using": [
            "Group_ZF_2_2_L1",
            "IsAmonoid_def",
            "EquivClass_2_T2"
        ],
        "statement": "theorem (in monoid0) Group_ZF_2_2_T1:\n  assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,f)\"\n  and A3: \"F = ProjFun2(G,r,f)\"\n  shows \"IsAmonoid(G//r,F)\"\n",
        "proof": "proof -\n  let ?E = \"r``{TheNeutralElement(G,f)}\"\n  from A1 A2 A3 have \n    \"?E \\<in> G//r \\<and> (\\<forall>c\\<in>G//r. F`\\<langle> ?E,c\\<rangle> = c \\<and> F`\\<langle> c,?E\\<rangle> = c)\"\n    using Group_ZF_2_2_L1 by simp\n  hence\n    \"\\<exists>E\\<in>G//r. \\<forall> c\\<in>G//r. F`\\<langle> E,c\\<rangle> = c \\<and> F`\\<langle> c,E\\<rangle> = c\"\n    by auto\n  with monoidAssum A1 A2 A3 show ?thesis\n    using IsAmonoid_def EquivClass_2_T2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 536
    },
    "492": {
        "type": "lemma",
        "text": "text\\<open>The class of the neutral element is the neutral element of the\n  projected monoid.\\<close>\n",
        "assumes": "assumes A1: \"IsAmonoid(G,f)\"\n  and A2: \"equiv(G,r)\" and A3: \"Congruent2(r,f)\"\n  and A4: \"F = ProjFun2(G,r,f)\"\n  and A5: \"e = TheNeutralElement(G,f)\"\n  ",
        "using": [
            "monoid0_def",
            "monoid0.Group_ZF_2_2_T1",
            "monoid0.Group_ZF_2_2_L1",
            "monoid0.group0_1_L4"
        ],
        "statement": "lemma Group_ZF_2_2_L1:\n  assumes A1: \"IsAmonoid(G,f)\"\n  and A2: \"equiv(G,r)\" and A3: \"Congruent2(r,f)\"\n  and A4: \"F = ProjFun2(G,r,f)\"\n  and A5: \"e = TheNeutralElement(G,f)\"\n  shows \" r``{e} = TheNeutralElement(G//r,F)\"\n",
        "proof": "proof -\n  from A1 A2 A3 A4 have \n    T1:\"monoid0(G,f)\" and T2:\"monoid0(G//r,F)\"\n    using monoid0_def monoid0.Group_ZF_2_2_T1 by auto\n  from T1 A2 A3 A4 A5 have \"r``{e} \\<in> G//r \\<and> \n    (\\<forall>c \\<in> G//r. F`\\<langle> r``{e},c\\<rangle> = c \\<and>  F`\\<langle> c,r``{e}\\<rangle> = c)\"\n    using monoid0.Group_ZF_2_2_L1 by simp\n  with T2 show ?thesis using monoid0.group0_1_L4\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 537
    },
    "493": {
        "type": "lemma",
        "text": "text\\<open>The projected operation can be defined in terms of the group operation\n  on representants in a natural way.\\<close>\n",
        "assumes": "assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,P)\"\n  and A3: \"F = ProjFun2(G,r,P)\"\n  and A4: \"a\\<in>G\" \"b\\<in>G\"\n  ",
        "using": [
            "EquivClass_1_L10"
        ],
        "statement": "lemma (in group0) Group_ZF_2_2_L2:\n  assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,P)\"\n  and A3: \"F = ProjFun2(G,r,P)\"\n  and A4: \"a\\<in>G\" \"b\\<in>G\"\n  shows \"F`\\<langle> r``{a},r``{b}\\<rangle> = r``{a\\<cdot>b}\"\n",
        "proof": "proof -\n  from A1 A2 A3 A4 show ?thesis\n    using EquivClass_1_L10 by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 538
    },
    "494": {
        "type": "lemma",
        "text": "text\\<open>The class of the inverse is a right inverse of the class.\\<close>\n",
        "assumes": "assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,P)\"\n  and A3: \"F = ProjFun2(G,r,P)\"\n  and A4: \"a\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "Group_ZF_2_2_L2",
            "group0_2_L6",
            "IsAgroup_def",
            "Group_ZF_2_2_L1"
        ],
        "statement": "lemma (in group0) Group_ZF_2_2_L3:\n  assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,P)\"\n  and A3: \"F = ProjFun2(G,r,P)\"\n  and A4: \"a\\<in>G\"\n  shows \"F`\\<langle>r``{a},r``{a\\<inverse>}\\<rangle> = TheNeutralElement(G//r,F)\"\n",
        "proof": "proof -\n  from A1 A2 A3 A4 have\n    \"F`\\<langle>r``{a},r``{a\\<inverse>}\\<rangle> = r``{\\<one>}\"\n    using inverse_in_group Group_ZF_2_2_L2 group0_2_L6 \n    by simp\n  with groupAssum A1 A2 A3 show ?thesis\n    using IsAgroup_def Group_ZF_2_2_L1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 539
    },
    "495": {
        "type": "lemma",
        "text": "text\\<open>The group inverse (in the projected group) of a class is the class\n  of the inverse.\\<close>\n",
        "assumes": "assumes A1: \"equiv(G,r)\" and \n  A2: \"Congruent2(r,P)\" and \n  A3: \"F = ProjFun2(G,r,P)\" and\n  A4: \"a\\<in>G\"\n  ",
        "using": [
            "Group_ZF_3_T2",
            "group0_def",
            "inverse_in_group",
            "quotientI",
            "Group_ZF_2_2_L3"
        ],
        "statement": "lemma (in group0) Group_ZF_2_2_L4:\n  assumes A1: \"equiv(G,r)\" and \n  A2: \"Congruent2(r,P)\" and \n  A3: \"F = ProjFun2(G,r,P)\" and\n  A4: \"a\\<in>G\"\n  shows \"r``{a\\<inverse>} = GroupInv(G//r,F)`(r``{a})\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \"group0(G//r,F)\"\n    using Group_ZF_3_T2 group0_def by simp\n  moreover from A4 have \n    \"r``{a} \\<in> G//r\"  \"r``{a\\<inverse>} \\<in> G//r\"\n    using inverse_in_group quotientI by auto\n  moreover from A1 A2 A3 A4 have\n     \"F`\\<langle>r``{a},r``{a\\<inverse>}\\<rangle> = TheNeutralElement(G//r,F)\"\n    using Group_ZF_2_2_L3 by simp\n  ultimately show ?thesis\n    by (rule group0.group0_2_L9)\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 541
    },
    "496": {
        "type": "definition",
        "text": "text\\<open>A normal subgorup $N$ of a group $G$ is such that $aba^{-1}$ belongs to \n  $N$ if $a\\in G, b\\in N$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAnormalSubgroup(G,P,N) \\<equiv> IsAsubgroup(N,P) \\<and> \n  (\\<forall>n\\<in>N.\\<forall>g\\<in>G. P`\\<langle>  P`\\<langle>  g,n \\<rangle>,GroupInv(G,P)`(g) \\<rangle> \\<in> N)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 542
    },
    "497": {
        "type": "definition",
        "text": "text\\<open>Having a group and a normal subgroup $N$ \n  we can create another group\n  consisting of eqivalence classes of the relation \n  $a\\sim b \\equiv a\\cdot b^{-1} \\in N$.  We will refer to this relation\n  as the quotient group relation. The classes of this relation are in \n  fact cosets of subgroup $H$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"QuotientGroupRel(G,P,H) \\<equiv> \n  {\\<langle> a,b\\<rangle> \\<in> G\\<times>G. P`\\<langle> a, GroupInv(G,P)`(b)\\<rangle> \\<in> H}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 543
    },
    "498": {
        "type": "definition",
        "text": "text\\<open>Next we define the operation in the quotient group as the\n  projection of the group operation on the classses of the\n  quotient group relation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"QuotientGroupOp(G,P,H) \\<equiv> ProjFun2(G,QuotientGroupRel(G,P,H ),P)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 544
    },
    "499": {
        "type": "lemma",
        "text": "text\\<open>The quotient group relation is reflexive.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "assms",
            "group0_2_L6",
            "group0_3_L5",
            "QuotientGroupRel_def",
            "refl_def"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L1: \n  assumes \"IsAsubgroup(H,P)\"\n  shows \"refl(G,QuotientGroupRel(G,P,H))\"\n  ",
        "proof": "using assms  group0_2_L6 group0_3_L5 \n    QuotientGroupRel_def refl_def by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 546
    },
    "500": {
        "type": "lemma",
        "text": "text\\<open>The quotient group relation is transistive.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,P)\" and \n  A2: \"\\<langle> a,b\\<rangle> \\<in> QuotientGroupRel(G,P,H)\" and \n  A3: \"\\<langle> b,c\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n  ",
        "using": [
            "QuotientGroupRel_def",
            "group0_3_L6",
            "group0_2_L14A"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L3A:\n  assumes A1: \"IsAsubgroup(H,P)\" and \n  A2: \"\\<langle> a,b\\<rangle> \\<in> QuotientGroupRel(G,P,H)\" and \n  A3: \"\\<langle> b,c\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n  shows \"\\<langle> a,c\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n",
        "proof": "proof -\n  let ?r = \"QuotientGroupRel(G,P,H)\"\n  from A2 A3 have T1:\"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\"\n    using QuotientGroupRel_def by auto\n  from A1 A2 A3 have \"(a\\<cdot>b\\<inverse>)\\<cdot>(b\\<cdot>c\\<inverse>) \\<in> H\"\n    using  QuotientGroupRel_def group0_3_L6\n    by simp\n  moreover from T1 have \n    \"a\\<cdot>c\\<inverse> = (a\\<cdot>b\\<inverse>)\\<cdot>(b\\<cdot>c\\<inverse>)\"\n    using group0_2_L14A by blast\n  ultimately have \"a\\<cdot>c\\<inverse> \\<in> H\" \n    by simp\n  with T1 show ?thesis using QuotientGroupRel_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 548
    },
    "501": {
        "type": "lemma",
        "text": "text\\<open>The quotient group relation is an equivalence relation. Note\n  we do not need the subgroup to be normal for this to be true.\\<close>\n",
        "assumes": "assumes A1:\"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "Group_ZF_2_4_L3A",
            "Fol1_L2",
            "Group_ZF_2_4_L1",
            "Group_ZF_2_4_L2",
            "QuotientGroupRel_def",
            "equiv_def"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L3: assumes A1:\"IsAsubgroup(H,P)\"\n  shows \"equiv(G,QuotientGroupRel(G,P,H))\"\n",
        "proof": "proof -\n  let ?r = \"QuotientGroupRel(G,P,H)\"\n  from A1 have \n     \"\\<forall>a b c. (\\<langle>a, b\\<rangle> \\<in> ?r  \\<and>  \\<langle>b, c\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>a, c\\<rangle> \\<in> ?r)\"\n    using Group_ZF_2_4_L3A by blast\n  then have \"trans(?r)\"\n    using Fol1_L2 by blast\n  with A1 show ?thesis \n    using Group_ZF_2_4_L1 Group_ZF_2_4_L2 \n      QuotientGroupRel_def equiv_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 549
    },
    "502": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states the essential condition for congruency of \n  the group operation with respect to the quotient group relation.\\<close>\n",
        "assumes": "assumes A1: \"IsAnormalSubgroup(G,P,H)\"\n  and A2: \"\\<langle>a1,a2\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n  and A3: \"\\<langle>b1,b2\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n  ",
        "using": [
            "QuotientGroupRel_def",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "IsAnormalSubgroup_def",
            "group0_3_L6",
            "group0_2_L15"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L4: \n  assumes A1: \"IsAnormalSubgroup(G,P,H)\"\n  and A2: \"\\<langle>a1,a2\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n  and A3: \"\\<langle>b1,b2\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n  shows \"\\<langle>a1\\<cdot>b1, a2\\<cdot>b2\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n",
        "proof": "proof -\n  from A2 A3 have T1:\n    \"a1\\<in>G\"  \"a2\\<in>G\"  \"b1\\<in>G\"  \"b2\\<in>G\"\n    \"a1\\<cdot>b1 \\<in> G\"  \"a2\\<cdot>b2 \\<in> G\"\n    \"b1\\<cdot>b2\\<inverse> \\<in> H\"  \"a1\\<cdot>a2\\<inverse> \\<in> H\"\n    using QuotientGroupRel_def group0_2_L1 monoid0.group0_1_L1\n    by auto\n  with A1 show ?thesis using\n    IsAnormalSubgroup_def group0_3_L6 group0_2_L15\n    QuotientGroupRel_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 550
    },
    "503": {
        "type": "lemma",
        "text": "text\\<open>If the subgroup is normal, the group operation is congruent \n  with respect to the quotient group relation.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\"\n  and \"IsAnormalSubgroup(G,P,H)\" \n  ",
        "using": [
            "assms",
            "group0_def",
            "group0.Group_ZF_2_4_L4",
            "Congruent2_def"
        ],
        "statement": "lemma Group_ZF_2_4_L5A:\n  assumes \"IsAgroup(G,P)\"\n  and \"IsAnormalSubgroup(G,P,H)\" \n  shows \"Congruent2(QuotientGroupRel(G,P,H),P)\"\n  ",
        "proof": "using assms group0_def group0.Group_ZF_2_4_L4 Congruent2_def\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 551
    },
    "504": {
        "type": "theorem",
        "text": "text\\<open>The quotient group is indeed a group.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" and \"IsAnormalSubgroup(G,P,H)\"\n  ",
        "using": [
            "assms",
            "group0_def",
            "group0.Group_ZF_2_4_L3",
            "IsAnormalSubgroup_def",
            "Group_ZF_2_4_L5A",
            "group0.Group_ZF_3_T2",
            "QuotientGroupOp_def"
        ],
        "statement": "theorem Group_ZF_2_4_T1:\n  assumes \"IsAgroup(G,P)\" and \"IsAnormalSubgroup(G,P,H)\"\n  shows   \n  \"IsAgroup(G//QuotientGroupRel(G,P,H),QuotientGroupOp(G,P,H))\"\n  ",
        "proof": "using assms group0_def group0.Group_ZF_2_4_L3 IsAnormalSubgroup_def\n    Group_ZF_2_4_L5A group0.Group_ZF_3_T2 QuotientGroupOp_def\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 552
    },
    "505": {
        "type": "lemma",
        "text": "text\\<open>The class (coset) of the neutral element is the neutral\n  element of the quotient group.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" and \"IsAnormalSubgroup(G,P,H)\"\n  and \"r = QuotientGroupRel(G,P,H)\"\n  and \"e = TheNeutralElement(G,P)\"\n  ",
        "using": [
            "assms",
            "IsAnormalSubgroup_def",
            "group0_def",
            "IsAgroup_def",
            "group0.Group_ZF_2_4_L3",
            "Group_ZF_2_4_L5A",
            "QuotientGroupOp_def",
            "Group_ZF_2_2_L1"
        ],
        "statement": "lemma Group_ZF_2_4_L5B: \n  assumes \"IsAgroup(G,P)\" and \"IsAnormalSubgroup(G,P,H)\"\n  and \"r = QuotientGroupRel(G,P,H)\"\n  and \"e = TheNeutralElement(G,P)\"\n  shows \" r``{e} = TheNeutralElement(G//r,QuotientGroupOp(G,P,H))\"\n  ",
        "proof": "using assms IsAnormalSubgroup_def group0_def\n    IsAgroup_def group0.Group_ZF_2_4_L3 Group_ZF_2_4_L5A\n    QuotientGroupOp_def Group_ZF_2_2_L1\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 553
    },
    "506": {
        "type": "lemma",
        "text": "text\\<open>A group element is equivalent to the neutral element iff it is in the\n  subgroup we divide the group by.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"\n  ",
        "using": [
            "assms",
            "QuotientGroupRel_def",
            "group_inv_of_one",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L5C: assumes \"a\\<in>G\"\n  shows \"\\<langle>a,\\<one>\\<rangle> \\<in> QuotientGroupRel(G,P,H) \\<longleftrightarrow> a\\<in>H\"\n  ",
        "proof": "using assms QuotientGroupRel_def group_inv_of_one group0_2_L2\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 554
    },
    "507": {
        "type": "lemma",
        "text": "text\\<open>A group element is in $H$ iff its class is the neutral element of\n  $G/H$.\\<close>\n",
        "assumes": "assumes A1: \"IsAnormalSubgroup(G,P,H)\" and \n  A2: \"a\\<in>G\" and \n  A3: \"r = QuotientGroupRel(G,P,H)\" and\n  A4: \"TheNeutralElement(G//r,QuotientGroupOp(G,P,H)) = e\"\n  ",
        "using": [
            "Group_ZF_2_4_L5B",
            "IsAnormalSubgroup_def",
            "Group_ZF_2_4_L3",
            "eq_equiv_class",
            "equiv_class_eq"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L5D:\n  assumes A1: \"IsAnormalSubgroup(G,P,H)\" and \n  A2: \"a\\<in>G\" and \n  A3: \"r = QuotientGroupRel(G,P,H)\" and\n  A4: \"TheNeutralElement(G//r,QuotientGroupOp(G,P,H)) = e\"\n  shows \"r``{a} = e \\<longleftrightarrow> \\<langle>a,\\<one>\\<rangle> \\<in> r\"\n",
        "proof": "proof\n  assume \"r``{a} = e\"\n  with groupAssum assms have \n    \"r``{\\<one>} = r``{a}\" and I: \"equiv(G,r)\"\n    using Group_ZF_2_4_L5B IsAnormalSubgroup_def Group_ZF_2_4_L3\n    by auto\n  with A2 have \"\\<langle>\\<one>,a\\<rangle> \\<in> r\" using eq_equiv_class \n    by simp\n  with I show \"\\<langle>a,\\<one>\\<rangle> \\<in> r\" by (rule equiv_is_sym)\nnext assume \"\\<langle>a,\\<one>\\<rangle> \\<in> r\"\n  moreover from A1 A3 have \"equiv(G,r)\"\n    using IsAnormalSubgroup_def Group_ZF_2_4_L3\n    by simp\n  ultimately have \"r``{a} = r``{\\<one>}\"\n    using equiv_class_eq by simp\n  with groupAssum A1 A3 A4 show \"r``{a} = e\"\n    using Group_ZF_2_4_L5B by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 555
    },
    "508": {
        "type": "lemma",
        "text": "text\\<open>Every subgroup of an abelian group is normal. Moreover, the quotient\n  group is also abelian.\\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,P)\"\n  and A2: \"P {is commutative on} G\" \n  and A3: \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "group0_def",
            "IsAnormalSubgroup_def",
            "group0.Group_ZF_2_4_L5",
            "group0.Group_ZF_2_4_L3",
            "Group_ZF_2_4_L5A",
            "EquivClass_2_T1",
            "QuotientGroupOp_def"
        ],
        "statement": "lemma Group_ZF_2_4_L6:\n  assumes A1: \"IsAgroup(G,P)\"\n  and A2: \"P {is commutative on} G\" \n  and A3: \"IsAsubgroup(H,P)\"\n  shows  \"IsAnormalSubgroup(G,P,H)\"\n  \"QuotientGroupOp(G,P,H) {is commutative on} (G//QuotientGroupRel(G,P,H))\"\n",
        "proof": "proof -\n  from A1 A2 A3 show T1: \"IsAnormalSubgroup(G,P,H)\" using\n    group0_def IsAnormalSubgroup_def group0.Group_ZF_2_4_L5 \n    by simp\n  let ?r = \"QuotientGroupRel(G,P,H)\"\n  from A1 A3 T1 have \"equiv(G,?r)\" \"Congruent2(?r,P)\"\n    using group0_def group0.Group_ZF_2_4_L3 Group_ZF_2_4_L5A\n    by auto\n  with A2 show \n    \"QuotientGroupOp(G,P,H) {is commutative on} (G//QuotientGroupRel(G,P,H))\"\n    using EquivClass_2_T1 QuotientGroupOp_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 558
    },
    "509": {
        "type": "lemma",
        "text": "text\\<open>The group inverse (in the quotient group) of a class (coset) is the class\n  of the inverse.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,P,H)\" \n  and \"a\\<in>G\" and \"r = QuotientGroupRel(G,P,H)\" \n  and \"F = QuotientGroupOp(G,P,H)\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "IsAnormalSubgroup_def",
            "Group_ZF_2_4_L3",
            "Group_ZF_2_4_L5A",
            "QuotientGroupOp_def",
            "Group_ZF_2_2_L4"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L7: \n  assumes \"IsAnormalSubgroup(G,P,H)\" \n  and \"a\\<in>G\" and \"r = QuotientGroupRel(G,P,H)\" \n  and \"F = QuotientGroupOp(G,P,H)\"\n  shows \"r``{a\\<inverse>} = GroupInv(G//r,F)`(r``{a})\"\n  ",
        "proof": "using groupAssum assms IsAnormalSubgroup_def Group_ZF_2_4_L3 \n    Group_ZF_2_4_L5A QuotientGroupOp_def Group_ZF_2_2_L4\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 559
    },
    "510": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states that composition has a neutral element, \n  namely the identity function on $X$ \n  (the one that maps $x\\in X$ into itself).\\<close>\n",
        "assumes": "assumes A1: \"F = Composition(X)\"\n  ",
        "using": [
            "id_type",
            "func_ZF_6_L1A"
        ],
        "statement": "lemma Group_ZF_2_5_L1: assumes A1: \"F = Composition(X)\"\n  shows \"\\<exists>I\\<in>(X\\<rightarrow>X). \\<forall>f\\<in>(X\\<rightarrow>X). F`\\<langle> I,f\\<rangle> = f \\<and> F`\\<langle> f,I\\<rangle> = f\"\n",
        "proof": "proof-\n  let ?I = \"id(X)\"\n  from A1 have \n    \"?I \\<in> X\\<rightarrow>X \\<and> (\\<forall>f\\<in>(X\\<rightarrow>X). F`\\<langle> ?I,f\\<rangle> = f \\<and> F`\\<langle> f,?I\\<rangle> = f)\" \n    using id_type func_ZF_6_L1A by simp\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 560
    },
    "511": {
        "type": "lemma",
        "text": "text\\<open>The space of functions that map a set $X$ into \n  itsef is a monoid with composition as operation and the identity function\n  as the neutral element.\\<close>\n",
        "assumes": "",
        "using": [
            "func_ZF_5_L5",
            "Group_ZF_2_5_L1",
            "IsAmonoid_def",
            "monoid0_def",
            "id_type",
            "func_ZF_6_L1A",
            "monoid0.group0_1_L4"
        ],
        "statement": "lemma Group_ZF_2_5_L2: shows\n  \"IsAmonoid(X\\<rightarrow>X,Composition(X))\"\n  \"id(X) = TheNeutralElement(X\\<rightarrow>X,Composition(X))\"\n",
        "proof": "proof -\n  let ?I = \"id(X)\"\n  let ?F = \"Composition(X)\"\n  show \"IsAmonoid(X\\<rightarrow>X,Composition(X))\" \n    using func_ZF_5_L5 Group_ZF_2_5_L1 IsAmonoid_def\n    by auto  \n  then have \"monoid0(X\\<rightarrow>X,?F)\"\n    using monoid0_def by simp\n  moreover have\n    \"?I \\<in> X\\<rightarrow>X \\<and> (\\<forall>f\\<in>(X\\<rightarrow>X). ?F`\\<langle> ?I,f\\<rangle> = f \\<and> ?F`\\<langle> f,?I\\<rangle> = f)\"\n    using id_type func_ZF_6_L1A by simp\n  ultimately show \"?I = TheNeutralElement(X\\<rightarrow>X,?F)\"\n    using monoid0.group0_1_L4 by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 561
    },
    "512": {
        "type": "lemma",
        "text": "text\\<open>The following proves the essential condition to show that the set of \n  finite range functions is\n  closed with respect to the lifted group operation.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  and \n  A2: \"s \\<in> FinRangeFunctions(X,G)\"  \"r \\<in>  FinRangeFunctions(X,G)\" \n  ",
        "using": [
            "FinRangeFunctions_def",
            "group0_2_L1",
            "monoid0.Group_ZF_2_1_L0",
            "Finite1_L18",
            "group_oper_fun",
            "Finite1_L15",
            "Group_ZF_2_1_L3",
            "func_imagedef"
        ],
        "statement": "lemma (in group0) Group_ZF_3_1_L1: \n  assumes A1: \"F = P {lifted to function space over} X\"\n  and \n  A2: \"s \\<in> FinRangeFunctions(X,G)\"  \"r \\<in>  FinRangeFunctions(X,G)\" \n  shows \"F`\\<langle> s,r\\<rangle> \\<in> FinRangeFunctions(X,G)\"\n",
        "proof": "proof -\n  let ?q = \"F`\\<langle> s,r\\<rangle>\"\n  from A2 have T1:\"s:X\\<rightarrow>G\" \"r:X\\<rightarrow>G\"\n    using FinRangeFunctions_def by auto\n  with A1 have T2:\"?q : X\\<rightarrow>G\"\n    using group0_2_L1 monoid0.Group_ZF_2_1_L0\n    by simp\n  moreover have \"?q``(X) \\<in> Fin(G)\"\n  proof -\n    from A2 have\n      \"{s`(x). x\\<in>X} \\<in> Fin(G)\"\n      \"{r`(x). x\\<in>X} \\<in> Fin(G)\"\n      using Finite1_L18 by auto\n    with A1 T1 T2 show ?thesis using \n      group_oper_fun Finite1_L15 Group_ZF_2_1_L3 func_imagedef\n      by simp\n  qed\n  ultimately show ?thesis using FinRangeFunctions_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 562
    },
    "513": {
        "type": "lemma",
        "text": "text\\<open>A composition of a finite range function with the group inverse is\n  a finite range function.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> FinRangeFunctions(X,G)\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "group0_2_T2",
            "Finite1_L20"
        ],
        "statement": "lemma (in group0) Group_ZF_3_1_L3: \n  assumes A1: \"s \\<in> FinRangeFunctions(X,G)\"\n  shows \"GroupInv(G,P) O s \\<in> FinRangeFunctions(X,G)\"\n  ",
        "proof": "using groupAssum assms group0_2_T2 Finite1_L20 by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 564
    },
    "514": {
        "type": "theorem",
        "text": "text\\<open>The set of finite range functions is s subgroup of the lifted group.\\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,P)\" \n  and A2: \"F = P {lifted to function space over} X\"\n  and A3: \"X\\<noteq>0\"\n  ",
        "using": [
            "group0_def",
            "group0.Group_ZF_2_1_T2",
            "group0.group0_2_L1",
            "monoid0.unit_is_neutral",
            "Finite1_L17",
            "FinRangeFunctions_def",
            "group0.Group_ZF_3_1_L2",
            "group0.Group_ZF_2_1_L6",
            "group0.Group_ZF_3_1_L3",
            "group0.group0_3_T3"
        ],
        "statement": "theorem Group_ZF_3_1_T1: \n  assumes A1: \"IsAgroup(G,P)\" \n  and A2: \"F = P {lifted to function space over} X\"\n  and A3: \"X\\<noteq>0\"\n  shows \"IsAsubgroup(FinRangeFunctions(X,G),F)\"\n",
        "proof": "proof -\n  let ?e = \"TheNeutralElement(G,P)\"\n  let ?S = \"FinRangeFunctions(X,G)\"\n  from A1 have T1: \"group0(G,P)\" using group0_def \n    by simp\n  with A1 A2 have T2:\"group0(X\\<rightarrow>G,F)\"\n    using group0.Group_ZF_2_1_T2 group0_def\n    by simp\n  moreover have \"?S \\<noteq> 0\"\n  proof -   \n    from T1 A3 have \n      \"ConstantFunction(X,?e) \\<in> ?S\"\n      using group0.group0_2_L1 monoid0.unit_is_neutral\n\tFinite1_L17 by simp\n    thus ?thesis by auto\n  qed\n  moreover have \"?S \\<subseteq> X\\<rightarrow>G\"\n    using FinRangeFunctions_def by auto\n  moreover from A2 T1 have\n    \"?S {is closed under} F\"\n    using group0.Group_ZF_3_1_L2\n    by simp\n  moreover from A1 A2 T1 have\n    \"\\<forall>s \\<in> ?S. GroupInv(X\\<rightarrow>G,F)`(s) \\<in> ?S\"\n    using FinRangeFunctions_def group0.Group_ZF_2_1_L6\n      group0.Group_ZF_3_1_L3 by simp\n  ultimately show ?thesis\n    using group0.group0_3_T3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 565
    },
    "515": {
        "type": "definition",
        "text": "text\\<open>HomDiff is an acronym for \"homomorphism difference\". \n  This is the expression\n  $s(mn)(s(m)s(n))^{-1}$, or $s(m+n)-s(m)-s(n)$ in the additive notation.\n  It is equal to the neutral element of the group if $s$ is a homomorphism.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HomDiff(G,f,s,x) \\<equiv> \n  f`\\<langle>s`(f`\\<langle> fst(x),snd(x)\\<rangle>) , \n  (GroupInv(G,f)`(f`\\<langle> s`(fst(x)),s`(snd(x))\\<rangle>))\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 566
    },
    "516": {
        "type": "definition",
        "text": "text\\<open>Almost homomorphisms are defined as those maps \n  $s:G\\rightarrow G$ such that the \n  homomorphism difference takes only finite number of values on $G\\times G$.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"AlmostHoms(G,f) \\<equiv> \n  {s \\<in> G\\<rightarrow>G.{HomDiff(G,f,s,x). x \\<in> G\\<times>G } \\<in> Fin(G)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 567
    },
    "517": {
        "type": "definition",
        "text": "text\\<open>AlHomOp1$(G,f)$ is the group operation on almost \n  homomorphisms defined in a natural way \n  by $(s\\cdot r)(n) = s(n)\\cdot r(n)$. In the terminology defined in \n  func1.thy this is the group operation $f$ (on $G$) \n  lifted to the function space $G\\rightarrow G$ and restricted to the set \n  AlmostHoms$(G,f)$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"AlHomOp1(G,f) \\<equiv> \n  restrict(f {lifted to function space over} G,\n  AlmostHoms(G,f)\\<times>AlmostHoms(G,f))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 568
    },
    "518": {
        "type": "lemma",
        "text": "text\\<open>This lemma provides more readable notation for the HomDiff\n  definition. Not really intended to be used in proofs, but just to see the\n  definition in the notation defined in the group0 locale.\\<close>\n",
        "assumes": "",
        "using": [
            "HomDiff_def"
        ],
        "statement": "lemma (in group0) HomDiff_notation:\n  shows \"HomDiff(G,P,s,\\<langle> m,n\\<rangle>) = s`(m\\<cdot>n)\\<cdot>(s`(m)\\<cdot>s`(n))\\<inverse>\"\n  ",
        "proof": "using HomDiff_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 570
    },
    "519": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows the set from the definition of almost \n  homomorphism in a different form.\\<close>\n",
        "assumes": "",
        "using": [
            "HomDiff_notation"
        ],
        "statement": "lemma (in group0) Group_ZF_3_2_L1A: shows\n  \"{HomDiff(G,P,s,x). x \\<in> G\\<times>G } = {s`(m\\<cdot>n)\\<cdot>(s`(m)\\<cdot>s`(n))\\<inverse>. \\<langle> m,n\\<rangle> \\<in> G\\<times>G}\"\n",
        "proof": "proof -\n  have \"\\<forall>m\\<in>G.\\<forall>n\\<in>G. HomDiff(G,P,s,\\<langle> m,n\\<rangle>) = s`(m\\<cdot>n)\\<cdot>(s`(m)\\<cdot>s`(n))\\<inverse>\"\n    using HomDiff_notation by simp\n  then show ?thesis by (rule ZF1_1_L4A)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 571
    },
    "520": {
        "type": "lemma",
        "text": "text\\<open>HomDiff is a homomorphism on the lifted group structure.\\<close>\n",
        "assumes": "assumes A1: \"s:G\\<rightarrow>G\"  \"r:G\\<rightarrow>G\"\n  and A2: \"x \\<in> G\\<times>G\"\n  and A3: \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "apply_funtype",
            "monoid0.Group_ZF_2_1_L0",
            "HomDiff_notation",
            "group_inv_of_two",
            "Group_ZF_2_1_L3",
            "group0_4_L3"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L1: \n  assumes A1: \"s:G\\<rightarrow>G\"  \"r:G\\<rightarrow>G\"\n  and A2: \"x \\<in> G\\<times>G\"\n  and A3: \"F = P {lifted to function space over} G\"\n  shows \"\\<delta>(F`\\<langle> s,r\\<rangle>,x) = \\<delta>(s,x)\\<cdot>\\<delta>(r,x)\"\n",
        "proof": "proof -\n  let ?p = \"F`\\<langle> s,r\\<rangle>\"\n  from A2 obtain m n where\n    D1: \"x = \\<langle> m,n\\<rangle>\" \"m\\<in>G\" \"n\\<in>G\" \n    by auto\n  then have T1:\"m\\<cdot>n \\<in> G\"\n    using group0_2_L1 monoid0.group0_1_L1 by simp\n  with A1 D1 have T2:\n    \"s`(m)\\<in>G\" \"s`(n)\\<in>G\" \"r`(m)\\<in>G\" \n    \"r`(n)\\<in>G\" \"s`(m\\<cdot>n)\\<in>G\" \"r`(m\\<cdot>n)\\<in>G\"\n    using apply_funtype by auto\n  from A3 A1 have T3:\"?p : G\\<rightarrow>G\"\n    using group0_2_L1 monoid0.Group_ZF_2_1_L0\n    by simp\n  from D1 T3 have\n    \"\\<delta>(?p,x) = ?p`(m\\<cdot>n)\\<cdot>((?p`(n))\\<inverse>\\<cdot>(?p`(m))\\<inverse>)\"\n    using HomDiff_notation apply_funtype group_inv_of_two \n    by simp\n  also from A3 A1 D1 T1 isAbelian T2 have\n    \"\\<dots> = \\<delta>(s,x)\\<cdot> \\<delta>(r,x)\"\n    using Group_ZF_2_1_L3 group0_4_L3 HomDiff_notation\n    by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 572
    },
    "521": {
        "type": "lemma",
        "text": "text\\<open>The group operation lifted to the function space over $G$ preserves\n  almost homomorphisms.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> AH\" \"r \\<in> AH\"\n  and A2: \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "AlmostHoms_def",
            "group0_2_L1",
            "monoid0.Group_ZF_2_1_L0",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "Finite1_L15",
            "Group_ZF_3_2_L1"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L2: assumes A1: \"s \\<in> AH\" \"r \\<in> AH\"\n  and A2: \"F = P {lifted to function space over} G\"\n  shows \"F`\\<langle> s,r\\<rangle> \\<in> AH\"\n",
        "proof": "proof -\n  let ?p = \"F`\\<langle> s,r\\<rangle>\"\n  from A1 A2 have \"?p : G\\<rightarrow>G\"\n    using AlmostHoms_def group0_2_L1 monoid0.Group_ZF_2_1_L0\n    by simp\n  moreover have\n    \"{\\<delta>(?p,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n  proof -\n    from A1 have\n      \"{\\<delta>(s,x). x \\<in> G\\<times>G } \\<in> Fin(G)\" \n      \"{\\<delta>(r,x). x \\<in> G\\<times>G } \\<in> Fin(G)\"\n      using AlmostHoms_def by auto\n    with groupAssum A1 A2 show ?thesis\n      using IsAgroup_def IsAmonoid_def IsAssociative_def\n      Finite1_L15 AlmostHoms_def Group_ZF_3_2_L1\n      by auto\n  qed\n  ultimately show ?thesis using AlmostHoms_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 573
    },
    "522": {
        "type": "lemma",
        "text": "text\\<open>The set of almost homomorphisms is closed under the \n  lifted group operation.\\<close>\n",
        "assumes": "assumes \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "assms",
            "IsOpClosed_def",
            "Group_ZF_3_2_L2"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L3:\n  assumes \"F = P {lifted to function space over} G\"\n  shows \"AH {is closed under} F\"\n  ",
        "proof": "using assms IsOpClosed_def Group_ZF_3_2_L2 by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 574
    },
    "523": {
        "type": "lemma",
        "text": "text\\<open>The terms in the homomorphism difference for a function\n  are in the group.\\<close>\n",
        "assumes": "assumes \"s:G\\<rightarrow>G\" and \"m\\<in>G\"  \"n\\<in>G\"\n  ",
        "using": [
            "assms",
            "group_op_closed",
            "inverse_in_group",
            "apply_funtype",
            "HomDiff_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L4:\n  assumes \"s:G\\<rightarrow>G\" and \"m\\<in>G\"  \"n\\<in>G\"\n  shows \n  \"m\\<cdot>n \\<in> G\" \n  \"s`(m\\<cdot>n) \\<in> G\"\n  \"s`(m) \\<in> G\" \"s`(n) \\<in> G\"\n  \"\\<delta>(s,\\<langle> m,n\\<rangle>) \\<in> G\"\n  \"s`(m)\\<cdot>s`(n) \\<in> G\"\n  ",
        "proof": "using assms group_op_closed inverse_in_group  \n    apply_funtype HomDiff_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 575
    },
    "524": {
        "type": "corollary",
        "text": "text\\<open>It is handy to have a version of \\<open> Group_ZF_3_2_L4\\<close>\n  specifically for almost homomorphisms.\\<close>\n",
        "assumes": "assumes \"s \\<in> AH\" and \"m\\<in>G\"  \"n\\<in>G\"\n  ",
        "using": [
            "assms",
            "AlmostHoms_def",
            "Group_ZF_3_2_L4"
        ],
        "statement": "corollary (in group1) Group_ZF_3_2_L4A:  \n  assumes \"s \\<in> AH\" and \"m\\<in>G\"  \"n\\<in>G\"\n  shows \"m\\<cdot>n \\<in> G\" \n  \"s`(m\\<cdot>n) \\<in> G\"\n  \"s`(m) \\<in> G\" \"s`(n) \\<in> G\"\n  \"\\<delta>(s,\\<langle> m,n\\<rangle>) \\<in> G\"\n  \"s`(m)\\<cdot>s`(n) \\<in> G\"\n  ",
        "proof": "using assms AlmostHoms_def Group_ZF_3_2_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 576
    },
    "525": {
        "type": "lemma",
        "text": "text\\<open>The terms in the homomorphism difference are in the group, \n  a different form.\\<close>\n",
        "assumes": "assumes A1:\"s \\<in> AH\" and A2:\"x\\<in>G\\<times>G\"\n  ",
        "using": [
            "Group_ZF_3_2_L4A"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L4B:  \n  assumes A1:\"s \\<in> AH\" and A2:\"x\\<in>G\\<times>G\"\n  shows \"fst(x)\\<cdot>snd(x) \\<in> G\" \n  \"s`(fst(x)\\<cdot>snd(x)) \\<in> G\"\n  \"s`(fst(x)) \\<in> G\" \"s`(snd(x)) \\<in> G\"\n  \"\\<delta>(s,x) \\<in> G\"\n  \"s`(fst(x))\\<cdot>s`(snd(x)) \\<in> G\"\n",
        "proof": "proof -\n  let ?m = \"fst(x)\" \n  let ?n = \"snd(x)\"\n  from A1 A2 show \n    \"?m\\<cdot>?n \\<in> G\"  \"s`(?m\\<cdot>?n) \\<in> G\" \n    \"s`(?m) \\<in> G\" \"s`(?n) \\<in> G\"\n    \"s`(?m)\\<cdot>s`(?n) \\<in> G\"\n    using Group_ZF_3_2_L4A\n    by auto\n  from A1 A2 have \"\\<delta>(s,\\<langle> ?m,?n\\<rangle>) \\<in> G\" using Group_ZF_3_2_L4A\n    by simp\n  moreover from A2 have \"\\<langle> ?m,?n\\<rangle> = x\" by auto\n  ultimately show \"\\<delta>(s,x) \\<in> G\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 577
    },
    "526": {
        "type": "lemma",
        "text": "text\\<open>What are the values of the inverse of an almost homomorphism?\\<close>\n",
        "assumes": "assumes \"s \\<in> AH\" and \"n\\<in>G\"\n  ",
        "using": [
            "assms",
            "AlmostHoms_def",
            "comp_fun_apply"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L5:\n  assumes \"s \\<in> AH\" and \"n\\<in>G\"\n  shows \"(\\<sim>s)`(n) = (s`(n))\\<inverse>\"\n  ",
        "proof": "using assms AlmostHoms_def comp_fun_apply by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 578
    },
    "527": {
        "type": "lemma",
        "text": "text\\<open>The inverse of an almost homomorphism  maps the group into itself.\\<close>\n",
        "assumes": "assumes \"s \\<in> AH\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "AlmostHoms_def",
            "group0_2_T2",
            "comp_fun"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L7: \n  assumes \"s \\<in> AH\"\n  shows \"\\<sim>s : G\\<rightarrow>G\"\n  ",
        "proof": "using groupAssum assms AlmostHoms_def group0_2_T2 comp_fun by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 580
    },
    "528": {
        "type": "lemma",
        "text": "text\\<open>The inverse of an almost homomorphism is an almost homomorphism.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} G\"\n  and A2: \"s \\<in> AH\"\n  ",
        "using": [
            "AlmostHoms_def",
            "group0_2_T2",
            "Finite1_L6A",
            "Group_ZF_3_2_L4B",
            "func1_1_L17",
            "Group_ZF_3_2_L6",
            "Group_ZF_3_2_L7",
            "Group_ZF_2_1_L6"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L8:\n  assumes A1: \"F = P {lifted to function space over} G\"\n  and A2: \"s \\<in> AH\"\n  shows \"GroupInv(G\\<rightarrow>G,F)`(s) \\<in> AH\"\n",
        "proof": "proof -\n  from A2 have \"{\\<delta>(s,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n    using AlmostHoms_def by simp\n  with groupAssum  have\n    \"GroupInv(G,P)``{\\<delta>(s,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n    using group0_2_T2 Finite1_L6A by blast\n  moreover have \n     \"GroupInv(G,P)``{\\<delta>(s,x). x \\<in> G\\<times>G} =\n    {(\\<delta>(s,x))\\<inverse>. x \\<in> G\\<times>G}\"\n  proof -\n    from groupAssum have \n      \"GroupInv(G,P) : G\\<rightarrow>G\"\n      using group0_2_T2 by simp\n    moreover from A2 have \n      \"\\<forall>x\\<in>G\\<times>G. \\<delta>(s,x)\\<in>G\"\n      using Group_ZF_3_2_L4B by simp\n    ultimately show ?thesis \n      using func1_1_L17 by simp\n  qed\n  ultimately have \"{(\\<delta>(s,x))\\<inverse>. x \\<in> G\\<times>G} \\<in> Fin(G)\"\n    by simp\n  moreover from A2 have\n    \"{(\\<delta>(s,x))\\<inverse>. x \\<in> G\\<times>G} = {\\<delta>(\\<sim>s,x). x \\<in> G\\<times>G}\"\n    using Group_ZF_3_2_L6 by simp\n  ultimately have \"{\\<delta>(\\<sim>s,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n    by simp\n  with A2 groupAssum A1 show ?thesis\n    using Group_ZF_3_2_L7 AlmostHoms_def Group_ZF_2_1_L6\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 581
    },
    "529": {
        "type": "lemma",
        "text": "text\\<open>The function that assigns the neutral element everywhere \n  is an almost homomorphism.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L1",
            "monoid0.group0_1_L3A",
            "monoid0.group0_1_L1",
            "func1_3_L2",
            "HomDiff_def",
            "group0_2_L2",
            "group_inv_of_one",
            "Finite1_L16",
            "func1_3_L1",
            "AlmostHoms_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L9: shows\n  \"ConstantFunction(G,\\<one>) \\<in> AH\" and \"AH\\<noteq>0\"\n",
        "proof": "proof -\n  let ?z = \"ConstantFunction(G,\\<one>)\"\n  have \"G\\<times>G\\<noteq>0\" using group0_2_L1 monoid0.group0_1_L3A\n    by blast\n  moreover have \"\\<forall>x\\<in>G\\<times>G. \\<delta>(?z,x) = \\<one>\"\n  proof\n    fix x assume A1:\"x \\<in> G \\<times> G\"\n    then obtain m n where \"x = \\<langle> m,n\\<rangle>\" \"m\\<in>G\" \"n\\<in>G\"\n      by auto\n    then show \"\\<delta>(?z,x) = \\<one>\"\n      using group0_2_L1 monoid0.group0_1_L1\n\tfunc1_3_L2 HomDiff_def group0_2_L2 \n\tgroup_inv_of_one by simp\n  qed\n  ultimately have \"{\\<delta>(?z,x). x\\<in>G\\<times>G} = {\\<one>}\" by (rule ZF1_1_L5)\n  then show \"?z \\<in> AH\" using group0_2_L2 Finite1_L16\n    func1_3_L1 group0_2_L2 AlmostHoms_def by simp\n  then show \"AH\\<noteq>0\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 582
    },
    "530": {
        "type": "lemma",
        "text": "text\\<open>If the group is abelian, then almost homomorphisms form a \n  subgroup of the lifted group.\\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,P)\"\n  and A2: \"P {is commutative on} G\"\n  and A3: \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "group1_axioms.intro",
            "group0_def",
            "group1_def",
            "group0.Group_ZF_2_1_T2",
            "group1.Group_ZF_3_2_L9",
            "AlmostHoms_def",
            "group1.Group_ZF_3_2_L3",
            "group1.Group_ZF_3_2_L8",
            "group0.group0_3_T3"
        ],
        "statement": "lemma Group_ZF_3_2_L10:\n  assumes A1: \"IsAgroup(G,P)\"\n  and A2: \"P {is commutative on} G\"\n  and A3: \"F = P {lifted to function space over} G\"\n  shows \"IsAsubgroup(AlmostHoms(G,P),F)\"\n",
        "proof": "proof -\n  let ?AH = \"AlmostHoms(G,P)\"\n  from A2 A1 have T1: \"group1(G,P)\"\n    using group1_axioms.intro group0_def group1_def\n    by simp\n  from A1 A3 have \"group0(G\\<rightarrow>G,F)\"\n    using group0_def group0.Group_ZF_2_1_T2 by simp\n  moreover from T1 have \"?AH\\<noteq>0\"\n    using group1.Group_ZF_3_2_L9 by simp\n  moreover have T2:\"?AH \\<subseteq> G\\<rightarrow>G\"\n    using AlmostHoms_def by auto\n  moreover from T1 A3 have \n    \"?AH {is closed under} F\"\n    using group1.Group_ZF_3_2_L3 by simp\n  moreover from T1 A3 have\n    \"\\<forall>s\\<in>?AH. GroupInv(G\\<rightarrow>G,F)`(s) \\<in> ?AH\"\n    using group1.Group_ZF_3_2_L8 by simp\n  ultimately show \"IsAsubgroup(AlmostHoms(G,P),F)\"\n    using group0.group0_3_T3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 583
    },
    "531": {
        "type": "lemma",
        "text": "text\\<open>If the group is abelian, then almost homomorphisms form a group\n  with the first operation, hence we can use theorems proven in group0\n  context aplied to this group.\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "isAbelian",
            "Group_ZF_3_2_L10",
            "IsAsubgroup_def",
            "AlHomOp1_def",
            "group0_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L10A: \n  shows \"IsAgroup(AH,Op1)\" \"group0(AH,Op1)\"\n    ",
        "proof": "using groupAssum isAbelian Group_ZF_3_2_L10 IsAsubgroup_def \n      AlHomOp1_def group0_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 584
    },
    "532": {
        "type": "lemma",
        "text": "text\\<open>The group of almost homomorphisms is abelian\\<close>\n",
        "assumes": "assumes A1: \"IsAgroup(G,f)\"\n  and A2: \"f {is commutative on} G\"\n  ",
        "using": [
            "Group_ZF_3_2_L10",
            "IsAsubgroup_def",
            "AlHomOp1_def",
            "IsAgroup_def",
            "monoid0_def",
            "monoid0.Group_ZF_2_1_L0A",
            "AlmostHoms_def",
            "group0_def",
            "group0.Group_ZF_2_1_L7",
            "func_ZF_4_L1"
        ],
        "statement": "lemma Group_ZF_3_2_L11: assumes A1: \"IsAgroup(G,f)\"\n  and A2: \"f {is commutative on} G\"\n  shows \n  \"IsAgroup(AlmostHoms(G,f),AlHomOp1(G,f))\"\n  \"AlHomOp1(G,f) {is commutative on} AlmostHoms(G,f)\"\n",
        "proof": "proof-\n  let ?AH = \"AlmostHoms(G,f)\"\n  let ?F = \"f {lifted to function space over} G\"\n  from A1 A2 have \"IsAsubgroup(?AH,?F)\"\n    using Group_ZF_3_2_L10 by simp\n  then show \"IsAgroup(?AH,AlHomOp1(G,f))\"\n    using IsAsubgroup_def AlHomOp1_def by simp\n  from A1 have \"?F : (G\\<rightarrow>G)\\<times>(G\\<rightarrow>G)\\<rightarrow>(G\\<rightarrow>G)\"\n    using IsAgroup_def monoid0_def monoid0.Group_ZF_2_1_L0A\n    by simp\n  moreover have \"?AH \\<subseteq> G\\<rightarrow>G\"\n    using AlmostHoms_def by auto\n  moreover from A1 A2 have\n    \"?F {is commutative on} (G\\<rightarrow>G)\"\n    using group0_def group0.Group_ZF_2_1_L7\n    by simp\n  ultimately show \n    \"AlHomOp1(G,f){is commutative on} ?AH\"\n    using func_ZF_4_L1 AlHomOp1_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 585
    },
    "533": {
        "type": "lemma",
        "text": "text\\<open>The first operation on homomorphisms acts in a natural way on its \n  operands.\\<close>\n",
        "assumes": "assumes \"s\\<in>AH\"  \"r\\<in>AH\" and \"n\\<in>G\"\n  ",
        "using": [
            "assms",
            "AlHomOp1_def",
            "restrict",
            "AlmostHoms_def",
            "Group_ZF_2_1_L3"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L12: \n  assumes \"s\\<in>AH\"  \"r\\<in>AH\" and \"n\\<in>G\"\n  shows \"(s\\<bullet>r)`(n) = s`(n)\\<cdot>r`(n)\"\n  ",
        "proof": "using assms AlHomOp1_def restrict AlmostHoms_def Group_ZF_2_1_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 586
    },
    "534": {
        "type": "lemma",
        "text": "text\\<open>What is the group inverse in the group of almost homomorphisms?\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"\n  ",
        "using": [
            "Group_ZF_3_2_L10",
            "AlHomOp1_def",
            "Group_ZF_2_1_L6A",
            "Group_ZF_3_2_L10A",
            "group0.inverse_in_group"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L13: \n  assumes A1: \"s\\<in>AH\"\n  shows \n  \"GroupInv(AH,Op1)`(s) = GroupInv(G,P) O s\"\n  \"GroupInv(AH,Op1)`(s) \\<in> AH\"\n  \"GroupInv(G,P) O s \\<in> AH\"\n",
        "proof": "proof -\n  let ?F = \"P {lifted to function space over} G\"\n  from groupAssum isAbelian have \"IsAsubgroup(AH,?F)\" \n    using Group_ZF_3_2_L10 by simp\n  with A1 show I: \"GroupInv(AH,Op1)`(s) = GroupInv(G,P) O s\"\n    using AlHomOp1_def Group_ZF_2_1_L6A by simp\n  from A1 show \"GroupInv(AH,Op1)`(s) \\<in> AH\"\n    using Group_ZF_3_2_L10A group0.inverse_in_group by simp\n  with I show \"GroupInv(G,P) O s \\<in> AH\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 587
    },
    "535": {
        "type": "lemma",
        "text": "text\\<open>The group inverse in the group of almost homomorphisms acts in a \n  natural way on its operand.\\<close>\n",
        "assumes": "assumes \"s\\<in>AH\" and \"n\\<in>G\"\n  ",
        "using": [
            "isAbelian",
            "assms",
            "Group_ZF_3_2_L13",
            "AlmostHoms_def",
            "comp_fun_apply"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L14:\n  assumes \"s\\<in>AH\" and \"n\\<in>G\"\n  shows \"(GroupInv(AH,Op1)`(s))`(n) = (s`(n))\\<inverse>\"\n  ",
        "proof": "using isAbelian assms Group_ZF_3_2_L13 AlmostHoms_def comp_fun_apply\n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 588
    },
    "536": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states that if $s,r$ are almost homomorphisms, then\n  $s\\cdot r^{-1}$ is also an almost homomorphism.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,f)\"\n  and \"f {is commutative on} G\"\n  and \"AH = AlmostHoms(G,f)\" \"Op1 = AlHomOp1(G,f)\"\n  and \"s \\<in> AH\"  \"r \\<in> AH\"\n  ",
        "using": [
            "assms",
            "group0_def",
            "group1_axioms.intro",
            "group1_def",
            "group1.Group_ZF_3_2_L10A",
            "group0.group0_2_L1",
            "monoid0.group0_1_L1",
            "group0.inverse_in_group"
        ],
        "statement": "lemma Group_ZF_3_2_L15: assumes \"IsAgroup(G,f)\"\n  and \"f {is commutative on} G\"\n  and \"AH = AlmostHoms(G,f)\" \"Op1 = AlHomOp1(G,f)\"\n  and \"s \\<in> AH\"  \"r \\<in> AH\"\n  shows \n  \"Op1`\\<langle> s,r\\<rangle> \\<in> AH\"\n  \"GroupInv(AH,Op1)`(r) \\<in> AH\"\n  \"Op1`\\<langle> s,GroupInv(AH,Op1)`(r)\\<rangle> \\<in> AH\"\n  ",
        "proof": "using assms group0_def group1_axioms.intro group1_def\n      group1.Group_ZF_3_2_L10A group0.group0_2_L1 \n      monoid0.group0_1_L1 group0.inverse_in_group by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 589
    },
    "537": {
        "type": "corollary",
        "text": "text\\<open>A version of \\<open>Group_ZF_3_2_L15\\<close> formulated in notation\n  used in \\<open>group1\\<close> context. States that the product of almost\n  homomorphisms is an almost homomorphism and the the product\n  of an almost homomorphism with a (pointwise) inverse of an almost \n  homomorphism is an almost homomorphism.\\<close>\n",
        "assumes": "assumes \"s \\<in> AH\"  \"r \\<in> AH\"\n  ",
        "using": [
            "assms",
            "isAbelian",
            "group0_def",
            "group1_axioms",
            "group1_def",
            "Group_ZF_3_2_L15",
            "Group_ZF_3_2_L13"
        ],
        "statement": "corollary (in group1) Group_ZF_3_2_L16: assumes \"s \\<in> AH\"  \"r \\<in> AH\"\n  shows \"s\\<bullet>r \\<in> AH\"  \"s\\<bullet>(\\<sim>r) \\<in> AH\"\n  ",
        "proof": "using assms isAbelian group0_def group1_axioms group1_def\n  Group_ZF_3_2_L15 Group_ZF_3_2_L13 by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 590
    },
    "538": {
        "type": "lemma",
        "text": "text\\<open>Finite range functions are almost homomorphisms.\\<close>\n",
        "assumes": "",
        "using": [
            "Finite1_L18",
            "Finite1_L6B",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "inverse_in_group",
            "group_oper_fun",
            "Finite1_L15",
            "HomDiff_def",
            "FinRangeFunctions_def",
            "AlmostHoms_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_3_L1: shows \"FR \\<subseteq> AH\"\n",
        "proof": "proof\n  fix s assume A1:\"s \\<in> FR\"\n  then have T1:\"{s`(n). n \\<in> G} \\<in> Fin(G)\"\n    \"{s`(fst(x)). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    \"{s`(snd(x)). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    using Finite1_L18 Finite1_L6B by auto\n  have \"{s`(fst(x)\\<cdot>snd(x)). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n  proof -\n    have \"\\<forall>x\\<in>G\\<times>G. fst(x)\\<cdot>snd(x) \\<in> G\"\n      using group0_2_L1 monoid0.group0_1_L1 by simp\n    moreover from T1 have \"{s`(n). n \\<in> G} \\<in> Fin(G)\" by simp\n    ultimately show ?thesis by (rule Finite1_L6B)\n  qed\n  moreover have \n    \"{(s`(fst(x))\\<cdot>s`(snd(x)))\\<inverse>. x\\<in>G\\<times>G} \\<in> Fin(G)\"\n  proof -\n    have \"\\<forall>g\\<in>G. g\\<inverse> \\<in> G\" using inverse_in_group \n      by simp\n    moreover from T1 have \n      \"{s`(fst(x))\\<cdot>s`(snd(x)). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n      using group_oper_fun  Finite1_L15 by simp\n    ultimately show ?thesis \n      by (rule Finite1_L6C)\n  qed\n  ultimately have \"{\\<delta>(s,x). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    using HomDiff_def Finite1_L15  group_oper_fun \n    by simp\n  with A1 show \"s \\<in> AH\" \n    using FinRangeFunctions_def AlmostHoms_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 591
    },
    "539": {
        "type": "lemma",
        "text": "text\\<open>Finite range functions valued in an abelian group form a normal \n  subgroup of almost homomorphisms.\\<close>\n",
        "assumes": "assumes A1:\"IsAgroup(G,f)\"\n  and A2:\"f {is commutative on} G\"\n  ",
        "using": [
            "group0_def",
            "group0.group0_2_L1",
            "group1_axioms.intro",
            "group1_def",
            "group0.Group_ZF_2_1_T2",
            "Group_ZF_3_2_L10",
            "monoid0.group0_1_L3A",
            "Group_ZF_3_1_T1",
            "group0_3_L7",
            "group1.Group_ZF_3_3_L1",
            "AlHomOp1_def",
            "Group_ZF_3_2_L11",
            "Group_ZF_2_4_L6"
        ],
        "statement": "lemma Group_ZF_3_3_L2: assumes A1:\"IsAgroup(G,f)\"\n  and A2:\"f {is commutative on} G\"\n  shows\n  \"IsAsubgroup(FinRangeFunctions(G,G),AlHomOp1(G,f))\"\n  \"IsAnormalSubgroup(AlmostHoms(G,f),AlHomOp1(G,f),\n  FinRangeFunctions(G,G))\"\n",
        "proof": "proof -\n  let ?H1 = \"AlmostHoms(G,f)\"\n  let ?H2 = \"FinRangeFunctions(G,G)\"\n  let ?F = \"f {lifted to function space over} G\"\n  from A1 A2 have T1:\"group0(G,f)\"\n    \"monoid0(G,f)\" \"group1(G,f)\"\n    using group0_def group0.group0_2_L1  \n      group1_axioms.intro group1_def\n    by auto\n  with A1 A2 have \"IsAgroup(G\\<rightarrow>G,?F)\"\n    \"IsAsubgroup(?H1,?F)\" \"IsAsubgroup(?H2,?F)\"\n    using group0.Group_ZF_2_1_T2 Group_ZF_3_2_L10\n      monoid0.group0_1_L3A Group_ZF_3_1_T1\n    by auto\n  then have \n    \"IsAsubgroup(?H1\\<inter>?H2,restrict(?F,?H1\\<times>?H1))\"\n    using group0_3_L7 by simp\n  moreover from T1 have \"?H1\\<inter>?H2 = ?H2\"\n    using group1.Group_ZF_3_3_L1 by auto\n  ultimately show \"IsAsubgroup(?H2,AlHomOp1(G,f))\"\n    using AlHomOp1_def by simp\n  with A1 A2 show \"IsAnormalSubgroup(AlmostHoms(G,f),AlHomOp1(G,f),\n    FinRangeFunctions(G,G))\"\n    using Group_ZF_3_2_L11 Group_ZF_2_4_L6\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 592
    },
    "540": {
        "type": "theorem",
        "text": "text\\<open>The group of almost homomorphisms divided by the subgroup of finite\n  range functions is an abelian group.\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "isAbelian",
            "Group_ZF_3_3_L2",
            "Group_ZF_3_2_L10A",
            "Group_ZF_2_4_T1",
            "Group_ZF_3_2_L11",
            "IsAnormalSubgroup_def",
            "Group_ZF_2_4_L6"
        ],
        "statement": "theorem (in group1) Group_ZF_3_3_T1:\n  shows \n  \"IsAgroup(AH//QuotientGroupRel(AH,Op1,FR),QuotientGroupOp(AH,Op1,FR))\"\n  and\n  \"QuotientGroupOp(AH,Op1,FR) {is commutative on}\n  (AH//QuotientGroupRel(AH,Op1,FR))\"\n  ",
        "proof": "using groupAssum isAbelian Group_ZF_3_3_L2 Group_ZF_3_2_L10A \n    Group_ZF_2_4_T1 Group_ZF_3_2_L10A Group_ZF_3_2_L11  \n    Group_ZF_3_3_L2 IsAnormalSubgroup_def Group_ZF_2_4_L6 by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 593
    },
    "541": {
        "type": "lemma",
        "text": "text\\<open>It is useful to have a direct statement that the \n  quotient group relation is an equivalence relation for the group of AH and\n  subgroup FR.\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "isAbelian",
            "QuotientGroupRel_def",
            "Group_ZF_3_3_L2",
            "Group_ZF_3_2_L10A",
            "group0.Group_ZF_2_4_L3"
        ],
        "statement": "lemma (in group1) Group_ZF_3_3_L3: shows\n  \"QuotientGroupRel(AH,Op1,FR) \\<subseteq> AH \\<times> AH\" and\n  \"equiv(AH,QuotientGroupRel(AH,Op1,FR))\"\n  ",
        "proof": "using groupAssum isAbelian QuotientGroupRel_def \n    Group_ZF_3_3_L2 Group_ZF_3_2_L10A group0.Group_ZF_2_4_L3 \n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 594
    },
    "542": {
        "type": "lemma",
        "text": "text\\<open>The \"almost equal\" relation is symmetric.\\<close>\n",
        "assumes": "assumes A1: \"s\\<cong>r\"\n  ",
        "using": [
            "Group_ZF_3_3_L3"
        ],
        "statement": "lemma (in group1) Group_ZF_3_3_L3A: assumes A1: \"s\\<cong>r\"\n  shows \"r\\<cong>s\"\n",
        "proof": "proof -\n  let ?R = \"QuotientGroupRel(AH,Op1,FR)\"\n  from A1 have \"equiv(AH,?R)\" and \"\\<langle>s,r\\<rangle> \\<in> ?R\"\n    using Group_ZF_3_3_L3 by simp_all\n  then have \"\\<langle>r,s\\<rangle> \\<in> ?R\" by (rule equiv_is_sym)\n  then show \"r\\<cong>s\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 595
    },
    "543": {
        "type": "lemma",
        "text": "text\\<open>Although we have bypassed this fact when proving that \n  group of almost homomorphisms divided by the subgroup of finite\n  range functions is a group, it is still useful to know directly \n  that the first group operation on AH is congruent with respect to the\n  quotient group relation.\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "isAbelian",
            "Group_ZF_3_2_L10A",
            "Group_ZF_3_3_L2",
            "Group_ZF_2_4_L5A"
        ],
        "statement": "lemma (in group1) Group_ZF_3_3_L4: \n  shows \"Congruent2(QuotientGroupRel(AH,Op1,FR),Op1)\"\n  ",
        "proof": "using groupAssum isAbelian Group_ZF_3_2_L10A Group_ZF_3_3_L2 \n    Group_ZF_2_4_L5A by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 596
    },
    "544": {
        "type": "lemma",
        "text": "text\\<open>The class of an almost homomorphism $s$ is the neutral element\n  of the quotient group of almost homomorphisms iff $s$ is a finite range\n  function.\\<close>\n",
        "assumes": "assumes \"s \\<in> AH\" and\n  \"r = QuotientGroupRel(AH,Op1,FR)\" and\n  \"TheNeutralElement(AH//r,QuotientGroupOp(AH,Op1,FR)) = e\"\n  ",
        "using": [
            "groupAssum",
            "isAbelian",
            "assms",
            "Group_ZF_3_2_L11",
            "group0_def",
            "Group_ZF_3_3_L2",
            "group0.Group_ZF_2_4_L5E"
        ],
        "statement": "lemma (in group1) Group_ZF_3_3_L5: assumes \"s \\<in> AH\" and\n  \"r = QuotientGroupRel(AH,Op1,FR)\" and\n  \"TheNeutralElement(AH//r,QuotientGroupOp(AH,Op1,FR)) = e\"\n  shows \"r``{s} = e \\<longleftrightarrow> s \\<in> FR\"\n  ",
        "proof": "using groupAssum isAbelian assms Group_ZF_3_2_L11 \n    group0_def Group_ZF_3_3_L2 group0.Group_ZF_2_4_L5E\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 597
    },
    "545": {
        "type": "lemma",
        "text": "text\\<open>The group inverse of a class of an almost homomorphism $f$\n  is the class of the inverse of $f$.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> AH\"  and \n  \"r = QuotientGroupRel(AH,Op1,FR)\" and \n  \"F = ProjFun2(AH,r,Op1)\"\n  ",
        "using": [
            "Group_ZF_3_2_L10A",
            "Group_ZF_3_3_L2",
            "QuotientGroupOp_def",
            "group0.Group_ZF_2_4_L7",
            "Group_ZF_3_2_L13"
        ],
        "statement": "lemma (in group1) Group_ZF_3_3_L6: \n  assumes A1: \"s \\<in> AH\"  and \n  \"r = QuotientGroupRel(AH,Op1,FR)\" and \n  \"F = ProjFun2(AH,r,Op1)\"\n  shows \"r``{\\<sim>s} = GroupInv(AH//r,F)`(r``{s})\"\n",
        "proof": "proof -\n  from groupAssum isAbelian assms have\n    \"r``{GroupInv(AH, Op1)`(s)} = GroupInv(AH//r,F)`(r `` {s})\"\n    using Group_ZF_3_2_L10A Group_ZF_3_3_L2 QuotientGroupOp_def\n      group0.Group_ZF_2_4_L7 by simp\n  with A1 show ?thesis using Group_ZF_3_2_L13\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 598
    },
    "546": {
        "type": "lemma",
        "text": "text\\<open>The next formula restates the definition of the homomorphism \n  difference to express the value an almost homomorphism on a product.\\<close>\n",
        "assumes": "assumes \"s\\<in>AH\" and  \"m\\<in>G\"  \"n\\<in>G\" \n  ",
        "using": [
            "isAbelian",
            "assms",
            "Group_ZF_3_2_L4A",
            "HomDiff_def",
            "group0_4_L5"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L1: \n  assumes \"s\\<in>AH\" and  \"m\\<in>G\"  \"n\\<in>G\" \n  shows \"s`(m\\<cdot>n) = s`(m)\\<cdot>s`(n)\\<cdot>\\<delta>(s,\\<langle> m,n\\<rangle>)\"\n  ",
        "proof": "using isAbelian assms Group_ZF_3_2_L4A HomDiff_def group0_4_L5\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 599
    },
    "547": {
        "type": "lemma",
        "text": "text\\<open>What is the value of a composition of almost homomorhisms?\\<close>\n",
        "assumes": "assumes \"s\\<in>AH\"  \"r\\<in>AH\" and \"m\\<in>G\"\n  ",
        "using": [
            "assms",
            "AlmostHoms_def",
            "func_ZF_5_L3",
            "restrict",
            "AlHomOp2_def",
            "apply_funtype"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L2:\n  assumes \"s\\<in>AH\"  \"r\\<in>AH\" and \"m\\<in>G\"\n  shows \"(s\\<circ>r)`(m) = s`(r`(m))\"  \"s`(r`(m)) \\<in> G\"\n  ",
        "proof": "using assms AlmostHoms_def func_ZF_5_L3 restrict AlHomOp2_def\n    apply_funtype by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 600
    },
    "548": {
        "type": "lemma",
        "text": "text\\<open>What is the homomorphism difference of a composition?\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\" and A2: \"m\\<in>G\"  \"n\\<in>G\"\n  ",
        "using": [
            "Group_ZF_3_4_L2",
            "AlmostHoms_def",
            "apply_funtype",
            "Group_ZF_3_2_L4A",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "HomDiff_def",
            "Group_ZF_3_4_L1",
            "group0_4_L6C"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L3:\n  assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\" and A2: \"m\\<in>G\"  \"n\\<in>G\"\n  shows \"\\<delta>(s\\<circ>r,\\<langle> m,n\\<rangle>) = \n  \\<delta>(s,\\<langle> r`(m),r`(n)\\<rangle>)\\<cdot>s`(\\<delta>(r,\\<langle> m,n\\<rangle>))\\<cdot>\\<delta>(s,\\<langle> r`(m)\\<cdot>r`(n),\\<delta>(r,\\<langle> m,n\\<rangle>)\\<rangle>)\"\n",
        "proof": "proof -\n  from A1 A2 have T1:\n    \"s`(r`(m))\\<cdot> s`(r`(n)) \\<in> G\"\n    \"\\<delta>(s,\\<langle> r`(m),r`(n)\\<rangle>)\\<in> G\" \"s`(\\<delta>(r,\\<langle> m,n\\<rangle>)) \\<in>G\" \n    \"\\<delta>(s,\\<langle> (r`(m)\\<cdot>r`(n)),\\<delta>(r,\\<langle> m,n\\<rangle>)\\<rangle>) \\<in> G\"\n    using Group_ZF_3_4_L2 AlmostHoms_def apply_funtype \n      Group_ZF_3_2_L4A group0_2_L1 monoid0.group0_1_L1\n    by auto\n  from A1 A2 have \"\\<delta>(s\\<circ>r,\\<langle> m,n\\<rangle>) =\n    s`(r`(m)\\<cdot>r`(n)\\<cdot>\\<delta>(r,\\<langle> m,n\\<rangle>))\\<cdot>(s`((r`(m)))\\<cdot>s`(r`(n)))\\<inverse>\"\n    using HomDiff_def group0_2_L1 monoid0.group0_1_L1 Group_ZF_3_4_L2\n      Group_ZF_3_4_L1 by simp\n  moreover from A1 A2 have\n    \"s`(r`(m)\\<cdot>r`(n)\\<cdot>\\<delta>(r,\\<langle> m,n\\<rangle>)) =\n    s`(r`(m)\\<cdot>r`(n))\\<cdot>s`(\\<delta>(r,\\<langle> m,n\\<rangle>))\\<cdot>\\<delta>(s,\\<langle> (r`(m)\\<cdot>r`(n)),\\<delta>(r,\\<langle> m,n\\<rangle>)\\<rangle>)\"\n    \"s`(r`(m)\\<cdot>r`(n)) = s`(r`(m))\\<cdot>s`(r`(n))\\<cdot>\\<delta>(s,\\<langle> r`(m),r`(n)\\<rangle>)\"\n    using Group_ZF_3_2_L4A Group_ZF_3_4_L1 by auto\n  moreover from T1 isAbelian have\n    \"s`(r`(m))\\<cdot>s`(r`(n))\\<cdot>\\<delta>(s,\\<langle> r`(m),r`(n)\\<rangle>)\\<cdot>\n    s`(\\<delta>(r,\\<langle> m,n\\<rangle>))\\<cdot>\\<delta>(s,\\<langle> (r`(m)\\<cdot>r`(n)),\\<delta>(r,\\<langle> m,n\\<rangle>)\\<rangle>)\\<cdot>\n    (s`((r`(m)))\\<cdot>s`(r`(n)))\\<inverse> = \n    \\<delta>(s,\\<langle> r`(m),r`(n)\\<rangle>)\\<cdot>s`(\\<delta>(r,\\<langle> m,n\\<rangle>))\\<cdot>\\<delta>(s,\\<langle> (r`(m)\\<cdot>r`(n)),\\<delta>(r,\\<langle> m,n\\<rangle>)\\<rangle>)\" \n    using group0_4_L6C by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 601
    },
    "549": {
        "type": "lemma",
        "text": "text\\<open>What is the homomorphism difference of a composition (another form)?\n  Here we split the homomorphism difference of a composition \n  into a product of three factors.\n  This will help us in proving that the range of homomorphism difference\n  for the composition is finite, as each factor has finite range.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\" and A2: \"x \\<in> G\\<times>G\"\n  and A3:\n  \"A = \\<delta>(s,\\<langle> r`(fst(x)),r`(snd(x))\\<rangle>)\"\n  \"B = s`(\\<delta>(r,x))\"\n  \"C = \\<delta>(s,\\<langle> (r`(fst(x))\\<cdot>r`(snd(x))),\\<delta>(r,x)\\<rangle>)\"\n  ",
        "using": [],
        "statement": "lemma (in group1) Group_ZF_3_4_L4:\n  assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\" and A2: \"x \\<in> G\\<times>G\"\n  and A3:\n  \"A = \\<delta>(s,\\<langle> r`(fst(x)),r`(snd(x))\\<rangle>)\"\n  \"B = s`(\\<delta>(r,x))\"\n  \"C = \\<delta>(s,\\<langle> (r`(fst(x))\\<cdot>r`(snd(x))),\\<delta>(r,x)\\<rangle>)\"\n  shows \"\\<delta>(s\\<circ>r,x) = A\\<cdot>B\\<cdot>C\"\n",
        "proof": "proof -\n  let ?m = \"fst(x)\"\n  let ?n = \"snd(x)\"\n  note A1\n  moreover from A2 have \"?m\\<in>G\" \"?n\\<in>G\"\n    by auto\n  ultimately have\n    \"\\<delta>(s\\<circ>r,\\<langle> ?m,?n\\<rangle>) = \n    \\<delta>(s,\\<langle> r`(?m),r`(?n)\\<rangle>)\\<cdot>s`(\\<delta>(r,\\<langle> ?m,?n\\<rangle>))\\<cdot>\n    \\<delta>(s,\\<langle> (r`(?m)\\<cdot>r`(?n)),\\<delta>(r,\\<langle> ?m,?n\\<rangle>)\\<rangle>)\"\n    by (rule Group_ZF_3_4_L3)\n  with A1 A2 A3 show ?thesis\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 602
    },
    "550": {
        "type": "lemma",
        "text": "text\\<open>The range of the homomorphism difference of a composition\n  of two almost homomorphisms is finite. This is the essential condition\n  to show that a composition of almost homomorphisms is an almost \n  homomorphism.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"\n  ",
        "using": [
            "Group_ZF_3_2_L4B",
            "AlmostHoms_def",
            "apply_funtype",
            "group_oper_fun",
            "Finite1_L15",
            "Group_ZF_3_4_L4",
            "restrict",
            "AlHomOp2_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L5:\n  assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"\n  shows \"{\\<delta>(Composition(G)`\\<langle> s,r\\<rangle>,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n",
        "proof": "proof -\n  from A1 have \n    \"\\<forall>x\\<in>G\\<times>G. \\<langle> r`(fst(x)),r`(snd(x))\\<rangle> \\<in> G\\<times>G\"\n    using Group_ZF_3_2_L4B by simp\n  moreover from A1 have \n    \"{\\<delta>(s,x). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    using AlmostHoms_def by simp\n  ultimately have \n    \"{\\<delta>(s,\\<langle> r`(fst(x)),r`(snd(x))\\<rangle>). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    by (rule Finite1_L6B)\n  moreover have \"{s`(\\<delta>(r,x)). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n  proof -\n    from A1 have \"\\<forall>m\\<in>G. s`(m) \\<in> G\" \n      using AlmostHoms_def apply_funtype by auto\n    moreover from A1 have \"{\\<delta>(r,x). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n      using AlmostHoms_def by simp\n    ultimately show ?thesis\n      by (rule Finite1_L6C)\n  qed\n  ultimately have\n    \"{\\<delta>(s,\\<langle> r`(fst(x)),r`(snd(x))\\<rangle>)\\<cdot>s`(\\<delta>(r,x)). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    using group_oper_fun Finite1_L15 by simp\n  moreover have \n    \"{\\<delta>(s,\\<langle> (r`(fst(x))\\<cdot>r`(snd(x))),\\<delta>(r,x)\\<rangle>).  x\\<in>G\\<times>G} \\<in> Fin(G)\"\n  proof -\n    from A1 have \n    \"\\<forall>x\\<in>G\\<times>G. \\<langle> (r`(fst(x))\\<cdot>r`(snd(x))),\\<delta>(r,x)\\<rangle> \\<in> G\\<times>G\"\n      using Group_ZF_3_2_L4B by simp\n    moreover from A1 have \n      \"{\\<delta>(s,x). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n      using AlmostHoms_def by simp\n    ultimately show ?thesis by (rule Finite1_L6B)\n  qed\n  ultimately have\n    \"{\\<delta>(s,\\<langle> r`(fst(x)),r`(snd(x))\\<rangle>)\\<cdot>s`(\\<delta>(r,x))\\<cdot>\n    \\<delta>(s,\\<langle> (r`(fst(x))\\<cdot>r`(snd(x))),\\<delta>(r,x)\\<rangle>). x\\<in>G\\<times>G} \\<in> Fin(G)\"\n    using group_oper_fun Finite1_L15 by simp\n  moreover from A1 have \"{\\<delta>(s\\<circ>r,x). x\\<in>G\\<times>G} = \n    {\\<delta>(s,\\<langle> r`(fst(x)),r`(snd(x))\\<rangle>)\\<cdot>s`(\\<delta>(r,x))\\<cdot>\n    \\<delta>(s,\\<langle> (r`(fst(x))\\<cdot>r`(snd(x))),\\<delta>(r,x)\\<rangle>). x\\<in>G\\<times>G}\"\n    using Group_ZF_3_4_L4 by simp\n  ultimately have \"{\\<delta>(s\\<circ>r,x). x\\<in>G\\<times>G} \\<in> Fin(G)\" by simp\n  with A1 show ?thesis using restrict AlHomOp2_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 603
    },
    "551": {
        "type": "theorem",
        "text": "text\\<open>Composition of almost homomorphisms is an almost homomorphism.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"\n  ",
        "using": [
            "AlmostHoms_def",
            "func_ZF_5_L1",
            "apply_funtype",
            "Group_ZF_3_4_L5",
            "AlHomOp2_def",
            "restrict"
        ],
        "statement": "theorem (in group1) Group_ZF_3_4_T1:\n  assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"\n  shows \"Composition(G)`\\<langle> s,r\\<rangle> \\<in> AH\" \"s\\<circ>r \\<in> AH\"\n",
        "proof": "proof -\n  from A1 have \"\\<langle> s,r\\<rangle> \\<in> (G\\<rightarrow>G)\\<times>(G\\<rightarrow>G)\"\n    using AlmostHoms_def by simp\n  then have \"Composition(G)`\\<langle> s,r\\<rangle> : G\\<rightarrow>G\"\n    using func_ZF_5_L1 apply_funtype by blast\n  with A1 show \"Composition(G)`\\<langle> s,r\\<rangle> \\<in> AH\" \n    using Group_ZF_3_4_L5 AlmostHoms_def\n    by simp\n  with A1 show  \"s\\<circ>r \\<in> AH\" using AlHomOp2_def restrict \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 604
    },
    "552": {
        "type": "lemma",
        "text": "text\\<open>The set of almost homomorphisms is closed under composition.\n  The second operation on almost homomorphisms is associative.\\<close>\n",
        "assumes": "",
        "using": [
            "Group_ZF_3_4_T1",
            "IsOpClosed_def",
            "AlmostHoms_def",
            "func_ZF_5_L5",
            "func_ZF_4_L3",
            "AlHomOp2_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L6: shows \n  \"AH {is closed under} Composition(G)\"\n  \"AlHomOp2(G,P) {is associative on} AH\"\n",
        "proof": "proof -\n  show \"AH {is closed under} Composition(G)\"\n    using Group_ZF_3_4_T1 IsOpClosed_def by simp\n  moreover have \"AH \\<subseteq> G\\<rightarrow>G\" using AlmostHoms_def\n    by auto\n  moreover have \n    \"Composition(G) {is associative on} (G\\<rightarrow>G)\"\n    using func_ZF_5_L5 by simp\n  ultimately show \"AlHomOp2(G,P) {is associative on} AH\"\n    using func_ZF_4_L3 AlHomOp2_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 605
    },
    "553": {
        "type": "lemma",
        "text": "text\\<open>Type information related to the situation of two almost\n  homomorphisms.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\" and A2: \"n\\<in>G\"\n  ",
        "using": [
            "AlmostHoms_def",
            "apply_type",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "inverse_in_group"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L7: \n  assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\" and A2: \"n\\<in>G\"\n  shows \n  \"s`(n) \\<in> G\" \"(r`(n))\\<inverse> \\<in> G\" \n  \"s`(n)\\<cdot>(r`(n))\\<inverse> \\<in> G\"   \"s`(r`(n)) \\<in> G\"\n",
        "proof": "proof -\n  from A1 A2 show \n    \"s`(n) \\<in> G\"\n    \"(r`(n))\\<inverse> \\<in> G\"\n    \"s`(r`(n)) \\<in> G\"\n    \"s`(n)\\<cdot>(r`(n))\\<inverse> \\<in> G\"\n    using AlmostHoms_def apply_type  \n      group0_2_L1 monoid0.group0_1_L1 inverse_in_group\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 606
    },
    "554": {
        "type": "lemma",
        "text": "text\\<open>A formula useful in showing that the composition of almost\n  homomorphisms is congruent with respect \n  to the quotient group relation.\\<close>\n",
        "assumes": "assumes A1: \"s1 \\<in> AH\"  \"r1 \\<in> AH\"  \"s2 \\<in> AH\"  \"r2 \\<in> AH\"\n  and A2: \"n\\<in>G\"\n  ",
        "using": [
            "Group_ZF_3_4_L2",
            "Group_ZF_3_4_L7",
            "group0_4_L6A",
            "group_oper_assoc",
            "Group_ZF_3_4_L8",
            "Group_ZF_3_4_L1",
            "group0_4_L7"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L9:\n  assumes A1: \"s1 \\<in> AH\"  \"r1 \\<in> AH\"  \"s2 \\<in> AH\"  \"r2 \\<in> AH\"\n  and A2: \"n\\<in>G\"\n  shows \"(s1\\<circ>r1)`(n)\\<cdot>((s2\\<circ>r2)`(n))\\<inverse> =\n  s1`(r2`(n))\\<cdot> (s2`(r2`(n)))\\<inverse>\\<cdot>s1`(r1`(n)\\<cdot>(r2`(n))\\<inverse>)\\<cdot>\n  \\<delta>(s1,\\<langle> r2`(n),r1`(n)\\<cdot>(r2`(n))\\<inverse>\\<rangle>)\"\n",
        "proof": "proof -\n  from A1 A2 isAbelian have\n    \"(s1\\<circ>r1)`(n)\\<cdot>((s2\\<circ>r2)`(n))\\<inverse> =\n    s1`(r2`(n)\\<cdot>(r1`(n)\\<cdot>(r2`(n))\\<inverse>))\\<cdot>(s2`(r2`(n)))\\<inverse>\"\n    using Group_ZF_3_4_L2 Group_ZF_3_4_L7 group0_4_L6A\n      group_oper_assoc by simp\n  with A1 A2 have \"(s1\\<circ>r1)`(n)\\<cdot>((s2\\<circ>r2)`(n))\\<inverse> = s1`(r2`(n))\\<cdot>\n    s1`(r1`(n)\\<cdot>(r2`(n))\\<inverse>)\\<cdot>\\<delta>(s1,\\<langle> r2`(n),r1`(n)\\<cdot>(r2`(n))\\<inverse>\\<rangle>)\\<cdot>\n    (s2`(r2`(n)))\\<inverse>\"\n    using Group_ZF_3_4_L8 Group_ZF_3_4_L1 by simp\n  with A1 A2 isAbelian show ?thesis using\n    Group_ZF_3_4_L8 group0_4_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 608
    },
    "555": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows a formula that translates an expression\n  in terms of the first group operation on almost homomorphisms and the\n  group inverse in the group of almost homomorphisms to an expression using\n  only the underlying group operations.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> AH\"  \"r \\<in> AH\"\n  and A2: \"n \\<in> G\"\n  ",
        "using": [
            "isAbelian",
            "Group_ZF_3_2_L13",
            "Group_ZF_3_2_L12",
            "Group_ZF_3_2_L14"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L10: assumes A1: \"s \\<in> AH\"  \"r \\<in> AH\"\n  and A2: \"n \\<in> G\"\n  shows \"(s\\<bullet>(GroupInv(AH,Op1)`(r)))`(n) = s`(n)\\<cdot>(r`(n))\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A2 show ?thesis\n    using isAbelian Group_ZF_3_2_L13 Group_ZF_3_2_L12 Group_ZF_3_2_L14\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 609
    },
    "556": {
        "type": "lemma",
        "text": "text\\<open>A neccessary condition for two a. h. to be almost equal.\\<close>\n",
        "assumes": "assumes A1: \"s\\<cong>r\"\n  ",
        "using": [
            "QuotientGroupRel_def",
            "Finite1_L18",
            "Group_ZF_3_4_L10"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L11:\n  assumes A1: \"s\\<cong>r\"\n  shows \"{s`(n)\\<cdot>(r`(n))\\<inverse>. n\\<in>G} \\<in> Fin(G)\"\n",
        "proof": "proof -\n  from A1 have \"s\\<in>AH\" \"r\\<in>AH\"\n    using QuotientGroupRel_def by auto\n  moreover from A1 have \n    \"{(s\\<bullet>(GroupInv(AH,Op1)`(r)))`(n). n\\<in>G} \\<in> Fin(G)\"\n    using QuotientGroupRel_def Finite1_L18 by simp\n  ultimately show ?thesis\n    using Group_ZF_3_4_L10 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 610
    },
    "557": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for two a. h. to be almost equal.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"\n  and A2: \"{s`(n)\\<cdot>(r`(n))\\<inverse>. n\\<in>G} \\<in> Fin(G)\"\n  ",
        "using": [
            "Group_ZF_3_2_L15",
            "AlmostHoms_def",
            "Group_ZF_3_4_L10",
            "Finite1_L19",
            "QuotientGroupRel_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L12: assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"\n  and A2: \"{s`(n)\\<cdot>(r`(n))\\<inverse>. n\\<in>G} \\<in> Fin(G)\"\n  shows \"s\\<cong>r\"\n",
        "proof": "proof -\n  from groupAssum isAbelian A1 A2 show ?thesis\n    using Group_ZF_3_2_L15 AlmostHoms_def \n    Group_ZF_3_4_L10 Finite1_L19 QuotientGroupRel_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 611
    },
    "558": {
        "type": "lemma",
        "text": "text\\<open>Another sufficient consdition for two a.h. to be almost\n  equal. It is actually just an expansion of the definition\n  of the quotient group relation.\\<close>\n",
        "assumes": "assumes \"s\\<in>AH\"  \"r\\<in>AH\"\n  and \"s\\<bullet>(GroupInv(AH,Op1)`(r)) \\<in> FR\"\n  ",
        "using": [
            "assms",
            "QuotientGroupRel_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L12A: assumes \"s\\<in>AH\"  \"r\\<in>AH\"\n  and \"s\\<bullet>(GroupInv(AH,Op1)`(r)) \\<in> FR\"\n  shows \"s\\<cong>r\"  \"r\\<cong>s\"\n",
        "proof": "proof  -\n  from assms show \"s\\<cong>r\" using assms QuotientGroupRel_def \n    by simp\n  then show \"r\\<cong>s\" by (rule Group_ZF_3_3_L3A)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 612
    },
    "559": {
        "type": "lemma",
        "text": "text\\<open>Another necessary condition for two a.h. to be almost\n  equal. It is actually just an expansion of the definition\n  of the quotient group relation.\\<close>\n",
        "assumes": "assumes \"s\\<cong>r\"\n  ",
        "using": [
            "assms",
            "QuotientGroupRel_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L12B: assumes \"s\\<cong>r\"\n  shows \"s\\<bullet>(GroupInv(AH,Op1)`(r)) \\<in> FR\"\n  ",
        "proof": "using assms QuotientGroupRel_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 613
    },
    "560": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states the essential condition for \n  the composition of a. h. to be congruent\n  with respect to the quotient group relation for the subgroup of finite \n  range functions.\\<close> \n",
        "assumes": "assumes A1: \"s1\\<cong>s2\"  \"r1\\<cong>r2\"\n  ",
        "using": [
            "QuotientGroupRel_def",
            "AlmostHoms_def",
            "apply_funtype",
            "Group_ZF_3_4_L11",
            "group_oper_fun",
            "Finite1_L15",
            "Group_ZF_3_4_L7",
            "Group_ZF_3_4_L9",
            "Group_ZF_3_4_T1",
            "Group_ZF_3_4_L12"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L13: \n  assumes A1: \"s1\\<cong>s2\"  \"r1\\<cong>r2\"\n  shows \"(s1\\<circ>r1) \\<cong> (s2\\<circ>r2)\"\n",
        "proof": "proof -\n  have \"{s1`(r2`(n))\\<cdot> (s2`(r2`(n)))\\<inverse>. n\\<in>G} \\<in> Fin(G)\"\n  proof -\n    from A1 have \"\\<forall>n\\<in>G. r2`(n) \\<in> G\"\n      using QuotientGroupRel_def AlmostHoms_def apply_funtype\n      by auto\n    moreover from A1 have \"{s1`(n)\\<cdot>(s2`(n))\\<inverse>. n\\<in>G} \\<in> Fin(G)\"\n      using Group_ZF_3_4_L11 by simp\n    ultimately show ?thesis by (rule Finite1_L6B)\n  qed\n  moreover have \"{s1`(r1`(n)\\<cdot>(r2`(n))\\<inverse>). n \\<in> G} \\<in> Fin(G)\"\n  proof -\n    from A1 have \"\\<forall>n\\<in>G. s1`(n)\\<in>G\"\n      using QuotientGroupRel_def AlmostHoms_def apply_funtype\n      by auto\n    moreover from A1 have \"{r1`(n)\\<cdot>(r2`(n))\\<inverse>. n\\<in>G} \\<in> Fin(G)\"\n      using Group_ZF_3_4_L11 by simp\n    ultimately show ?thesis by (rule Finite1_L6C)\n  qed\n  ultimately have\n    \"{s1`(r2`(n))\\<cdot> (s2`(r2`(n)))\\<inverse>\\<cdot>s1`(r1`(n)\\<cdot>(r2`(n))\\<inverse>). \n    n\\<in>G} \\<in> Fin(G)\"\n    using group_oper_fun Finite1_L15 by simp\n  moreover have \n    \"{\\<delta>(s1,\\<langle> r2`(n),r1`(n)\\<cdot>(r2`(n))\\<inverse>\\<rangle>). n\\<in>G} \\<in> Fin(G)\"\n  proof -\n    from A1 have \"\\<forall>n\\<in>G. \\<langle> r2`(n),r1`(n)\\<cdot>(r2`(n))\\<inverse>\\<rangle> \\<in> G\\<times>G\" \n      using QuotientGroupRel_def Group_ZF_3_4_L7 by auto\n    moreover from A1 have \"{\\<delta>(s1,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n      using QuotientGroupRel_def AlmostHoms_def by simp\n    ultimately show ?thesis by (rule Finite1_L6B)\n  qed\n  ultimately have\n    \"{s1`(r2`(n))\\<cdot> (s2`(r2`(n)))\\<inverse>\\<cdot>s1`(r1`(n)\\<cdot>(r2`(n))\\<inverse>)\\<cdot>\n    \\<delta>(s1,\\<langle> r2`(n),r1`(n)\\<cdot>(r2`(n))\\<inverse>\\<rangle>). n\\<in>G} \\<in> Fin(G)\"\n    using group_oper_fun Finite1_L15 by simp\n  with A1 show ?thesis using\n    QuotientGroupRel_def Group_ZF_3_4_L9 \n    Group_ZF_3_4_T1 Group_ZF_3_4_L12 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 614
    },
    "561": {
        "type": "lemma",
        "text": "text\\<open>Composition of a. h. to is congruent\n  with respect to the quotient group relation for the subgroup of finite \n  range functions. Recall that if an operation say \"$\\circ $\" on $X$ is \n  congruent with respect to an equivalence relation $R$ then we can \n  define the operation \n  on the quotient space $X/R$ by $[s]_R\\circ [r]_R := [s\\circ r]_R$ and this\n  definition will be correct i.e. it will not depend on the choice of \n  representants for the classes $[x]$ and $[y]$. This is why we want it here.\\<close>\n",
        "assumes": "",
        "using": [
            "Group_ZF_3_4_L13",
            "Congruent2_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L13A: shows\n  \"Congruent2(QuotientGroupRel(AH,Op1,FR),Op2)\"\n",
        "proof": "proof -\n  show ?thesis using Group_ZF_3_4_L13 Congruent2_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 615
    },
    "562": {
        "type": "lemma",
        "text": "text\\<open>The homomorphism difference for the identity function is equal to\n  the neutral element of the group (denoted $e$ in the group1 context).\\<close>\n",
        "assumes": "assumes A1: \"x \\<in> G\\<times>G\"\n  ",
        "using": [
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "HomDiff_def",
            "id_conv",
            "group0_2_L6"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L14: assumes A1: \"x \\<in> G\\<times>G\"\n  shows \"\\<delta>(id(G),x) = \\<one>\"\n",
        "proof": "proof -\n  from A1 show ?thesis using\n    group0_2_L1 monoid0.group0_1_L1 HomDiff_def id_conv group0_2_L6\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 616
    },
    "563": {
        "type": "lemma",
        "text": "text\\<open>Almost homomorphisms form a monoid with composition.\n  The identity function on the group is the neutral element there.\\<close>\n",
        "assumes": "",
        "using": [
            "monoid0_def",
            "Group_ZF_2_5_L2",
            "Group_ZF_3_4_L6",
            "AlmostHoms_def",
            "Group_ZF_3_4_L15",
            "monoid0.group0_1_T1",
            "group0_1_L6",
            "AlHomOp2_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L16: \n  shows\n  \"IsAmonoid(AH,Op2)\"\n  \"monoid0(AH,Op2)\"\n  \"id(G) = TheNeutralElement(AH,Op2)\"\n",
        "proof": "proof-\n  let ?i = \"TheNeutralElement(G\\<rightarrow>G,Composition(G))\"\n  have\n    \"IsAmonoid(G\\<rightarrow>G,Composition(G))\"\n    \"monoid0(G\\<rightarrow>G,Composition(G))\"\n    using monoid0_def Group_ZF_2_5_L2 by auto\n  moreover have \"AH {is closed under} Composition(G)\" \n    using Group_ZF_3_4_L6 by simp\n  moreover have \"AH \\<subseteq> G\\<rightarrow>G\"\n    using AlmostHoms_def by auto\n  moreover have \"?i \\<in> AH\"\n    using Group_ZF_2_5_L2 Group_ZF_3_4_L15 by simp\n  moreover have \"id(G) =  ?i\"\n    using Group_ZF_2_5_L2 by simp\n  ultimately show \n    \"IsAmonoid(AH,Op2)\"\n    \"monoid0(AH,Op2)\"\n    \"id(G) = TheNeutralElement(AH,Op2)\"\n    using monoid0.group0_1_T1 group0_1_L6 AlHomOp2_def monoid0_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 618
    },
    "564": {
        "type": "theorem",
        "text": "text\\<open>We can project the monoid of almost homomorphisms with composition\n  to the group of almost homomorphisms divided by the subgroup of finite\n  range functions. The class of the identity function is the neutral element\n  of the quotient (monoid).\\<close>\n",
        "assumes": "assumes A1: \"R = QuotientGroupRel(AH,Op1,FR)\"\n  ",
        "using": [
            "Group_ZF_3_2_L10A",
            "group0_def",
            "Group_ZF_3_3_L2",
            "group0.Group_ZF_2_4_L3",
            "Group_ZF_3_4_L13A",
            "Group_ZF_3_4_L16",
            "monoid0.Group_ZF_2_2_T1",
            "Group_ZF_2_2_L1"
        ],
        "statement": "theorem (in group1) Group_ZF_3_4_T2:\n  assumes A1: \"R = QuotientGroupRel(AH,Op1,FR)\"\n  shows \n  \"IsAmonoid(AH//R,ProjFun2(AH,R,Op2))\"\n  \"R``{id(G)} = TheNeutralElement(AH//R,ProjFun2(AH,R,Op2))\"\n",
        "proof": "proof - \n  have \"group0(AH,Op1)\" using Group_ZF_3_2_L10A group0_def\n    by simp\n  with A1 groupAssum isAbelian show \n    \"IsAmonoid(AH//R,ProjFun2(AH,R,Op2))\"\n    \"R``{id(G)} = TheNeutralElement(AH//R,ProjFun2(AH,R,Op2))\"\n    using Group_ZF_3_3_L2 group0.Group_ZF_2_4_L3 Group_ZF_3_4_L13A \n      Group_ZF_3_4_L16 monoid0.Group_ZF_2_2_T1 Group_ZF_2_2_L1\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 619
    },
    "565": {
        "type": "lemma",
        "text": "text\\<open>If $s$ is an almost homomorphism and $c$ is some constant from the group, \n  then $s\\cdot c$ is an almost homomorphism.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> AH\" and A2: \"c\\<in>G\" and\n  A3: \"r = {\\<langle>x,s`(x)\\<cdot>c\\<rangle>. x\\<in>G}\"\n  ",
        "using": [
            "AlmostHoms_def",
            "apply_funtype",
            "group_op_closed",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val",
            "HomDiff_def",
            "group0_4_L7",
            "inverse_in_group",
            "group_oper_fun",
            "Finite1_L16AA",
            "group0_4_L6AB",
            "group0_2_L1",
            "monoid0.group0_1_L3A",
            "Group_ZF_3_4_L12"
        ],
        "statement": "lemma (in group1) Group_ZF_3_5_L1: \n  assumes A1: \"s \\<in> AH\" and A2: \"c\\<in>G\" and\n  A3: \"r = {\\<langle>x,s`(x)\\<cdot>c\\<rangle>. x\\<in>G}\"\n  shows\n  \"\\<forall>x\\<in>G. r`(x) = s`(x)\\<cdot>c\"\n  \"r \\<in> AH\"\n  \"s \\<cong> r\"\n",
        "proof": "proof -\n  from A1 A2 A3 have I: \"r:G\\<rightarrow>G\"\n    using AlmostHoms_def apply_funtype group_op_closed \n    ZF_fun_from_total by auto\n  with A3 show II: \"\\<forall>x\\<in>G. r`(x) = s`(x)\\<cdot>c\"\n    using ZF_fun_from_tot_val by simp\n  with isAbelian A1 A2 have III:\n    \"\\<forall>p \\<in> G\\<times>G. \\<delta>(r,p) = \\<delta>(s,p)\\<cdot>c\\<inverse>\"\n    using group_op_closed AlmostHoms_def apply_funtype\n    HomDiff_def group0_4_L7 by auto\n  have \"{\\<delta>(r,p). p \\<in> G\\<times>G} \\<in> Fin(G)\"\n  proof -\n    from A1 A2 have\n      \"{\\<delta>(s,p). p \\<in> G\\<times>G} \\<in> Fin(G)\"   \"c\\<inverse>\\<in>G\"\n      using AlmostHoms_def inverse_in_group by auto\n    then have \"{\\<delta>(s,p)\\<cdot>c\\<inverse>. p \\<in> G\\<times>G} \\<in> Fin(G)\"\n      using group_oper_fun Finite1_L16AA\n      by simp\n    moreover from III have\n      \"{\\<delta>(r,p). p \\<in> G\\<times>G} = {\\<delta>(s,p)\\<cdot>c\\<inverse>. p \\<in> G\\<times>G}\"\n      by (rule ZF1_1_L4B)\n    ultimately show ?thesis by simp\n  qed\n  with I show IV: \"r \\<in> AH\" using AlmostHoms_def\n    by simp\n  from isAbelian A1 A2 I II have \n    \"\\<forall>n \\<in> G. s`(n)\\<cdot>(r`(n))\\<inverse> = c\\<inverse>\"\n    using AlmostHoms_def apply_funtype group0_4_L6AB\n    by auto\n  then have \"{s`(n)\\<cdot>(r`(n))\\<inverse>. n\\<in>G} = {c\\<inverse>. n\\<in>G}\"\n    by (rule ZF1_1_L4B)\n  with A1 A2 IV show \"s \\<cong> r\"\n    using group0_2_L1 monoid0.group0_1_L3A \n      inverse_in_group Group_ZF_3_4_L12 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 620
    },
    "566": {
        "type": "theorem",
        "text": "text\\<open>The conjugate of a subgroup is a subgroup.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \"g\\<in>G\"\n  ",
        "using": [
            "assms(1)",
            "group0_3_L2",
            "inverse_in_group",
            "group0_3_T3A",
            "group_op_closed",
            "group_inv_of_two",
            "assms(2)",
            "group_inv_of_inv",
            "group_oper_assoc",
            "sub",
            "group0_2_L2",
            "group0_2_L6",
            "group0_3_L6",
            "group0_3_L5",
            "group0_3_T3"
        ],
        "statement": "theorem (in group0) conj_group_is_group:\n  assumes \"IsAsubgroup(H,P)\" \"g\\<in>G\"\n  shows \"IsAsubgroup({g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H},P)\"\n",
        "proof": "proof-\n  have sub:\"H\\<subseteq>G\" using assms(1) group0_3_L2 by auto\n  from assms(2) have \"g\\<inverse>\\<in>G\" using inverse_in_group by auto\n  {\n    fix r assume \"r\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\"\n    then  obtain h where h:\"h\\<in>H\" \"r=g\\<cdot>(h\\<cdot>(g\\<inverse>))\" by auto\n    from h(1) have \"h\\<inverse>\\<in>H\" using group0_3_T3A assms(1) by auto\n    from h(1) sub have \"h\\<in>G\" by auto\n    then have \"h\\<inverse>\\<in>G\" using inverse_in_group by auto\n    with \\<open>g\\<inverse>\\<in>G\\<close> have \"((h\\<inverse>)\\<cdot>(g)\\<inverse>)\\<in>G\" using group_op_closed by auto\n    from h(2) have \"r\\<inverse>=(g\\<cdot>(h\\<cdot>(g\\<inverse>)))\\<inverse>\" by auto moreover\n    from \\<open>h\\<in>G\\<close> \\<open>g\\<inverse>\\<in>G\\<close> have s:\"h\\<cdot>(g\\<inverse>)\\<in>G\" using group_op_closed by blast\n    ultimately have \"r\\<inverse>=(h\\<cdot>(g\\<inverse>))\\<inverse>\\<cdot>(g)\\<inverse>\" using group_inv_of_two assms(2) by auto\n    moreover\n    from \\<open>h\\<in>G\\<close> \\<open>g\\<inverse>\\<in>G\\<close> have \"(h\\<cdot>(g\\<inverse>))\\<inverse>=(g\\<inverse>)\\<inverse>\\<cdot>h\\<inverse>\" using group_inv_of_two by auto\n    moreover have \"(g\\<inverse>)\\<inverse>=g\" using group_inv_of_inv assms(2) by auto\n    ultimately have \"r\\<inverse>=(g\\<cdot>(h\\<inverse>))\\<cdot>(g)\\<inverse>\" by auto\n    with \\<open>h\\<inverse>\\<in>G\\<close>\\<open>g\\<inverse>\\<in>G\\<close> have \"r\\<inverse>=g\\<cdot>((h\\<inverse>)\\<cdot>(g)\\<inverse>)\" using group_oper_assoc assms(2) by auto\n    moreover from s assms(2) h(2) have \"r\\<in>G\" using group_op_closed by auto\n    moreover note \\<open>h\\<inverse>\\<in>H\\<close> ultimately have \"r\\<inverse>\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" \"r\\<in>G\" by auto\n  }\n  then have \"\\<forall>r\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}. r\\<inverse>\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" and \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<subseteq>G\" by auto moreover\n  {\n    fix s t assume s:\"s\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" and t:\"t\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\"\n    then obtain hs ht where hs:\"hs\\<in>H\" \"s=g\\<cdot>(hs\\<cdot>(g\\<inverse>))\" and ht:\"ht\\<in>H\" \"t=g\\<cdot>(ht\\<cdot>(g\\<inverse>))\" by auto\n    from hs(1) have \"hs\\<in>G\" using sub by auto\n    then have \"g\\<cdot>hs\\<in>G\" using group_op_closed assms(2) by auto\n    then have \"(g\\<cdot>hs)\\<inverse>\\<in>G\" using inverse_in_group by auto\n    from ht(1) have \"ht\\<in>G\" using sub by auto\n    with \\<open>g\\<inverse>:G\\<close> have \"ht\\<cdot>(g\\<inverse>)\\<in>G\" using group_op_closed by auto\n    from hs(2) ht(2) have \"s\\<cdot>t=(g\\<cdot>(hs\\<cdot>(g\\<inverse>)))\\<cdot>(g\\<cdot>(ht\\<cdot>(g\\<inverse>)))\" by auto\n    moreover from \\<open>hs\\<in>G\\<close> have \"hs\\<cdot>ht = hs\\<cdot>\\<one>\\<cdot>ht\" using group0_2_L2 by auto\n    then have \"hs\\<cdot>ht = hs\\<cdot>(g\\<inverse>\\<cdot>g)\\<cdot>ht\" using group0_2_L6 assms(2) by auto\n    then have \"g\\<cdot>(hs\\<cdot>ht) = g\\<cdot>(hs\\<cdot>(g\\<inverse>\\<cdot>g)\\<cdot>ht)\" by auto\n    with \\<open>hs\\<in>G\\<close> have \"g\\<cdot>(hs\\<cdot>ht) = g\\<cdot>((hs\\<cdot>g\\<inverse>\\<cdot>g)\\<cdot>ht)\" using group_oper_assoc\n      assms(2) inverse_in_group by auto\n    with \\<open>hs\\<in>G\\<close> \\<open>ht\\<in>G\\<close> have \"g\\<cdot>(hs\\<cdot>ht) = g\\<cdot>(hs\\<cdot>g\\<inverse>\\<cdot>(g\\<cdot>ht))\" using group_oper_assoc\n      assms(2) inverse_in_group group_op_closed by auto\n    with \\<open>hs\\<in>G\\<close> \\<open>ht\\<in>G\\<close> have \"g\\<cdot>(hs\\<cdot>ht) = g\\<cdot>(hs\\<cdot>g\\<inverse>)\\<cdot>(g\\<cdot>ht)\" using group_oper_assoc\n      assms(2) inverse_in_group group_op_closed by auto\n    then have \"g\\<cdot>(hs\\<cdot>ht)\\<cdot>g\\<inverse> = g\\<cdot>(hs\\<cdot>g\\<inverse>)\\<cdot>(g\\<cdot>ht)\\<cdot>g\\<inverse>\" by auto\n    with \\<open>hs\\<in>G\\<close> \\<open>ht\\<in>G\\<close> have \"g\\<cdot>((hs\\<cdot>ht)\\<cdot>g\\<inverse>) = g\\<cdot>(hs\\<cdot>g\\<inverse>)\\<cdot>(g\\<cdot>ht)\\<cdot>g\\<inverse>\" using group_oper_assoc\n      inverse_in_group assms(2) group_op_closed by auto\n    with \\<open>hs\\<in>G\\<close> \\<open>ht\\<in>G\\<close> have \"g\\<cdot>((hs\\<cdot>ht)\\<cdot>g\\<inverse>) = (g\\<cdot>(hs\\<cdot>g\\<inverse>))\\<cdot>(g\\<cdot>(ht\\<cdot>g\\<inverse>))\" using group_oper_assoc\n      inverse_in_group assms(2) group_op_closed by auto\n    ultimately have \"s\\<cdot>t=g\\<cdot>((hs\\<cdot>ht)\\<cdot>(g\\<inverse>))\" by auto moreover\n    from hs(1) ht(1) have \"hs\\<cdot>ht\\<in>H\" using assms(1) group0_3_L6 by auto\n    ultimately have \"s\\<cdot>t\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" by auto\n  }\n  then have \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H} {is closed under}P\" unfolding IsOpClosed_def by auto moreover\n  from assms(1) have \"\\<one>\\<in>H\" using group0_3_L5 by auto\n  then have \"g\\<cdot>(\\<one>\\<cdot>g\\<inverse>)\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" by auto\n  then have \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<noteq>0\" by auto ultimately\n  show ?thesis using group0_3_T3 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 621
    },
    "567": {
        "type": "theorem",
        "text": "text\\<open>Every set is equipollent with its conjugates.\\<close>\n",
        "assumes": "assumes \"H\\<subseteq>G\" \"g\\<in>G\"\n  ",
        "using": [
            "apply_equality",
            "assms(1)",
            "group_op_closed",
            "inverse_in_group",
            "assms(2)",
            "group0_2_L19(2)",
            "group0_2_L19(1)",
            "fun"
        ],
        "statement": "theorem (in group0) conj_set_is_eqpoll:\n  assumes \"H\\<subseteq>G\" \"g\\<in>G\"\n  shows \"H\\<approx>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\"\n",
        "proof": "proof-\n  have fun:\"{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}:H\\<rightarrow>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" unfolding Pi_def function_def domain_def by auto\n  {\n    fix h1 h2 assume \"h1\\<in>H\"\"h2\\<in>H\"\"{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}`h1={\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}`h2\"\n    with fun have \"g\\<cdot>(h1\\<cdot>g\\<inverse>)=g\\<cdot>(h2\\<cdot>g\\<inverse>)\"\"h1\\<cdot>g\\<inverse>\\<in>G\"\"h2\\<cdot>g\\<inverse>\\<in>G\"\"h1\\<in>G\"\"h2\\<in>G\" using apply_equality assms(1)\n      group_op_closed inverse_in_group assms(2) by auto\n    then have \"h1\\<cdot>g\\<inverse>=h2\\<cdot>g\\<inverse>\" using group0_2_L19(2) assms(2) by auto\n    with \\<open>h1\\<in>G\\<close> \\<open>h2\\<in>G\\<close> have \"h1=h2\" using group0_2_L19(1) inverse_in_group assms(2) by auto\n  }\n  then have \"\\<forall>h1\\<in>H. \\<forall>h2\\<in>H. {\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}`h1={\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}`h2 \\<longrightarrow> h1=h2\" by auto\n  with fun have \"{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}\\<in>inj(H,{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H})\" unfolding inj_def by auto moreover\n  {\n    fix ghg assume \"ghg\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\"\n    then obtain h where \"h\\<in>H\" \"ghg=g\\<cdot>(h\\<cdot>g\\<inverse>)\" by auto\n    then have \"\\<langle>h,ghg\\<rangle>\\<in>{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}\" by auto\n    then have \"{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}`h=ghg\" using apply_equality fun by auto\n    with \\<open>h\\<in>H\\<close> have \"\\<exists>h\\<in>H. {\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}`h=ghg\" by auto\n  }\n  with fun have \"{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}\\<in>surj(H,{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H})\" unfolding surj_def by auto\n  ultimately have \"{\\<langle>h,g\\<cdot>(h\\<cdot>g\\<inverse>)\\<rangle>. h\\<in>H}\\<in>bij(H,{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H})\" unfolding bij_def by auto\n  then show ?thesis unfolding eqpoll_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 622
    },
    "568": {
        "type": "theorem",
        "text": "text\\<open>Every normal subgroup contains its conjugate subgroups.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,P,H)\" \"g\\<in>G\"\n  ",
        "using": [
            "group0_3_L2",
            "assms(1)",
            "IsAnormalSubgroup_def",
            "inverse_in_group",
            "group_oper_assoc",
            "assms(2)",
            "assms"
        ],
        "statement": "theorem (in group0) norm_group_cont_conj:\n  assumes \"IsAnormalSubgroup(G,P,H)\" \"g\\<in>G\"\n  shows \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<subseteq>H\"\n",
        "proof": "proof-\n  {\n    fix r assume \"r\\<in>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\"\n    then obtain h where h:\"r=g\\<cdot>(h\\<cdot>g\\<inverse>)\" \"h\\<in>H\" by auto moreover\n    from h(2) have \"h\\<in>G\" using group0_3_L2 assms(1) unfolding IsAnormalSubgroup_def by auto moreover\n    from assms(2) have \"g\\<inverse>\\<in>G\" using inverse_in_group by auto\n    ultimately have \"r=g\\<cdot>h\\<cdot>g\\<inverse>\" \"h\\<in>H\" using group_oper_assoc assms(2) by auto\n    then have \"r\\<in>H\" using assms unfolding IsAnormalSubgroup_def by auto\n  }\n  then show \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<subseteq>H\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 623
    },
    "569": {
        "type": "theorem",
        "text": "text\\<open>If a subgroup contains all its conjugate subgroups, then it is normal.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \"\\<forall>g\\<in>G. {g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<subseteq>H\"\n  ",
        "using": [
            "group0_3_L2",
            "assms(1)",
            "inverse_in_group",
            "group_oper_assoc",
            "IsAnormalSubgroup_def"
        ],
        "statement": "theorem (in group0) cont_conj_is_normal:\n  assumes \"IsAsubgroup(H,P)\" \"\\<forall>g\\<in>G. {g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<subseteq>H\"\n  shows \"IsAnormalSubgroup(G,P,H)\"\n",
        "proof": "proof-\n  {\n    fix h g assume \"h\\<in>H\" \"g\\<in>G\"\n    with assms(2) have \"g\\<cdot>(h\\<cdot>g\\<inverse>)\\<in>H\" by auto\n    moreover from \\<open>g\\<in>G\\<close>\\<open>h\\<in>H\\<close> have \"h\\<in>G\" \"g\\<inverse>\\<in>G\" \"g\\<in>G\" using group0_3_L2 assms(1) inverse_in_group by auto\n    ultimately have \"g\\<cdot>h\\<cdot>g\\<inverse>\\<in>H\" using group_oper_assoc by auto\n  }\n  then show ?thesis using assms(1) unfolding IsAnormalSubgroup_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 624
    },
    "570": {
        "type": "corollary",
        "text": "text\\<open>If a group has only one subgroup of a given order, then this subgroup is normal.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \"\\<forall>M. IsAsubgroup(M,P)\\<and> H\\<approx>M \\<longrightarrow> M=H\"\n  ",
        "using": [
            "conj_group_is_group",
            "conj_set_is_eqpoll",
            "group0_3_L2",
            "assms(2)",
            "cont_conj_is_normal",
            "assms(1)"
        ],
        "statement": "corollary (in group0) only_one_equipoll_sub:\n  assumes \"IsAsubgroup(H,P)\" \"\\<forall>M. IsAsubgroup(M,P)\\<and> H\\<approx>M \\<longrightarrow> M=H\"\n  shows \"IsAnormalSubgroup(G,P,H)\"\n",
        "proof": "proof-\n  {\n    fix g assume g:\"g\\<in>G\"\n    with assms(1) have \"IsAsubgroup({g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H},P)\" using conj_group_is_group by auto\n    moreover\n    from assms(1) g have \"H\\<approx>{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\" using conj_set_is_eqpoll group0_3_L2 by auto\n    ultimately have \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}=H\" using assms(2) by auto\n    then have \"{g\\<cdot>(h\\<cdot>g\\<inverse>). h\\<in>H}\\<subseteq>H\" by auto\n  }\n  then show ?thesis using cont_conj_is_normal assms(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 625
    },
    "571": {
        "type": "corollary",
        "text": "text\\<open>The trivial subgroup is then a normal subgroup.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L2",
            "group_inv_of_one",
            "group0_3_T3",
            "eqpoll_sym",
            "group0_3_L5",
            "inj",
            "inj_def",
            "only_one_equipoll_sub"
        ],
        "statement": "corollary (in group0) trivial_normal_subgroup:\n  shows \"IsAnormalSubgroup(G,P,{\\<one>})\"\n",
        "proof": "proof-\n  have \"{\\<one>}\\<subseteq>G\" using group0_2_L2 by auto\n  moreover have \"{\\<one>}\\<noteq>0\" by auto moreover\n  {\n    fix a b assume \"a\\<in>{\\<one>}\"\"b\\<in>{\\<one>}\"\n    then have \"a=\\<one>\"\"b=\\<one>\" by auto\n    then have \"P`\\<langle>a,b\\<rangle>=\\<one>\\<cdot>\\<one>\" by auto\n    then have \"P`\\<langle>a,b\\<rangle>=\\<one>\" using group0_2_L2 by auto\n    then have \"P`\\<langle>a,b\\<rangle>\\<in>{\\<one>}\" by auto\n  }\n  then have \"{\\<one>}{is closed under}P\" unfolding IsOpClosed_def by auto\n  moreover\n  {\n    fix a assume \"a\\<in>{\\<one>}\"\n    then have \"a=\\<one>\" by auto\n    then have \"a\\<inverse>=\\<one>\\<inverse>\" by auto\n    then have \"a\\<inverse>=\\<one>\" using group_inv_of_one by auto\n    then have \"a\\<inverse>\\<in>{\\<one>}\" by auto\n  }\n  then have \"\\<forall>a\\<in>{\\<one>}. a\\<inverse>\\<in>{\\<one>}\" by auto ultimately\n  have \"IsAsubgroup({\\<one>},P)\" using group0_3_T3 by auto moreover\n  {\n    fix M assume M:\"IsAsubgroup(M,P)\" \"{\\<one>}\\<approx>M\"\n    then have one:\"\\<one>\\<in>M\" \"M\\<approx>{\\<one>}\" using eqpoll_sym group0_3_L5 by auto\n    then obtain f where \"f\\<in>bij(M,{\\<one>})\" unfolding eqpoll_def by auto\n    then have inj:\"f\\<in>inj(M,{\\<one>})\" unfolding bij_def by auto\n    then have fun:\"f:M\\<rightarrow>{\\<one>}\" unfolding inj_def by auto\n    {\n      fix b assume b:\"b\\<in>M\" \"b\\<noteq>\\<one>\"\n      with \\<open>\\<one>\\<in>M\\<close> have \"f`b\\<noteq>f`\\<one>\" using inj unfolding inj_def by auto\n      moreover from fun b(1) have \"f`b\\<in>{\\<one>}\" by (rule apply_type)\n      moreover from fun one(1) have \"f`\\<one>\\<in>{\\<one>}\" by (rule apply_type)\n      ultimately have \"False\" by auto\n    }\n    with \\<open>\\<one>\\<in>M\\<close> have \"M={\\<one>}\" by auto\n  }\n  ultimately show ?thesis using only_one_equipoll_sub by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 626
    },
    "572": {
        "type": "lemma",
        "text": "text\\<open>The whole group is normal as a subgroup\\<close>\n",
        "assumes": "",
        "using": [
            "inverse_in_group",
            "group0_2_L2",
            "group_op_closed",
            "IsOpClosed_def",
            "group0_3_T3"
        ],
        "statement": "lemma (in group0) whole_normal_subgroup:\n  shows \"IsAnormalSubgroup(G,P,G)\"\n",
        "proof": "proof-\n  have \"G\\<subseteq>G\" by auto moreover\n  have \"\\<forall>x\\<in>G. x\\<inverse>\\<in>G\" using inverse_in_group by auto moreover\n  have \"G\\<noteq>0\" using group0_2_L2 by auto moreover\n  have \"G{is closed under}P\" using group_op_closed\n    unfolding IsOpClosed_def by auto ultimately\n  have \"IsAsubgroup(G,P)\" using group0_3_T3 by auto\n  moreover\n  {\n    fix n g assume ng:\"n\\<in>G\" \"g\\<in>G\"\n    then have \"P ` \\<langle>P ` \\<langle>g, n\\<rangle>, GroupInv(G, P) ` g\\<rangle> \\<in> G\"\n      using group_op_closed inverse_in_group by auto\n  }\n  ultimately show ?thesis unfolding IsAnormalSubgroup_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 627
    },
    "573": {
        "type": "definition",
        "text": "text\\<open>Since the whole group and the trivial subgroup are always normal,\nit is natural to define simplicity of groups in the following way:\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsSimple (\"[_,_]{is a simple group}\" 89)\n  where \"[G,f]{is a simple group} \\<equiv> IsAgroup(G,f) \\<and> (\\<forall>M. IsAnormalSubgroup(G,f,M) \\<longrightarrow> M=G\\<or>M={TheNeutralElement(G,f)})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 628
    },
    "574": {
        "type": "corollary",
        "text": "text\\<open>From the definition follows that if a group has no subgroups,\nthen it is simple.\\<close>\n",
        "assumes": "assumes \"\\<forall>H. IsAsubgroup(H,P)\\<longrightarrow> H=G\\<or>H={\\<one>}\"\n  ",
        "using": [
            "groupAssum"
        ],
        "statement": "corollary (in group0) noSubgroup_imp_simple:\n  assumes \"\\<forall>H. IsAsubgroup(H,P)\\<longrightarrow> H=G\\<or>H={\\<one>}\"\n  shows \"[G,P]{is a simple group}\"\n",
        "proof": "proof-\n  have \"IsAgroup(G,P)\" using groupAssum by auto moreover\n  {\n    fix M assume \"IsAnormalSubgroup(G,P,M)\"\n    then have \"IsAsubgroup(M,P)\" unfolding IsAnormalSubgroup_def by auto\n    with assms have \"M=G\\<or>M={\\<one>}\" by auto\n  }\n  ultimately show ?thesis unfolding IsSimple_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 629
    },
    "575": {
        "type": "corollary",
        "text": "text\\<open>Since every subgroup is normal in abelian\ngroups, it follows that commutative simple groups\ndo not have subgroups.\\<close>\n",
        "assumes": "assumes \"[G,P]{is a simple group}\"\n  ",
        "using": [
            "Group_ZF_2_4_L6(1)",
            "groupAssum",
            "isAbelian"
        ],
        "statement": "corollary (in abelian_group) abelian_simple_noSubgroups:\n  assumes \"[G,P]{is a simple group}\"\n  shows \"\\<forall>H. IsAsubgroup(H,P)\\<longrightarrow> H=G\\<or>H={\\<one>}\"\n",
        "proof": "proof-\n  {\n    fix H assume A:\"IsAsubgroup(H,P)\"\"H \\<noteq> {\\<one>}\"\n    then have \"IsAnormalSubgroup(G,P,H)\" using Group_ZF_2_4_L6(1) groupAssum isAbelian\n      by auto\n    with assms(1) A have \"H=G\" unfolding IsSimple_def by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 630
    },
    "576": {
        "type": "lemma",
        "text": "text\\<open>The subgroup of a finite group is finite.\\<close>\n",
        "assumes": "assumes \"Finite(G)\" \"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "group0_3_L2",
            "subset_Finite",
            "assms"
        ],
        "statement": "lemma (in group0) finite_subgroup:\n  assumes \"Finite(G)\" \"IsAsubgroup(H,P)\"\n  shows \"Finite(H)\"\n  ",
        "proof": "using group0_3_L2 subset_Finite assms by force\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 631
    },
    "577": {
        "type": "lemma",
        "text": "text\\<open>The space of cosets is also finite. In particular, quotient groups.\\<close>\n",
        "assumes": "assumes \"Finite(G)\" \"IsAsubgroup(H,P)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\"\n  ",
        "using": [
            "Group_ZF_2_4_L3",
            "assms(2)",
            "r_def",
            "EquivClass_1_L5",
            "EquivClass_1_L2",
            "equiv",
            "EquivClass_1_L1",
            "apply_equality",
            "fun",
            "eqpoll_imp_lepoll",
            "surj_fun_inv_2",
            "surj",
            "lepoll_trans",
            "lepoll_nat_imp_Finite"
        ],
        "statement": "lemma (in group0) finite_cosets:\n  assumes \"Finite(G)\" \"IsAsubgroup(H,P)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\"\n  shows \"Finite(G//r)\"\n",
        "proof": "proof- \n  have fun:\"{\\<langle>g,r``{g}\\<rangle>. g\\<in>G}:G\\<rightarrow>(G//r)\" unfolding Pi_def function_def domain_def by auto\n  {\n    fix C assume C:\"C\\<in>G//r\"\n    have equiv:\"equiv(G,r)\" using Group_ZF_2_4_L3 assms(2) unfolding r_def by auto\n    then have \"refl(G,r)\" unfolding equiv_def by auto\n    with C have \"C\\<noteq>0\" using EquivClass_1_L5 by auto\n    then obtain c where c:\"c\\<in>C\" by auto\n    with C have \"r``{c}=C\" using EquivClass_1_L2 equiv by auto\n    with c C have \"\\<langle>c,C\\<rangle>\\<in>{\\<langle>g,r``{g}\\<rangle>. g\\<in>G}\" using EquivClass_1_L1 equiv by auto\n    then have \"{\\<langle>g,r``{g}\\<rangle>. g\\<in>G}`c=C\" \"c\\<in>G\" using apply_equality fun by auto\n    then have \"\\<exists>c\\<in>G. {\\<langle>g,r``{g}\\<rangle>. g\\<in>G}`c=C\" by auto\n  }\n  with fun have surj:\"{\\<langle>g,r``{g}\\<rangle>. g\\<in>G}\\<in>surj(G,G//r)\" unfolding surj_def by auto\n  from assms(1) obtain n where \"n\\<in>nat\" \"G\\<approx>n\" unfolding Finite_def by auto\n  then have G:\"G\\<lesssim>n\" \"Ord(n)\" using eqpoll_imp_lepoll by auto\n  then have \"G//r\\<lesssim>G\" using surj_fun_inv_2 surj by auto\n  with G(1) have \"G//r\\<lesssim>n\" using lepoll_trans by blast\n  with \\<open>n\\<in>nat\\<close> show \"Finite(G//r)\" using lepoll_nat_imp_Finite by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 632
    },
    "578": {
        "type": "lemma",
        "text": "text\\<open>All the cosets are equipollent.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \"g1\\<in>G\"\"g2\\<in>G\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\"\n  ",
        "using": [
            "Group_ZF_2_4_L3",
            "assms(1)",
            "r_def",
            "inverse_in_group",
            "group_op_closed",
            "trans_bij(1)",
            "assms(3)",
            "quotient_def",
            "EquivClass_1_L1",
            "equiv",
            "assms(2)",
            "restrict_bij",
            "bij_def",
            "func_imagedef",
            "group0_5_L1(1)",
            "image_iff",
            "sub",
            "QuotientGroupRel_def",
            "group0_5_L2(1)",
            "group_inv_of_two",
            "group_inv_of_inv",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2",
            "assms(4)",
            "sub2",
            "group0_3_L2",
            "GGG",
            "HH",
            "rg1"
        ],
        "statement": "lemma (in group0) cosets_equipoll:\n  assumes \"IsAsubgroup(H,P)\" \"g1\\<in>G\"\"g2\\<in>G\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\"\n  shows \"r``{g1} \\<approx> r``{g2}\"\n",
        "proof": "proof-\n  have equiv:\"equiv(G,r)\" using Group_ZF_2_4_L3 assms(1) unfolding r_def by auto\n  from assms(3,2) have GG:\"(g1\\<inverse>)\\<cdot>g2\\<in>G\" using inverse_in_group group_op_closed by auto\n  then have bij:\"RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)\\<in>bij(G,G)\" using trans_bij(1) by auto\n  have \"r``{g2}\\<in>G//r\" using assms(3) unfolding quotient_def by auto\n  then have sub2:\"r``{g2}\\<subseteq>G\" using EquivClass_1_L1 equiv\n      assms(3) by blast\n  have \"r``{g1}\\<in>G//r\" using assms(2) unfolding quotient_def by auto\n  then have sub:\"r``{g1}\\<subseteq>G\" using EquivClass_1_L1 equiv assms(2) by blast\n  with bij have \"restrict(RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2),r``{g1})\\<in>bij(r``{g1},RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)``(r``{g1}))\"\n    using restrict_bij unfolding bij_def by auto\n  then have \"r``{g1}\\<approx>RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)``(r``{g1})\" unfolding eqpoll_def by auto\n  with GG sub have A0:\"r``{g1}\\<approx>{RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`t. t\\<in>r``{g1}}\"\n    using func_imagedef group0_5_L1(1) by force\n  {\n    fix t assume \"t\\<in>{RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`t. t\\<in>r``{g1}}\"\n    then obtain q where q:\"t=RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`q\" \"q\\<in>r``{g1}\" by auto\n    then have \"\\<langle>g1,q\\<rangle>\\<in>r\" \"q\\<in>G\" using image_iff sub by auto\n    then have \"g1\\<cdot>(q\\<inverse>)\\<in>H\" \"q\\<inverse>\\<in>G\" using inverse_in_group unfolding r_def QuotientGroupRel_def by auto\n    from GG q sub have t:\"t=q\\<cdot>((g1\\<inverse>)\\<cdot>g2)\" using group0_5_L2(1) by auto\n    then have \"g2\\<cdot>t\\<inverse>=g2\\<cdot>(q\\<cdot>((g1\\<inverse>)\\<cdot>g2))\\<inverse>\" by auto\n    with \\<open>q\\<in>G\\<close> GG have \"g2\\<cdot>t\\<inverse>=g2\\<cdot>(((g1\\<inverse>)\\<cdot>g2)\\<inverse>\\<cdot>q\\<inverse>)\" using group_inv_of_two by auto\n    then have \"g2\\<cdot>t\\<inverse>=g2\\<cdot>(((g2\\<inverse>)\\<cdot>g1\\<inverse>\\<inverse>)\\<cdot>q\\<inverse>)\" using group_inv_of_two inverse_in_group assms(2)\n      assms(3) by auto\n    then have \"g2\\<cdot>t\\<inverse>=g2\\<cdot>(((g2\\<inverse>)\\<cdot>g1)\\<cdot>q\\<inverse>)\" using group_inv_of_inv assms(2) by auto moreover\n    have \"(g2\\<inverse>)\\<cdot>g1\\<in>G\" using assms(2) inverse_in_group assms(3) group_op_closed by auto\n    with assms(3) \\<open>q\\<inverse>\\<in>G\\<close> have \"g2\\<cdot>(((g2\\<inverse>)\\<cdot>g1)\\<cdot>q\\<inverse>)=g2\\<cdot>((g2\\<inverse>)\\<cdot>g1)\\<cdot>q\\<inverse>\" using group_oper_assoc by auto\n    moreover have \"g2\\<cdot>((g2\\<inverse>)\\<cdot>g1)=g2\\<cdot>(g2\\<inverse>)\\<cdot>g1\" using assms(2) inverse_in_group assms(3)\n      group_oper_assoc by auto\n    then have \"g2\\<cdot>((g2\\<inverse>)\\<cdot>g1)=g1\" using group0_2_L6 assms(3) group0_2_L2 assms(2) by auto ultimately\n    have \"g2\\<cdot>t\\<inverse>=g1\\<cdot>q\\<inverse>\" by auto\n    with \\<open>g1\\<cdot>(q\\<inverse>)\\<in>H\\<close> have \"g2\\<cdot>t\\<inverse>\\<in>H\" by auto moreover\n    from t \\<open>q\\<in>G\\<close> \\<open>g2\\<in>G\\<close> have \"t\\<in>G\" using inverse_in_group assms(2) group_op_closed by auto\n    ultimately have \"\\<langle>g2,t\\<rangle>\\<in>r\" unfolding QuotientGroupRel_def r_def using assms(3) by auto\n    then have \"t\\<in>r``{g2}\" using image_iff assms(4) by auto\n  }\n  then have A1:\"{RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`t. t\\<in>r``{g1}}\\<subseteq>r``{g2}\" by auto\n  {\n    fix t assume \"t\\<in>r``{g2}\"\n    then have \"\\<langle>g2,t\\<rangle>\\<in>r\" \"t\\<in>G\" using sub2 image_iff by auto\n    then have H:\"g2\\<cdot>t\\<inverse>\\<in>H\" unfolding QuotientGroupRel_def r_def by auto\n    then have G:\"g2\\<cdot>t\\<inverse>\\<in>G\" using group0_3_L2 assms(1) by auto\n    then have \"g1\\<cdot>(g1\\<inverse>\\<cdot>(g2\\<cdot>t\\<inverse>))=g1\\<cdot>g1\\<inverse>\\<cdot>(g2\\<cdot>t\\<inverse>)\" using group_oper_assoc\n        assms(2) inverse_in_group by auto\n    with G have \"g1\\<cdot>(g1\\<inverse>\\<cdot>(g2\\<cdot>t\\<inverse>))=g2\\<cdot>t\\<inverse>\" using group0_2_L6 assms(2) group0_2_L2 by auto\n    with H have HH:\"g1\\<cdot>(g1\\<inverse>\\<cdot>(g2\\<cdot>t\\<inverse>))\\<in>H\" by auto\n    from \\<open>t\\<in>G\\<close> have GGG:\"t\\<cdot>g2\\<inverse>\\<in>G\" using inverse_in_group assms(3) group_op_closed by auto\n    from \\<open>t\\<in>G\\<close> have \"(t\\<cdot>g2\\<inverse>)\\<inverse>=g2\\<inverse>\\<inverse>\\<cdot>t\\<inverse>\" using group_inv_of_two inverse_in_group assms(3) by auto\n    also have \"\\<dots>=g2\\<cdot>t\\<inverse>\" using group_inv_of_inv assms(3) by auto\n    finally have \"(t\\<cdot>g2\\<inverse>)\\<inverse>=g2\\<cdot>t\\<inverse>\" by auto\n    then have \"g1\\<inverse>\\<cdot>(t\\<cdot>g2\\<inverse>)\\<inverse>=g1\\<inverse>\\<cdot>(g2\\<cdot>t\\<inverse>)\" by auto\n    then have \"((t\\<cdot>g2\\<inverse>)\\<cdot>g1)\\<inverse>=g1\\<inverse>\\<cdot>(g2\\<cdot>t\\<inverse>)\" using group_inv_of_two GGG assms(2) by auto\n    then have HHH:\"g1\\<cdot>((t\\<cdot>g2\\<inverse>)\\<cdot>g1)\\<inverse>\\<in>H\" using HH by auto\n    from \\<open>t\\<in>G\\<close> have \"(t\\<cdot>g2\\<inverse>)\\<cdot>g1\\<in>G\" using assms(2) inverse_in_group assms(3) group_op_closed by auto\n    with HHH have \"\\<langle>g1,(t\\<cdot>g2\\<inverse>)\\<cdot>g1\\<rangle>\\<in>r\" using assms(2) unfolding r_def QuotientGroupRel_def by auto\n    then have rg1:\"t\\<cdot>g2\\<inverse>\\<cdot>g1\\<in>r``{g1}\" using image_iff by auto\n    from assms(3) have \"g2\\<inverse>:G\" using inverse_in_group by auto\n    from \\<open>t\\<in>G\\<close> have \"t\\<cdot>g2\\<inverse>\\<cdot>g1\\<cdot>((g1\\<inverse>)\\<cdot>g2)=t\\<cdot>(g2\\<inverse>\\<cdot>g1)\\<cdot>((g1\\<inverse>)\\<cdot>g2)\" using group_oper_assoc inverse_in_group assms(3) assms(2)\n      by auto\n    also from \\<open>t\\<in>G\\<close> have \"\\<dots>=t\\<cdot>((g2\\<inverse>\\<cdot>g1)\\<cdot>((g1\\<inverse>)\\<cdot>g2))\" using group_oper_assoc group_op_closed inverse_in_group assms(3) assms(2)\n      by auto\n    also from GG \\<open>g2\\<inverse>:G\\<close> have \"\\<dots>=t\\<cdot>(g2\\<inverse>\\<cdot>(g1\\<cdot>((g1\\<inverse>)\\<cdot>g2)))\" using group_oper_assoc\n      assms(2) by auto\n    also have \"\\<dots>=t\\<cdot>(g2\\<inverse>\\<cdot>(g1\\<cdot>(g1\\<inverse>)\\<cdot>g2))\" using group_oper_assoc assms(2) inverse_in_group assms(3) by auto\n    also from \\<open>t\\<in>G\\<close> have \"\\<dots>=t\" using group0_2_L6 assms(3) group0_2_L6 assms(2) group0_2_L2 assms(3) by auto\n    finally have \"t\\<cdot>g2\\<inverse>\\<cdot>g1\\<cdot>((g1\\<inverse>)\\<cdot>g2)=t\" by auto\n    with \\<open>(t\\<cdot>g2\\<inverse>)\\<cdot>g1\\<in>G\\<close> GG have \"RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`(t\\<cdot>g2\\<inverse>\\<cdot>g1)=t\" using group0_5_L2(1) by auto\n    then have \"t\\<in>{RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`t. t\\<in>r``{g1}}\" using rg1 by force\n  }\n  then have \"r``{g2}\\<subseteq>{RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`t. t\\<in>r``{g1}}\" by blast\n  with A1 have \"r``{g2}={RightTranslation(G,P,(g1\\<inverse>)\\<cdot>g2)`t. t\\<in>r``{g1}}\" by auto\n  with A0 show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 633
    },
    "579": {
        "type": "theorem",
        "text": "text\\<open>The order of a subgroup multiplied by the order of the space of cosets is the order of\nthe group. We only prove the theorem for finite groups.\\<close>\n",
        "assumes": "assumes \"Finite(G)\" \"IsAsubgroup(H,P)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\"\n  ",
        "using": [
            "Group_ZF_2_4_L3",
            "assms(2)",
            "r_def"
        ],
        "statement": "theorem (in group0) Lagrange:\n  assumes \"Finite(G)\" \"IsAsubgroup(H,P)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\"\n  shows \"|G|=|H| #* |G//r|\"\nproof-\n  have equiv:\"equiv(G,r)\" ",
        "proof": "using Group_ZF_2_4_L3 assms(2) unfolding r_def by auto\n  have \"r``{\\<one>} \\<subseteq>G\" unfolding r_def QuotientGroupRel_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 634
    },
    "580": {
        "type": "definition",
        "text": "text\\<open>Since \\<open>G\\<close> is always a group containing the set, we may take\nthe intersection of all subgroups bigger than the set; and hence\nthe result is the subgroup we searched.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in group0)\n  SubgroupGenerated (\"\\<langle>_\\<rangle>\\<^sub>G\" 80)\n  where \"X\\<subseteq>G \\<Longrightarrow> \\<langle>X\\<rangle>\\<^sub>G \\<equiv> \\<Inter>{H\\<in>Pow(G). X\\<subseteq>H \\<and> IsAsubgroup(H,P)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 635
    },
    "581": {
        "type": "theorem",
        "text": "text\\<open>Every generated subgroup is a subgroup\\<close>\n",
        "assumes": "assumes \"X\\<subseteq>G\"\n  ",
        "using": [
            "group_oper_fun",
            "restrict_idem",
            "Pi_def",
            "groupAssum",
            "subgroup_inter",
            "SubgroupGenerated_def",
            "assms"
        ],
        "statement": "theorem (in group0) subgroupGen_is_subgroup:\n  assumes \"X\\<subseteq>G\"\n  shows \"IsAsubgroup(\\<langle>X\\<rangle>\\<^sub>G,P)\"\n",
        "proof": "proof-\n  have \"restrict(P,G\\<times>G)=P\" using group_oper_fun restrict_idem unfolding Pi_def by auto\n  then have \"IsAsubgroup(G,P)\" unfolding IsAsubgroup_def using groupAssum by auto\n  with assms have \"G\\<in>{H\\<in>Pow(G). X\\<subseteq>H \\<and> IsAsubgroup(H,P)}\" by auto\n  then have \"{H\\<in>Pow(G). X\\<subseteq>H \\<and> IsAsubgroup(H,P)}\\<noteq>0\" by auto\n  then show ?thesis using subgroup_inter SubgroupGenerated_def assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 636
    },
    "582": {
        "type": "theorem",
        "text": "text\\<open>The generated subgroup contains the original set\\<close>\n",
        "assumes": "assumes \"X\\<subseteq>G\"\n  ",
        "using": [
            "group_oper_fun",
            "restrict_idem",
            "Pi_def",
            "groupAssum",
            "subgroup_inter",
            "SubgroupGenerated_def",
            "assms"
        ],
        "statement": "theorem (in group0) subgroupGen_contains_set:\n  assumes \"X\\<subseteq>G\"\n  shows \"X \\<subseteq> \\<langle>X\\<rangle>\\<^sub>G\"\n",
        "proof": "proof-\n  have \"restrict(P,G\\<times>G)=P\" using group_oper_fun restrict_idem unfolding Pi_def by auto\n  then have \"IsAsubgroup(G,P)\" unfolding IsAsubgroup_def using groupAssum by auto\n  with assms have \"G\\<in>{H\\<in>Pow(G). X\\<subseteq>H \\<and> IsAsubgroup(H,P)}\" by auto\n  then have \"{H\\<in>Pow(G). X\\<subseteq>H \\<and> IsAsubgroup(H,P)}\\<noteq>0\" by auto\n  then show ?thesis using subgroup_inter SubgroupGenerated_def assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 637
    },
    "583": {
        "type": "theorem",
        "text": "text\\<open>Given a subgroup that contains a set, the generated subgroup\nfrom that set is smaller than this subgroup\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,P)\" \"X\\<subseteq>H\"\n  ",
        "using": [
            "group0_3_L2",
            "sub",
            "subgroup_inter",
            "SubgroupGenerated_def",
            "assms"
        ],
        "statement": "theorem (in group0) subgroupGen_minimal:\n  assumes \"IsAsubgroup(H,P)\" \"X\\<subseteq>H\"\n  shows \"\\<langle>X\\<rangle>\\<^sub>G \\<subseteq> H\"\n",
        "proof": "proof-\n  from assms have sub:\"X\\<subseteq>G\" using group0_3_L2 by auto\n  from assms have \"H\\<in>{H\\<in>Pow(G). X\\<subseteq>H \\<and> IsAsubgroup(H,P)}\" using group0_3_L2 by auto\n  then show ?thesis using sub subgroup_inter SubgroupGenerated_def assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_4.thy",
        "id": 638
    },
    "584": {
        "type": "definition",
        "text": "text\\<open>Suppose we have two groups $G$ and $H$ with corresponding binary operations \n  $P:G\\times G \\rightarrow G$ and $F:H\\times H \\rightarrow H$. Then $f$ is a homomorphism\n  if for all $g_1,g_2\\in G$ we have $f(P\\langle g_1,g_2\\rangle ) = F\\langle f(g_1),f(g_2)\\rangle$. \\<close> \n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  Homomor where  \"IsAgroup(G,P) \\<Longrightarrow> IsAgroup(H,F) \\<Longrightarrow> \n    Homomor(f,G,P,H,F) \\<equiv> \\<forall>g\\<^sub>1\\<in>G. \\<forall>g\\<^sub>2\\<in>G. f`(P`\\<langle>g\\<^sub>1,g\\<^sub>2\\<rangle>)=F`\\<langle>f`(g\\<^sub>1),f`(g\\<^sub>2)\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 639
    },
    "585": {
        "type": "lemma",
        "text": "text\\<open>Now a lemma about the definition:\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"g\\<^sub>1\\<in>G\" \"g\\<^sub>2\\<in>G\"\n  ",
        "using": [
            "assms",
            "Homomor_def"
        ],
        "statement": "lemma homomor_eq:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"g\\<^sub>1\\<in>G\" \"g\\<^sub>2\\<in>G\"\n  shows \"f`(P`\\<langle>g\\<^sub>1,g\\<^sub>2\\<rangle>)=F`\\<langle>f`(g\\<^sub>1),f`(g\\<^sub>2)\\<rangle>\"\n  ",
        "proof": "using assms Homomor_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 640
    },
    "586": {
        "type": "definition",
        "text": "text\\<open>An endomorphism is a homomorphism from a group to the same group. In case\nthe group is abelian, it has a nice structure.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"End(G,P) \\<equiv> {f\\<in>G\\<rightarrow>G. Homomor(f,G,P,G,P)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 641
    },
    "587": {
        "type": "lemma",
        "text": "text\\<open>The defining property of an endomorphism written in notation used in \\<open>group0\\<close> context:\\<close>\n",
        "assumes": "assumes \"f \\<in> End(G,P)\" \"g\\<^sub>1\\<in>G\" \"g\\<^sub>2\\<in>G\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "homomor_eq",
            "End_def"
        ],
        "statement": "lemma (in group0) endomor_eq: assumes \"f \\<in> End(G,P)\" \"g\\<^sub>1\\<in>G\" \"g\\<^sub>2\\<in>G\"\n  shows \"f`(g\\<^sub>1\\<cdot>g\\<^sub>2) = f`(g\\<^sub>1)\\<cdot>f`(g\\<^sub>2)\"\n  ",
        "proof": "using groupAssum assms homomor_eq unfolding End_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 642
    },
    "588": {
        "type": "lemma",
        "text": "text\\<open>A function that maps a group $G$ into itself and satisfies \n  $f(g_1\\cdot g2) = f(g_1)\\cdot f(g_2)$ is an endomorphism.\\<close>\n",
        "assumes": "assumes \"f:G\\<rightarrow>G\" and \"\\<forall>g\\<^sub>1\\<in>G. \\<forall>g\\<^sub>2\\<in>G. f`(g\\<^sub>1\\<cdot>g\\<^sub>2)=f`(g\\<^sub>1)\\<cdot>f`(g\\<^sub>2)\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "Homomor_def",
            "End_def"
        ],
        "statement": "lemma (in group0) eq_endomor: \n  assumes \"f:G\\<rightarrow>G\" and \"\\<forall>g\\<^sub>1\\<in>G. \\<forall>g\\<^sub>2\\<in>G. f`(g\\<^sub>1\\<cdot>g\\<^sub>2)=f`(g\\<^sub>1)\\<cdot>f`(g\\<^sub>2)\"\n  shows \"f \\<in> End(G,P)\"\n  ",
        "proof": "using groupAssum assms Homomor_def unfolding End_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 643
    },
    "589": {
        "type": "lemma",
        "text": "text\\<open>The set of endomorphisms forms a submonoid of the monoid of function\nfrom a set to that set under composition.\\<close>\n",
        "assumes": "assumes \"f\\<^sub>1\\<in>End(G,P)\" \"f\\<^sub>2\\<in>End(G,P)\"\n  ",
        "using": [
            "comp_fun",
            "group_op_closed",
            "comp_fun_apply",
            "endomor_eq",
            "apply_type",
            "eq_endomor",
            "func_ZF_5_L2"
        ],
        "statement": "lemma (in group0) end_composition:\n  assumes \"f\\<^sub>1\\<in>End(G,P)\" \"f\\<^sub>2\\<in>End(G,P)\"\n  shows \"Composition(G)`\\<langle>f\\<^sub>1,f\\<^sub>2\\<rangle> \\<in> End(G,P)\"\n",
        "proof": "proof-\n  from assms have fun: \"f\\<^sub>1:G\\<rightarrow>G\" \"f\\<^sub>2:G\\<rightarrow>G\" unfolding End_def by auto\n  then have \"f\\<^sub>1 O f\\<^sub>2:G\\<rightarrow>G\" using comp_fun by auto\n  from assms fun(2) have \n    \"\\<forall>g\\<^sub>1\\<in>G. \\<forall>g\\<^sub>2\\<in>G. (f\\<^sub>1 O f\\<^sub>2)`(g\\<^sub>1\\<cdot>g\\<^sub>2) = ((f\\<^sub>1 O f\\<^sub>2)`(g\\<^sub>1))\\<cdot>((f\\<^sub>1 O f\\<^sub>2)`(g\\<^sub>2))\"\n    using group_op_closed comp_fun_apply endomor_eq apply_type \n    by simp    \n  with fun \\<open>f\\<^sub>1 O f\\<^sub>2:G\\<rightarrow>G\\<close> show ?thesis using eq_endomor func_ZF_5_L2 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 644
    },
    "590": {
        "type": "theorem",
        "text": "text\\<open>The set of endomorphisms is closed under pointwise addition (derived from the group operation).\n   This is so because the group is abelian.\\<close>\n",
        "assumes": "assumes \"f\\<in>End(G,P)\" \"g\\<in>End(G,P)\" \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "monoid0.Group_ZF_2_1_L0",
            "group0_2_L1",
            "Group_ZF_2_1_L3",
            "group_op_closed",
            "endomor_eq",
            "apply_type",
            "group0_4_L8(3)",
            "eq_endomor"
        ],
        "statement": "theorem (in abelian_group) end_pointwise_addition:\n  assumes \"f\\<in>End(G,P)\" \"g\\<in>End(G,P)\" \"F = P {lifted to function space over} G\"\n  shows \"F`\\<langle>f,g\\<rangle> \\<in> End(G,P)\"\n",
        "proof": "proof-\n  from assms(1,2) have fun: \"f:G\\<rightarrow>G\" \"g\\<in>G\\<rightarrow>G\" unfolding End_def by simp_all\n  with assms(3) have fun2: \"F`\\<langle>f,g\\<rangle>:G\\<rightarrow>G\" \n    using monoid0.Group_ZF_2_1_L0 group0_2_L1 by simp\n  { fix g\\<^sub>1 g\\<^sub>2 assume \"g\\<^sub>1\\<in>G\" \"g\\<^sub>2\\<in>G\"\n    with isAbelian assms fun have \n      \"(F`\\<langle>f,g\\<rangle>)`(g\\<^sub>1\\<cdot>g\\<^sub>2) = (F`\\<langle>f,g\\<rangle>)`(g\\<^sub>1)\\<cdot>(F`\\<langle>f,g\\<rangle>)`(g\\<^sub>2)\"\n      using Group_ZF_2_1_L3 group_op_closed endomor_eq\n        apply_type group0_4_L8(3) Group_ZF_2_1_L3 by simp\n  } with fun2 show ?thesis using eq_endomor by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 646
    },
    "591": {
        "type": "lemma",
        "text": "text\\<open>The inverse of an abelian group is an endomorphism.\\<close>\n",
        "assumes": "",
        "using": [
            "inverse_in_group",
            "group_inv_of_two",
            "isAbelian",
            "IsCommutative_def",
            "group0_2_T2",
            "groupAssum",
            "Homomor_def",
            "End_def"
        ],
        "statement": "lemma (in abelian_group) end_inverse_group:\n  shows \"GroupInv(G,P) \\<in> End(G,P)\"\n  ",
        "proof": "using inverse_in_group group_inv_of_two isAbelian IsCommutative_def \n    group0_2_T2 groupAssum Homomor_def \n  unfolding End_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 647
    },
    "592": {
        "type": "theorem",
        "text": "text\\<open>The set of homomorphisms of an abelian group is an abelian subgroup of\n  the group of functions from a set to a group, under pointwise multiplication.\\<close>\n",
        "assumes": "assumes \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "end_comp_monoid(1)",
            "monoid0.group0_1_L3A",
            "monoid0_def",
            "end_pointwise_addition",
            "monoid0.group0_1_L1",
            "end_composition(1)",
            "end_inverse_group",
            "func_ZF_5_L2",
            "group0_2_T2",
            "Group_ZF_2_1_L6",
            "End_def",
            "assms(1)",
            "group0.group0_3_T3",
            "Group_ZF_2_1_T2",
            "IsAsubgroup_def",
            "group0_def",
            "Group_ZF_2_1_L7",
            "IsCommutative_def"
        ],
        "statement": "theorem (in abelian_group) end_addition_group:\n  assumes \"F = P {lifted to function space over} G\"\n  shows \"IsAgroup(End(G,P),InEnd(F,G,P))\" and\n    \"InEnd(F,G,P) {is commutative on} End(G,P)\"\n",
        "proof": "proof-\n  have \"End(G,P)\\<noteq>0\" using end_comp_monoid(1) monoid0.group0_1_L3A \n    unfolding monoid0_def by auto\n  moreover have \"End(G,P) \\<subseteq> G\\<rightarrow>G\" unfolding End_def by auto \n  moreover from isAbelian assms(1) have \"End(G,P){is closed under}F\" \n    unfolding IsOpClosed_def using end_pointwise_addition by auto \n  moreover from groupAssum assms(1) have \n    \"\\<forall>f\\<in>End(G,P). GroupInv(G\\<rightarrow>G,F)`(f) \\<in> End(G,P)\"\n    using monoid0.group0_1_L1 end_composition(1) end_inverse_group \n      func_ZF_5_L2 group0_2_T2 Group_ZF_2_1_L6 \n    unfolding monoid0_def End_def by force\n  ultimately show \"IsAgroup(End(G,P),InEnd(F,G,P))\" \n    using assms(1) group0.group0_3_T3 Group_ZF_2_1_T2 \n    unfolding IsAsubgroup_def group0_def by blast\n  from assms(1) isAbelian show \n    \"InEnd(F,G,P) {is commutative on} End(G,P)\" \n    using Group_ZF_2_1_L7 unfolding End_def IsCommutative_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 648
    },
    "593": {
        "type": "lemma",
        "text": "text\\<open>For the endomorphisms of a group $G$ the group operation lifted to the function space \n  over $G$ is distributive with respect to the composition operation. \\<close>\n",
        "assumes": "assumes \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "monoid.Group_ZF_2_1_L0",
            "func_ZF_5_L2",
            "End_def",
            "comp_fun",
            "comp_fun_apply",
            "Group_ZF_2_1_L3",
            "apply_type",
            "homomor_eq",
            "func_eq",
            "restrict",
            "end_pointwise_addition",
            "end_composition"
        ],
        "statement": "lemma (in abelian_group) distributive_comp_pointwise:\n  assumes \"F = P {lifted to function space over} G\"\n  shows \n    \"IsDistributive(End(G,P),InEnd(F,G,P),InEnd(Composition(G),G,P))\"\n",
        "proof": "proof -\n  let ?C\\<^sub>G = \"Composition(G)\"\n  let ?C\\<^sub>E = \"InEnd(?C\\<^sub>G,G,P)\"\n  let ?F\\<^sub>E = \"InEnd(F,G,P)\"\n  { fix b c d assume AS: \"b\\<in>End(G,P)\" \"c\\<in>End(G,P)\" \"d\\<in>End(G,P)\"\n    with assms(1) have ig1: \"?C\\<^sub>G `\\<langle>b, F ` \\<langle>c, d\\<rangle>\\<rangle> = b O (F`\\<langle>c,d\\<rangle>)\" \n      using monoid.Group_ZF_2_1_L0 func_ZF_5_L2 unfolding End_def \n      by auto\n    with AS have ig2: \"F`\\<langle>?C\\<^sub>G`\\<langle>b,c\\<rangle>,?C\\<^sub>G `\\<langle>b,d\\<rangle>\\<rangle> = F`\\<langle>b O c,b O d\\<rangle>\" \n      unfolding End_def using func_ZF_5_L2 by auto\n    from assms(1) AS have comp1fun: \"(b O (F`\\<langle>c,d\\<rangle>)):G\\<rightarrow>G\" \n      using monoid.Group_ZF_2_1_L0 comp_fun unfolding End_def by force\n    from assms(1) AS have comp2fun: \"(F `\\<langle>b O c,b O d\\<rangle>) : G\\<rightarrow>G\" \n      using monoid.Group_ZF_2_1_L0 comp_fun unfolding End_def by force\n    { fix g assume \"g\\<in>G\"\n      with assms(1) AS(2,3) have \"(b O (F`\\<langle>c,d\\<rangle>))`(g) = b`((F`\\<langle>c,d\\<rangle>)`(g))\" \n        using comp_fun_apply monoid.Group_ZF_2_1_L0 unfolding End_def \n        by force\n      with groupAssum assms(1) AS \\<open>g\\<in>G\\<close> have \n        \"(b O (F`\\<langle>c,d\\<rangle>))`(g) = (F`\\<langle>b O c,b O d\\<rangle>)`(g)\"\n        using Group_ZF_2_1_L3 apply_type homomor_eq comp_fun \n        unfolding End_def by auto\n    } hence \"\\<forall>g\\<in>G. (b O (F`\\<langle>c,d\\<rangle>))`(g) = (F`\\<langle>b O c,b O d\\<rangle>)`(g)\" by simp\n    with comp1fun comp2fun ig1 ig2 have \n      \"?C\\<^sub>G`\\<langle>b,F`\\<langle>c, d\\<rangle>\\<rangle> = F`\\<langle>?C\\<^sub>G`\\<langle>b , c\\<rangle>,?C\\<^sub>G`\\<langle>b,d\\<rangle>\\<rangle>\"\n      using func_eq by simp\n    moreover from AS(2,3) have \"F`\\<langle>c, d\\<rangle> = ?F\\<^sub>E`\\<langle>c, d\\<rangle>\" \n      using restrict by simp\n    moreover from AS have \"?C\\<^sub>G`\\<langle>b,c\\<rangle> = ?C\\<^sub>E`\\<langle>b,c\\<rangle>\" and \"?C\\<^sub>G`\\<langle>b,d\\<rangle> = ?C\\<^sub>E`\\<langle>b,d\\<rangle>\"\n      using restrict by auto \n    moreover from assms AS have \"?C\\<^sub>G`\\<langle>b,F `\\<langle>c,d\\<rangle>\\<rangle> = ?C\\<^sub>E`\\<langle>b, F`\\<langle>c, d\\<rangle>\\<rangle>\"\n      using end_pointwise_addition by simp\n    moreover from AS have \"F`\\<langle>?C\\<^sub>G`\\<langle>b,c\\<rangle>,?C\\<^sub>G`\\<langle>b,d\\<rangle>\\<rangle> = ?F\\<^sub>E`\\<langle>?C\\<^sub>G `\\<langle>b,c\\<rangle>,?C\\<^sub>G `\\<langle>b,d\\<rangle>\\<rangle>\"\n      using end_composition by simp\n    ultimately have eq1: \"?C\\<^sub>E`\\<langle>b, ?F\\<^sub>E`\\<langle>c,d\\<rangle>\\<rangle> = ?F\\<^sub>E `\\<langle>?C\\<^sub>E`\\<langle>b,c\\<rangle>,?C\\<^sub>E`\\<langle>b,d\\<rangle>\\<rangle>\"\n      by simp\n    from assms(1) AS have \n      compfun: \"(F`\\<langle>c,d\\<rangle>) O b : G\\<rightarrow>G\" \"F`\\<langle>c O b,d O b\\<rangle> : G\\<rightarrow>G\" \n      using monoid.Group_ZF_2_1_L0 comp_fun unfolding End_def by auto\n    { fix g assume \"g\\<in>G\"\n      with AS(1) have bg: \"b`(g) \\<in> G\" unfolding End_def using apply_type \n        by auto\n      from \\<open>g\\<in>G\\<close> AS(1) have \"((F`\\<langle>c,d\\<rangle>) O b)`g = (F`\\<langle>c,d\\<rangle>)`(b`(g))\" \n        using comp_fun_apply  unfolding End_def by force\n      also from assms(1) AS(2,3) bg have \"\\<dots> = (c`(b`(g)))\\<cdot>(d`(b`(g)))\" \n        using Group_ZF_2_1_L3 unfolding End_def by auto\n      also from \\<open>g\\<in>G\\<close> AS have \"\\<dots> = ((c O b)`(g))\\<cdot>((d O b)`(g))\" \n        using comp_fun_apply unfolding End_def by auto\n      also from assms(1) \\<open>g\\<in>G\\<close> AS have \"\\<dots> = (F`\\<langle>c O b,d O b\\<rangle>)`g\" \n        using comp_fun Group_ZF_2_1_L3 unfolding End_def by auto\n      finally have \"((F`\\<langle>c,d\\<rangle>) O b)`(g) = (F`\\<langle>c O b,d O b\\<rangle>)`(g)\" by simp\n    } hence \"\\<forall>g\\<in>G. ((F`\\<langle>c,d\\<rangle>) O b)`(g) = (F`\\<langle>c O b,d O b\\<rangle>)`(g)\" by simp\n    with compfun have \"(F`\\<langle>c,d\\<rangle>) O b = F`\\<langle>c O b,d O b\\<rangle>\" \n      using func_eq by blast\n    with assms(1) AS have \"?C\\<^sub>G`\\<langle>F`\\<langle>c,d\\<rangle>,b\\<rangle> = F`\\<langle>?C\\<^sub>G`\\<langle>c,b\\<rangle>,?C\\<^sub>G`\\<langle>d , b\\<rangle>\\<rangle>\"\n      using monoid.Group_ZF_2_1_L0 func_ZF_5_L2 unfolding End_def \n      by simp\n    moreover from AS(2,3) have \"F`\\<langle>c, d\\<rangle> = ?F\\<^sub>E`\\<langle>c, d\\<rangle>\" \n      using restrict by simp \n    moreover from AS have \"?C\\<^sub>G`\\<langle>c,b\\<rangle> = ?C\\<^sub>E`\\<langle>c , b\\<rangle>\" \"?C\\<^sub>G`\\<langle>d,b\\<rangle> = ?C\\<^sub>E`\\<langle>d,b\\<rangle>\"\n      using restrict by auto \n    moreover from assms AS have \"?C\\<^sub>G`\\<langle>F`\\<langle>c,d\\<rangle>,b\\<rangle> = ?C\\<^sub>E`\\<langle>F`\\<langle>c,d\\<rangle>,b\\<rangle>\" \n      using end_pointwise_addition by auto\n    moreover from AS have \"F`\\<langle>?C\\<^sub>G`\\<langle>c,b\\<rangle>,?C\\<^sub>G`\\<langle>d,b\\<rangle>\\<rangle> = ?F\\<^sub>E`\\<langle>?C\\<^sub>G`\\<langle>c,b\\<rangle>,?C\\<^sub>G`\\<langle>d,b\\<rangle>\\<rangle>\"\n      using end_composition by auto \n    ultimately have \"?C\\<^sub>E`\\<langle>?F\\<^sub>E`\\<langle>c,d\\<rangle>,b\\<rangle> = ?F\\<^sub>E`\\<langle>?C\\<^sub>E`\\<langle>c,b\\<rangle>,?C\\<^sub>E`\\<langle>d,b\\<rangle>\\<rangle>\"\n      by auto\n    with eq1 have \"(?C\\<^sub>E`\\<langle>b, ?F\\<^sub>E`\\<langle>c, d\\<rangle>\\<rangle> = ?F\\<^sub>E`\\<langle>?C\\<^sub>E`\\<langle>b,c\\<rangle>,?C\\<^sub>E`\\<langle>b,d\\<rangle>\\<rangle>) \\<and>\n      (?C\\<^sub>E`\\<langle>?F\\<^sub>E`\\<langle>c,d\\<rangle>,b\\<rangle> = ?F\\<^sub>E`\\<langle>?C\\<^sub>E`\\<langle>c,b\\<rangle>,?C\\<^sub>E`\\<langle>d,b\\<rangle>\\<rangle>)\"\n      by auto\n  } then show ?thesis unfolding IsDistributive_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 649
    },
    "594": {
        "type": "theorem",
        "text": "text\\<open>The endomorphisms of an abelian group is in fact a ring with the previous\n  operations.\\<close>\n",
        "assumes": "assumes \"F = P {lifted to function space over} G\"\n  ",
        "using": [
            "assms",
            "end_addition_group",
            "end_comp_monoid(1)",
            "distributive_comp_pointwise",
            "IsAring_def"
        ],
        "statement": "theorem (in abelian_group) end_is_ring:\n  assumes \"F = P {lifted to function space over} G\"\n  shows \n    \"IsAring(End(G,P),InEnd(F,G,P),InEnd(Composition(G),G,P))\"\n  ",
        "proof": "using assms end_addition_group end_comp_monoid(1) distributive_comp_pointwise\n  unfolding IsAring_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 650
    },
    "595": {
        "type": "lemma",
        "text": "text\\<open>A group homomorphism sends the neutral element to the neutral element.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  ",
        "using": [
            "assms(1)",
            "group0.group0_2_L2",
            "group0_def",
            "Homomor_def",
            "apply_type",
            "group0.group0_5_L2(2)",
            "group0.trans_bij(2)",
            "bij_def",
            "h",
            "assms(2)",
            "inj_def"
        ],
        "statement": "lemma image_neutral:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  shows \"f`(TheNeutralElement(G,P)) = TheNeutralElement(H,F)\"\n",
        "proof": "proof -\n  let ?e\\<^sub>G = \"TheNeutralElement(G,P)\"\n  let ?e\\<^sub>H = \"TheNeutralElement(H,F)\"\n  have g: \"?e\\<^sub>G = P`\\<langle>?e\\<^sub>G,?e\\<^sub>G\\<rangle>\" \"?e\\<^sub>G \\<in> G\"\n    using assms(1) group0.group0_2_L2 unfolding group0_def by simp_all\n  with assms have \"f`(?e\\<^sub>G) = F`\\<langle>f`(?e\\<^sub>G),f`(?e\\<^sub>G)\\<rangle>\"\n    using Homomor_def by force \n  moreover\n  from assms(4) g(2) have h: \"f`(?e\\<^sub>G) \\<in> H\" using apply_type \n    by simp\n  with assms(2) have \"f`(?e\\<^sub>G) = F`\\<langle>f`(?e\\<^sub>G),?e\\<^sub>H\\<rangle>\"\n    using group0.group0_2_L2 unfolding group0_def by simp \n  ultimately have \"F`\\<langle>f`(?e\\<^sub>G),?e\\<^sub>H\\<rangle> = F`\\<langle>f`(?e\\<^sub>G),f`(?e\\<^sub>G)\\<rangle>\" \n    by simp\n  with assms(2) h have \n    \"LeftTranslation(H,F,f`(?e\\<^sub>G))`(?e\\<^sub>H) = LeftTranslation(H,F,f`(?e\\<^sub>G))`(f`(?e\\<^sub>G))\"\n    using group0.group0_5_L2(2) group0.group0_2_L2 unfolding group0_def \n      by simp\n  moreover from assms(2) h have \"LeftTranslation(H,F,f`(?e\\<^sub>G))\\<in>inj(H,H)\"\n      using group0.trans_bij(2) unfolding group0_def bij_def\n      by simp\n  ultimately show ?thesis using h assms(2) group0.group0_2_L2 \n    unfolding inj_def group0_def by force\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 651
    },
    "596": {
        "type": "theorem",
        "text": "text\\<open>The preimage of a subgroup is a subgroup\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n          \"IsAsubgroup(K,F)\"\n  ",
        "using": [
            "image_neutral",
            "group0.group0_3_L5",
            "func1_1_L15",
            "group0.group0_2_L2",
            "func1_1_L3",
            "group0.group0_3_L6",
            "Homomor_def",
            "group0.group_op_closed",
            "IsOpClosed_def",
            "group0.group0_3_T3A",
            "image_inv",
            "group0.inverse_in_group"
        ],
        "statement": "theorem preimage_sub:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n          \"IsAsubgroup(K,F)\"\n  shows \"IsAsubgroup(f-``(K),P)\"\n",
        "proof": "proof -\n  from assms(2) have Hgr: \"group0(H,F)\" unfolding group0_def by simp\n  from assms(1) have Ggr: \"group0(G,P)\" unfolding group0_def by simp\n  moreover \n  from assms Ggr Hgr have \"TheNeutralElement(G,P) \\<in> f-``(K)\"\n    using image_neutral group0.group0_3_L5 func1_1_L15 group0.group0_2_L2 \n    by simp\n  hence \"f-``(K)\\<noteq>0\" by blast\n  moreover from assms(4) have \"f-``(K) \\<subseteq> G\" using func1_1_L3 by simp\n  moreover from assms Ggr Hgr have \"f-``(K) {is closed under} P\"\n    using func1_1_L15 group0.group0_3_L6 Homomor_def \n        group0.group_op_closed func1_1_L15\n    unfolding IsOpClosed_def by simp\n  moreover from assms Ggr Hgr have \n    \"\\<forall>x\\<in>f-``(K). GroupInv(G, P)`(x) \\<in> f-``(K)\"\n    using group0.group0_3_T3A image_inv func1_1_L15 \n        group0.inverse_in_group by simp\n  ultimately show ?thesis by (rule group0.group0_3_T3)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 653
    },
    "597": {
        "type": "theorem",
        "text": "text\\<open>The preimage of a normal subgroup is normal\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n          \"IsAnormalSubgroup(H,F,K)\"\n        ",
        "using": [
            "group0.group0_3_L2",
            "IsAnormalSubgroup_def",
            "preimage_sub",
            "vimage_iff",
            "Pi_def",
            "assms(1-4)",
            "Ggr",
            "gG",
            "group0.group_op_closed",
            "group0.inverse_in_group",
            "image_inv",
            "homomor_eq",
            "func1_1_L15",
            "apply_type",
            "group0.group_oper_assoc",
            "group0.cont_conj_is_normal"
        ],
        "statement": "theorem preimage_normal_subgroup:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n          \"IsAnormalSubgroup(H,F,K)\"\n        shows \"IsAnormalSubgroup(G,P,f-``(K))\"\n",
        "proof": "proof -\n  from assms(2) have Hgr: \"group0(H,F)\" unfolding group0_def by simp\n  with assms(5) have \"K\\<subseteq>H\" using group0.group0_3_L2 \n    unfolding IsAnormalSubgroup_def  by simp\n  from assms(1) have Ggr: \"group0(G,P)\" unfolding group0_def by simp\n  moreover from assms have \"IsAsubgroup(f-``(K),P)\" \n    using preimage_sub unfolding IsAnormalSubgroup_def by simp\n  moreover\n  { fix g assume gG: \"g\\<in>G\"\n    { fix h assume \"h \\<in> {P`\\<langle>g,P`\\<langle>h, GroupInv(G, P)`(g)\\<rangle>\\<rangle>. h \\<in> f-``(K)}\"\n      then obtain k where \n        k: \"h = P`\\<langle>g,P`\\<langle>k,GroupInv(G, P)`(g)\\<rangle>\\<rangle>\" \"k \\<in> f-``(K)\" \n        by auto\n      from k(1) have \"f`(h) = f`(P`\\<langle>g,P`\\<langle>k, GroupInv(G, P)`(g)\\<rangle>\\<rangle>)\" by simp\n      moreover from assms(4) k(2) have \"k\\<in>G\" using vimage_iff \n        unfolding Pi_def by blast\n      ultimately have f: \"f`(h) = F`\\<langle>f`(g),F`\\<langle>f`(k),GroupInv(H,F)`(f`(g))\\<rangle>\\<rangle>\"\n        using assms(1-4) Ggr gG group0.group_op_closed \n          group0.inverse_in_group image_inv homomor_eq by simp\n      from assms(1,4) Ggr \\<open>g\\<in>G\\<close> k have \"h\\<in>G\" using group0.group_op_closed\n        group0.inverse_in_group func1_1_L15 by simp\n      from assms(4,5) k(2) \\<open>g\\<in>G\\<close> have \"f`(k)\\<in>K\" \"f`(g)\\<in>H\" and \n        \"F`\\<langle>F`\\<langle>f`(g),f`(k)\\<rangle>,GroupInv(H,F)`(f`(g))\\<rangle> \\<in> K\"\n        using func1_1_L15 apply_type unfolding IsAnormalSubgroup_def \n        by auto\n      moreover from \\<open>f`(k)\\<in>K\\<close> \\<open>K\\<subseteq>H\\<close> Hgr f \\<open>f`(g)\\<in>H\\<close> have\n        \"f`(h) = F`\\<langle>F`\\<langle>f`(g),f`(k)\\<rangle>,GroupInv(H,F)`(f`(g))\\<rangle>\"\n        using group0.group_oper_assoc group0.inverse_in_group by auto\n      ultimately have \"f`(h) \\<in> K\" by simp\n      with assms(4) \\<open>h\\<in>G\\<close> have \"h \\<in> f-``(K)\" using func1_1_L15 by simp\n    } hence \"{P`\\<langle>g,P`\\<langle>h,GroupInv(G,P)`(g)\\<rangle>\\<rangle>. h\\<in>f-``(K)} \\<subseteq> f-``(K)\" \n      by blast\n  } hence \"\\<forall>g\\<in>G. {P`\\<langle>g, P`\\<langle>h, GroupInv(G, P)`(g)\\<rangle>\\<rangle>. h\\<in>f-``(K)} \\<subseteq> f-``(K)\" \n    by simp\n  ultimately show ?thesis using group0.cont_conj_is_normal by simp \nqed        \n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 654
    },
    "598": {
        "type": "corollary",
        "text": "text\\<open>The image of a group under a homomorphism is a subgroup of the target group.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  ",
        "using": [
            "group0.group_oper_fun",
            "restrict_domain",
            "group0_def",
            "image_subgroup",
            "IsAsubgroup_def"
        ],
        "statement": "corollary image_group:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  shows \"IsAsubgroup(f``(G),F)\"\n",
        "proof": "proof - \n  from assms(1) have \"restrict(P,G\\<times>G) = P\" \n    using group0.group_oper_fun restrict_domain unfolding group0_def \n    by blast\n  with assms show ?thesis using image_subgroup unfolding IsAsubgroup_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 657
    },
    "599": {
        "type": "theorem",
        "text": "text\\<open>Now we are able to prove the first isomorphism theorem. This theorem states\n  that any group homomorphism $f:G\\to H$ gives an isomorphism between a quotient group of $G$\n  and a subgroup of $H$.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,f-``{TheNeutralElement(H,F)})\" and\n  \"\\<P> \\<equiv> QuotientGroupOp(G,P,f-``{TheNeutralElement(H,F)})\"\n  ",
        "using": [
            "group0.Group_ZF_2_4_L3",
            "kernel_normal_sub",
            "group0_def",
            "IsAnormalSubgroup_def",
            "func_imagedef",
            "apply_type",
            "same_image_equiv",
            "func1_1_L15",
            "image_inv",
            "Homomor_def",
            "group0.inverse_in_group",
            "group0.group0_2_L11A",
            "Group_ZF_2_4_L5A",
            "group0.Group_ZF_2_2_L2",
            "group0.group_op_closed",
            "QuotientGroupOp_def",
            "apply_equality",
            "Group_ZF_2_4_T1",
            "image_group",
            "IsAsubgroup_def",
            "func1_1_L6(2)",
            "group0.group0_2_L6(1)",
            "restrict",
            "group0.group0_3_T1",
            "group0.Group_ZF_2_4_L5E",
            "ff_fun"
        ],
        "statement": "theorem isomorphism_first_theorem:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,f-``{TheNeutralElement(H,F)})\" and\n  \"\\<P> \\<equiv> QuotientGroupOp(G,P,f-``{TheNeutralElement(H,F)})\"\n  shows \"\\<exists>\\<ff>. Homomor(\\<ff>,G//r,\\<P>,f``(G),restrict(F,(f``(G))\\<times>(f``(G)))) \\<and> \\<ff>\\<in>bij(G//r,f``(G))\"\n",
        "proof": "proof-\n  let ?\\<ff> = \"{\\<langle>r``{g},f`(g)\\<rangle>. g\\<in>G}\"\n  from assms(1-5) have \"equiv(G,r)\"\n    using group0.Group_ZF_2_4_L3 kernel_normal_sub \n    unfolding group0_def IsAnormalSubgroup_def by simp\n  from assms(4,5) have \"?\\<ff> \\<in> Pow((G//r)\\<times>f``G)\" \n    unfolding quotient_def using func_imagedef by auto\n  moreover have \"(G//r) \\<subseteq> domain(?\\<ff>)\" unfolding domain_def quotient_def by auto \n  moreover\n  { fix x y t assume A: \"\\<langle>x,y\\<rangle> \\<in> ?\\<ff>\" \"\\<langle>x,t\\<rangle> \\<in> ?\\<ff>\"\n    then obtain g\\<^sub>y g\\<^sub>r where \"\\<langle>x, y\\<rangle>=\\<langle>r``{g\\<^sub>y},f`(g\\<^sub>y)\\<rangle>\" \"\\<langle>x, t\\<rangle>=\\<langle>r``{g\\<^sub>r},f`(g\\<^sub>r)\\<rangle>\" \n      and \"g\\<^sub>r\\<in>G\" \"g\\<^sub>y\\<in>G\" by auto\n    hence B: \"r``{g\\<^sub>y}=r``{g\\<^sub>r}\" \"y=f`(g\\<^sub>y)\" \"t=f`(g\\<^sub>r)\" by auto\n    from assms(4) \\<open>g\\<^sub>y\\<in>G\\<close> \\<open>g\\<^sub>r\\<in>G\\<close> B(2,3) have \"y\\<in>H\" \"t\\<in>H\" \n      using apply_type by simp_all\n    with \\<open>equiv(G,r)\\<close> \\<open>g\\<^sub>r\\<in>G\\<close> \\<open>r``{g\\<^sub>y}=r``{g\\<^sub>r}\\<close> have \"\\<langle>g\\<^sub>y,g\\<^sub>r\\<rangle>\\<in>r\" \n      using same_image_equiv by simp\n    with assms(4,5) have \n      \"f`(P`\\<langle>g\\<^sub>y,GroupInv(G,P)`(g\\<^sub>r)\\<rangle>) = TheNeutralElement(H,F)\"\n      unfolding QuotientGroupRel_def using func1_1_L15 by simp\n    with assms(1-4) B(2,3) \\<open>g\\<^sub>y\\<in>G\\<close> \\<open>g\\<^sub>r\\<in>G\\<close> \\<open>y\\<in>H\\<close> \\<open>t\\<in>H\\<close> have \"y=t\"\n      using image_inv Homomor_def group0.inverse_in_group group0.group0_2_L11A \n      unfolding group0_def by auto\n  } hence \"\\<forall>x y. \\<langle>x,y\\<rangle> \\<in> ?\\<ff> \\<longrightarrow> (\\<forall>z. \\<langle>x,z\\<rangle>\\<in>?\\<ff> \\<longrightarrow> y=z)\" by auto\n  ultimately have ff_fun: \"?\\<ff>:G//r\\<rightarrow>f``(G)\" unfolding Pi_def function_def \n    by auto\n  { fix a\\<^sub>1 a\\<^sub>2 assume AS: \"a\\<^sub>1\\<in>G//r\" \"a\\<^sub>2\\<in>G//r\"\n    then obtain g\\<^sub>1 g\\<^sub>2  where \"g\\<^sub>1\\<in>G\" \"g\\<^sub>2\\<in>G\" and a: \"a\\<^sub>1=r``{g\\<^sub>1}\" \"a\\<^sub>2=r``{g\\<^sub>2}\" \n      unfolding quotient_def by auto\n    with assms \\<open>equiv(G,r)\\<close> have \"\\<langle>\\<P>`\\<langle>a\\<^sub>1,a\\<^sub>2\\<rangle>,f`(P`\\<langle>g\\<^sub>1,g\\<^sub>2\\<rangle>)\\<rangle> \\<in> ?\\<ff>\"\n      using Group_ZF_2_4_L5A kernel_normal_sub group0.Group_ZF_2_2_L2 group0.group_op_closed\n      unfolding QuotientGroupOp_def group0_def by auto       \n    with ff_fun have eq: \"?\\<ff>`(\\<P>`\\<langle>a\\<^sub>1,a\\<^sub>2\\<rangle>) = f`(P`\\<langle>g\\<^sub>1,g\\<^sub>2\\<rangle>)\" using apply_equality  \n      by simp\n    from \\<open>g\\<^sub>1\\<in>G\\<close> \\<open>g\\<^sub>2\\<in>G\\<close> a have \"\\<langle>a\\<^sub>1,f`(g\\<^sub>1)\\<rangle> \\<in> ?\\<ff>\" and \"\\<langle>a\\<^sub>2,f`(g\\<^sub>2)\\<rangle> \\<in> ?\\<ff>\" by auto\n    with assms(1,2,3) ff_fun \\<open>g\\<^sub>1\\<in>G\\<close> \\<open>g\\<^sub>2\\<in>G\\<close> eq have \"F`\\<langle>?\\<ff>`(a\\<^sub>1),?\\<ff>`(a\\<^sub>2)\\<rangle> = ?\\<ff>`(\\<P>`\\<langle>a\\<^sub>1,a\\<^sub>2\\<rangle>)\"\n      using apply_equality Homomor_def by simp\n    moreover from AS ff_fun have \"?\\<ff>`(a\\<^sub>1) \\<in> f``(G)\" \"?\\<ff>`(a\\<^sub>2) \\<in> f``(G)\" \n      using apply_type by auto \n    ultimately have \"restrict(F,f``(G)\\<times>f``(G))`\\<langle>?\\<ff>`(a\\<^sub>1),?\\<ff>`(a\\<^sub>2)\\<rangle> = ?\\<ff>`(\\<P>`\\<langle>a\\<^sub>1,a\\<^sub>2\\<rangle>)\" \n      by simp\n  } hence r: \"\\<forall>a\\<^sub>1\\<in>G//r. \\<forall>a\\<^sub>2\\<in>G//r. restrict(F,f``G\\<times>f``G)`\\<langle>?\\<ff>`a\\<^sub>1,?\\<ff>`a\\<^sub>2\\<rangle> = ?\\<ff>`(\\<P>`\\<langle>a\\<^sub>1,a\\<^sub>2\\<rangle>)\" \n    by simp\n  moreover from assms have G: \"IsAgroup(G//r,\\<P>)\" \n    using Group_ZF_2_4_T1 kernel_normal_sub by simp\n  moreover from assms(1-4) have H: \"IsAgroup(f``(G), restrict(F,f``(G)\\<times>f``(G)))\" \n    using image_group unfolding IsAsubgroup_def by simp\n  ultimately have HOM: \"Homomor(?\\<ff>,G//r,\\<P>,f``(G),restrict(F,(f``(G))\\<times>(f``(G))))\" \n    using Homomor_def by simp\n  { fix b\\<^sub>1 b\\<^sub>2 assume AS: \"?\\<ff>`(b\\<^sub>1) = ?\\<ff>`(b\\<^sub>2)\" \"b\\<^sub>1\\<in>G//r\" \"b\\<^sub>2\\<in>G//r\"\n    from G AS(3) have invb2: \"GroupInv(G//r,\\<P>)`(b\\<^sub>2)\\<in>G//r\" \n      using group0.inverse_in_group unfolding group0_def by simp\n    with G AS(2) have I: \"\\<P>`\\<langle>b\\<^sub>1,GroupInv(G//r,\\<P>)`(b\\<^sub>2)\\<rangle>\\<in>G//r\"\n      using group0.group_op_closed unfolding group0_def by auto\n    then obtain g where \"g\\<in>G\" and gg: \"\\<P>`\\<langle>b\\<^sub>1,GroupInv(G//r,\\<P>)`(b\\<^sub>2)\\<rangle>=r``{g}\" \n      unfolding quotient_def by auto\n    from \\<open>g\\<in>G\\<close> have \"\\<langle>r``{g},f`(g)\\<rangle> \\<in> ?\\<ff>\" by blast\n    with ff_fun gg have E: \"?\\<ff>`(\\<P>`\\<langle>b\\<^sub>1,GroupInv(G//r,\\<P>)`(b\\<^sub>2)\\<rangle>) = f`(g)\"\n      using apply_equality by simp\n    from ff_fun invb2 have pp: \"?\\<ff>`(GroupInv(G//r,\\<P>)`(b\\<^sub>2))\\<in>f``(G)\" \n      using apply_type by simp\n    from ff_fun AS(2,3) have fff: \"?\\<ff>`(b\\<^sub>1) \\<in> f``(G)\" \"?\\<ff>`(b\\<^sub>2) \\<in> f``(G)\" \n      using apply_type by simp_all\n    from fff(1) pp have \n      EE: \"F`\\<langle>?\\<ff>`(b\\<^sub>1),?\\<ff>`(GroupInv(G//r,\\<P>)`(b\\<^sub>2))\\<rangle>=\n          restrict(F,f``(G)\\<times>f``(G))`\\<langle>?\\<ff>`(b\\<^sub>1),?\\<ff>`(GroupInv(G//r,\\<P>)`(b\\<^sub>2))\\<rangle>\"\n      by auto\n    from assms(4) have \"f``(G) \\<subseteq> H\" using func1_1_L6(2) by simp\n    with fff have \"?\\<ff>`(b\\<^sub>1)\\<in>H\" \"?\\<ff>`(b\\<^sub>2)\\<in>H\" by auto\n    with assms(1-4) G H HOM ff_fun AS(1,3) fff(2) EE have\n      \"TheNeutralElement(H,F) = restrict(F,f``(G)\\<times>f``(G))`\\<langle>?\\<ff>`(b\\<^sub>1),?\\<ff>`(GroupInv(G//r,\\<P>)`(b\\<^sub>2))\\<rangle>\"\n      using group0.group0_2_L6(1) restrict image_inv group0.group0_3_T1 image_group \n      unfolding group0_def by simp\n    also from G H HOM AS(2,3) E have \"\\<dots> = f`(g)\"\n      using Homomor_def group0.inverse_in_group unfolding group0_def by simp\n    finally have \"TheNeutralElement(H,F) = f`(g)\" by simp\n    with assms(4) \\<open>g\\<in>G\\<close> have \"g\\<in>f-``{TheNeutralElement(H,F)}\" using func1_1_L15 \n      by simp\n    with assms \\<open>g\\<in>G\\<close> gg have \n      \"\\<P>`\\<langle>b\\<^sub>1,GroupInv(G//r,\\<P>)`(b\\<^sub>2)\\<rangle> = TheNeutralElement(G//r,\\<P>)\"\n      using group0.Group_ZF_2_4_L5E kernel_normal_sub unfolding group0_def \n      by simp\n    with AS(2,3) G have \"b\\<^sub>1=b\\<^sub>2\" using group0.group0_2_L11A unfolding group0_def \n      by auto\n  } with ff_fun have \"?\\<ff> \\<in> inj(G//r,f``(G))\" unfolding inj_def by blast \n  moreover\n  { fix m assume \"m \\<in> f``(G)\"\n    with assms(4) obtain g where \"g\\<in>G\" \"m=f`(g)\" using func_imagedef by auto\n    hence \"\\<langle>r``{g},m\\<rangle> \\<in> ?\\<ff>\" by blast\n    with ff_fun have \"?\\<ff>`(r``{g})=m\" using apply_equality by auto\n    with \\<open>g\\<in>G\\<close> have \"\\<exists>A\\<in>G//r. ?\\<ff>`(A) = m\" unfolding quotient_def by auto\n  }\n  ultimately have \"?\\<ff> \\<in> bij(G//r,f``G)\" unfolding bij_def surj_def using ff_fun \n    by blast\n  with HOM show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 658
    },
    "600": {
        "type": "theorem",
        "text": "text\\<open>The inverse of a bijective homomorphism is an homomorphism.\n  Meaning that in the previous result, the homomorphism we found is an isomorphism.\\<close>\n",
        "assumes": "assumes \"f\\<in>bij(G,H)\" \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\"\n  ",
        "using": [
            "homomor_eq",
            "left_inverse",
            "group0.group_op_closed",
            "group0_def",
            "bij_def",
            "Homomor_def"
        ],
        "statement": "theorem bij_homomor:\n  assumes \"f\\<in>bij(G,H)\" \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\"\n  shows \"Homomor(converse(f),H,F,G,P)\"\n",
        "proof": "proof-\n  { fix h\\<^sub>1 h\\<^sub>2 assume \"h\\<^sub>1\\<in>H\" \"h\\<^sub>2\\<in>H\"\n    with assms(1) obtain g\\<^sub>1 g\\<^sub>2 where \n      g1: \"g\\<^sub>1\\<in>G\" \"f`(g\\<^sub>1)=h\\<^sub>1\" and g2: \"g\\<^sub>2\\<in>G\" \"f`(g\\<^sub>2)=h\\<^sub>2\"\n      unfolding bij_def surj_def by blast\n    with assms(2,3,4) have  \n      \"converse(f)`(f`(P`\\<langle>g\\<^sub>1,g\\<^sub>2\\<rangle>)) = converse(f)`(F`\\<langle>h\\<^sub>1,h\\<^sub>2\\<rangle>)\"\n      using homomor_eq by simp\n    with assms(1,2) g1 g2 have\n      \"P`\\<langle>converse(f)`(h\\<^sub>1),converse(f)`(h\\<^sub>2)\\<rangle> = converse(f)`(F`\\<langle>h\\<^sub>1,h\\<^sub>2\\<rangle>)\"\n      using left_inverse group0.group_op_closed unfolding group0_def bij_def\n      by auto\n  } with assms(2,3) show ?thesis using Homomor_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 659
    },
    "601": {
        "type": "lemma",
        "text": "text\\<open>A very important homomorphism is given by taking every element\n  to its class in a group quotient. Recall that $\\lambda x\\in X. p(x)$\n  is an alternative notation for function defined as a set of pairs,\n  see lemma \\<open>lambda_fun_alt\\<close> in theory \\<open>func1.thy\\<close>.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,P,H)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\" and \"q \\<equiv> \\<lambda>x\\<in>G. QuotientGroupRel(G,P,H)``{x}\"\n  ",
        "using": [
            "groupAssum",
            "assms",
            "group_op_closed",
            "lam_funtype",
            "lamE",
            "EquivClass_1_L10",
            "Group_ZF_2_4_L3",
            "Group_ZF_2_4_L5A",
            "Homomor_def",
            "Group_ZF_2_4_T1",
            "IsAnormalSubgroup_def",
            "QuotientGroupOp_def"
        ],
        "statement": "lemma (in group0) quotient_map:\n  assumes \"IsAnormalSubgroup(G,P,H)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,P,H)\" and \"q \\<equiv> \\<lambda>x\\<in>G. QuotientGroupRel(G,P,H)``{x}\"\n  shows \"Homomor(q,G,P,G//r,QuotientGroupOp(G,P,H))\"\n  ",
        "proof": "using groupAssum assms group_op_closed lam_funtype lamE EquivClass_1_L10 \n    Group_ZF_2_4_L3 Group_ZF_2_4_L5A Homomor_def Group_ZF_2_4_T1\n  unfolding IsAnormalSubgroup_def QuotientGroupOp_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 660
    },
    "602": {
        "type": "definition",
        "text": "text\\<open>From that we define the inductive sequence on the \n  whole set of natural numbers. Recall that in Isabelle/ZF the set of natural numbers\n  is denoted \\<open>nat\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"InductiveSequence(x,f) \\<equiv> \\<Union>n\\<in>nat. InductiveSequenceN(x,f,n)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 662
    },
    "603": {
        "type": "lemma",
        "text": "text\\<open>A lemma about restricting finite sequences needed for the proof of\n  the inductive step of the existence and uniqueness of finite inductive seqences.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" and\n  A4: \"a: succ(succ(n))\\<rightarrow> X \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>succ(n). a`(succ(k)) = f`(a`(k)))\"\n  and A5: \"a\\<^sub>r = restrict(a,succ(n))\"\n  ",
        "using": [
            "restrict_type2",
            "empty_in_every_succ",
            "restrict_if",
            "succ_ineq"
        ],
        "statement": "lemma indseq_restrict: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" and\n  A4: \"a: succ(succ(n))\\<rightarrow> X \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>succ(n). a`(succ(k)) = f`(a`(k)))\"\n  and A5: \"a\\<^sub>r = restrict(a,succ(n))\"\n  shows \n  \"a\\<^sub>r: succ(n) \\<rightarrow> X \\<and> a\\<^sub>r`(0) = x \\<and> ( \\<forall>k\\<in>n. a\\<^sub>r`(succ(k)) = f`(a\\<^sub>r`(k)) )\"\n",
        "proof": "proof -\n  from A3 have \"succ(n) \\<subseteq> succ(succ(n))\" by auto\n  with A4 A5 have \"a\\<^sub>r: succ(n) \\<rightarrow> X\" using restrict_type2 by auto\n  moreover\n  from A3 have \"0 \\<in> succ(n)\" using empty_in_every_succ by simp\n  with A4 A5 have \"a\\<^sub>r`(0) = x\" using restrict_if by simp\n  moreover from A3 A4 A5 have \"\\<forall>k\\<in>n. a\\<^sub>r`(succ(k)) = f`(a\\<^sub>r`(k))\"\n    using succ_ineq restrict_if by auto\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 664
    },
    "604": {
        "type": "lemma",
        "text": "text\\<open>Existence and uniqueness of finite inductive sequences. The proof\n  is by induction and the next lemma is the inductive step.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" and \n  A4: \"\\<exists>! a. a: succ(n) \\<rightarrow> X \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)))\"\n  ",
        "using": [
            "restrict",
            "apply_funtype",
            "finseq_extend",
            "empty_in_every_succ",
            "succ_ineq"
        ],
        "statement": "lemma indseq_exun_ind: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" and \n  A4: \"\\<exists>! a. a: succ(n) \\<rightarrow> X \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)))\"\n  shows \n  \"\\<exists>! a. a: succ(succ(n)) \\<rightarrow> X \\<and> a`(0) = x \\<and> \n  ( \\<forall>k\\<in>succ(n). a`(succ(k)) = f`(a`(k)) )\"\n",
        "proof": "proof\n  fix a b assume\n    A5: \"a: succ(succ(n)) \\<rightarrow> X \\<and> a`(0) = x \\<and> \n    ( \\<forall>k\\<in>succ(n). a`(succ(k)) = f`(a`(k)) )\" and\n    A6: \"b: succ(succ(n)) \\<rightarrow> X \\<and> b`(0) = x \\<and> \n    ( \\<forall>k\\<in>succ(n). b`(succ(k)) = f`(b`(k)) )\"\n  show \"a = b\"\n  proof -\n    let ?a\\<^sub>r = \"restrict(a,succ(n))\"\n    let ?b\\<^sub>r = \"restrict(b,succ(n))\"\n    note A1 A2 A3 A5\n    moreover have \"?a\\<^sub>r = restrict(a,succ(n))\" by simp\n    ultimately have I:\n      \"?a\\<^sub>r: succ(n) \\<rightarrow> X \\<and> ?a\\<^sub>r`(0) = x \\<and> ( \\<forall>k\\<in>n. ?a\\<^sub>r`(succ(k)) = f`(?a\\<^sub>r`(k)) )\"\n      by (rule indseq_restrict)\n    note A1 A2 A3 A6\n    moreover have \"?b\\<^sub>r = restrict(b,succ(n))\" by simp\n    ultimately have\n      \"?b\\<^sub>r: succ(n) \\<rightarrow> X \\<and> ?b\\<^sub>r`(0) = x \\<and> ( \\<forall>k\\<in>n. ?b\\<^sub>r`(succ(k)) = f`(?b\\<^sub>r`(k)) )\"\n      by (rule indseq_restrict)\n    with A4 I have II: \"?a\\<^sub>r = ?b\\<^sub>r\" by blast\n    from A3 have \"succ(n) \\<in> nat\" by simp\n    moreover from A5 A6 have \n      \"a: succ(succ(n)) \\<rightarrow> X\" and \"b: succ(succ(n)) \\<rightarrow> X\"\n      by auto\n    moreover note II\n    moreover \n    have T: \"n \\<in> succ(n)\" by simp\n    then have \"?a\\<^sub>r`(n) = a`(n)\" and \"?b\\<^sub>r`(n) = b`(n)\" using restrict\n      by auto\n    with A5 A6 II T have \"a`(succ(n)) = b`(succ(n))\" by simp\n    ultimately show \"a = b\" by (rule finseq_restr_eq)\n  qed\nnext show \n    \"\\<exists> a. a: succ(succ(n)) \\<rightarrow> X \\<and> a`(0) = x \\<and> \n    ( \\<forall>k\\<in>succ(n). a`(succ(k)) = f`(a`(k)) )\"\n  proof -\n    from A4 obtain a where III: \"a: succ(n) \\<rightarrow> X\" and IV: \"a`(0) = x\" \n      and V: \"\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k))\" by auto\n    let ?b = \"a \\<union> {\\<langle>succ(n), f`(a`(n))\\<rangle>}\"\n    from A1 III have\n      VI: \"?b : succ(succ(n)) \\<rightarrow> X\" and\n      VII: \"\\<forall>k \\<in> succ(n). ?b`(k) = a`(k)\" and \n      VIII: \"?b`(succ(n)) = f`(a`(n))\" \n      using apply_funtype finseq_extend by auto\n    from A3 have \"0 \\<in> succ(n)\" using empty_in_every_succ by simp\n    with IV VII have IX: \"?b`(0) = x\" by auto\n    { fix k assume \"k \\<in> succ(n)\"\n      then have \"k\\<in>n \\<or> k = n\" by auto\n      moreover\n      { assume A7: \"k \\<in> n\"\n\twith A3 VII have \"?b`(succ(k)) = a`(succ(k))\"\n\t  using succ_ineq by auto\n\talso from A7 V VII have \"a`(succ(k)) = f`(?b`(k))\" by simp\n\tfinally have \"?b`(succ(k)) =  f`(?b`(k))\" by simp }\n      moreover\n      { assume A8: \"k = n\"\n\twith VIII have \"?b`(succ(k)) =  f`(a`(k))\" by simp\n\twith A8 VII VIII have \"?b`(succ(k)) =  f`(?b`(k))\" by simp }\n      ultimately have \"?b`(succ(k)) =  f`(?b`(k))\" by auto\n    } then have \"\\<forall>k \\<in> succ(n). ?b`(succ(k)) =  f`(?b`(k))\" by simp\n    with VI IX show ?thesis by auto\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 665
    },
    "605": {
        "type": "lemma",
        "text": "text\\<open>The next lemma combines \\<open>indseq_exun0\\<close> and \\<open>indseq_exun_ind\\<close> \n  to show the existence and uniqueness of finite sequences defined by induction.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\"\n  ",
        "using": [
            "indseq_exun0",
            "indseq_exun_ind"
        ],
        "statement": "lemma indseq_exun: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\"\n  shows \n  \"\\<exists>! a. a: succ(n) \\<rightarrow> X \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)))\"\n",
        "proof": "proof -\n  note A3\n  moreover from A1 A2 have\n    \"\\<exists>! a. a: succ(0) \\<rightarrow> X \\<and> a`(0) = x \\<and> ( \\<forall>k\\<in>0. a`(succ(k)) = f`(a`(k)) )\"\n    using indseq_exun0 by simp\n  moreover from A1 A2 have \"\\<forall>k \\<in> nat.\n    ( \\<exists>! a. a: succ(k) \\<rightarrow> X \\<and> a`(0) = x \\<and> \n    ( \\<forall>i\\<in>k. a`(succ(i)) = f`(a`(i)) )) \\<longrightarrow>\n    ( \\<exists>! a. a: succ(succ(k)) \\<rightarrow> X \\<and> a`(0) = x \\<and> \n    ( \\<forall>i\\<in>succ(k). a`(succ(i)) = f`(a`(i)) ) )\"\n    using indseq_exun_ind by simp\n  ultimately show\n    \"\\<exists>! a. a: succ(n) \\<rightarrow> X \\<and> a`(0) = x \\<and> ( \\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)) )\"\n    by (rule ind_on_nat)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 666
    },
    "606": {
        "type": "theorem",
        "text": "text\\<open>We are now ready to prove the main theorem about finite inductive sequences.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" and\n  A4: \"a = InductiveSequenceN(x,f,n)\"\n  ",
        "using": [
            "indseq_exun",
            "InductiveSequenceN_def",
            "func1_1_L1"
        ],
        "statement": "theorem fin_indseq_props: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" and\n  A4: \"a = InductiveSequenceN(x,f,n)\"\n  shows\n  \"a: succ(n) \\<rightarrow> X\"\n  \"a`(0) = x\"\n  \"\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k))\"\n",
        "proof": "proof -\n  let ?i = \"THE a. a: succ(n) \\<rightarrow> X \\<and> a`(0) = x \\<and> \n    ( \\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)) )\"\n  from A1 A2 A3 have \n    \"\\<exists>! a. a: succ(n) \\<rightarrow> X \\<and> a`(0) = x \\<and> ( \\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)) )\"\n    using indseq_exun by simp\n  then have \n    \"?i: succ(n) \\<rightarrow> X \\<and> ?i`(0) = x \\<and> ( \\<forall>k\\<in>n. ?i`(succ(k)) = f`(?i`(k)) )\"\n    by (rule theI)\n  moreover from A1 A4 have \"a = ?i\"\n    using InductiveSequenceN_def func1_1_L1 by simp\n  ultimately show \n    \"a: succ(n) \\<rightarrow> X\"   \"a`(0) = x\"   \"\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k))\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 667
    },
    "607": {
        "type": "lemma",
        "text": "text\\<open>Since we have uniqueness we can show the inverse of \\<open>fin_indseq_props\\<close>: \n  a sequence that satisfies the inductive sequence properties listed there \n  is the inductively defined sequence. \\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"f: X\\<rightarrow>X\" \"x\\<in>X\" and\n  \"a: succ(n) \\<rightarrow> X\" \"a`(0) = x\" \"\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k))\"\n  ",
        "using": [
            "fin_indseq_props",
            "indseq_exun"
        ],
        "statement": "lemma is_fin_indseq: \n  assumes \"n \\<in> nat\" \"f: X\\<rightarrow>X\" \"x\\<in>X\" and\n  \"a: succ(n) \\<rightarrow> X\" \"a`(0) = x\" \"\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k))\"\n  shows \"a = InductiveSequenceN(x,f,n)\"\n",
        "proof": "proof -\n  let ?b = \"InductiveSequenceN(x,f,n)\"\n  from assms(1,2,3) have \n    \"?b: succ(n) \\<rightarrow> X\" \"?b`(0) = x\" \"\\<forall>k\\<in>n. ?b`(succ(k)) = f`(?b`(k))\"\n    using fin_indseq_props by simp_all\n  with assms show ?thesis using indseq_exun by blast\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 668
    },
    "608": {
        "type": "corollary",
        "text": "text\\<open>A corollary about the domain of a finite inductive sequence.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" \n  ",
        "using": [
            "fin_indseq_props",
            "func1_1_L1"
        ],
        "statement": "corollary fin_indseq_domain: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\" \n  shows \"domain(InductiveSequenceN(x,f,n)) = succ(n)\"\n",
        "proof": "proof -\n  from assms have \"InductiveSequenceN(x,f,n) : succ(n) \\<rightarrow> X\"\n    using fin_indseq_props by simp\n  then show ?thesis using func1_1_L1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 669
    },
    "609": {
        "type": "lemma",
        "text": "text\\<open>The collection of finite sequences defined by induction is consistent\n  in the sense that the restriction of the sequence defined on a larger\n  set to the smaller set is the same as the sequence defined on the smaller set.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and \n  A3: \"i \\<in> nat\"  \"j \\<in> nat\" and A4: \"i \\<subseteq> j\"\n  ",
        "using": [
            "fin_indseq_props",
            "succ_subset",
            "restrict_type2",
            "empty_in_every_succ",
            "restrict",
            "succ_ineq",
            "indseq_exun"
        ],
        "statement": "lemma indseq_consistent: assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and \n  A3: \"i \\<in> nat\"  \"j \\<in> nat\" and A4: \"i \\<subseteq> j\"\n  shows \n  \"restrict(InductiveSequenceN(x,f,j),succ(i)) = InductiveSequenceN(x,f,i)\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequenceN(x,f,j)\"\n  let ?b = \"restrict(InductiveSequenceN(x,f,j),succ(i))\"\n  let ?c = \"InductiveSequenceN(x,f,i)\"\n  from A1 A2 A3 have \n    \"?a: succ(j) \\<rightarrow> X\"  \"?a`(0) = x\"   \"\\<forall>k\\<in>j. ?a`(succ(k)) = f`(?a`(k))\"\n    using fin_indseq_props by auto\n  with A3 A4 have\n    \"?b: succ(i) \\<rightarrow> X \\<and> ?b`(0) = x \\<and> ( \\<forall>k\\<in>i. ?b`(succ(k)) = f`(?b`(k)))\"\n    using succ_subset restrict_type2 empty_in_every_succ restrict succ_ineq\n    by auto\n  moreover from A1 A2 A3 have\n    \"?c: succ(i) \\<rightarrow> X \\<and> ?c`(0) = x \\<and> ( \\<forall>k\\<in>i. ?c`(succ(k)) = f`(?c`(k)))\"\n    using fin_indseq_props by simp\n  moreover from A1 A2 A3 have\n    \"\\<exists>! a. a: succ(i) \\<rightarrow> X \\<and> a`(0) = x \\<and> ( \\<forall>k\\<in>i. a`(succ(k)) = f`(a`(k)) )\"\n    using indseq_exun by simp\n  ultimately show \"?b = ?c\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 670
    },
    "610": {
        "type": "lemma",
        "text": "text\\<open>For any two natural numbers one of the corresponding inductive sequences\n  is contained in the other.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and \n  A3: \"i \\<in> nat\"  \"j \\<in> nat\" and \n  A4: \"a = InductiveSequenceN(x,f,i)\"  \"b = InductiveSequenceN(x,f,j)\"\n  ",
        "using": [
            "nat_incl_total",
            "indseq_consistent",
            "restrict_subset"
        ],
        "statement": "lemma indseq_subsets: assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and \n  A3: \"i \\<in> nat\"  \"j \\<in> nat\" and \n  A4: \"a = InductiveSequenceN(x,f,i)\"  \"b = InductiveSequenceN(x,f,j)\"\n  shows \"a \\<subseteq> b \\<or> b \\<subseteq> a\"\n",
        "proof": "proof -\n  from A3 have \"i\\<subseteq>j \\<or> j\\<subseteq>i\" using nat_incl_total by simp\n  moreover\n  { assume \"i\\<subseteq>j\"\n    with A1 A2 A3 A4 have \"restrict(b,succ(i)) = a\" \n      using indseq_consistent by simp\n    moreover have \"restrict(b,succ(i)) \\<subseteq> b\" \n      using restrict_subset by simp\n    ultimately have \"a \\<subseteq> b \\<or> b \\<subseteq> a\" by simp }\n  moreover\n  { assume \"j\\<subseteq>i\"\n    with A1 A2 A3 A4 have \"restrict(a,succ(j)) = b\" \n      using indseq_consistent by simp\n    moreover have \"restrict(a,succ(j)) \\<subseteq> a\" \n      using restrict_subset by simp\n    ultimately have \"a \\<subseteq> b \\<or> b \\<subseteq> a\" by simp }\n  ultimately show  \"a \\<subseteq> b \\<or> b \\<subseteq> a\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 671
    },
    "611": {
        "type": "lemma",
        "text": "text\\<open>The inductive sequence generated by applying a function 0 times is just\n  the singleton list containing the starting point.\\<close>\n",
        "assumes": "assumes \"f: X\\<rightarrow>X\" \"x\\<in>X\"\n  ",
        "using": [
            "fin_indseq_props(1,2)",
            "func_singleton_pair"
        ],
        "statement": "lemma indseq_empty: assumes \"f: X\\<rightarrow>X\" \"x\\<in>X\"\n  shows \n    \"InductiveSequenceN(x,f,0):{0}\\<rightarrow>X\"\n    \"InductiveSequenceN(x,f,0) = {\\<langle>0,x\\<rangle>}\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequenceN(x,f,0)\"\n  from assms have \"?a:succ(0)\\<rightarrow>X\" and \"?a`(0) = x\"\n    using fin_indseq_props(1,2) by simp_all\n  moreover have \"succ(0) = {0}\" by auto\n  ultimately show \"?a:{0}\\<rightarrow>X\" by auto\n  then have \"?a = {\\<langle>0,?a`(0)\\<rangle>}\" using func_singleton_pair \n    by simp\n  with\\<open>?a`(0) = x\\<close> show \"?a = {\\<langle>0,x\\<rangle>}\" by simp \nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 672
    },
    "612": {
        "type": "lemma",
        "text": "text\\<open>The tail of an inductive sequence generated by $f$ and started from $x$\n  is the same as the inductive sequence started from $f(x)$.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"f: X\\<rightarrow>X\" \"x\\<in>X\" \n  ",
        "using": [
            "apply_funtype",
            "fin_indseq_props(1)",
            "tail_props",
            "empty_in_every_succ",
            "fin_indseq_props(3)",
            "fin_indseq_props(2)",
            "succ_ineq"
        ],
        "statement": "lemma indseq_tail: assumes \"n \\<in> nat\" \"f: X\\<rightarrow>X\" \"x\\<in>X\" \n  shows \"Tail(InductiveSequenceN(x,f,succ(n))) = InductiveSequenceN(f`(x),f,n)\"\n",
        "proof": "proof -\n  let ?a = \"Tail(InductiveSequenceN(x,f,succ(n)))\"\n  from assms(2,3) have \"f`(x)\\<in>X\" using apply_funtype by simp\n  have  \"?a: succ(n) \\<rightarrow> X\" \"?a`(0) = f`(x)\" and \n        \"\\<forall>k\\<in>n. ?a`(succ(k)) = f`(?a`(k))\"\n  proof -\n    let ?b = \"InductiveSequenceN(x,f,succ(n))\"\n    from assms have I: \"succ(n)\\<in>nat\" \"?b: succ(succ(n)) \\<rightarrow> X\"\n      using fin_indseq_props(1) by simp_all\n    then show \"Tail(?b):succ(n)\\<rightarrow>X\" using tail_props by simp\n    from assms(1) I have II: \"Tail(?b)`(0) = ?b`(succ(0))\"\n      using tail_props empty_in_every_succ by blast\n    from assms \\<open>succ(n)\\<in>nat\\<close> have \"?b`(succ(0)) = f`(?b`(0))\" \n      using fin_indseq_props(3) empty_in_every_succ by blast\n    moreover from assms(2,3) \\<open>succ(n)\\<in>nat\\<close> have \"?b`(0) = x\"\n      using fin_indseq_props(2) by simp\n    ultimately have \"?b`(succ(0)) = f`(x)\" by simp\n    with II show \"?a`(0) = f`(x)\" by simp\n    { fix k assume \"k\\<in>n\"\n      from I have III: \"\\<forall>k\\<in>succ(n). ?a`(k) = ?b`(succ(k))\"\n        using tail_props by blast\n      with assms(1) \\<open>k\\<in>n\\<close> have \"?a`(succ(k)) = ?b`(succ(succ(k)))\"\n        using succ_ineq by blast\n      with assms \\<open>k\\<in>n\\<close> III have \"?a`(succ(k)) = f`(?a`(k))\" \n        using succ_ineq fin_indseq_props(3) by simp\n    } then show \"\\<forall>k\\<in>n. ?a`(succ(k)) = f`(?a`(k))\"\n      by simp\n  qed\n  with assms(1,2) \\<open>f`(x)\\<in>X\\<close> show ?thesis by (rule is_fin_indseq)\nqed    \n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 673
    },
    "613": {
        "type": "theorem",
        "text": "text\\<open>The first theorem about properties of infinite inductive sequences:\n  inductive sequence is a indeed a sequence (i.e. a function on the set of \n  natural numbers.\\<close>\n",
        "assumes": "assumes  A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"\n  ",
        "using": [
            "fin_indseq_props",
            "indseq_subsets",
            "fun_Union",
            "domain_UN",
            "fin_indseq_domain",
            "nat_union_succ",
            "func1_1_L5",
            "func1_1_L1A",
            "InductiveSequence_def"
        ],
        "statement": "theorem indseq_seq: assumes  A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"\n  shows \"InductiveSequence(x,f) : nat \\<rightarrow> X\"\n",
        "proof": "proof -\n  let ?S = \"{InductiveSequenceN(x,f,n). n \\<in> nat}\"\n  { fix a assume \"a\\<in>?S\"\n    then obtain n where \"n \\<in> nat\" and \"a =  InductiveSequenceN(x,f,n)\"\n      by auto\n    with A1 A2 have \"a : succ(n)\\<rightarrow>X\" using fin_indseq_props\n      by simp\n    then have \"\\<exists>A B. a:A\\<rightarrow>B\" by auto\n  } then have \"\\<forall>a \\<in> ?S. \\<exists>A B. a:A\\<rightarrow>B\" by auto\n  moreover\n  { fix a b assume \"a\\<in>?S\"   \"b\\<in>?S\"\n    then obtain i j where \"i\\<in>nat\"  \"j\\<in>nat\" and\n      \"a = InductiveSequenceN(x,f,i)\"   \"b = InductiveSequenceN(x,f,j)\"\n      by auto\n    with A1 A2 have \"a\\<subseteq>b \\<or> b\\<subseteq>a\" using indseq_subsets by simp\n  } then have \"\\<forall>a\\<in>?S. \\<forall>b\\<in>?S. a\\<subseteq>b \\<or> b\\<subseteq>a\" by auto\n  ultimately have \"\\<Union>?S : domain(\\<Union>?S) \\<rightarrow> range(\\<Union>?S)\"\n    using fun_Union by simp\n  with A1 A2 have I: \"\\<Union>?S : nat \\<rightarrow> range(\\<Union>?S)\"\n    using domain_UN fin_indseq_domain nat_union_succ by simp\n  moreover\n  { fix k assume A3: \"k \\<in> nat\"\n    let ?y = \"(\\<Union>?S)`(k)\"\n    note I A3\n    moreover have \"?y = (\\<Union>?S)`(k)\" by simp\n    ultimately have \"\\<langle>k,?y\\<rangle> \\<in> (\\<Union>?S)\" by (rule func1_1_L5A)\n    then obtain n where \"n \\<in> nat\" and II: \"\\<langle>k,?y\\<rangle> \\<in> InductiveSequenceN(x,f,n)\"\n      by auto\n    with A1 A2 have \"InductiveSequenceN(x,f,n): succ(n) \\<rightarrow> X\" \n      using fin_indseq_props by simp\n    with II have \"?y \\<in> X\" using func1_1_L5 by blast\n  } then have \"\\<forall>k \\<in> nat.  (\\<Union>?S)`(k) \\<in> X\" by simp\n  ultimately have \"\\<Union>?S : nat \\<rightarrow> X\" using func1_1_L1A\n    by blast\n  then show \"InductiveSequence(x,f) : nat \\<rightarrow> X\"\n    using InductiveSequence_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 674
    },
    "614": {
        "type": "lemma",
        "text": "text\\<open>Restriction of an inductive sequence to a finite domain\n  is the corresponding finite inductive sequence.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\"\n  ",
        "using": [
            "indseq_seq",
            "succnat_subset_nat",
            "restrict_type2",
            "fin_indseq_props",
            "InductiveSequence_def",
            "fun_Union_apply",
            "restrict_if"
        ],
        "statement": "lemma indseq_restr_eq: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\" and A3: \"n \\<in> nat\"\n  shows \n  \"restrict(InductiveSequence(x,f),succ(n)) = InductiveSequenceN(x,f,n)\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequence(x,f)\"\n  let ?b = \"InductiveSequenceN(x,f,n)\"\n  let ?S = \"{InductiveSequenceN(x,f,n). n \\<in> nat}\"\n  from A1 A2 A3 have \n    I: \"?a : nat \\<rightarrow> X\"  and \"succ(n) \\<subseteq> nat\"\n    using indseq_seq succnat_subset_nat by auto\n  then have \"restrict(?a,succ(n)) : succ(n) \\<rightarrow> X\"\n    using restrict_type2 by simp\n  moreover from A1 A2 A3 have \"?b : succ(n) \\<rightarrow> X\"\n    using fin_indseq_props by simp\n  moreover\n  { fix k assume A4: \"k \\<in> succ(n)\"\n    from A1 A2 A3 I have\n      \"\\<Union>?S : nat \\<rightarrow> X\"   \"?b \\<in> ?S\"  \"?b : succ(n) \\<rightarrow> X\"\n      using InductiveSequence_def fin_indseq_props by auto\n    with A4 have \"restrict(?a,succ(n))`(k) = ?b`(k)\"\n      using fun_Union_apply InductiveSequence_def restrict_if\n      by simp\n  } then have \"\\<forall>k \\<in> succ(n). restrict(?a,succ(n))`(k) = ?b`(k)\" \n    by simp\n  ultimately show ?thesis by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 675
    },
    "615": {
        "type": "theorem",
        "text": "text\\<open>An infinite inductive sequence satisfies the \n  inductive relation that defines it.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"  and A3: \"n \\<in> nat\"\n  ",
        "using": [
            "restrict_if",
            "indseq_restr_eq",
            "fin_indseq_props"
        ],
        "statement": "theorem indseq_vals: \n  assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"  and A3: \"n \\<in> nat\"\n  shows \n  \"InductiveSequence(x,f)`(succ(n)) = f`(InductiveSequence(x,f)`(n))\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequence(x,f)\"\n  let ?b = \"InductiveSequenceN(x,f,succ(n))\"\n  from A3 have T: \n    \"succ(n) \\<in> succ(succ(n))\"  \n    \"succ(succ(n)) \\<in> nat\" \n    \"n \\<in> succ(succ(n))\"\n    by auto    \n  then have \"?a`(succ(n)) = restrict(?a,succ(succ(n)))`(succ(n))\"\n    using restrict_if by simp\n  also from A1 A2 T have \"\\<dots> = f`(restrict(?a,succ(succ(n)))`(n))\"\n    using indseq_restr_eq fin_indseq_props by simp\n  also from T have \"\\<dots> = f`(?a`(n))\" using restrict_if by simp\n  finally show \"?a`(succ(n)) = f`(?a`(n))\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 677
    },
    "616": {
        "type": "theorem",
        "text": "text\\<open>The basic properties of orbits.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"  and \n  A3: \"A = InductiveSequence(x,f)``(nat)\"\n  ",
        "using": [
            "indseq_seq",
            "func_imagedef",
            "indseq_valat0",
            "indseq_vals"
        ],
        "statement": "theorem ind_seq_image: assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"  and \n  A3: \"A = InductiveSequence(x,f)``(nat)\"\n  shows \"x\\<in>A\" and \"\\<forall>y\\<in>A. f`(y) \\<in> A\" \n",
        "proof": "proof -\n  let ?a = \"InductiveSequence(x,f)\"\n  from A1 A2 have \"?a : nat \\<rightarrow> X\" using indseq_seq\n    by simp\n  with A3 have I: \"A = {?a`(n). n \\<in> nat}\" using func_imagedef\n    by auto hence \"?a`(0) \\<in> A\" by auto\n  with A1 A2 show \"x\\<in>A\" using indseq_valat0 by simp\n  { fix y assume \"y\\<in>A\"\n    with I obtain n where II: \"n \\<in> nat\" and III: \"y = ?a`(n)\"\n      by auto\n    with A1 A2 have \"?a`(succ(n)) = f`(y)\"\n      using indseq_vals by simp\n    moreover from I II have \"?a`(succ(n)) \\<in> A\" by auto\n    ultimately have \"f`(y) \\<in> A\" by simp\n  } then show \"\\<forall>y\\<in>A. f`(y) \\<in> A\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 678
    },
    "617": {
        "type": "theorem",
        "text": "text\\<open>Basic propertes of sets generated by binary operations.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and A2: \"x\\<in>X\"  \"y\\<in>Y\" and\n  A3: \"a = InductiveSequence(x,Fix2ndVar(f,y))\"\n  ",
        "using": [
            "fix_2nd_var_fun",
            "indseq_seq",
            "func1_1_L6",
            "ind_seq_image"
        ],
        "statement": "theorem binop_gen_set: \n  assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and A2: \"x\\<in>X\"  \"y\\<in>Y\" and\n  A3: \"a = InductiveSequence(x,Fix2ndVar(f,y))\"\n  shows\n  \"a : nat \\<rightarrow> X\"\n  \"a``(nat) \\<in> Pow(X)\"\n  \"x \\<in> a``(nat)\"\n  \"\\<forall>z \\<in> a``(nat). Fix2ndVar(f,y)`(z) \\<in> a``(nat)\"\n",
        "proof": "proof -\n  let ?g = \"Fix2ndVar(f,y)\"\n  from A1 A2 have I: \"?g : X\\<rightarrow>X\"\n    using fix_2nd_var_fun by simp\n  with A2 A3 show \"a : nat \\<rightarrow> X\"\n    using indseq_seq by simp\n  then show \"a``(nat) \\<in> Pow(X)\" using func1_1_L6 by simp\n  from A2 A3 I show \"x \\<in> a``(nat)\" using ind_seq_image by blast\n  from A2 A3 I have\n    \"?g : X\\<rightarrow>X\"  \"x\\<in>X\"  \"a``(nat) = InductiveSequence(x,?g)``(nat)\"\n    by auto\n  then show \"\\<forall>z \\<in> a``(nat). Fix2ndVar(f,y)`(z) \\<in> a``(nat)\"\n    by (rule ind_seq_image)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 679
    },
    "618": {
        "type": "lemma",
        "text": "text\\<open>A simple corollary to the theorem \\<open>binop_gen_set\\<close>: a set\n  that contains all iterations of the application of a binary operation\n  exists.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and A2: \"x\\<in>X\"  \"y\\<in>Y\"\n  ",
        "using": [
            "binop_gen_set",
            "fix_var_val"
        ],
        "statement": "lemma binop_gen_set_ex: assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and A2: \"x\\<in>X\"  \"y\\<in>Y\"\n  shows \"{A \\<in> Pow(X). x\\<in>A \\<and> (\\<forall>z \\<in> A. f`\\<langle>z,y\\<rangle> \\<in> A) } \\<noteq> 0\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequence(x,Fix2ndVar(f,y))\" \n  let ?A = \"?a``(nat)\"\n  from A1 A2 have I: \"?A \\<in> Pow(X)\" and \"x \\<in> ?A\" using binop_gen_set \n    by auto\n  moreover\n  { fix z assume T: \"z\\<in>?A\"\n    with A1 A2 have \"Fix2ndVar(f,y)`(z) \\<in> ?A\"\n      using binop_gen_set by simp\n    moreover\n    from I T have \"z \\<in> X\" by auto\n    with A1 A2 have \"Fix2ndVar(f,y)`(z) = f`\\<langle>z,y\\<rangle>\"\n      using fix_var_val by simp\n    ultimately have \"f`\\<langle>z,y\\<rangle> \\<in> ?A\" by simp\n  } then have \"\\<forall>z \\<in> ?A. f`\\<langle>z,y\\<rangle> \\<in> ?A\" by simp\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 680
    },
    "619": {
        "type": "theorem",
        "text": "text\\<open>A more general version of \\<open> binop_gen_set\\<close> where the generating\n  binary operation acts on a larger set.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and \n  A2: \"X\\<^sub>1 \\<subseteq> X\" and A3: \"x\\<in>X\\<^sub>1\"  \"y\\<in>Y\" and\n  A4: \"\\<forall>t\\<in>X\\<^sub>1. f`\\<langle>t,y\\<rangle> \\<in> X\\<^sub>1\" and \n  A5: \"a = InductiveSequence(x,Fix2ndVar(restrict(f,X\\<^sub>1\\<times>Y),y))\"\n",
        "using": [
            "restrict_type2",
            "fix_2nd_var_fun",
            "restrict",
            "fix_var_val",
            "func1_1_L1A",
            "indseq_seq",
            "func1_1_L6",
            "ind_seq_image",
            "fix_2nd_var_restr_comm"
        ],
        "statement": "theorem binop_gen_set1: assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and \n  A2: \"X\\<^sub>1 \\<subseteq> X\" and A3: \"x\\<in>X\\<^sub>1\"  \"y\\<in>Y\" and\n  A4: \"\\<forall>t\\<in>X\\<^sub>1. f`\\<langle>t,y\\<rangle> \\<in> X\\<^sub>1\" and \n  A5: \"a = InductiveSequence(x,Fix2ndVar(restrict(f,X\\<^sub>1\\<times>Y),y))\"\nshows \n  \"a : nat \\<rightarrow> X\\<^sub>1\"\n  \"a``(nat) \\<in> Pow(X\\<^sub>1)\"\n  \"x \\<in> a``(nat)\"\n  \"\\<forall>z \\<in> a``(nat). Fix2ndVar(f,y)`(z) \\<in> a``(nat)\"\n  \"\\<forall>z \\<in> a``(nat). f`\\<langle>z,y\\<rangle> \\<in> a``(nat)\"\n",
        "proof": "proof -\n  let ?h = \"restrict(f,X\\<^sub>1\\<times>Y)\"\n  let ?g = \"Fix2ndVar(?h,y)\"\n  from A2 have \"X\\<^sub>1\\<times>Y \\<subseteq> X\\<times>Y\" by auto\n  with A1 have I: \"?h : X\\<^sub>1\\<times>Y \\<rightarrow> X\"\n    using restrict_type2 by simp\n  with A3 have II: \"?g: X\\<^sub>1 \\<rightarrow> X\" using fix_2nd_var_fun by simp\n  from A3 A4 I have \"\\<forall>t\\<in>X\\<^sub>1. ?g`(t) \\<in> X\\<^sub>1\"\n    using restrict fix_var_val by simp\n  with II have III: \"?g : X\\<^sub>1 \\<rightarrow> X\\<^sub>1\" using func1_1_L1A by blast\n  with A3 A5 show \"a : nat \\<rightarrow> X\\<^sub>1\" using indseq_seq by simp\n  then show IV: \"a``(nat) \\<in> Pow(X\\<^sub>1)\" using func1_1_L6 by simp\n  from A3 A5 III show \"x \\<in> a``(nat)\" using ind_seq_image by blast\n  from A3 A5 III have \n    \"?g : X\\<^sub>1 \\<rightarrow> X\\<^sub>1\"   \"x\\<in>X\\<^sub>1\"  \"a``(nat) =  InductiveSequence(x,?g)``(nat)\"\n    by auto\n  then have \"\\<forall>z \\<in> a``(nat). Fix2ndVar(?h,y)`(z) \\<in> a``(nat)\" \n    by (rule ind_seq_image)\n  moreover\n  { fix z assume \"z \\<in> a``(nat)\"\n    with IV have \"z \\<in> X\\<^sub>1\" by auto\n    with A1 A2 A3 have \"?g`(z) = Fix2ndVar(f,y)`(z)\"\n      using fix_2nd_var_restr_comm restrict by simp\n  } then have \"\\<forall>z \\<in> a``(nat). ?g`(z) = Fix2ndVar(f,y)`(z)\" by simp\n  ultimately show \"\\<forall>z \\<in> a``(nat). Fix2ndVar(f,y)`(z) \\<in> a``(nat)\" by simp\n  moreover\n  { fix z assume \"z \\<in> a``(nat)\"\n    with A2 IV have \"z\\<in>X\" by auto\n    with A1 A3 have \"Fix2ndVar(f,y)`(z) = f`\\<langle>z,y\\<rangle>\"\n      using fix_var_val by simp\n  } then have \"\\<forall>z \\<in> a``(nat). Fix2ndVar(f,y)`(z) = f`\\<langle>z,y\\<rangle>\"\n    by simp\n  ultimately show \"\\<forall>z \\<in> a``(nat). f`\\<langle>z,y\\<rangle> \\<in> a``(nat)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 681
    },
    "620": {
        "type": "lemma",
        "text": "text\\<open>A generalization of \\<open> binop_gen_set_ex\\<close> that applies when the binary\n  operation acts on a larger set. This is used in our Metamath translation\n  to prove the existence of the set of real natural numbers. \n  Metamath defines the real natural numbers as the smallest set that cantains\n  $1$ and is closed with respect to operation of adding $1$.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and \n  A2: \"X\\<^sub>1 \\<subseteq> X\" and A3: \"x\\<in>X\\<^sub>1\"  \"y\\<in>Y\" and\n  A4: \"\\<forall>t\\<in>X\\<^sub>1. f`\\<langle>t,y\\<rangle> \\<in> X\\<^sub>1\"\n  ",
        "using": [
            "binop_gen_set1"
        ],
        "statement": "lemma binop_gen_set_ex1: assumes A1: \"f: X\\<times>Y \\<rightarrow> X\" and \n  A2: \"X\\<^sub>1 \\<subseteq> X\" and A3: \"x\\<in>X\\<^sub>1\"  \"y\\<in>Y\" and\n  A4: \"\\<forall>t\\<in>X\\<^sub>1. f`\\<langle>t,y\\<rangle> \\<in> X\\<^sub>1\"\n  shows \"{A \\<in> Pow(X\\<^sub>1). x\\<in>A \\<and> (\\<forall>z \\<in> A. f`\\<langle>z,y\\<rangle> \\<in> A) } \\<noteq> 0\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequence(x,Fix2ndVar(restrict(f,X\\<^sub>1\\<times>Y),y))\"\n  let ?A = \"?a``(nat)\"\n  from A1 A2 A3 A4 have \n    \"?A \\<in> Pow(X\\<^sub>1)\"   \"x \\<in> ?A\"   \"\\<forall>z \\<in> ?A. f`\\<langle>z,y\\<rangle> \\<in> ?A\"\n    using binop_gen_set1 by auto\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 682
    },
    "621": {
        "type": "definition",
        "text": "text\\<open>The situation where the function that we iterate changes with $n$ can be \n  derived from the simpler case if we define the generating function appropriately.\n  Namely, we replace the generating function in the definitions of \n  \\<open>InductiveSequenceN\\<close> by the function $f: X\\times n \\rightarrow X\\times n$, \n  $f\\langle x,k\\rangle = \\langle f_k(x), k+1 \\rangle$ if $k < n$,  \n  $\\langle f_k(x), k \\rangle$ otherwise. The first notion defines the expression \n  we will use to define the generating function. \n  To understand the notation recall that in standard Isabelle/ZF\n  for a pair $s=\\langle x,n \\rangle$ we have \\<open>fst\\<close>$(s)=x$ and \n  \\<open>snd\\<close>$(s)=n$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"StateTransfFunNMeta(F,n,s) \\<equiv> \n  if (snd(s) \\<in> n) then \\<langle>F`(snd(s))`(fst(s)), succ(snd(s))\\<rangle> else s\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 683
    },
    "622": {
        "type": "definition",
        "text": "text\\<open>Then we define the actual generating function on sets of pairs\n  from $X\\times \\{0,1, .. ,n\\}$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"StateTransfFunN(X,F,n) \\<equiv> {\\<langle>s, StateTransfFunNMeta(F,n,s)\\<rangle>. s \\<in> X\\<times>succ(n)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 684
    },
    "623": {
        "type": "definition",
        "text": "text\\<open>Having the generating function we can define the expression\n  that we cen use to define the inductive sequence generates.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"StatesSeq(x,X,F,n) \\<equiv> \n  InductiveSequenceN(\\<langle>x,0\\<rangle>, StateTransfFunN(X,F,n),n)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 685
    },
    "624": {
        "type": "definition",
        "text": "text\\<open>Finally we can define the sequence given by a initial point $x$,\n  and a sequence $F$ of $n$ functions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"InductiveSeqVarFN(x,X,F,n) \\<equiv> {\\<langle>k,fst(StatesSeq(x,X,F,n)`(k))\\<rangle>. k \\<in> succ(n)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 686
    },
    "625": {
        "type": "lemma",
        "text": "text\\<open>The state transformation function (\\<open>StateTransfFunN\\<close> is \n  a function that transforms $X\\times n$ into itself.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"F: n \\<rightarrow> (X\\<rightarrow>X)\"\n  ",
        "using": [
            "succ_ineq",
            "apply_funtype",
            "StateTransfFunNMeta_def",
            "StateTransfFunN_def"
        ],
        "statement": "lemma state_trans_fun: assumes A1: \"n \\<in> nat\" and A2: \"F: n \\<rightarrow> (X\\<rightarrow>X)\"\n  shows \"StateTransfFunN(X,F,n): X\\<times>succ(n) \\<rightarrow> X\\<times>succ(n)\"\n",
        "proof": "proof -\n  { fix s assume A3: \"s \\<in> X\\<times>succ(n)\"\n    let ?x = \"fst(s)\"\n    let ?k = \"snd(s)\"\n    let ?S = \"StateTransfFunNMeta(F,n,s)\"\n    from A3 have T: \"?x \\<in> X\"  \"?k \\<in> succ(n)\" and \"\\<langle>?x,?k\\<rangle> = s\" by auto\n    { assume A4: \"?k \\<in> n\"\n      with A1 have \"succ(?k) \\<in> succ(n)\" using succ_ineq by simp\n      with A2 T A4 have \"?S \\<in> X\\<times>succ(n)\"\n\tusing apply_funtype StateTransfFunNMeta_def by simp }\n    with A2 A3 T have \"?S \\<in> X\\<times>succ(n)\"\n      using apply_funtype StateTransfFunNMeta_def by auto\n  } then have \"\\<forall>s \\<in> X\\<times>succ(n). StateTransfFunNMeta(F,n,s) \\<in> X\\<times>succ(n)\"\n    by simp\n  then have \n    \"{\\<langle>s, StateTransfFunNMeta(F,n,s)\\<rangle>. s \\<in> X\\<times>succ(n)} : X\\<times>succ(n) \\<rightarrow> X\\<times>succ(n)\"\n    by (rule ZF_fun_from_total)\n  then show \"StateTransfFunN(X,F,n): X\\<times>succ(n) \\<rightarrow> X\\<times>succ(n)\"\n    using StateTransfFunN_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 687
    },
    "626": {
        "type": "lemma",
        "text": "text\\<open>We can apply \\<open>fin_indseq_props\\<close> to the sequence used in the\n  definition of \\<open>InductiveSeqVarFN\\<close> to get the properties of the sequence\n  of states generated by the \\<open>StateTransfFunN\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"F: n \\<rightarrow> (X\\<rightarrow>X)\" and A3: \"x\\<in>X\" and \n  A4: \"b = StatesSeq(x,X,F,n)\"\n  ",
        "using": [
            "state_trans_fun",
            "empty_in_every_succ",
            "StatesSeq_def",
            "apply_funtype",
            "StateTransfFunN_def",
            "StateTransfFunNMeta_def"
        ],
        "statement": "lemma states_seq_props:\n  assumes A1: \"n \\<in> nat\" and A2: \"F: n \\<rightarrow> (X\\<rightarrow>X)\" and A3: \"x\\<in>X\" and \n  A4: \"b = StatesSeq(x,X,F,n)\"\n  shows\n  \"b : succ(n) \\<rightarrow> X\\<times>succ(n)\"\n  \"b`(0) = \\<langle>x,0\\<rangle>\"\n  \"\\<forall>k \\<in> succ(n). snd(b`(k)) = k\"  \n  \"\\<forall>k\\<in>n. b`(succ(k)) = \\<langle>F`(k)`(fst(b`(k))), succ(k)\\<rangle>\"\n",
        "proof": "proof -\n  let ?f = \"StateTransfFunN(X,F,n)\"\n  from A1 A2 have I: \"?f : X\\<times>succ(n) \\<rightarrow> X\\<times>succ(n)\"\n    using state_trans_fun by simp\n  moreover from A1 A3 have II: \"\\<langle>x,0\\<rangle> \\<in> X\\<times>succ(n)\"\n    using empty_in_every_succ by simp\n  moreover note A1\n  moreover from A4 have III: \"b = InductiveSequenceN(\\<langle>x,0\\<rangle>,?f,n)\"\n    using StatesSeq_def by simp\n  ultimately show IV: \"b : succ(n) \\<rightarrow> X\\<times>succ(n)\"\n    by (rule fin_indseq_props)\n  from I II A1 III show V: \"b`(0) = \\<langle>x,0\\<rangle>\"\n    by (rule fin_indseq_props)\n  from I II A1 III have VI: \"\\<forall>k\\<in>n. b`(succ(k)) = ?f`(b`(k))\"\n    by (rule fin_indseq_props)\n  { fix k \n    note I\n    moreover\n    assume A5: \"k \\<in> n\" hence \"k \\<in> succ(n)\" by auto\n    with IV have \"b`(k) \\<in>  X\\<times>succ(n)\" using apply_funtype by simp\n    moreover have \"?f = {\\<langle>s, StateTransfFunNMeta(F,n,s)\\<rangle>. s \\<in> X\\<times>succ(n)}\"\n      using StateTransfFunN_def by simp\n    ultimately have \"?f`(b`(k)) =  StateTransfFunNMeta(F,n,b`(k))\"\n      by (rule ZF_fun_from_tot_val)\n  } then have VII: \"\\<forall>k \\<in> n. ?f`(b`(k)) =  StateTransfFunNMeta(F,n,b`(k))\"\n    by simp\n  { fix k assume A5: \"k \\<in> succ(n)\"\n    note A1 A5\n    moreover from V have \" snd(b`(0)) = 0\" by simp\n    moreover from VI VII have \n      \"\\<forall>j\\<in>n. snd(b`(j)) = j \\<longrightarrow> snd(b`(succ(j))) = succ(j)\"\n      using StateTransfFunNMeta_def by auto\n    ultimately have \"snd(b`(k)) = k\" by (rule fin_nat_ind)\n  } then show \"\\<forall>k \\<in> succ(n). snd(b`(k)) = k\" by simp\n  with VI VII show \"\\<forall>k\\<in>n. b`(succ(k)) = \\<langle>F`(k)`(fst(b`(k))), succ(k)\\<rangle>\"\n    using StateTransfFunNMeta_def by auto\nqed  \n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 688
    },
    "627": {
        "type": "theorem",
        "text": "text\\<open>Basic properties of sequences defined by equation $x_{n+1}=f_n (x_n)$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"x\\<in>X\" and A3: \"F: n \\<rightarrow> (X\\<rightarrow>X)\" and \n  A4: \"a = InductiveSeqVarFN(x,X,F,n)\"\n  ",
        "using": [
            "states_seq_props",
            "apply_funtype",
            "InductiveSeqVarFN_def",
            "empty_in_every_succ",
            "succ_ineq"
        ],
        "statement": "theorem fin_indseq_var_f_props: \n  assumes A1: \"n \\<in> nat\" and A2: \"x\\<in>X\" and A3: \"F: n \\<rightarrow> (X\\<rightarrow>X)\" and \n  A4: \"a = InductiveSeqVarFN(x,X,F,n)\"\n  shows\n  \"a: succ(n) \\<rightarrow> X\"\n  \"a`(0) = x\"\n  \"\\<forall>k\\<in>n. a`(succ(k)) = F`(k)`(a`(k))\"\n",
        "proof": "proof -\n  let ?f = \"StateTransfFunN(X,F,n)\"\n  let ?b = \"StatesSeq(x,X,F,n)\"\n  from A1 A2 A3 have \"?b : succ(n) \\<rightarrow> X\\<times>succ(n)\"\n    using states_seq_props by simp\n  then have \"\\<forall>k \\<in> succ(n). ?b`(k) \\<in> X\\<times>succ(n)\"\n    using apply_funtype by simp\n  hence \"\\<forall>k \\<in> succ(n). fst(?b`(k)) \\<in> X\" by auto\n  then have I: \"{\\<langle>k,fst(?b`(k))\\<rangle>. k \\<in> succ(n)} : succ(n) \\<rightarrow> X\"\n    by (rule ZF_fun_from_total)\n  with A4 show II: \"a: succ(n) \\<rightarrow> X\" using InductiveSeqVarFN_def\n    by simp\n  moreover from A1 have \"0 \\<in> succ(n)\" using empty_in_every_succ\n    by simp\n  moreover from A4 have III: \n    \"a = {\\<langle>k,fst(StatesSeq(x,X,F,n)`(k))\\<rangle>. k \\<in> succ(n)}\"\n    using InductiveSeqVarFN_def by simp\n  ultimately have \"a`(0) = fst(?b`(0))\"\n    by (rule ZF_fun_from_tot_val)\n  with A1 A2 A3 show \"a`(0) = x\" using states_seq_props by auto\n  { fix k\n    assume A5: \"k \\<in> n\"\n    with A1 have T1: \"succ(k) \\<in> succ(n)\" and T2: \"k \\<in> succ(n)\"\n      using succ_ineq by auto\n    from II T1 III have \"a`(succ(k)) = fst(?b`(succ(k)))\"\n      by (rule ZF_fun_from_tot_val)\n    with A1 A2 A3 A5 have \"a`(succ(k)) = F`(k)`(fst(?b`(k)))\"\n      using states_seq_props by simp\n    moreover from II T2 III have \"a`(k) = fst(?b`(k))\"\n      by (rule ZF_fun_from_tot_val)\n    ultimately have \"a`(succ(k)) =  F`(k)`(a`(k))\"\n      by simp\n  } then show \"\\<forall>k\\<in>n. a`(succ(k)) = F`(k)`(a`(k))\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 689
    },
    "628": {
        "type": "lemma",
        "text": "text\\<open>Uniqueness lemma for sequences generated by equation $x_{n+1}=f_n (x_n)$:\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>X\" \"F: n \\<rightarrow> (X\\<rightarrow>X)\"\n  and \"a: succ(n) \\<rightarrow> X\" \"a`(0) = x\" \"\\<forall>k\\<in>n. a`(succ(k)) = (F`(k))`(a`(k))\"\n  and \"b: succ(n) \\<rightarrow> X\" \"b`(0) = x\" \"\\<forall>k\\<in>n. b`(succ(k)) = (F`(k))`(b`(k))\"\n  ",
        "using": [
            "empty_in_every_succ",
            "succ_ineq",
            "mem_succ_not_eq",
            "Nat_ZF_1_L3",
            "succ_mem",
            "succ_explained"
        ],
        "statement": "lemma fin_indseq_var_f_uniq: assumes \"n\\<in>nat\" \"x\\<in>X\" \"F: n \\<rightarrow> (X\\<rightarrow>X)\"\n  and \"a: succ(n) \\<rightarrow> X\" \"a`(0) = x\" \"\\<forall>k\\<in>n. a`(succ(k)) = (F`(k))`(a`(k))\"\n  and \"b: succ(n) \\<rightarrow> X\" \"b`(0) = x\" \"\\<forall>k\\<in>n. b`(succ(k)) = (F`(k))`(b`(k))\"\n  shows \"a=b\"\n",
        "proof": "proof -\n  have \"\\<forall>k\\<in>succ(n). a`(k) = b`(k)\"\n  proof -\n    let ?A = \"{i\\<in>succ(succ(n)). \\<forall>k\\<in>i.  a`(k) = b`(k)}\"\n    let ?m = \"Maximum(Le,?A)\"\n    from assms(1) have I: \"succ(succ(n)) \\<in> nat\" \"?A\\<subseteq>succ(succ(n))\" by auto\n    moreover \n    from assms(1,5,8) have \"succ(0) \\<in> ?A\" using empty_in_every_succ succ_ineq\n      by simp\n    hence II: \"?A\\<noteq>0\" by auto\n    ultimately have \"?m\\<in>?A\" by (rule nat_max_props)\n    moreover have \"?m = succ(n)\"\n    proof -\n      { assume \"?m \\<noteq> succ(n)\"\n        from I II have III: \"\\<forall>k\\<in>?A. k \\<le> ?m\" by (rule nat_max_props)\n        have \"succ(?m) \\<in> ?A\"\n        proof -\n          from \\<open>?m \\<noteq> succ(n)\\<close> \\<open>?m\\<in>?A\\<close> have \"?m\\<in>succ(n)\" \n            using mem_succ_not_eq by blast\n          from I II have \"?m \\<in> nat\" by (rule nat_max_props)\n          from \\<open>succ(0) \\<in> ?A\\<close> III have \"succ(0) \\<le> ?m\" by blast\n          hence \"?m \\<noteq> 0\" by auto\n          with \\<open>?m \\<in> nat\\<close> obtain k where \"k\\<in>nat\" \"?m = succ(k)\"\n            using Nat_ZF_1_L3 by auto\n          with assms(1) \\<open>?m\\<in>succ(n)\\<close> have \"k\\<in>n\" using succ_mem by simp\n          with assms(6,9) \\<open>?m = succ(k)\\<close> \\<open>?m\\<in>?A\\<close> \n          have \"a`(?m) = b`(?m)\" using succ_explained by simp\n          with assms(1) \\<open>?m\\<in>?A\\<close> \\<open>?m\\<in>succ(n)\\<close> show \"succ(?m) \\<in> ?A\"\n            using succ_explained succ_ineq by blast\n        qed\n        with III have \"succ(?m) \\<le> ?m\" by (rule property_holds)\n        hence False by auto\n      } thus ?thesis by auto\n    qed \n    ultimately show ?thesis by simp\n  qed\n  with assms(4,7) show \"a=b\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 690
    },
    "629": {
        "type": "theorem",
        "text": "text\\<open>A sequence that has the properties of sequences generated by equation $x_{n+1}=f_n (x_n)$\n  must be the one generated by this equation.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>X\" \"F: n \\<rightarrow> (X\\<rightarrow>X)\"\n  and \"a: succ(n) \\<rightarrow> X\" \"a`(0) = x\" \"\\<forall>k\\<in>n. a`(succ(k)) = (F`(k))`(a`(k))\"\n",
        "using": [
            "fin_indseq_var_f_props"
        ],
        "statement": "theorem is_fin_indseq_var_f:  assumes \"n\\<in>nat\" \"x\\<in>X\" \"F: n \\<rightarrow> (X\\<rightarrow>X)\"\n  and \"a: succ(n) \\<rightarrow> X\" \"a`(0) = x\" \"\\<forall>k\\<in>n. a`(succ(k)) = (F`(k))`(a`(k))\"\nshows \"a = InductiveSeqVarFN(x,X,F,n)\"\n",
        "proof": "proof -\n  let ?b = \"InductiveSeqVarFN(x,X,F,n)\"\n  from assms(1,2,3) have \"?b: succ(n) \\<rightarrow> X\"  \"?b`(0) = x\" \n    and \"\\<forall>k\\<in>n. ?b`(succ(k)) = F`(k)`(?b`(k))\"\n    using fin_indseq_var_f_props by simp_all\n  with assms show ?thesis by (rule fin_indseq_var_f_uniq)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 691
    },
    "630": {
        "type": "lemma",
        "text": "text\\<open>A consistency condition: if we make the sequence of \n  generating functions shorter, then we get a shorter inductive \n  sequence with the same values as in the original sequence.\\<close>\n",
        "assumes": "assumes \n  A1: \"n \\<in> nat\"  \"i \\<in> nat\"  \"x\\<in>X\"  \"F: n \\<rightarrow> (X\\<rightarrow>X)\"   \"G: i \\<rightarrow> (X\\<rightarrow>X)\"\n  and A2: \"i \\<subseteq> n\" and  A3: \"\\<forall>j\\<in>i. G`(j) = F`(j)\" and A4: \"k \\<in> succ(i)\"\n  ",
        "using": [
            "fin_indseq_var_f_props"
        ],
        "statement": "lemma fin_indseq_var_f_restrict: assumes \n  A1: \"n \\<in> nat\"  \"i \\<in> nat\"  \"x\\<in>X\"  \"F: n \\<rightarrow> (X\\<rightarrow>X)\"   \"G: i \\<rightarrow> (X\\<rightarrow>X)\"\n  and A2: \"i \\<subseteq> n\" and  A3: \"\\<forall>j\\<in>i. G`(j) = F`(j)\" and A4: \"k \\<in> succ(i)\"\n  shows \"InductiveSeqVarFN(x,X,G,i)`(k) = InductiveSeqVarFN(x,X,F,n)`(k)\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSeqVarFN(x,X,F,n)\"\n  let ?b = \"InductiveSeqVarFN(x,X,G,i)\"\n  from A1 A4 have \"i \\<in> nat\"  \"k \\<in> succ(i)\" by auto\n  moreover from A1 have \"?b`(0) = ?a`(0)\"\n    using fin_indseq_var_f_props by simp\n  moreover from A1 A2 A3 have\n    \"\\<forall>j\\<in>i. ?b`(j) = ?a`(j) \\<longrightarrow> ?b`(succ(j)) = ?a`(succ(j))\"\n    using fin_indseq_var_f_props by auto\n  ultimately show \"?b`(k) = ?a`(k)\"\n    by (rule fin_nat_ind)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 692
    },
    "631": {
        "type": "definition",
        "text": "text\\<open>To shorten the definition of the function generating the Pascal's trangle we first\n  define expression for the k'th element in the row following given row $r$. \n  The rows are represented as lists, i.e. functions $r:n\\rightarrow \\mathbb{N}$ (recall that\n  for natural numbers we have $n=\\{ 0,1,2,...,n-1\\})$.\n  The value of the next row is 1 at the beginning and equals $r(k-1)+r(k)$ \n  otherwise. A careful reader might wonder why we do not require the values to be 1\n  on the right boundary of the Pascal's triangle. We are able to show this as a theorem \n  (see \\<open>binom_right_boundary\\<close> below) using the fact that in Isabelle/ZF the value of a function\n  on an argument that is outside of the domain is the empty set, which is the same as zero of \n  natural numbers. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"BinomElem(r,k) \\<equiv> if k=0 then 1 else r`(pred(k)) #+ r`(k)\"  \n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 693
    },
    "632": {
        "type": "definition",
        "text": "text\\<open>Next we define a function that takes a row in a Pascal's triangle and returns the next row. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"GenBinom \\<equiv> {\\<langle>r,{\\<langle>k,BinomElem(r,k)\\<rangle>. k\\<in>succ(domain(r))}\\<rangle>. r\\<in>NELists(nat)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 694
    },
    "633": {
        "type": "lemma",
        "text": "text\\<open>The value of the function \\<open>GenBinom\\<close> at a nonempty list $r$ is a list of length\n  one greater than the length of $r$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"r:succ(n)\\<rightarrow>nat\"\n  ",
        "using": [
            "ZF_fun_from_tot_val1",
            "func1_1_L1",
            "GenBinom_def"
        ],
        "statement": "lemma gen_binom_fun_val: assumes \"n\\<in>nat\" \"r:succ(n)\\<rightarrow>nat\"\n  shows \"GenBinom`(r):succ(succ(n)) \\<rightarrow> nat\"\n",
        "proof": "proof -\n  let ?B = \"{\\<langle>r,{\\<langle>k,BinomElem(r,k)\\<rangle>. k\\<in>succ(domain(r))}\\<rangle>. r\\<in>NELists(nat)}\"\n  let ?r\\<^sub>1 = \"{\\<langle>k,BinomElem(r,k)\\<rangle>. k\\<in>succ(domain(r))}\"\n  from assms have \"r\\<in>NELists(nat)\" unfolding NELists_def by blast\n  then have \"?B`(r) = ?r\\<^sub>1\" using ZF_fun_from_tot_val1 by simp\n  have \"\\<forall>k\\<in>succ(domain(r)). BinomElem(r,k) \\<in> nat\"\n    unfolding BinomElem_def by simp\n  then have \"?r\\<^sub>1: succ(domain(r))\\<rightarrow>nat\"\n    by (rule ZF_fun_from_total)\n  with assms(2) \\<open>?B`(r) = ?r\\<^sub>1\\<close> show ?thesis\n    using func1_1_L1 unfolding GenBinom_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 696
    },
    "634": {
        "type": "definition",
        "text": "text\\<open>Now we are ready to define the Pascal's triangle as the inductive sequence that\n  starts from a singleton list $0\\mapsto 1$ and is generated by iterations of the \n  \\<open>GenBinom\\<close> function. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"PascalTriangle \\<equiv> InductiveSequence({\\<langle>0,1\\<rangle>},GenBinom)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 697
    },
    "635": {
        "type": "lemma",
        "text": "text\\<open>The singleton list containing 1 (i.e. the starting point of the inductive sequence \n  that defines the \\<open>PascalTriangle\\<close>) is a finite list and \n  the \\<open>PascalTriangle\\<close> is a sequence (an infinite list) of nonempty lists of natural numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "list_len1_singleton(2)",
            "gen_binom_fun",
            "indseq_seq",
            "PascalTriangle_def"
        ],
        "statement": "lemma pascal_sequence: \n  shows \"{\\<langle>0,1\\<rangle>} \\<in> NELists(nat)\" and \"PascalTriangle: nat \\<rightarrow> NELists(nat)\"\n  ",
        "proof": "using list_len1_singleton(2) gen_binom_fun indseq_seq\n  unfolding PascalTriangle_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 698
    },
    "636": {
        "type": "lemma",
        "text": "text\\<open>The \\<open>GenBinom\\<close> function creates the next row of the Pascal's triangle\n  from the previous one. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\"\n  ",
        "using": [
            "assms",
            "pascal_sequence",
            "gen_binom_fun",
            "indseq_vals",
            "PascalTriangle_def"
        ],
        "statement": "lemma binom_gen: assumes \"n\\<in>nat\"\n  shows \"PascalTriangle`(succ(n)) = GenBinom`(PascalTriangle`(n))\"\n  ",
        "proof": "using assms pascal_sequence gen_binom_fun indseq_vals\n  unfolding PascalTriangle_def by simp\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 699
    },
    "637": {
        "type": "lemma",
        "text": "text\\<open>The $n$'th row of the Pascal's triangle is a list of $n+1$ natural numbers. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" ",
        "using": [
            "gen_binom_fun",
            "pascal_sequence(1)",
            "indseq_valat0",
            "list_len1_singleton(1)",
            "PascalTriangle_def",
            "gen_binom_fun_val",
            "indseq_vals",
            "NELists_def"
        ],
        "statement": "lemma pascal_row_list: \n  assumes \"n\\<in>nat\" shows \"PascalTriangle`(n):succ(n)\\<rightarrow>nat\"\n",
        "proof": "proof -\n  from assms(1) have \"n\\<in>nat\" and \"PascalTriangle`(0):succ(0)\\<rightarrow>nat\"\n    using gen_binom_fun pascal_sequence(1) indseq_valat0 list_len1_singleton(1)\n    unfolding PascalTriangle_def by auto\n  moreover have \n    \"\\<forall>k\\<in>nat. PascalTriangle`(k):succ(k)\\<rightarrow>nat \\<longrightarrow> \n      PascalTriangle`(succ(k)):succ(succ(k))\\<rightarrow>nat\"\n  proof -\n    { fix k assume \"k\\<in>nat\" and \"PascalTriangle`(k):succ(k)\\<rightarrow>nat\"\n      then have \"PascalTriangle`(succ(k)):succ(succ(k))\\<rightarrow>nat\"\n        using gen_binom_fun_val gen_binom_fun pascal_sequence(1) indseq_vals \n        unfolding NELists_def PascalTriangle_def\n        by auto        \n    } thus ?thesis by simp\n  qed\n  ultimately show ?thesis by (rule ind_on_nat)\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 700
    },
    "638": {
        "type": "lemma",
        "text": "text\\<open>In our approach the Pascal's triangle is a list of lists. The value\n  at index $n\\in \\mathbb{N}$ is a list of length $n+1$ (see \\<open>pascal_row_list\\<close> above).\n  Hence, the largest index in the domain of this list is $n$. However,  \n  we can still show that the value of that list at index $n+1$ is 0, because in Isabelle/ZF\n  (as well as in Metamath) the value of a function at a point outside of the domain is the empty\n  set, which happens to be the same as the natural number 0. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \n  ",
        "using": [
            "pascal_row_list",
            "func1_1_L1",
            "mem_self",
            "apply_0"
        ],
        "statement": "lemma pascal_val_beyond: assumes \"n\\<in>nat\" \n  shows \"(PascalTriangle`(n))`(succ(n)) = 0\"\n",
        "proof": "proof -\n  from assms have \"domain(PascalTriangle`(n)) = succ(n)\"\n    using pascal_row_list func1_1_L1 by blast \n  then show ?thesis using mem_self apply_0\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 701
    },
    "639": {
        "type": "lemma",
        "text": "text\\<open>For $n>0$ the Pascal's triangle values at $(n,k)$ are given by the \\<open>BinomElem\\<close> expression. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"k\\<in>succ(succ(n))\"\n  ",
        "using": [
            "pascal_sequence(2)",
            "apply_funtype",
            "pascal_row_list",
            "func1_1_L1",
            "ZF_fun_from_tot_val1",
            "binom_gen",
            "GenBinom_def"
        ],
        "statement": "lemma pascal_row_val: assumes \"n\\<in>nat\" \"k\\<in>succ(succ(n))\"\n  shows \"(PascalTriangle`(succ(n)))`(k) = BinomElem(PascalTriangle`(n),k)\"\n",
        "proof": "proof -\n  let ?B = \"{\\<langle>r,{\\<langle>k,BinomElem(r,k)\\<rangle>. k\\<in>succ(domain(r))}\\<rangle>. r\\<in>NELists(nat)}\"\n  let ?r = \"PascalTriangle`(n)\" \n  let ?B\\<^sub>r = \"{\\<langle>k,BinomElem(?r,k)\\<rangle>. k\\<in>succ(succ(n))}\"\n  from assms(1) have \"?r \\<in> NELists(nat)\" and \"?r : succ(n)\\<rightarrow>nat\"\n    using pascal_sequence(2) apply_funtype pascal_row_list\n    by auto\n  then have \"?B`(?r) = ?B\\<^sub>r\" using func1_1_L1 ZF_fun_from_tot_val1 \n    by simp\n  moreover from assms(1) have \"?B`(?r) = PascalTriangle`(succ(n))\"\n    using binom_gen unfolding GenBinom_def by simp\n  moreover from assms(2) have \"?B\\<^sub>r`(k) = BinomElem(?r,k)\"\n    by (rule ZF_fun_from_tot_val1)\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 702
    },
    "640": {
        "type": "definition",
        "text": "text\\<open>The notion that will actually be used is the binomial coefficient ${n\\choose k}$\n  which we define as the value at the right place of the Pascal's triangle. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Binom(n,k) \\<equiv> (PascalTriangle`(n))`(k)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 703
    },
    "641": {
        "type": "lemma",
        "text": "text\\<open>Entries in the Pascal's triangle are natural numbers. \n  Since in Isabelle/ZF the value of a function at a point \n  that is outside of the domain is the empty set (which is the same as zero of natural numbers) \n  we do not need any assumption on $k$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" ",
        "using": [
            "pascal_row_list",
            "apply_funtype",
            "func1_1_L1",
            "apply_0"
        ],
        "statement": "lemma binom_in_nat: assumes \"n\\<in>nat\" shows \"Binom(n,k) \\<in> nat\"\n",
        "proof": "proof -\n  { assume \"k \\<in> succ(n)\"\n    with assms have \"(PascalTriangle`(n))`(k) \\<in> nat\"\n      using pascal_row_list apply_funtype by blast\n  }\n  moreover\n  { assume \"k \\<notin> succ(n)\"\n    from assms have \"domain(PascalTriangle`(n)) = succ(n)\"\n      using pascal_row_list func1_1_L1 by blast\n    with \\<open>k \\<notin> succ(n)\\<close> have \"(PascalTriangle`(n))`(k) = 0\"\n      using apply_0 by simp\n    hence \"(PascalTriangle`(n))`(k) \\<in> nat\" by simp\n  }\n  ultimately show ?thesis unfolding Binom_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 704
    },
    "642": {
        "type": "lemma",
        "text": "text\\<open>The top of the Pascal's triangle is equal to 1 (i.e. ${0\\choose 0}=1$).\n  This is an easy fact that it is useful to have handy as it  is at the start of a \n  couple of inductive arguments. \\<close>\n",
        "assumes": "",
        "using": [
            "gen_binom_fun",
            "pascal_sequence(1)",
            "indseq_valat0",
            "pair_val",
            "Binom_def",
            "PascalTriangle_def"
        ],
        "statement": "lemma binom_zero_zero: shows \"Binom(0,0) = 1\"\n  ",
        "proof": "using gen_binom_fun pascal_sequence(1) indseq_valat0 pair_val\n    unfolding Binom_def PascalTriangle_def by auto\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 705
    },
    "643": {
        "type": "theorem",
        "text": "text\\<open>The binomial coefficients are 1 on the left boundary of the Pascal's triangle.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" ",
        "using": [
            "Nat_ZF_1_L3",
            "empty_in_every_succ",
            "pascal_row_val",
            "BinomElem_def",
            "Binom_def",
            "binom_zero_zero"
        ],
        "statement": "theorem binom_left_boundary: assumes \"n\\<in>nat\" shows \"Binom(n,0) = 1\"\n",
        "proof": "proof -\n  { assume \"n\\<noteq>0\"\n    with assms obtain k where \"k\\<in>nat\" and \"n = succ(k)\"\n      using Nat_ZF_1_L3 by blast\n    then have \"Binom(n,0) = 1\" using empty_in_every_succ pascal_row_val\n      unfolding BinomElem_def Binom_def by simp    \n  }\n  then show ?thesis using binom_zero_zero by blast\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 706
    },
    "644": {
        "type": "theorem",
        "text": "text\\<open>The main recursive property of binomial coefficients: \n  each number in the ${n\\choose k}$, $n>0, 0\\neq k\\leq n$ array \n  (i.e. the Pascal's triangle except the top) \n  is the sum of the two numbers directly  above it. The statement looks like it has an \n  off-by-one error in the assumptions, but it's ok and needed later. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"k \\<le> n #+ 1\" \"k\\<noteq>0\"\n  ",
        "using": [
            "le_in_nat",
            "nat_mem_lt(2)",
            "pascal_row_val",
            "pred_minus_one"
        ],
        "statement": "theorem binom_prop: assumes \"n\\<in>nat\" \"k \\<le> n #+ 1\" \"k\\<noteq>0\"\n  shows \"Binom(n #+ 1,k) = Binom(n,k #- 1) #+ Binom(n,k)\"\n",
        "proof": "proof -\n  let ?P = \"PascalTriangle\"\n  from assms(1,2) have \"k\\<in>nat\" and \"k \\<in> succ(succ(n))\"\n    using le_in_nat nat_mem_lt(2) by auto\n  with assms(1) have \"Binom(n #+ 1,k) = BinomElem(?P`(n),k)\"\n    unfolding Binom_def using pascal_row_val by simp\n  also from assms(3) \\<open>k\\<in>nat\\<close> have\n    \"BinomElem(?P`(n),k) = (?P`(n))`(k #- 1) #+ (?P`(n))`(k)\"\n    unfolding BinomElem_def using pred_minus_one by simp\n  also have \"(?P`(n))`(k #- 1) #+ (?P`(n))`(k) =  Binom(n,k #- 1) #+ Binom(n,k)\"\n    unfolding Binom_def by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 707
    },
    "645": {
        "type": "lemma",
        "text": "text\\<open>A version \\<open>binom_prop\\<close> where we write $k+1$ instead of $k$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"k \\<in> n #+ 1\"\n  ",
        "using": [
            "elem_nat_is_nat(2)",
            "succ_ineq2",
            "binom_prop"
        ],
        "statement": "lemma binom_prop2: assumes \"n\\<in>nat\" \"k \\<in> n #+ 1\"\n  shows \"Binom(n #+ 1,k #+ 1) = Binom(n,k #+ 1) #+ Binom(n,k)\"\n",
        "proof": "proof -\n  from assms have \"k\\<in>nat\" using elem_nat_is_nat(2) by blast\n  hence \"k #+1 #- 1 = k\" by simp\n  moreover from assms have \n    \"Binom(n #+ 1,k #+ 1) = Binom(n,k #+1 #- 1) #+ Binom(n,k #+ 1)\"\n    using succ_ineq2 binom_prop by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 708
    },
    "646": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>binom_prop\\<close> when $n=k+1$ that helps \n  with the induction step in the proof that the binomial coefficient \n  are 1 on the right boundary of the Pascal's triangle.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \n  ",
        "using": [
            "pascal_row_list",
            "apply_funtype",
            "Binom_def",
            "pascal_val_beyond",
            "succ_add_one(1)",
            "succ_add_one(2)",
            "binom_prop",
            "add_subctract",
            "add_0",
            "add_commute"
        ],
        "statement": "lemma binom_prop1: assumes \"n\\<in>nat\" \n  shows \"Binom(n #+ 1,n #+ 1) = Binom(n,n)\"\n",
        "proof": "proof -\n  let ?B = \"Binom\"\n  from assms have \"?B(n,n) \\<in> nat\"\n    using pascal_row_list apply_funtype\n    unfolding Binom_def by blast\n  from assms have \"(PascalTriangle`(n))`(succ(n)) = 0\"\n    using pascal_val_beyond by simp\n  moreover from assms have \"succ(n) = n #+ 1\"\n    using succ_add_one(1) by simp\n  ultimately have \"?B(n,n #+ 1) = 0\"\n    unfolding Binom_def by simp\n  with assms \\<open>?B(n,n) \\<in> nat\\<close> show ?thesis\n    using succ_add_one(2) binom_prop add_subctract add_0 add_commute\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 709
    },
    "647": {
        "type": "theorem",
        "text": "text\\<open>The binomial coefficients are 1 on the right boundary of the Pascal's triangle.\\<close> \n",
        "assumes": "assumes \"n\\<in>nat\" ",
        "using": [
            "binom_zero_zero",
            "binom_prop1"
        ],
        "statement": "theorem binom_right_boundary: assumes \"n\\<in>nat\" shows \"Binom(n,n) = 1\"\n",
        "proof": "proof -\n  from assms have \"n\\<in>nat\" and \"Binom(0,0) = 1\"\n    using binom_zero_zero by auto\n  moreover have \n    \"\\<forall>k\\<in>nat. Binom(k,k) = 1 \\<longrightarrow> Binom(succ(k),succ(k)) = 1\"\n    using binom_prop1 by simp\n  ultimately show ?thesis by (rule ind_on_nat)  \nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 710
    },
    "648": {
        "type": "lemma",
        "text": "text\\<open>If $n$ is greater than $0$ then \\<open>m zmod n\\<close> is between $0$ and $n-1$.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" and A2: \"\\<zero>\\<lsq>n\"  \"n\\<noteq>\\<zero>\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_2_L9",
            "Int_ZF_1_L8",
            "pos_mod",
            "Int_ZF_1_L8A",
            "zmod_type",
            "Int_ZF_2_L1",
            "Int_ZF_2_L9AA",
            "Int_ZF_4_L1B"
        ],
        "statement": "lemma (in int0) IntDiv_ZF_1_L2: \n  assumes A1: \"m\\<in>\\<int>\" and A2: \"\\<zero>\\<lsq>n\"  \"n\\<noteq>\\<zero>\"\n  shows \n  \"\\<zero> \\<lsq> m zmod n\"  \n  \"m zmod n \\<lsq> n\"    \"m zmod n \\<noteq> n\" \n  \"m zmod n \\<lsq> n\\<rs>\\<one>\"\n",
        "proof": "proof -\n  from A2 have T: \"n \\<in> \\<int>\"\n    using Int_ZF_2_L1A by simp\n  from A2 have \"#0 $< n\" using Int_ZF_2_L9 Int_ZF_1_L8 \n    by auto\n  with T show \n    \"\\<zero> \\<lsq> m zmod n\"  \n    \"m zmod n \\<lsq> n\"  \n    \"m zmod n \\<noteq> n\" \n    using pos_mod Int_ZF_1_L8 Int_ZF_1_L8A zmod_type \n      Int_ZF_2_L1 Int_ZF_2_L9AA \n    by auto\n  then show \"m zmod n \\<lsq> n\\<rs>\\<one>\"\n    using Int_ZF_4_L1B by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_1",
            "ZF.IntDiv"
        ],
        "source": "IsarMathLib/IntDiv_ZF_IML.thy",
        "id": 712
    },
    "649": {
        "type": "lemma",
        "text": "text\\<open>$(m\\cdot k)$ div $k = m$.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"  and \"k\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "zdiv_zmult_self1",
            "zdiv_zmult_self2",
            "Int_ZF_1_L8",
            "Int_ZF_1_L2"
        ],
        "statement": "lemma (in int0) IntDiv_ZF_1_L3: \n  assumes \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"  and \"k\\<noteq>\\<zero>\"\n  shows \n  \"(m\\<cdot>k) zdiv k = m\"\n  \"(k\\<cdot>m) zdiv k = m\"\n  ",
        "proof": "using assms zdiv_zmult_self1 zdiv_zmult_self2 \n    Int_ZF_1_L8 Int_ZF_1_L2 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_1",
            "ZF.IntDiv"
        ],
        "source": "IsarMathLib/IntDiv_ZF_IML.thy",
        "id": 713
    },
    "650": {
        "type": "lemma",
        "text": "text\\<open>The next lemma essentially translates \\<open>zdiv_mono1\\<close> from \n  standard Isabelle to our notation.\\<close>\n",
        "assumes": "assumes A1: \"m \\<lsq> k\" and A2: \"\\<zero>\\<lsq>n\"  \"n\\<noteq>\\<zero>\"\n  ",
        "using": [
            "Int_ZF_1_L8",
            "Int_ZF_2_L1A",
            "Int_ZF_2_L9",
            "zdiv_mono1",
            "Int_ZF_2_L1"
        ],
        "statement": "lemma (in int0) IntDiv_ZF_1_L4: \n  assumes A1: \"m \\<lsq> k\" and A2: \"\\<zero>\\<lsq>n\"  \"n\\<noteq>\\<zero>\"\n  shows \"m zdiv n \\<lsq>  k zdiv n\"\n",
        "proof": "proof -\n  from A2 have \"#0 \\<lsq> n\"  \"#0 \\<noteq> n\"\n    using Int_ZF_1_L8 by auto\n  with A1 have \n    \"m zdiv n $\\<le> k zdiv n\"\n    \"m zdiv n \\<in> \\<int>\"    \"m zdiv k \\<in> \\<int>\"\n    using Int_ZF_2_L1A Int_ZF_2_L9 zdiv_mono1\n    by auto\n  then show \"(m zdiv n) \\<lsq> (k zdiv n)\"\n    using Int_ZF_2_L1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_1",
            "ZF.IntDiv"
        ],
        "source": "IsarMathLib/IntDiv_ZF_IML.thy",
        "id": 714
    },
    "651": {
        "type": "lemma",
        "text": "text\\<open>A quotient-reminder theorem about integers greater than a given \n  product.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<int>\\<^sub>+\" and A2: \"n \\<lsq> k\" and A3: \"k\\<cdot>n \\<lsq> m\" \n  ",
        "using": [
            "Int_ZF_2_L1A",
            "IntDiv_ZF_1_L1",
            "Int_ZF_1_L4",
            "PositiveSet_def",
            "IntDiv_ZF_1_L2",
            "Order_ZF_2_L1",
            "IntDiv_ZF_1_L4",
            "IntDiv_ZF_1_L3",
            "Int_ZF_1_5_L7"
        ],
        "statement": "lemma (in int0) IntDiv_ZF_1_L5:\n  assumes A1: \"n \\<in> \\<int>\\<^sub>+\" and A2: \"n \\<lsq> k\" and A3: \"k\\<cdot>n \\<lsq> m\" \n  shows \n  \"m = n\\<cdot>(m zdiv n) \\<ra> (m zmod n)\"\n  \"m = (m zdiv n)\\<cdot>n \\<ra> (m zmod n)\"\n  \"(m zmod n) \\<in> \\<zero>..(n\\<rs>\\<one>)\"\n  \"k \\<lsq> (m zdiv n)\"  \n  \"m zdiv n \\<in> \\<int>\\<^sub>+\"\n",
        "proof": "proof -\n  from A2 A3 have T: \n    \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"  \"m zdiv n \\<in> \\<int>\"  \n    using Int_ZF_2_L1A by auto\n   then show \"m = n\\<cdot>(m zdiv n) \\<ra> (m zmod n)\"\n     using IntDiv_ZF_1_L1 by simp\n   with T show \"m = (m zdiv n)\\<cdot>n \\<ra> (m zmod n)\"\n     using Int_ZF_1_L4 by simp\n    from A1 have I: \"\\<zero>\\<lsq>n\"  \"n\\<noteq>\\<zero>\"\n     using PositiveSet_def by auto\n   with T show \"(m zmod n) \\<in> \\<zero>..(n\\<rs>\\<one>)\"\n    using IntDiv_ZF_1_L2 Order_ZF_2_L1\n    by simp\n  from A3 I have \"(k\\<cdot>n zdiv n) \\<lsq> (m zdiv n)\"\n    using IntDiv_ZF_1_L4 by simp\n  with I T show \"k \\<lsq> (m zdiv n)\"\n    using IntDiv_ZF_1_L3 by simp\n  with A1 A2 show \"m zdiv n \\<in> \\<int>\\<^sub>+\"\n    using Int_ZF_1_5_L7 by blast\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_1",
            "ZF.IntDiv"
        ],
        "source": "IsarMathLib/IntDiv_ZF_IML.thy",
        "id": 715
    },
    "652": {
        "type": "lemma",
        "text": "text\\<open>Integers form a commutative ring, hence we can use theorems proven \n  in \\<open>ring0\\<close> context (locale).\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_1_L1",
            "IsDistributive_def",
            "Int_ZF_1_T1",
            "Int_ZF_1_T2",
            "IsAring_def",
            "ring0_def",
            "Int_ZF_1_L4",
            "IsCommutative_def"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L2: shows\n  \"IsAring(\\<int>,IntegerAddition,IntegerMultiplication)\"\n  \"IntegerMultiplication {is commutative on} \\<int>\"\n  \"ring0(\\<int>,IntegerAddition,IntegerMultiplication)\"\n",
        "proof": "proof -\n  have \"\\<forall>a\\<in>\\<int>.\\<forall>b\\<in>\\<int>.\\<forall>c\\<in>\\<int>. \n    a\\<cdot>(b\\<ra>c) = a\\<cdot>b \\<ra> a\\<cdot>c \\<and> (b\\<ra>c)\\<cdot>a = b\\<cdot>a \\<ra> c\\<cdot>a\"\n    using Int_ZF_1_1_L1 by simp\n  then have \"IsDistributive(\\<int>,IntegerAddition,IntegerMultiplication)\"\n    using IsDistributive_def by simp\n  then show \"IsAring(\\<int>,IntegerAddition,IntegerMultiplication)\"\n    \"ring0(\\<int>,IntegerAddition,IntegerMultiplication)\"\n    using Int_ZF_1_T1 Int_ZF_1_T2 IsAring_def ring0_def \n    by auto\n  have \"\\<forall>a\\<in>\\<int>.\\<forall>b\\<in>\\<int>. a\\<cdot>b = b\\<cdot>a\" using Int_ZF_1_L4 by simp\n  then show \"IntegerMultiplication {is commutative on} \\<int>\"\n    using IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 717
    },
    "653": {
        "type": "lemma",
        "text": "text\\<open>Zero and one are integers.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L2"
        ],
        "statement": "lemma (in int0) int_zero_one_are_int: shows \"\\<zero>\\<in>\\<int>\"  \"\\<one>\\<in>\\<int>\"\n  ",
        "proof": "using Int_ZF_1_1_L2 ring0.Ring_ZF_1_L2 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 718
    },
    "654": {
        "type": "lemma",
        "text": "text\\<open>Negative of zero is zero.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_T2",
            "group0.group_inv_of_one"
        ],
        "statement": "lemma (in int0) int_zero_one_are_intA: shows \"(\\<rm>\\<zero>) = \\<zero>\"\n  ",
        "proof": "using Int_ZF_1_T2 group0.group_inv_of_one by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 719
    },
    "655": {
        "type": "lemma",
        "text": "text\\<open>Properties with one integer.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L3",
            "ring0.Ring_ZF_1_L6"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L4: assumes A1: \"a \\<in> \\<int>\"\n  shows \n  \"a\\<ra>\\<zero> = a\" \n  \"\\<zero>\\<ra>a = a\" \n  \"a\\<cdot>\\<one> = a\"   \"\\<one>\\<cdot>a = a\"\n  \"\\<zero>\\<cdot>a = \\<zero>\"   \"a\\<cdot>\\<zero> = \\<zero>\" \n  \"(\\<rm>a) \\<in> \\<int>\"  \"(\\<rm>(\\<rm>a)) = a\"\n  \"a\\<rs>a = \\<zero>\"   \"a\\<rs>\\<zero> = a\"  \"\\<two>\\<cdot>a = a\\<ra>a\"\n",
        "proof": "proof -\n  from A1 show \n    \"a\\<ra>\\<zero> = a\"   \"\\<zero>\\<ra>a = a\"   \"a\\<cdot>\\<one> = a\" \n    \"\\<one>\\<cdot>a = a\"   \"a\\<rs>a = \\<zero>\"   \"a\\<rs>\\<zero> = a\"  \n    \"(\\<rm>a) \\<in> \\<int>\"  \"\\<two>\\<cdot>a = a\\<ra>a\"   \"(\\<rm>(\\<rm>a)) = a\"\n    using Int_ZF_1_1_L2 ring0.Ring_ZF_1_L3 by auto\n  from A1 show \"\\<zero>\\<cdot>a = \\<zero>\"   \"a\\<cdot>\\<zero> = \\<zero>\"\n    using Int_ZF_1_1_L2 ring0.Ring_ZF_1_L6 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 720
    },
    "656": {
        "type": "lemma",
        "text": "text\\<open>$2$ and $3$ are integers.\\<close>\n",
        "assumes": "",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int0) int_two_three_are_int: shows \"\\<two> \\<in> \\<int>\"  \"\\<three> \\<in> \\<int>\"\n    ",
        "proof": "using int_zero_one_are_int Int_ZF_1_1_L5 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 722
    },
    "657": {
        "type": "lemma",
        "text": "text\\<open>Another property with two integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L9"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L5B:\n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \"a\\<rs>(\\<rm>b) = a\\<ra>b\"\n  ",
        "proof": "using assms Int_ZF_1_1_L2 ring0.Ring_ZF_1_L9\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 723
    },
    "658": {
        "type": "lemma",
        "text": "text\\<open>Properties that require three integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L10",
            "ring0.Ring_ZF_1_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L6: assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \n  \"a\\<rs>(b\\<ra>c) = a\\<rs>b\\<rs>c\"\n  \"a\\<rs>(b\\<rs>c) = a\\<rs>b\\<ra>c\"\n  \"a\\<cdot>(b\\<rs>c) = a\\<cdot>b \\<rs> a\\<cdot>c\"\n  \"(b\\<rs>c)\\<cdot>a = b\\<cdot>a \\<rs> c\\<cdot>a\"\n  ",
        "proof": "using assms Int_ZF_1_1_L2 ring0.Ring_ZF_1_L10  ring0.Ring_ZF_1_L8 \n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 724
    },
    "659": {
        "type": "lemma",
        "text": "text\\<open>One more property with three integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L10A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L6A: assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \"a\\<ra>(b\\<rs>c) = a\\<ra>b\\<rs>c\"\n  ",
        "proof": "using assms Int_ZF_1_1_L2 ring0.Ring_ZF_1_L10A by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 725
    },
    "660": {
        "type": "lemma",
        "text": "text\\<open>Associativity of addition and multiplication.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\" \"b\\<in>\\<int>\" \"c\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L11"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L7: assumes \"a\\<in>\\<int>\" \"b\\<in>\\<int>\" \"c\\<in>\\<int>\"\n  shows \n  \"a\\<ra>b\\<ra>c = a\\<ra>(b\\<ra>c)\"\n  \"a\\<cdot>b\\<cdot>c = a\\<cdot>(b\\<cdot>c)\"\n  ",
        "proof": "using assms Int_ZF_1_1_L2 ring0.Ring_ZF_1_L11 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 726
    },
    "661": {
        "type": "lemma",
        "text": "text\\<open>A formula with a positive integer.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_L16",
            "Int_ZF_2_L12A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L1: assumes \"\\<zero>\\<lsq>a\"\n  shows \"abs(a)\\<ra>\\<one> = abs(a\\<ra>\\<one>)\"\n  ",
        "proof": "using assms Int_ZF_2_L16 Int_ZF_2_L12A by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 727
    },
    "662": {
        "type": "lemma",
        "text": "text\\<open>A formula with two integers, one positive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\" and A2: \"\\<zero>\\<lsq>b\"\n  ",
        "using": [
            "Int_ZF_2_L12A",
            "Int_ZF_2_L1A",
            "Int_ZF_2_L14",
            "Int_ZF_1_2_L1",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_2_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L2: assumes A1: \"a\\<in>\\<int>\" and A2: \"\\<zero>\\<lsq>b\"\n  shows \"a\\<ra>(abs(b)\\<ra>\\<one>)\\<cdot>a = (abs(b\\<ra>\\<one>)\\<ra>\\<one>)\\<cdot>a\"\n",
        "proof": "proof -\n  from A2 have \"abs(b\\<ra>\\<one>) \\<in> \\<int>\"\n    using Int_ZF_2_L12A Int_ZF_2_L1A Int_ZF_2_L14 by blast\n  with A1 A2 show ?thesis \n    using Int_ZF_1_2_L1 Int_ZF_1_1_L2 ring0.Ring_ZF_2_L1 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 728
    },
    "663": {
        "type": "lemma",
        "text": "text\\<open>A couple of formulae about canceling opposite integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "group0.group0_4_L6A",
            "group0.inv_cancel_two",
            "group0.group0_2_L16A",
            "group0.group0_4_L6AA",
            "group0.group0_4_L6AB",
            "group0.group0_4_L6F",
            "group0.group0_4_L6AC"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L3: assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \n  \"a\\<ra>b\\<rs>a = b\"\n  \"a\\<ra>(b\\<rs>a) = b\"\n  \"a\\<ra>b\\<rs>b = a\" \n  \"a\\<rs>b\\<ra>b = a\"\n  \"(\\<rm>a)\\<ra>(a\\<ra>b) = b\"\n  \"a\\<ra>(b\\<rs>a) = b\"\n  \"(\\<rm>b)\\<ra>(a\\<ra>b) = a\"\n  \"a\\<rs>(b\\<ra>a) = \\<rm>b\"\n  \"a\\<rs>(a\\<ra>b) = \\<rm>b\"\n  \"a\\<rs>(a\\<rs>b) = b\"\n  \"a\\<rs>b\\<rs>a =  \\<rm>b\"\n  \"a\\<rs>b \\<rs> (a\\<ra>b) = (\\<rm>b)\\<rs>b\"\n  ",
        "proof": "using assms Int_ZF_1_T2 group0.group0_4_L6A group0.inv_cancel_two\n    group0.group0_2_L16A group0.group0_4_L6AA group0.group0_4_L6AB\n    group0.group0_4_L6F group0.group0_4_L6AC by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 729
    },
    "664": {
        "type": "lemma",
        "text": "text\\<open>Subtracting one does not increase integers. This may be moved to a theory\n  about ordered rings one day.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "int_zero_one_are_int",
            "Int_ZF_1_2_L3",
            "Int_ZF_2_L12A",
            "Int_ZF_1_1_L4",
            "int_ord_transl_inv"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L3A: assumes A1: \"a\\<lsq>b\"\n  shows \"a\\<rs>\\<one> \\<lsq> b\" \n",
        "proof": "proof -\n  from A1 have \"b\\<ra>\\<one>\\<rs>\\<one> = b\"\n    using Int_ZF_2_L1A int_zero_one_are_int Int_ZF_1_2_L3 by simp\n  moreover from A1 have \"a\\<rs>\\<one> \\<lsq> b\\<ra>\\<one>\\<rs>\\<one>\"\n    using Int_ZF_2_L12A int_zero_one_are_int Int_ZF_1_1_L4 int_ord_transl_inv\n    by simp\n  ultimately show \"a\\<rs>\\<one> \\<lsq> b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 730
    },
    "665": {
        "type": "lemma",
        "text": "text\\<open>Subtracting one does not increase integers, special case.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\" ",
        "using": [
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_1_2_L3A",
            "Int_ZF_1_L14",
            "Int_ZF_2_L19AA",
            "int_zero_one_are_int",
            "Int_ZF_2_L9B",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L3AA: \n  assumes A1: \"a\\<in>\\<int>\" shows \n  \"a\\<rs>\\<one> \\<lsq>a\"\n  \"a\\<rs>\\<one> \\<noteq> a\"\n  \"\\<not>(a\\<lsq>a\\<rs>\\<one>)\"\n  \"\\<not>(a\\<ra>\\<one> \\<lsq>a)\"\n  \"\\<not>(\\<one>\\<ra>a \\<lsq>a)\"\n",
        "proof": "proof -\n  from A1 have \"a\\<lsq>a\" using int_ord_is_refl refl_def\n    by simp\n  then show \"a\\<rs>\\<one> \\<lsq>a\" using Int_ZF_1_2_L3A\n    by simp\n  moreover from A1 show \"a\\<rs>\\<one> \\<noteq> a\" using Int_ZF_1_L14 by simp\n  ultimately show I: \"\\<not>(a\\<lsq>a\\<rs>\\<one>)\" using Int_ZF_2_L19AA\n    by blast\n  with A1 show \"\\<not>(a\\<ra>\\<one> \\<lsq>a)\"\n    using int_zero_one_are_int Int_ZF_2_L9B by simp\n  with A1 show \"\\<not>(\\<one>\\<ra>a \\<lsq>a)\" \n    using int_zero_one_are_int Int_ZF_1_1_L5 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 731
    },
    "666": {
        "type": "lemma",
        "text": "text\\<open>A formula with a nonpositive integer.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "int_zero_one_are_int",
            "Int_ZF_1_2_L3A",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L3A",
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L4: assumes \"a\\<lsq>\\<zero>\"\n  shows \"abs(a)\\<ra>\\<one> = abs(a\\<rs>\\<one>)\"\n  ",
        "proof": "using assms int_zero_one_are_int Int_ZF_1_2_L3A Int_ZF_2_T1 \n      group3.OrderedGroup_ZF_3_L3A Int_ZF_2_L1A \n      int_zero_one_are_int Int_ZF_1_1_L5 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 732
    },
    "667": {
        "type": "lemma",
        "text": "text\\<open>A formula with two integers, one negative.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\" and A2: \"b\\<lsq>\\<zero>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_1_2_L3A",
            "Int_ZF_2_L1A",
            "Int_ZF_2_L14",
            "Int_ZF_1_2_L4",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_2_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L5: assumes A1: \"a\\<in>\\<int>\" and A2: \"b\\<lsq>\\<zero>\"\n  shows \"a\\<ra>(abs(b)\\<ra>\\<one>)\\<cdot>a = (abs(b\\<rs>\\<one>)\\<ra>\\<one>)\\<cdot>a\"\n",
        "proof": "proof -\n  from A2 have \"abs(b\\<rs>\\<one>) \\<in> \\<int>\"\n    using int_zero_one_are_int Int_ZF_1_2_L3A Int_ZF_2_L1A Int_ZF_2_L14 \n    by blast\n  with A1 A2 show ?thesis \n    using Int_ZF_1_2_L4 Int_ZF_1_1_L2 ring0.Ring_ZF_2_L1\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 733
    },
    "668": {
        "type": "lemma",
        "text": "text\\<open>Some other rearrangements with two integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_1_L5",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L6",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_T2",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L7: assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \n  \"a\\<cdot>b = (a\\<rs>\\<one>)\\<cdot>b\\<ra>b\"\n  \"a\\<cdot>(b\\<ra>\\<one>) = a\\<cdot>b\\<ra>a\"\n  \"(b\\<ra>\\<one>)\\<cdot>a = b\\<cdot>a\\<ra>a\"\n  \"(b\\<ra>\\<one>)\\<cdot>a = a\\<ra>b\\<cdot>a\"\n  ",
        "proof": "using assms Int_ZF_1_1_L1 Int_ZF_1_1_L5 int_zero_one_are_int \n    Int_ZF_1_1_L6 Int_ZF_1_1_L4 Int_ZF_1_T2 group0.inv_cancel_two \n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 735
    },
    "669": {
        "type": "lemma",
        "text": "text\\<open>A couple of rearrangement with three integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "group0.group0_4_L4B",
            "group0.group0_4_L6D",
            "group0.group0_4_L4D",
            "group0.group0_4_L6B",
            "group0.group0_4_L6E"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L9: \n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \n  \"(a\\<rs>b)\\<ra>(b\\<rs>c) = a\\<rs>c\"\n  \"(a\\<rs>b)\\<rs>(a\\<rs>c) = c\\<rs>b\"\n  \"a\\<ra>(b\\<ra>(c\\<rs>a\\<rs>b)) = c\"\n  \"(\\<rm>a)\\<rs>b\\<ra>c = c\\<rs>a\\<rs>b\"\n  \"(\\<rm>b)\\<rs>a\\<ra>c = c\\<rs>a\\<rs>b\"\n  \"(\\<rm>((\\<rm>a)\\<ra>b\\<ra>c)) = a\\<rs>b\\<rs>c\"\n  \"a\\<ra>b\\<ra>c\\<rs>a = b\\<ra>c\"\n  \"a\\<ra>b\\<rs>(a\\<ra>c) = b\\<rs>c\"\n  ",
        "proof": "using assms Int_ZF_1_T2 \n    group0.group0_4_L4B group0.group0_4_L6D group0.group0_4_L4D\n    group0.group0_4_L6B group0.group0_4_L6E\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 737
    },
    "670": {
        "type": "lemma",
        "text": "text\\<open>Another couple of rearrangements with three integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_1_L6",
            "Int_ZF_1_1_L5B"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L9A: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \"(\\<rm>(a\\<rs>b\\<rs>c)) = c\\<ra>b\\<rs>a\"\n",
        "proof": "proof -\n  from A1 have T: \n    \"a\\<rs>b \\<in> \\<int>\"  \"(\\<rm>(a\\<rs>b)) \\<in> \\<int>\"  \"(\\<rm>b) \\<in> \\<int>\" using \n    Int_ZF_1_1_L4 Int_ZF_1_1_L5 by auto\n  with A1 have \"(\\<rm>(a\\<rs>b\\<rs>c)) = c \\<rs> ((\\<rm>b)\\<ra>a)\"\n     using Int_ZF_1_1_L5 by simp\n   also from A1 T have \"\\<dots> = c\\<ra>b\\<rs>a\"\n     using Int_ZF_1_1_L6 Int_ZF_1_1_L5B\n     by simp\n  finally show \"(\\<rm>(a\\<rs>b\\<rs>c)) = c\\<ra>b\\<rs>a\" \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 738
    },
    "671": {
        "type": "lemma",
        "text": "text\\<open>A technical rearrangement involing inequalities with absolute value.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"e\\<in>\\<int>\"\n  and A2: \"abs(a\\<cdot>b\\<rs>c) \\<lsq> d\"  \"abs(b\\<cdot>a\\<rs>e) \\<lsq> f\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_L21",
            "Int_ZF_1_2_L9"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L10A: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"e\\<in>\\<int>\"\n  and A2: \"abs(a\\<cdot>b\\<rs>c) \\<lsq> d\"  \"abs(b\\<cdot>a\\<rs>e) \\<lsq> f\"\n  shows \"abs(c\\<rs>e) \\<lsq>  f\\<ra>d\"\n",
        "proof": "proof -  \n  from A1 A2 have T1:\n    \"d\\<in>\\<int>\"  \"f\\<in>\\<int>\"  \"a\\<cdot>b \\<in> \\<int>\"  \"a\\<cdot>b\\<rs>c \\<in> \\<int>\"  \"b\\<cdot>a\\<rs>e \\<in> \\<int>\"\n    using Int_ZF_2_L1A Int_ZF_1_1_L5 by auto\n  with A2 have\n    \"abs((b\\<cdot>a\\<rs>e)\\<rs>(a\\<cdot>b\\<rs>c)) \\<lsq> f \\<ra>d\"\n    using Int_ZF_2_L21 by simp\n  with A1 T1 show \"abs(c\\<rs>e) \\<lsq> f\\<ra>d\" \n    using Int_ZF_1_1_L5 Int_ZF_1_2_L9 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 740
    },
    "672": {
        "type": "lemma",
        "text": "text\\<open>Some arithmetics.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "int_two_three_are_int",
            "Int_ZF_1_T2",
            "group0.group0_4_L4C",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_1_L4",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L11: assumes A1: \"a\\<in>\\<int>\"\n  shows \n  \"a\\<ra>\\<one>\\<ra>\\<two> = a\\<ra>\\<three>\"\n  \"a = \\<two>\\<cdot>a \\<rs> a\"\n",
        "proof": "proof -\n  from A1 show \"a\\<ra>\\<one>\\<ra>\\<two> = a\\<ra>\\<three>\"\n    using int_zero_one_are_int int_two_three_are_int Int_ZF_1_T2 group0.group0_4_L4C\n    by simp\n  from A1 show \"a = \\<two>\\<cdot>a \\<rs> a\"\n    using int_zero_one_are_int Int_ZF_1_1_L1 Int_ZF_1_1_L4 Int_ZF_1_T2 group0.inv_cancel_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 741
    },
    "673": {
        "type": "lemma",
        "text": "text\\<open>A simple rearrangement with three integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L6",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L12: \n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \n  \"(b\\<rs>c)\\<cdot>a = a\\<cdot>b \\<rs> a\\<cdot>c\"\n  ",
        "proof": "using assms Int_ZF_1_1_L6 Int_ZF_1_1_L5 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 742
    },
    "674": {
        "type": "lemma",
        "text": "text\\<open>A big rearrangement with five integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"  \"x\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L7",
            "Int_ZF_1_2_L7",
            "Int_ZF_1_1_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L13: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"  \"x\\<in>\\<int>\"\n  shows \"(x\\<ra>(a\\<cdot>x\\<ra>b)\\<ra>c)\\<cdot>d = d\\<cdot>(a\\<ra>\\<one>)\\<cdot>x \\<ra> (b\\<cdot>d\\<ra>c\\<cdot>d)\"\n",
        "proof": "proof -\n  from A1 have T1: \n    \"a\\<cdot>x \\<in> \\<int>\"   \"(a\\<ra>\\<one>)\\<cdot>x \\<in> \\<int>\"  \n    \"(a\\<ra>\\<one>)\\<cdot>x \\<ra> b \\<in> \\<int>\" \n    using Int_ZF_1_1_L5 int_zero_one_are_int by auto\n  with A1 have \"(x\\<ra>(a\\<cdot>x\\<ra>b)\\<ra>c)\\<cdot>d = ((a\\<ra>\\<one>)\\<cdot>x \\<ra> b)\\<cdot>d \\<ra> c\\<cdot>d\"\n    using Int_ZF_1_1_L7 Int_ZF_1_2_L7 Int_ZF_1_1_L1\n    by simp\n  also from A1 T1 have \"\\<dots> = (a\\<ra>\\<one>)\\<cdot>x\\<cdot>d \\<ra> b \\<cdot> d \\<ra> c\\<cdot>d\"\n    using Int_ZF_1_1_L1 by simp\n  finally have \"(x\\<ra>(a\\<cdot>x\\<ra>b)\\<ra>c)\\<cdot>d = (a\\<ra>\\<one>)\\<cdot>x\\<cdot>d \\<ra> b\\<cdot>d \\<ra> c\\<cdot>d\"\n    by simp\n  moreover from A1 T1 have \"(a\\<ra>\\<one>)\\<cdot>x\\<cdot>d = d\\<cdot>(a\\<ra>\\<one>)\\<cdot>x\"\n    using int_zero_one_are_int Int_ZF_1_1_L5 Int_ZF_1_1_L7 by simp\n  ultimately have \"(x\\<ra>(a\\<cdot>x\\<ra>b)\\<ra>c)\\<cdot>d = d\\<cdot>(a\\<ra>\\<one>)\\<cdot>x \\<ra> b\\<cdot>d \\<ra> c\\<cdot>d\"\n    by simp\n  moreover from A1 T1 have \n    \"d\\<cdot>(a\\<ra>\\<one>)\\<cdot>x \\<in> \\<int>\"  \"b\\<cdot>d \\<in> \\<int>\"  \"c\\<cdot>d \\<in> \\<int>\"\n    using int_zero_one_are_int Int_ZF_1_1_L5 by auto\n  ultimately show ?thesis using Int_ZF_1_1_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 743
    },
    "675": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement with four integers. \n  Again we have to use the generic set notation to use a theorem proven in \n  different context.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"\n  and A2: \"a = b\\<rs>c\\<rs>d\"\n  ",
        "using": [
            "Int_ZF_1_T2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L15: assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"\n  and A2: \"a = b\\<rs>c\\<rs>d\"\n  shows \n  \"d = b\\<rs>a\\<rs>c\"\n  \"d = (\\<rm>a)\\<ra>b\\<rs>c\"\n  \"b = a\\<ra>d\\<ra>c\"\n",
        "proof": "proof -\n  let ?G = \"int\"\n  let ?f = \"IntegerAddition\"\n  from A1 A2 have I:\n    \"group0(?G, ?f)\"   \"?f {is commutative on} ?G\"\n    \"a \\<in> ?G\"  \"b \\<in> ?G\" \"c \\<in> ?G\"  \"d \\<in> ?G\"\n    \"a = ?f`\\<langle>?f`\\<langle>b,GroupInv(?G, ?f)`(c)\\<rangle>,GroupInv(?G, ?f)`(d)\\<rangle>\"\n    using Int_ZF_1_T2 by auto\n  then have  \n    \"d = ?f`\\<langle>?f`\\<langle>b,GroupInv(?G, ?f)`(a)\\<rangle>,GroupInv(?G,?f)`(c)\\<rangle>\"\n    by (rule group0.group0_4_L9)\n  then show \"d = b\\<rs>a\\<rs>c\" by simp\n  from I have \"d = ?f`\\<langle>?f`\\<langle>GroupInv(?G, ?f)`(a),b\\<rangle>, GroupInv(?G, ?f)`(c)\\<rangle>\"\n    by (rule group0.group0_4_L9)\n  thus \"d = (\\<rm>a)\\<ra>b\\<rs>c\"\n    by simp\n  from I have \"b = ?f`\\<langle>?f`\\<langle>a, d\\<rangle>,c\\<rangle>\"\n    by (rule group0.group0_4_L9)\n  thus \"b = a\\<ra>d\\<ra>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 745
    },
    "676": {
        "type": "lemma",
        "text": "text\\<open>Some rearrangements with three integers. Properties of groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_T2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L17:\n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \n  \"a\\<ra>b\\<rs>c\\<ra>(c\\<rs>b) = a\"\n  \"a\\<ra>(b\\<ra>c)\\<rs>c = a\\<ra>b\"\n",
        "proof": "proof -\n  let ?G = \"int\"\n  let ?f = \"IntegerAddition\"\n  from A1 have I:\n    \"group0(?G, ?f)\"\n    \"a \\<in> ?G\"  \"b \\<in> ?G\" \"c \\<in> ?G\"\n    using Int_ZF_1_T2 by auto\n  then have \n    \"?f`\\<langle>?f`\\<langle>?f`\\<langle>a,b\\<rangle>,GroupInv(?G, ?f)`(c)\\<rangle>,?f`\\<langle>c,GroupInv(?G, ?f)`(b)\\<rangle>\\<rangle> = a\"\n    by (rule group0.group0_2_L14A)\n  thus \"a\\<ra>b\\<rs>c\\<ra>(c\\<rs>b) = a\" by simp\n  from I have\n    \"?f`\\<langle>?f`\\<langle>a,?f`\\<langle>b,c\\<rangle>\\<rangle>,GroupInv(?G, ?f)`(c)\\<rangle> = ?f`\\<langle>a,b\\<rangle>\"\n    by (rule group0.group0_2_L14A)\n  thus \"a\\<ra>(b\\<ra>c)\\<rs>c = a\\<ra>b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 747
    },
    "677": {
        "type": "lemma",
        "text": "text\\<open>Another rearrangement with three integers. Property of abelian groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_T2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L18:\n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \"a\\<ra>b\\<rs>c\\<ra>(c\\<rs>a) = b\"\n",
        "proof": "proof -\n  let ?G = \"int\"\n  let ?f = \"IntegerAddition\"\n  from A1 have\n    \"group0(?G, ?f)\"   \"?f {is commutative on} ?G\"\n    \"a \\<in> ?G\"  \"b \\<in> ?G\" \"c \\<in> ?G\"\n    using Int_ZF_1_T2 by auto\n  then have\n    \"?f`\\<langle>?f`\\<langle>?f`\\<langle>a,b\\<rangle>,GroupInv(?G, ?f)`(c)\\<rangle>,?f`\\<langle>c,GroupInv(?G, ?f)`(a)\\<rangle>\\<rangle> = b\"\n    by (rule group0.group0_4_L6D)\n  thus \"a\\<ra>b\\<rs>c\\<ra>(c\\<rs>a) = b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 748
    },
    "678": {
        "type": "lemma",
        "text": "text\\<open>We start with the property that a product of \n  nonnegative integers is nonnegative. The proof is by induction and the next\n  lemma is the induction step.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<lsq>a\"  \"\\<zero>\\<lsq>b\"\n  and A3: \"\\<zero> \\<lsq> a\\<cdot>b\"\n  ",
        "using": [
            "int_ineq_add_sides",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L4",
            "Int_ZF_2_L1A",
            "Int_ZF_1_2_L7"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L1: assumes A1: \"\\<zero>\\<lsq>a\"  \"\\<zero>\\<lsq>b\"\n  and A3: \"\\<zero> \\<lsq> a\\<cdot>b\"\n  shows \"\\<zero> \\<lsq> a\\<cdot>(b\\<ra>\\<one>)\"\n",
        "proof": "proof -\n  from A1 A3 have \"\\<zero>\\<ra>\\<zero> \\<lsq> a\\<cdot>b\\<ra>a\"\n    using int_ineq_add_sides by simp\n  with A1 show \"\\<zero> \\<lsq> a\\<cdot>(b\\<ra>\\<one>)\"\n    using int_zero_one_are_int Int_ZF_1_1_L4 Int_ZF_2_L1A Int_ZF_1_2_L7 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 749
    },
    "679": {
        "type": "lemma",
        "text": "text\\<open>Product of nonnegative integers is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<lsq>a\"  \"\\<zero>\\<lsq>b\" \n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L4",
            "int_zero_one_are_int",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_1_3_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L2: assumes A1: \"\\<zero>\\<lsq>a\"  \"\\<zero>\\<lsq>b\" \n  shows \"\\<zero>\\<lsq>a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have \"\\<zero>\\<lsq>b\" by simp\n  moreover from A1 have \"\\<zero> \\<lsq> a\\<cdot>\\<zero>\" using\n    Int_ZF_2_L1A Int_ZF_1_1_L4 int_zero_one_are_int int_ord_is_refl refl_def\n    by simp\n  moreover from A1 have \n    \"\\<forall>m. \\<zero>\\<lsq>m \\<and> \\<zero>\\<lsq>a\\<cdot>m \\<longrightarrow> \\<zero> \\<lsq> a\\<cdot>(m\\<ra>\\<one>)\"\n    using Int_ZF_1_3_L1 by simp\n  ultimately show \"\\<zero>\\<lsq>a\\<cdot>b\" by (rule Induction_on_int)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 750
    },
    "680": {
        "type": "lemma",
        "text": "text\\<open>The set of nonnegative integers is closed under  multiplication.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_3_L2",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L2",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L2A: shows \n  \"\\<int>\\<^sup>+ {is closed under} IntegerMultiplication\"\n",
        "proof": "proof -\n  { fix a b assume \"a\\<in>\\<int>\\<^sup>+\"  \"b\\<in>\\<int>\\<^sup>+\"\n    then have \"a\\<cdot>b \\<in>\\<int>\\<^sup>+\"\n      using Int_ZF_1_3_L2 Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L2 \n      by simp\n  } then have \"\\<forall>a\\<in>\\<int>\\<^sup>+.\\<forall>b\\<in>\\<int>\\<^sup>+.a\\<cdot>b \\<in>\\<int>\\<^sup>+\" by simp \n  then show ?thesis using IsOpClosed_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 751
    },
    "681": {
        "type": "theorem",
        "text": "text\\<open>Integers form an ordered ring. All theorems proven in the \n  \\<open>ring1\\<close> context are valid in \\<open>int0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_1_L2",
            "Int_ZF_2_L1B",
            "Int_ZF_1_3_L2A",
            "Int_ZF_2_T1",
            "OrdRing_ZF_1_L6",
            "OrdRing_ZF_1_L2"
        ],
        "statement": "theorem (in int0) Int_ZF_1_3_T1: shows \n  \"IsAnOrdRing(\\<int>,IntegerAddition,IntegerMultiplication,IntegerOrder)\"\n  \"ring1(\\<int>,IntegerAddition,IntegerMultiplication,IntegerOrder)\"\n  ",
        "proof": "using Int_ZF_1_1_L2 Int_ZF_2_L1B Int_ZF_1_3_L2A Int_ZF_2_T1\n    OrdRing_ZF_1_L6 OrdRing_ZF_1_L2 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 752
    },
    "682": {
        "type": "lemma",
        "text": "text\\<open>Product of integers that are greater that one is greater than one. \n  The proof is by induction and \n  the next step is the induction step.\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\"  \"\\<one>\\<lsq>b\"\n  and A2: \"\\<one> \\<lsq> a\\<cdot>b\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "int_ineq_add_sides",
            "Int_ZF_2_L16B",
            "Int_ZF_1_2_L7"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L3_indstep:  \n  assumes A1: \"\\<one>\\<lsq>a\"  \"\\<one>\\<lsq>b\"\n  and A2: \"\\<one> \\<lsq> a\\<cdot>b\"\n  shows \"\\<one> \\<lsq> a\\<cdot>(b\\<ra>\\<one>)\"\n",
        "proof": "proof -\n   from A1 A2 have \"\\<one>\\<lsq>\\<two>\" and \"\\<two> \\<lsq> a\\<cdot>(b\\<ra>\\<one>)\"\n    using Int_ZF_2_L1A int_ineq_add_sides Int_ZF_2_L16B Int_ZF_1_2_L7 \n    by auto\n  then show \"\\<one> \\<lsq> a\\<cdot>(b\\<ra>\\<one>)\" by (rule Int_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 753
    },
    "683": {
        "type": "lemma",
        "text": "text\\<open>Product of integers that are greater that one is greater than one.\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\" \"\\<one>\\<lsq>b\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_3_L3_indstep"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L3: \n  assumes A1: \"\\<one>\\<lsq>a\" \"\\<one>\\<lsq>b\"\n  shows \"\\<one> \\<lsq> a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have \"\\<one>\\<lsq>b\"  \"\\<one>\\<lsq>a\\<cdot>\\<one>\"\n    using Int_ZF_2_L1A Int_ZF_1_1_L4 by auto\n  moreover from A1 have \n    \"\\<forall>m. \\<one>\\<lsq>m \\<and> \\<one> \\<lsq> a\\<cdot>m \\<longrightarrow> \\<one> \\<lsq> a\\<cdot>(m\\<ra>\\<one>)\"\n    using Int_ZF_1_3_L3_indstep by simp\n  ultimately show \"\\<one> \\<lsq> a\\<cdot>b\" by (rule Induction_on_int)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 754
    },
    "684": {
        "type": "lemma",
        "text": "text\\<open>$|a\\cdot (-b)| = |(-a)\\cdot b| = |(-a)\\cdot (-b)| = |a\\cdot b|$\n  This is a property of ordered rings..\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_L17"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L4: assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \n  \"abs((\\<rm>a)\\<cdot>b) = abs(a\\<cdot>b)\"\n  \"abs(a\\<cdot>(\\<rm>b)) = abs(a\\<cdot>b)\"\n  \"abs((\\<rm>a)\\<cdot>(\\<rm>b)) = abs(a\\<cdot>b)\"\n  ",
        "proof": "using assms Int_ZF_1_1_L5 Int_ZF_2_L17 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 755
    },
    "685": {
        "type": "lemma",
        "text": "text\\<open>Absolute value of a product is the product of absolute values.\n  Property of ordered rings.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_2_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L5:\n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \"abs(a\\<cdot>b) = abs(a)\\<cdot>abs(b)\"\n  ",
        "proof": "using assms Int_ZF_1_3_T1 ring1.OrdRing_ZF_2_L5 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 756
    },
    "686": {
        "type": "lemma",
        "text": "text\\<open>Double nonnegative is nonnegative. Property of ordered rings.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_1_L5A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L5A: assumes \"\\<zero>\\<lsq>a\"\n  shows \"\\<zero>\\<lsq>\\<two>\\<cdot>a\"\n  ",
        "proof": "using assms Int_ZF_1_3_T1 ring1.OrdRing_ZF_1_L5A by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 757
    },
    "687": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows what happens when one integer is not\n  greater or equal than another.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" \n  ",
        "using": [
            "Int_ZF_4_L1B",
            "Int_ZF_2_L12B",
            "Int_ZF_1_L14"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L6: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" \n  shows \"\\<not>(b\\<lsq>a) \\<longleftrightarrow> a\\<ra>\\<one> \\<lsq> b\"\n",
        "proof": "proof\n  assume A3: \"\\<not>(b\\<lsq>a)\"\n  with A1 have  \"a\\<lsq>b\" by (rule Int_ZF_2_L19)\n  then have \"a = b   \\<or>  a\\<ra>\\<one> \\<lsq> b\"\n    using Int_ZF_4_L1B by simp \n  moreover from A1 A3 have \"a\\<noteq>b\" by (rule Int_ZF_2_L19)\n  ultimately show \"a\\<ra>\\<one> \\<lsq> b\" by simp\nnext assume A4: \"a\\<ra>\\<one> \\<lsq> b\"\n  { assume \"b\\<lsq>a\" \n    with A4 have \"a\\<ra>\\<one> \\<lsq> a\" by (rule Int_order_transitive)\n    moreover from A1 have \"a \\<lsq> a\\<ra>\\<one>\"\n      using Int_ZF_2_L12B by simp\n    ultimately have \"a\\<ra>\\<one> = a\"\n      by (rule Int_ZF_2_L3) \n    with A1 have False using Int_ZF_1_L14 by simp \n  } then show \"\\<not>(b\\<lsq>a)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 758
    },
    "688": {
        "type": "corollary",
        "text": "text\\<open>Another form of stating that there are no integers\n  between integers $m$ and $m+1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "A1",
            "Int_ZF_1_3_L6"
        ],
        "statement": "corollary (in int0) no_int_between: assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \"b\\<lsq>a \\<or> a\\<ra>\\<one> \\<lsq> b\"\n  ",
        "proof": "using A1 Int_ZF_1_3_L6 by auto     \n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 759
    },
    "689": {
        "type": "corollary",
        "text": "text\\<open>Another way of saying what it means that one integer is not\n  greater or equal than another.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" and A2: \"\\<not>(b\\<lsq>a)\"\n  ",
        "using": [
            "Int_ZF_1_3_L6",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L4",
            "int_ord_transl_inv",
            "Int_ZF_1_2_L3"
        ],
        "statement": "corollary (in int0) Int_ZF_1_3_L6A:\n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" and A2: \"\\<not>(b\\<lsq>a)\"\n  shows \"a \\<lsq> b\\<rs>\\<one>\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<ra>\\<one> \\<rs> \\<one> \\<lsq> b \\<rs> \\<one>\"\n    using Int_ZF_1_3_L6 int_zero_one_are_int Int_ZF_1_1_L4 \n      int_ord_transl_inv by simp\n  with A1 show \"a \\<lsq> b\\<rs>\\<one>\"\n    using int_zero_one_are_int Int_ZF_1_2_L3\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 760
    },
    "690": {
        "type": "lemma",
        "text": "text\\<open>Yet another form of stating that there are nointegers between\n  $m$ and $m+1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  and A2: \"a\\<noteq>b\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "no_int_between",
            "Int_ZF_1_3_L6A"
        ],
        "statement": "lemma (in int0) no_int_between1: \n  assumes A1: \"a\\<lsq>b\"  and A2: \"a\\<noteq>b\"\n  shows \n  \"a\\<ra>\\<one> \\<lsq> b\"\n  \"a \\<lsq> b\\<rs>\\<one>\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" using Int_ZF_2_L1A\n    by auto\n  { assume \"b\\<lsq>a\"\n    with A1 have \"a=b\" by (rule Int_ZF_2_L3)\n    with A2 have False by simp }\n  then have \"\\<not>(b\\<lsq>a)\" by auto\n  with T show \n    \"a\\<ra>\\<one> \\<lsq> b\" \n    \"a \\<lsq> b\\<rs>\\<one>\"\n    using no_int_between Int_ZF_1_3_L6A by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 761
    },
    "691": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>Int_ZF_1_3_L6B\\<close> when $b=0$. This\n  allows to split the proofs in cases $a\\leq -1$, $a=0$ and $a\\geq 1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_1_3_L6B",
            "Int_ZF_1_1_L4"
        ],
        "statement": "corollary (in int0) Int_ZF_1_3_L6C: assumes A1: \"a\\<in>\\<int>\"\n  shows \"a=\\<zero> \\<or> (a \\<lsq> \\<rm>\\<one>) \\<or> (\\<one>\\<lsq>a)\"  \n",
        "proof": "proof -\n  from A1 have \"a=\\<zero> \\<or> (a \\<lsq> \\<zero> \\<rs>\\<one>) \\<or> (\\<zero> \\<ra>\\<one> \\<lsq>a)\"\n    using int_zero_one_are_int Int_ZF_1_3_L6B by simp\n  then show ?thesis using Int_ZF_1_1_L4 int_zero_one_are_int\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 763
    },
    "692": {
        "type": "lemma",
        "text": "text\\<open>An integer is not less or equal zero iff it is greater or equal one.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\" \n  ",
        "using": [
            "assms",
            "int_zero_one_are_int",
            "Int_ZF_1_3_L6",
            "Int_ZF_1_1_L4"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L7: assumes \"a\\<in>\\<int>\" \n  shows \"\\<not>(a\\<lsq>\\<zero>) \\<longleftrightarrow> \\<one> \\<lsq> a\"\n  ",
        "proof": "using assms int_zero_one_are_int Int_ZF_1_3_L6 Int_ZF_1_1_L4\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 764
    },
    "693": {
        "type": "lemma",
        "text": "text\\<open>Product of positive integers is positive.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" \n  and \"\\<not>(a\\<lsq>\\<zero>)\"  \"\\<not>(b\\<lsq>\\<zero>)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_3_L7",
            "Int_ZF_1_3_L3",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L8: \n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\" \n  and \"\\<not>(a\\<lsq>\\<zero>)\"  \"\\<not>(b\\<lsq>\\<zero>)\"\n  shows \"\\<not>((a\\<cdot>b) \\<lsq> \\<zero>)\"\n  ",
        "proof": "using assms Int_ZF_1_3_L7 Int_ZF_1_3_L3 Int_ZF_1_1_L5 Int_ZF_1_3_L7\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 765
    },
    "694": {
        "type": "lemma",
        "text": "text\\<open>If $a\\cdot b$ is nonnegative and $b$ is positive, then $a$ is \n  nonnegative. Proof by contradiction.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  and A2:  \"\\<not>(b\\<lsq>\\<zero>)\" and A3: \"a\\<cdot>b \\<lsq> \\<zero>\" \n  ",
        "using": [
            "Int_ZF_1_3_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L9:\n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  and A2:  \"\\<not>(b\\<lsq>\\<zero>)\" and A3: \"a\\<cdot>b \\<lsq> \\<zero>\" \n  shows \"a\\<lsq>\\<zero>\"\n",
        "proof": "proof -\n  { assume \"\\<not>(a\\<lsq>\\<zero>)\"\n    with A1 A2 have \"\\<not>((a\\<cdot>b) \\<lsq> \\<zero>)\" using Int_ZF_1_3_L8\n      by simp\n  } with A3 show \"a\\<lsq>\\<zero>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 766
    },
    "695": {
        "type": "lemma",
        "text": "text\\<open>One integer is less or equal another iff the difference is nonpositive.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L9"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L10:\n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \"a\\<lsq>b \\<longleftrightarrow> a\\<rs>b \\<lsq> \\<zero>\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L9\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 767
    },
    "696": {
        "type": "lemma",
        "text": "text\\<open>Some conclusions from the fact that one integer\n  is less or equal than another.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L12A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L10A: assumes \"a\\<lsq>b\"\n  shows \"\\<zero> \\<lsq> b\\<rs>a\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L12A\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 768
    },
    "697": {
        "type": "lemma",
        "text": "text\\<open>We can simplify out a positive element on both sides of an \n  inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \n  and A2: \"a\\<cdot>c \\<lsq> b\\<cdot>c\" and A4: \"\\<not>(c\\<lsq>\\<zero>)\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_1_3_L10",
            "Int_ZF_1_1_L6"
        ],
        "statement": "lemma (in int0) Int_ineq_simpl_positive: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \n  and A2: \"a\\<cdot>c \\<lsq> b\\<cdot>c\" and A4: \"\\<not>(c\\<lsq>\\<zero>)\"\n  shows \"a \\<lsq> b\"\n",
        "proof": "proof -\n  from A1 A4 have \"a\\<rs>b \\<in>  \\<int>\"  \"c\\<in>\\<int>\"  \"\\<not>(c\\<lsq>\\<zero>)\"\n    using Int_ZF_1_1_L5 by auto\n  moreover from A1 A2 have \"(a\\<rs>b)\\<cdot>c \\<lsq> \\<zero>\"\n    using Int_ZF_1_1_L5 Int_ZF_1_3_L10 Int_ZF_1_1_L6\n    by simp\n  ultimately have \"a\\<rs>b \\<lsq> \\<zero>\" by (rule Int_ZF_1_3_L9)\n  with A1 show \"a \\<lsq> b\" using Int_ZF_1_3_L10 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 769
    },
    "698": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about conclusion from an inequality between\n  absolute values. This is a property of ordered rings.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  and A2: \"\\<not>(abs(a) \\<lsq> abs(b))\"\n  ",
        "using": [
            "int_abs_nonneg"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L11:\n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  and A2: \"\\<not>(abs(a) \\<lsq> abs(b))\"\n  shows \"\\<not>(abs(a) \\<lsq> \\<zero>)\"\n",
        "proof": "proof -\n  { assume \"abs(a) \\<lsq> \\<zero>\"\n    moreover from A1 have \"\\<zero> \\<lsq> abs(a)\" using int_abs_nonneg\n      by simp\n    ultimately have \"abs(a) = \\<zero>\" by (rule Int_ZF_2_L3)\n    with A1 A2 have False using int_abs_nonneg by simp\n  } then show  \"\\<not>(abs(a) \\<lsq> \\<zero>)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 770
    },
    "699": {
        "type": "lemma",
        "text": "text\\<open>Negative times positive is negative. This a property of ordered rings.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>\\<zero>\"  and \"\\<zero>\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_1_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L12:\n  assumes \"a\\<lsq>\\<zero>\"  and \"\\<zero>\\<lsq>b\"\n  shows \"a\\<cdot>b \\<lsq> \\<zero>\"\n  ",
        "proof": "using assms Int_ZF_1_3_T1 ring1.OrdRing_ZF_1_L8 \n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 771
    },
    "700": {
        "type": "lemma",
        "text": "text\\<open>We can multiply an inequality by a nonnegative number. \n  This is a property of ordered rings.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"\\<zero>\\<lsq>c\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_1_L9"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L13:\n  assumes A1: \"a\\<lsq>b\" and A2: \"\\<zero>\\<lsq>c\"\n  shows \n  \"a\\<cdot>c \\<lsq> b\\<cdot>c\"\n  \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n  ",
        "proof": "using assms Int_ZF_1_3_T1 ring1.OrdRing_ZF_1_L9 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 772
    },
    "701": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about decreasing a factor in an inequality.\\<close>\n",
        "assumes": "assumes \"\\<one>\\<lsq>a\" and \"b\\<lsq>c\" and \"(a\\<ra>\\<one>)\\<cdot>c \\<lsq> d\"\n  ",
        "using": [
            "Int_ZF_2_L16C",
            "Int_ZF_1_3_L13"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L13A:\n  assumes \"\\<one>\\<lsq>a\" and \"b\\<lsq>c\" and \"(a\\<ra>\\<one>)\\<cdot>c \\<lsq> d\"\n  shows \"(a\\<ra>\\<one>)\\<cdot>b \\<lsq> d\"\n",
        "proof": "proof -\n  from assms have \n    \"(a\\<ra>\\<one>)\\<cdot>b \\<lsq> (a\\<ra>\\<one>)\\<cdot>c\"\n    \"(a\\<ra>\\<one>)\\<cdot>c \\<lsq> d\"\n    using Int_ZF_2_L16C Int_ZF_1_3_L13 by auto\n  then show \"(a\\<ra>\\<one>)\\<cdot>b \\<lsq> d\" by (rule Int_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 773
    },
    "702": {
        "type": "lemma",
        "text": "text\\<open>We can multiply an inequality by a positive number. \n  This is a property of ordered rings.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_1_L9A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L13B:  \n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>\\<int>\\<^sub>+\"\n  shows  \n  \"a\\<cdot>c \\<lsq> b\\<cdot>c\"  \n  \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n",
        "proof": "proof -\n  let ?R = \"\\<int>\"\n  let ?A = \"IntegerAddition\"\n  let ?M = \"IntegerMultiplication\"\n  let ?r = \"IntegerOrder\"\n  from A1 A2 have \n    \"ring1(?R, ?A, ?M, ?r)\" \n    \"\\<langle>a,b\\<rangle> \\<in> ?r\"\n    \"c \\<in> PositiveSet(?R, ?A, ?r)\"\n    using Int_ZF_1_3_T1 by auto\n  then show \n    \"a\\<cdot>c \\<lsq> b\\<cdot>c\"  \n    \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n    using ring1.OrdRing_ZF_1_L9A by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 774
    },
    "703": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement with four integers and absolute value.\\<close>\n",
        "assumes": "assumes  A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"d\\<in>\\<int>\" \n  ",
        "using": [
            "Int_ZF_2_L14",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_3_L5",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_1_L7"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L14:\n  assumes  A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"d\\<in>\\<int>\" \n  shows \"abs(a\\<cdot>b)\\<ra>(abs(a)\\<ra>c)\\<cdot>d = (d\\<ra>abs(b))\\<cdot>abs(a)\\<ra>c\\<cdot>d\"\n",
        "proof": "proof -\n  from A1 have T1: \n    \"abs(a) \\<in> \\<int>\"  \"abs(b) \\<in> \\<int>\" \n    \"abs(a)\\<cdot>abs(b) \\<in> \\<int>\" \n    \"abs(a)\\<cdot>d \\<in> \\<int>\" \n    \"c\\<cdot>d \\<in> \\<int>\"\n    \"abs(b)\\<ra>d \\<in> \\<int>\" \n    using Int_ZF_2_L14 Int_ZF_1_1_L5 by auto\n  with A1 have \"abs(a\\<cdot>b)\\<ra>(abs(a)\\<ra>c)\\<cdot>d = abs(a)\\<cdot>(abs(b)\\<ra>d)\\<ra>c\\<cdot>d\"\n    using Int_ZF_1_3_L5 Int_ZF_1_1_L1 Int_ZF_1_1_L7 by simp\n  with A1 T1 show ?thesis using Int_ZF_1_1_L5 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 775
    },
    "704": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about what happens when one absolute value is\n  not greater or equal than another.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" \"n\\<in>\\<int>\"\n  and A2: \"\\<not>(abs(m) \\<lsq> abs(n))\"\n  ",
        "using": [
            "Int_ZF_2_L19C",
            "Int_ZF_2_L14",
            "Int_ZF_2_L18",
            "int_abs_nonneg"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L15: assumes A1: \"m\\<in>\\<int>\" \"n\\<in>\\<int>\"\n  and A2: \"\\<not>(abs(m) \\<lsq> abs(n))\"\n  shows \"n \\<lsq> abs(m)\"  \"m\\<noteq>\\<zero>\" \n",
        "proof": "proof -\n  from A1 have T1: \"n \\<lsq> abs(n)\" \n    using Int_ZF_2_L19C by simp\n  from A1 have \"abs(n) \\<in> \\<int>\"  \"abs(m) \\<in> \\<int>\"\n    using Int_ZF_2_L14 by auto\n  moreover note A2\n  ultimately have \"abs(n) \\<lsq> abs(m)\"\n    by (rule Int_ZF_2_L19)\n  with T1 show  \"n \\<lsq> abs(m)\" by (rule Int_order_transitive)\n  from A1 A2 show \"m\\<noteq>\\<zero>\" using Int_ZF_2_L18 int_abs_nonneg by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 776
    },
    "705": {
        "type": "lemma",
        "text": "text\\<open>Negative of a nonnegative is nonpositive.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero> \\<lsq> m\"\n  ",
        "using": [
            "Int_ZF_2_L10",
            "Int_ZF_1_L11"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L16: assumes A1: \"\\<zero> \\<lsq> m\"\n  shows \"(\\<rm>m) \\<lsq> \\<zero>\"\n",
        "proof": "proof -\n  from A1 have \"(\\<rm>m) \\<lsq> (\\<rm>\\<zero>)\"\n    using Int_ZF_2_L10 by simp\n  then show \"(\\<rm>m) \\<lsq> \\<zero>\" using Int_ZF_1_L11\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 777
    },
    "706": {
        "type": "lemma",
        "text": "text\\<open>The greater of two integers is indeed greater than both, \n  and the smaller one is smaller that both.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "Order_ZF_3_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L18: assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"m \\<lsq> GreaterOf(IntegerOrder,m,n)\"\n  \"n \\<lsq> GreaterOf(IntegerOrder,m,n)\"\n  \"SmallerOf(IntegerOrder,m,n) \\<lsq> m\"\n  \"SmallerOf(IntegerOrder,m,n) \\<lsq> n\"\n  ",
        "proof": "using assms Int_ZF_2_T1 Order_ZF_3_L2 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 779
    },
    "707": {
        "type": "lemma",
        "text": "text\\<open>If $|m| \\leq n$, then $m \\in -n..n$.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" and A2: \"abs(m) \\<lsq> n\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L8",
            "group3.OrderedGroup_ZF_3_L8A",
            "Order_ZF_2_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L19: \n  assumes A1: \"m\\<in>\\<int>\" and A2: \"abs(m) \\<lsq> n\"\n  shows \n  \"(\\<rm>n) \\<lsq> m\"  \"m \\<lsq> n\"\n  \"m \\<in> (\\<rm>n)..n\"\n  \"\\<zero> \\<lsq> n\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L8  \n    group3.OrderedGroup_ZF_3_L8A Order_ZF_2_L1 \n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 780
    },
    "708": {
        "type": "lemma",
        "text": "text\\<open>A slight generalization of the above lemma.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" and A2: \"abs(m) \\<lsq> n\" and A3: \"\\<zero>\\<lsq>k\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L8B"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L19A: \n  assumes A1: \"m\\<in>\\<int>\" and A2: \"abs(m) \\<lsq> n\" and A3: \"\\<zero>\\<lsq>k\"\n  shows \"(\\<rm>(n\\<ra>k)) \\<lsq> m\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L8B\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 781
    },
    "709": {
        "type": "lemma",
        "text": "text\\<open>Sets of integers that have absolute value bounded are bounded.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int> \\<and> abs(b(x)) \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L20:\n  assumes A1: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int> \\<and> abs(b(x)) \\<lsq> L\"\n  shows \"IsBounded({b(x). x\\<in>X},IntegerOrder)\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?P = \"IntegerAddition\"\n  let ?r = \"IntegerOrder\"\n  from A1 have\n    \"group3(?G, ?P, ?r)\"\n    \"?r {is total on} ?G\"\n    \"\\<forall>x\\<in>X. b(x) \\<in> ?G \\<and> \\<langle>AbsoluteValue(?G, ?P, ?r) ` b(x), L\\<rangle> \\<in> ?r\"\n    using Int_ZF_2_T1 by auto\n  then show \"IsBounded({b(x). x\\<in>X},IntegerOrder)\"\n    by (rule group3.OrderedGroup_ZF_3_L9A)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 782
    },
    "710": {
        "type": "lemma",
        "text": "text\\<open>If a set is bounded, then the absolute values of the elements of that\n  set are bounded.\\<close>\n",
        "assumes": "assumes \"IsBounded(A,IntegerOrder)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L10A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L20A: assumes \"IsBounded(A,IntegerOrder)\"\n  shows \"\\<exists>L. \\<forall>a\\<in>A. abs(a) \\<lsq> L\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L10A \n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 783
    },
    "711": {
        "type": "lemma",
        "text": "text\\<open>Absolute vaues of integers from a finite image of integers are bounded\n  by an integer.\\<close>\n",
        "assumes": "assumes A1: \"{b(x). x\\<in>\\<int>} \\<in> Fin(\\<int>)\"\n  ",
        "using": [
            "assms",
            "int_not_empty",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L11A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L20AA: \n  assumes A1: \"{b(x). x\\<in>\\<int>} \\<in> Fin(\\<int>)\"\n  shows \"\\<exists>L\\<in>\\<int>. \\<forall>x\\<in>\\<int>. abs(b(x)) \\<lsq> L\"\n  ",
        "proof": "using assms int_not_empty Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L11A\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 784
    },
    "712": {
        "type": "lemma",
        "text": "text\\<open>If absolute values of values of some integer function are bounded,\n  then the image a set from the domain is a bounded set.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>\\<int>\" and \"A\\<subseteq>X\" and \"\\<forall>x\\<in>A. abs(f`(x)) \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L20B:\n  assumes \"f:X\\<rightarrow>\\<int>\" and \"A\\<subseteq>X\" and \"\\<forall>x\\<in>A. abs(f`(x)) \\<lsq> L\"\n  shows  \"IsBounded(f``(A),IntegerOrder)\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?P = \"IntegerAddition\"\n  let ?r = \"IntegerOrder\"\n  from assms have \n    \"group3(?G, ?P, ?r)\"\n    \"?r {is total on} ?G\"\n    \"f:X\\<rightarrow>?G\"\n    \"A\\<subseteq>X\"\n    \"\\<forall>x\\<in>A. \\<langle>AbsoluteValue(?G, ?P, ?r)`(f`(x)), L\\<rangle> \\<in> ?r\"\n    using Int_ZF_2_T1 by auto\n  then show \"IsBounded(f``(A), ?r)\" \n    by (rule group3.OrderedGroup_ZF_3_L9B)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 785
    },
    "713": {
        "type": "corollary",
        "text": "text\\<open>A special case of the previous lemma for a function from integers to \n  integers.\\<close>\n",
        "assumes": "assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"\\<forall>m\\<in>\\<int>. abs(f`(m)) \\<lsq> L\"\n  ",
        "using": [
            "Int_bounded_iff_fin"
        ],
        "statement": "corollary (in int0) Int_ZF_1_3_L20C:\n  assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"\\<forall>m\\<in>\\<int>. abs(f`(m)) \\<lsq> L\"\n  shows \"f``(\\<int>) \\<in> Fin(\\<int>)\"\n",
        "proof": "proof -\n  from assms have \"f:\\<int>\\<rightarrow>\\<int>\" \"\\<int> \\<subseteq> \\<int>\"  \"\\<forall>m\\<in>\\<int>. abs(f`(m)) \\<lsq> L\"\n    by auto\n  then have \"IsBounded(f``(\\<int>),IntegerOrder)\"\n    by (rule Int_ZF_1_3_L20B)\n  then show \"f``(\\<int>) \\<in> Fin(\\<int>)\" using Int_bounded_iff_fin\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 786
    },
    "714": {
        "type": "lemma",
        "text": "text\\<open>A triangle inequality with three integers. Property of \n  linearly ordered abelian groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_2_L14",
            "Int_triangle_ineq1",
            "int_ord_transl_inv"
        ],
        "statement": "lemma (in int0) int_triangle_ineq3: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \"abs(a\\<rs>b\\<rs>c) \\<lsq> abs(a) \\<ra> abs(b) \\<ra> abs(c)\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<rs>b \\<in> \\<int>\"  \"abs(c) \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 Int_ZF_2_L14 by auto\n  with A1 have \"abs(a\\<rs>b\\<rs>c) \\<lsq> abs(a\\<rs>b) \\<ra> abs(c)\"\n    using Int_triangle_ineq1 by simp\n  moreover from A1 T have \n    \"abs(a\\<rs>b) \\<ra> abs(c) \\<lsq>  abs(a) \\<ra> abs(b) \\<ra> abs(c)\"\n    using Int_triangle_ineq1 int_ord_transl_inv by simp\n  ultimately show ?thesis by (rule Int_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 787
    },
    "715": {
        "type": "lemma",
        "text": "text\\<open>If $a\\leq c$ and $b\\leq c$, then $a+b\\leq 2\\cdot c$. \n  Property of ordered rings.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>c\"  \"b\\<lsq>c\" ",
        "using": [
            "assms",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_2_L6"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L21:\n  assumes A1: \"a\\<lsq>c\"  \"b\\<lsq>c\" shows \"a\\<ra>b \\<lsq> \\<two>\\<cdot>c\"\n  ",
        "proof": "using assms Int_ZF_1_3_T1 ring1.OrdRing_ZF_2_L6 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 788
    },
    "716": {
        "type": "lemma",
        "text": "text\\<open>If an integer $a$ is between $b$ and $b+c$, then\n  $|b-a| \\leq c$. Property of ordered groups.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"c\\<in>\\<int>\" and \"b\\<lsq> c\\<ra>a\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L8C"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L22: \n  assumes \"a\\<lsq>b\" and \"c\\<in>\\<int>\" and \"b\\<lsq> c\\<ra>a\"\n  shows \"abs(b\\<rs>a) \\<lsq> c\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L8C\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 789
    },
    "717": {
        "type": "lemma",
        "text": "text\\<open>An application of the triangle inequality with four\n  integers. Property of linearly ordered abelian groups.\\<close>\n",
        "assumes": "assumes  \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"d\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L7F"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L22A: \n  assumes  \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"d\\<in>\\<int>\"\n  shows \"abs(a\\<rs>c) \\<lsq> abs(a\\<ra>b) \\<ra> abs(c\\<ra>d) \\<ra> abs(b\\<rs>d)\"\n  ",
        "proof": "using assms Int_ZF_1_T2 Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L7F\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 790
    },
    "718": {
        "type": "lemma",
        "text": "text\\<open>If an integer $a$ is between $b$ and $b+c$, then\n  $|b-a| \\leq c$. Property of ordered groups.\n  A version of \\<open>Int_ZF_1_3_L22\\<close> with sligtly different\n  assumptions.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>\\<int>\" and A3: \"b\\<lsq> a\\<ra>c\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_3_L22"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L23: \n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>\\<int>\" and A3: \"b\\<lsq> a\\<ra>c\"\n  shows \"abs(b\\<rs>a) \\<lsq> c\"\n",
        "proof": "proof -\n  from A1 have \"a \\<in> \\<int>\"\n    using Int_ZF_2_L1A by simp\n  with A2 A3 have \"b\\<lsq> c\\<ra>a\"\n    using Int_ZF_1_1_L5 by simp\n  with A1 A2 show \"abs(b\\<rs>a) \\<lsq> c\"\n    using Int_ZF_1_3_L22 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 791
    },
    "719": {
        "type": "theorem",
        "text": "text\\<open>Finite nonempty subsets of integers attain maxima and minima.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> Fin(\\<int>)\" and A2: \"A\\<noteq>0\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "Int_ZF_2_L6",
            "Finite_ZF_1_1_T1A",
            "Finite_ZF_1_1_T1B",
            "Finite_ZF_1_T2",
            "FinD"
        ],
        "statement": "theorem (in int0) Int_fin_have_max_min:\n  assumes A1: \"A \\<in> Fin(\\<int>)\" and A2: \"A\\<noteq>0\"\n  shows \n  \"HasAmaximum(IntegerOrder,A)\"\n  \"HasAminimum(IntegerOrder,A)\"  \n  \"Maximum(IntegerOrder,A) \\<in> A\"\n  \"Minimum(IntegerOrder,A) \\<in> A\"\n  \"\\<forall>x\\<in>A. x \\<lsq> Maximum(IntegerOrder,A)\"\n  \"\\<forall>x\\<in>A. Minimum(IntegerOrder,A) \\<lsq> x\"\n  \"Maximum(IntegerOrder,A) \\<in> \\<int>\"\n  \"Minimum(IntegerOrder,A) \\<in> \\<int>\"\n",
        "proof": "proof -\n  from A1 have \n    \"A=0 \\<or> HasAmaximum(IntegerOrder,A)\" and\n    \"A=0 \\<or> HasAminimum(IntegerOrder,A)\"\n    using Int_ZF_2_T1 Int_ZF_2_L6 Finite_ZF_1_1_T1A Finite_ZF_1_1_T1B\n    by auto\n  with A2 show \n    \"HasAmaximum(IntegerOrder,A)\"\n    \"HasAminimum(IntegerOrder,A)\"  \n    by auto\n  from A1 A2 show \n    \"Maximum(IntegerOrder,A) \\<in> A\"\n    \"Minimum(IntegerOrder,A) \\<in> A\"\n    \"\\<forall>x\\<in>A. x \\<lsq> Maximum(IntegerOrder,A)\"\n    \"\\<forall>x\\<in>A. Minimum(IntegerOrder,A) \\<lsq> x\"\n    using Int_ZF_2_T1 Finite_ZF_1_T2 by auto\n  moreover from A1 have \"A\\<subseteq>\\<int>\" using FinD by simp\n  ultimately show \n    \"Maximum(IntegerOrder,A) \\<in> \\<int>\"\n    \"Minimum(IntegerOrder,A) \\<in> \\<int>\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 792
    },
    "720": {
        "type": "theorem",
        "text": "text\\<open>Bounded nonempty integer subsets attain maximum and minimum.\\<close>\n",
        "assumes": "assumes \"IsBounded(A,IntegerOrder)\" and \"A\\<noteq>0\"\n  ",
        "using": [
            "assms",
            "Int_fin_have_max_min",
            "Int_bounded_iff_fin"
        ],
        "statement": "theorem (in int0) Int_bounded_have_max_min:\n  assumes \"IsBounded(A,IntegerOrder)\" and \"A\\<noteq>0\"\n  shows \n  \"HasAmaximum(IntegerOrder,A)\"\n  \"HasAminimum(IntegerOrder,A)\"  \n  \"Maximum(IntegerOrder,A) \\<in> A\"\n  \"Minimum(IntegerOrder,A) \\<in> A\"\n  \"\\<forall>x\\<in>A. x \\<lsq> Maximum(IntegerOrder,A)\"\n  \"\\<forall>x\\<in>A. Minimum(IntegerOrder,A) \\<lsq> x\"\n  \"Maximum(IntegerOrder,A) \\<in> \\<int>\"\n  \"Minimum(IntegerOrder,A) \\<in> \\<int>\"\n  ",
        "proof": "using assms Int_fin_have_max_min Int_bounded_iff_fin\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 793
    },
    "721": {
        "type": "theorem",
        "text": "text\\<open>Nonempty set of integers that is bounded below attains its minimum.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedBelow(A,IntegerOrder)\" and A2: \"A\\<noteq>0\"\n  ",
        "using": [],
        "statement": "theorem (in int0) int_bounded_below_has_min:\n  assumes A1: \"IsBoundedBelow(A,IntegerOrder)\" and A2: \"A\\<noteq>0\"\n  shows \"\n  HasAminimum(IntegerOrder,A)\"\n  \"Minimum(IntegerOrder,A) \\<in> A\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 794
    },
    "722": {
        "type": "theorem",
        "text": "text\\<open>Nonempty set of integers that is bounded above attains its\n  maximum.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(A,IntegerOrder)\" and A2: \"A\\<noteq>0\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "Int_ZF_2_L6",
            "Int_ZF_2_L1B",
            "Int_bounded_have_max_min",
            "Int_ZF_2_L4",
            "Order_ZF_4_L3"
        ],
        "statement": "theorem (in int0) int_bounded_above_has_max:\n  assumes A1: \"IsBoundedAbove(A,IntegerOrder)\" and A2: \"A\\<noteq>0\"\n  shows \n  \"HasAmaximum(IntegerOrder,A)\"\n  \"Maximum(IntegerOrder,A) \\<in> A\"\n  \"Maximum(IntegerOrder,A) \\<in> \\<int>\"\n  \"\\<forall>x\\<in>A. x \\<lsq> Maximum(IntegerOrder,A)\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"IntegerOrder {is total on} \\<int>\"\n    \"trans(IntegerOrder)\" and\n    I: \"IntegerOrder \\<subseteq> \\<int>\\<times>\\<int>\" and\n    \"\\<forall>A. IsBounded(A,IntegerOrder) \\<and> A\\<noteq>0 \\<longrightarrow> HasAmaximum(IntegerOrder,A)\"\n    \"A\\<noteq>0\"  \"IsBoundedAbove(A,IntegerOrder)\"\n    using Int_ZF_2_T1 Int_ZF_2_L6 Int_ZF_2_L1B Int_bounded_have_max_min\n    by auto\n  then show \"HasAmaximum(IntegerOrder,A)\"\n    by (rule Order_ZF_4_L11A)\n  then show \n    II: \"Maximum(IntegerOrder,A) \\<in> A\" and\n    \"\\<forall>x\\<in>A. x \\<lsq> Maximum(IntegerOrder,A)\"\n    using Int_ZF_2_L4 Order_ZF_4_L3 by auto\n  from I A1 have \"A \\<subseteq> \\<int>\" by (rule Order_ZF_3_L1A)\n  with II show \"Maximum(IntegerOrder,A) \\<in> \\<int>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 795
    },
    "723": {
        "type": "lemma",
        "text": "text\\<open>A set defined by separation over a bounded set attains its maximum\n  and minimum.\\<close>\n",
        "assumes": "assumes A1: \"IsBounded(A,IntegerOrder)\" and A2: \"A\\<noteq>0\"\n  and A3: \"\\<forall>q\\<in>\\<int>. F(q) \\<in> \\<int>\"\n  and A4: \"K = {F(q). q \\<in> A}\"\n  ",
        "using": [
            "Int_bounded_iff_fin",
            "Int_fin_have_max_min",
            "Order_ZF_4_L7",
            "Order_ZF_4_L8A",
            "IsBounded_def"
        ],
        "statement": "lemma (in int0) Int_ZF_1_4_L1:\n  assumes A1: \"IsBounded(A,IntegerOrder)\" and A2: \"A\\<noteq>0\"\n  and A3: \"\\<forall>q\\<in>\\<int>. F(q) \\<in> \\<int>\"\n  and A4: \"K = {F(q). q \\<in> A}\"\n  shows\n  \"HasAmaximum(IntegerOrder,K)\"\n  \"HasAminimum(IntegerOrder,K)\"  \n  \"Maximum(IntegerOrder,K) \\<in> K\"\n  \"Minimum(IntegerOrder,K) \\<in> K\"\n  \"Maximum(IntegerOrder,K) \\<in> \\<int>\"\n  \"Minimum(IntegerOrder,K) \\<in> \\<int>\"\n  \"\\<forall>q\\<in>A. F(q) \\<lsq> Maximum(IntegerOrder,K)\"\n  \"\\<forall>q\\<in>A. Minimum(IntegerOrder,K) \\<lsq> F(q)\"\n  \"IsBounded(K,IntegerOrder)\"\n",
        "proof": "proof -\n  from A1 have \"A \\<in> Fin(\\<int>)\" using Int_bounded_iff_fin\n    by simp\n  with A3 have \"{F(q). q \\<in> A} \\<in> Fin(\\<int>)\"\n    by (rule fin_image_fin)\n  with A2 A4 have T1: \"K \\<in> Fin(\\<int>)\"  \"K\\<noteq>0\" by auto\n  then show T2: \n    \"HasAmaximum(IntegerOrder,K)\"\n    \"HasAminimum(IntegerOrder,K)\"  \n    and \"Maximum(IntegerOrder,K) \\<in> K\"\n    \"Minimum(IntegerOrder,K) \\<in> K\"\n    \"Maximum(IntegerOrder,K) \\<in> \\<int>\"\n    \"Minimum(IntegerOrder,K) \\<in> \\<int>\"\n    using Int_fin_have_max_min by auto\n  { fix q assume \"q\\<in>A\" \n    with A4 have \"F(q) \\<in> K\" by auto\n    with T1 have \n      \"F(q) \\<lsq> Maximum(IntegerOrder,K)\"\n      \"Minimum(IntegerOrder,K) \\<lsq> F(q)\"\n      using Int_fin_have_max_min by auto\n  } then show \n      \"\\<forall>q\\<in>A. F(q) \\<lsq> Maximum(IntegerOrder,K)\"\n      \"\\<forall>q\\<in>A. Minimum(IntegerOrder,K) \\<lsq> F(q)\"\n    by auto\n  from T2 show \"IsBounded(K,IntegerOrder)\"\n    using Order_ZF_4_L7 Order_ZF_4_L8A IsBounded_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 796
    },
    "724": {
        "type": "lemma",
        "text": "text\\<open>A three element set has a maximume and minimum.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "Finite_ZF_1_L2A"
        ],
        "statement": "lemma (in int0) Int_ZF_1_4_L1A: assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"\n  shows \n  \"Maximum(IntegerOrder,{a,b,c}) \\<in>  \\<int>\"\n  \"a \\<lsq> Maximum(IntegerOrder,{a,b,c})\"\n  \"b \\<lsq> Maximum(IntegerOrder,{a,b,c})\"\n  \"c \\<lsq> Maximum(IntegerOrder,{a,b,c})\"\n  ",
        "proof": "using assms Int_ZF_2_T1 Finite_ZF_1_L2A by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 797
    },
    "725": {
        "type": "lemma",
        "text": "text\\<open>Integer functions attain maxima and minima over intervals.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"a\\<lsq>b\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_2_L1B",
            "Order_ZF_2_L6",
            "Int_ZF_4_L8",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_2_L6",
            "Int_fin_have_max_min",
            "func_imagedef"
        ],
        "statement": "lemma (in int0) Int_ZF_1_4_L2:\n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"a\\<lsq>b\"\n  shows\n  \"maxf(f,a..b) \\<in> \\<int>\"\n  \"\\<forall>c \\<in> a..b. f`(c) \\<lsq> maxf(f,a..b)\"\n  \"\\<exists>c \\<in> a..b. f`(c) = maxf(f,a..b)\"\n  \"minf(f,a..b) \\<in> \\<int>\"\n  \"\\<forall>c \\<in> a..b. minf(f,a..b) \\<lsq> f`(c)\"\n  \"\\<exists>c \\<in> a..b. f`(c) = minf(f,a..b)\"\n",
        "proof": "proof -\n  from A2 have T: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"a..b \\<subseteq> \\<int>\"\n    using Int_ZF_2_L1A Int_ZF_2_L1B Order_ZF_2_L6 \n    by auto\n  with A1 A2 have\n    \"Maximum(IntegerOrder,f``(a..b)) \\<in> f``(a..b)\" \n    \"\\<forall>x\\<in>f``(a..b). x \\<lsq> Maximum(IntegerOrder,f``(a..b))\"\n    \"Maximum(IntegerOrder,f``(a..b)) \\<in> \\<int>\"\n    \"Minimum(IntegerOrder,f``(a..b)) \\<in> f``(a..b)\" \n    \"\\<forall>x\\<in>f``(a..b). Minimum(IntegerOrder,f``(a..b)) \\<lsq> x\"\n    \"Minimum(IntegerOrder,f``(a..b)) \\<in> \\<int>\"\n    using Int_ZF_4_L8 Int_ZF_2_T1 group3.OrderedGroup_ZF_2_L6\n      Int_fin_have_max_min by auto\n  with A1 T show\n    \"maxf(f,a..b) \\<in> \\<int>\"\n    \"\\<forall>c \\<in> a..b. f`(c) \\<lsq> maxf(f,a..b)\"\n    \"\\<exists>c \\<in> a..b. f`(c) = maxf(f,a..b)\"\n    \"minf(f,a..b) \\<in> \\<int>\"\n    \"\\<forall>c \\<in> a..b. minf(f,a..b) \\<lsq> f`(c)\"\n    \"\\<exists>c \\<in> a..b. f`(c) = minf(f,a..b)\"\n    using func_imagedef by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 798
    },
    "726": {
        "type": "lemma",
        "text": "text\\<open>The set of positive integers is closed under addition.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L13"
        ],
        "statement": "lemma (in int0) pos_int_closed_add: \n  shows \"\\<int>\\<^sub>+ {is closed under} IntegerAddition\"\n  ",
        "proof": "using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L13 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 799
    },
    "727": {
        "type": "lemma",
        "text": "text\\<open>Subsets of \\<open>\\<int>\\<^sup>+\\<close> are bounded below.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<int>\\<^sup>+\" \n  ",
        "using": [
            "assms",
            "Int_ZF_1_5_L1",
            "Order_ZF_3_L12"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L1A: assumes \"A \\<subseteq> \\<int>\\<^sup>+\" \n  shows \"IsBoundedBelow(A,IntegerOrder)\"\n  ",
        "proof": "using assms Int_ZF_1_5_L1 Order_ZF_3_L12 by blast\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 802
    },
    "728": {
        "type": "lemma",
        "text": "text\\<open>Subsets of \\<open>\\<int>\\<^sub>+\\<close> are bounded below.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<int>\\<^sub>+\" \n  ",
        "using": [
            "A1",
            "Int_ZF_1_5_L1",
            "Order_ZF_3_L12"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L1B: assumes A1: \"A \\<subseteq> \\<int>\\<^sub>+\" \n  shows \"IsBoundedBelow(A,IntegerOrder)\"\n  ",
        "proof": "using A1 Int_ZF_1_5_L1 Order_ZF_3_L12 by blast \n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 803
    },
    "729": {
        "type": "lemma",
        "text": "text\\<open>Every nonempty subset of positive integers has a mimimum.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<int>\\<^sub>+\" and \"A \\<noteq> 0\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_5_L1B",
            "int_bounded_below_has_min"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L1C: assumes \"A \\<subseteq> \\<int>\\<^sub>+\" and \"A \\<noteq> 0\"\n  shows \n  \"HasAminimum(IntegerOrder,A)\"\n  \"Minimum(IntegerOrder,A) \\<in> A\"\n  \"\\<forall>x\\<in>A. Minimum(IntegerOrder,A) \\<lsq> x\"\n  ",
        "proof": "using assms Int_ZF_1_5_L1B int_bounded_below_has_min by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 804
    },
    "730": {
        "type": "lemma",
        "text": "text\\<open>Infinite subsets of $Z^+$ do not have a maximum - If $A\\subseteq Z^+$\n  then for every integer we can find one in the set that is not smaller.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<int>\\<^sup>+\"  and A2: \"A \\<notin> Fin(\\<int>)\" and A3: \"D\\<in>\\<int>\"\n  ",
        "using": [
            "Nonnegative_def",
            "Int_ZF_2_L19",
            "Int_ZF_1_5_L1A",
            "IsBounded_def",
            "Int_bounded_iff_fin"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L2:\n  assumes A1: \"A \\<subseteq> \\<int>\\<^sup>+\"  and A2: \"A \\<notin> Fin(\\<int>)\" and A3: \"D\\<in>\\<int>\"\n  shows \"\\<exists>n\\<in>A. D\\<lsq>n\"\n",
        "proof": "proof -\n  { assume \"\\<forall>n\\<in>A. \\<not>(D\\<lsq>n)\" \n    moreover from A1 A3 have \"D\\<in>\\<int>\"  \"\\<forall>n\\<in>A. n\\<in>\\<int>\" \n      using Nonnegative_def by auto\n    ultimately have \"\\<forall>n\\<in>A. n\\<lsq>D\"\n      using Int_ZF_2_L19 by blast\n    hence \"\\<forall>n\\<in>A. \\<langle>n,D\\<rangle> \\<in> IntegerOrder\" by simp\n    then have \"IsBoundedAbove(A,IntegerOrder)\"\n      by (rule Order_ZF_3_L10)\n    with A1 have \"IsBounded(A,IntegerOrder)\"\n      using Int_ZF_1_5_L1A IsBounded_def by simp\n    with A2 have False using Int_bounded_iff_fin by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 805
    },
    "731": {
        "type": "lemma",
        "text": "text\\<open>An integer is either positive, zero, or its opposite is postitive.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrdGroup_decomp"
        ],
        "statement": "lemma (in int0) Int_decomp: assumes \"m\\<in>\\<int>\"\n  shows \"Exactly_1_of_3_holds (m=\\<zero>,m\\<in>\\<int>\\<^sub>+,(\\<rm>m)\\<in>\\<int>\\<^sub>+)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrdGroup_decomp \n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 807
    },
    "732": {
        "type": "lemma",
        "text": "text\\<open>An integer is zero, positive, or it's inverse is positive.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L14"
        ],
        "statement": "lemma (in int0) int_decomp_cases: assumes \"m\\<in>\\<int>\"\n  shows \"m=\\<zero> \\<or> m\\<in>\\<int>\\<^sub>+ \\<or> (\\<rm>m) \\<in> \\<int>\\<^sub>+\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L14\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 808
    },
    "733": {
        "type": "lemma",
        "text": "text\\<open>An integer is in the positive set iff it is greater or equal one.\\<close>\n",
        "assumes": "",
        "using": [
            "PositiveSet_def",
            "Int_ZF_4_L1B",
            "int_zero_one_are_int",
            "Int_ZF_1_T2",
            "group0.group0_2_L2",
            "Int_ZF_2_L1A",
            "Int_ZF_2_L16C"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L3: shows \"m\\<in>\\<int>\\<^sub>+ \\<longleftrightarrow> \\<one>\\<lsq>m\"\n",
        "proof": "proof\n  assume \"m\\<in>\\<int>\\<^sub>+\" then have \"\\<zero>\\<lsq>m\"  \"m\\<noteq>\\<zero>\"\n    using PositiveSet_def by auto\n  then have \"\\<zero>\\<ra>\\<one> \\<lsq> m\" \n    using Int_ZF_4_L1B by auto\n  then show \"\\<one>\\<lsq>m\" \n    using int_zero_one_are_int Int_ZF_1_T2 group0.group0_2_L2\n    by simp\nnext assume \"\\<one>\\<lsq>m\"\n  then have \"m\\<in>\\<int>\"  \"\\<zero>\\<lsq>m\"  \"m\\<noteq>\\<zero>\"\n    using Int_ZF_2_L1A Int_ZF_2_L16C by auto\n  then show \"m\\<in>\\<int>\\<^sub>+\" using PositiveSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 809
    },
    "734": {
        "type": "lemma",
        "text": "text\\<open>The set of positive integers is closed under multiplication.\n  The unfolded form.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\\<^sub>+\"  \"b\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_5_L3",
            "Int_ZF_1_3_L3"
        ],
        "statement": "lemma (in int0) pos_int_closed_mul_unfold: \n  assumes \"a\\<in>\\<int>\\<^sub>+\"  \"b\\<in>\\<int>\\<^sub>+\"\n  shows \"a\\<cdot>b \\<in> \\<int>\\<^sub>+\"\n  ",
        "proof": "using assms Int_ZF_1_5_L3 Int_ZF_1_3_L3 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 810
    },
    "735": {
        "type": "lemma",
        "text": "text\\<open>The set of positive integers is closed under multiplication.\\<close>\n",
        "assumes": "",
        "using": [
            "pos_int_closed_mul_unfold",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in int0) pos_int_closed_mul: shows\n  \"\\<int>\\<^sub>+ {is closed under} IntegerMultiplication\"\n  ",
        "proof": "using pos_int_closed_mul_unfold IsOpClosed_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 811
    },
    "736": {
        "type": "lemma",
        "text": "text\\<open>It is an overkill to prove that the ring of integers has no zero\n  divisors this way, but why not?\\<close>\n",
        "assumes": "",
        "using": [
            "pos_int_closed_mul",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_3_L3"
        ],
        "statement": "lemma (in int0) int_has_no_zero_divs: \n  shows \"HasNoZeroDivs(\\<int>,IntegerAddition,IntegerMultiplication)\"\n  ",
        "proof": "using pos_int_closed_mul Int_ZF_1_3_T1 ring1.OrdRing_ZF_3_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 812
    },
    "737": {
        "type": "lemma",
        "text": "text\\<open>Nonnegative integers are positive ones plus zero.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L24"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L3A: shows \"\\<int>\\<^sup>+ = \\<int>\\<^sub>+ \\<union> {\\<zero>}\"\n  ",
        "proof": "using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L24 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 813
    },
    "738": {
        "type": "lemma",
        "text": "text\\<open>Absolute value is identity on positive integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\\<^sub>+\" ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L2B"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L4A: \n  assumes \"a\\<in>\\<int>\\<^sub>+\" shows \"abs(a) = a\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L2B\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 815
    },
    "739": {
        "type": "lemma",
        "text": "text\\<open>One and two are in \\<open>\\<int>\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "int_zero_one_are_int",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_1_5_L3",
            "Int_ZF_2_L16B"
        ],
        "statement": "lemma (in int0) int_one_two_are_pos: shows \"\\<one> \\<in> \\<int>\\<^sub>+\"  \"\\<two> \\<in> \\<int>\\<^sub>+\"\n  ",
        "proof": "using int_zero_one_are_int int_ord_is_refl refl_def Int_ZF_1_5_L3\n  Int_ZF_2_L16B by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 816
    },
    "740": {
        "type": "lemma",
        "text": "text\\<open>The image of \\<open>\\<int>\\<^sub>+\\<close> by a function defined on integers \n  is not empty.\\<close>\n",
        "assumes": "assumes A1: \"f : \\<int>\\<rightarrow>X\"\n  ",
        "using": [
            "PositiveSet_def",
            "int_one_two_are_pos",
            "func_imagedef"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L5: assumes A1: \"f : \\<int>\\<rightarrow>X\"\n  shows \"f``(\\<int>\\<^sub>+) \\<noteq> 0\"\n",
        "proof": "proof -\n  have \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" using PositiveSet_def by auto\n  with A1 show \"f``(\\<int>\\<^sub>+) \\<noteq> 0\"\n    using int_one_two_are_pos func_imagedef by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 817
    },
    "741": {
        "type": "lemma",
        "text": "text\\<open>If $n$ is positive, then $n-1$ is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_1_5_L3",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L4",
            "int_ord_transl_inv",
            "int_ord_is_refl",
            "refl_def",
            "Order_ZF_2_L1B",
            "Int_ZF_2_L1B",
            "Order_ZF_2_L6"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L6: assumes A1: \"n \\<in> \\<int>\\<^sub>+\"\n  shows \n  \"\\<zero> \\<lsq> n\\<rs>\\<one>\"\n  \"\\<zero> \\<in> \\<zero>..(n\\<rs>\\<one>)\"\n  \"\\<zero>..(n\\<rs>\\<one>) \\<subseteq> \\<int>\"\n",
        "proof": "proof -\n  from A1 have \"\\<one> \\<lsq> n\"  \"(\\<rm>\\<one>) \\<in> \\<int>\"\n    using Int_ZF_1_5_L3 int_zero_one_are_int Int_ZF_1_1_L4 \n    by auto\n  then have \"\\<one>\\<rs>\\<one> \\<lsq> n\\<rs>\\<one>\"\n    using int_ord_transl_inv by simp\n  then show \"\\<zero> \\<lsq> n\\<rs>\\<one>\"\n    using int_zero_one_are_int Int_ZF_1_1_L4 by simp\n  then show \"\\<zero> \\<in> \\<zero>..(n\\<rs>\\<one>)\"\n    using int_zero_one_are_int int_ord_is_refl refl_def Order_ZF_2_L1B\n    by simp\n  show \"\\<zero>..(n\\<rs>\\<one>) \\<subseteq> \\<int>\"\n    using Int_ZF_2_L1B Order_ZF_2_L6 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 818
    },
    "742": {
        "type": "lemma",
        "text": "text\\<open>Intgers greater than one in \\<open>\\<int>\\<^sub>+\\<close> belong to \\<open>\\<int>\\<^sub>+\\<close>.\n  This is a property of ordered groups and follows from \n  \\<open>OrderedGroup_ZF_1_L19\\<close>, but Isabelle's simplifier has problems \n  using that result directly, so we reprove it specifically for integers.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<int>\\<^sub>+\" and \"a\\<lsq>b\"\n  ",
        "using": [
            "Int_ZF_1_5_L3"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L7:  assumes \"a \\<in> \\<int>\\<^sub>+\" and \"a\\<lsq>b\"\n  shows \"b \\<in> \\<int>\\<^sub>+\"\n",
        "proof": "proof-\n  from assms have \"\\<one>\\<lsq>a\"  \"a\\<lsq>b\"\n    using Int_ZF_1_5_L3 by auto\n  then have \"\\<one>\\<lsq>b\" by (rule Int_order_transitive)\n  then show \"b \\<in> \\<int>\\<^sub>+\" using Int_ZF_1_5_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 819
    },
    "743": {
        "type": "lemma",
        "text": "text\\<open>For any integer $m$ the greater of $m$ and $1$ is a positive\n  integer that is greater or equal than $m$. If we add $1$ to it we\n  get a positive integer that is strictly greater than $m$.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "int_zero_not_one",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_3_L12"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L7B: assumes \"a\\<in>\\<int>\"\n  shows \n  \"a \\<lsq> GreaterOf(IntegerOrder,\\<one>,a)\"\n  \"GreaterOf(IntegerOrder,\\<one>,a) \\<in> \\<int>\\<^sub>+\"\n  \"GreaterOf(IntegerOrder,\\<one>,a) \\<ra> \\<one> \\<in> \\<int>\\<^sub>+\"\n  \"a \\<lsq> GreaterOf(IntegerOrder,\\<one>,a) \\<ra> \\<one>\"  \n  \"a \\<noteq> GreaterOf(IntegerOrder,\\<one>,a) \\<ra> \\<one>\"\n  ",
        "proof": "using assms int_zero_not_one Int_ZF_1_3_T1 ring1.OrdRing_ZF_3_L12\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 821
    },
    "744": {
        "type": "lemma",
        "text": "text\\<open>The opposite of an element of \\<open>\\<int>\\<^sub>+\\<close> cannot belong to\n  \\<open>\\<int>\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L20"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L8: assumes \"a \\<in> \\<int>\\<^sub>+\"\n  shows \"(\\<rm>a) \\<notin> \\<int>\\<^sub>+\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L20\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 822
    },
    "745": {
        "type": "lemma",
        "text": "text\\<open>A theorem about odd extensions. Recall from \\<open>OrdereGroup_ZF.thy\\<close>\n  that the odd extension of an integer function $f$ defined on \\<open>\\<int>\\<^sub>+\\<close> \n  is the odd function on \\<open>\\<int>\\<close> equal to $f$ on \\<open>\\<int>\\<^sub>+\\<close>. \n  First we show that the odd extension is defined on \\<open>\\<int>\\<close>.\\<close>\n",
        "assumes": "assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.odd_ext_props"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L10: assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\"\n  shows \"OddExtension(\\<int>,IntegerAddition,IntegerOrder,f) : \\<int>\\<rightarrow>\\<int>\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.odd_ext_props by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 824
    },
    "746": {
        "type": "lemma",
        "text": "text\\<open>On \\<open>\\<int>\\<^sub>+\\<close>, the odd extension of $f$ is the same as $f$.\\<close>\n",
        "assumes": "assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a \\<in> \\<int>\\<^sub>+\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.odd_ext_props"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L11: assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a \\<in> \\<int>\\<^sub>+\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  shows \"g`(a) = f`(a)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.odd_ext_props by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 825
    },
    "747": {
        "type": "lemma",
        "text": "text\\<open>On \\<open>\\<sm>\\<int>\\<^sub>+\\<close>, the value of the odd extension of $f$ \n  is the negative of $f(-a)$.\\<close>\n",
        "assumes": "assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a \\<in> (\\<sm>\\<int>\\<^sub>+)\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.odd_ext_props"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L12:  \n  assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a \\<in> (\\<sm>\\<int>\\<^sub>+)\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  shows \"g`(a) = \\<rm>(f`(\\<rm>a))\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.odd_ext_props by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 826
    },
    "748": {
        "type": "lemma",
        "text": "text\\<open>Odd extensions are odd on \\<open>\\<int>\\<close>.\\<close>\n",
        "assumes": "assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a\\<in>\\<int>\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.oddext_is_odd"
        ],
        "statement": "lemma (in int0) int_oddext_is_odd:\n  assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a\\<in>\\<int>\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  shows \"g`(\\<rm>a) = \\<rm>(g`(a))\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.oddext_is_odd by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 827
    },
    "749": {
        "type": "lemma",
        "text": "text\\<open>Alternative definition of an odd function.\\<close>\n",
        "assumes": "assumes A1: \"f: \\<int>\\<rightarrow>\\<int>\" ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "group0.group0_6_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L13:  assumes A1: \"f: \\<int>\\<rightarrow>\\<int>\" shows \n  \"(\\<forall>a\\<in>\\<int>. f`(\\<rm>a) = (\\<rm>f`(a))) \\<longleftrightarrow> (\\<forall>a\\<in>\\<int>. (\\<rm>(f`(\\<rm>a))) = f`(a))\"\n  ",
        "proof": "using assms Int_ZF_1_T2 group0.group0_6_L2 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 828
    },
    "750": {
        "type": "lemma",
        "text": "text\\<open>Another way of expressing the fact that odd extensions are odd.\\<close>\n",
        "assumes": "assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a\\<in>\\<int>\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.oddext_is_odd_alt"
        ],
        "statement": "lemma (in int0) int_oddext_is_odd_alt:\n  assumes \"f : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" and \"a\\<in>\\<int>\" and\n  \"g = OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  shows \"(\\<rm>g`(\\<rm>a)) = g`(a)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.oddext_is_odd_alt by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 829
    },
    "751": {
        "type": "lemma",
        "text": "text\\<open>If an image of a set by a function with infinite positive limit \n  is bounded above, then the set itself is bounded above.\\<close>\n",
        "assumes": "assumes \"f: \\<int>\\<rightarrow>\\<int>\" and\n  \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and \"A \\<subseteq> \\<int>\" and\n  \"IsBoundedAbove(f``(A),IntegerOrder)\"\n  ",
        "using": [
            "assms",
            "int_not_trivial",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_7_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L1: assumes \"f: \\<int>\\<rightarrow>\\<int>\" and\n  \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and \"A \\<subseteq> \\<int>\" and\n  \"IsBoundedAbove(f``(A),IntegerOrder)\"\n  shows \"IsBoundedAbove(A,IntegerOrder)\"\n  ",
        "proof": "using assms int_not_trivial Int_ZF_2_T1 group3.OrderedGroup_ZF_7_L1\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 830
    },
    "752": {
        "type": "lemma",
        "text": "text\\<open>If an image of a set defined by separation \n  by a integer function with infinite negative limit \n  is bounded below, then the set itself is bounded above.\n  This is dual to \\<open> Int_ZF_1_6_L2\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"X\\<noteq>0\" and A2: \"f: \\<int>\\<rightarrow>\\<int>\" and \n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(\\<rm>y) \\<lsq> a\" and\n  A4: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int>  \\<and> L \\<lsq> f`(b(x))\"\n  ",
        "using": [
            "int_not_trivial",
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L3: assumes A1: \"X\\<noteq>0\" and A2: \"f: \\<int>\\<rightarrow>\\<int>\" and \n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(\\<rm>y) \\<lsq> a\" and\n  A4: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int>  \\<and> L \\<lsq> f`(b(x))\"\n  shows \"\\<exists>l.\\<forall>x\\<in>X. l \\<lsq> b(x)\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?P = \"IntegerAddition\"\n  let ?r = \"IntegerOrder\"\n  from A1 A2 A3 A4 have \n    \"group3(?G, ?P, ?r)\" \n    \"?r {is total on} ?G\" \n    \"?G \\<noteq> {TheNeutralElement(?G, ?P)}\"\n    \"X\\<noteq>0\"  \"f: ?G\\<rightarrow>?G\"\n    \"\\<forall>a\\<in>?G. \\<exists>b\\<in>PositiveSet(?G, ?P, ?r). \\<forall>y. \n    \\<langle>b, y\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>f`(GroupInv(?G, ?P)`(y)),a\\<rangle> \\<in> ?r\"\n    \"\\<forall>x\\<in>X. b(x) \\<in> ?G \\<and> \\<langle>L,f`(b(x))\\<rangle> \\<in> ?r\"\n    using int_not_trivial Int_ZF_2_T1 by auto\n  then have \"\\<exists>l. \\<forall>x\\<in>X. \\<langle>l, b(x)\\<rangle> \\<in> ?r\" by (rule group3.OrderedGroup_ZF_7_L3)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 832
    },
    "753": {
        "type": "lemma",
        "text": "text\\<open>The next lemma combines \\<open>Int_ZF_1_6_L2\\<close> and \n  \\<open>Int_ZF_1_6_L3\\<close> to show that if the image of a set \n  defined by separation by a function with infinite limits is bounded,\n  then the set itself is bounded. The proof again uses directly a fact from\n  \\<open>OrderedGroup_ZF\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"X\\<noteq>0\" and A2: \"f: \\<int>\\<rightarrow>\\<int>\" and \n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and\n  A4: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(\\<rm>y) \\<lsq> a\" and\n  A5: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int> \\<and> f`(b(x)) \\<lsq> U \\<and> L \\<lsq> f`(b(x))\"\n  ",
        "using": [
            "int_not_trivial",
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L4:\n  assumes A1: \"X\\<noteq>0\" and A2: \"f: \\<int>\\<rightarrow>\\<int>\" and \n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and\n  A4: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(\\<rm>y) \\<lsq> a\" and\n  A5: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int> \\<and> f`(b(x)) \\<lsq> U \\<and> L \\<lsq> f`(b(x))\"\n  shows \"\\<exists>M.\\<forall>x\\<in>X. abs(b(x)) \\<lsq> M\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?P = \"IntegerAddition\"\n  let ?r = \"IntegerOrder\"\n  from A1 A2 A3 A4 A5 have\n    \"group3(?G, ?P, ?r)\" \n    \"?r {is total on} ?G\" \n    \"?G \\<noteq> {TheNeutralElement(?G, ?P)}\"\n    \"X\\<noteq>0\"  \"f: ?G\\<rightarrow>?G\"\n    \"\\<forall>a\\<in>?G. \\<exists>b\\<in>PositiveSet(?G, ?P, ?r). \\<forall>y. \\<langle>b, y\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>a, f`(y)\\<rangle> \\<in> ?r\"\n    \"\\<forall>a\\<in>?G. \\<exists>b\\<in>PositiveSet(?G, ?P, ?r). \\<forall>y. \n    \\<langle>b, y\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>f`(GroupInv(?G, ?P)`(y)),a\\<rangle> \\<in> ?r\"\n    \"\\<forall>x\\<in>X. b(x) \\<in> ?G \\<and> \\<langle>L,f`(b(x))\\<rangle> \\<in> ?r \\<and> \\<langle>f`(b(x)), U\\<rangle> \\<in> ?r\"\n    using int_not_trivial Int_ZF_2_T1 by auto\n  then have \"\\<exists>M. \\<forall>x\\<in>X. \\<langle>AbsoluteValue(?G, ?P, ?r) ` b(x), M\\<rangle> \\<in> ?r\"\n    by (rule group3.OrderedGroup_ZF_7_L4)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 833
    },
    "754": {
        "type": "lemma",
        "text": "text\\<open>If a function is larger than some constant for arguments large\n  enough, then the image of a set that is bounded below is bounded below.\n  This is not true for ordered groups in general, but only for those for which\n  bounded sets are finite.\n  This does not require the function to have infinite limit, but such \n  functions do have this property.\\<close>\n",
        "assumes": "assumes A1: \"f: \\<int>\\<rightarrow>\\<int>\" and A2: \"N\\<in>\\<int>\" and\n  A3: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> L \\<lsq> f`(m)\" and \n  A4: \"IsBoundedBelow(A,IntegerOrder)\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "Int_ZF_2_L1C",
            "Order_ZF_1_L5",
            "Order_ZF_3_L16",
            "Int_bounded_iff_fin",
            "Finite1_L6A",
            "IsBounded_def",
            "func_imagedef",
            "Int_ZF_2_L6",
            "Int_ZF_2_L1B",
            "Order_ZF_3_L6"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L5:\n  assumes A1: \"f: \\<int>\\<rightarrow>\\<int>\" and A2: \"N\\<in>\\<int>\" and\n  A3: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> L \\<lsq> f`(m)\" and \n  A4: \"IsBoundedBelow(A,IntegerOrder)\"\n  shows \"IsBoundedBelow(f``(A),IntegerOrder)\"\n",
        "proof": "proof -\n  from A2 A4 have \"A = {x\\<in>A. x\\<lsq>N} \\<union> {x\\<in>A. N\\<lsq>x}\"\n    using Int_ZF_2_T1 Int_ZF_2_L1C Order_ZF_1_L5 \n    by simp\n  moreover have \n    \"f``({x\\<in>A. x\\<lsq>N} \\<union> {x\\<in>A. N\\<lsq>x}) =\n    f``{x\\<in>A. x\\<lsq>N} \\<union> f``{x\\<in>A. N\\<lsq>x}\"\n    by (rule image_Un)\n  ultimately have \"f``(A) = f``{x\\<in>A. x\\<lsq>N} \\<union> f``{x\\<in>A. N\\<lsq>x}\"\n    by simp\n  moreover have \"IsBoundedBelow(f``{x\\<in>A. x\\<lsq>N},IntegerOrder)\"\n  proof -\n    let ?B = \"{x\\<in>A. x\\<lsq>N}\"\n    from A4 have \"?B \\<in> Fin(\\<int>)\"\n      using Order_ZF_3_L16 Int_bounded_iff_fin by auto\n    with A1 have  \"IsBounded(f``(?B),IntegerOrder)\"\n      using Finite1_L6A Int_bounded_iff_fin by simp\n    then show \"IsBoundedBelow(f``(?B),IntegerOrder)\"\n      using IsBounded_def by simp\n  qed\n  moreover have \"IsBoundedBelow(f``{x\\<in>A. N\\<lsq>x},IntegerOrder)\"\n  proof -\n    let ?C = \"{x\\<in>A. N\\<lsq>x}\"\n    from A4 have \"?C \\<subseteq> \\<int>\" using Int_ZF_2_L1C by auto\n    with A1 A3 have \"\\<forall>y \\<in> f``(?C). \\<langle>L,y\\<rangle> \\<in> IntegerOrder\"\n      using func_imagedef by simp\n    then show \"IsBoundedBelow(f``(?C),IntegerOrder)\"\n      by (rule Order_ZF_3_L9)\n  qed\n  ultimately show \"IsBoundedBelow(f``(A),IntegerOrder)\"\n    using Int_ZF_2_T1 Int_ZF_2_L6 Int_ZF_2_L1B Order_ZF_3_L6\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 834
    },
    "755": {
        "type": "lemma",
        "text": "text\\<open>A function that has an infinite limit can be made arbitrarily large\n  on positive integers by adding a constant. This does not actually require\n  the function to have infinite limit, just to be larger than a constant\n  for arguments large enough.\\<close>\n",
        "assumes": "assumes A1: \"N\\<in>\\<int>\" and\n  A2: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> L \\<lsq> f`(m)\" and\n  A3: \"f: \\<int>\\<rightarrow>\\<int>\" and A4: \"K\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_5_L1",
            "Int_ZF_1_5_L5",
            "IsBoundedBelow_def",
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L5",
            "PositiveSet_def",
            "func_imagedef",
            "int_ord_transl_inv",
            "Int_ZF_1_2_L3"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L6: assumes A1: \"N\\<in>\\<int>\" and\n  A2: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> L \\<lsq> f`(m)\" and\n  A3: \"f: \\<int>\\<rightarrow>\\<int>\" and A4: \"K\\<in>\\<int>\"\n  shows \"\\<exists>c\\<in>\\<int>. \\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>c\"\n",
        "proof": "proof -\n  have \"IsBoundedBelow(\\<int>\\<^sub>+,IntegerOrder)\"\n    using Int_ZF_1_5_L1 by simp\n  with A3 A1 A2 have \"IsBoundedBelow(f``(\\<int>\\<^sub>+),IntegerOrder)\"\n    by (rule Int_ZF_1_6_L5)\n  with A1 obtain l where I: \"\\<forall>y\\<in>f``(\\<int>\\<^sub>+). l \\<lsq> y\"\n    using Int_ZF_1_5_L5 IsBoundedBelow_def by auto\n  let ?c = \"K\\<rs>l\"\n  from A3 have \"f``(\\<int>\\<^sub>+) \\<noteq> 0\" using Int_ZF_1_5_L5\n    by simp\n  then have \"\\<exists>y. y \\<in> f``(\\<int>\\<^sub>+)\" by (rule nonempty_has_element)\n  then obtain y where \"y \\<in> f``(\\<int>\\<^sub>+)\" by auto\n  with A4 I have T: \"l \\<in> \\<int>\"  \"?c \\<in> \\<int>\"\n    using Int_ZF_2_L1A Int_ZF_1_1_L5 by auto\n  { fix n assume A5: \"n\\<in>\\<int>\\<^sub>+\"\n    have \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" using PositiveSet_def by auto\n    with A3 I T A5 have \"l \\<ra> ?c \\<lsq> f`(n) \\<ra> ?c\"\n      using func_imagedef int_ord_transl_inv by auto\n     with I T have \"l \\<ra> ?c \\<lsq> f`(n) \\<ra> ?c\"\n      using int_ord_transl_inv by simp\n    with A4 T have \"K \\<lsq>  f`(n) \\<ra> ?c\"\n      using Int_ZF_1_2_L3 by simp\n  } then have \"\\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq>  f`(n) \\<ra> ?c\" by simp\n  with T show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 835
    },
    "756": {
        "type": "lemma",
        "text": "text\\<open>If a function has infinite limit, then we can add such constant\n  such that minimum of those arguments for which the function (plus the constant) \n  is larger than another given constant is greater than a third constant.\n  It is not as complicated as it sounds.\\<close>\n",
        "assumes": "assumes A1: \"f: \\<int>\\<rightarrow>\\<int>\" and A2: \"K\\<in>\\<int>\"  \"N\\<in>\\<int>\" and\n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\"\n  ",
        "using": [
            "Int_ZF_1_5_L4",
            "Int_ZF_2_L4",
            "Int_ZF_1_1_L5",
            "int_ord_is_refl",
            "refl_def",
            "PositiveSet_def",
            "Int_ZF_2_L9C",
            "Int_ZF_1_5_L1C"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L7: \n  assumes A1: \"f: \\<int>\\<rightarrow>\\<int>\" and A2: \"K\\<in>\\<int>\"  \"N\\<in>\\<int>\" and\n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\"\n  shows \"\\<exists>C\\<in>\\<int>. N \\<lsq> Minimum(IntegerOrder,{n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C})\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<exists>C\\<in>\\<int>. \\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> C \\<longrightarrow> N\\<lsq>n\"\n    using Int_ZF_1_5_L4 by simp\n  then obtain C where I: \"C\\<in>\\<int>\" and\n    II: \"\\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> C \\<longrightarrow> N\\<lsq>n\"\n    by auto\n  have \"antisym(IntegerOrder)\" using Int_ZF_2_L4 by simp\n  moreover have \"HasAminimum(IntegerOrder,{n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C})\"\n  proof -\n    from A2 A3 I have \"\\<exists>n\\<in>\\<int>\\<^sub>+.\\<forall>x. n\\<lsq>x \\<longrightarrow> K\\<rs>C \\<lsq> f`(x)\"\n      using Int_ZF_1_1_L5 by simp\n    then obtain n where \n      \"n\\<in>\\<int>\\<^sub>+\" and \"\\<forall>x. n\\<lsq>x \\<longrightarrow> K\\<rs>C \\<lsq>  f`(x)\"\n      by auto\n    with A2 I have \n      \"{n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C} \\<noteq> 0\"\n      \"{n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C} \\<subseteq> \\<int>\\<^sub>+\"\n      using int_ord_is_refl refl_def PositiveSet_def Int_ZF_2_L9C\n      by auto\n    then show \"HasAminimum(IntegerOrder,{n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C})\"\n      using Int_ZF_1_5_L1C by simp\n  qed\n  moreover from II have \n    \"\\<forall>n \\<in> {n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C}. \\<langle>N,n\\<rangle> \\<in> IntegerOrder\" \n    by auto \n  ultimately have \n    \"\\<langle>N,Minimum(IntegerOrder,{n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\\<ra>C})\\<rangle> \\<in> IntegerOrder\"\n    by (rule Order_ZF_4_L12)\n  with I show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 836
    },
    "757": {
        "type": "lemma",
        "text": "text\\<open>Suppose we have an integer expression (a meta-function)$F$ such that \n  $F(p)|p|$ is bounded by a linear function of $|p|$, that is for some integers\n  $A,B$ we have $F(p)|p|\\leq A|p|+B.$ We show that $F$ is then bounded. \n  The proof is easy, we just divide both sides by $|p|$ \n  and take the limit (just kidding).\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>q\\<in>\\<int>. F(q) \\<in> \\<int>\" and \n  A2:  \"\\<forall>q\\<in>\\<int>. F(q)\\<cdot>abs(q) \\<lsq> A\\<cdot>abs(q) \\<ra> B\" and \n  A3: \"A\\<in>\\<int>\"  \"B\\<in>\\<int>\"\n  ",
        "using": [
            "Order_ZF_3_L11",
            "Int_ZF_1_3_L17",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_3_L18",
            "Int_ZF_1_3_L19",
            "Int_ZF_2_L14",
            "Int_ZF_1_3_L15",
            "Int_ZF_2_L15A",
            "Int_ZF_1_2_L7",
            "Int_ZF_1_3_L11",
            "Int_ineq_simpl_positive"
        ],
        "statement": "lemma (in int0) Int_ZF_1_7_L1:\n  assumes A1: \"\\<forall>q\\<in>\\<int>. F(q) \\<in> \\<int>\" and \n  A2:  \"\\<forall>q\\<in>\\<int>. F(q)\\<cdot>abs(q) \\<lsq> A\\<cdot>abs(q) \\<ra> B\" and \n  A3: \"A\\<in>\\<int>\"  \"B\\<in>\\<int>\"\n  shows \"\\<exists>L. \\<forall>p\\<in>\\<int>. F(p) \\<lsq> L\"\n",
        "proof": "proof -\n  let ?I = \"(\\<rm>abs(B))..abs(B)\"\n  let ?K = \"{F(q). q \\<in> ?I}\"\n  let ?M = \"Maximum(IntegerOrder,?K)\"\n  let ?L = \"GreaterOf(IntegerOrder,?M,A\\<ra>\\<one>)\"\n  from A3 A1 have C1:\n    \"IsBounded(?I,IntegerOrder)\"   \n    \"?I \\<noteq> 0\"\n    \"\\<forall>q\\<in>\\<int>. F(q) \\<in> \\<int>\"\n    \"?K = {F(q). q \\<in> ?I}\"\n    using Order_ZF_3_L11 Int_ZF_1_3_L17 by auto\n  then have \"?M \\<in> \\<int>\" by (rule Int_ZF_1_4_L1)\n  with A3 have T1: \"?M \\<lsq> ?L\"  \"A\\<ra>\\<one> \\<lsq> ?L\"\n    using int_zero_one_are_int Int_ZF_1_1_L5 Int_ZF_1_3_L18\n    by auto\n  from C1 have T2: \"\\<forall>q\\<in>?I. F(q) \\<lsq> ?M\"\n    by (rule Int_ZF_1_4_L1)\n  { fix p assume A4: \"p\\<in>\\<int>\" have \"F(p) \\<lsq> ?L\" \n    proof -\n      { assume \"abs(p) \\<lsq> abs(B)\"\n\twith A4 T1 T2 have \"F(p) \\<lsq> ?M\"  \"?M \\<lsq> ?L\"\n\t  using Int_ZF_1_3_L19 by auto\n\tthen have \"F(p) \\<lsq> ?L\" by (rule Int_order_transitive) }\n      moreover\n      { assume A5: \"\\<not>(abs(p) \\<lsq> abs(B))\"\n\tfrom A3 A2 A4 have \n\t  \"A\\<cdot>abs(p) \\<in> \\<int>\"  \"F(p)\\<cdot>abs(p) \\<lsq> A\\<cdot>abs(p) \\<ra> B\"\n\t  using Int_ZF_2_L14 Int_ZF_1_1_L5 by auto\n\tmoreover from A3 A4 A5 have \"B \\<lsq> abs(p)\"\n\t  using Int_ZF_1_3_L15 by simp\n\tultimately have\n\t  \"F(p)\\<cdot>abs(p) \\<lsq> A\\<cdot>abs(p) \\<ra> abs(p)\"\n\t  using Int_ZF_2_L15A by blast\n\twith A3 A4 have \"F(p)\\<cdot>abs(p) \\<lsq> (A\\<ra>\\<one>)\\<cdot>abs(p)\"\n\t  using Int_ZF_2_L14 Int_ZF_1_2_L7 by simp\n\tmoreover from A3 A1 A4 A5 have \n\t  \"F(p) \\<in> \\<int>\"  \"A\\<ra>\\<one> \\<in> \\<int>\"  \"abs(p) \\<in> \\<int>\"\n\t  \"\\<not>(abs(p) \\<lsq> \\<zero>)\"\n\t  using int_zero_one_are_int Int_ZF_1_1_L5 Int_ZF_2_L14 Int_ZF_1_3_L11\n\t  by auto\n\tultimately have \"F(p) \\<lsq> A\\<ra>\\<one>\"\n\t  using Int_ineq_simpl_positive by simp\n\tmoreover from T1 have  \"A\\<ra>\\<one> \\<lsq> ?L\" by simp\n\tultimately have \"F(p) \\<lsq> ?L\" by (rule Int_order_transitive) }\n      ultimately show ?thesis by blast\n    qed\n  } then have \"\\<forall>p\\<in>\\<int>. F(p) \\<lsq> ?L\" by simp\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 838
    },
    "758": {
        "type": "lemma",
        "text": "text\\<open>A lemma about splitting (not really, there is some overlap) \n  the \\<open>\\<int>\\<times>\\<int>\\<close> into six subsets (cases). The subsets are as follows:\n  first and third qaudrant, and second and fourth quadrant farther split\n  by the $b =-a$ line.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrdGroup_6cases"
        ],
        "statement": "lemma (in int0) int_plane_split_in6: assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows\n  \"\\<zero>\\<lsq>a \\<and> \\<zero>\\<lsq>b  \\<or>  a\\<lsq>\\<zero> \\<and> b\\<lsq>\\<zero>  \\<or>  \n  a\\<lsq>\\<zero> \\<and> \\<zero>\\<lsq>b \\<and> \\<zero> \\<lsq> a\\<ra>b  \\<or> a\\<lsq>\\<zero> \\<and> \\<zero>\\<lsq>b \\<and> a\\<ra>b \\<lsq> \\<zero>  \\<or>  \n  \\<zero>\\<lsq>a \\<and> b\\<lsq>\\<zero> \\<and> \\<zero> \\<lsq> a\\<ra>b  \\<or>  \\<zero>\\<lsq>a \\<and> b\\<lsq>\\<zero> \\<and> a\\<ra>b \\<lsq> \\<zero>\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrdGroup_6cases by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 839
    },
    "759": {
        "type": "lemma",
        "text": "text\\<open>We can use theorems proven in the \\<open>group1\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_T2",
            "group1_axioms.intro",
            "group1_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L1: shows \"group1(\\<int>,IntegerAddition)\"\n  ",
        "proof": "using Int_ZF_1_T2 group1_axioms.intro group1_def by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 840
    },
    "760": {
        "type": "lemma",
        "text": "text\\<open>Type information related to the homomorphism difference expression.\\<close>\n",
        "assumes": "assumes \"f\\<in>\\<S>\" and \"n\\<in>\\<int>\" \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L4A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L2: assumes \"f\\<in>\\<S>\" and \"n\\<in>\\<int>\" \"m\\<in>\\<int>\"\n  shows \n  \"m\\<ra>n \\<in> \\<int>\"  \n  \"f`(m\\<ra>n) \\<in> \\<int>\"  \n  \"f`(m) \\<in> \\<int>\"   \"f`(n) \\<in> \\<int>\"\n  \"f`(m) \\<ra> f`(n) \\<in> \\<int>\"  \n  \"HomDiff(\\<int>,IntegerAddition,f,\\<langle> m,n\\<rangle>) \\<in> \\<int>\" \n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_2_L4A\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 841
    },
    "761": {
        "type": "lemma",
        "text": "text\\<open>Type information related to the homomorphism difference expression.\\<close>\n",
        "assumes": "assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"n\\<in>\\<int>\"  \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L4"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L2A: \n  assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"n\\<in>\\<int>\"  \"m\\<in>\\<int>\"\n  shows \n  \"m\\<ra>n \\<in> \\<int>\" \n  \"f`(m\\<ra>n) \\<in> \\<int>\"   \"f`(m) \\<in> \\<int>\"   \"f`(n) \\<in> \\<int>\"\n  \"f`(m) \\<ra> f`(n) \\<in> \\<int>\" \n  \"HomDiff(\\<int>,IntegerAddition,f,\\<langle> m,n\\<rangle>) \\<in> \\<int>\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_2_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 842
    },
    "762": {
        "type": "lemma",
        "text": "text\\<open>Slopes map integers into integers.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\" \n  ",
        "using": [
            "AlmostHoms_def",
            "apply_funtype"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L2B: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\" \n  shows \"f`(m) \\<in> \\<int>\"\n",
        "proof": "proof -\n  from A1 have \"f:\\<int>\\<rightarrow>\\<int>\" using AlmostHoms_def by simp\n  with A2 show \"f`(m) \\<in> \\<int>\" using apply_funtype by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 843
    },
    "763": {
        "type": "lemma",
        "text": "text\\<open>The homomorphism difference in multiplicative notation is defined as\n  the expression $s(m\\cdot n)\\cdot(s(m)\\cdot s(n))^{-1}$. The next lemma \n  shows that \n  in the additive notation used for integers the homomorphism \n  difference is $f(m+n) - f(m) - f(n)$ which we denote as \\<open>\\<delta>(f,m,n)\\<close>.\\<close>\n",
        "assumes": "assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L2A",
            "Int_ZF_1_T2",
            "group0.group0_4_L4A",
            "HomDiff_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L3: \n  assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"HomDiff(\\<int>,IntegerAddition,f,\\<langle> m,n\\<rangle>) = \\<delta>(f,m,n)\"\n  ",
        "proof": "using assms Int_ZF_2_1_L2A Int_ZF_1_T2 group0.group0_4_L4A \n    HomDiff_def by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 844
    },
    "764": {
        "type": "lemma",
        "text": "text\\<open>The homomorphism difference of any integer function is integer.\\<close>\n",
        "assumes": "assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L2A",
            "Int_ZF_2_1_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L3B: \n  assumes \"f:\\<int>\\<rightarrow>\\<int>\" and \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"\\<delta>(f,m,n) \\<in> \\<int>\"\n  ",
        "proof": "using assms Int_ZF_2_1_L2A Int_ZF_2_1_L3 by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 846
    },
    "765": {
        "type": "lemma",
        "text": "text\\<open>The next lemma presents two ways the set of homomorphism differences\n  can be written.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_1_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L4: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\"\n  shows \"{abs(HomDiff(\\<int>,IntegerAddition,f,x)). x \\<in> \\<int>\\<times>\\<int>} =\n  {abs(\\<delta>(f,m,n)). \\<langle> m,n\\<rangle> \\<in> \\<int>\\<times>\\<int>}\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>m\\<in>\\<int>. \\<forall>n\\<in>\\<int>. \n    abs(HomDiff(\\<int>,IntegerAddition,f,\\<langle> m,n\\<rangle>)) = abs(\\<delta>(f,m,n))\"\n    using Int_ZF_2_1_L3 by simp\n  then show ?thesis by (rule ZF1_1_L4A)\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 848
    },
    "766": {
        "type": "lemma",
        "text": "text\\<open>If $f$ maps integers into integers and \n  for all $m,n\\in Z$ we have $|f(m+n) - f(m) - f(n)| \\leq L$ for some $L$,\n  then $f$ is a slope.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\"\n  and A2: \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>. abs(\\<delta>(f,m,n)) \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "Int_ZF_2_1_L2A",
            "Int_ZF_2_1_L3",
            "Int_bounded_iff_fin",
            "AlmostHoms_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L5: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\"\n  and A2: \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>. abs(\\<delta>(f,m,n)) \\<lsq> L\"\n  shows \"f\\<in>\\<S>\"\n",
        "proof": "proof -\n  let ?Abs = \"AbsoluteValue(\\<int>,IntegerAddition,IntegerOrder)\"\n  have \"group3(\\<int>,IntegerAddition,IntegerOrder)\" \n    \"IntegerOrder {is total on} \\<int>\"\n    using Int_ZF_2_T1 by auto\n  moreover from A1 A2 have \n    \"\\<forall>x\\<in>\\<int>\\<times>\\<int>. HomDiff(\\<int>,IntegerAddition,f,x) \\<in> \\<int> \\<and>\n    \\<langle>?Abs`(HomDiff(\\<int>,IntegerAddition,f,x)),L \\<rangle> \\<in> IntegerOrder\"\n    using Int_ZF_2_1_L2A Int_ZF_2_1_L3 by auto\n  ultimately have \n    \"IsBounded({HomDiff(\\<int>,IntegerAddition,f,x). x\\<in>\\<int>\\<times>\\<int>},IntegerOrder)\"\n    by (rule group3.OrderedGroup_ZF_3_L9A)\n  with A1 show \"f \\<in> \\<S>\" using Int_bounded_iff_fin AlmostHoms_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 849
    },
    "767": {
        "type": "lemma",
        "text": "text\\<open>The absolute value of homomorphism difference \n  of a slope $s$ does not exceed \\<open>max\\<delta>(s)\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\" and A2: \"n\\<in>\\<int>\"  \"m\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_1_L2",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_T1",
            "Int_ZF_2_L14",
            "AlmostHoms_def",
            "Int_ZF_2_1_L4",
            "Int_ZF_2_L1A",
            "Int_ZF_1_3_L19"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L7: \n  assumes A1: \"s\\<in>\\<S>\" and A2: \"n\\<in>\\<int>\"  \"m\\<in>\\<int>\"\n  shows \n  \"abs(\\<delta>(s,m,n)) \\<lsq> max\\<delta>(s)\"   \n  \"\\<delta>(s,m,n) \\<in> \\<int>\"   \"max\\<delta>(s) \\<in> \\<int>\"\n  \"(\\<rm>max\\<delta>(s)) \\<lsq> \\<delta>(s,m,n)\"\n",
        "proof": "proof -\n  from A1 A2 show T: \"\\<delta>(s,m,n) \\<in> \\<int>\"\n    using Int_ZF_2_1_L2 Int_ZF_1_1_L5 by simp\n  let ?A = \"{abs(HomDiff(\\<int>,IntegerAddition,s,x)). x\\<in>\\<int>\\<times>\\<int>}\"\n  let ?B = \"{abs(\\<delta>(s,m,n)). \\<langle> m,n\\<rangle> \\<in> \\<int>\\<times>\\<int>}\"\n  let ?d = \"abs(\\<delta>(s,m,n))\"\n  have \"IsLinOrder(\\<int>,IntegerOrder)\" using Int_ZF_2_T1\n    by simp\n  moreover have \"?A \\<in> Fin(\\<int>)\" \n  proof -\n    have \"\\<forall>k\\<in>\\<int>. abs(k) \\<in> \\<int>\" using Int_ZF_2_L14 by simp\n    moreover from A1 have \n      \"{HomDiff(\\<int>,IntegerAddition,s,x). x \\<in> \\<int>\\<times>\\<int>} \\<in> Fin(\\<int>)\"\n      using AlmostHoms_def by simp\n    ultimately show \"?A \\<in> Fin(\\<int>)\" by (rule Finite1_L6C)\n  qed\n  moreover have \"?A\\<noteq>0\" by auto\n  ultimately have \"\\<forall>k\\<in>?A. \\<langle>k,Maximum(IntegerOrder,?A)\\<rangle> \\<in> IntegerOrder\"\n    by (rule Finite_ZF_1_T2)\n  moreover from A1 A2 have \"?d\\<in>?A\" using AlmostHoms_def Int_ZF_2_1_L4\n    by auto\n  ultimately have \"?d \\<lsq> Maximum(IntegerOrder,?A)\" by auto \n  with A1 show \"?d \\<lsq> max\\<delta>(s)\"  \"max\\<delta>(s) \\<in> \\<int>\"\n    using AlmostHoms_def Int_ZF_2_1_L4 Int_ZF_2_L1A \n    by auto\n  with T show \"(\\<rm>max\\<delta>(s)) \\<lsq> \\<delta>(s,m,n)\"\n    using Int_ZF_1_3_L19 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 850
    },
    "768": {
        "type": "lemma",
        "text": "text\\<open>Int \\<open>Group_ZF_3.thy\\<close> we show that finite range functions \n  valued in an abelian group \n  form a normal subgroup of almost homomorphisms. \n  This allows to define the equivalence relation \n  between almost homomorphisms as the relation resulting from dividing \n  by that normal subgroup. \n  Then we show in \\<open>Group_ZF_3_4_L12\\<close> that if the difference of $f$ and $g$ \n  has finite range (actually $f(n)\\cdot g(n)^{-1}$ as we use multiplicative \n  notation \n  in \\<open>Group_ZF_3.thy\\<close>), then $f$ and $g$ are equivalent.\n  The next lemma translates that fact into the notation used in \\<open>int1\\<close> \n  context.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  and A2: \"\\<forall>m\\<in>\\<int>. abs(s`(m)\\<rs>r`(m)) \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_1_L2B",
            "Int_ZF_1_1_L5",
            "Int_bounded_iff_fin",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_L12"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L9: assumes A1: \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  and A2: \"\\<forall>m\\<in>\\<int>. abs(s`(m)\\<rs>r`(m)) \\<lsq> L\"\n  shows \"s \\<sim> r\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"\\<forall>m\\<in>\\<int>. s`(m)\\<rs>r`(m) \\<in> \\<int> \\<and> abs(s`(m)\\<rs>r`(m)) \\<lsq> L\"\n    using Int_ZF_2_1_L2B Int_ZF_1_1_L5 by simp\n  then have\n    \"IsBounded({s`(n)\\<rs>r`(n). n\\<in>\\<int>}, IntegerOrder)\"\n    by (rule Int_ZF_1_3_L20)\n  with A1 show \"s \\<sim> r\" using Int_bounded_iff_fin \n    Int_ZF_2_1_L1 group1.Group_ZF_3_4_L12 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 852
    },
    "769": {
        "type": "lemma",
        "text": "text\\<open>A neccessary condition for two slopes to be almost equal. \n  For slopes the definition postulates the \n  set $\\{f(m)-g(m): m\\in Z\\}$ to be finite. \n  This lemma shows that this implies that\n  $|f(m)-g(m)|$ is bounded (by some integer) as $m$ varies over integers.\n  We also mention here that in this context \\<open>s \\<sim> r\\<close> implies that both\n  $s$ and $r$ are slopes.\\<close>\n",
        "assumes": "assumes \"s \\<sim> r\" \n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_L11",
            "Int_ZF_1_3_L20AA",
            "QuotientGroupRel_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L9A: assumes \"s \\<sim> r\" \n  shows \n  \"\\<exists>L\\<in>\\<int>. \\<forall>m\\<in>\\<int>. abs(s`(m)\\<rs>r`(m)) \\<lsq> L\"\n  \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_4_L11 \n    Int_ZF_1_3_L20AA QuotientGroupRel_def by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 853
    },
    "770": {
        "type": "lemma",
        "text": "text\\<open>Let's recall that the relation of almost equality is an equivalence relation\n  on the set of slopes.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_3_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L9B: shows\n  \"AlEqRel \\<subseteq> \\<S>\\<times>\\<S>\"\n  \"equiv(\\<S>,AlEqRel)\"\n  ",
        "proof": "using Int_ZF_2_1_L1 group1.Group_ZF_3_3_L3 by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 854
    },
    "771": {
        "type": "lemma",
        "text": "text\\<open>Another version of sufficient condition for two slopes to be almost\n  equal: if the difference of two slopes is a finite range function, then\n  they are almost equal.\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" and \n  \"s \\<fp> (\\<fm>r) \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L13",
            "group1.Group_ZF_3_4_L12A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L9C: assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" and \n  \"s \\<fp> (\\<fm>r) \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  shows  \n  \"s \\<sim> r\"  \n  \"r \\<sim> s\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 \n    group1.Group_ZF_3_2_L13 group1.Group_ZF_3_4_L12A\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 855
    },
    "772": {
        "type": "lemma",
        "text": "text\\<open>If two slopes are almost equal, then the difference has finite range.\n  This is the inverse of \\<open>Int_ZF_2_1_L9C\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"s \\<sim> r\"\n  ",
        "using": [
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_L12B",
            "Int_ZF_2_1_L9A",
            "group1.Group_ZF_3_2_L13"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L9D: assumes A1: \"s \\<sim> r\"\n  shows \"s \\<fp> (\\<fm>r) \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?f = \"IntegerAddition\"\n  from A1 have \"AlHomOp1(?G, ?f)`\\<langle>s,GroupInv(AlmostHoms(?G, ?f),AlHomOp1(?G, ?f))`(r)\\<rangle> \n    \\<in> FinRangeFunctions(?G, ?G)\"\n    using Int_ZF_2_1_L1 group1.Group_ZF_3_4_L12B by auto\n  with A1 show \"s \\<fp> (\\<fm>r) \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n    using Int_ZF_2_1_L9A Int_ZF_2_1_L1 group1.Group_ZF_3_2_L13\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 856
    },
    "773": {
        "type": "lemma",
        "text": "text\\<open>What is the value of a composition of slopes?\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" and \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_L2"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L10: \n  assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" and \"m\\<in>\\<int>\"\n  shows \"(s\\<circ>r)`(m) = s`(r`(m))\"  \"s`(r`(m)) \\<in> \\<int>\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_4_L2 by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 857
    },
    "774": {
        "type": "lemma",
        "text": "text\\<open>Negative of a slope is a slope.\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\" ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L13"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L12: assumes \"s\\<in>\\<S>\" shows \"\\<fm>s \\<in> \\<S>\"\n  ",
        "proof": "using assms Int_ZF_1_T2 Int_ZF_2_1_L1 group1.Group_ZF_3_2_L13 \n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 859
    },
    "775": {
        "type": "lemma",
        "text": "text\\<open>Sum of slopes is a slope.\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L16"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L12C: assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  shows \"s\\<fp>r \\<in> \\<S>\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_2_L16\n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 862
    },
    "776": {
        "type": "lemma",
        "text": "text\\<open>A simple but useful identity.\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\" and \"n\\<in>\\<int>\"  \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L2B",
            "Int_ZF_1_2_L9",
            "Int_ZF_1_2_L7"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L13: \n  assumes \"s\\<in>\\<S>\" and \"n\\<in>\\<int>\"  \"m\\<in>\\<int>\"\n  shows \"s`(n\\<cdot>m) \\<ra> (s`(m) \\<ra> \\<delta>(s,n\\<cdot>m,m)) = s`((n\\<ra>\\<one>)\\<cdot>m)\"\n  ",
        "proof": "using assms Int_ZF_1_1_L5 Int_ZF_2_1_L2B Int_ZF_1_2_L9 Int_ZF_1_2_L7\n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 863
    },
    "777": {
        "type": "lemma",
        "text": "text\\<open>Some estimates for the absolute value of a slope at the opposite \n  integer.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_L14",
            "Int_ZF_2_1_L2",
            "Int_ZF_1_1_L5",
            "int_zero_one_are_int",
            "Int_ZF_1_2_L15",
            "Int_triangle_ineq1",
            "Int_ZF_2_1_L7",
            "Int_ZF_2_1_L8",
            "Int_ZF_1_3_L21",
            "Int_ZF_1_2_L3",
            "int_triangle_ineq3",
            "int_ord_transl_inv",
            "Int_ZF_2_L15E"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L14: assumes A1: \"s\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\"\n  shows \n  \"s`(\\<rm>m) = s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<rs> s`(m)\"\n  \"abs(s`(m)\\<ra>s`(\\<rm>m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(s)\"\n  \"abs(s`(\\<rm>m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(s) \\<ra> abs(s`(m))\"\n  \"s`(\\<rm>m) \\<lsq> abs(s`(\\<zero>)) \\<ra> max\\<delta>(s) \\<rs> s`(m)\"\n",
        "proof": "proof -\n  from A1 A2 have T:\n    \"(\\<rm>m) \\<in> \\<int>\"  \"abs(s`(m)) \\<in> \\<int>\"  \"s`(\\<zero>) \\<in> \\<int>\"  \"abs(s`(\\<zero>)) \\<in> \\<int>\"  \n    \"\\<delta>(s,m,\\<rm>m) \\<in> \\<int>\"   \"s`(m) \\<in> \\<int>\"   \"s`(\\<rm>m) \\<in> \\<int>\"  \n    \"(\\<rm>(s`(m))) \\<in> \\<int>\"  \"s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<in> \\<int>\"\n    using Int_ZF_1_1_L4 Int_ZF_2_1_L2B Int_ZF_2_L14 Int_ZF_2_1_L2 \n      Int_ZF_1_1_L5 int_zero_one_are_int by auto\n  with A2 show I: \"s`(\\<rm>m) = s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<rs> s`(m)\"\n    using Int_ZF_1_1_L4 Int_ZF_1_2_L15 by simp\n  from T have \"abs(s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m)) \\<lsq> abs(s`(\\<zero>)) \\<ra> abs(\\<delta>(s,m,\\<rm>m))\"\n    using Int_triangle_ineq1 by simp\n  moreover from A1 A2 T have \"abs(s`(\\<zero>)) \\<ra> abs(\\<delta>(s,m,\\<rm>m)) \\<lsq>  \\<two>\\<cdot>max\\<delta>(s)\"\n    using Int_ZF_2_1_L7 Int_ZF_2_1_L8 Int_ZF_1_3_L21 by simp\n  ultimately have \"abs(s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(s)\"\n    by (rule Int_order_transitive)\n  moreover\n  from I have \"s`(m) \\<ra> s`(\\<rm>m) = s`(m) \\<ra> (s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<rs> s`(m))\"\n    by simp\n  with T have \"abs(s`(m) \\<ra> s`(\\<rm>m)) = abs(s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m))\"\n    using Int_ZF_1_2_L3 by simp\n  ultimately show \"abs(s`(m)\\<ra>s`(\\<rm>m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(s)\"\n    by simp\n  from I have \"abs(s`(\\<rm>m)) = abs(s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<rs> s`(m))\"\n    by simp\n  with T have \n    \"abs(s`(\\<rm>m)) \\<lsq> abs(s`(\\<zero>)) \\<ra> abs(\\<delta>(s,m,\\<rm>m)) \\<ra> abs(s`(m))\"\n    using int_triangle_ineq3 by simp\n  moreover from A1 A2 T have\n    \"abs(s`(\\<zero>)) \\<ra> abs(\\<delta>(s,m,\\<rm>m)) \\<ra> abs(s`(m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(s) \\<ra> abs(s`(m))\"\n    using Int_ZF_2_1_L7 Int_ZF_2_1_L8 Int_ZF_1_3_L21 int_ord_transl_inv by simp\n  ultimately show \"abs(s`(\\<rm>m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(s) \\<ra> abs(s`(m))\"\n    by (rule Int_order_transitive)\n  from T have \"s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<lsq> abs(s`(\\<zero>)) \\<ra> abs(\\<delta>(s,m,\\<rm>m))\"\n    using Int_ZF_2_L15E by simp\n  moreover from A1 A2 T have \n    \"abs(s`(\\<zero>)) \\<ra> abs(\\<delta>(s,m,\\<rm>m)) \\<lsq> abs(s`(\\<zero>)) \\<ra> max\\<delta>(s)\"\n    using Int_ZF_2_1_L7 int_ord_transl_inv by simp\n  ultimately have \"s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<lsq> abs(s`(\\<zero>)) \\<ra> max\\<delta>(s)\"\n    by (rule Int_order_transitive)\n  with T have \n    \"s`(\\<zero>) \\<rs> \\<delta>(s,m,\\<rm>m) \\<rs> s`(m) \\<lsq> abs(s`(\\<zero>)) \\<ra> max\\<delta>(s) \\<rs> s`(m)\"\n    using int_ord_transl_inv by simp\n  with I show \"s`(\\<rm>m) \\<lsq> abs(s`(\\<zero>)) \\<ra> max\\<delta>(s) \\<rs> s`(m)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 864
    },
    "778": {
        "type": "lemma",
        "text": "text\\<open>An identity that expresses the value of an integer function at the opposite\n  integer in terms of the value of that function at the integer, zero, and the \n  homomorphism difference. We have a similar identity in \\<open>Int_ZF_2_1_L14\\<close>, but\n  over there we assume that $f$ is a slope.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L5",
            "int_zero_one_are_int",
            "apply_funtype",
            "Int_ZF_1_2_L15"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L14A: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"\n  shows \"f`(\\<rm>m) = (\\<rm>\\<delta>(f,m,\\<rm>m)) \\<ra> f`(\\<zero>) \\<rs> f`(m)\"\n",
        "proof": "proof -\n  from A1 A2 have T:\n    \"f`(\\<rm>m) \\<in> \\<int>\"  \"\\<delta>(f,m,\\<rm>m) \\<in> \\<int>\"  \"f`(\\<zero>) \\<in> \\<int>\"  \"f`(m) \\<in> \\<int>\"\n    using Int_ZF_1_1_L4 Int_ZF_1_1_L5 int_zero_one_are_int apply_funtype \n    by auto\n   with A2 show \"f`(\\<rm>m) = (\\<rm>\\<delta>(f,m,\\<rm>m)) \\<ra> f`(\\<zero>) \\<rs> f`(m)\"\n     using Int_ZF_1_1_L4 Int_ZF_1_2_L15 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 865
    },
    "779": {
        "type": "lemma",
        "text": "text\\<open>The next lemma allows to use the expression \\<open>maxf(f,\\<zero>..M-1)\\<close>. \n  Recall that \\<open>maxf(f,A)\\<close> is the maximum of (function) $f$ on \n  (the set) $A$.\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\" and \"M \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "AlmostHoms_def",
            "Int_ZF_1_5_L6",
            "Int_ZF_1_4_L2"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L15:\n  assumes \"s\\<in>\\<S>\" and \"M \\<in> \\<int>\\<^sub>+\"\n  shows \n  \"maxf(s,\\<zero>..(M\\<rs>\\<one>)) \\<in> \\<int>\"\n  \"\\<forall>n \\<in> \\<zero>..(M\\<rs>\\<one>). s`(n) \\<lsq> maxf(s,\\<zero>..(M\\<rs>\\<one>))\"\n  \"minf(s,\\<zero>..(M\\<rs>\\<one>)) \\<in> \\<int>\"\n  \"\\<forall>n \\<in> \\<zero>..(M\\<rs>\\<one>). minf(s,\\<zero>..(M\\<rs>\\<one>)) \\<lsq> s`(n)\"\n  ",
        "proof": "using assms AlmostHoms_def Int_ZF_1_5_L6 Int_ZF_1_4_L2\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 866
    },
    "780": {
        "type": "lemma",
        "text": "text\\<open>A lower estimate for the value of a slope at $nM+k$.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"  and A2: \"m\\<in>\\<int>\" and A3: \"M \\<in> \\<int>\\<^sub>+\" and A4: \"k \\<in> \\<zero>..(M\\<rs>\\<one>)\"\n  ",
        "using": [
            "Int_ZF_1_5_L6",
            "PositiveSet_def",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_1_L15",
            "Int_ZF_2_1_L7",
            "int_ineq_add_sides",
            "int_ord_transl_inv",
            "Int_ZF_2_1_L3A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L16:\n  assumes A1: \"s\\<in>\\<S>\"  and A2: \"m\\<in>\\<int>\" and A3: \"M \\<in> \\<int>\\<^sub>+\" and A4: \"k \\<in> \\<zero>..(M\\<rs>\\<one>)\"\n  shows \"s`(m\\<cdot>M) \\<ra> (minf(s,\\<zero>..(M\\<rs>\\<one>))\\<rs> max\\<delta>(s)) \\<lsq> s`(m\\<cdot>M\\<ra>k)\"\n",
        "proof": "proof -\n  from A3 have \"\\<zero>..(M\\<rs>\\<one>) \\<subseteq> \\<int>\"\n    using Int_ZF_1_5_L6 by simp\n  with A1 A2 A3 A4 have T: \"m\\<cdot>M \\<in> \\<int>\"   \"k \\<in> \\<int>\"  \"s`(m\\<cdot>M) \\<in> \\<int>\"\n    using PositiveSet_def Int_ZF_1_1_L5  Int_ZF_2_1_L2B\n    by auto\n  with A1 A3 A4 have \n    \"s`(m\\<cdot>M) \\<ra> (minf(s,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(s)) \\<lsq> s`(m\\<cdot>M) \\<ra> (s`(k) \\<ra> \\<delta>(s,m\\<cdot>M,k))\"\n    using Int_ZF_2_1_L15 Int_ZF_2_1_L7 int_ineq_add_sides int_ord_transl_inv\n    by simp\n  with A1 T show ?thesis using Int_ZF_2_1_L3A by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 867
    },
    "781": {
        "type": "lemma",
        "text": "text\\<open>Identity is a slope.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_L15"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L17: shows \"id(\\<int>) \\<in> \\<S>\"\n  ",
        "proof": "using Int_ZF_2_1_L1 group1.Group_ZF_3_4_L15 by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 868
    },
    "782": {
        "type": "lemma",
        "text": "text\\<open>Recall that $f$ is a slope iff $f(m+n)-f(m)-f(n)$ is bounded\n  as $m,n$ ranges over integers. The next lemma is the first \n  step in showing that we only need to check this condition as $m,n$ ranges\n  over positive intergers. Namely we show that if the condition holds for\n  positive integers, then it holds if one integer is positive and the second \n  one is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\" and\n  A3:  \"m\\<in>\\<int>\\<^sup>+\"  \"n\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "int_one_two_are_pos",
            "PositiveSet_def",
            "Int_ZF_2_1_L3B",
            "Int_ZF_1_3_L19",
            "int_zero_one_are_int",
            "apply_funtype",
            "Nonnegative_def",
            "Int_ZF_2_L14",
            "Int_ZF_1_5_L3A",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_2_L3",
            "Int_ZF_2_L17",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_2_L15F",
            "int_abs_nonneg"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L20: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\" and\n  A3:  \"m\\<in>\\<int>\\<^sup>+\"  \"n\\<in>\\<int>\\<^sub>+\"\n  shows \n  \"\\<zero> \\<lsq> L\"\n  \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n",
        "proof": "proof -       \n  from A1 A2 have \n    \"\\<delta>(f,\\<one>,\\<one>) \\<in> \\<int>\"  and \"abs(\\<delta>(f,\\<one>,\\<one>)) \\<lsq> L\" \n    using int_one_two_are_pos PositiveSet_def Int_ZF_2_1_L3B\n    by auto\n  then show I: \"\\<zero> \\<lsq> L\" using Int_ZF_1_3_L19 by simp\n  from A1 A3 have T: \n    \"n \\<in> \\<int>\"  \"f`(n) \\<in> \\<int>\"  \"f`(\\<zero>) \\<in> \\<int>\"  \n    \"\\<delta>(f,m,n) \\<in> \\<int>\"  \"abs(\\<delta>(f,m,n)) \\<in> \\<int>\"\n    using PositiveSet_def int_zero_one_are_int apply_funtype\n      Nonnegative_def Int_ZF_2_1_L3B Int_ZF_2_L14 by auto\n  from A3 have \"m=\\<zero> \\<or> m\\<in>\\<int>\\<^sub>+\" using Int_ZF_1_5_L3A by auto\n  moreover\n  { assume \"m = \\<zero>\"\n    with T I have \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n      using Int_ZF_1_1_L4 Int_ZF_1_2_L3 Int_ZF_2_L17 \n\tint_ord_is_refl refl_def Int_ZF_2_L15F by simp }\n  moreover\n  { assume \"m\\<in>\\<int>\\<^sub>+\"\n    with A2 A3 T have \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n       using int_abs_nonneg Int_ZF_2_L15F by simp }\n   ultimately show \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n     by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 871
    },
    "783": {
        "type": "lemma",
        "text": "text\\<open>If the slope condition holds for all pairs of integers such that one integer is \n  positive and the second one is nonnegative, then it holds when both integers are \n  nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sup>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\" and\n  A3: \"n\\<in>\\<int>\\<^sup>+\"  \"m\\<in>\\<int>\\<^sup>+\"\n  ",
        "using": [
            "int_one_two_are_pos",
            "PositiveSet_def",
            "Nonnegative_def",
            "Int_ZF_2_1_L3B",
            "Int_ZF_1_3_L19",
            "int_zero_one_are_int",
            "apply_funtype",
            "Int_ZF_2_L14",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_5_L3A",
            "Int_ZF_2_L17",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_2_L15F",
            "int_abs_nonneg"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L21: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sup>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\" and\n  A3: \"n\\<in>\\<int>\\<^sup>+\"  \"m\\<in>\\<int>\\<^sup>+\"\n  shows \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"\\<delta>(f,\\<one>,\\<one>) \\<in> \\<int>\"  and \"abs(\\<delta>(f,\\<one>,\\<one>)) \\<lsq> L\" \n    using int_one_two_are_pos PositiveSet_def Nonnegative_def Int_ZF_2_1_L3B\n    by auto\n  then have I: \"\\<zero> \\<lsq> L\" using Int_ZF_1_3_L19 by simp\n  from A1 A3 have T: \n    \"m \\<in> \\<int>\"  \"f`(m) \\<in> \\<int>\"  \"f`(\\<zero>) \\<in> \\<int>\"  \"(\\<rm>f`(\\<zero>)) \\<in> \\<int>\"  \n    \"\\<delta>(f,m,n) \\<in> \\<int>\"  \"abs(\\<delta>(f,m,n)) \\<in> \\<int>\"\n    using int_zero_one_are_int apply_funtype Nonnegative_def \n      Int_ZF_2_1_L3B Int_ZF_2_L14 Int_ZF_1_1_L4 by auto\n  from A3 have \"n=\\<zero> \\<or> n\\<in>\\<int>\\<^sub>+\" using Int_ZF_1_5_L3A by auto\n  moreover\n  { assume \"n=\\<zero>\"\n     with T have \"\\<delta>(f,m,n) = \\<rm>f`(\\<zero>)\"\n      using Int_ZF_1_1_L4 by simp\n    with T have \"abs(\\<delta>(f,m,n)) = abs(f`(\\<zero>))\"\n      using Int_ZF_2_L17 by simp\n    with T have \"abs(\\<delta>(f,m,n)) \\<lsq> abs(f`(\\<zero>))\"\n      using int_ord_is_refl refl_def by simp\n    with T I have \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n      using Int_ZF_2_L15F by simp }\n  moreover\n  { assume \"n\\<in>\\<int>\\<^sub>+\"\n    with A2 A3 T have \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n      using int_abs_nonneg Int_ZF_2_L15F by simp }\n  ultimately show  \"abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>))\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 872
    },
    "784": {
        "type": "lemma",
        "text": "text\\<open>If the homomorphism difference is bounded on \\<open>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+\\<close>, \n  then it is bounded on \\<open>\\<int>\\<^sup>+\\<times>\\<int>\\<^sup>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_1_L20",
            "Int_ZF_2_1_L21"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L22: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\"\n  shows \"\\<exists>M. \\<forall>m\\<in>\\<int>\\<^sup>+. \\<forall>n\\<in>\\<int>\\<^sup>+. abs(\\<delta>(f,m,n)) \\<lsq> M\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"\\<forall>m\\<in>\\<int>\\<^sup>+. \\<forall>n\\<in>\\<int>\\<^sup>+. abs(\\<delta>(f,m,n)) \\<lsq> L \\<ra> abs(f`(\\<zero>)) \\<ra> abs(f`(\\<zero>))\"\n    using Int_ZF_2_1_L20 Int_ZF_2_1_L21 by simp\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 873
    },
    "785": {
        "type": "lemma",
        "text": "text\\<open>For odd functions we can do better than in \\<open>Int_ZF_2_1_L22\\<close>: \n  if the homomorphism \n  difference of $f$ is bounded on \\<open>\\<int>\\<^sup>+\\<times>\\<int>\\<^sup>+\\<close>, then it is bounded \n  on \\<open>\\<int>\\<times>\\<int>\\<close>, hence $f$ is a slope. \n  Loong prof by splitting the \\<open>\\<int>\\<times>\\<int>\\<close> into six subsets.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\"\n  and A3: \"\\<forall>x\\<in>\\<int>. (\\<rm>f`(\\<rm>x)) = f`(x)\"\n  ",
        "using": [
            "int_plane_split_in6",
            "Int_ZF_2_L16",
            "Int_ZF_2_L10A",
            "Int_ZF_2_1_L19"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L23: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and\n  A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\"\n  and A3: \"\\<forall>x\\<in>\\<int>. (\\<rm>f`(\\<rm>x)) = f`(x)\"\n  shows  \"f\\<in>\\<S>\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"\\<exists>M.\\<forall>a\\<in>\\<int>\\<^sup>+. \\<forall>b\\<in>\\<int>\\<^sup>+. abs(\\<delta>(f,a,b)) \\<lsq> M\"\n    by (rule Int_ZF_2_1_L22)\n  then obtain M where I: \"\\<forall>m\\<in>\\<int>\\<^sup>+. \\<forall>n\\<in>\\<int>\\<^sup>+. abs(\\<delta>(f,m,n)) \\<lsq> M\"\n    by auto\n  { fix a b assume A4: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n    then have \n      \"\\<zero>\\<lsq>a \\<and> \\<zero>\\<lsq>b  \\<or>  a\\<lsq>\\<zero> \\<and> b\\<lsq>\\<zero>  \\<or>  \n      a\\<lsq>\\<zero> \\<and> \\<zero>\\<lsq>b \\<and> \\<zero> \\<lsq> a\\<ra>b  \\<or> a\\<lsq>\\<zero> \\<and> \\<zero>\\<lsq>b \\<and> a\\<ra>b \\<lsq> \\<zero>  \\<or>  \n      \\<zero>\\<lsq>a \\<and> b\\<lsq>\\<zero> \\<and> \\<zero> \\<lsq> a\\<ra>b  \\<or>  \\<zero>\\<lsq>a \\<and> b\\<lsq>\\<zero> \\<and> a\\<ra>b \\<lsq> \\<zero>\"\n      using int_plane_split_in6 by simp\n    moreover\n    { assume \"\\<zero>\\<lsq>a \\<and> \\<zero>\\<lsq>b\" \n      then have \"a\\<in>\\<int>\\<^sup>+\"  \"b\\<in>\\<int>\\<^sup>+\"\n\tusing Int_ZF_2_L16 by auto\n      with I have \"abs(\\<delta>(f,a,b)) \\<lsq> M\" by simp }\n    moreover\n    { assume \"a\\<lsq>\\<zero> \\<and> b\\<lsq>\\<zero>\"\n      with I have \"abs(\\<delta>(f,\\<rm>a,\\<rm>b)) \\<lsq> M\"\n\tusing Int_ZF_2_L10A Int_ZF_2_L16 by simp\n      with A1 A3 A4 have \"abs(\\<delta>(f,a,b)) \\<lsq> M\"\n\tusing Int_ZF_2_1_L19 by simp }\n    moreover\n    { assume \"a\\<lsq>\\<zero> \\<and> \\<zero>\\<lsq>b \\<and> \\<zero> \\<lsq> a\\<ra>b\"\n      with I have \"abs(\\<delta>(f,\\<rm>a,a\\<ra>b)) \\<lsq> M\"\n\tusing Int_ZF_2_L10A Int_ZF_2_L16 by simp\n      with A1 A3 A4 have \"abs(\\<delta>(f,a,b)) \\<lsq> M\"\n\tusing Int_ZF_2_1_L19 by simp } \n    moreover\n    { assume \"a\\<lsq>\\<zero> \\<and> \\<zero>\\<lsq>b \\<and> a\\<ra>b \\<lsq> \\<zero>\"\n      with I have \"abs(\\<delta>(f,b,\\<rm>(a\\<ra>b))) \\<lsq> M\"\n\tusing Int_ZF_2_L10A Int_ZF_2_L16 by simp\n      with A1 A3 A4 have \"abs(\\<delta>(f,a,b)) \\<lsq> M\"\n\tusing Int_ZF_2_1_L19 by simp }\n    moreover\n    { assume \"\\<zero>\\<lsq>a \\<and> b\\<lsq>\\<zero> \\<and> \\<zero> \\<lsq> a\\<ra>b\"\n      with I have \"abs(\\<delta>(f,\\<rm>b,a\\<ra>b)) \\<lsq> M\"\n\tusing Int_ZF_2_L10A Int_ZF_2_L16 by simp\n      with A1 A3 A4 have \"abs(\\<delta>(f,a,b)) \\<lsq> M\"\n\tusing Int_ZF_2_1_L19 by simp }\n    moreover\n    { assume \"\\<zero>\\<lsq>a \\<and> b\\<lsq>\\<zero> \\<and> a\\<ra>b \\<lsq> \\<zero>\" \n      with I have \"abs(\\<delta>(f,a,\\<rm>(a\\<ra>b))) \\<lsq> M\"\n\tusing Int_ZF_2_L10A Int_ZF_2_L16 by simp\n      with A1 A3 A4 have \"abs(\\<delta>(f,a,b)) \\<lsq> M\"\n\tusing Int_ZF_2_1_L19 by simp }\n    ultimately have \"abs(\\<delta>(f,a,b)) \\<lsq> M\" by auto } \n  then have \"\\<forall>m\\<in>\\<int>. \\<forall>n\\<in>\\<int>. abs(\\<delta>(f,m,n)) \\<lsq> M\" by simp\n  with A1 show \"f\\<in>\\<S>\" by (rule Int_ZF_2_1_L5)\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 874
    },
    "786": {
        "type": "lemma",
        "text": "text\\<open>If the homomorphism difference of a function defined \n  on positive integers is bounded, then the odd extension\n  of this function is a slope.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<^sub>+\\<rightarrow>\\<int>\" and A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_1_5_L10",
            "pos_int_closed_add_unfolded",
            "Int_ZF_1_5_L11",
            "int_oddext_is_odd_alt"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L24: \n  assumes A1: \"f:\\<int>\\<^sub>+\\<rightarrow>\\<int>\" and A2: \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<lsq> L\"\n  shows \"OddExtension(\\<int>,IntegerAddition,IntegerOrder,f) \\<in> \\<S>\"\n",
        "proof": "proof -\n  let ?g = \"OddExtension(\\<int>,IntegerAddition,IntegerOrder,f)\"\n  from A1 have \"?g : \\<int>\\<rightarrow>\\<int>\"\n    using Int_ZF_1_5_L10 by simp\n  moreover have \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(?g,a,b)) \\<lsq> L\"\n  proof -\n    { fix a b assume A3: \"a\\<in>\\<int>\\<^sub>+\"  \"b\\<in>\\<int>\\<^sub>+\"\n      with A1 have \"abs(\\<delta>(f,a,b)) =  abs(\\<delta>(?g,a,b))\"\n\tusing pos_int_closed_add_unfolded Int_ZF_1_5_L11 \n\tby simp\n      moreover from A2 A3 have \"abs(\\<delta>(f,a,b)) \\<lsq> L\" by simp\n      ultimately have \"abs(\\<delta>(?g,a,b)) \\<lsq> L\" by simp\n    } then show ?thesis by simp\n  qed\n  moreover from A1 have \"\\<forall>x\\<in>\\<int>. (\\<rm>?g`(\\<rm>x)) = ?g`(x)\"\n    using int_oddext_is_odd_alt by simp\n  ultimately show \"?g \\<in> \\<S>\" by (rule Int_ZF_2_1_L23)\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 875
    },
    "787": {
        "type": "lemma",
        "text": "text\\<open>A formula expressing the difference between $f(m-n-k)$ and\n  $f(m)-f(n)-f(k)$ in terms of $\\gamma$.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L25",
            "apply_funtype",
            "Int_ZF_2_1_L26",
            "Int_ZF_1_2_L17"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L26A: \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  shows \n  \"f`(m\\<rs>n\\<rs>k) \\<rs> (f`(m)\\<rs> f`(n) \\<rs> f`(k)) = \\<gamma>(f,m\\<rs>n,k) \\<ra> \\<gamma>(f,m,n)\"\n",
        "proof": "proof -\n  from A1 A2 have \n    T: \"m\\<rs>n \\<in> \\<int>\" \"\\<gamma>(f,m\\<rs>n,k) \\<in> \\<int>\"  \"f`(m) \\<rs> f`(n) \\<rs> f`(k) \\<in> \\<int>\" and\n    T1: \"\\<gamma>(f,m,n) \\<in> \\<int>\"  \"f`(m) \\<rs> f`(n) \\<in> \\<int>\"  \"(\\<rm>f`(k)) \\<in> \\<int>\"\n    using Int_ZF_1_1_L4 Int_ZF_1_1_L5 Int_ZF_2_1_L25 apply_funtype \n    by auto\n  from A1 A2 have \n    \"f`(m\\<rs>n) \\<rs> f`(k) = \\<gamma>(f,m,n) \\<ra> (f`(m) \\<rs> f`(n)) \\<ra> (\\<rm>f`(k))\"\n    using Int_ZF_2_1_L26 by simp\n  also from T1 have \"\\<dots> = \\<gamma>(f,m,n) \\<ra> (f`(m) \\<rs> f`(n) \\<ra> (\\<rm>f`(k)))\"\n    by (rule Int_ZF_1_1_L7)\n  finally have \n    \"f`(m\\<rs>n) \\<rs> f`(k) = \\<gamma>(f,m,n) \\<ra> (f`(m) \\<rs> f`(n) \\<rs> f`(k))\"\n    by simp\n  moreover from A1 A2 T have\n    \"f`(m\\<rs>n\\<rs>k) =  \\<gamma>(f,m\\<rs>n,k) \\<ra> (f`(m\\<rs>n)\\<rs>f`(k))\"\n    using Int_ZF_2_1_L26 by simp\n  ultimately have \n    \"f`(m\\<rs>n\\<rs>k) \\<rs> (f`(m)\\<rs> f`(n) \\<rs> f`(k)) = \n    \\<gamma>(f,m\\<rs>n,k) \\<ra> ( \\<gamma>(f,m,n) \\<ra> (f`(m) \\<rs> f`(n) \\<rs> f`(k))) \n    \\<rs> (f`(m)\\<rs> f`(n) \\<rs> f`(k))\"\n    by simp\n  with T T1 show ?thesis \n    using Int_ZF_1_2_L17 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 878
    },
    "788": {
        "type": "lemma",
        "text": "text\\<open>If $s$ is a slope, then $\\gamma (s,m,n)$ is uniformly bounded.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"\n  ",
        "using": [
            "Int_ZF_2_1_L8",
            "int_zero_one_are_int",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_L14",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_1_L4",
            "AlmostHoms_def",
            "Int_ZF_2_1_L25",
            "Int_triangle_ineq3",
            "Int_ZF_2_1_L7",
            "int_ineq_add_sides",
            "int_ord_transl_inv",
            "Int_ZF_2_L17"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L27: assumes A1: \"s\\<in>\\<S>\"\n  shows \"\\<exists>L\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>. abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n",
        "proof": "proof -\n  let ?L = \"max\\<delta>(s) \\<ra> max\\<delta>(s) \\<ra> abs(s`(\\<zero>))\"\n  from A1 have T: \n    \"max\\<delta>(s) \\<in> \\<int>\"  \"abs(s`(\\<zero>)) \\<in> \\<int>\"  \"?L \\<in> \\<int>\"\n    using Int_ZF_2_1_L8 int_zero_one_are_int Int_ZF_2_1_L2B \n      Int_ZF_2_L14 Int_ZF_1_1_L5 by auto\n  moreover\n  { fix m \n    fix n\n    assume A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n    with A1 have T: \n      \"(\\<rm>n) \\<in> \\<int>\"\n      \"\\<delta>(s,m,\\<rm>n) \\<in> \\<int>\"\n      \"\\<delta>(s,n,\\<rm>n) \\<in> \\<int>\"\n      \"(\\<rm>\\<delta>(s,n,\\<rm>n)) \\<in> \\<int>\"\n      \"s`(\\<zero>) \\<in> \\<int>\"  \"abs(s`(\\<zero>)) \\<in> \\<int>\"\n      using Int_ZF_1_1_L4 AlmostHoms_def Int_ZF_2_1_L25 Int_ZF_2_L14\n      by auto\n    with T have\n      \"abs(\\<delta>(s,m,\\<rm>n) \\<rs> \\<delta>(s,n,\\<rm>n) \\<ra> s`(\\<zero>)) \\<lsq>\n      abs(\\<delta>(s,m,\\<rm>n)) \\<ra> abs(\\<rm>\\<delta>(s,n,\\<rm>n)) \\<ra> abs(s`(\\<zero>))\"\n      using Int_triangle_ineq3 by simp\n    moreover from A1 A2 T have \n      \"abs(\\<delta>(s,m,\\<rm>n)) \\<ra> abs(\\<rm>\\<delta>(s,n,\\<rm>n)) \\<ra> abs(s`(\\<zero>)) \\<lsq> ?L\"\n      using Int_ZF_2_1_L7 int_ineq_add_sides int_ord_transl_inv Int_ZF_2_L17\n      by simp\n   ultimately have \"abs(\\<delta>(s,m,\\<rm>n) \\<rs> \\<delta>(s,n,\\<rm>n) \\<ra> s`(\\<zero>)) \\<lsq> ?L\"\n      by (rule Int_order_transitive)    \n    then have \"abs(\\<gamma>(s,m,n)) \\<lsq> ?L\" by simp }\n  ultimately show \"\\<exists>L\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>. abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 879
    },
    "789": {
        "type": "lemma",
        "text": "text\\<open>If $s$ is a slope, then $s(m) \\leq s(m-1) + M$, where $L$ does not depend\n  on $m$.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"\n  ",
        "using": [
            "Int_ZF_2_1_L27",
            "int_zero_one_are_int",
            "Int_ZF_2_1_L2B",
            "Int_ZF_1_1_L5",
            "AlmostHoms_def",
            "Int_ZF_2_1_L25",
            "apply_funtype",
            "Int_ZF_2_L19C",
            "int_ord_transl_inv"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L28: assumes A1: \"s\\<in>\\<S>\"\n  shows \"\\<exists>M\\<in>\\<int>. \\<forall>m\\<in>\\<int>. s`(m) \\<lsq> s`(m\\<rs>\\<one>) \\<ra> M\"\n",
        "proof": "proof -\n  from A1 have\n    \"\\<exists>L\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n    using Int_ZF_2_1_L27 by simp\n  then obtain L where T: \"L\\<in>\\<int>\" and \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n    using Int_ZF_2_1_L27 by auto\n  then have I: \"\\<forall>m\\<in>\\<int>.abs(\\<gamma>(s,m,\\<one>)) \\<lsq> L\"\n    using int_zero_one_are_int by simp\n  let ?M = \"s`(\\<one>) \\<ra> L\"\n  from A1 T have \"?M \\<in> \\<int>\"\n    using int_zero_one_are_int Int_ZF_2_1_L2B Int_ZF_1_1_L5\n    by simp\n  moreover\n  { fix m assume A2: \"m\\<in>\\<int>\"\n    with A1 have \n      T1: \"s:\\<int>\\<rightarrow>\\<int>\"  \"m\\<in>\\<int>\"  \"\\<one>\\<in>\\<int>\" and\n      T2: \"\\<gamma>(s,m,\\<one>) \\<in> \\<int>\"  \"s`(\\<one>) \\<in> \\<int>\"\n      using int_zero_one_are_int AlmostHoms_def \n\tInt_ZF_2_1_L25 by auto\n    from A2 T1 have T3: \"s`(m\\<rs>\\<one>) \\<in> \\<int>\"\n      using Int_ZF_1_1_L5 apply_funtype by simp\n    from I A2 T2 have \n      \"(\\<rm>\\<gamma>(s,m,\\<one>)) \\<lsq> abs(\\<gamma>(s,m,\\<one>))\"\n      \"abs(\\<gamma>(s,m,\\<one>)) \\<lsq> L\"\n      using Int_ZF_2_L19C by auto\n    then have \"(\\<rm>\\<gamma>(s,m,\\<one>)) \\<lsq> L\"\n      by (rule Int_order_transitive)\n    with T2 T3 have \n      \"s`(m\\<rs>\\<one>) \\<ra> (s`(\\<one>) \\<rs> \\<gamma>(s,m,\\<one>)) \\<lsq> s`(m\\<rs>\\<one>) \\<ra> ?M\"\n      using int_ord_transl_inv by simp\n    moreover from T1 have\n      \"s`(m\\<rs>\\<one>) \\<ra> (s`(\\<one>) \\<rs> \\<gamma>(s,m,\\<one>)) = s`(m)\"\n      by (rule Int_ZF_2_1_L26)\n    ultimately have \"s`(m) \\<lsq> s`(m\\<rs>\\<one>) \\<ra> ?M\"  by simp  }\n  ultimately show \"\\<exists>M\\<in>\\<int>. \\<forall>m\\<in>\\<int>. s`(m) \\<lsq> s`(m\\<rs>\\<one>) \\<ra> M\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 880
    },
    "790": {
        "type": "lemma",
        "text": "text\\<open>If $s$ is a slope, then the difference between \n  $s(m-n-k)$ and $s(m)-s(n)-s(k)$ is uniformly bounded.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"\n  ",
        "using": [
            "Int_ZF_2_1_L27",
            "Int_ZF_1_1_L5",
            "AlmostHoms_def",
            "Int_ZF_2_1_L25",
            "Int_triangle_ineq",
            "int_ineq_add_sides",
            "Int_ZF_2_1_L26A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L29: assumes A1: \"s\\<in>\\<S>\"\n  shows \n  \"\\<exists>M\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. abs(s`(m\\<rs>n\\<rs>k) \\<rs> (s`(m)\\<rs>s`(n)\\<rs>s`(k))) \\<lsq>M\"\n",
        "proof": "proof -\n  from A1 have \"\\<exists>L\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>. abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n    using Int_ZF_2_1_L27 by simp\n  then obtain L where I: \"L\\<in>\\<int>\" and \n    II: \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>. abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n    by auto\n  from I have \"L\\<ra>L \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 by simp\n  moreover\n  { fix m n k assume A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n    with A1 have T: \n      \"m\\<rs>n \\<in> \\<int>\"  \"\\<gamma>(s,m\\<rs>n,k) \\<in> \\<int>\"  \"\\<gamma>(s,m,n) \\<in> \\<int>\"\n      using Int_ZF_1_1_L5 AlmostHoms_def Int_ZF_2_1_L25 \n      by auto\n    then have \n      I: \"abs(\\<gamma>(s,m\\<rs>n,k) \\<ra> \\<gamma>(s,m,n)) \\<lsq> abs(\\<gamma>(s,m\\<rs>n,k)) \\<ra> abs(\\<gamma>(s,m,n))\"\n      using Int_triangle_ineq by simp\n    from II A2 T have \n      \"abs(\\<gamma>(s,m\\<rs>n,k)) \\<lsq> L\"\n      \"abs(\\<gamma>(s,m,n)) \\<lsq> L\"\n      by auto\n    then have \"abs(\\<gamma>(s,m\\<rs>n,k)) \\<ra> abs(\\<gamma>(s,m,n)) \\<lsq> L\\<ra>L\"\n      using int_ineq_add_sides by simp\n    with I have \"abs(\\<gamma>(s,m\\<rs>n,k) \\<ra> \\<gamma>(s,m,n)) \\<lsq> L\\<ra>L\"\n      by (rule Int_order_transitive)\n    moreover from A1 A2 have \n      \"s`(m\\<rs>n\\<rs>k) \\<rs> (s`(m)\\<rs> s`(n) \\<rs> s`(k)) = \\<gamma>(s,m\\<rs>n,k) \\<ra> \\<gamma>(s,m,n)\"\n      using AlmostHoms_def Int_ZF_2_1_L26A by simp\n    ultimately have \n      \"abs(s`(m\\<rs>n\\<rs>k) \\<rs> (s`(m)\\<rs> s`(n) \\<rs> s`(k))) \\<lsq> L\\<ra>L\"\n      by simp }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 881
    },
    "791": {
        "type": "lemma",
        "text": "text\\<open>If $s$ is a slope, then we can find integers $M,K$ such that\n  $s(m-n-k) \\leq s(m)-s(n)-s(k) + M$ and $s(m)-s(n)-s(k) + K \\leq s(m-n-k)$, \n  for all integer $m,n,k$.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"\n  ",
        "using": [
            "Int_ZF_2_1_L29",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L2B",
            "Int_triangle_ineq2"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L30: assumes A1: \"s\\<in>\\<S>\"\n  shows \n  \"\\<exists>M\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. s`(m\\<rs>n\\<rs>k) \\<lsq> s`(m)\\<rs>s`(n)\\<rs>s`(k)\\<ra>M\"\n  \"\\<exists>K\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. s`(m)\\<rs>s`(n)\\<rs>s`(k)\\<ra>K \\<lsq> s`(m\\<rs>n\\<rs>k)\"\n",
        "proof": "proof -\n  from A1 have\n    \"\\<exists>M\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. abs(s`(m\\<rs>n\\<rs>k) \\<rs> (s`(m)\\<rs>s`(n)\\<rs>s`(k))) \\<lsq>M\"\n    using Int_ZF_2_1_L29 by simp\n  then obtain M where I: \"M\\<in>\\<int>\" and II:\n    \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. abs(s`(m\\<rs>n\\<rs>k) \\<rs> (s`(m)\\<rs>s`(n)\\<rs>s`(k))) \\<lsq>M\"\n    by auto\n  from I have III: \"(\\<rm>M) \\<in> \\<int>\" using Int_ZF_1_1_L4 by simp\n  { fix m n k assume A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n    with A1 have \"s`(m\\<rs>n\\<rs>k) \\<in> \\<int>\"  and \"s`(m)\\<rs>s`(n)\\<rs>s`(k) \\<in> \\<int>\"\n      using Int_ZF_1_1_L5 Int_ZF_2_1_L2B by auto\n    moreover from II A2 have\n      \"abs(s`(m\\<rs>n\\<rs>k) \\<rs> (s`(m)\\<rs>s`(n)\\<rs>s`(k))) \\<lsq>M\"\n      by simp\n    ultimately have \n      \"s`(m\\<rs>n\\<rs>k) \\<lsq> s`(m)\\<rs>s`(n)\\<rs>s`(k)\\<ra>M \\<and> \n      s`(m)\\<rs>s`(n)\\<rs>s`(k) \\<rs> M \\<lsq> s`(m\\<rs>n\\<rs>k)\"\n      using Int_triangle_ineq2 by simp\n  } then have \n      \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. s`(m\\<rs>n\\<rs>k) \\<lsq> s`(m)\\<rs>s`(n)\\<rs>s`(k)\\<ra>M\"\n      \"\\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. s`(m)\\<rs>s`(n)\\<rs>s`(k) \\<rs> M \\<lsq> s`(m\\<rs>n\\<rs>k)\"\n    by auto\n  with I III show  \n    \"\\<exists>M\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. s`(m\\<rs>n\\<rs>k) \\<lsq> s`(m)\\<rs>s`(n)\\<rs>s`(k)\\<ra>M\"\n    \"\\<exists>K\\<in>\\<int>. \\<forall>m\\<in>\\<int>.\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. s`(m)\\<rs>s`(n)\\<rs>s`(k)\\<ra>K \\<lsq> s`(m\\<rs>n\\<rs>k)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 882
    },
    "792": {
        "type": "lemma",
        "text": "text\\<open>By definition functions $f,g$ are almost equal if $f-g$* is bounded. \n  In the next lemma we show it is sufficient to check the boundedness on positive\n  integers.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" \n  and A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. abs(s`(m)\\<rs>r`(m)) \\<lsq> L\"\n  ",
        "using": [
            "int_one_two_are_pos",
            "Int_ZF_2_L1A",
            "int_zero_one_are_int",
            "Int_ZF_2_1_L2B",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_L14",
            "Int_ZF_2_1_L8",
            "int_two_three_are_int",
            "Int_ZF_1_4_L1A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L31: assumes A1: \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" \n  and A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. abs(s`(m)\\<rs>r`(m)) \\<lsq> L\"\n  shows \"s \\<sim> r\"\nproof -\n  let ?a = \"abs(s`(\\<zero>) \\<rs> r`(\\<zero>))\"\n  let ?c = \"\\<two>\\<cdot>max\\<delta>(s) \\<ra> \\<two>\\<cdot>max\\<delta>(r) \\<ra> L\"\n  let ?M = \"Maximum(IntegerOrder,{?a,L,?c})\"\n  from A2 have \"abs(s`(\\<one>)\\<rs>r`(\\<one>)) \\<lsq> L\"\n    ",
        "proof": "using int_one_two_are_pos by simp\n  then have T: \"L\\<in>\\<int>\" using Int_ZF_2_L1A by simp\n  moreover from A1 have \"?a \\<in> \\<int>\"\n    using int_zero_one_are_int Int_ZF_2_1_L2B \n      Int_ZF_1_1_L5 Int_ZF_2_L14 by simp\n  moreover from A1 T have \"?c \\<in> \\<int>\"\n    using Int_ZF_2_1_L8 int_two_three_are_int Int_ZF_1_1_L5\n    by simp\n  ultimately have \n    I: \"?a \\<lsq> ?M\" and\n    II: \"L \\<lsq> ?M\" and \n    III: \"?c \\<lsq> ?M\"\n    using Int_ZF_1_4_L1A by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 883
    },
    "793": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for an odd slope to be almost equal to identity:\n  If for all positive integers the value of the slope at $m$ is between $m$ and\n  $m$ plus some constant independent of $m$, then the slope is almost identity.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"  \"M\\<in>\\<int>\"\n  and A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. m \\<lsq> s`(m) \\<and> s`(m) \\<lsq> m\\<ra>M\"\n  ",
        "using": [
            "Int_ZF_2_1_L17",
            "Int_ZF_1_3_L23",
            "PositiveSet_def",
            "id_conv"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L32: assumes A1: \"s\\<in>\\<S>\"  \"M\\<in>\\<int>\"\n  and A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. m \\<lsq> s`(m) \\<and> s`(m) \\<lsq> m\\<ra>M\"\n  shows \"s \\<sim> id(\\<int>)\"\n",
        "proof": "proof -\n  let ?r = \"id(\\<int>)\"\n  from A1 have \"s\\<in>\\<S>\"  \"?r \\<in> \\<S>\"\n    using Int_ZF_2_1_L17 by auto\n  moreover from A1 A2 have \"\\<forall>m\\<in>\\<int>\\<^sub>+. abs(s`(m)\\<rs>?r`(m)) \\<lsq> M\"\n    using Int_ZF_1_3_L23 PositiveSet_def id_conv by simp\n  ultimately show \"s \\<sim> id(\\<int>)\" by (rule Int_ZF_2_1_L31)\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 884
    },
    "794": {
        "type": "lemma",
        "text": "text\\<open>A lemma about adding a constant to slopes. This is actually proven in\n  \\<open>Group_ZF_3_5_L1\\<close>, in \\<open>Group_ZF_3.thy\\<close> here we just refer to \n  that lemma to show it in notation used for integers. Unfortunately we have\n  to use raw set notation in the proof.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\" and A2: \"c\\<in>\\<int>\" and \n  A3: \"r = {\\<langle>m,s`(m)\\<ra>c\\<rangle>. m\\<in>\\<int>}\"\n  ",
        "using": [
            "Int_ZF_2_1_L1"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L33:\n  assumes A1: \"s\\<in>\\<S>\" and A2: \"c\\<in>\\<int>\" and \n  A3: \"r = {\\<langle>m,s`(m)\\<ra>c\\<rangle>. m\\<in>\\<int>}\"\n  shows\n  \"\\<forall>m\\<in>\\<int>. r`(m) = s`(m)\\<ra>c\"\n  \"r\\<in>\\<S>\"\n  \"s \\<sim> r\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?f = \"IntegerAddition\"\n  let ?AH = \"AlmostHoms(?G, ?f)\"\n  from assms have I:\n    \"group1(?G, ?f)\"\n    \"s \\<in> AlmostHoms(?G, ?f)\"\n    \"c \\<in> ?G\"\n    \"r = {\\<langle>x, ?f`\\<langle>s`(x), c\\<rangle>\\<rangle>. x \\<in> ?G}\"\n    using Int_ZF_2_1_L1 by auto\n  then have \"\\<forall>x\\<in>?G. r`(x) = ?f`\\<langle>s`(x),c\\<rangle>\"\n    by (rule group1.Group_ZF_3_5_L1)\n  moreover from I have \"r \\<in> AlmostHoms(?G, ?f)\"\n    by (rule group1.Group_ZF_3_5_L1)\n  moreover from I have \n    \"\\<langle>s, r\\<rangle> \\<in> QuotientGroupRel(AlmostHoms(?G, ?f), AlHomOp1(?G, ?f), FinRangeFunctions(?G, ?G))\"\n    by (rule group1.Group_ZF_3_5_L1)\n  ultimately show \n    \"\\<forall>m\\<in>\\<int>. r`(m) = s`(m)\\<ra>c\"\n    \"r\\<in>\\<S>\"\n    \"s \\<sim> r\"\n    by auto\nqed  \n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 885
    },
    "795": {
        "type": "lemma",
        "text": "text\\<open>Two useful estimates.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"p\\<in>\\<int>\"  \"q\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L2",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5",
            "apply_funtype",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_1_L4",
            "Int_triangle_ineq",
            "Int_ZF_1_2_L7",
            "Int_triangle_ineq1"
        ],
        "statement": "lemma (in int1) Int_ZF_2_2_L1: \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"p\\<in>\\<int>\"  \"q\\<in>\\<int>\"\n  shows \n  \"abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> abs(\\<delta>(f,p\\<cdot>q,q))\\<ra>abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n  \"abs(f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q)) \\<lsq> abs(\\<delta>(f,(p\\<rs>\\<one>)\\<cdot>q,q))\\<ra>abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n",
        "proof": "proof -\n  let ?R = \"\\<int>\"\n  let ?A = \"IntegerAddition\"\n  let ?M = \"IntegerMultiplication\"\n  let ?I = \"GroupInv(?R, ?A)\"\n  let ?a = \"f`((p\\<ra>\\<one>)\\<cdot>q)\"\n  let ?b = \"p\"\n  let ?c = \"f`(q)\"\n  let ?d = \"f`(p\\<cdot>q)\"\n  from A1 A2 have T1:\n    \"ring0(?R, ?A, ?M)\"  \"?a \\<in> ?R\"  \"?b \\<in> ?R\"  \"?c \\<in> ?R\"  \"?d \\<in> ?R\"\n    using  Int_ZF_1_1_L2 int_zero_one_are_int Int_ZF_1_1_L5 apply_funtype \n    by auto\n  then have \n    \"?A`\\<langle>?a,?I`(?M`\\<langle>?A`\\<langle>?b, TheNeutralElement(?R, ?M)\\<rangle>,?c\\<rangle>)\\<rangle> =\n    ?A`\\<langle>?A`\\<langle>?A`\\<langle>?a,?I`(?d)\\<rangle>,?I`(?c)\\<rangle>,?A`\\<langle>?d, ?I`(?M`\\<langle>?b, ?c\\<rangle>)\\<rangle>\\<rangle>\"\n    by (rule ring0.Ring_ZF_2_L2)\n  with A2 have \n    \"f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q) = \\<delta>(f,p\\<cdot>q,q)\\<ra>(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n    using int_zero_one_are_int Int_ZF_1_1_L1 Int_ZF_1_1_L4 by simp\n  moreover from A1 A2 T1 have \"\\<delta>(f,p\\<cdot>q,q) \\<in> \\<int>\" \"f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q) \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 apply_funtype by auto\n  ultimately show \n    \"abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> abs(\\<delta>(f,p\\<cdot>q,q))\\<ra>abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n    using Int_triangle_ineq by simp\n  from A1 A2 have T1: \n    \"f`((p\\<rs>\\<one>)\\<cdot>q) \\<in> \\<int>\"   \"p\\<in>\\<int>\"  \"f`(q) \\<in> \\<int>\"   \"f`(p\\<cdot>q) \\<in> \\<int>\" \n    using int_zero_one_are_int Int_ZF_1_1_L5 apply_funtype by auto\n  then have\n    \"f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q) = (f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\\<rs>(f`(p\\<cdot>q)\\<rs>f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>f`(q))\"\n    by (rule Int_ZF_1_2_L6)\n  with A2 have \"f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q) = (f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\\<rs>\\<delta>(f,(p\\<rs>\\<one>)\\<cdot>q,q)\"\n    using Int_ZF_1_2_L7 by simp\n  moreover from A1 A2 have \n    \"f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q) \\<in> \\<int>\"   \"\\<delta>(f,(p\\<rs>\\<one>)\\<cdot>q,q) \\<in> \\<int>\" \n    using Int_ZF_1_1_L5 int_zero_one_are_int apply_funtype by auto\n  ultimately show \n    \"abs(f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q)) \\<lsq> abs(\\<delta>(f,(p\\<rs>\\<one>)\\<cdot>q,q))\\<ra>abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n    using Int_triangle_ineq1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 886
    },
    "796": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a slope, then \n  $|f(p\\cdot q)-p\\cdot f(q)|\\leq (|p|+1)\\cdot$\\<open>max\\<delta>(f)\\<close>. \n  The proof is by induction on $p$ and the next lemma is the induction step for the case when $0\\leq p$.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"\\<zero>\\<lsq>p\"  \"q\\<in>\\<int>\"\n  and A3: \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L5",
            "AlmostHoms_def",
            "Int_ZF_2_2_L1",
            "Int_ZF_1_2_L2"
        ],
        "statement": "lemma (in int1) Int_ZF_2_2_L2: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"\\<zero>\\<lsq>p\"  \"q\\<in>\\<int>\"\n  and A3: \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n  shows \n  \"abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> (abs(p\\<ra>\\<one>)\\<ra> \\<one>)\\<cdot>max\\<delta>(f)\"\n",
        "proof": "proof -\n  from A2 have \"q\\<in>\\<int>\"  \"p\\<cdot>q \\<in> \\<int>\" \n    using Int_ZF_2_L1A Int_ZF_1_1_L5 by auto\n  with A1 have I: \"abs(\\<delta>(f,p\\<cdot>q,q)) \\<lsq> max\\<delta>(f)\" by (rule Int_ZF_2_1_L7)\n  moreover note A3\n  moreover from A1 A2 have\n    \"abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> abs(\\<delta>(f,p\\<cdot>q,q))\\<ra>abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n    using AlmostHoms_def Int_ZF_2_L1A Int_ZF_2_2_L1 by simp\n  ultimately have \n    \"abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> max\\<delta>(f)\\<ra>(abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n    by (rule Int_ZF_2_L15)\n  moreover from I A2 have \n    \"max\\<delta>(f)\\<ra>(abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f) = (abs(p\\<ra>\\<one>)\\<ra> \\<one>)\\<cdot>max\\<delta>(f)\"\n    using Int_ZF_2_L1A Int_ZF_1_2_L2 by simp\n  ultimately show\n    \"abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> (abs(p\\<ra>\\<one>)\\<ra> \\<one>)\\<cdot>max\\<delta>(f)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 887
    },
    "797": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a slope, then \n  $|f(p\\cdot q)-p\\cdot f(q)|\\leq (|p|+1)\\cdot$\\<open>max\\<delta>\\<close>. \n  The proof is by induction on $p$ and the next lemma is the induction step for the case when $p\\leq 0$.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"p\\<lsq>\\<zero>\"  \"q\\<in>\\<int>\"\n  and A3: \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5",
            "AlmostHoms_def",
            "Int_ZF_2_2_L1",
            "Int_ZF_1_2_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_2_L3: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"p\\<lsq>\\<zero>\"  \"q\\<in>\\<int>\"\n  and A3: \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n  shows  \"abs(f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q)) \\<lsq> (abs(p\\<rs>\\<one>)\\<ra> \\<one>)\\<cdot>max\\<delta>(f)\"\n",
        "proof": "proof -\n  from A2 have \"q\\<in>\\<int>\"  \"(p\\<rs>\\<one>)\\<cdot>q \\<in> \\<int>\" \n    using Int_ZF_2_L1A int_zero_one_are_int Int_ZF_1_1_L5 by auto\n  with A1 have I: \"abs(\\<delta>(f,(p\\<rs>\\<one>)\\<cdot>q,q)) \\<lsq> max\\<delta>(f)\" by (rule Int_ZF_2_1_L7)\n  moreover note A3\n  moreover from A1 A2 have \n    \"abs(f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q)) \\<lsq> abs(\\<delta>(f,(p\\<rs>\\<one>)\\<cdot>q,q))\\<ra>abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))\"\n    using AlmostHoms_def Int_ZF_2_L1A Int_ZF_2_2_L1 by simp\n  ultimately have \n    \"abs(f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q)) \\<lsq> max\\<delta>(f)\\<ra>(abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n    by (rule Int_ZF_2_L15)\n  with I A2 show ?thesis using Int_ZF_2_L1A Int_ZF_1_2_L5 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 888
    },
    "798": {
        "type": "lemma",
        "text": "text\\<open>The next elegant result is Lemma 7 in the Arthan's paper \\cite{Arthan2004}.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"p\\<in>\\<int>\"  \"q\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_1_L7",
            "Int_ZF_2_L14",
            "Int_ZF_2_2_L4",
            "Int_ZF_2_L20",
            "Int_ZF_2_L21",
            "Int_ZF_1_2_L9",
            "int_zero_one_are_int",
            "Int_ZF_1_2_L10"
        ],
        "statement": "lemma (in int1) Arthan_Lem_7: \n assumes A1: \"f\\<in>\\<S>\" and A2: \"p\\<in>\\<int>\"  \"q\\<in>\\<int>\"\n  shows \"abs(q\\<cdot>f`(p)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>abs(q)\\<ra>\\<two>)\\<cdot>max\\<delta>(f)\"\n",
        "proof": "proof -\n  from A1 A2 have T:\n    \"q\\<cdot>f`(p)\\<rs>f`(p\\<cdot>q) \\<in> \\<int>\" \n    \"f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q) \\<in> \\<int>\"\n    \"f`(q\\<cdot>p) \\<in> \\<int>\"  \"f`(p\\<cdot>q) \\<in> \\<int>\"\n    \"q\\<cdot>f`(p) \\<in> \\<int>\"  \"p\\<cdot>f`(q) \\<in> \\<int>\" \n    \"max\\<delta>(f) \\<in> \\<int>\"\n    \"abs(q) \\<in> \\<int>\"  \"abs(p) \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 Int_ZF_2_1_L2B Int_ZF_2_1_L7 Int_ZF_2_L14 by auto\n  moreover have \"abs(q\\<cdot>f`(p)\\<rs>f`(p\\<cdot>q)) \\<lsq> (abs(q)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n  proof -\n    from A1 A2 have \"abs(f`(q\\<cdot>p)\\<rs>q\\<cdot>f`(p)) \\<lsq> (abs(q)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n      using Int_ZF_2_2_L4 by simp\n    with T A2 show ?thesis\n      using Int_ZF_2_L20 Int_ZF_1_1_L5 by simp\n  qed\n  moreover from A1 A2 have \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n    using Int_ZF_2_2_L4 by simp\n  ultimately have \n    \"abs(q\\<cdot>f`(p)\\<rs>f`(p\\<cdot>q)\\<ra>(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q))) \\<lsq> (abs(q)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\\<ra>(abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n    using Int_ZF_2_L21 by simp\n  with T show ?thesis using Int_ZF_1_2_L9 int_zero_one_are_int Int_ZF_1_2_L10\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 890
    },
    "799": {
        "type": "lemma",
        "text": "text\\<open>This is Lemma 8 in the Arthan's paper.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_1_L7",
            "Int_ZF_2_L14",
            "Arthan_Lem_7",
            "Int_ZF_2_L16A",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_2_L11",
            "Int_triangle_ineq2",
            "Int_ZF_1_3_L14"
        ],
        "statement": "lemma (in int1) Arthan_Lem_8: assumes A1: \"f\\<in>\\<S>\"\n  shows \"\\<exists>A B. A\\<in>\\<int> \\<and> B\\<in>\\<int> \\<and> (\\<forall>p\\<in>\\<int>. abs(f`(p)) \\<lsq> A\\<cdot>abs(p)\\<ra>B)\"\n",
        "proof": "proof -\n  let ?A = \"max\\<delta>(f) \\<ra> abs(f`(\\<one>))\"\n  let ?B = \"\\<three>\\<cdot>max\\<delta>(f)\"\n  from A1 have \"?A\\<in>\\<int>\" \"?B\\<in>\\<int>\"\n    using int_zero_one_are_int Int_ZF_1_1_L5 Int_ZF_2_1_L2B \n      Int_ZF_2_1_L7 Int_ZF_2_L14 by auto\n  moreover have \"\\<forall>p\\<in>\\<int>. abs(f`(p)) \\<lsq> ?A\\<cdot>abs(p)\\<ra>?B\"\n  proof\n    fix p assume A2: \"p\\<in>\\<int>\" \n    with A1 have T: \n      \"f`(p) \\<in> \\<int>\"  \"abs(p) \\<in> \\<int>\"  \"f`(\\<one>) \\<in> \\<int>\" \n      \"p\\<cdot>f`(\\<one>) \\<in> \\<int>\"  \"\\<three>\\<in>\\<int>\"  \"max\\<delta>(f) \\<in> \\<int>\"\n      using Int_ZF_2_1_L2B Int_ZF_2_L14 int_zero_one_are_int \n\tInt_ZF_1_1_L5 Int_ZF_2_1_L7 by auto\n    from A1 A2 have \n      \"abs(\\<one>\\<cdot>f`(p)\\<rs>p\\<cdot>f`(\\<one>)) \\<lsq> (abs(p)\\<ra>abs(\\<one>)\\<ra>\\<two>)\\<cdot>max\\<delta>(f)\"\n      using int_zero_one_are_int Arthan_Lem_7 by simp\n    with T have \"abs(f`(p)) \\<lsq> abs(p\\<cdot>f`(\\<one>))\\<ra>(abs(p)\\<ra>\\<three>)\\<cdot>max\\<delta>(f)\"\n      using Int_ZF_2_L16A Int_ZF_1_1_L4 Int_ZF_1_2_L11 \n\tInt_triangle_ineq2 by simp\n    with A2 T show \"abs(f`(p)) \\<lsq> ?A\\<cdot>abs(p)\\<ra>?B\"\n      using Int_ZF_1_3_L14 by simp\n  qed\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 891
    },
    "800": {
        "type": "theorem",
        "text": "text\\<open>If $f$ and $g$ are slopes, then $f\\circ g$ is equivalent \n  (almost equal) to $g\\circ f$. This is Theorem 9 in Arthan's paper \\cite{Arthan2004}.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\"\n  ",
        "using": [
            "Arthan_Lem_8",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_1_L10",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_L14",
            "int_two_three_are_int",
            "Arthan_Lem_7",
            "Int_ZF_1_2_L10A",
            "Int_ZF_1_2_L12",
            "Int_ZF_2_L15C",
            "Int_ZF_2_1_L8",
            "Int_ZF_1_3_L13",
            "Int_ZF_1_2_L13",
            "int_ineq_add_sides",
            "int_zero_one_are_int",
            "Int_ZF_1_2_L14",
            "Int_ZF_1_3_L5",
            "Int_ZF_2_1_L11",
            "Int_ZF_2_1_L9"
        ],
        "statement": "theorem (in int1) Arthan_Th_9: assumes A1: \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\"\n  shows \"f\\<circ>g \\<sim> g\\<circ>f\"\n",
        "proof": "proof -\n   from A1 have \n      \"\\<exists>A B. A\\<in>\\<int> \\<and> B\\<in>\\<int> \\<and> (\\<forall>p\\<in>\\<int>. abs(f`(p)) \\<lsq> A\\<cdot>abs(p)\\<ra>B)\"\n      \"\\<exists>C D. C\\<in>\\<int> \\<and> D\\<in>\\<int> \\<and> (\\<forall>p\\<in>\\<int>. abs(g`(p)) \\<lsq> C\\<cdot>abs(p)\\<ra>D)\"\n      using Arthan_Lem_8 by auto\n    then obtain A B C D where D1: \"A\\<in>\\<int>\" \"B\\<in>\\<int>\" \"C\\<in>\\<int>\" \"D\\<in>\\<int>\" and D2: \n      \"\\<forall>p\\<in>\\<int>. abs(f`(p)) \\<lsq> A\\<cdot>abs(p)\\<ra>B\"\n      \"\\<forall>p\\<in>\\<int>. abs(g`(p)) \\<lsq> C\\<cdot>abs(p)\\<ra>D\"\n      by auto\n    let ?E = \"max\\<delta>(g)\\<cdot>(A\\<ra>\\<one>) \\<ra> max\\<delta>(f)\\<cdot>(C\\<ra>\\<one>)\"\n    let ?F = \"(B\\<cdot>max\\<delta>(g) \\<ra> \\<two>\\<cdot>max\\<delta>(g)) \\<ra> (D\\<cdot>max\\<delta>(f) \\<ra> \\<two>\\<cdot>max\\<delta>(f))\"\n  { fix p assume A2: \"p\\<in>\\<int>\"\n    with A1 have T1:\n      \"g`(p) \\<in> \\<int>\"  \"f`(p) \\<in> \\<int>\"  \"abs(p) \\<in> \\<int>\"  \"\\<two> \\<in> \\<int>\"\n      \"f`(g`(p)) \\<in> \\<int>\"  \"g`(f`(p)) \\<in> \\<int>\"  \"f`(g`(p)) \\<rs> g`(f`(p)) \\<in> \\<int>\"\n      \"p\\<cdot>f`(g`(p)) \\<in> \\<int>\"  \"p\\<cdot>g`(f`(p)) \\<in> \\<int>\"\n      \"abs(f`(g`(p))\\<rs>g`(f`(p))) \\<in> \\<int>\"\n      using Int_ZF_2_1_L2B Int_ZF_2_1_L10 Int_ZF_1_1_L5 Int_ZF_2_L14 int_two_three_are_int\n      by auto\n    with A1 A2 have\n      \"abs((f`(g`(p))\\<rs>g`(f`(p)))\\<cdot>p) \\<lsq> \n      (abs(p)\\<ra>abs(f`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(g) \\<ra> (abs(p)\\<ra>abs(g`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(f)\"\n      using Arthan_Lem_7 Int_ZF_1_2_L10A Int_ZF_1_2_L12 by simp\n    moreover have \n      \"(abs(p)\\<ra>abs(f`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(g) \\<ra> (abs(p)\\<ra>abs(g`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(f) \\<lsq>\n      ((max\\<delta>(g)\\<cdot>(A\\<ra>\\<one>) \\<ra> max\\<delta>(f)\\<cdot>(C\\<ra>\\<one>)))\\<cdot>abs(p) \\<ra>\n      ((B\\<cdot>max\\<delta>(g) \\<ra> \\<two>\\<cdot>max\\<delta>(g)) \\<ra> (D\\<cdot>max\\<delta>(f) \\<ra> \\<two>\\<cdot>max\\<delta>(f)))\"\n    proof -\n      from D2 A2 T1 have \n\t\"abs(p)\\<ra>abs(f`(p))\\<ra>\\<two> \\<lsq> abs(p)\\<ra>(A\\<cdot>abs(p)\\<ra>B)\\<ra>\\<two>\"\n\t\"abs(p)\\<ra>abs(g`(p))\\<ra>\\<two> \\<lsq> abs(p)\\<ra>(C\\<cdot>abs(p)\\<ra>D)\\<ra>\\<two>\"\n\tusing Int_ZF_2_L15C by auto\n      with A1 have \n\t\"(abs(p)\\<ra>abs(f`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(g) \\<lsq> (abs(p)\\<ra>(A\\<cdot>abs(p)\\<ra>B)\\<ra>\\<two>)\\<cdot>max\\<delta>(g)\"\n\t\"(abs(p)\\<ra>abs(g`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(f) \\<lsq> (abs(p)\\<ra>(C\\<cdot>abs(p)\\<ra>D)\\<ra>\\<two>)\\<cdot>max\\<delta>(f)\"\n\tusing Int_ZF_2_1_L8 Int_ZF_1_3_L13 by auto\n      moreover from A1 D1 T1 have \n\t\"(abs(p)\\<ra>(A\\<cdot>abs(p)\\<ra>B)\\<ra>\\<two>)\\<cdot>max\\<delta>(g) = \n\tmax\\<delta>(g)\\<cdot>(A\\<ra>\\<one>)\\<cdot>abs(p) \\<ra> (B\\<cdot>max\\<delta>(g) \\<ra> \\<two>\\<cdot>max\\<delta>(g))\"\n\t\"(abs(p)\\<ra>(C\\<cdot>abs(p)\\<ra>D)\\<ra>\\<two>)\\<cdot>max\\<delta>(f) = \n\tmax\\<delta>(f)\\<cdot>(C\\<ra>\\<one>)\\<cdot>abs(p) \\<ra> (D\\<cdot>max\\<delta>(f) \\<ra> \\<two>\\<cdot>max\\<delta>(f))\"\n\tusing Int_ZF_2_1_L8 Int_ZF_1_2_L13 by auto\n      ultimately have \n\t\"(abs(p)\\<ra>abs(f`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(g) \\<ra> (abs(p)\\<ra>abs(g`(p))\\<ra>\\<two>)\\<cdot>max\\<delta>(f) \\<lsq>\n\t(max\\<delta>(g)\\<cdot>(A\\<ra>\\<one>)\\<cdot>abs(p) \\<ra> (B\\<cdot>max\\<delta>(g) \\<ra> \\<two>\\<cdot>max\\<delta>(g))) \\<ra> \n\t(max\\<delta>(f)\\<cdot>(C\\<ra>\\<one>)\\<cdot>abs(p) \\<ra> (D\\<cdot>max\\<delta>(f) \\<ra> \\<two>\\<cdot>max\\<delta>(f)))\"\n\tusing int_ineq_add_sides by simp\n      moreover from A1 A2 D1 have \"abs(p) \\<in> \\<int>\"\n\t\"max\\<delta>(g)\\<cdot>(A\\<ra>\\<one>) \\<in> \\<int>\"  \"B\\<cdot>max\\<delta>(g) \\<ra> \\<two>\\<cdot>max\\<delta>(g) \\<in> \\<int>\"\n\t\"max\\<delta>(f)\\<cdot>(C\\<ra>\\<one>) \\<in> \\<int>\"  \"D\\<cdot>max\\<delta>(f) \\<ra> \\<two>\\<cdot>max\\<delta>(f) \\<in> \\<int>\" \n\tusing Int_ZF_2_L14 Int_ZF_2_1_L8 int_zero_one_are_int \n\t  Int_ZF_1_1_L5 int_two_three_are_int by auto\n      ultimately show ?thesis using Int_ZF_1_2_L14 by simp\n    qed\n    ultimately have\n      \"abs((f`(g`(p))\\<rs>g`(f`(p)))\\<cdot>p) \\<lsq> ?E\\<cdot>abs(p) \\<ra> ?F\"\n      by (rule Int_order_transitive)\n    with A2 T1 have\n      \"abs(f`(g`(p))\\<rs>g`(f`(p)))\\<cdot>abs(p) \\<lsq> ?E\\<cdot>abs(p) \\<ra> ?F\"\n      \"abs(f`(g`(p))\\<rs>g`(f`(p))) \\<in> \\<int>\"\n      using Int_ZF_1_3_L5 by auto\n  } then have \n      \"\\<forall>p\\<in>\\<int>. abs(f`(g`(p))\\<rs>g`(f`(p))) \\<in> \\<int>\"\n      \"\\<forall>p\\<in>\\<int>. abs(f`(g`(p))\\<rs>g`(f`(p)))\\<cdot>abs(p) \\<lsq> ?E\\<cdot>abs(p) \\<ra> ?F\"\n    by auto\n  moreover from A1 D1 have \"?E \\<in> \\<int>\"  \"?F \\<in> \\<int>\"\n    using int_zero_one_are_int int_two_three_are_int Int_ZF_2_1_L8 Int_ZF_1_1_L5\n    by auto\n  ultimately have\n    \"\\<exists>L. \\<forall>p\\<in>\\<int>. abs(f`(g`(p))\\<rs>g`(f`(p))) \\<lsq> L\"\n    by (rule Int_ZF_1_7_L1)\n  with A1 obtain L where \"\\<forall>p\\<in>\\<int>. abs((f\\<circ>g)`(p)\\<rs>(g\\<circ>f)`(p)) \\<lsq> L\"\n    using Int_ZF_2_1_L10 by auto\n  moreover from A1 have \"f\\<circ>g \\<in> \\<S>\"  \"g\\<circ>f \\<in> \\<S>\"\n    using Int_ZF_2_1_L11 by auto\n  ultimately show \"f\\<circ>g \\<sim> g\\<circ>f\" using Int_ZF_2_1_L9 by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 892
    },
    "801": {
        "type": "lemma",
        "text": "text\\<open>A small technical lemma to simplify the proof of the next theorem.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"\\<exists>n \\<in> f``(\\<int>\\<^sub>+) \\<inter> \\<int>\\<^sub>+. a\\<lsq>n\"\n  ",
        "using": [
            "AlmostHoms_def",
            "PositiveSet_def",
            "func_imagedef"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L1A: \n  assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"\\<exists>n \\<in> f``(\\<int>\\<^sub>+) \\<inter> \\<int>\\<^sub>+. a\\<lsq>n\"\n  shows \"\\<exists>M\\<in>\\<int>\\<^sub>+. a \\<lsq> f`(M)\"\n",
        "proof": "proof -\n from A1 have \"f:\\<int>\\<rightarrow>\\<int>\"  \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" \n    using AlmostHoms_def PositiveSet_def by auto\n with A2 show ?thesis using func_imagedef by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 894
    },
    "802": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open> Arthan_Lem_3\\<close> when $D=1$.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "PositiveSet_def",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_1_L4",
            "int_one_two_are_pos",
            "Arthan_Lem_3"
        ],
        "statement": "corollary (in int1) Arthan_L_3_spec: assumes A1: \"f \\<in> \\<S>\\<^sub>+\"\n  shows \"\\<exists>M\\<in>\\<int>\\<^sub>+.\\<forall>n\\<in>\\<int>\\<^sub>+. n\\<ra>\\<one> \\<lsq> f`(n\\<cdot>M)\"\n",
        "proof": "proof -\n  have \"\\<forall>n\\<in>\\<int>\\<^sub>+. n\\<ra>\\<one> \\<in> \\<int>\"\n    using PositiveSet_def int_zero_one_are_int Int_ZF_1_1_L5\n    by simp\n  then have \"\\<forall>n\\<in>\\<int>\\<^sub>+. (n\\<ra>\\<one>)\\<cdot>\\<one> = n\\<ra>\\<one>\"\n    using Int_ZF_1_1_L4 by simp\n  moreover from A1 have \"\\<exists>M\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. (n\\<ra>\\<one>)\\<cdot>\\<one> \\<lsq> f`(n\\<cdot>M)\" \n    using int_one_two_are_pos Arthan_Lem_3 by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 896
    },
    "803": {
        "type": "lemma",
        "text": "text\\<open>We know  from \\<open>Group_ZF_3.thy\\<close> that finite range functions are almost homomorphisms. \n  Besides reminding that fact for slopes the next lemma shows \n  that finite range functions do not belong to \\<open>\\<S>\\<^sub>+\\<close>. \n  This is important, because the projection\n  of the set of finite range functions defines zero in the real number construction in \\<open>Real_ZF_x.thy\\<close> \n  series, while the projection of \\<open>\\<S>\\<^sub>+\\<close> becomes the set of (strictly) positive reals. \n  We don't want zero to be positive, do we? The next lemma is a part of Lemma 5 in the Arthan's paper \n  \\cite{Arthan2004}.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  ",
        "using": [
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_3_L1",
            "PositiveSet_def",
            "Finite1_L21",
            "Fin_subset_lemma"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L1B: \n  assumes A1: \"f \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  shows \"f\\<in>\\<S>\"   \"f \\<notin> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 show \"f\\<in>\\<S>\" using Int_ZF_2_1_L1 group1.Group_ZF_3_3_L1\n    by auto\n  have \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" using PositiveSet_def by auto\n  with A1 have \"f``(\\<int>\\<^sub>+) \\<in> Fin(\\<int>)\"\n    using Finite1_L21 by simp\n  then have \"f``(\\<int>\\<^sub>+) \\<inter> \\<int>\\<^sub>+ \\<in> Fin(\\<int>)\"\n    using Fin_subset_lemma by blast\n  thus \"f \\<notin> \\<S>\\<^sub>+\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 897
    },
    "804": {
        "type": "lemma",
        "text": "text\\<open>We want to show that if $f$ is a slope and neither $f$ nor $-f$ are in \\<open>\\<S>\\<^sub>+\\<close>, \n  then $f$ is bounded. The next lemma is the first step towards that goal and \n  shows that if slope is not in \\<open>\\<S>\\<^sub>+\\<close> then $f($\\<open>\\<int>\\<^sub>+\\<close>$)$ is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"f \\<notin> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "AlmostHoms_def",
            "func1_1_L6",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_2_L4"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L2: assumes A1: \"f\\<in>\\<S>\" and A2: \"f \\<notin> \\<S>\\<^sub>+\"\n  shows \"IsBoundedAbove(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n",
        "proof": "proof -\n  from A1 have \"f:\\<int>\\<rightarrow>\\<int>\" using AlmostHoms_def by simp\n  then have \"f``(\\<int>\\<^sub>+) \\<subseteq> \\<int>\" using func1_1_L6 by simp\n  moreover from A1 A2 have \"f``(\\<int>\\<^sub>+) \\<inter> \\<int>\\<^sub>+ \\<in> Fin(\\<int>)\" by auto\n  ultimately show ?thesis using Int_ZF_2_T1 group3.OrderedGroup_ZF_2_L4\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 898
    },
    "805": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a slope and $-f\\notin$ \\<open>\\<S>\\<^sub>+\\<close>, then \n  $f($\\<open>\\<int>\\<^sub>+\\<close>$)$ is bounded below.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"\\<fm>f \\<notin> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "AlmostHoms_def",
            "Int_ZF_1_T2",
            "group0_2_T2",
            "PositiveSet_def",
            "func1_1_L15C",
            "Int_ZF_2_1_L12",
            "Int_ZF_2_3_L2",
            "func1_1_L6",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_2_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L3: assumes A1: \"f\\<in>\\<S>\" and A2: \"\\<fm>f \\<notin> \\<S>\\<^sub>+\"\n  shows \"IsBoundedBelow(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n",
        "proof": "proof -\n  from A1 have T: \"f:\\<int>\\<rightarrow>\\<int>\" using AlmostHoms_def by simp\n  then have \"(\\<sm>(f``(\\<int>\\<^sub>+))) = (\\<fm>f)``(\\<int>\\<^sub>+)\"\n    using Int_ZF_1_T2 group0_2_T2 PositiveSet_def func1_1_L15C\n    by auto\n  with A1 A2 T show \"IsBoundedBelow(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n    using Int_ZF_2_1_L12 Int_ZF_2_3_L2 PositiveSet_def func1_1_L6 \n      Int_ZF_2_T1 group3.OrderedGroup_ZF_2_L5 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 899
    },
    "806": {
        "type": "lemma",
        "text": "text\\<open>A slope that is bounded on \\<open>\\<int>\\<^sub>+\\<close> is bounded everywhere.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\" \n  and A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. abs(f`(n)) \\<lsq> L\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_2_1_L2B",
            "int_abs_nonneg",
            "int_one_two_are_pos",
            "Int_ZF_2_1_L8",
            "Int_ZF_2_L15F",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_3_L5A",
            "int_two_three_are_int",
            "Int_ZF_1_1_L5",
            "PositiveSet_def",
            "Int_ZF_2_1_L14",
            "Int_ZF_2_L15A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L4: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\" \n  and A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. abs(f`(n)) \\<lsq> L\"\n  shows \"abs(f`(m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> L\"\n",
        "proof": "proof -\n  from A1 A3 have \n    \"\\<zero> \\<lsq> abs(f`(\\<one>))\"  \"abs(f`(\\<one>)) \\<lsq> L\"\n    using int_zero_one_are_int Int_ZF_2_1_L2B int_abs_nonneg int_one_two_are_pos\n    by auto\n  then have II: \"\\<zero>\\<lsq>L\" by (rule Int_order_transitive)\n  note A2\n  moreover have \"abs(f`(\\<zero>)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> L\"\n  proof -\n    from A1 have \n      \"abs(f`(\\<zero>)) \\<lsq> max\\<delta>(f)\"  \"\\<zero> \\<lsq> max\\<delta>(f)\" \n      and T: \"max\\<delta>(f) \\<in> \\<int>\"\n      using Int_ZF_2_1_L8 by auto\n    with II have \"abs(f`(\\<zero>)) \\<lsq> max\\<delta>(f) \\<ra> max\\<delta>(f) \\<ra> L\"\n      using Int_ZF_2_L15F by simp\n    with T show ?thesis using Int_ZF_1_1_L4 by simp\n  qed\n  moreover from A1 A3 II have \n    \"\\<forall>n\\<in>\\<int>\\<^sub>+. abs(f`(n)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> L\"\n    using Int_ZF_2_1_L8 Int_ZF_1_3_L5A Int_ZF_2_L15F \n    by simp\n  moreover have \"\\<forall>n\\<in>\\<int>\\<^sub>+. abs(f`(\\<rm>n)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> L\"\n  proof\n    fix n assume \"n\\<in>\\<int>\\<^sub>+\"\n    with A1 A3 have\n      \"\\<two>\\<cdot>max\\<delta>(f) \\<in> \\<int>\"\n      \"abs(f`(\\<rm>n)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> abs(f`(n))\"\n      \"abs(f`(n)) \\<lsq> L\"\n      using int_two_three_are_int Int_ZF_2_1_L8 Int_ZF_1_1_L5\n\tPositiveSet_def Int_ZF_2_1_L14 by auto\n    then show \"abs(f`(\\<rm>n)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> L\"\n      using Int_ZF_2_L15A by blast\n  qed    \n  ultimately show ?thesis by (rule Int_ZF_2_L19B)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 900
    },
    "807": {
        "type": "lemma",
        "text": "text\\<open>A slope whose image of the set of positive integers is bounded\n  is a finite range function.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"IsBounded(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n  ",
        "using": [
            "PositiveSet_def",
            "AlmostHoms_def",
            "Int_ZF_1_3_L20A",
            "Int_ZF_2_3_L4",
            "FinRangeFunctions_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L4A: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"IsBounded(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n  shows \"f \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n",
        "proof": "proof -\n  have T1: \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" using PositiveSet_def by auto\n  from A1 have T2: \"f:\\<int>\\<rightarrow>\\<int>\" using AlmostHoms_def by simp\n  from A2 obtain L where \"\\<forall>a\\<in>f``(\\<int>\\<^sub>+). abs(a) \\<lsq> L\"\n    using Int_ZF_1_3_L20A by auto\n  with T2 T1 have \"\\<forall>n\\<in>\\<int>\\<^sub>+. abs(f`(n)) \\<lsq> L\"\n    by (rule func1_1_L15B)\n  with A1 have \"\\<forall>m\\<in>\\<int>. abs(f`(m)) \\<lsq> \\<two>\\<cdot>max\\<delta>(f) \\<ra> L\"\n    using Int_ZF_2_3_L4 by simp\n  with T2 have \"f``(\\<int>) \\<in> Fin(\\<int>)\"\n    by (rule Int_ZF_1_3_L20C)\n  with T2 show \"f \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n    using FinRangeFunctions_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 901
    },
    "808": {
        "type": "lemma",
        "text": "text\\<open>A slope whose image of the set of positive integers is bounded\n  below is a finite range function or a positive slope.\\<close>\n",
        "assumes": "assumes \"f\\<in>\\<S>\" and \"IsBoundedBelow(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_3_L2",
            "IsBounded_def",
            "Int_ZF_2_3_L4A"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L4B: \n  assumes \"f\\<in>\\<S>\" and \"IsBoundedBelow(f``(\\<int>\\<^sub>+), IntegerOrder)\"\n  shows \"f \\<in> FinRangeFunctions(\\<int>,\\<int>) \\<or> f\\<in>\\<S>\\<^sub>+\"\n  ",
        "proof": "using assms Int_ZF_2_3_L2 IsBounded_def Int_ZF_2_3_L4A\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 902
    },
    "809": {
        "type": "lemma",
        "text": "text\\<open>If one slope is not greater then another on positive integers,\n  then they are almost equal or the difference is a positive slope.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\" and\n  A2: \"\\<forall>n\\<in>\\<int>\\<^sub>+. f`(n) \\<lsq> g`(n)\"\n  ",
        "using": [
            "Int_ZF_2_1_L12",
            "Int_ZF_2_1_L12C",
            "AlmostHoms_def",
            "PositiveSet_def",
            "Int_ZF_2_1_L2B",
            "Int_ZF_1_3_L10A",
            "Int_ZF_2_1_L12B",
            "Int_ZF_2_1_L12A",
            "Int_ZF_2_3_L4B",
            "Int_ZF_2_1_L9C"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L4C: assumes A1: \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\" and\n  A2: \"\\<forall>n\\<in>\\<int>\\<^sub>+. f`(n) \\<lsq> g`(n)\"\n  shows \"f\\<sim>g \\<or> g \\<fp> (\\<fm>f) \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  let ?h = \"g \\<fp> (\\<fm>f)\"\n  from A1 have \"(\\<fm>f) \\<in> \\<S>\" using Int_ZF_2_1_L12 \n    by simp\n  with A1 have I: \"?h \\<in> \\<S>\" using Int_ZF_2_1_L12C \n    by simp\n  moreover have \"IsBoundedBelow(?h``(\\<int>\\<^sub>+), IntegerOrder)\"\n  proof -\n    from I have \n      \"?h:\\<int>\\<rightarrow>\\<int>\" and \"\\<int>\\<^sub>+\\<subseteq>\\<int>\" using AlmostHoms_def PositiveSet_def\n      by auto\n    moreover from A1 A2 have \"\\<forall>n\\<in>\\<int>\\<^sub>+. \\<langle>\\<zero>, ?h`(n)\\<rangle> \\<in> IntegerOrder\"\n      using Int_ZF_2_1_L2B PositiveSet_def Int_ZF_1_3_L10A \n\tInt_ZF_2_1_L12 Int_ZF_2_1_L12B Int_ZF_2_1_L12A\n      by simp\n    ultimately show \"IsBoundedBelow(?h``(\\<int>\\<^sub>+), IntegerOrder)\"\n      by (rule func_ZF_8_L1)\n  qed\n  ultimately have \"?h \\<in> FinRangeFunctions(\\<int>,\\<int>) \\<or> ?h\\<in>\\<S>\\<^sub>+\"\n    using Int_ZF_2_3_L4B by simp\n  with A1 show \"f\\<sim>g \\<or> g \\<fp> (\\<fm>f) \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_1_L9C by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 903
    },
    "810": {
        "type": "lemma",
        "text": "text\\<open>Positive slopes are arbitrarily large for large enough arguments.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"K\\<in>\\<int>\"\n  ",
        "using": [
            "Arthan_L_3_spec",
            "Int_ZF_2_1_L15",
            "Int_ZF_2_1_L8",
            "Int_ZF_1_1_L5",
            "PositiveSet_def",
            "int_zero_one_are_int",
            "Int_ZF_1_3_L18",
            "Int_ZF_2_L9C",
            "Int_ZF_2_L1A",
            "Int_ZF_1_5_L3",
            "IntDiv_ZF_1_L5",
            "int_ord_transl_inv",
            "Int_ZF_2_1_L16"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L5: \n  assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"K\\<in>\\<int>\"\n  shows \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n",
        "proof": "proof -\n  from A1 obtain M where I: \"M\\<in>\\<int>\\<^sub>+\" and II: \"\\<forall>n\\<in>\\<int>\\<^sub>+. n\\<ra>\\<one> \\<lsq> f`(n\\<cdot>M)\"\n    using Arthan_L_3_spec by auto\n  let ?j = \"GreaterOf(IntegerOrder,M,K \\<rs> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f)) \\<rs> \\<one>)\"\n  from A1 I have T1: \n    \"minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f) \\<in> \\<int>\"  \"M\\<in>\\<int>\"\n    using Int_ZF_2_1_L15 Int_ZF_2_1_L8 Int_ZF_1_1_L5 PositiveSet_def\n    by auto\n  with A2 I have T2: \n    \"K \\<rs> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f)) \\<in> \\<int>\"\n    \"K \\<rs> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f)) \\<rs> \\<one> \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 int_zero_one_are_int by auto\n  with T1 have III: \"M \\<lsq> ?j\"  and \n    \"K \\<rs> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f)) \\<rs> \\<one> \\<lsq> ?j\"\n    using Int_ZF_1_3_L18 by auto\n  with A2 T1 T2 have \n    IV: \"K \\<lsq> ?j\\<ra>\\<one> \\<ra> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f))\"\n    using int_zero_one_are_int Int_ZF_2_L9C by simp\n  let ?N = \"GreaterOf(IntegerOrder,\\<one>,?j\\<cdot>M)\"\n  from T1 III have T3: \"?j \\<in> \\<int>\"  \"?j\\<cdot>M \\<in> \\<int>\"\n    using Int_ZF_2_L1A Int_ZF_1_1_L5 by auto\n  then have V: \"?N \\<in> \\<int>\\<^sub>+\" and VI: \"?j\\<cdot>M \\<lsq> ?N\"\n    using int_zero_one_are_int Int_ZF_1_5_L3 Int_ZF_1_3_L18 \n    by auto\n  { fix m\n    let ?n = \"m zdiv M\"\n    let ?k = \"m zmod M\"\n    assume \"?N\\<lsq>m\"\n    with VI have \"?j\\<cdot>M \\<lsq> m\" by (rule Int_order_transitive)\n    with I III have \n      VII: \"m = ?n\\<cdot>M\\<ra>?k\" \n      \"?j \\<lsq> ?n\"  and \n      VIII: \"?n \\<in> \\<int>\\<^sub>+\"  \"?k \\<in> \\<zero>..(M\\<rs>\\<one>)\"\n      using IntDiv_ZF_1_L5 by auto\n    with II have \n      \"?j \\<ra> \\<one> \\<lsq> ?n \\<ra> \\<one>\"  \"?n\\<ra>\\<one> \\<lsq> f`(?n\\<cdot>M)\"\n      using int_zero_one_are_int int_ord_transl_inv by auto\n    then have \"?j \\<ra> \\<one> \\<lsq>  f`(?n\\<cdot>M)\"\n      by (rule Int_order_transitive)\n    with T1 have \n      \"?j\\<ra>\\<one> \\<ra> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f)) \\<lsq>  \n      f`(?n\\<cdot>M) \\<ra> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f))\"\n      using int_ord_transl_inv by simp\n    with IV have \"K \\<lsq> f`(?n\\<cdot>M) \\<ra> (minf(f,\\<zero>..(M\\<rs>\\<one>)) \\<rs> max\\<delta>(f))\"\n      by (rule Int_order_transitive)\n    moreover from A1 I VIII have\n      \"f`(?n\\<cdot>M) \\<ra> (minf(f,\\<zero>..(M\\<rs>\\<one>))\\<rs> max\\<delta>(f)) \\<lsq> f`(?n\\<cdot>M\\<ra>?k)\"\n      using PositiveSet_def Int_ZF_2_1_L16 by simp\n    ultimately have \"K \\<lsq> f`(?n\\<cdot>M\\<ra>?k)\"\n      by (rule Int_order_transitive)\n    with VII have \"K \\<lsq> f`(m)\" by simp\n    } then have  \"\\<forall>m. ?N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n      by simp\n    with V show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 904
    },
    "811": {
        "type": "lemma",
        "text": "text\\<open>Positive slopes are arbitrarily small for small enough arguments.\n  Kind of dual to \\<open>Int_ZF_2_3_L5\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"K\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_1_L8",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_3_L5",
            "Int_ZF_2_L1A",
            "Int_ZF_2_1_L14",
            "Int_ZF_2_L10",
            "int_ord_transl_inv",
            "Int_ZF_1_2_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L5A: assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"K\\<in>\\<int>\"\n  shows \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> f`(\\<rm>m) \\<lsq> K\"\n",
        "proof": "proof -\n  from A1 have T1: \"abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<in> \\<int>\"\n    using Int_ZF_2_1_L8 by auto\n  with A2 have \"abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> K \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 by simp\n  with A1 have \n    \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> K \\<lsq> f`(m)\"\n    using Int_ZF_2_3_L5 by simp\n  then obtain N where I: \"N\\<in>\\<int>\\<^sub>+\" and II:\n    \"\\<forall>m. N\\<lsq>m \\<longrightarrow>  abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> K \\<lsq> f`(m)\"\n    by auto\n  { fix m assume A3: \"N\\<lsq>m\"\n    with A1 have\n      \"f`(\\<rm>m) \\<lsq> abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> f`(m)\"\n      using Int_ZF_2_L1A Int_ZF_2_1_L14 by simp\n    moreover\n    from II T1 A3 have \"abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> f`(m) \\<lsq> \n      (abs(f`(\\<zero>)) \\<ra> max\\<delta>(f)) \\<rs>(abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> K)\"\n      using Int_ZF_2_L10 int_ord_transl_inv by simp\n    with A2 T1 have \"abs(f`(\\<zero>)) \\<ra> max\\<delta>(f) \\<rs> f`(m) \\<lsq> K\"\n      using Int_ZF_1_2_L3 by simp\n    ultimately have \"f`(\\<rm>m) \\<lsq> K\"\n      by (rule Int_order_transitive)\n  } then have \"\\<forall>m. N\\<lsq>m  \\<longrightarrow> f`(\\<rm>m) \\<lsq> K\"\n    by simp\n  with I show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 905
    },
    "812": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>Int_ZF_2_3_L5\\<close> where $K=1$.\\<close>\n",
        "assumes": "assumes \"f\\<in>\\<S>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "int_zero_one_are_int",
            "Int_ZF_2_3_L5",
            "Int_ZF_1_5_L3"
        ],
        "statement": "corollary (in int1) Int_ZF_2_3_L6: assumes \"f\\<in>\\<S>\\<^sub>+\"\n  shows \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> f`(m) \\<in> \\<int>\\<^sub>+\"\n  ",
        "proof": "using assms int_zero_one_are_int Int_ZF_2_3_L5 Int_ZF_1_5_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 906
    },
    "813": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>Int_ZF_2_3_L5\\<close> where $m=N$.\\<close> \n",
        "assumes": "assumes \"f\\<in>\\<S>\\<^sub>+\" and \"K\\<in>\\<int>\"\n   ",
        "using": [
            "Int_ZF_2_3_L5",
            "PositiveSet_def",
            "int_ord_is_refl",
            "refl_def"
        ],
        "statement": "corollary (in int1) Int_ZF_2_3_L6A: assumes \"f\\<in>\\<S>\\<^sub>+\" and \"K\\<in>\\<int>\"\n   shows \"\\<exists>N\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(N)\"\n",
        "proof": "proof -\n  from assms have \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n    using Int_ZF_2_3_L5 by simp\n  then obtain N where I: \"N \\<in> \\<int>\\<^sub>+\"  and II: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n    by auto\n  then show ?thesis using PositiveSet_def int_ord_is_refl refl_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 907
    },
    "814": {
        "type": "lemma",
        "text": "text\\<open>If values of a slope are not bounded above, \n  then the slope is positive.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" \n  and A2: \"\\<forall>K\\<in>\\<int>. \\<exists>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\"\n  ",
        "using": [
            "PositiveSet_def",
            "AlmostHoms_def",
            "func1_1_L15D",
            "Int_ZF_4_L9",
            "Int_ZF_2_3_L2"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L7: assumes A1: \"f\\<in>\\<S>\" \n  and A2: \"\\<forall>K\\<in>\\<int>. \\<exists>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n)\"\n  shows \"f \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  { fix K assume \"K\\<in>\\<int>\"\n    with A2 obtain n where \"n\\<in>\\<int>\\<^sub>+\"  \"K \\<lsq> f`(n)\"\n      by auto\n    moreover from A1 have \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\"  \"f:\\<int>\\<rightarrow>\\<int>\" \n      using PositiveSet_def AlmostHoms_def by auto\n    ultimately have \"\\<exists>m \\<in> f``(\\<int>\\<^sub>+). K \\<lsq> m\" \n      using func1_1_L15D by auto\n  } then have \"\\<forall>K\\<in>\\<int>. \\<exists>m \\<in> f``(\\<int>\\<^sub>+). K \\<lsq> m\" by simp\n  with A1 show \"f \\<in> \\<S>\\<^sub>+\" using Int_ZF_4_L9 Int_ZF_2_3_L2\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 908
    },
    "815": {
        "type": "theorem",
        "text": "text\\<open>For unbounded slope $f$ either $f\\in$\\<open>\\<S>\\<^sub>+\\<close> of \n  $-f\\in$\\<open>\\<S>\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"f \\<notin> FinRangeFunctions(\\<int>,\\<int>)\"\n  ",
        "using": [
            "PositiveSet_def",
            "AlmostHoms_def",
            "func1_1_L6",
            "Int_ZF_2_3_L2",
            "Int_ZF_2_3_L3",
            "IsBounded_def",
            "Int_ZF_2_3_L4A",
            "Int_ZF_2_3_L6",
            "Int_ZF_1_3_L18",
            "Int_ZF_2_L1A",
            "Int_ZF_2_1_L12A",
            "Int_ZF_1_5_L8",
            "Xor_def"
        ],
        "statement": "theorem (in int1) Int_ZF_2_3_L8:\n  assumes A1: \"f\\<in>\\<S>\" and A2: \"f \\<notin> FinRangeFunctions(\\<int>,\\<int>)\"\n  shows \"(f \\<in> \\<S>\\<^sub>+) Xor ((\\<fm>f) \\<in> \\<S>\\<^sub>+)\"\n",
        "proof": "proof -\n  have T1: \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" using PositiveSet_def by auto\n  from A1 have T2: \"f:\\<int>\\<rightarrow>\\<int>\"  using AlmostHoms_def by simp\n  then have I: \"f``(\\<int>\\<^sub>+) \\<subseteq> \\<int>\" using func1_1_L6 by auto\n  from A1 A2 have \"f \\<in> \\<S>\\<^sub>+ \\<or> (\\<fm>f) \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_3_L2 Int_ZF_2_3_L3 IsBounded_def Int_ZF_2_3_L4A\n    by blast\n  moreover have \"\\<not>(f \\<in> \\<S>\\<^sub>+ \\<and> (\\<fm>f) \\<in> \\<S>\\<^sub>+)\"\n  proof -\n    { assume A3: \"f \\<in> \\<S>\\<^sub>+\"  and A4: \"(\\<fm>f) \\<in> \\<S>\\<^sub>+\"\n      from A3 obtain N1 where \n\tI: \"N1\\<in>\\<int>\\<^sub>+\" and II: \"\\<forall>m. N1\\<lsq>m \\<longrightarrow> f`(m) \\<in> \\<int>\\<^sub>+\"\n\tusing Int_ZF_2_3_L6 by auto\n      from A4 obtain N2 where \n\tIII: \"N2\\<in>\\<int>\\<^sub>+\" and IV: \"\\<forall>m. N2\\<lsq>m \\<longrightarrow> (\\<fm>f)`(m) \\<in> \\<int>\\<^sub>+\"\n\tusing Int_ZF_2_3_L6 by auto\n      let ?N = \"GreaterOf(IntegerOrder,N1,N2)\"\n      from I III have \"N1 \\<lsq> ?N\"  \"N2 \\<lsq> ?N\"\n\tusing PositiveSet_def Int_ZF_1_3_L18 by auto\n      with A1 II IV have\n\t\"f`(?N) \\<in> \\<int>\\<^sub>+\"  \"(\\<fm>f)`(?N) \\<in> \\<int>\\<^sub>+\"  \"(\\<fm>f)`(?N) = \\<rm>(f`(?N))\"\n\tusing Int_ZF_2_L1A PositiveSet_def Int_ZF_2_1_L12A\n\tby auto\n      then have False using Int_ZF_1_5_L8 by simp\n    } thus ?thesis by auto\n  qed\n  ultimately show \"(f \\<in> \\<S>\\<^sub>+) Xor ((\\<fm>f) \\<in> \\<S>\\<^sub>+)\"\n    using Xor_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 909
    },
    "816": {
        "type": "theorem",
        "text": "text\\<open>The sum of positive slopes is a positive slope.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\"  \"g \\<in> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_3_L5",
            "int_zero_one_are_int",
            "GreaterOf_def",
            "PositiveSet_def",
            "Int_ZF_2_1_L12B",
            "Int_ZF_1_3_L18",
            "Int_ZF_2_L15F",
            "Int_ZF_2_1_L12C",
            "Int_ZF_2_3_L7"
        ],
        "statement": "theorem (in int1) sum_of_pos_sls_is_pos_sl: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\"  \"g \\<in> \\<S>\\<^sub>+\"\n  shows \"f\\<fp>g \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  { fix K assume \"K\\<in>\\<int>\"\n    with A1 have \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n      using Int_ZF_2_3_L5 by simp\n    then obtain N where I: \"N\\<in>\\<int>\\<^sub>+\" and II: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n      by auto\n    from A1 have \"\\<exists>M\\<in>\\<int>\\<^sub>+. \\<forall>m. M\\<lsq>m \\<longrightarrow> \\<zero> \\<lsq> g`(m)\"\n      using int_zero_one_are_int Int_ZF_2_3_L5 by simp\n    then obtain M where III: \"M\\<in>\\<int>\\<^sub>+\" and IV: \"\\<forall>m. M\\<lsq>m \\<longrightarrow> \\<zero> \\<lsq> g`(m)\"\n      by auto\n    let ?L = \"GreaterOf(IntegerOrder,N,M)\"\n    from I III have V: \"?L \\<in> \\<int>\\<^sub>+\"  \"\\<int>\\<^sub>+ \\<subseteq> \\<int>\" \n      using GreaterOf_def PositiveSet_def by auto\n    moreover from A1 V have \"(f\\<fp>g)`(?L) = f`(?L) \\<ra> g`(?L)\"\n      using Int_ZF_2_1_L12B by auto\n    moreover from I II III IV have \"K \\<lsq> f`(?L) \\<ra> g`(?L)\"\n      using PositiveSet_def Int_ZF_1_3_L18 Int_ZF_2_L15F\n      by simp\n    ultimately have \"?L \\<in> \\<int>\\<^sub>+\"  \"K \\<lsq> (f\\<fp>g)`(?L)\"\n      by auto\n    then have \"\\<exists>n \\<in>\\<int>\\<^sub>+. K \\<lsq> (f\\<fp>g)`(n)\"\n      by auto\n  } with A1 show \"f\\<fp>g \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_1_L12C Int_ZF_2_3_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 910
    },
    "817": {
        "type": "theorem",
        "text": "text\\<open>The composition of positive slopes is a positive slope.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\"  \"g \\<in> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_3_L5",
            "PositiveSet_def",
            "Int_ZF_2_3_L6A",
            "Int_ZF_2_1_L10",
            "Int_ZF_2_1_L11",
            "Int_ZF_2_3_L7"
        ],
        "statement": "theorem (in int1) comp_of_pos_sls_is_pos_sl: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\"  \"g \\<in> \\<S>\\<^sub>+\"\n  shows \"f\\<circ>g \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  { fix K assume \"K\\<in>\\<int>\"\n    with A1 have \"\\<exists>N\\<in>\\<int>\\<^sub>+. \\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n      using Int_ZF_2_3_L5 by simp\n    then obtain N where \"N\\<in>\\<int>\\<^sub>+\" and I: \"\\<forall>m. N\\<lsq>m \\<longrightarrow> K \\<lsq> f`(m)\"\n      by auto\n    with A1 have \"\\<exists>M\\<in>\\<int>\\<^sub>+. N \\<lsq> g`(M)\"\n      using PositiveSet_def Int_ZF_2_3_L6A by simp\n    then obtain M where \"M\\<in>\\<int>\\<^sub>+\"  \"N \\<lsq> g`(M)\"\n      by auto\n    with A1 I have \"\\<exists>M\\<in>\\<int>\\<^sub>+. K \\<lsq> (f\\<circ>g)`(M)\"\n      using PositiveSet_def Int_ZF_2_1_L10\n      by auto\n  } with A1 show \"f\\<circ>g \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_1_L11 Int_ZF_2_3_L7\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 911
    },
    "818": {
        "type": "lemma",
        "text": "text\\<open>A slope equivalent to a positive one is positive.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"\\<langle>f,g\\<rangle> \\<in> AlEqRel\" ",
        "using": [
            "Int_ZF_2_1_L9A",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_3_L6A",
            "PositiveSet_def",
            "Int_ZF_2_1_L2B",
            "Int_ZF_2_L9B",
            "Int_triangle_ineq2",
            "Int_ZF_2_3_L7"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L9: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"\\<langle>f,g\\<rangle> \\<in> AlEqRel\" shows \"g \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  from A2 have T: \"g\\<in>\\<S>\" and \"\\<exists>L\\<in>\\<int>. \\<forall>m\\<in>\\<int>. abs(f`(m)\\<rs>g`(m)) \\<lsq> L\"\n    using Int_ZF_2_1_L9A by auto\n   then obtain L where \n     I: \"L\\<in>\\<int>\"  and II: \"\\<forall>m\\<in>\\<int>. abs(f`(m)\\<rs>g`(m)) \\<lsq> L\"\n     by auto\n  { fix K assume A3: \"K\\<in>\\<int>\"\n    with I have \"K\\<ra>L \\<in> \\<int>\"\n      using Int_ZF_1_1_L5 by simp\n    with A1 obtain M where III: \"M\\<in>\\<int>\\<^sub>+\"  and IV: \"K\\<ra>L \\<lsq> f`(M)\"\n      using Int_ZF_2_3_L6A by auto\n    with A1 A3 I have  \"K \\<lsq> f`(M)\\<rs>L\"\n      using PositiveSet_def Int_ZF_2_1_L2B Int_ZF_2_L9B\n      by simp\n    moreover from A1 T II III have  \n      \"f`(M)\\<rs>L \\<lsq> g`(M)\"\n      using PositiveSet_def Int_ZF_2_1_L2B Int_triangle_ineq2\n      by simp\n    ultimately have \"K \\<lsq>  g`(M)\"\n      by (rule Int_order_transitive)\n    with III have \"\\<exists>n\\<in>\\<int>\\<^sub>+. K \\<lsq> g`(n)\"\n      by auto\n  } with T show \"g \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_3_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 912
    },
    "819": {
        "type": "lemma",
        "text": "text\\<open>Identity function is a positive slope.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_5_L9",
            "PositiveSet_def",
            "Int_ZF_2_1_L17",
            "Int_ZF_2_3_L7"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L11: shows \"id(\\<int>) \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  let ?f = \"id(\\<int>)\"\n  { fix K assume \"K\\<in>\\<int>\" \n    then obtain n where T: \"n\\<in>\\<int>\\<^sub>+\" and \"K\\<lsq>n\"\n      using Int_ZF_1_5_L9 by auto\n    moreover from T have \"?f`(n) = n\"\n      using PositiveSet_def by simp\n    ultimately have  \"n\\<in>\\<int>\\<^sub>+\" and \"K\\<lsq>?f`(n)\"\n      by auto\n    then have \"\\<exists>n\\<in>\\<int>\\<^sub>+. K\\<lsq>?f`(n)\" by auto\n  } then show \"?f \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_1_L17 Int_ZF_2_3_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 915
    },
    "820": {
        "type": "lemma",
        "text": "text\\<open>The identity function is not almost equal to any bounded function.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  ",
        "using": [
            "Int_ZF_2_3_L11",
            "Int_ZF_2_3_L1B"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L12: assumes A1: \"f \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  shows \"\\<not>(id(\\<int>) \\<sim> f)\"\n",
        "proof": "proof -\n  { from A1 have \"id(\\<int>) \\<in> \\<S>\\<^sub>+\"\n      using Int_ZF_2_3_L11 by simp\n    moreover assume \"\\<langle>id(\\<int>),f\\<rangle> \\<in> AlEqRel\"\n    ultimately have  \"f \\<in> \\<S>\\<^sub>+\"\n      by (rule Int_ZF_2_3_L9)\n    with A1 have False using Int_ZF_2_3_L1B\n      by simp\n  } then show \"\\<not>(id(\\<int>) \\<sim> f)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 916
    },
    "821": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a positive slope, then for every positive integer $p$ \n  the set $\\{n\\in Z_+: p\\leq f(n)\\}$ is a nonempty subset of positive integers.\n  Recall that $f^{-1}(p)$ is the notation for the smallest element of this set.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"p\\<in>\\<int>\\<^sub>+\" and A3: \"A = {n\\<in>\\<int>\\<^sub>+. p \\<lsq> f`(n)}\"\n  ",
        "using": [
            "PositiveSet_def",
            "Int_ZF_2_3_L6A",
            "Int_ZF_1_5_L1C"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L1: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"p\\<in>\\<int>\\<^sub>+\" and A3: \"A = {n\\<in>\\<int>\\<^sub>+. p \\<lsq> f`(n)}\"\n  shows \n  \"A \\<subseteq> \\<int>\\<^sub>+\"  \n  \"A \\<noteq> 0\"\n  \"f\\<inverse>(p) \\<in> A\"\n  \"\\<forall>m\\<in>A. f\\<inverse>(p) \\<lsq> m\"\n",
        "proof": "proof -\n  from A3 show I: \"A \\<subseteq> \\<int>\\<^sub>+\" by auto\n  from A1 A2 have \"\\<exists>n\\<in>\\<int>\\<^sub>+. p \\<lsq> f`(n)\"\n    using PositiveSet_def Int_ZF_2_3_L6A by simp\n  with A3 show II: \"A \\<noteq> 0\" by auto\n  from A3 I II show \n    \"f\\<inverse>(p) \\<in> A\"\n    \"\\<forall>m\\<in>A. f\\<inverse>(p) \\<lsq> m\"\n    using Int_ZF_1_5_L1C by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 917
    },
    "822": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a positive slope and $p$ is a positive integer $p$, then \n   $f^{-1}(p)$ (defined as the minimum of the set $\\{n\\in Z_+: p\\leq f(n)\\}$ ) \n  is a (well defined) positive integer.\\<close>\n",
        "assumes": "assumes \"f \\<in> \\<S>\\<^sub>+\" and \"p\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_4_L1"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L2: \n  assumes \"f \\<in> \\<S>\\<^sub>+\" and \"p\\<in>\\<int>\\<^sub>+\"\n  shows \n  \"f\\<inverse>(p) \\<in> \\<int>\\<^sub>+\" \n  \"p \\<lsq> f`(f\\<inverse>(p))\"\n  ",
        "proof": "using assms Int_ZF_2_4_L1 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 918
    },
    "823": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a positive slope and $p$ is a positive integer such \n  that $n\\leq f(p)$, then\n  $f^{-1}(n) \\leq p$.\\<close>\n",
        "assumes": "assumes \"f \\<in> \\<S>\\<^sub>+\" and  \"m\\<in>\\<int>\\<^sub>+\"  \"p\\<in>\\<int>\\<^sub>+\" and \"m \\<lsq> f`(p)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_4_L1"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L3: \n  assumes \"f \\<in> \\<S>\\<^sub>+\" and  \"m\\<in>\\<int>\\<^sub>+\"  \"p\\<in>\\<int>\\<^sub>+\" and \"m \\<lsq> f`(p)\"\n  shows \"f\\<inverse>(m) \\<lsq> p\"\n  ",
        "proof": "using assms Int_ZF_2_4_L1 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 919
    },
    "824": {
        "type": "lemma",
        "text": "text\\<open>An upper bound $f(f^{-1}(m) -1)$ for positive slopes.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"m\\<in>\\<int>\\<^sub>+\" and A3: \"f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_4_L2",
            "PositiveSet_def",
            "Int_ZF_2_3_L1",
            "apply_funtype",
            "Int_ZF_1_2_L3AA"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L4: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"m\\<in>\\<int>\\<^sub>+\" and A3: \"f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  shows \"f`(f\\<inverse>(m)\\<rs>\\<one>) \\<lsq> m\"   \"f`(f\\<inverse>(m)\\<rs>\\<one>) \\<noteq> m\"\n",
        "proof": "proof -\n  from A1 A2 have T: \"f\\<inverse>(m) \\<in> \\<int>\" using Int_ZF_2_4_L2 PositiveSet_def\n    by simp\n  from A1 A3 have \"f:\\<int>\\<rightarrow>\\<int>\"  and \"f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\"\n    using Int_ZF_2_3_L1 PositiveSet_def by auto\n  with A1 A2 have T1: \"f`(f\\<inverse>(m)\\<rs>\\<one>) \\<in> \\<int>\"  \"m\\<in>\\<int>\" \n    using apply_funtype PositiveSet_def by auto\n  { assume \"m \\<lsq> f`(f\\<inverse>(m)\\<rs>\\<one>)\"\n    with A1 A2 A3 have \"f\\<inverse>(m) \\<lsq> f\\<inverse>(m)\\<rs>\\<one>\" \n      by (rule Int_ZF_2_4_L3)\n    with T have False using Int_ZF_1_2_L3AA\n      by simp\n  } then have I: \"\\<not>(m \\<lsq> f`(f\\<inverse>(m)\\<rs>\\<one>))\" by auto\n  with T1 show \"f`(f\\<inverse>(m)\\<rs>\\<one>) \\<lsq> m\"   \n    by (rule Int_ZF_2_L19)\n  from T1 I show \"f`(f\\<inverse>(m)\\<rs>\\<one>) \\<noteq> m\"\n    by (rule Int_ZF_2_L19)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 920
    },
    "825": {
        "type": "lemma",
        "text": "text\\<open>The (candidate for) the inverse of a positive slope is nondecreasing.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"m\\<in>\\<int>\\<^sub>+\" and A3: \"m\\<lsq>n\"\n  ",
        "using": [
            "Int_ZF_1_5_L7",
            "Int_ZF_2_4_L2",
            "Int_ZF_2_4_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L5:\n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"m\\<in>\\<int>\\<^sub>+\" and A3: \"m\\<lsq>n\"\n  shows \"f\\<inverse>(m) \\<lsq> f\\<inverse>(n)\"\n",
        "proof": "proof -\n  from A2 A3 have T: \"n \\<in> \\<int>\\<^sub>+\" using Int_ZF_1_5_L7 by blast\n  with A1 have \"n \\<lsq> f`(f\\<inverse>(n))\" using Int_ZF_2_4_L2\n    by simp\n  with A3 have \"m \\<lsq> f`(f\\<inverse>(n))\" by (rule Int_order_transitive)\n  with A1 A2 T show \"f\\<inverse>(m) \\<lsq> f\\<inverse>(n)\"\n    using Int_ZF_2_4_L2 Int_ZF_2_4_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 921
    },
    "826": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a slope, then $f(f^{-1}(m+n)-f^{-1}(m) - f^{-1}(n))$ is \n  uniformly bounded above and below. Will it be the messiest IsarMathLib\n  proof ever? Only time will tell.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and\n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_1_L28",
            "Int_ZF_2_1_L30",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_4_L2",
            "pos_int_closed_add_unfolded",
            "PositiveSet_def",
            "Int_ZF_2_4_L4",
            "int_ord_transl_inv",
            "int_ineq_add_sides",
            "Int_ZF_1_2_L9",
            "Int_ZF_1_2_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L7:  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and\n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  shows \n  \"\\<exists>U\\<in>\\<int>. \\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n)) \\<lsq> U\"\n  \"\\<exists>N\\<in>\\<int>. \\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. N \\<lsq> f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n))\"\n",
        "proof": "proof -\n  from A1 have \"\\<exists>L\\<in>\\<int>. \\<forall>r\\<in>\\<int>. f`(r) \\<lsq> f`(r\\<rs>\\<one>) \\<ra> L\"\n    using Int_ZF_2_1_L28 by simp\n  then obtain L where \n    I: \"L\\<in>\\<int>\" and II: \"\\<forall>r\\<in>\\<int>. f`(r) \\<lsq> f`(r\\<rs>\\<one>) \\<ra> L\"\n    by auto\n  from A1 have \n    \"\\<exists>M\\<in>\\<int>. \\<forall>r\\<in>\\<int>.\\<forall>p\\<in>\\<int>.\\<forall>q\\<in>\\<int>. f`(r\\<rs>p\\<rs>q) \\<lsq> f`(r)\\<rs>f`(p)\\<rs>f`(q)\\<ra>M\"\n    \"\\<exists>K\\<in>\\<int>. \\<forall>r\\<in>\\<int>.\\<forall>p\\<in>\\<int>.\\<forall>q\\<in>\\<int>. f`(r)\\<rs>f`(p)\\<rs>f`(q)\\<ra>K \\<lsq> f`(r\\<rs>p\\<rs>q)\"\n    using Int_ZF_2_1_L30 by auto\n  then obtain M K where III: \"M\\<in>\\<int>\" and \n    IV: \"\\<forall>r\\<in>\\<int>.\\<forall>p\\<in>\\<int>.\\<forall>q\\<in>\\<int>. f`(r\\<rs>p\\<rs>q) \\<lsq> f`(r)\\<rs>f`(p)\\<rs>f`(q)\\<ra>M\" \n    and \n    V: \"K\\<in>\\<int>\" and VI: \"\\<forall>r\\<in>\\<int>.\\<forall>p\\<in>\\<int>.\\<forall>q\\<in>\\<int>. f`(r)\\<rs>f`(p)\\<rs>f`(q)\\<ra>K \\<lsq> f`(r\\<rs>p\\<rs>q)\"\n    by auto\n  from I III V have \n    \"L\\<ra>M \\<in> \\<int>\"  \"(\\<rm>L) \\<rs> L \\<ra> K \\<in> \\<int>\" \n    using Int_ZF_1_1_L4 Int_ZF_1_1_L5 by auto\n  moreover\n    { fix m n\n      assume A3: \"m\\<in>\\<int>\\<^sub>+\" \"n\\<in>\\<int>\\<^sub>+\" \n      have  \"f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n)) \\<lsq>  L\\<ra>M \\<and> \n\t(\\<rm>L)\\<rs>L\\<ra>K \\<lsq> f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n))\"\n      proof -\n\tlet ?r = \"f\\<inverse>(m\\<ra>n)\"\n\tlet ?p = \"f\\<inverse>(m)\"\n\tlet ?q = \"f\\<inverse>(n)\"\n\tfrom A1 A3 have T1:\n\t  \"?p \\<in> \\<int>\\<^sub>+\"  \"?q \\<in> \\<int>\\<^sub>+\"  \"?r \\<in> \\<int>\\<^sub>+\"\n\t  using Int_ZF_2_4_L2 pos_int_closed_add_unfolded by auto\n\twith A3 have T2:\n\t  \"m \\<in> \\<int>\"  \"n \\<in> \\<int>\"  \"?p \\<in> \\<int>\"  \"?q \\<in> \\<int>\"  \"?r \\<in> \\<int>\" \n\t  using PositiveSet_def by auto\n\tfrom A2 A3 have T3:\n\t  \"?r\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\" \"?p\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"  \"?q\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n\t  using pos_int_closed_add_unfolded by auto\n\tfrom A1 A3 have VII:\n\t  \"m\\<ra>n \\<lsq> f`(?r)\"\n\t  \"m \\<lsq> f`(?p)\"  \n\t  \"n \\<lsq> f`(?q)\"  \n\t  using Int_ZF_2_4_L2 pos_int_closed_add_unfolded by auto\n\tfrom A1 A3 T3 have VIII:\n\t  \"f`(?r\\<rs>\\<one>) \\<lsq> m\\<ra>n\"\n\t  \"f`(?p\\<rs>\\<one>) \\<lsq> m\"\n\t  \"f`(?q\\<rs>\\<one>) \\<lsq> n\"\n\t  using pos_int_closed_add_unfolded Int_ZF_2_4_L4 by auto\n\thave \"f`(?r\\<rs>?p\\<rs>?q) \\<lsq> L\\<ra>M\"\n\tproof -\n\t  from IV T2 have \"f`(?r\\<rs>?p\\<rs>?q) \\<lsq> f`(?r)\\<rs>f`(?p)\\<rs>f`(?q)\\<ra>M\"\n\t    by simp\n\t  moreover \n\t  from I II T2 VIII have\n\t    \"f`(?r) \\<lsq> f`(?r\\<rs>\\<one>) \\<ra> L\"\n\t    \"f`(?r\\<rs>\\<one>) \\<ra> L \\<lsq> m\\<ra>n\\<ra>L\"\n\t    using int_ord_transl_inv by auto\n\t  then have \"f`(?r) \\<lsq>  m\\<ra>n\\<ra>L\"\n\t    by (rule Int_order_transitive)\n\t  with VII have \"f`(?r) \\<rs> f`(?p) \\<lsq> m\\<ra>n\\<ra>L\\<rs>m\"\n\t    using int_ineq_add_sides by simp\n\t  with I T2 VII have \"f`(?r) \\<rs> f`(?p) \\<rs> f`(?q) \\<lsq> n\\<ra>L\\<rs>n\"\n\t    using Int_ZF_1_2_L9 int_ineq_add_sides by simp\n\t  with I III T2 have \"f`(?r) \\<rs> f`(?p) \\<rs> f`(?q) \\<ra> M \\<lsq> L\\<ra>M\"\n\t    using Int_ZF_1_2_L3 int_ord_transl_inv by simp\n\t  ultimately show \"f`(?r\\<rs>?p\\<rs>?q) \\<lsq> L\\<ra>M\"\n\t    by (rule Int_order_transitive)\n\tqed\n\tmoreover have \"(\\<rm>L)\\<rs>L \\<ra>K \\<lsq> f`(?r\\<rs>?p\\<rs>?q)\"\n\tproof -\n\t  from I II T2 VIII have\n\t    \"f`(?p) \\<lsq> f`(?p\\<rs>\\<one>) \\<ra> L\"\n\t    \"f`(?p\\<rs>\\<one>) \\<ra> L \\<lsq> m \\<ra>L\"\n\t    using int_ord_transl_inv by auto\n\t  then have \"f`(?p) \\<lsq>  m \\<ra>L\"\n\t    by (rule Int_order_transitive)\n\t  with VII have \"m\\<ra>n \\<rs>(m\\<ra>L) \\<lsq> f`(?r) \\<rs> f`(?p)\"\n\t    using int_ineq_add_sides by simp\n\t  with I T2 have \"n \\<rs> L \\<lsq>  f`(?r) \\<rs> f`(?p)\"\n\t    using Int_ZF_1_2_L9 by simp\n\t  moreover\n\t  from I II T2 VIII have\n\t    \"f`(?q) \\<lsq> f`(?q\\<rs>\\<one>) \\<ra> L\"\n\t    \"f`(?q\\<rs>\\<one>) \\<ra> L \\<lsq> n \\<ra>L\"\n\t    using int_ord_transl_inv by auto\n\t  then have \"f`(?q) \\<lsq>  n \\<ra>L\"\n\t    by (rule Int_order_transitive)\n\t  ultimately have \n\t    \"n \\<rs> L \\<rs> (n\\<ra>L) \\<lsq>  f`(?r) \\<rs> f`(?p) \\<rs> f`(?q)\"\n\t    using int_ineq_add_sides by simp\n\t  with I V T2 have \n\t    \"(\\<rm>L)\\<rs>L \\<ra>K \\<lsq>  f`(?r) \\<rs> f`(?p) \\<rs> f`(?q) \\<ra> K\"\n\t    using Int_ZF_1_2_L3 int_ord_transl_inv by simp\n\t  moreover from VI T2 have\n\t    \"f`(?r) \\<rs> f`(?p) \\<rs> f`(?q) \\<ra> K \\<lsq> f`(?r\\<rs>?p\\<rs>?q)\"\n\t    by simp\n\t  ultimately show \"(\\<rm>L)\\<rs>L \\<ra>K \\<lsq> f`(?r\\<rs>?p\\<rs>?q)\"\n\t    by (rule Int_order_transitive)\n\tqed\n\tultimately show\n\t  \"f`(?r\\<rs>?p\\<rs>?q) \\<lsq>  L\\<ra>M \\<and> \n\t  (\\<rm>L)\\<rs>L\\<ra>K \\<lsq> f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n))\" \n\t  by simp \n      qed \n    }\n  ultimately show \n    \"\\<exists>U\\<in>\\<int>. \\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n)) \\<lsq> U\"\n    \"\\<exists>N\\<in>\\<int>. \\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. N \\<lsq> f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n))\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 923
    },
    "827": {
        "type": "lemma",
        "text": "text\\<open>The expression $f^{-1}(m+n)-f^{-1}(m) - f^{-1}(n)$ is uniformly bounded\n  for all pairs $\\langle m,n \\rangle \\in$ \\<open>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+\\<close>. \n  Recall that in the \\<open>int1\\<close>\n  context \\<open>\\<epsilon>(f,x)\\<close> is defined so that \n  $\\varepsilon(f,\\langle m,n \\rangle ) = f^{-1}(m+n)-f^{-1}(m) - f^{-1}(n)$.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and\n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_4_L7",
            "int_one_two_are_pos",
            "AlmostHoms_def",
            "Int_ZF_2_3_L5",
            "Int_ZF_2_3_L5A",
            "pos_int_closed_add_unfolded",
            "Int_ZF_2_4_L2",
            "PositiveSet_def",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L8:  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and\n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  shows \"\\<exists>M. \\<forall>x\\<in>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+. abs(\\<epsilon>(f,x)) \\<lsq> M\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"\\<exists>U\\<in>\\<int>. \\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n)) \\<lsq> U\"\n    \"\\<exists>N\\<in>\\<int>. \\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. N \\<lsq> f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n))\"\n    using  Int_ZF_2_4_L7 by auto\n  then obtain U N where I:\n    \"\\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n)) \\<lsq> U\" \n    \"\\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. N \\<lsq> f`(f\\<inverse>(m\\<ra>n)\\<rs>f\\<inverse>(m)\\<rs>f\\<inverse>(n))\"\n    by auto\n  have \"\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+ \\<noteq> 0\" using int_one_two_are_pos by auto\n  moreover from A1 have \"f: \\<int>\\<rightarrow>\\<int>\"\n    using AlmostHoms_def by simp\n  moreover from A1 have\n    \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\"\n    using Int_ZF_2_3_L5 by simp\n  moreover from A1 have\n    \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(\\<rm>y) \\<lsq> a\"\n    using Int_ZF_2_3_L5A by simp\n  moreover have \n    \"\\<forall>x\\<in>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+. \\<epsilon>(f,x) \\<in> \\<int> \\<and> f`(\\<epsilon>(f,x)) \\<lsq> U \\<and> N \\<lsq> f`(\\<epsilon>(f,x))\"\n  proof -\n    { fix x assume A3: \"x \\<in> \\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+\"\n      let ?m = \"fst(x)\"\n      let ?n = \"snd(x)\"\n      from A3 have T: \"?m \\<in> \\<int>\\<^sub>+\"  \"?n \\<in> \\<int>\\<^sub>+\"  \"?m\\<ra>?n \\<in> \\<int>\\<^sub>+\"\n\tusing pos_int_closed_add_unfolded by auto\n      with A1 have \n\t\"f\\<inverse>(?m\\<ra>?n) \\<in> \\<int>\"  \"f\\<inverse>(?m) \\<in> \\<int>\"  \"f\\<inverse>(?n) \\<in> \\<int>\"\n\tusing Int_ZF_2_4_L2 PositiveSet_def by auto\n      with I T have \n\t\"\\<epsilon>(f,x) \\<in> \\<int> \\<and> f`(\\<epsilon>(f,x)) \\<lsq> U \\<and> N \\<lsq> f`(\\<epsilon>(f,x))\"\n\tusing Int_ZF_1_1_L5 by auto \n    } thus ?thesis by simp\n    qed\n  ultimately show \"\\<exists>M.\\<forall>x\\<in>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+. abs(\\<epsilon>(f,x)) \\<lsq> M\"\n    by (rule Int_ZF_1_6_L4)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 924
    },
    "828": {
        "type": "lemma",
        "text": "text\\<open>The (candidate for) inverse of a positive slope is a (well defined) \n  function on \\<open>\\<int>\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"g = {\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  ",
        "using": [
            "Int_ZF_2_4_L2",
            "PositiveSet_def",
            "ZF_fun_from_total"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L9: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"g = {\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  shows \n  \"g : \\<int>\\<^sub>+\\<rightarrow>\\<int>\\<^sub>+\"\n  \"g : \\<int>\\<^sub>+\\<rightarrow>\\<int>\"\n",
        "proof": "proof -\n  from A1 have \n    \"\\<forall>p\\<in>\\<int>\\<^sub>+. f\\<inverse>(p) \\<in> \\<int>\\<^sub>+\" \n    \"\\<forall>p\\<in>\\<int>\\<^sub>+. f\\<inverse>(p) \\<in> \\<int>\" \n    using Int_ZF_2_4_L2 PositiveSet_def by auto\n  with A2 show \n    \"g : \\<int>\\<^sub>+\\<rightarrow>\\<int>\\<^sub>+\"  and  \"g : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" \n    using ZF_fun_from_total by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 925
    },
    "829": {
        "type": "lemma",
        "text": "text\\<open>What are the values of the (candidate for) the inverse of a positive slope?\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"g = {\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\" and A3: \"p\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_4_L9",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L10: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"g = {\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\" and A3: \"p\\<in>\\<int>\\<^sub>+\"\n  shows \"g`(p) = f\\<inverse>(p)\"\n",
        "proof": "proof -\n  from A1 A2 have  \"g : \\<int>\\<^sub>+\\<rightarrow>\\<int>\\<^sub>+\" using Int_ZF_2_4_L9 by simp\n  with A2 A3 show \"g`(p) = f\\<inverse>(p)\" using ZF_fun_from_tot_val by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 926
    },
    "830": {
        "type": "lemma",
        "text": "text\\<open>The (candidate for) the inverse of a positive slope is a slope.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and \n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\" and\n  A3: \"g = {\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  ",
        "using": [
            "Int_ZF_2_4_L8",
            "Int_ZF_2_4_L9",
            "pos_int_closed_add_unfolded",
            "Int_ZF_2_4_L10"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L11: assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and \n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\" and\n  A3: \"g = {\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  shows \"OddExtension(\\<int>,IntegerAddition,IntegerOrder,g) \\<in> \\<S>\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<exists>L. \\<forall>x\\<in>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+. abs(\\<epsilon>(f,x)) \\<lsq> L\"\n    using Int_ZF_2_4_L8 by simp\n  then obtain L where I: \"\\<forall>x\\<in>\\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+. abs(\\<epsilon>(f,x)) \\<lsq> L\"\n    by auto\n  from A1 A3 have \"g : \\<int>\\<^sub>+\\<rightarrow>\\<int>\" using Int_ZF_2_4_L9 \n    by simp\n  moreover have \"\\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. abs(\\<delta>(g,m,n)) \\<lsq> L\"\n  proof-\n    { fix m n\n      assume A4: \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\"\n      then have \"\\<langle>m,n\\<rangle> \\<in> \\<int>\\<^sub>+\\<times>\\<int>\\<^sub>+\" by simp\n      with I have \"abs(\\<epsilon>(f,\\<langle>m,n\\<rangle>)) \\<lsq> L\" by simp\n      moreover have \"\\<epsilon>(f,\\<langle>m,n\\<rangle>) = f\\<inverse>(m\\<ra>n) \\<rs> f\\<inverse>(m) \\<rs> f\\<inverse>(n)\"\n\tby simp\n      moreover from A1 A3 A4 have\n\t\"f\\<inverse>(m\\<ra>n) = g`(m\\<ra>n)\"  \"f\\<inverse>(m) = g`(m)\"  \"f\\<inverse>(n) = g`(n)\"\n\tusing pos_int_closed_add_unfolded Int_ZF_2_4_L10 by auto\n      ultimately have \"abs(\\<delta>(g,m,n)) \\<lsq> L\" by simp\n    } thus \"\\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. abs(\\<delta>(g,m,n)) \\<lsq> L\" by simp\n  qed\n  ultimately show ?thesis by (rule Int_ZF_2_1_L24)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 927
    },
    "831": {
        "type": "lemma",
        "text": "text\\<open>Every positive slope that is at least $2$ on positive integers\n  almost has an inverse.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and \n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_2_1_L28",
            "Int_ZF_2_4_L11",
            "Int_ZF_2_1_L11",
            "Int_ZF_2_4_L2",
            "PositiveSet_def",
            "Int_ZF_2_4_L4",
            "int_ord_transl_inv",
            "Int_ZF_2_4_L9",
            "Int_ZF_1_5_L11",
            "Int_ZF_2_4_L10",
            "Int_ZF_2_1_L10",
            "Int_ZF_2_1_L32"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L12: assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and \n  A2: \"\\<forall>m\\<in>\\<int>\\<^sub>+. f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  shows \"\\<exists>h\\<in>\\<S>. f\\<circ>h \\<sim> id(\\<int>)\"\n",
        "proof": "proof -\n  let ?g = \"{\\<langle>p,f\\<inverse>(p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  let ?h = \"OddExtension(\\<int>,IntegerAddition,IntegerOrder,?g)\"\n  from A1 have \n    \"\\<exists>M\\<in>\\<int>. \\<forall>n\\<in>\\<int>. f`(n) \\<lsq> f`(n\\<rs>\\<one>) \\<ra> M\"\n    using Int_ZF_2_1_L28 by simp\n  then obtain M where \n    I: \"M\\<in>\\<int>\" and II: \"\\<forall>n\\<in>\\<int>. f`(n) \\<lsq> f`(n\\<rs>\\<one>) \\<ra> M\"\n    by auto\n  from A1 A2 have T: \"?h \\<in> \\<S>\"\n    using Int_ZF_2_4_L11 by simp\n  moreover have  \"f\\<circ>?h \\<sim> id(\\<int>)\"\n  proof -\n    from A1 T have \"f\\<circ>?h \\<in> \\<S>\" using Int_ZF_2_1_L11 \n      by simp\n    moreover note I\n    moreover\n    { fix m assume A3: \"m\\<in>\\<int>\\<^sub>+\"\n      with A1 have \"f\\<inverse>(m) \\<in> \\<int>\"\n\tusing Int_ZF_2_4_L2 PositiveSet_def by simp \n      with II have \"f`(f\\<inverse>(m)) \\<lsq> f`(f\\<inverse>(m)\\<rs>\\<one>) \\<ra> M\"\n\tby simp\n      moreover from A1 A2 I A3 have \"f`(f\\<inverse>(m)\\<rs>\\<one>) \\<ra> M \\<lsq> m\\<ra>M\"\n\tusing Int_ZF_2_4_L4 int_ord_transl_inv by simp\n      ultimately have \"f`(f\\<inverse>(m)) \\<lsq> m\\<ra>M\"\n\tby (rule Int_order_transitive)\n      moreover from A1 A3 have \"m \\<lsq> f`(f\\<inverse>(m))\"\n\tusing Int_ZF_2_4_L2 by simp\n      moreover from A1 A2 T A3 have \"f`(f\\<inverse>(m)) = (f\\<circ>?h)`(m)\"\n\tusing Int_ZF_2_4_L9 Int_ZF_1_5_L11\n\t  Int_ZF_2_4_L10 PositiveSet_def Int_ZF_2_1_L10\n\tby simp\n      ultimately have \"m \\<lsq> (f\\<circ>?h)`(m) \\<and> (f\\<circ>?h)`(m) \\<lsq> m\\<ra>M\"\n\tby simp }\n    ultimately show \"f\\<circ>?h \\<sim> id(\\<int>)\" using Int_ZF_2_1_L32\n      by simp\n  qed \n  ultimately show \"\\<exists>h\\<in>\\<S>. f\\<circ>h \\<sim> id(\\<int>)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 928
    },
    "832": {
        "type": "theorem",
        "text": "text\\<open>\\<open>Int_ZF_2_4_L12\\<close> is almost what we need, except that it has an assumption\n  that the values of the slope that we get the inverse for are not smaller than $2$ on\n  positive integers. The Arthan's proof of Theorem 11 has a mistake where he says \"note that\n  for all but finitely many $m,n\\in N$ $p=g(m)$ and $q=g(n)$ are both positive\". Of course\n  there may be infinitely many pairs $\\langle m,n \\rangle$ such that $p,q$ are not both \n  positive. This is however easy to workaround: we just modify the slope by adding a \n  constant so that the slope is large enough on positive integers and then look \n  for the inverse.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "AlmostHoms_def",
            "int_zero_one_are_int",
            "int_two_three_are_int",
            "Int_ZF_2_3_L5",
            "Int_ZF_2_1_L33",
            "PositiveSet_def",
            "Int_ZF_1_5_L3",
            "int_one_two_are_pos",
            "Int_ZF_2_4_L5",
            "Int_ZF_1_1_L4",
            "int_ord_transl_inv",
            "Int_ZF_1_2_L3"
        ],
        "statement": "theorem (in int1) pos_slope_has_inv: assumes A1: \"f \\<in> \\<S>\\<^sub>+\"\n  shows \"\\<exists>g\\<in>\\<S>. f\\<sim>g \\<and> (\\<exists>h\\<in>\\<S>. g\\<circ>h \\<sim> id(\\<int>))\"\n",
        "proof": "proof -\n  from A1 have \"f: \\<int>\\<rightarrow>\\<int>\"  \"\\<one>\\<in>\\<int>\"  \"\\<two> \\<in> \\<int>\"\n    using AlmostHoms_def int_zero_one_are_int int_two_three_are_int\n    by auto\n  moreover from A1 have\n     \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\"\n    using Int_ZF_2_3_L5 by simp\n  ultimately have \n    \"\\<exists>c\\<in>\\<int>. \\<two> \\<lsq> Minimum(IntegerOrder,{n\\<in>\\<int>\\<^sub>+. \\<one> \\<lsq> f`(n)\\<ra>c})\"\n    by (rule Int_ZF_1_6_L7)\n  then obtain c where I: \"c\\<in>\\<int>\" and\n    II: \"\\<two> \\<lsq> Minimum(IntegerOrder,{n\\<in>\\<int>\\<^sub>+. \\<one> \\<lsq> f`(n)\\<ra>c})\"\n    by auto\n  let ?g = \"{\\<langle>m,f`(m)\\<ra>c\\<rangle>. m\\<in>\\<int>}\"\n  from A1 I have III: \"?g\\<in>\\<S>\" and IV: \"f\\<sim>?g\" using Int_ZF_2_1_L33 \n    by auto\n  from IV have \"\\<langle>f,?g\\<rangle> \\<in> AlEqRel\" by simp\n  with A1 have T: \"?g \\<in> \\<S>\\<^sub>+\" by (rule Int_ZF_2_3_L9)\n  moreover have \"\\<forall>m\\<in>\\<int>\\<^sub>+. ?g\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  proof\n    fix m assume A2: \"m\\<in>\\<int>\\<^sub>+\"\n    from A1 I II have V: \"\\<two> \\<lsq> ?g\\<inverse>(\\<one>)\"\n      using Int_ZF_2_1_L33 PositiveSet_def by simp\n    moreover from A2 T have \"?g\\<inverse>(\\<one>) \\<lsq> ?g\\<inverse>(m)\"\n      using Int_ZF_1_5_L3 int_one_two_are_pos Int_ZF_2_4_L5\n      by simp\n    ultimately have \"\\<two> \\<lsq> ?g\\<inverse>(m)\"\n      by (rule Int_order_transitive)\n    then have \"\\<two>\\<rs>\\<one> \\<lsq> ?g\\<inverse>(m)\\<rs>\\<one>\"\n      using int_zero_one_are_int Int_ZF_1_1_L4 int_ord_transl_inv\n      by simp\n    then show  \"?g\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n      using int_zero_one_are_int Int_ZF_1_2_L3 Int_ZF_1_5_L3\n      by simp\n  qed\n  ultimately have \"\\<exists>h\\<in>\\<S>. ?g\\<circ>h \\<sim> id(\\<int>)\"\n    by (rule Int_ZF_2_4_L12)\n  with III IV show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 929
    },
    "833": {
        "type": "lemma",
        "text": "text\\<open>If m is an integer, then $m^S$ is a slope whose value\n  is $m\\cdot n$ for every integer.\\<close>\n",
        "assumes": "assumes A1: \"m \\<in> \\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_2_L3",
            "Int_ZF_1_1_L4",
            "Int_ZF_2_L18",
            "int_zero_one_are_int",
            "int_ord_is_refl",
            "refl_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L1: assumes A1: \"m \\<in> \\<int>\"\n  shows \n  \"\\<forall>n \\<in> \\<int>. (m\\<^sup>S)`(n) = m\\<cdot>n\"\n  \"m\\<^sup>S \\<in> \\<S>\"\n",
        "proof": "proof -\n  from A1 have I: \"m\\<^sup>S:\\<int>\\<rightarrow>\\<int>\"\n    using Int_ZF_1_1_L5 ZF_fun_from_total by simp\n  then show II: \"\\<forall>n \\<in> \\<int>. (m\\<^sup>S)`(n) = m\\<cdot>n\" using ZF_fun_from_tot_val\n    by simp\n  { fix n k\n    assume A2: \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n    with A1 have T: \"m\\<cdot>n \\<in> \\<int>\"  \"m\\<cdot>k \\<in> \\<int>\"\n      using Int_ZF_1_1_L5 by auto\n    from A1 A2 II T  have \"\\<delta>(m\\<^sup>S,n,k) = m\\<cdot>k \\<rs> m\\<cdot>k\"\n      using Int_ZF_1_1_L5 Int_ZF_1_1_L1 Int_ZF_1_2_L3\n      by simp\n    also from T have \"\\<dots> = \\<zero>\" using Int_ZF_1_1_L4\n      by simp\n    finally have \"\\<delta>(m\\<^sup>S,n,k) = \\<zero>\" by simp\n    then have \"abs(\\<delta>(m\\<^sup>S,n,k)) \\<lsq> \\<zero>\"\n      using Int_ZF_2_L18 int_zero_one_are_int int_ord_is_refl refl_def\n      by simp\n  } then have \"\\<forall>n\\<in>\\<int>.\\<forall>k\\<in>\\<int>. abs(\\<delta>(m\\<^sup>S,n,k)) \\<lsq> \\<zero>\"\n    by simp\n  with I show  \"m\\<^sup>S \\<in> \\<S>\" by (rule Int_ZF_2_1_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 930
    },
    "834": {
        "type": "lemma",
        "text": "text\\<open>For any slope $f$ there is an integer $m$ such that there is some slope $g$ \n  that is almost equal to $m^S$ and dominates $f$ in the sense that $f\\leq g$ \n  on positive integers (which implies that either $g$ is almost equal to $f$ or\n  $g-f$ is a positive slope. This will be used in \\<open>Real_ZF_1.thy\\<close> to show\n  that for any real number there is an integer that (whose real embedding) \n  is greater or equal.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"\n  ",
        "using": [
            "Arthan_Lem_8",
            "Int_ZF_2_5_L1",
            "Int_ZF_2_1_L33",
            "Int_ZF_2_1_L2B",
            "PositiveSet_def",
            "Int_ZF_2_L19C",
            "Int_ZF_1_5_L4A",
            "Int_ZF_2_3_L4C"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L2: assumes A1: \"f \\<in> \\<S>\"\n  shows \"\\<exists>m\\<in>\\<int>. \\<exists>g\\<in>\\<S>. (m\\<^sup>S\\<sim>g \\<and> (f\\<sim>g \\<or> g\\<fp>(\\<fm>f) \\<in> \\<S>\\<^sub>+))\"\n",
        "proof": "proof -\n  from A1 have \n    \"\\<exists>m k. m\\<in>\\<int> \\<and> k\\<in>\\<int> \\<and> (\\<forall>p\\<in>\\<int>. abs(f`(p)) \\<lsq> m\\<cdot>abs(p)\\<ra>k)\"\n    using Arthan_Lem_8 by simp\n  then obtain m k where I: \"m\\<in>\\<int>\" and II: \"k\\<in>\\<int>\" and \n    III: \"\\<forall>p\\<in>\\<int>. abs(f`(p)) \\<lsq> m\\<cdot>abs(p)\\<ra>k\"\n    by auto\n  let ?g = \"{\\<langle>n,m\\<^sup>S`(n) \\<ra>k\\<rangle>. n\\<in>\\<int>}\"\n  from I have IV: \"m\\<^sup>S \\<in> \\<S>\" using Int_ZF_2_5_L1 by simp\n  with II have V: \"?g\\<in>\\<S>\" and VI: \"m\\<^sup>S\\<sim>?g\" using Int_ZF_2_1_L33 \n    by auto\n  { fix n assume A2: \"n\\<in>\\<int>\\<^sub>+\"\n    with A1 have \"f`(n) \\<in> \\<int>\"\n      using Int_ZF_2_1_L2B PositiveSet_def by simp\n    then have \"f`(n) \\<lsq> abs(f`(n))\" using Int_ZF_2_L19C \n      by simp\n    moreover  \n    from III A2 have \"abs(f`(n)) \\<lsq> m\\<cdot>abs(n) \\<ra> k\"\n      using PositiveSet_def by simp\n    with A2 have \"abs(f`(n)) \\<lsq> m\\<cdot>n\\<ra>k\"\n      using Int_ZF_1_5_L4A by simp\n    ultimately have \"f`(n) \\<lsq> m\\<cdot>n\\<ra>k\"\n      by (rule Int_order_transitive)\n    moreover\n    from II IV A2 have \"?g`(n) = (m\\<^sup>S)`(n)\\<ra>k\"\n      using Int_ZF_2_1_L33 PositiveSet_def by simp\n    with I A2 have \"?g`(n) = m\\<cdot>n\\<ra>k\"\n      using Int_ZF_2_5_L1 PositiveSet_def by simp\n    ultimately have \"f`(n) \\<lsq> ?g`(n)\"\n      by simp\n  } then have \"\\<forall>n\\<in>\\<int>\\<^sub>+. f`(n) \\<lsq> ?g`(n)\"\n    by simp\n  with A1 V have \"f\\<sim>?g \\<or> ?g \\<fp> (\\<fm>f) \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_3_L4C by simp\n  with I V VI show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 931
    },
    "835": {
        "type": "lemma",
        "text": "text\\<open>The negative of an integer embeds in slopes as a negative of the \n  orgiginal embedding.\\<close>\n",
        "assumes": "assumes A1:  \"m \\<in> \\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_2_5_L1",
            "AlmostHoms_def",
            "Int_ZF_2_1_L12",
            "Int_ZF_2_1_L12A",
            "Int_ZF_1_1_L5",
            "fun_extension_iff"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L3: assumes A1:  \"m \\<in> \\<int>\"\n  shows \"(\\<rm>m)\\<^sup>S = \\<fm>(m\\<^sup>S)\"\n",
        "proof": "proof -\n  from A1 have \"(\\<rm>m)\\<^sup>S: \\<int>\\<rightarrow>\\<int>\" and \"(\\<fm>(m\\<^sup>S)): \\<int>\\<rightarrow>\\<int>\"\n    using Int_ZF_1_1_L4 Int_ZF_2_5_L1 AlmostHoms_def Int_ZF_2_1_L12\n    by auto\n  moreover have \"\\<forall>n\\<in>\\<int>. ((\\<rm>m)\\<^sup>S)`(n) = (\\<fm>(m\\<^sup>S))`(n)\"\n  proof\n    fix n assume A2: \"n\\<in>\\<int>\"\n    with A1 have \n      \"((\\<rm>m)\\<^sup>S)`(n) = (\\<rm>m)\\<cdot>n\"\n      \"(\\<fm>(m\\<^sup>S))`(n) = \\<rm>(m\\<cdot>n)\"\n      using Int_ZF_1_1_L4 Int_ZF_2_5_L1 Int_ZF_2_1_L12A\n      by auto\n    with A1 A2 show \"((\\<rm>m)\\<^sup>S)`(n) = (\\<fm>(m\\<^sup>S))`(n)\"\n      using Int_ZF_1_1_L5 by simp\n  qed\n  ultimately show \"(\\<rm>m)\\<^sup>S = \\<fm>(m\\<^sup>S)\" using fun_extension_iff\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 932
    },
    "836": {
        "type": "lemma",
        "text": "text\\<open>The sum of embeddings is the embeding of the sum.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_2_5_L1",
            "Int_ZF_2_1_L12C",
            "AlmostHoms_def",
            "Int_ZF_2_1_L12B",
            "Int_ZF_1_1_L1",
            "fun_extension_iff"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L3A: assumes A1: \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  shows \"(m\\<^sup>S) \\<fp> (k\\<^sup>S) = ((m\\<ra>k)\\<^sup>S)\"\n",
        "proof": "proof -\n  from A1 have T1: \"m\\<ra>k \\<in> \\<int>\" using Int_ZF_1_1_L5 \n    by simp\n  with A1 have T2:\n    \"(m\\<^sup>S) \\<in> \\<S>\"  \"(k\\<^sup>S) \\<in> \\<S>\"\n    \"(m\\<ra>k)\\<^sup>S  \\<in> \\<S>\"\n    \"(m\\<^sup>S) \\<fp> (k\\<^sup>S) \\<in> \\<S>\"\n    using Int_ZF_2_5_L1 Int_ZF_2_1_L12C by auto\n  then have \n    \"(m\\<^sup>S) \\<fp> (k\\<^sup>S) : \\<int>\\<rightarrow>\\<int>\"\n    \"(m\\<ra>k)\\<^sup>S : \\<int>\\<rightarrow>\\<int>\" \n    using AlmostHoms_def by auto\n  moreover have \"\\<forall>n\\<in>\\<int>. ((m\\<^sup>S) \\<fp> (k\\<^sup>S))`(n) = ((m\\<ra>k)\\<^sup>S)`(n)\"\n  proof\n    fix n assume A2: \"n\\<in>\\<int>\"\n    with A1 T1 T2 have  \"((m\\<^sup>S) \\<fp> (k\\<^sup>S))`(n) = (m\\<ra>k)\\<cdot>n\"\n      using Int_ZF_2_1_L12B Int_ZF_2_5_L1 Int_ZF_1_1_L1\n      by simp\n    also from T1 A2 have \"\\<dots> = ((m\\<ra>k)\\<^sup>S)`(n)\"\n      using Int_ZF_2_5_L1 by simp\n    finally show \"((m\\<^sup>S) \\<fp> (k\\<^sup>S))`(n) = ((m\\<ra>k)\\<^sup>S)`(n)\"\n      by simp\n  qed\n  ultimately show \"(m\\<^sup>S) \\<fp> (k\\<^sup>S) = ((m\\<ra>k)\\<^sup>S)\"\n    using fun_extension_iff by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 933
    },
    "837": {
        "type": "lemma",
        "text": "text\\<open>The composition of embeddings is the embeding of the product.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_2_5_L1",
            "Int_ZF_2_1_L11",
            "AlmostHoms_def",
            "Int_ZF_2_1_L10",
            "Int_ZF_1_1_L7",
            "fun_extension_iff"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L3B: assumes A1: \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  shows \"(m\\<^sup>S) \\<circ> (k\\<^sup>S) = ((m\\<cdot>k)\\<^sup>S)\"\n",
        "proof": "proof -\n  from A1 have T1: \"m\\<cdot>k \\<in> \\<int>\" using Int_ZF_1_1_L5 \n    by simp\n  with A1 have T2:\n    \"(m\\<^sup>S) \\<in> \\<S>\"  \"(k\\<^sup>S) \\<in> \\<S>\"\n    \"(m\\<cdot>k)\\<^sup>S  \\<in> \\<S>\"\n    \"(m\\<^sup>S) \\<circ> (k\\<^sup>S) \\<in> \\<S>\"\n    using Int_ZF_2_5_L1 Int_ZF_2_1_L11 by auto\n  then have \n    \"(m\\<^sup>S) \\<circ> (k\\<^sup>S) : \\<int>\\<rightarrow>\\<int>\"\n    \"(m\\<cdot>k)\\<^sup>S : \\<int>\\<rightarrow>\\<int>\" \n    using AlmostHoms_def by auto\n  moreover have \"\\<forall>n\\<in>\\<int>. ((m\\<^sup>S) \\<circ> (k\\<^sup>S))`(n) = ((m\\<cdot>k)\\<^sup>S)`(n)\"\n  proof\n    fix n assume A2: \"n\\<in>\\<int>\"\n    with A1 T2 have\n      \"((m\\<^sup>S) \\<circ> (k\\<^sup>S))`(n) = (m\\<^sup>S)`(k\\<cdot>n)\"\n       using Int_ZF_2_1_L10 Int_ZF_2_5_L1 by simp\n    moreover\n    from A1 A2 have \"k\\<cdot>n \\<in> \\<int>\" using Int_ZF_1_1_L5 \n      by simp\n    with A1 A2 have \"(m\\<^sup>S)`(k\\<cdot>n) = m\\<cdot>k\\<cdot>n\"\n      using Int_ZF_2_5_L1 Int_ZF_1_1_L7 by simp\n    ultimately have \"((m\\<^sup>S) \\<circ> (k\\<^sup>S))`(n) = m\\<cdot>k\\<cdot>n\"\n      by simp\n    also from T1 A2 have \"m\\<cdot>k\\<cdot>n = ((m\\<cdot>k)\\<^sup>S)`(n)\"\n      using Int_ZF_2_5_L1 by simp\n    finally show \"((m\\<^sup>S) \\<circ> (k\\<^sup>S))`(n) = ((m\\<cdot>k)\\<^sup>S)`(n)\"\n      by simp\n  qed\n  ultimately show \"(m\\<^sup>S) \\<circ> (k\\<^sup>S) = ((m\\<cdot>k)\\<^sup>S)\"\n    using fun_extension_iff by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 934
    },
    "838": {
        "type": "lemma",
        "text": "text\\<open>Embedding integers in slopes preserves order.\\<close>\n",
        "assumes": "assumes A1:  \"m\\<lsq>n\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_2_5_L1",
            "Int_ZF_1_3_L13B",
            "PositiveSet_def",
            "Int_ZF_2_3_L4C"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L4: assumes A1:  \"m\\<lsq>n\"\n  shows \"(m\\<^sup>S) \\<sim> (n\\<^sup>S) \\<or> (n\\<^sup>S)\\<fp>(\\<fm>(m\\<^sup>S)) \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 have \"m\\<^sup>S \\<in> \\<S>\" and \"n\\<^sup>S \\<in> \\<S>\"\n    using Int_ZF_2_L1A Int_ZF_2_5_L1 by auto\n  moreover from A1 have \"\\<forall>k\\<in>\\<int>\\<^sub>+. (m\\<^sup>S)`(k) \\<lsq> (n\\<^sup>S)`(k)\"\n    using Int_ZF_1_3_L13B Int_ZF_2_L1A PositiveSet_def Int_ZF_2_5_L1\n    by simp\n  ultimately show ?thesis using Int_ZF_2_3_L4C\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 935
    },
    "839": {
        "type": "lemma",
        "text": "text\\<open>Embeddings of two integers are almost equal only if \n  the integers are equal.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\" and A2: \"(m\\<^sup>S) \\<sim> (k\\<^sup>S)\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_2_5_L3",
            "Int_ZF_1_1_L4",
            "Int_ZF_2_5_L3A",
            "Int_ZF_2_5_L1",
            "Int_ZF_2_1_L9D",
            "Int_ZF_2_5_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L6: \n  assumes A1: \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\" and A2: \"(m\\<^sup>S) \\<sim> (k\\<^sup>S)\"\n  shows \"m=k\"\n",
        "proof": "proof -\n  from A1 have T: \"m\\<rs>k \\<in> \\<int>\" using Int_ZF_1_1_L5 by simp\n  from A1 have \"(\\<fm>(k\\<^sup>S)) =  ((\\<rm>k)\\<^sup>S)\"\n    using Int_ZF_2_5_L3 by simp\n  then have \"m\\<^sup>S \\<fp> (\\<fm>(k\\<^sup>S)) = (m\\<^sup>S) \\<fp> ((\\<rm>k)\\<^sup>S)\"\n    by simp\n  with A1 have \"m\\<^sup>S \\<fp> (\\<fm>(k\\<^sup>S)) = ((m\\<rs>k)\\<^sup>S)\"\n    using Int_ZF_1_1_L4 Int_ZF_2_5_L3A by simp\n  moreover from A1 A2 have \"m\\<^sup>S \\<fp> (\\<fm>(k\\<^sup>S)) \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n    using Int_ZF_2_5_L1 Int_ZF_2_1_L9D by simp\n  ultimately have \"(m\\<rs>k)\\<^sup>S \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n    by simp\n  with T have \"m\\<rs>k = \\<zero>\" using Int_ZF_2_5_L5\n    by simp\n  with A1 show \"m=k\" by (rule Int_ZF_1_L15)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 937
    },
    "840": {
        "type": "lemma",
        "text": "text\\<open>A somewhat technical condition for a embedding of an integer \n  to be \"less  or equal\" (in the sense apriopriate for slopes) than \n  the composition of a slope and another integer (embedding).\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> \\<int>\"  \"M \\<in> \\<int>\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. M\\<cdot>n \\<lsq> f`(N\\<cdot>n)\"\n  ",
        "using": [
            "Int_ZF_2_5_L1",
            "Int_ZF_2_1_L11",
            "PositiveSet_def",
            "Int_ZF_2_1_L10",
            "Int_ZF_2_3_L4C"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L8: \n  assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> \\<int>\"  \"M \\<in> \\<int>\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. M\\<cdot>n \\<lsq> f`(N\\<cdot>n)\"\n  shows \"M\\<^sup>S \\<sim> f\\<circ>(N\\<^sup>S) \\<or>  (f\\<circ>(N\\<^sup>S)) \\<fp> (\\<fm>(M\\<^sup>S)) \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \"M\\<^sup>S \\<in> \\<S>\"  \"f\\<circ>(N\\<^sup>S) \\<in> \\<S>\"\n    using Int_ZF_2_5_L1 Int_ZF_2_1_L11 by auto\n  moreover from A1 A2 A3 have \"\\<forall>n\\<in>\\<int>\\<^sub>+. (M\\<^sup>S)`(n) \\<lsq> (f\\<circ>(N\\<^sup>S))`(n)\"\n    using Int_ZF_2_5_L1 PositiveSet_def Int_ZF_2_1_L10\n    by simp\n  ultimately show ?thesis using Int_ZF_2_3_L4C\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 939
    },
    "841": {
        "type": "definition",
        "text": "text\\<open>Definition of addition of integers as a binary operation \n  on \\<open>int\\<close>.\n  Recall that in standard Isabelle/ZF \\<open>int\\<close> is the set of integers \n  and the sum of integers is denoted by prependig $+$ with a dollar sign.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IntegerAddition \\<equiv> { \\<langle> x,c\\<rangle> \\<in> (int\\<times>int)\\<times>int. fst(x) $+ snd(x) = c}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 941
    },
    "842": {
        "type": "definition",
        "text": "text\\<open>Definition of multiplication of integers as a binary operation \n  on \\<open>int\\<close>. In standard Isabelle/ZF product of integers is denoted by\n  prepending the dollar sign to \\<open>*\\<close>.  \n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IntegerMultiplication \\<equiv> \n    { \\<langle> x,c\\<rangle> \\<in> (int\\<times>int)\\<times>int. fst(x) $* snd(x) = c}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 942
    },
    "843": {
        "type": "definition",
        "text": "text\\<open>Definition of natural order on integers as a relation on \\<open>int\\<close>.\n  In the standard Isabelle/ZF the inequality relation on integers\n  is denoted \\<open>\\<le>\\<close> prepended with the dollar sign.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IntegerOrder \\<equiv> {p \\<in> int\\<times>int. fst(p) $\\<le> snd(p)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 943
    },
    "844": {
        "type": "lemma",
        "text": "text\\<open>IntegerAddition adds integers and IntegerMultiplication multiplies\n  integers. This states that the ZF functions \\<open>IntegerAddition\\<close> and\n  \\<open>IntegerMultiplication\\<close> give the same results as the higher-order\n  equivalents defined in the standard \\<open>Int\\<close> theory.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<int>\"  \"b \\<in> \\<int>\"\n  ",
        "using": [
            "IntegerAddition_def",
            "IntegerMultiplication_def",
            "Int_ZF_1_L1",
            "apply_iff"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L2: assumes A1: \"a \\<in> \\<int>\"  \"b \\<in> \\<int>\"\n  shows \n  \"a\\<ra>b = a $+ b\"  \n  \"a\\<cdot>b = a $* b\"\n",
        "proof": "proof -\n  let ?x = \"\\<langle> a,b\\<rangle>\"\n  let ?c = \"a $+ b\"\n  let ?d = \"a $* b\"\n  from A1 have \n    \"\\<langle> ?x,?c\\<rangle> \\<in> {\\<langle> x,c\\<rangle> \\<in> (\\<int>\\<times>\\<int>)\\<times>\\<int>. fst(x) $+ snd(x) = c}\"\n    \"\\<langle> ?x,?d\\<rangle> \\<in> {\\<langle> x,d\\<rangle> \\<in> (\\<int>\\<times>\\<int>)\\<times>\\<int>. fst(x) $* snd(x) = d}\"\n    by auto\n  then show \"a\\<ra>b = a $+ b\"  \"a\\<cdot>b = a $* b\"\n    using IntegerAddition_def IntegerMultiplication_def \n      Int_ZF_1_L1 apply_iff by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 946
    },
    "845": {
        "type": "lemma",
        "text": "text\\<open>Integer addition and multiplication are associative.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<int>\"  \"y\\<in>\\<int>\"  \"z\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_L2",
            "zadd_assoc",
            "zmult_assoc"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L3: \n  assumes \"x\\<in>\\<int>\"  \"y\\<in>\\<int>\"  \"z\\<in>\\<int>\"\n  shows \"x\\<ra>y\\<ra>z = x\\<ra>(y\\<ra>z)\"  \"x\\<cdot>y\\<cdot>z = x\\<cdot>(y\\<cdot>z)\"\n  ",
        "proof": "using assms Int_ZF_1_L2 zadd_assoc zmult_assoc by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 947
    },
    "846": {
        "type": "lemma",
        "text": "text\\<open>Integer addition and multiplication are commutative.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<int>\"  \"y\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_L2",
            "zadd_commute",
            "zmult_commute"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L4:\n  assumes \"x\\<in>\\<int>\"  \"y\\<in>\\<int>\"\n  shows \"x\\<ra>y = y\\<ra>x\"  \"x\\<cdot>y = y\\<cdot>x\"\n  ",
        "proof": "using assms Int_ZF_1_L2 zadd_commute zmult_commute \n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 948
    },
    "847": {
        "type": "lemma",
        "text": "text\\<open>Zero is neutral for addition and one for multiplication.\\<close>\n",
        "assumes": "assumes A1:\"x\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_L2",
            "zadd_int0",
            "Int_ZF_1_L4",
            "zmult_int1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L5: assumes A1:\"x\\<in>\\<int>\"\n  shows \"($# 0) \\<ra> x = x \\<and> x \\<ra> ($# 0) = x\"\n  \"($# 1)\\<cdot>x = x \\<and> x\\<cdot>($# 1) = x\"\n",
        "proof": "proof -\n  from A1 show \"($# 0) \\<ra> x = x \\<and> x \\<ra> ($# 0) = x\"\n    using  Int_ZF_1_L2 zadd_int0 Int_ZF_1_L4 by simp\n  from A1 have \"($# 1)\\<cdot>x = x\"\n    using Int_ZF_1_L2 zmult_int1 by simp\n  with A1 show \"($# 1)\\<cdot>x = x \\<and> x\\<cdot>($# 1) = x\"\n    using Int_ZF_1_L4 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 949
    },
    "848": {
        "type": "lemma",
        "text": "text\\<open>Zero is neutral for addition and one for multiplication.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L6: shows \"($# 0)\\<in>\\<int> \\<and> \n  (\\<forall>x\\<in>\\<int>. ($# 0)\\<ra>x = x \\<and> x\\<ra>($# 0) = x)\"\n  \"($# 1)\\<in>\\<int> \\<and> \n  (\\<forall>x\\<in>\\<int>. ($# 1)\\<cdot>x = x \\<and> x\\<cdot>($# 1) = x)\"\n  ",
        "proof": "using Int_ZF_1_L5 by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 950
    },
    "849": {
        "type": "theorem",
        "text": "text\\<open>Integers with addition and integers with multiplication\n  form monoids.\\<close>\n",
        "assumes": "",
        "using": [
            "int0.Int_ZF_1_L6",
            "IsAmonoid_def",
            "IsAssociative_def",
            "Int_ZF_1_L1",
            "Int_ZF_1_L3"
        ],
        "statement": "theorem (in int0) Int_ZF_1_T1: shows\n  \"IsAmonoid(\\<int>,IntegerAddition)\"\n  \"IsAmonoid(\\<int>,IntegerMultiplication)\"\n",
        "proof": "proof -\n   have  \n    \"\\<exists>e\\<in>\\<int>. \\<forall>x\\<in>\\<int>. e\\<ra>x = x \\<and> x\\<ra>e = x\"\n     \"\\<exists>e\\<in>\\<int>. \\<forall>x\\<in>\\<int>. e\\<cdot>x = x \\<and> x\\<cdot>e = x\"\n     using int0.Int_ZF_1_L6 by auto\n   then show \"IsAmonoid(\\<int>,IntegerAddition)\"\n     \"IsAmonoid(\\<int>,IntegerMultiplication)\" using \n     IsAmonoid_def IsAssociative_def Int_ZF_1_L1 Int_ZF_1_L3 \n     by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 951
    },
    "850": {
        "type": "lemma",
        "text": "text\\<open>Zero is the neutral element of the integers with addition\n  and one is the neutral element of the integers with multiplication.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_T1",
            "monoid0_def",
            "Int_ZF_1_L6"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L8: shows \"($# 0) = \\<zero>\"  \"($# 1) = \\<one>\"\n",
        "proof": "proof -\n  have \"monoid0(\\<int>,IntegerAddition)\"\n    using Int_ZF_1_T1 monoid0_def by simp\n  moreover have \n    \"($# 0)\\<in>\\<int> \\<and>\n    (\\<forall>x\\<in>\\<int>. IntegerAddition`\\<langle>$# 0,x\\<rangle> = x \\<and> \n    IntegerAddition`\\<langle>x ,$# 0\\<rangle> = x)\"\n    using Int_ZF_1_L6 by auto\n  ultimately have \"($# 0) = TheNeutralElement(\\<int>,IntegerAddition)\"\n    by (rule monoid0.group0_1_L4)\n  then show \"($# 0) = \\<zero>\" by simp\n  have \"monoid0(int,IntegerMultiplication)\"\n    using Int_ZF_1_T1 monoid0_def by simp\n  moreover have \"($# 1) \\<in> int \\<and> \n    (\\<forall>x\\<in>int. IntegerMultiplication`\\<langle>$# 1, x\\<rangle> = x \\<and> \n    IntegerMultiplication`\\<langle>x ,$# 1\\<rangle> = x)\"\n    using Int_ZF_1_L6 by auto\n  ultimately have\n    \"($# 1) = TheNeutralElement(int,IntegerMultiplication)\"\n    by (rule monoid0.group0_1_L4)\n  then show  \"($# 1) = \\<one>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 952
    },
    "851": {
        "type": "lemma",
        "text": "text\\<open>$0$  and $1$, as defined in \\<open>int0\\<close> context, are integers.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L8A: shows \"\\<zero> \\<in> \\<int>\"  \"\\<one> \\<in> \\<int>\"\n",
        "proof": "proof -\n  have \"($# 0) \\<in> \\<int>\"  \"($# 1) \\<in> \\<int>\" by auto\n  then show \"\\<zero> \\<in> \\<int>\"  \"\\<one> \\<in> \\<int>\" using Int_ZF_1_L8 by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 953
    },
    "852": {
        "type": "lemma",
        "text": "text\\<open>Zero is not one.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L8"
        ],
        "statement": "lemma (in int0) int_zero_not_one: shows \"\\<zero> \\<noteq> \\<one>\"\n",
        "proof": "proof -\n  have \"($# 0) \\<noteq> ($# 1)\" by simp\n  then show \"\\<zero> \\<noteq> \\<one>\" using Int_ZF_1_L8 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 954
    },
    "853": {
        "type": "lemma",
        "text": "text\\<open>The set of integers is not empty, of course.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L8A"
        ],
        "statement": "lemma (in int0) int_not_empty: shows \"\\<int> \\<noteq> 0\"\n  ",
        "proof": "using Int_ZF_1_L8A by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 955
    },
    "854": {
        "type": "lemma",
        "text": "text\\<open>The set of integers has more than just zero in it.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L8A",
            "int_zero_not_one"
        ],
        "statement": "lemma (in int0) int_not_trivial: shows \"\\<int> \\<noteq> {\\<zero>}\"\n  ",
        "proof": "using Int_ZF_1_L8A int_zero_not_one by blast\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 956
    },
    "855": {
        "type": "lemma",
        "text": "text\\<open>Each integer has an inverse (in the addition sense).\\<close>\n",
        "assumes": "assumes A1: \"g \\<in> \\<int>\"\n  ",
        "using": [
            "Int_ZF_1_L2",
            "Int_ZF_1_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L9: assumes A1: \"g \\<in> \\<int>\"\n  shows \"\\<exists> b\\<in>\\<int>. g\\<ra>b = \\<zero>\"\n",
        "proof": "proof -\n  from A1 have \"g\\<ra> $-g = \\<zero>\"\n    using Int_ZF_1_L2 Int_ZF_1_L8 by simp\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 957
    },
    "856": {
        "type": "theorem",
        "text": "text\\<open>Integers with addition form an abelian group. This also shows\n  that we can apply all theorems proven in the proof contexts (locales) \n  that require the assumpion that some pair of sets form a group like \n  locale \\<open>group0\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "int0.Int_ZF_1_T1",
            "int0.Int_ZF_1_L9",
            "IsAgroup_def",
            "group0_def",
            "int0.Int_ZF_1_L4",
            "IsCommutative_def"
        ],
        "statement": "theorem Int_ZF_1_T2: shows\n  \"IsAgroup(int,IntegerAddition)\"\n  \"IntegerAddition {is commutative on} int\"\n  \"group0(int,IntegerAddition)\"\n  ",
        "proof": "using int0.Int_ZF_1_T1 int0.Int_ZF_1_L9 IsAgroup_def\n  group0_def int0.Int_ZF_1_L4 IsCommutative_def by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 958
    },
    "857": {
        "type": "lemma",
        "text": "text\\<open>What is the additive group inverse in the group of integers?\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" \n  ",
        "using": [
            "zminus_type",
            "Int_ZF_1_L2",
            "Int_ZF_1_L8",
            "Int_ZF_1_T2",
            "group0.group0_2_L9"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L9A: assumes A1: \"m\\<in>\\<int>\" \n  shows \"$-m = \\<rm>m\"\n",
        "proof": "proof - \n   from A1 have \"m\\<in>int\" \"$-m \\<in> int\" \"IntegerAddition`\\<langle> m,$-m\\<rangle> = \n     TheNeutralElement(int,IntegerAddition)\"\n    using zminus_type Int_ZF_1_L2 Int_ZF_1_L8 by auto\n  then have \"$-m = GroupInv(int,IntegerAddition)`(m)\"\n    using Int_ZF_1_T2 group0.group0_2_L9 by blast\n  then show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 959
    },
    "858": {
        "type": "lemma",
        "text": "text\\<open>Subtracting integers corresponds to adding the negative.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "group0.inverse_in_group",
            "Int_ZF_1_L9A",
            "Int_ZF_1_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L10: assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"m\\<rs>n = m $+ $-n\"\n  ",
        "proof": "using assms Int_ZF_1_T2  group0.inverse_in_group Int_ZF_1_L9A Int_ZF_1_L2\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 960
    },
    "859": {
        "type": "lemma",
        "text": "text\\<open>Negative of zero is zero.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_T2",
            "group0.group_inv_of_one"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L11: shows \"(\\<rm>\\<zero>) = \\<zero>\"\n  ",
        "proof": "using Int_ZF_1_T2  group0.group_inv_of_one by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 961
    },
    "860": {
        "type": "lemma",
        "text": "text\\<open>A trivial calculation lemma that allows to subtract and add one.\\<close>\n",
        "assumes": "assumes \"m\\<in>int\" ",
        "using": [
            "assms",
            "eq_zdiff_iff"
        ],
        "statement": "lemma Int_ZF_1_L12: \n  assumes \"m\\<in>int\" shows \"m $- $#1 $+ $#1 = m\"\n  ",
        "proof": "using assms eq_zdiff_iff by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 962
    },
    "861": {
        "type": "lemma",
        "text": "text\\<open>A trivial calculation lemma that allows to subtract and add one,\n  version with ZF-operation.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\" \n  ",
        "using": [
            "assms",
            "Int_ZF_1_L8A",
            "Int_ZF_1_L2",
            "Int_ZF_1_L8",
            "Int_ZF_1_L12"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L13: assumes \"m\\<in>\\<int>\" \n  shows \"(m $- $#1) \\<ra> \\<one> = m\"\n  ",
        "proof": "using assms Int_ZF_1_L8A Int_ZF_1_L2 Int_ZF_1_L8 Int_ZF_1_L12\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 963
    },
    "862": {
        "type": "lemma",
        "text": "text\\<open>Adding or subtracing one changes integers.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" \n  ",
        "using": [
            "Int_ZF_1_T2",
            "Int_ZF_1_L8A",
            "int_zero_not_one",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L14: assumes A1: \"m\\<in>\\<int>\" \n  shows \n  \"m\\<ra>\\<one> \\<noteq> m\"\n  \"m\\<rs>\\<one> \\<noteq> m\"\n",
        "proof": "proof -\n  { assume \"m\\<ra>\\<one> = m\" \n    with A1 have \n      \"group0(\\<int>,IntegerAddition)\"  \n      \"m\\<in>\\<int>\"  \"\\<one>\\<in>\\<int>\"\n      \"IntegerAddition`\\<langle>m,\\<one>\\<rangle> = m\" \n      using Int_ZF_1_T2 Int_ZF_1_L8A by auto\n    then have \"\\<one> = TheNeutralElement(\\<int>,IntegerAddition)\"\n      by (rule group0.group0_2_L7)\n    then have False using int_zero_not_one by simp\n  } then show I: \"m\\<ra>\\<one> \\<noteq> m\" by auto\n  { from A1 have \"m \\<rs> \\<one> \\<ra> \\<one> = m\"\n      using Int_ZF_1_L8A Int_ZF_1_T2 group0.inv_cancel_two\n      by simp\n    moreover assume \"m\\<rs>\\<one> = m\"\n    ultimately have \"m \\<ra> \\<one> = m\" by simp\n    with I have False by simp\n  } then show \"m\\<rs>\\<one> \\<noteq> m\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 964
    },
    "863": {
        "type": "lemma",
        "text": "text\\<open>Integer order is a relation on integers.\\<close>\n",
        "assumes": "",
        "using": [
            "IntegerOrder_def"
        ],
        "statement": "lemma Int_ZF_2_L1B: shows \"IntegerOrder \\<subseteq> int\\<times>int\"\n",
        "proof": "proof\n  fix x assume \"x\\<in>IntegerOrder\" \n  then have \"x \\<in> {p\\<in>int\\<times>int. fst(p) $\\<le> snd(p)}\"\n    using IntegerOrder_def by simp\n  then show \"x\\<in>int\\<times>int\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 968
    },
    "864": {
        "type": "lemma",
        "text": "text\\<open>The way we define the notion of being bounded below,\n  its sufficient for the relation to be on integers for\n  all bounded below sets to be subsets of integers.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedBelow(A,IntegerOrder)\"\n  ",
        "using": [
            "Int_ZF_2_L1B"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L1C: \n  assumes A1: \"IsBoundedBelow(A,IntegerOrder)\"\n  shows \"A\\<subseteq>\\<int>\"\n",
        "proof": "proof -\n  from A1 have \n    \"IntegerOrder \\<subseteq> \\<int>\\<times>\\<int>\"\n    \"IsBoundedBelow(A,IntegerOrder)\"\n    using Int_ZF_2_L1B by auto\n  then show \"A\\<subseteq>\\<int>\" by (rule Order_ZF_3_L1B)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 969
    },
    "865": {
        "type": "lemma",
        "text": "text\\<open>The order on integers is reflexive.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_L1",
            "zle_refl",
            "refl_def"
        ],
        "statement": "lemma (in int0) int_ord_is_refl: shows \"refl(\\<int>,IntegerOrder)\"\n  ",
        "proof": "using Int_ZF_2_L1 zle_refl refl_def by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 970
    },
    "866": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show antisymmetry of the order on integers.\\<close>\n",
        "assumes": "assumes A1: \"m \\<lsq> n\"  \"n \\<lsq> m\"  \n  ",
        "using": [
            "Int_ZF_2_L1A",
            "zle_anti_sym"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L3: \n  assumes A1: \"m \\<lsq> n\"  \"n \\<lsq> m\"  \n  shows \"m=n\"\n",
        "proof": "proof -\n  from A1 have \"m $\\<le> n\"  \"n $\\<le> m\"  \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n    using Int_ZF_2_L1A by auto\n  then show \"m=n\" using zle_anti_sym by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 971
    },
    "867": {
        "type": "lemma",
        "text": "text\\<open>The order on integers is antisymmetric.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_L3",
            "imp_conj",
            "antisym_def"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L4: shows \"antisym(IntegerOrder)\"\n",
        "proof": "proof -\n  have \"\\<forall>m n. m \\<lsq> n  \\<and> n \\<lsq> m \\<longrightarrow> m=n\"\n    using Int_ZF_2_L3 by auto\n  then show ?thesis using imp_conj antisym_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 972
    },
    "868": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that the order on integers is \n  transitive.\\<close>\n",
        "assumes": "assumes A1: \"\\<langle>m,n\\<rangle> \\<in> IntegerOrder\"  \"\\<langle>n,k\\<rangle> \\<in> IntegerOrder\"\n  ",
        "using": [
            "int0.Int_ZF_2_L1A",
            "int0.Int_ZF_2_L1"
        ],
        "statement": "lemma Int_ZF_2_L5: \n  assumes A1: \"\\<langle>m,n\\<rangle> \\<in> IntegerOrder\"  \"\\<langle>n,k\\<rangle> \\<in> IntegerOrder\"\n  shows \"\\<langle>m,k\\<rangle> \\<in> IntegerOrder\"\n",
        "proof": "proof -\n  from A1 have T1: \"m $\\<le> n\" \"n $\\<le> k\" and T2: \"m\\<in>int\" \"k\\<in>int\"\n    using int0.Int_ZF_2_L1A by auto\n  from T1 have \"m $\\<le> k\" by (rule zle_trans)\n  with T2 show ?thesis using int0.Int_ZF_2_L1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 973
    },
    "869": {
        "type": "lemma",
        "text": "text\\<open>The order on integers is \n  transitive. This version is stated in the \\<open>int0\\<close> context \n  using notation for integers.\\<close>\n",
        "assumes": "assumes A1: \"m\\<lsq>n\"  \"n\\<lsq>k\"\n  ",
        "using": [],
        "statement": "lemma (in int0) Int_order_transitive: \n  assumes A1: \"m\\<lsq>n\"  \"n\\<lsq>k\"\n  shows \"m\\<lsq>k\"\n",
        "proof": "proof -\n  from A1 have \"\\<langle> m,n\\<rangle> \\<in> IntegerOrder\"  \"\\<langle> n,k\\<rangle> \\<in> IntegerOrder\"\n    by auto\n  then have \"\\<langle> m,k\\<rangle> \\<in> IntegerOrder\" by (rule Int_ZF_2_L5)\n  then show \"m\\<lsq>k\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 974
    },
    "870": {
        "type": "lemma",
        "text": "text\\<open>The order on integers is transitive.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_L5"
        ],
        "statement": "lemma Int_ZF_2_L6: shows \"trans(IntegerOrder)\"\n",
        "proof": "proof -\n  have \"\\<forall> m n k. \n    \\<langle>m, n\\<rangle> \\<in> IntegerOrder \\<and> \\<langle>n, k\\<rangle> \\<in> IntegerOrder \\<longrightarrow> \n    \\<langle>m, k\\<rangle> \\<in> IntegerOrder\"\n    using Int_ZF_2_L5 by blast\n  then show ?thesis by (rule Fol1_L2)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 975
    },
    "871": {
        "type": "lemma",
        "text": "text\\<open>The order on integers is a partial order.\\<close>\n",
        "assumes": "",
        "using": [
            "int0.int_ord_is_refl",
            "int0.Int_ZF_2_L4",
            "Int_ZF_2_L6",
            "IsPartOrder_def"
        ],
        "statement": "lemma Int_ZF_2_L7: shows \"IsPartOrder(int,IntegerOrder)\"\n  ",
        "proof": "using int0.int_ord_is_refl int0.Int_ZF_2_L4 \n    Int_ZF_2_L6 IsPartOrder_def by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 976
    },
    "872": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that the order on integers is \n  preserved by translations.\\<close>\n",
        "assumes": "assumes A1: \"k \\<in> \\<int>\" and A2: \"m \\<lsq> n\" \n  ",
        "using": [
            "Int_ZF_2_L1A",
            "zadd_right_cancel_zle",
            "zadd_left_cancel_zle",
            "Int_ZF_1_L2",
            "Int_ZF_1_L1",
            "apply_funtype",
            "Int_ZF_2_L1"
        ],
        "statement": "lemma (in int0) int_ord_transl_inv: \n  assumes A1: \"k \\<in> \\<int>\" and A2: \"m \\<lsq> n\" \n  shows \"m\\<ra>k \\<lsq> n\\<ra>k \"  \"k\\<ra>m\\<lsq> k\\<ra>n \"\n",
        "proof": "proof -\n  from A2 have \"m $\\<le> n\" and \"m\\<in>\\<int>\" \"n\\<in>\\<int>\" \n    using Int_ZF_2_L1A by auto  \n  with A1 show \"m\\<ra>k \\<lsq> n\\<ra>k \"  \"k\\<ra>m\\<lsq> k\\<ra>n \"\n    using zadd_right_cancel_zle zadd_left_cancel_zle\n    Int_ZF_1_L2 Int_ZF_1_L1 apply_funtype\n    Int_ZF_1_L2 Int_ZF_2_L1 Int_ZF_1_L2 by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 977
    },
    "873": {
        "type": "theorem",
        "text": "text\\<open>Integers form a linearly ordered group. We can apply all theorems\n  proven in group3 context to integers.\\<close>\n",
        "assumes": "",
        "using": [
            "int_ord_transl_inv",
            "Int_ZF_1_T2",
            "Int_ZF_2_L1B",
            "Int_ZF_2_L7",
            "IsAnOrdGroup_def",
            "group3_def",
            "zle_linear",
            "Int_ZF_2_L1",
            "IsTotal_def",
            "IsPartOrder_def",
            "IsLinOrder_def"
        ],
        "statement": "theorem (in int0) Int_ZF_2_T1: shows\n  \"IsAnOrdGroup(\\<int>,IntegerAddition,IntegerOrder)\"\n  \"IntegerOrder {is total on} \\<int>\"\n  \"group3(\\<int>,IntegerAddition,IntegerOrder)\"\n  \"IsLinOrder(\\<int>,IntegerOrder)\"\n",
        "proof": "proof -\n  have \"\\<forall>k\\<in>\\<int>. \\<forall>m n. m \\<lsq> n  \\<longrightarrow> \n    m\\<ra>k \\<lsq> n\\<ra>k \\<and> k\\<ra>m\\<lsq> k\\<ra>n\"\n    using int_ord_transl_inv by simp\n  then show T1: \"IsAnOrdGroup(\\<int>,IntegerAddition,IntegerOrder)\" using\n    Int_ZF_1_T2 Int_ZF_2_L1B Int_ZF_2_L7 IsAnOrdGroup_def\n    by simp\n  then show \"group3(\\<int>,IntegerAddition,IntegerOrder)\"\n    using group3_def by simp\n  have \"\\<forall>n\\<in>\\<int>. \\<forall>m\\<in>\\<int>. n\\<lsq>m \\<or> m\\<lsq>n\"\n    using zle_linear Int_ZF_2_L1 by auto\n  then show \"IntegerOrder {is total on} \\<int>\"\n    using IsTotal_def by simp\n  with T1 show \"IsLinOrder(\\<int>,IntegerOrder)\"\n    using IsAnOrdGroup_def IsPartOrder_def IsLinOrder_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 978
    },
    "874": {
        "type": "lemma",
        "text": "text\\<open>If a pair $(i,m)$ belongs to the order relation on integers and\n  $i\\neq m$, then $i<m$ in the sense of defined in the standard Isabelle's \n  Int.thy.\\<close>\n",
        "assumes": "assumes A1: \"i \\<lsq> m\" and A2: \"i\\<noteq>m\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "zle_def"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L9: assumes A1: \"i \\<lsq> m\" and A2: \"i\\<noteq>m\"\n  shows \"i $< m\"\n",
        "proof": "proof -\n  from A1 have \"i $\\<le> m\"  \"i\\<in>\\<int>\"  \"m\\<in>\\<int>\" \n    using Int_ZF_2_L1A by auto\n  with A2 show \"i $< m\" using zle_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 979
    },
    "875": {
        "type": "lemma",
        "text": "text\\<open>A small technical lemma about putting one on the other side\n  of an inequality.\\<close>\n",
        "assumes": "assumes A1: \"k\\<in>\\<int>\" and A2: \"m \\<lsq> k $- ($# 1)\"\n  ",
        "using": [
            "Int_ZF_1_L8A",
            "int_ord_transl_inv",
            "Int_ZF_1_L13"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L9A: \n  assumes A1: \"k\\<in>\\<int>\" and A2: \"m \\<lsq> k $- ($# 1)\"\n  shows \"m\\<ra>\\<one> \\<lsq> k\"\n",
        "proof": "proof -\n  from A2 have \"m\\<ra>\\<one> \\<lsq> (k $- ($# 1)) \\<ra> \\<one>\"\n    using Int_ZF_1_L8A int_ord_transl_inv by simp\n  with A1 show \"m\\<ra>\\<one> \\<lsq> k\"\n    using Int_ZF_1_L13 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 981
    },
    "876": {
        "type": "lemma",
        "text": "text\\<open>We can put any integer on the other side of an inequality reversing\n  its sign.\\<close>\n",
        "assumes": "assumes \"i\\<in>\\<int>\"  \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L9A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L9B: assumes \"i\\<in>\\<int>\"  \"m\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  shows \"i\\<ra>m \\<lsq> k  \\<longleftrightarrow> i \\<lsq> k\\<rs>m\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L9A\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 982
    },
    "877": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>Int_ZF_2_L9B\\<close> with weaker assumptions.\\<close>\n",
        "assumes": "assumes \"i\\<in>\\<int>\"  \"m\\<in>\\<int>\" and \"i\\<rs>m \\<lsq> k\" \n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L9B"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L9C: \n  assumes \"i\\<in>\\<int>\"  \"m\\<in>\\<int>\" and \"i\\<rs>m \\<lsq> k\" \n  shows \"i \\<lsq> k\\<ra>m\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L9B\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 983
    },
    "878": {
        "type": "lemma",
        "text": "text\\<open>Taking (higher order) minus on both sides of inequality reverses it.\\<close>\n",
        "assumes": "assumes \"k \\<lsq> i\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_L1A",
            "Int_ZF_1_L9A",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L10: assumes \"k \\<lsq> i\"\n  shows \n  \"(\\<rm>i) \\<lsq> (\\<rm>k)\"   \n  \"$-i \\<lsq> $-k\" \n  ",
        "proof": "using assms Int_ZF_2_L1A Int_ZF_1_L9A Int_ZF_2_T1 \n    group3.OrderedGroup_ZF_1_L5 by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 984
    },
    "879": {
        "type": "lemma",
        "text": "text\\<open>Taking minus on both sides of inequality reverses it, \n  version with a negative on one side.\\<close>\n",
        "assumes": "assumes \"n\\<in>\\<int>\"  \"m\\<lsq>(\\<rm>n)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5AD"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L10AA: assumes \"n\\<in>\\<int>\"  \"m\\<lsq>(\\<rm>n)\"\n  shows \"n\\<lsq>(\\<rm>m)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5AD\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 985
    },
    "880": {
        "type": "lemma",
        "text": "text\\<open>We can cancel the same element on on both sides of an inequality,\n  a version with minus on both sides.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\" and \"m\\<rs>n \\<lsq> m\\<rs>k\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5AF"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L10AB: \n  assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\" and \"m\\<rs>n \\<lsq> m\\<rs>k\"\n  shows \"k\\<lsq>n\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5AF\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 986
    },
    "881": {
        "type": "lemma",
        "text": "text\\<open>If an integer is nonpositive, then its opposite is nonnegative.\\<close>\n",
        "assumes": "assumes \"k \\<lsq> \\<zero>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L10A: assumes \"k \\<lsq> \\<zero>\"\n  shows \"\\<zero>\\<lsq>(\\<rm>k)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5A by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 987
    },
    "882": {
        "type": "lemma",
        "text": "text\\<open>If the opposite of an integers is nonnegative, then the integer \n  is nonpositive.\\<close>\n",
        "assumes": "assumes \"k\\<in>\\<int>\" and \"\\<zero>\\<lsq>(\\<rm>k)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5AA"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L10B: \n  assumes \"k\\<in>\\<int>\" and \"\\<zero>\\<lsq>(\\<rm>k)\"\n  shows \"k\\<lsq>\\<zero>\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5AA by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 988
    },
    "883": {
        "type": "lemma",
        "text": "text\\<open>Adding one to an integer corresponds to taking a successor for a natural\n  number.\\<close>\n",
        "assumes": "",
        "using": [
            "int_succ_int_1",
            "zadd_commute",
            "zadd_assoc"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L11: \n  shows \"i $+ $# n $+ ($# 1)  =  i $+ $# succ(n)\"\n",
        "proof": "proof -\n  have \"$# succ(n) = $#1 $+ $# n\" using int_succ_int_1 by blast\n  then have \"i $+ $# succ(n) = i $+ ($# n  $+ $#1)\"\n    using zadd_commute by simp\n  then show ?thesis using zadd_assoc by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 989
    },
    "884": {
        "type": "lemma",
        "text": "text\\<open>Adding a natural number increases integers.\\<close>\n",
        "assumes": "assumes A1: \"i\\<in>\\<int>\" and A2: \"n\\<in>nat\"\n  ",
        "using": [
            "zadd_int0",
            "int_ord_is_refl",
            "refl_def",
            "Nat_ZF_1_L3",
            "zless_succ_zadd",
            "zless_imp_zle",
            "Int_ZF_2_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L12: assumes A1: \"i\\<in>\\<int>\" and A2: \"n\\<in>nat\"\n  shows \"i \\<lsq> i $+ $#n\"\n",
        "proof": "proof -\n  { assume \"n = 0\" \n    with A1 have \"i \\<lsq> i $+ $#n\" using zadd_int0 int_ord_is_refl refl_def\n      by simp }\n  moreover\n  { assume \"n\\<noteq>0\" \n    with A2 obtain k where \"k\\<in>nat\" \"n = succ(k)\" \n      using Nat_ZF_1_L3 by auto\n    with A1 have \"i \\<lsq> i $+ $#n\"\n      using zless_succ_zadd zless_imp_zle Int_ZF_2_L1 by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 990
    },
    "885": {
        "type": "lemma",
        "text": "text\\<open>Adding one increases integers.\\<close>\n",
        "assumes": "assumes A1: \"j\\<lsq>k\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_2_L12",
            "zle_trans",
            "Int_ZF_2_L1",
            "Int_ZF_1_L2",
            "Int_ZF_1_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L12A: assumes A1: \"j\\<lsq>k\"\n  shows \"j \\<lsq> k $+ $#1\"  \"j \\<lsq> k\\<ra>\\<one>\"\n",
        "proof": "proof -\n  from A1 have T1:\"j\\<in>\\<int>\" \"k\\<in>\\<int>\" \"j $\\<le> k\" \n    using Int_ZF_2_L1A by auto  \n  moreover from T1 have \"k $\\<le> k $+ $#1\" using Int_ZF_2_L12 Int_ZF_2_L1A\n    by simp\n  ultimately have \"j $\\<le> k $+ $#1\" using zle_trans by fast\n  with T1 show \"j \\<lsq> k $+ $#1\" using Int_ZF_2_L1 by simp\n  with T1 have \"j\\<lsq> k\\<ra>$#1\"\n    using Int_ZF_1_L2 by simp\n  then show \"j \\<lsq> k\\<ra>\\<one>\" using Int_ZF_1_L8 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 991
    },
    "886": {
        "type": "lemma",
        "text": "text\\<open>Adding one increases integers, yet one more version.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" ",
        "using": [
            "assms",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_2_L12A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L12B: assumes A1: \"m\\<in>\\<int>\" shows \"m \\<lsq> m\\<ra>\\<one>\"\n  ",
        "proof": "using assms int_ord_is_refl refl_def Int_ZF_2_L12A by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 992
    },
    "887": {
        "type": "lemma",
        "text": "text\\<open>If $k+1 = m+n$, where $n$ is a non-zero natural number, then \n  $m\\leq k$.\\<close>\n",
        "assumes": "assumes A1: \"k\\<in>\\<int>\" \"m\\<in>\\<int>\" and A2: \"n\\<in>nat\" \n  and A3: \"k $+ ($# 1) = m $+ $# succ(n)\"\n  ",
        "using": [
            "Int_ZF_2_L11",
            "zadd_right_cancel",
            "Int_ZF_2_L12"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L13: \n  assumes A1: \"k\\<in>\\<int>\" \"m\\<in>\\<int>\" and A2: \"n\\<in>nat\" \n  and A3: \"k $+ ($# 1) = m $+ $# succ(n)\"\n  shows \"m \\<lsq> k\"\n",
        "proof": "proof -\n  from A1 have \"k\\<in>\\<int>\" \"m $+ $# n \\<in> \\<int>\" by auto\n  moreover from assms have \"k $+ $# 1 = m $+ $# n $+ $#1\"\n    using Int_ZF_2_L11 by simp\n  ultimately have \"k = m $+ $# n\" using zadd_right_cancel by simp\n  with A1 A2 show ?thesis using Int_ZF_2_L12 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 993
    },
    "888": {
        "type": "lemma",
        "text": "text\\<open>The absolute value of an integer is an integer.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L1",
            "apply_funtype"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L14: assumes A1: \"m\\<in>\\<int>\"\n  shows \"abs(m) \\<in> \\<int>\"\n",
        "proof": "proof -\n  have \"AbsoluteValue(\\<int>,IntegerAddition,IntegerOrder) : \\<int>\\<rightarrow>\\<int>\"\n    using Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L1 by simp\n  with A1 show ?thesis using apply_funtype by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 994
    },
    "889": {
        "type": "lemma",
        "text": "text\\<open>If two integers are nonnegative, then the opposite\n  of one is less or equal than the other and the sum is also nonnegative.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>m\"  \"\\<zero>\\<lsq>n\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5AC",
            "group3.OrderedGroup_ZF_1_L12"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L14A: \n  assumes \"\\<zero>\\<lsq>m\"  \"\\<zero>\\<lsq>n\"\n  shows \n  \"(\\<rm>m) \\<lsq> n\"\n  \"\\<zero> \\<lsq> m \\<ra> n\"\n  ",
        "proof": "using assms Int_ZF_2_T1 \n    group3.OrderedGroup_ZF_1_L5AC group3.OrderedGroup_ZF_1_L12\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 995
    },
    "890": {
        "type": "lemma",
        "text": "text\\<open>We can increase components in an estimate.\\<close>\n",
        "assumes": "assumes \"b\\<lsq>b\\<^sub>1\" \"c\\<lsq>c\\<^sub>1\" and \"a\\<lsq>b\\<ra>c\"\n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L15: \n  assumes \"b\\<lsq>b\\<^sub>1\" \"c\\<lsq>c\\<^sub>1\" and \"a\\<lsq>b\\<ra>c\"\n  shows \"a\\<lsq>b\\<^sub>1\\<ra>c\\<^sub>1\"\n",
        "proof": "proof -\n  from assms have \"group3(\\<int>,IntegerAddition,IntegerOrder)\" \n    \"\\<langle>a,IntegerAddition`\\<langle> b,c\\<rangle>\\<rangle> \\<in> IntegerOrder\" \n    \"\\<langle>b,b\\<^sub>1\\<rangle> \\<in> IntegerOrder\" \"\\<langle>c,c\\<^sub>1\\<rangle> \\<in> IntegerOrder\"\n    using Int_ZF_2_T1 by auto\n  then have \"\\<langle>a,IntegerAddition`\\<langle> b\\<^sub>1,c\\<^sub>1\\<rangle>\\<rangle> \\<in> IntegerOrder\" \n    by (rule group3.OrderedGroup_ZF_1_L5E)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 996
    },
    "891": {
        "type": "lemma",
        "text": "text\\<open>We can add or subtract the sides of two inequalities.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"c\\<lsq>d\"  \n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5B",
            "group3.OrderedGroup_ZF_1_L5I"
        ],
        "statement": "lemma (in int0) int_ineq_add_sides: \n  assumes \"a\\<lsq>b\" and \"c\\<lsq>d\"  \n  shows \n  \"a\\<ra>c \\<lsq> b\\<ra>d\"\n  \"a\\<rs>d \\<lsq> b\\<rs>c\"\n  ",
        "proof": "using assms Int_ZF_2_T1 \n    group3.OrderedGroup_ZF_1_L5B group3.OrderedGroup_ZF_1_L5I\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 997
    },
    "892": {
        "type": "lemma",
        "text": "text\\<open>We can increase the second component in an estimate.\\<close>\n",
        "assumes": "assumes \"b\\<in>\\<int>\" and \"a\\<lsq>b\\<ra>c\" and A3: \"c\\<lsq>c\\<^sub>1\" \n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L15A: \n  assumes \"b\\<in>\\<int>\" and \"a\\<lsq>b\\<ra>c\" and A3: \"c\\<lsq>c\\<^sub>1\" \n  shows \"a\\<lsq>b\\<ra>c\\<^sub>1\"\n",
        "proof": "proof - \n  from assms have \n    \"group3(\\<int>,IntegerAddition,IntegerOrder)\" \n    \"b \\<in> \\<int>\"\n    \"\\<langle>a,IntegerAddition`\\<langle> b,c\\<rangle>\\<rangle> \\<in> IntegerOrder\" \n    \"\\<langle>c,c\\<^sub>1\\<rangle> \\<in> IntegerOrder\"\n    using Int_ZF_2_T1 by auto\n  then have \"\\<langle>a,IntegerAddition`\\<langle> b,c\\<^sub>1\\<rangle>\\<rangle> \\<in> IntegerOrder\" \n     by (rule group3.OrderedGroup_ZF_1_L5D)\n   thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 998
    },
    "893": {
        "type": "lemma",
        "text": "text\\<open>If we increase the second component in a sum of three\n  integers, the whole sum inceases.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" and A2: \"k \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L15C: \n  assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" and A2: \"k \\<lsq> L\"\n  shows \"m\\<ra>k\\<ra>n \\<lsq> m\\<ra>L\\<ra>n\"\n",
        "proof": "proof -\n  let ?P = \"IntegerAddition\"\n  from assms have\n    \"group3(int,?P,IntegerOrder)\"\n    \"m \\<in> int\"  \"n \\<in> int\"\n    \"\\<langle>k,L\\<rangle> \\<in> IntegerOrder\"\n    using Int_ZF_2_T1 by auto\n  then have \"\\<langle>?P`\\<langle>?P`\\<langle> m,k\\<rangle>,n\\<rangle>, ?P`\\<langle>?P`\\<langle> m,L\\<rangle>,n\\<rangle> \\<rangle> \\<in> IntegerOrder\"\n    by (rule group3.OrderedGroup_ZF_1_L10)\n  then show \"m\\<ra>k\\<ra>n \\<lsq> m\\<ra>L\\<ra>n\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 999
    },
    "894": {
        "type": "lemma",
        "text": "text\\<open>We don't decrease an integer by adding a nonnegative one.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>n\"  \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5F"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L15D:\n  assumes \"\\<zero>\\<lsq>n\"  \"m\\<in>\\<int>\"\n  shows \"m \\<lsq> n\\<ra>m\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5F\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1000
    },
    "895": {
        "type": "lemma",
        "text": "text\\<open>Some inequalities about the sum of two integers\n  and its absolute value.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L6A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L15E:\n  assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"m\\<ra>n \\<lsq> abs(m)\\<ra>abs(n)\"\n  \"m\\<rs>n \\<lsq> abs(m)\\<ra>abs(n)\"\n  \"(\\<rm>m)\\<ra>n \\<lsq> abs(m)\\<ra>abs(n)\"\n  \"(\\<rm>m)\\<rs>n \\<lsq> abs(m)\\<ra>abs(n)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L6A\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1001
    },
    "896": {
        "type": "lemma",
        "text": "text\\<open>We can add a nonnegative\n  integer to the right hand side of an inequality.\\<close>\n",
        "assumes": "assumes \"m\\<lsq>k\"  and \"\\<zero>\\<lsq>n\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L5G"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L15F:  assumes \"m\\<lsq>k\"  and \"\\<zero>\\<lsq>n\"\n  shows \"m \\<lsq> k\\<ra>n\"  \"m \\<lsq> n\\<ra>k\"  \n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L5G\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1002
    },
    "897": {
        "type": "lemma",
        "text": "text\\<open>Triangle inequality for integers.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "Int_ZF_2_T1",
            "group3.OrdGroup_triangle_ineq"
        ],
        "statement": "lemma (in int0) Int_triangle_ineq: \n  assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"abs(m\\<ra>n)\\<lsq>abs(m)\\<ra>abs(n)\"\n  ",
        "proof": "using assms Int_ZF_1_T2 Int_ZF_2_T1 group3.OrdGroup_triangle_ineq\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1003
    },
    "898": {
        "type": "lemma",
        "text": "text\\<open>$0\\leq 1$, so $|1| = 1$.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L8",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_2_L12A",
            "Int_ZF_1_T2",
            "group0.group0_2_L2",
            "Int_ZF_2_L16"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L16A: shows \"\\<zero>\\<lsq>\\<one>\" and \"abs(\\<one>) = \\<one>\"\n",
        "proof": "proof -\n  have \"($# 0) \\<in> \\<int>\" \"($# 1)\\<in> \\<int>\" by auto\n  then have \"\\<zero>\\<lsq>\\<zero>\" and T1: \"\\<one>\\<in>\\<int>\" \n    using Int_ZF_1_L8 int_ord_is_refl refl_def by auto\n  then have \"\\<zero>\\<lsq>\\<zero>\\<ra>\\<one>\" using Int_ZF_2_L12A by simp\n  with T1 show \"\\<zero>\\<lsq>\\<one>\" using Int_ZF_1_T2 group0.group0_2_L2\n    by simp\n  then show \"abs(\\<one>) = \\<one>\" using Int_ZF_2_L16 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1005
    },
    "899": {
        "type": "lemma",
        "text": "text\\<open>$1\\leq 2$.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_1_L8",
            "int_ord_is_refl",
            "refl_def",
            "Int_ZF_2_L12A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L16B: shows \"\\<one>\\<lsq>\\<two>\"\n",
        "proof": "proof -\n  have \"($# 1)\\<in> \\<int>\" by simp\n  then show \"\\<one>\\<lsq>\\<two>\" \n    using Int_ZF_1_L8 int_ord_is_refl refl_def Int_ZF_2_L12A \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1006
    },
    "900": {
        "type": "lemma",
        "text": "text\\<open>Integers greater or equal one are greater or equal zero.\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\" ",
        "using": [
            "Int_ZF_2_L16A",
            "Int_ZF_2_L16B",
            "Int_ZF_1_L8A",
            "int_ord_transl_inv",
            "Int_ZF_2_L3",
            "int_zero_not_one"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L16C: \n  assumes A1: \"\\<one>\\<lsq>a\" shows \n  \"\\<zero>\\<lsq>a\"  \"a\\<noteq>\\<zero>\"\n  \"\\<two> \\<lsq> a\\<ra>\\<one>\"\n  \"\\<one> \\<lsq> a\\<ra>\\<one>\"\n  \"\\<zero> \\<lsq> a\\<ra>\\<one>\"\n",
        "proof": "proof -\n  from A1 have \"\\<zero>\\<lsq>\\<one>\" and \"\\<one>\\<lsq>a\" \n    using Int_ZF_2_L16A by auto\n  then show \"\\<zero>\\<lsq>a\" by (rule Int_order_transitive)\n  have I: \"\\<zero>\\<lsq>\\<one>\" using Int_ZF_2_L16A by simp \n  have \"\\<one>\\<lsq>\\<two>\" using Int_ZF_2_L16B by simp\n  moreover from A1 show \"\\<two> \\<lsq> a\\<ra>\\<one>\"\n    using Int_ZF_1_L8A int_ord_transl_inv by simp\n  ultimately show \"\\<one> \\<lsq> a\\<ra>\\<one>\" by (rule Int_order_transitive)\n  with I show \"\\<zero> \\<lsq> a\\<ra>\\<one>\" by (rule Int_order_transitive)\n  from A1 show \"a\\<noteq>\\<zero>\" using\n    Int_ZF_2_L16A Int_ZF_2_L3 int_zero_not_one by auto \nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1007
    },
    "901": {
        "type": "lemma",
        "text": "text\\<open>Absolute value is the same for an integer and its opposite.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\" ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L7A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L17: \n  assumes \"m\\<in>\\<int>\" shows \"abs(\\<rm>m) = abs(m)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L7A by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1008
    },
    "902": {
        "type": "lemma",
        "text": "text\\<open>The absolute value of zero is zero.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L2A"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L18: shows \"abs(\\<zero>) = \\<zero>\"\n  ",
        "proof": "using Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L2A by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1009
    },
    "903": {
        "type": "lemma",
        "text": "text\\<open>A different version of the triangle inequality.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_L9A",
            "Int_triangle_ineq",
            "Int_ZF_2_L17",
            "Int_ZF_2_L14",
            "Int_ZF_1_T2",
            "IsCommutative_def"
        ],
        "statement": "lemma (in int0) Int_triangle_ineq1: \n  assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"abs(m\\<rs>n) \\<lsq> abs(n)\\<ra>abs(m)\"\n  \"abs(m\\<rs>n) \\<lsq> abs(m)\\<ra>abs(n)\"\n",
        "proof": "proof -\n  have \"$-n \\<in> \\<int>\" by simp\n  with A1 have \"abs(m\\<rs>n) \\<lsq> abs(m)\\<ra>abs(\\<rm>n)\"\n    using Int_ZF_1_L9A Int_triangle_ineq by simp\n  with A1 show \n    \"abs(m\\<rs>n) \\<lsq> abs(n)\\<ra>abs(m)\"\n    \"abs(m\\<rs>n) \\<lsq> abs(m)\\<ra>abs(n)\" \n    using Int_ZF_2_L17 Int_ZF_2_L14 Int_ZF_1_T2 IsCommutative_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1010
    },
    "904": {
        "type": "lemma",
        "text": "text\\<open>Another version of the triangle inequality.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  and \"abs(m\\<rs>n) \\<lsq> k\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L7D",
            "group3.OrderedGroup_ZF_3_L7E"
        ],
        "statement": "lemma (in int0) Int_triangle_ineq2: \n  assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  and \"abs(m\\<rs>n) \\<lsq> k\"\n  shows \n  \"abs(m) \\<lsq> abs(n)\\<ra>k\"\n  \"m\\<rs>k \\<lsq> n\"\n  \"m \\<lsq> n\\<ra>k\"\n  \"n\\<rs>k \\<lsq> m\"\n  ",
        "proof": "using assms Int_ZF_1_T2 Int_ZF_2_T1 \n    group3.OrderedGroup_ZF_3_L7D group3.OrderedGroup_ZF_3_L7E\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1011
    },
    "905": {
        "type": "lemma",
        "text": "text\\<open>Triangle inequality with three integers. We could use\n  \\<open>OrdGroup_triangle_ineq3\\<close>, but since simp cannot translate\n  the notation directly, it is simpler to reprove it for integers.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_T2",
            "group0.group_op_closed",
            "Int_ZF_2_L14",
            "Int_triangle_ineq",
            "int_ord_transl_inv"
        ],
        "statement": "lemma (in int0) Int_triangle_ineq3: \n  assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"  \"k\\<in>\\<int>\"\n  shows \"abs(m\\<ra>n\\<ra>k) \\<lsq> abs(m)\\<ra>abs(n)\\<ra>abs(k)\"\n",
        "proof": "proof -\n  from A1 have T: \"m\\<ra>n \\<in> \\<int>\"  \"abs(k) \\<in> \\<int>\"\n    using Int_ZF_1_T2 group0.group_op_closed  Int_ZF_2_L14\n    by auto\n  with A1 have \"abs(m\\<ra>n\\<ra>k) \\<lsq> abs(m\\<ra>n) \\<ra> abs(k)\"\n    using Int_triangle_ineq by simp\n  moreover from A1 T have \n    \"abs(m\\<ra>n) \\<ra> abs(k) \\<lsq> abs(m) \\<ra> abs(n) \\<ra> abs(k)\"\n    using Int_triangle_ineq int_ord_transl_inv by simp\n  ultimately show ?thesis by (rule Int_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1012
    },
    "906": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows what happens when one integers is not\n  greater or equal than another.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" and A2: \"\\<not>(n\\<lsq>m)\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "IsTotal_def",
            "Int_ZF_2_L10",
            "int_ord_is_refl",
            "refl_def"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L19: \n  assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" and A2: \"\\<not>(n\\<lsq>m)\"\n  shows \"m\\<lsq>n\"  \"(\\<rm>n) \\<lsq> (\\<rm>m)\"  \"m\\<noteq>n\"\n",
        "proof": "proof -\n  from A1 A2 show \"m\\<lsq>n\" using Int_ZF_2_T1 IsTotal_def \n    by auto\n  then show \"(\\<rm>n) \\<lsq> (\\<rm>m)\" using Int_ZF_2_L10 \n    by simp\n  from A1 have \"n \\<lsq> n\" using int_ord_is_refl refl_def \n    by simp\n  with A2 show \"m\\<noteq>n\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1013
    },
    "907": {
        "type": "lemma",
        "text": "text\\<open>If one integer is greater or equal and not equal to another,\n  then it is not smaller or equal.\\<close>\n",
        "assumes": "assumes A1: \"m\\<lsq>n\" and A2: \"m\\<noteq>n\"\n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L19AA: assumes A1: \"m\\<lsq>n\" and A2: \"m\\<noteq>n\"\n  shows \"\\<not>(n\\<lsq>m)\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"group3(\\<int>, IntegerAddition, IntegerOrder)\"\n    \"\\<langle>m,n\\<rangle> \\<in> IntegerOrder\"\n    \"m\\<noteq>n\"\n    using Int_ZF_2_T1 by auto\n  then have \"\\<langle>n,m\\<rangle> \\<notin> IntegerOrder\" \n    by (rule group3.OrderedGroup_ZF_1_L8AA)\n  thus \"\\<not>(n\\<lsq>m)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1014
    },
    "908": {
        "type": "lemma",
        "text": "text\\<open>The next lemma allows to prove theorems for the case of positive and \n  negative integers separately.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" and A2: \"\\<not>(\\<zero>\\<lsq>m)\"\n  ",
        "using": [
            "Int_ZF_1_T2",
            "group0.group0_2_L2",
            "Int_ZF_2_L19",
            "group0.group_inv_of_one"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L19A: assumes A1: \"m\\<in>\\<int>\" and A2: \"\\<not>(\\<zero>\\<lsq>m)\"\n  shows \"m\\<lsq>\\<zero>\"  \"\\<zero> \\<lsq> (\\<rm>m)\"  \"m\\<noteq>\\<zero>\"\n",
        "proof": "proof -\n  from A1 have T: \"\\<zero> \\<in> \\<int>\"\n    using Int_ZF_1_T2 group0.group0_2_L2 by auto\n  with A1 A2 show \"m\\<lsq>\\<zero>\" using Int_ZF_2_L19 by blast\n  from A1 T A2 show \"m\\<noteq>\\<zero>\"  by (rule Int_ZF_2_L19)\n  from A1 T A2 have \"(\\<rm>\\<zero>)\\<lsq>(\\<rm>m)\" by (rule Int_ZF_2_L19)\n  then show \"\\<zero> \\<lsq> (\\<rm>m)\"\n    using Int_ZF_1_T2 group0.group_inv_of_one by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1015
    },
    "909": {
        "type": "lemma",
        "text": "text\\<open>We can prove a theorem about integers by proving that\n  it holds for $m=0$, $m\\in$\\<open>\\<int>\\<^sub>+\\<close> and $-m\\in$\\<open>\\<int>\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\" and \"Q(\\<zero>)\" and \"\\<forall>n\\<in>\\<int>\\<^sub>+. Q(n)\" and \"\\<forall>n\\<in>\\<int>\\<^sub>+. Q(\\<rm>n)\"\n  ",
        "using": [
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L19B: \n  assumes \"m\\<in>\\<int>\" and \"Q(\\<zero>)\" and \"\\<forall>n\\<in>\\<int>\\<^sub>+. Q(n)\" and \"\\<forall>n\\<in>\\<int>\\<^sub>+. Q(\\<rm>n)\"\n  shows \"Q(m)\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?P = \"IntegerAddition\"\n  let ?r = \"IntegerOrder\"\n  let ?b = \"m\"\n  from assms have \n    \"group3(?G, ?P, ?r)\"\n    \"?r {is total on} ?G\"\n    \"?b \\<in> ?G\"\n    \"Q(TheNeutralElement(?G, ?P))\"\n    \"\\<forall>a\\<in>PositiveSet(?G, ?P, ?r). Q(a)\"\n    \"\\<forall>a\\<in>PositiveSet(?G, ?P, ?r). Q(GroupInv(?G, ?P)`(a))\"\n    using Int_ZF_2_T1 by auto\n  then show \"Q(?b)\" by (rule group3.OrderedGroup_ZF_1_L18)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1016
    },
    "910": {
        "type": "lemma",
        "text": "text\\<open>An integer is not greater than its absolute value.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L5",
            "group3.OrderedGroup_ZF_3_L6"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L19C: assumes A1: \"m\\<in>\\<int>\"\n  shows \n  \"m \\<lsq> abs(m)\"\n  \"(\\<rm>m) \\<lsq> abs(m)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 \n    group3.OrderedGroup_ZF_3_L5 group3.OrderedGroup_ZF_3_L6\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1017
    },
    "911": {
        "type": "lemma",
        "text": "text\\<open>$|m-n| = |n-m|$.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L7B"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L20: assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"abs(m\\<rs>n) = abs(n\\<rs>m)\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L7B by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1018
    },
    "912": {
        "type": "lemma",
        "text": "text\\<open>We can add the sides of inequalities with absolute values.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" \"n\\<in>\\<int>\"\n  and A2: \"abs(m) \\<lsq> k\"  \"abs(n) \\<lsq> l\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L7C",
            "group3.OrderedGroup_ZF_3_L7CA"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L21: \n  assumes A1: \"m\\<in>\\<int>\" \"n\\<in>\\<int>\"\n  and A2: \"abs(m) \\<lsq> k\"  \"abs(n) \\<lsq> l\"\n  shows \n  \"abs(m\\<ra>n) \\<lsq> k \\<ra> l\"\n  \"abs(m\\<rs>n) \\<lsq> k \\<ra> l\"\n  ",
        "proof": "using assms Int_ZF_1_T2 Int_ZF_2_T1 \n    group3.OrderedGroup_ZF_3_L7C group3.OrderedGroup_ZF_3_L7CA\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1019
    },
    "913": {
        "type": "lemma",
        "text": "text\\<open>Absolute value is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_3_L3C",
            "apply_funtype",
            "group3.OrderedGroup_ZF_1_L2"
        ],
        "statement": "lemma (in int0) int_abs_nonneg: assumes A1: \"m\\<in>\\<int>\"\n  shows \"abs(m) \\<in> \\<int>\\<^sup>+\"  \"\\<zero> \\<lsq> abs(m)\" \n",
        "proof": "proof -\n  have \"AbsoluteValue(\\<int>,IntegerAddition,IntegerOrder) : \\<int>\\<rightarrow>\\<int>\\<^sup>+\"\n    using Int_ZF_2_T1 group3.OrderedGroup_ZF_3_L3C by simp\n  with A1 show \"abs(m) \\<in> \\<int>\\<^sup>+\" using apply_funtype\n    by simp\n  then show \"\\<zero> \\<lsq> abs(m)\" \n    using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1020
    },
    "914": {
        "type": "lemma",
        "text": "text\\<open>If an nonnegative integer is less or equal than another,\n  then so is its absolute value.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>m\"   \"m\\<lsq>k\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_L16"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L23: \n  assumes \"\\<zero>\\<lsq>m\"   \"m\\<lsq>k\"\n  shows \"abs(m) \\<lsq> k\"\n  ",
        "proof": "using assms Int_ZF_2_L16 by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1021
    },
    "915": {
        "type": "lemma",
        "text": "text\\<open>An integer can be written a a sum of a smaller integer and a natural \n  number.\\<close>\n",
        "assumes": "assumes A1: \"i \\<lsq> m\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "zadd_int0_right",
            "Int_ZF_2_L9",
            "zless_imp_succ_zadd_lemma"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L2: assumes A1: \"i \\<lsq> m\"\n  shows \"\\<exists>n\\<in>nat. m = i $+ $# n\"\n",
        "proof": "proof -\n  let ?n = \"0\"\n  { assume A2: \"i=m\"  \n    from A1 A2 have \"?n \\<in> nat\" \"m = i $+ $# ?n\"\n      using Int_ZF_2_L1A zadd_int0_right by auto\n    hence \"\\<exists>n\\<in>nat. m = i $+ $# n\" by blast }\n  moreover\n  { assume A3: \"i\\<noteq>m\" \n    with A1 have \"i $< m\" \"i\\<in>\\<int>\" \"m\\<in>\\<int>\"   \n      using Int_ZF_2_L9 Int_ZF_2_L1A by auto\n    then obtain k where D1: \"k\\<in>nat\" \"m = i $+ $# succ(k)\"\n      using zless_imp_succ_zadd_lemma by auto\n    let ?n = \"succ(k)\"\n    from D1 have \"?n\\<in>nat\" \"m = i $+ $# ?n\" by auto\n    hence \"\\<exists>n\\<in>nat. m = i $+ $# n\" by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1022
    },
    "916": {
        "type": "lemma",
        "text": "text\\<open>Induction for integers, the induction step.\\<close>\n",
        "assumes": "assumes A1: \"i\\<in>\\<int>\" \n  and A2: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m $+ ($# 1))\"\n  ",
        "using": [
            "Int_ZF_2_L12",
            "Int_ZF_2_L11"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L6: assumes A1: \"i\\<in>\\<int>\" \n  and A2: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m $+ ($# 1))\"\n  shows \"\\<forall>k\\<in>nat. Q(i $+ ($# k)) \\<longrightarrow> Q(i $+ ($# succ(k)))\"\n",
        "proof": "proof\n  fix k assume A3: \"k\\<in>nat\" show \"Q(i $+ $# k) \\<longrightarrow> Q(i $+ $# succ(k))\"\n  proof\n    assume A4: \"Q(i $+ $# k)\"\n    from A1 A3 have \"i\\<lsq> i $+ ($# k)\" using Int_ZF_2_L12\n      by simp\n    with A4 A2 have \"Q(i $+ ($# k) $+ ($# 1))\" by simp\n    then show \"Q(i $+ ($# succ(k)))\" using Int_ZF_2_L11 by simp\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1023
    },
    "917": {
        "type": "lemma",
        "text": "text\\<open>Induction on integer, implication between two forms of the induction\n  step.\\<close>\n",
        "assumes": "assumes \n  A1: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m\\<ra>\\<one>)\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_L8",
            "Int_ZF_1_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L7A: assumes \n  A1: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m\\<ra>\\<one>)\"\n  shows \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m $+ ($# 1))\"\n",
        "proof": "proof -\n  { fix m assume \"i\\<lsq>m \\<and> Q(m)\" \n    with A1 have T1: \"m\\<in>\\<int>\" \"Q(m\\<ra>\\<one>)\" using Int_ZF_2_L1A by auto\n    then have \"m\\<ra>\\<one> = m\\<ra>($# 1)\" using Int_ZF_1_L8 by simp\n    with T1 have \"Q(m $+ ($# 1))\" using Int_ZF_1_L2\n      by simp\n  } then show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1025
    },
    "918": {
        "type": "theorem",
        "text": "text\\<open>Induction on integers, version with ZF increment function.\\<close>\n",
        "assumes": "assumes A1: \"i\\<lsq>k\" and A2: \"Q(i)\"\n  and A3: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m\\<ra>\\<one>)\"\n  ",
        "using": [],
        "statement": "theorem (in int0) Induction_on_int: \n  assumes A1: \"i\\<lsq>k\" and A2: \"Q(i)\"\n  and A3: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m\\<ra>\\<one>)\"\n  shows \"Q(k)\"\n",
        "proof": "proof -\n  from A3 have \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m $+ ($# 1))\"\n    by (rule Int_ZF_3_L7A)\n  with A1 A2 show ?thesis by (rule Int_ZF_3_L7)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1026
    },
    "919": {
        "type": "lemma",
        "text": "text\\<open>Another form of induction on integers. This rewrites the basic theorem \n   \\<open>Int_ZF_3_L7\\<close> substituting $P(-k)$ for $Q(k)$.\\<close>\n",
        "assumes": "assumes A1: \"i\\<lsq>k\" and A2: \"P($-i)\"\n  and A3: \"\\<forall>m. i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n  ",
        "using": [],
        "statement": "lemma (in int0) Int_ZF_3_L7B: assumes A1: \"i\\<lsq>k\" and A2: \"P($-i)\"\n  and A3: \"\\<forall>m. i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n  shows \"P($-k)\"\n",
        "proof": "proof -\n  from A1 A2 A3 show \"P($-k)\" by (rule Int_ZF_3_L7)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1027
    },
    "920": {
        "type": "lemma",
        "text": "text\\<open>Another induction on integers. This rewrites Int\\_ZF\\_3\\_L7\n  substituting $-k$ for $k$ and $-i$ for $i$.\\<close>\n",
        "assumes": "assumes A1: \"k\\<lsq>i\" and A2: \"P(i)\" \n  and A3: \"\\<forall>m. $-i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n  ",
        "using": [
            "Int_ZF_2_L10",
            "Int_ZF_2_L1A",
            "zminus_zminus"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L8: assumes A1: \"k\\<lsq>i\" and A2: \"P(i)\" \n  and A3: \"\\<forall>m. $-i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n  shows \"P(k)\"\n",
        "proof": "proof -\n  from A1 have T1: \"$-i\\<lsq>$-k\" using Int_ZF_2_L10 by simp\n  from A1 A2 have T2: \"P($- $- i)\" using Int_ZF_2_L1A zminus_zminus\n    by simp\n  from T1 T2 A3 have \"P($-($-k))\" by (rule Int_ZF_3_L7)\n  with A1 show \"P(k)\" using Int_ZF_2_L1A zminus_zminus by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1028
    },
    "921": {
        "type": "lemma",
        "text": "text\\<open>An implication between two forms of induction steps.\\<close>\n",
        "assumes": "assumes A1: \"i\\<in>\\<int>\"\n  and A2: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n $+ $-($#1))\"    \n  ",
        "using": [
            "zminus_zminus",
            "zminus_zadd_distrib"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L9: assumes A1: \"i\\<in>\\<int>\"\n  and A2: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n $+ $-($#1))\"    \n  shows \"\\<forall>m. $-i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n",
        "proof": "proof\n  fix m show \"$-i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n  proof\n    assume A3: \"$- i \\<lsq> m \\<and> P($- m)\"\n    then have \"$- i \\<lsq> m\" by simp\n    then have \"$-m \\<lsq> $- ($- i)\" by (rule Int_ZF_2_L10)\n    with A1 A2 A3 show \"P($-(m $+ ($# 1)))\"\n      using zminus_zminus zminus_zadd_distrib by simp\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1029
    },
    "922": {
        "type": "lemma",
        "text": "text\\<open>Backwards induction on integers, version with higher-order decrement\n  function.\\<close>\n",
        "assumes": "assumes A1: \"k\\<lsq>i\" and A2: \"P(i)\" \n  and A3: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow>P(n $+ $-($#1)) \"\n  ",
        "using": [
            "Int_ZF_2_L1A"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L9A: assumes A1: \"k\\<lsq>i\" and A2: \"P(i)\" \n  and A3: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow>P(n $+ $-($#1)) \"\n  shows \"P(k)\"\n",
        "proof": "proof -\n  from A1 have T1: \"i\\<in>\\<int>\" using Int_ZF_2_L1A by simp\n  from T1 A3 have T2: \"\\<forall>m. $-i\\<lsq>m \\<and> P($-m) \\<longrightarrow> P($-(m $+ ($# 1)))\"\n    by (rule Int_ZF_3_L9)\n  from A1 A2 T2 show \"P(k)\" by (rule Int_ZF_3_L8)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1030
    },
    "923": {
        "type": "lemma",
        "text": "text\\<open>Induction on integers, implication between two forms of the induction\n  step.\\<close>\n",
        "assumes": "assumes\n  A1: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n\\<rs>\\<one>)\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_1_L8",
            "Int_ZF_1_L10"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L10: assumes\n  A1: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n\\<rs>\\<one>)\"\n  shows \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n $+ $-($#1))\"\n",
        "proof": "proof -\n  { fix n assume \"n\\<lsq>i \\<and> P(n)\"\n    with A1 have T1: \"n\\<in>\\<int>\" \"P(n\\<rs>\\<one>)\" using Int_ZF_2_L1A by auto\n    then have \"n\\<rs>\\<one> = n\\<rs>($# 1)\" using Int_ZF_1_L8 by simp\n    with T1 have \"P(n $+ $-($#1))\" using Int_ZF_1_L10 by simp\n  } then show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1031
    },
    "924": {
        "type": "theorem",
        "text": "text\\<open>Backwards induction on integers.\\<close>\n",
        "assumes": "assumes A1: \"k\\<lsq>i\" and A2: \"P(i)\" \n  and A3: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n\\<rs>\\<one>)\"\n  ",
        "using": [],
        "statement": "theorem (in int0) Back_induct_on_int: \n  assumes A1: \"k\\<lsq>i\" and A2: \"P(i)\" \n  and A3: \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n\\<rs>\\<one>)\"\n  shows \"P(k)\"\n",
        "proof": "proof -\n  from A3 have \"\\<forall>n. n\\<lsq>i \\<and> P(n) \\<longrightarrow> P(n $+ $-($#1))\"\n    by (rule Int_ZF_3_L10)\n  with A1 A2 show \"P(k)\" by (rule Int_ZF_3_L9A)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1032
    },
    "925": {
        "type": "lemma",
        "text": "text\\<open>A trivial calculation lemma that allows to subtract and add one.\\<close>\n",
        "assumes": "assumes \"m\\<in>int\" ",
        "using": [
            "assms",
            "eq_zdiff_iff"
        ],
        "statement": "lemma Int_ZF_4_L1A: \n  assumes \"m\\<in>int\" shows \"m $- $#1 $+ $#1 = m\"\n  ",
        "proof": "using assms eq_zdiff_iff by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1034
    },
    "926": {
        "type": "lemma",
        "text": "text\\<open>There are no integers between $k$ and $k+1$, another formulation.\\<close>\n",
        "assumes": "assumes A1: \"m \\<lsq> L\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_4_L1A",
            "Int_ZF_3_L2",
            "Int_ZF_4_L1",
            "Int_ZF_2_L9A",
            "Int_ZF_1_L8A",
            "Int_ZF_2_L9B"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L1B: assumes A1: \"m \\<lsq> L\"\n  shows \n  \"m = L \\<or> m\\<ra>\\<one> \\<lsq> L\"\n  \"m = L \\<or> m \\<lsq> L\\<rs>\\<one>\" \n",
        "proof": "proof -\n  let ?k = \"L $- $#1\"\n  from A1 have T1: \"m\\<in>\\<int>\"  \"L\\<in>\\<int>\"  \"L = ?k $+ $#1\" \n    using Int_ZF_2_L1A Int_ZF_4_L1A by auto\n  moreover from A1 obtain n where D1: \"n\\<in>nat\"  \"L = m $+ $# n\"\n    using Int_ZF_3_L2 by auto\n  ultimately have \"m = L \\<or> m \\<lsq> ?k\"\n    using Int_ZF_4_L1 by simp\n  with T1 show \"m = L   \\<or>  m\\<ra>\\<one> \\<lsq> L\"\n    using Int_ZF_2_L9A by auto\n  with T1 show \"m = L \\<or> m \\<lsq> L\\<rs>\\<one>\"\n    using Int_ZF_1_L8A Int_ZF_2_L9B by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1035
    },
    "927": {
        "type": "lemma",
        "text": "text\\<open>If $j\\in m..k+1$, then $j\\in m..n$ or $j=k+1$.\\<close>\n",
        "assumes": "assumes A1: \"k\\<in>\\<int>\"\n  and A2: \"j \\<in> m..(k $+ $#1)\"\n  ",
        "using": [
            "Order_ZF_2_L1A",
            "Int_ZF_2_L1A",
            "Int_ZF_3_L2",
            "Int_ZF_4_L1",
            "Order_ZF_2_L1B"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L2: assumes A1: \"k\\<in>\\<int>\"\n  and A2: \"j \\<in> m..(k $+ $#1)\"\n  shows \"j \\<in> m..k \\<or> j \\<in> {k $+ $#1}\"\n",
        "proof": "proof -\n  from A2 have T1: \"m\\<lsq>j\" \"j\\<lsq>(k $+ $#1)\" using Order_ZF_2_L1A \n    by auto\n  then have T2: \"m\\<in>\\<int>\" \"j\\<in>\\<int>\" using Int_ZF_2_L1A by auto \n  from T1 obtain n where \"n\\<in>nat\" \"k $+ $#1 = j $+ $# n\"\n    using Int_ZF_3_L2 by auto\n  with A1 T1 T2 have \"(m\\<lsq>j \\<and> j \\<lsq> k) \\<or> j \\<in> {k $+ $#1}\"\n    using Int_ZF_4_L1 by auto\n  then show ?thesis using Order_ZF_2_L1B by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1036
    },
    "928": {
        "type": "lemma",
        "text": "text\\<open>Extending an integer interval by one is the same as adding the new \n  endpoint.\\<close>\n",
        "assumes": "assumes A1: \"m\\<lsq> k\"\n  ",
        "using": [
            "Int_ZF_2_L1A",
            "Int_ZF_4_L2",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L3",
            "Int_ZF_2_L12",
            "Int_ZF_2_L6",
            "Order_ZF_2_L3",
            "Int_ZF_2_L12A",
            "int_ord_is_refl",
            "Order_ZF_2_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L3: assumes A1: \"m\\<lsq> k\"\n  shows \"m..(k $+ $#1) = m..k \\<union> {k $+ $#1}\"\n",
        "proof": "proof\n  from A1 have T1: \"m\\<in>\\<int>\" \"k\\<in>\\<int>\" using Int_ZF_2_L1A by auto\n  then show \"m .. (k $+ $# 1) \\<subseteq> m .. k \\<union> {k $+ $# 1}\"\n    using Int_ZF_4_L2 by auto\n  from T1 have \"m\\<lsq> m\" using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L3\n    by simp\n  with T1 A1 have \"m .. k \\<subseteq> m .. (k $+ $# 1)\"\n    using Int_ZF_2_L12 Int_ZF_2_L6 Order_ZF_2_L3 by simp\n  with T1 A1 show \"m..k \\<union> {k $+ $#1} \\<subseteq> m..(k $+ $#1)\"\n    using Int_ZF_2_L12A int_ord_is_refl Order_ZF_2_L2 by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1037
    },
    "929": {
        "type": "lemma",
        "text": "text\\<open>Integer intervals are finite - induction step.\\<close>\n",
        "assumes": "assumes A1: \"i\\<lsq>m\" and A2: \"i..m \\<in> Fin(\\<int>)\"\n  ",
        "using": [
            "assms",
            "Int_ZF_4_L3"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L4: \n  assumes A1: \"i\\<lsq>m\" and A2: \"i..m \\<in> Fin(\\<int>)\"\n  shows \"i..(m $+ $#1) \\<in> Fin(\\<int>)\"\n  ",
        "proof": "using assms Int_ZF_4_L3 by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1038
    },
    "930": {
        "type": "lemma",
        "text": "text\\<open>Integer intervals are finite.\\<close>\n",
        "assumes": "assumes A1: \"i\\<in>\\<int>\" \"k\\<in>\\<int>\"\n  ",
        "using": [
            "int_ord_is_refl",
            "Int_ZF_2_L4",
            "Order_ZF_2_L4",
            "Int_ZF_4_L4",
            "Int_ZF_2_L6",
            "Order_ZF_2_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L5: assumes A1: \"i\\<in>\\<int>\" \"k\\<in>\\<int>\"\n  shows \"i..k \\<in> Fin(\\<int>)\"\n",
        "proof": "proof -\n  { assume A2: \"i\\<lsq>k\"\n    moreover from A1 have \"i..i \\<in> Fin(\\<int>)\"\n      using int_ord_is_refl Int_ZF_2_L4 Order_ZF_2_L4 by simp\n    moreover from A2 have \n      \"\\<forall>m. i\\<lsq>m \\<and> i..m \\<in> Fin(\\<int>) \\<longrightarrow> i..(m $+ $#1) \\<in> Fin(\\<int>)\"\n      using Int_ZF_4_L4 by simp\n    ultimately have \"i..k \\<in> Fin(\\<int>)\" by (rule Int_ZF_3_L7) }\n  moreover \n  { assume \"\\<not> i \\<lsq> k\"\n    then have \"i..k \\<in> Fin(\\<int>)\" using Int_ZF_2_L6 Order_ZF_2_L5\n      by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1039
    },
    "931": {
        "type": "lemma",
        "text": "text\\<open>Bounded integer sets are finite.\\<close>\n",
        "assumes": "assumes A1: \"IsBounded(A,IntegerOrder)\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L4E",
            "Int_ZF_4_L5",
            "Int_ZF_1_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L6: assumes A1: \"IsBounded(A,IntegerOrder)\"\n  shows \"A \\<in> Fin(\\<int>)\"\n",
        "proof": "proof -\n  have T1: \"\\<forall>m \\<in> Nonnegative(\\<int>,IntegerAddition,IntegerOrder).\n    $#0..m \\<in> Fin(\\<int>)\" \n  proof\n    fix m assume \"m \\<in> Nonnegative(\\<int>,IntegerAddition,IntegerOrder)\"\n    then have \"m\\<in>\\<int>\" using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L4E\n      by auto\n    then show \"$#0..m \\<in> Fin(\\<int>)\" using Int_ZF_4_L5 by simp\n  qed\n  have \"group3(\\<int>,IntegerAddition,IntegerOrder)\"\n    using Int_ZF_2_T1 by simp\n  moreover from T1 have \"\\<forall>m \\<in> Nonnegative(\\<int>,IntegerAddition,IntegerOrder).\n    Interval(IntegerOrder,TheNeutralElement(\\<int>,IntegerAddition),m) \n    \\<in> Fin(\\<int>)\" using Int_ZF_1_L8 by simp\n  moreover note A1\n  ultimately show \"A \\<in> Fin(\\<int>)\" by (rule group3.OrderedGroup_ZF_2_T1)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1040
    },
    "932": {
        "type": "theorem",
        "text": "text\\<open>A subset of integers is bounded iff it is finite.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_4_L6",
            "Int_ZF_2_T1",
            "group3.ord_group_fin_bounded"
        ],
        "statement": "theorem (in int0) Int_bounded_iff_fin: \n  shows \"IsBounded(A,IntegerOrder)\\<longleftrightarrow> A\\<in>Fin(\\<int>)\"\n  ",
        "proof": "using Int_ZF_4_L6 Int_ZF_2_T1 group3.ord_group_fin_bounded \n  by blast\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1041
    },
    "933": {
        "type": "lemma",
        "text": "text\\<open>The image of an interval by any integer function is\n  finite, hence bounded.\\<close>\n",
        "assumes": "assumes A1: \"i\\<in>\\<int>\"  \"k\\<in>\\<int>\" and A2: \"f:\\<int>\\<rightarrow>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_4_L5",
            "Finite1_L6A",
            "Int_bounded_iff_fin"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L8: \n  assumes A1: \"i\\<in>\\<int>\"  \"k\\<in>\\<int>\" and A2: \"f:\\<int>\\<rightarrow>\\<int>\"\n  shows \n  \"f``(i..k) \\<in> Fin(\\<int>)\"\n  \"IsBounded(f``(i..k),IntegerOrder)\"\n  ",
        "proof": "using assms Int_ZF_4_L5 Finite1_L6A Int_bounded_iff_fin\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1042
    },
    "934": {
        "type": "lemma",
        "text": "text\\<open>If for every integer we can find one in $A$ that is greater or equal,\n  then $A$ is is not bounded above, hence infinite.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>m\\<in>\\<int>. \\<exists>k\\<in>A. m\\<lsq>k\"\n  ",
        "using": [
            "Int_ZF_1_L8A",
            "int_zero_not_one",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_2_L2A"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L9: assumes A1: \"\\<forall>m\\<in>\\<int>. \\<exists>k\\<in>A. m\\<lsq>k\"\n  shows \n  \"\\<not>IsBoundedAbove(A,IntegerOrder)\"\n  \"A \\<notin> Fin(\\<int>)\"\n",
        "proof": "proof -\n  have \"\\<int> \\<noteq> {\\<zero>}\"\n    using Int_ZF_1_L8A int_zero_not_one by blast\n  with A1 show \n    \"\\<not>IsBoundedAbove(A,IntegerOrder)\"\n    \"A \\<notin> Fin(\\<int>)\"\n    using Int_ZF_2_T1 group3.OrderedGroup_ZF_2_L2A\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1043
    },
    "935": {
        "type": "definition",
        "text": "text\\<open>The first thing that mathematicians typically do is to define\n  notions. In Isar this is done with the \\<open>definition\\<close> keyword.\n  In our case we define a notion of two \n  sets being disjoint. We will use the infix notation, i.e. the string\n  \\<open>{is disjoint with}\\<close> put between two sets to denote our notion \n  of disjointness. \n  The left side of the \\<open>\\<equiv>\\<close> symbol is the notion \n  being defined, the right side says how we define it. In Isabelle/ZF \\<open>0\\<close>\n  is used to denote both zero (of natural numbers) and the empty set, which is\n  not surprising as those two things are the same in set theory.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  AreDisjoint (infix \"{is disjoint with}\" 90) where\n  \"A {is disjoint with} B \\<equiv> A \\<inter> B = 0\"\n",
        "proof": "",
        "imports": [
            "ZF.equalities"
        ],
        "source": "IsarMathLib/Introduction.thy",
        "id": 1044
    },
    "936": {
        "type": "theorem",
        "text": "text\\<open>We are ready to prove a theorem. Here we show that the relation\n  of being disjoint is symmetric. We start with one of the keywords\n  ''theorem'', ''lemma'' or ''corollary''. In Isar they are synonymous.\n  Then we provide a name for the theorem. In standard mathematics \n  theorems are numbered. In Isar we can do that too, but it is\n  considered better to give theorems meaningful names.\n  After the ''shows'' keyword we give the statement to show. The \n  \\<open>\\<longleftrightarrow>\\<close> symbol denotes the equivalence in Isabelle/ZF. Here\n  we want to show that \"A is disjoint with B iff and only if B is disjoint \n  with A\". To prove this fact we show two implications - the first one that \n  \\<open>A {is disjoint with} B\\<close> implies \\<open>B {is disjoint with} A\\<close>\n  and then the converse one. Each of these implications is formulated\n  as a statement to be proved and then proved in \n  a subproof like a mini-theorem.\n  Each subproof uses a proof block to show the implication. Proof blocks\n  are delimited with curly brackets in Isar. \n  Proof block is one of the constructs that\n  does not exist in informal mathematics, so it may be confusing. \n  When reading a proof containing a proof block I suggest to focus first \n  on what is that we are proving in it. This can be done by looking\n  at the first line or two of the block and then at the last statement. \n  In our case the block starts with \n  \"assume \\<open>A {is disjoint with} B\\<close> and the last statement\n  is \"then have \\<open>B {is disjoint with} A\\<close>\". It is a typical pattern \n  when someone needs to prove an implication: one assumes the antecedent\n  and then shows that the consequent follows from this assumption.\n  Implications are denoted with the \n  \\<open>\\<longrightarrow>\\<close> symbol in Isabelle. \n  After we prove both implications we collect them \n  using the ''moreover'' construct. The keyword ''ultimately''\n  indicates that what follows is the conclusion of the statements \n  collected with ''moreover''. The ''show'' keyword is like ''have'',\n  except that it indicates that we have arrived at the claim of the \n  theorem (or a subproof).\\<close>\n",
        "assumes": "",
        "using": [
            "AreDisjoint_def"
        ],
        "statement": "theorem disjointness_symmetric: \n  shows \"A {is disjoint with} B \\<longleftrightarrow> B {is disjoint with} A\"\n",
        "proof": "proof -\n  have \"A {is disjoint with} B \\<longrightarrow> B {is disjoint with} A\"\n  proof -\n    { assume \"A {is disjoint with} B\"\n      then have \"A \\<inter> B = 0\" using AreDisjoint_def by simp\n      hence \"B \\<inter> A = 0\" by auto\n      then have  \"B {is disjoint with} A\"\n        using AreDisjoint_def by simp\n    } thus ?thesis by simp\n  qed\n  moreover have \"B {is disjoint with} A \\<longrightarrow> A {is disjoint with} B\"\n  proof -\n    { assume \"B {is disjoint with} A\"\n      then have \"B \\<inter> A = 0\" using AreDisjoint_def by simp\n      hence \"A \\<inter> B = 0\" by auto\n      then have  \"A {is disjoint with} B\"\n        using AreDisjoint_def by simp\n    } thus ?thesis by simp\n  qed\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "ZF.equalities"
        ],
        "source": "IsarMathLib/Introduction.thy",
        "id": 1045
    },
    "937": {
        "type": "definition",
        "text": "text\\<open> A partially ordered $(L,r)$ set is a join-semilattice if each two-element subset of $L$\n  has a supremum (i.e. the least upper bound). \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsJoinSemilattice(L,r) \\<equiv> \n    r\\<subseteq>L\\<times>L \\<and> IsPartOrder(L,r) \\<and> (\\<forall>x\\<in>L. \\<forall>y\\<in>L. HasAsupremum(r,{x,y}))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1046
    },
    "938": {
        "type": "definition",
        "text": "text\\<open> A partially ordered $(L,r)$ set is a lattice if it is both join and meet-semilattice, i.e. if \n  every two element set has a supremum (least upper bound) and infimum (greatest lower bound). \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsAlattice (infixl \"{is a lattice on}\" 90) where\n  \"r {is a lattice on} L \\<equiv> IsJoinSemilattice(L,r) \\<and> IsMeetSemilattice(L,r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1048
    },
    "939": {
        "type": "definition",
        "text": "text\\<open> Join is a binary operation whose value on a pair $\\langle x,y\\rangle$\n  is defined as the supremum of the set $\\{ x,y\\}$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Join(L,r) \\<equiv> {\\<langle>p,Supremum(r,{fst(p),snd(p)})\\<rangle> . p \\<in> L\\<times>L}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1049
    },
    "940": {
        "type": "definition",
        "text": "text\\<open> Meet is a binary operation whose value on a pair $\\langle x,y\\rangle$\n  is defined as the infimum of the set $\\{ x,y\\}$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Meet(L,r) \\<equiv> {\\<langle>p,Infimum(r,{fst(p),snd(p)})\\<rangle> . p \\<in> L\\<times>L}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1050
    },
    "941": {
        "type": "lemma",
        "text": "text\\<open>Linear order is a lattice.\\<close>\n",
        "assumes": "assumes \"r\\<subseteq>L\\<times>L\" and \"IsLinOrder(L,r)\"\n  ",
        "using": [
            "Order_ZF_1_L2",
            "inf_sup_two_el(1)",
            "inf_sup_two_el(3)"
        ],
        "statement": "lemma lin_is_latt: assumes \"r\\<subseteq>L\\<times>L\" and \"IsLinOrder(L,r)\"\n  shows \"r {is a lattice on} L\"\n",
        "proof": "proof -\n  from assms(2) have \"IsPartOrder(L,r)\" using Order_ZF_1_L2 by simp\n  with assms have \"IsMeetSemilattice(L,r)\" unfolding IsLinOrder_def IsMeetSemilattice_def\n    using inf_sup_two_el(1) by auto\n  moreover from assms \\<open>IsPartOrder(L,r)\\<close> have \"IsJoinSemilattice(L,r)\"\n    unfolding IsLinOrder_def IsJoinSemilattice_def using inf_sup_two_el(3) by auto\n  ultimately show ?thesis unfolding IsAlattice_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1051
    },
    "942": {
        "type": "lemma",
        "text": "text\\<open> In a join-semilattice join is indeed a binary operation. \\<close>\n",
        "assumes": "assumes \"IsJoinSemilattice(L,r)\" \n  ",
        "using": [
            "sup_in_space",
            "ZF_fun_from_total"
        ],
        "statement": "lemma join_is_binop: assumes \"IsJoinSemilattice(L,r)\" \n  shows \"Join(L,r) :  L\\<times>L \\<rightarrow> L\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>p \\<in> L\\<times>L. Supremum(r,{fst(p),snd(p)}) \\<in> L\"\n    unfolding IsJoinSemilattice_def IsPartOrder_def HasAsupremum_def using sup_in_space \n    by auto\n  then show ?thesis unfolding Join_def using ZF_fun_from_total by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1052
    },
    "943": {
        "type": "lemma",
        "text": "text\\<open> The value of \\<open>Join(L,r)\\<close> on a pair $\\langle x,y\\rangle$ is the supremum\n  of the set $\\{ x,y\\}$, hence its is greater or equal than both. \\<close>\n",
        "assumes": "assumes \"IsJoinSemilattice(L,r)\" \"x\\<in>L\" \"y\\<in>L\"\n  defines \"j \\<equiv> Join(L,r)`\\<langle>x,y\\<rangle>\"\n  ",
        "using": [
            "join_is_binop",
            "ZF_fun_from_tot_val",
            "apply_funtype",
            "sup_in_space(2)"
        ],
        "statement": "lemma join_val: \n  assumes \"IsJoinSemilattice(L,r)\" \"x\\<in>L\" \"y\\<in>L\"\n  defines \"j \\<equiv> Join(L,r)`\\<langle>x,y\\<rangle>\"\n  shows \"j\\<in>L\" \"j = Supremum(r,{x,y})\" \"\\<langle>x,j\\<rangle> \\<in> r\" \"\\<langle>y,j\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from assms(1) have \"Join(L,r) :  L\\<times>L \\<rightarrow> L\" using join_is_binop by simp\n  with assms(2,3,4) show \"j = Supremum(r,{x,y})\" unfolding Join_def using ZF_fun_from_tot_val \n    by auto\n  from assms(2,3,4) \\<open>Join(L,r) : L\\<times>L \\<rightarrow> L\\<close>  show \"j\\<in>L\" using apply_funtype by simp\n  from assms(1,2,3) have \"r \\<subseteq> L\\<times>L\" \"antisym(r)\" \"HasAminimum(r,\\<Inter>z\\<in>{x,y}. r``{z})\"\n    unfolding IsJoinSemilattice_def IsPartOrder_def HasAsupremum_def by auto\n  with \\<open>j = Supremum(r,{x,y})\\<close> show \"\\<langle>x,j\\<rangle> \\<in> r\" and \"\\<langle>y,j\\<rangle> \\<in> r\"\n    using sup_in_space(2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1053
    },
    "944": {
        "type": "lemma",
        "text": "text\\<open> In a meet-semilattice meet is indeed a binary operation. \\<close>\n",
        "assumes": "assumes \"IsMeetSemilattice(L,r)\" \n  ",
        "using": [
            "inf_in_space",
            "ZF_fun_from_total"
        ],
        "statement": "lemma meet_is_binop: assumes \"IsMeetSemilattice(L,r)\" \n  shows \"Meet(L,r) :  L\\<times>L \\<rightarrow> L\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>p \\<in> L\\<times>L. Infimum(r,{fst(p),snd(p)}) \\<in> L\"\n    unfolding IsMeetSemilattice_def IsPartOrder_def HasAnInfimum_def using inf_in_space \n    by auto\n  then show ?thesis unfolding Meet_def using ZF_fun_from_total by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1054
    },
    "945": {
        "type": "lemma",
        "text": "text\\<open> The value of \\<open>Meet(L,r)\\<close> on a pair $\\langle x,y\\rangle$ is the infimum\n  of the set $\\{ x,y\\}$, hence is less or equal than both. \\<close>\n",
        "assumes": "assumes \"IsMeetSemilattice(L,r)\" \"x\\<in>L\" \"y\\<in>L\"\n  defines \"m \\<equiv> Meet(L,r)`\\<langle>x,y\\<rangle>\"\n  ",
        "using": [
            "meet_is_binop",
            "ZF_fun_from_tot_val",
            "apply_funtype",
            "inf_in_space(2)"
        ],
        "statement": "lemma meet_val: \n  assumes \"IsMeetSemilattice(L,r)\" \"x\\<in>L\" \"y\\<in>L\"\n  defines \"m \\<equiv> Meet(L,r)`\\<langle>x,y\\<rangle>\"\n  shows \"m\\<in>L\" \"m = Infimum(r,{x,y})\" \"\\<langle>m,x\\<rangle> \\<in> r\" \"\\<langle>m,y\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from assms(1) have \"Meet(L,r) : L\\<times>L \\<rightarrow> L\" using meet_is_binop by simp\n  with assms(2,3,4) show  \"m = Infimum(r,{x,y})\" unfolding Meet_def using ZF_fun_from_tot_val \n    by auto\n  from assms(2,3,4) \\<open>Meet(L,r) : L\\<times>L \\<rightarrow> L\\<close>  show \"m\\<in>L\" using apply_funtype by simp\n  from assms(1,2,3) have \"r \\<subseteq> L\\<times>L\" \"antisym(r)\" \"HasAmaximum(r,\\<Inter>z\\<in>{x,y}. r-``{z})\"\n    unfolding IsMeetSemilattice_def IsPartOrder_def HasAnInfimum_def by auto\n  with \\<open>m = Infimum(r,{x,y})\\<close> show \"\\<langle>m,x\\<rangle> \\<in> r\" and \"\\<langle>m,y\\<rangle> \\<in> r\"\n    using inf_in_space(2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1055
    },
    "946": {
        "type": "lemma",
        "text": "text\\<open>In a (nonempty) meet semi-lattice the relation down-directs the set. \\<close>\n",
        "assumes": "assumes \"IsMeetSemilattice(L,r)\" \"L\\<noteq>0\"\n  ",
        "using": [
            "meet_val"
        ],
        "statement": "lemma meet_down_directs: assumes \"IsMeetSemilattice(L,r)\" \"L\\<noteq>0\"\n  shows \"r {down-directs} L\"\n",
        "proof": "proof -\n  { fix x y assume \"x\\<in>L\" \"y\\<in>L\"\n    let ?m = \"Meet(L,r)`\\<langle>x,y\\<rangle>\"\n    from assms(1) \\<open>x\\<in>L\\<close> \\<open>y\\<in>L\\<close> have  \"?m\\<in>L\" \"\\<langle>?m,x\\<rangle> \\<in> r\" \"\\<langle>?m,y\\<rangle> \\<in> r\"\n      using meet_val by auto\n  } hence \"\\<forall>x\\<in>L. \\<forall>y\\<in>L. \\<exists>m\\<in>L. \\<langle>m,x\\<rangle> \\<in> r \\<and>\\<langle>m,y\\<rangle> \\<in> r\"\n    by blast\n  with assms(2) show ?thesis unfolding DownDirects_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1056
    },
    "947": {
        "type": "lemma",
        "text": "text\\<open>In a (nonempty) join semi-lattice the relation up-directs the set. \\<close>\n",
        "assumes": "assumes \"IsJoinSemilattice(L,r)\" \"L\\<noteq>0\"\n  ",
        "using": [
            "join_val"
        ],
        "statement": "lemma join_up_directs: assumes \"IsJoinSemilattice(L,r)\" \"L\\<noteq>0\"\n  shows \"r {up-directs} L\"\n",
        "proof": "proof -\n  { fix x y assume \"x\\<in>L\" \"y\\<in>L\"\n    let ?m = \"Join(L,r)`\\<langle>x,y\\<rangle>\"\n    from assms(1) \\<open>x\\<in>L\\<close> \\<open>y\\<in>L\\<close> have  \"?m\\<in>L\" \"\\<langle>x,?m\\<rangle> \\<in> r\" \"\\<langle>y,?m\\<rangle> \\<in> r\"\n      using join_val by auto\n  } hence \"\\<forall>x\\<in>L. \\<forall>y\\<in>L. \\<exists>m\\<in>L. \\<langle>x,m\\<rangle> \\<in> r \\<and>\\<langle>y,m\\<rangle> \\<in> r\"\n    by blast\n  with assms(2) show ?thesis unfolding UpDirects_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1057
    },
    "948": {
        "type": "lemma",
        "text": "text\\<open> Join of the elements of the lattice is in the lattice. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \n  ",
        "using": [
            "join_is_binop",
            "apply_funtype",
            "join_val(2)"
        ],
        "statement": "lemma (in join_semilatt) join_props: assumes \"x\\<in>L\" \"y\\<in>L\" \n  shows \"x\\<squnion>y \\<in> L\" and \"x\\<squnion>y = sup {x,y}\"\n",
        "proof": "proof -\n  from joinLatt assms have \"Join(L,r)`\\<langle>x,y\\<rangle> \\<in> L\" using join_is_binop apply_funtype \n    by blast\n  thus \"x\\<squnion>y \\<in> L\" by simp\n  from joinLatt assms have \"Join(L,r)`\\<langle>x,y\\<rangle> = Supremum(r,{x,y})\" using join_val(2) \n    by simp\n  thus \"x\\<squnion>y = sup {x,y}\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1058
    },
    "949": {
        "type": "lemma",
        "text": "text\\<open> Join is associative. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\"\n  ",
        "using": [
            "join_val(2)",
            "join_props",
            "sup_inf_singl(2)",
            "sup_inf_singl(1)",
            "sup_in_space(1)"
        ],
        "statement": "lemma (in join_semilatt) join_assoc: assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\"\n  shows \"x\\<squnion>(y\\<squnion>z) = x\\<squnion>y\\<squnion>z\"\n",
        "proof": "proof -\n  from joinLatt assms(2,3) have \"x\\<squnion>(y\\<squnion>z) = x\\<squnion>(sup {y,z})\" using join_val(2) by simp\n  also from assms joinLatt have \"... = sup {sup {x}, sup {y,z}}\"\n    unfolding IsJoinSemilattice_def IsPartOrder_def using join_props sup_inf_singl(2) \n    by auto\n  also have \"... = sup {x,y,z}\"\n  proof -\n    let ?\\<T> = \"{{x},{y,z}}\"\n    from joinLatt have \"r \\<subseteq> L\\<times>L\" \"antisym(r)\" \"trans(r)\" \n      unfolding IsJoinSemilattice_def IsPartOrder_def by auto\n    moreover from joinLatt assms have \"\\<forall>T\\<in>?\\<T>. HasAsupremum(r,T)\"\n      unfolding IsJoinSemilattice_def IsPartOrder_def using sup_inf_singl(1) by blast\n    moreover from joinLatt assms have \"HasAsupremum(r,{Supremum(r,T).T\\<in>?\\<T>})\"\n      unfolding IsJoinSemilattice_def IsPartOrder_def  HasAsupremum_def \n      using sup_in_space(1) sup_inf_singl(2) by auto\n    ultimately have \"Supremum(r,{Supremum(r,T).T\\<in>?\\<T>}) = Supremum(r,\\<Union>?\\<T>)\" by (rule sup_sup)\n    moreover have \"{Supremum(r,T).T\\<in>?\\<T>} = {sup {x}, sup {y,z}}\" and \"\\<Union>?\\<T> = {x,y,z}\"\n      by auto\n    ultimately show \"(sup {sup {x}, sup {y,z}}) =  sup {x,y,z}\" by simp\n  qed\n  also have \"... = sup {sup {x,y}, sup {z}}\"\n  proof -\n    let ?\\<T> = \"{{x,y},{z}}\"\n    from joinLatt have \"r \\<subseteq> L\\<times>L\" \"antisym(r)\" \"trans(r)\" \n      unfolding IsJoinSemilattice_def IsPartOrder_def by auto\n    moreover from joinLatt assms have \"\\<forall>T\\<in>?\\<T>. HasAsupremum(r,T)\"\n      unfolding IsJoinSemilattice_def IsPartOrder_def using sup_inf_singl(1) by blast\n    moreover from joinLatt assms have \"HasAsupremum(r,{Supremum(r,T).T\\<in>?\\<T>})\"\n      unfolding IsJoinSemilattice_def IsPartOrder_def  HasAsupremum_def \n      using sup_in_space(1) sup_inf_singl(2) by auto\n    ultimately have \"Supremum(r,{Supremum(r,T).T\\<in>?\\<T>}) = Supremum(r,\\<Union>?\\<T>)\" by (rule sup_sup)\n    moreover have \"{Supremum(r,T).T\\<in>?\\<T>} = {sup {x,y}, sup {z}}\" and \"\\<Union>?\\<T> = {x,y,z}\"\n      by auto\n    ultimately show \"(sup {x,y,z}) = sup {sup {x,y}, sup {z}}\" by auto\n  qed\n  also from assms joinLatt have \"... = sup {sup {x,y}, z}\"\n    unfolding IsJoinSemilattice_def IsPartOrder_def using join_props sup_inf_singl(2) \n    by auto\n  also from assms joinLatt have \"... = (sup {x,y}) \\<squnion> z \"\n    unfolding IsJoinSemilattice_def IsPartOrder_def using join_props by auto\n  also from joinLatt assms(1,2) have \"... = x\\<squnion>y\\<squnion>z\" using join_val(2) by simp\n  finally show \"x\\<squnion>(y\\<squnion>z) = x\\<squnion>y\\<squnion>z\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1059
    },
    "950": {
        "type": "lemma",
        "text": "text\\<open> Meet of the elements of the lattice is in the lattice. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \n  ",
        "using": [
            "meet_is_binop",
            "apply_funtype",
            "meet_val(2)"
        ],
        "statement": "lemma (in meet_semilatt) meet_props: assumes \"x\\<in>L\" \"y\\<in>L\" \n  shows \"x\\<sqinter>y \\<in> L\" and \"x\\<sqinter>y = inf {x,y}\"\n",
        "proof": "proof -\n  from meetLatt assms have \"Meet(L,r)`\\<langle>x,y\\<rangle> \\<in> L\" using meet_is_binop apply_funtype \n    by blast\n  thus \"x\\<sqinter>y \\<in> L\" by simp\n  from meetLatt assms have \"Meet(L,r)`\\<langle>x,y\\<rangle> = Infimum(r,{x,y})\" using meet_val(2) by blast\n  thus \"x\\<sqinter>y = inf {x,y}\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1061
    },
    "951": {
        "type": "lemma",
        "text": "text\\<open> Meet is associative. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\"\n  ",
        "using": [
            "meet_val",
            "meet_props",
            "sup_inf_singl(4)",
            "sup_inf_singl(3)",
            "inf_in_space(1)"
        ],
        "statement": "lemma (in meet_semilatt) meet_assoc: assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\"\n  shows \"x\\<sqinter>(y\\<sqinter>z) = x\\<sqinter>y\\<sqinter>z\"\n",
        "proof": "proof -\n  from meetLatt assms(2,3) have \"x\\<sqinter>(y\\<sqinter>z) = x\\<sqinter>(inf {y,z})\" using meet_val by simp\n  also from assms meetLatt have \"... = inf {inf {x}, inf {y,z}}\"\n    unfolding IsMeetSemilattice_def IsPartOrder_def using meet_props sup_inf_singl(4) \n    by auto\n  also have \"... = inf {x,y,z}\"\n  proof -\n    let ?\\<T> = \"{{x},{y,z}}\"\n    from meetLatt have \"r \\<subseteq> L\\<times>L\" \"antisym(r)\" \"trans(r)\" \n      unfolding IsMeetSemilattice_def IsPartOrder_def by auto\n    moreover from meetLatt assms have \"\\<forall>T\\<in>?\\<T>. HasAnInfimum(r,T)\"\n      unfolding IsMeetSemilattice_def IsPartOrder_def using sup_inf_singl(3) by blast\n    moreover from meetLatt assms have \"HasAnInfimum(r,{Infimum(r,T).T\\<in>?\\<T>})\"\n      unfolding IsMeetSemilattice_def IsPartOrder_def  HasAnInfimum_def \n      using inf_in_space(1) sup_inf_singl(4) by auto\n    ultimately have \"Infimum(r,{Infimum(r,T).T\\<in>?\\<T>}) = Infimum(r,\\<Union>?\\<T>)\" by (rule inf_inf)\n    moreover have \"{Infimum(r,T).T\\<in>?\\<T>} = {inf {x}, inf {y,z}}\" and \"\\<Union>?\\<T> = {x,y,z}\"\n      by auto\n    ultimately show \"(inf {inf {x}, inf {y,z}}) =  inf {x,y,z}\" by simp\n  qed\n  also have \"... = inf {inf {x,y}, inf {z}}\"\n  proof -\n    let ?\\<T> = \"{{x,y},{z}}\"\n    from meetLatt have \"r \\<subseteq> L\\<times>L\" \"antisym(r)\" \"trans(r)\" \n      unfolding IsMeetSemilattice_def IsPartOrder_def by auto\n    moreover from meetLatt assms have \"\\<forall>T\\<in>?\\<T>. HasAnInfimum(r,T)\"\n      unfolding IsMeetSemilattice_def IsPartOrder_def using sup_inf_singl(3) by blast\n    moreover from meetLatt assms have \"HasAnInfimum(r,{Infimum(r,T).T\\<in>?\\<T>})\"\n      unfolding IsMeetSemilattice_def IsPartOrder_def HasAnInfimum_def \n      using inf_in_space(1) sup_inf_singl(4) by auto\n    ultimately have \"Infimum(r,{Infimum(r,T).T\\<in>?\\<T>}) = Infimum(r,\\<Union>?\\<T>)\" by (rule inf_inf)\n    moreover have \"{Infimum(r,T).T\\<in>?\\<T>} = {inf {x,y}, inf {z}}\" and \"\\<Union>?\\<T> = {x,y,z}\"\n      by auto\n    ultimately show \"(inf {x,y,z}) = inf {inf {x,y}, inf {z}}\" by auto\n  qed\n  also from assms meetLatt have \"... = inf {inf {x,y}, z}\"\n    unfolding IsMeetSemilattice_def IsPartOrder_def using meet_props sup_inf_singl(4) \n    by auto\n  also from assms meetLatt have \"... = (inf {x,y}) \\<sqinter> z \"\n    unfolding IsMeetSemilattice_def IsPartOrder_def using meet_props by auto\n  also from meetLatt assms(1,2) have \"... = x\\<sqinter>y\\<sqinter>z\" using meet_val by simp\n  finally show \"x\\<sqinter>(y\\<sqinter>z) = x\\<sqinter>y\\<sqinter>z\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1062
    },
    "952": {
        "type": "lemma",
        "text": "text\\<open> Meet is idempotent. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" ",
        "using": [
            "meetLatt",
            "assms",
            "meet_val",
            "IsMeetSemilattice_def",
            "IsPartOrder_def",
            "sup_inf_singl(4)"
        ],
        "statement": "lemma (in meet_semilatt) meet_idempotent: assumes \"x\\<in>L\" shows \"x\\<sqinter>x = x\" \n  ",
        "proof": "using meetLatt assms meet_val IsMeetSemilattice_def IsPartOrder_def sup_inf_singl(4)\n  by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1063
    },
    "953": {
        "type": "definition",
        "text": "text\\<open> A loop is a quasigroup with an identity elemen. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \"IsAloop(G,A) \\<equiv> IsAquasigroup(G,A) \\<and> (\\<exists>e\\<in>G. \\<forall>x\\<in>G. A`\\<langle>e,x\\<rangle> = x \\<and> A`\\<langle>x,e\\<rangle> = x)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1064
    },
    "954": {
        "type": "definition",
        "text": "text\\<open> The neutral element for a binary operation $A:G\\times G \\rightarrow G $ is defined\n  as the only element $e$ of $G$ such that $A\\langle x,e\\rangle = x$ and $A\\langle e,x\\rangle = x$\n  for all $x\\in G$. Note that although the loop definition guarantees the existence of (some) \n  such element(s) at this point we do not know if this element is unique. \n  We can define this notion   h ere but it will become usable only after we prove uniqueness. \\<close> \n",
        "assumes": "",
        "using": [],
        "statement": "definition \n \"TheNeutralElement(G,f) \\<equiv> \n  ( THE e. e\\<in>G \\<and> (\\<forall> g\\<in>G. f`\\<langle>e,g\\<rangle> = g \\<and> f`\\<langle>g,e\\<rangle> = g))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1065
    },
    "955": {
        "type": "lemma",
        "text": "text\\<open> In the loop context the pair \\<open>(G,A)\\<close> forms a loop. \\<close>\n",
        "assumes": "",
        "using": [
            "ex_ident",
            "qgroupassum"
        ],
        "statement": "lemma (in loop0) is_loop: shows \"IsAloop(G,A)\"\n  unfolding IsAloop_def ",
        "proof": "using ex_ident qgroupassum by simp\n",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1066
    },
    "956": {
        "type": "lemma",
        "text": "text\\<open>If we know that a pair \\<open>(G,A)\\<close> forms a loop then the assumptions of the \\<open>loop0\\<close> locale hold. \\<close>\n",
        "assumes": "assumes \"IsAloop(G,A)\" ",
        "using": [
            "assms",
            "IsAloop_def",
            "loop0_axioms_def",
            "quasigroup0_def",
            "loop0_def"
        ],
        "statement": "lemma loop_loop0_valid: assumes \"IsAloop(G,A)\" shows \"loop0(G,A)\"\n  ",
        "proof": "using assms unfolding IsAloop_def loop0_axioms_def quasigroup0_def loop0_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1067
    },
    "957": {
        "type": "lemma",
        "text": "text\\<open>The neutral element is unique in the loop. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in loop0) neut_uniq_loop: shows \n  \"\\<exists>!e. e\\<in>G \\<and> (\\<forall>x\\<in>G. e\\<cdot>x = x \\<and> x\\<cdot>e = x)\"\n",
        "proof": "proof\n  from ex_ident show \"\\<exists>e. e \\<in> G \\<and> (\\<forall>x\\<in>G. e \\<cdot> x = x \\<and> x \\<cdot> e = x)\" by auto\nnext\n  fix e y \n  assume \"e \\<in> G \\<and> (\\<forall>x\\<in>G. e \\<cdot> x = x \\<and> x \\<cdot> e = x)\"  \"y \\<in> G \\<and> (\\<forall>x\\<in>G. y \\<cdot> x = x \\<and> x \\<cdot> y = x)\"\n  then have \"e\\<cdot>y =y\" and \"e\\<cdot>y = e\" by auto\n  thus \"e=y\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1068
    },
    "958": {
        "type": "lemma",
        "text": "text\\<open> The neutral element as defined in the \\<open>loop0\\<close> locale is indeed neutral. \\<close>\n",
        "assumes": "",
        "using": [
            "neut_uniq_loop",
            "theI"
        ],
        "statement": "lemma (in loop0) neut_props_loop: shows \"\\<one>\\<in>G\" and \"\\<forall>x\\<in>G. \\<one>\\<cdot>x =x \\<and> x\\<cdot>\\<one> = x\"\n",
        "proof": "proof -  \n  let ?n = \"THE e. e\\<in>G \\<and> (\\<forall>x\\<in>G. e\\<cdot>x = x \\<and> x\\<cdot>e = x)\"\n  have \"\\<one> = TheNeutralElement(G,A)\" by simp\n  then have \"\\<one> = ?n\" unfolding TheNeutralElement_def by simp\n  moreover have \"?n\\<in>G \\<and> (\\<forall>x\\<in>G. ?n\\<cdot>x = x \\<and> x\\<cdot>?n = x)\" using neut_uniq_loop theI\n    by simp\n  ultimately show \"\\<one>\\<in>G\" and \"\\<forall>x\\<in>G. \\<one>\\<cdot>x = x \\<and> x\\<cdot>\\<one> = x\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1069
    },
    "959": {
        "type": "definition",
        "text": "text\\<open>Every element of a loop has unique left and right inverse (which need not be the same). \n  Here we define the left inverse as a function on $G$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"LeftInv(G,A) \\<equiv> {\\<langle>x,\\<Union>{y\\<in>G. A`\\<langle>y,x\\<rangle> = TheNeutralElement(G,A)}\\<rangle>. x\\<in>G}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1070
    },
    "960": {
        "type": "definition",
        "text": "text\\<open>Definition of the right inverse as a function on $G$: \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"RightInv(G,A) \\<equiv> {\\<langle>x,\\<Union>{y\\<in>G. A`\\<langle>x,y\\<rangle> = TheNeutralElement(G,A)}\\<rangle>. x\\<in>G}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1071
    },
    "961": {
        "type": "lemma",
        "text": "text\\<open>Right and left inverses have desired properties.\\<close>\n",
        "assumes": "assumes \"x\\<in>G\"\n  ",
        "using": [
            "lr_inv_fun",
            "apply_funtype",
            "neut_props_loop(1)",
            "lrdiv_props(1)",
            "lr_inv_fun(1)",
            "ZF_fun_from_tot_val",
            "LeftInv_def",
            "lrdiv_props(4)",
            "lr_inv_fun(2)",
            "RightInv_def"
        ],
        "statement": "lemma (in loop0) lr_inv_props: assumes \"x\\<in>G\"\n  shows \n    \"LeftInv(G,A)`(x) \\<in> G\" \"(LeftInv(G,A)`(x))\\<cdot>x = \\<one>\" \n    \"RightInv(G,A)`(x) \\<in> G\" \"x\\<cdot>(RightInv(G,A)`(x)) = \\<one>\"\n",
        "proof": "proof -\n  from assms show \"LeftInv(G,A)`(x) \\<in> G\" and \"RightInv(G,A)`(x) \\<in> G\"\n    using lr_inv_fun apply_funtype by auto\n  from assms have \"\\<exists>!y. y\\<in>G \\<and> y\\<cdot>x = \\<one>\"\n    using neut_props_loop(1) lrdiv_props(1) by simp\n  then have \"(\\<Union>{y\\<in>G.  y\\<cdot>x = \\<one>})\\<cdot>x = \\<one>\"\n    by (rule ZF1_1_L9)\n  with assms show \"(LeftInv(G,A)`(x))\\<cdot>x = \\<one>\" \n    using lr_inv_fun(1) ZF_fun_from_tot_val unfolding LeftInv_def by simp\n  from assms have \"\\<exists>!y. y\\<in>G \\<and> x\\<cdot>y = \\<one>\"\n    using neut_props_loop(1) lrdiv_props(4) by simp\n  then have \"x\\<cdot>(\\<Union>{y\\<in>G.  x\\<cdot>y = \\<one>}) = \\<one>\"\n    by (rule ZF1_1_L9)\n  with assms show \"x\\<cdot>(RightInv(G,A)`(x)) = \\<one>\" \n    using lr_inv_fun(2) ZF_fun_from_tot_val unfolding RightInv_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1073
    },
    "962": {
        "type": "lemma",
        "text": "text\\<open>This theory contains theorems (with proofs) about complex numbers\n  imported from the Metamath's set.mm database. \n  The original Metamath proofs were mostly written by Norman Megill, \n  see the Metamath Proof Explorer pages for full atribution.\n  This theory contains about 200 theorems from \"recnt\" to \"div11t\".\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "  lemma (in MMIsar0) MMI_recnt: \n   shows \"A \\<in> \\<real> \\<longrightarrow> A \\<in> \\<complex>\"\n",
        "proof": "proof -\n   have S1: \"\\<real> \\<subseteq> \\<complex>\" by (rule MMI_axresscn)\n   from S1 show \"A \\<in> \\<real> \\<longrightarrow> A \\<in> \\<complex>\" by (rule MMI_sseli)\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF.thy",
        "id": 1074
    },
    "963": {
        "type": "lemma",
        "text": "text\\<open>This theory contains theorems (with proofs) about complex numbers\n  imported from the Metamath's set.mm database. \n  The original Metamath proofs were mostly written by Norman Megill, \n  see the Metamath Proof Explorer pages for full atribution.\n  This theory contains about 200 theorems.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in MMIsar0) MMI_recrect: \n   shows \"( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> \n ( \\<one> \\<cdiv> ( \\<one> \\<cdiv> A ) ) = A\"\n",
        "proof": "proof -\n   have S1: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( \\<one> \\<cdiv> A ) = \n ( \\<one> \\<cdiv> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) )\" by (rule MMI_opreq2)\n   from S1 have S2: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( \\<one> \\<cdiv> ( \\<one> \\<cdiv> A ) ) = \n ( \\<one> \\<cdiv> ( \\<one> \\<cdiv> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) ) )\" \n     by (rule MMI_opreq2d)\n   have S3: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n A = if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> )\" by (rule MMI_id)\n   from S2 S3 have S4: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( ( \\<one> \\<cdiv> ( \\<one> \\<cdiv> A ) ) = \n A \\<longleftrightarrow> \n ( \\<one> \\<cdiv> ( \\<one> \\<cdiv> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) ) ) = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) )\" by (rule MMI_eqeq12d)\n   have S5: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( A \\<in> \\<complex> \\<longleftrightarrow> \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex> )\" by (rule MMI_eleq1)\n   have S6: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( A \\<noteq> \\<zero> \\<longleftrightarrow> \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero> )\" by (rule MMI_neeq1)\n   from S5 S6 have S7: \"A = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longleftrightarrow> \n ( if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex> \\<and> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero> ) )\" by (rule MMI_anbi12d)\n   have S8: \"\\<one> = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( \\<one> \\<in> \\<complex> \\<longleftrightarrow> \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex> )\" by (rule MMI_eleq1)\n   have S9: \"\\<one> = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( \\<one> \\<noteq> \\<zero> \\<longleftrightarrow> \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero> )\" by (rule MMI_neeq1)\n   from S8 S9 have S10: \"\\<one> = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<longrightarrow> \n ( ( \\<one> \\<in> \\<complex> \\<and> \\<one> \\<noteq> \\<zero> ) \\<longleftrightarrow> \n ( if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex> \\<and> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero> ) )\" by (rule MMI_anbi12d)\n   have S11: \"\\<one> \\<in> \\<complex>\" by (rule MMI_1cn)\n   have S12: \"\\<one> \\<noteq> \\<zero>\" by (rule MMI_ax1ne0)\n   from S11 S12 have S13: \"\\<one> \\<in> \\<complex> \\<and> \\<one> \\<noteq> \\<zero>\" by (rule MMI_pm3_2i)\n   from S7 S10 S13 have S14: \"if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex> \\<and> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero>\" by (rule MMI_elimhyp)\n   from S14 have S15: \"if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex>\" by (rule MMI_pm3_26i)\n   from S14 have S16: \"if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<in> \\<complex> \\<and> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero>\" .\n   from S16 have S17: \"if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) \\<noteq> \\<zero>\" by (rule MMI_pm3_27i)\n   from S15 S17 have S18: \"( \\<one> \\<cdiv> ( \\<one> \\<cdiv> if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> ) ) ) = \n if ( ( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) , A , \\<one> )\" by (rule MMI_recrec)\n   from S4 S18 show \"( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> \n ( \\<one> \\<cdiv> ( \\<one> \\<cdiv> A ) ) = A\" by (rule MMI_dedth)\nqed\n",
        "imports": [
            "IsarMathLib.MMI_examples"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_1.thy",
        "id": 1075
    },
    "964": {
        "type": "lemma",
        "text": "text\\<open>This theory contains theorems (with proofs) about complex numbers\n  imported from the Metamath's set.mm database. \n  The original Metamath proofs were mostly written by Norman Megill, \n  see the Metamath Proof Explorer pages for more detailed atribution.\n  This theory contains about 100 theorems from \\<open>1nn\\<close> to \\<open>infmrcl\\<close>\n\\<close>\n",
        "assumes": "",
        "using": [
            "cxn_def"
        ],
        "statement": "lemma (in MMIsar0) MMI_df_n: shows\n  \"\\<nat> = \\<Inter> {x\\<in> Pow(\\<real>). \\<one> \\<in> x \\<and> (\\<forall>y\\<in>x. y \\<ca> \\<one> \\<in> x) }\"\n",
        "proof": "proof -\n  let ?K\\<^sub>1 = \"{N \\<in> Pow(\\<real>). \\<one> \\<in> N \\<and> (\\<forall>n. n\\<in>N \\<longrightarrow> n\\<ca>\\<one> \\<in> N)}\"\n  let ?K\\<^sub>2 = \"{N \\<in> Pow(\\<real>). \\<one> \\<in> N \\<and> (\\<forall>n\\<in>N. n\\<ca>\\<one> \\<in> N)}\"\n  { fix N assume \"N \\<in> ?K\\<^sub>1\"\n    hence \"N \\<in> Pow(\\<real>)\"   \"\\<one> \\<in> N\"   \"\\<forall>n. n\\<in>N \\<longrightarrow> n\\<ca>\\<one> \\<in> N\"\n      by auto\n    then have \"N \\<in> ?K\\<^sub>2\" by auto }\n  moreover\n  { fix N assume \"N \\<in> ?K\\<^sub>2\"\n    hence \"N \\<in> Pow(\\<real>)\"   \"\\<one> \\<in> N\"   \"\\<forall>n\\<in>N. n\\<ca>\\<one> \\<in> N\"\n      by auto\n    then have \"N \\<in> ?K\\<^sub>1\" by auto }\n  ultimately have \"?K\\<^sub>1 = ?K\\<^sub>2\" by blast\n  then show ?thesis using cxn_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1076
    },
    "965": {
        "type": "corollary",
        "text": "text\\<open>Induction - on (real) natural numbers -  version for humans.\\<close>\n",
        "assumes": "assumes A1: \"\\<psi>(\\<one>)\" and \n  A2: \"\\<forall>k \\<in> \\<nat>. \\<psi>(k) \\<longrightarrow> \\<psi>(k\\<ca>\\<one>)\" and\n  A3: \"n \\<in> \\<nat>\"\n  ",
        "using": [],
        "statement": "corollary (in MMIsar0) nnind1: \n  assumes A1: \"\\<psi>(\\<one>)\" and \n  A2: \"\\<forall>k \\<in> \\<nat>. \\<psi>(k) \\<longrightarrow> \\<psi>(k\\<ca>\\<one>)\" and\n  A3: \"n \\<in> \\<nat>\"\n  shows \"\\<psi>(n)\"\n",
        "proof": "proof -\n  have \"\\<forall>x. x = \\<one> \\<longrightarrow>  \\<psi>(x) \\<longleftrightarrow> \\<psi>(\\<one>)\" by simp\n  moreover have \"\\<forall>x y. x = y \\<longrightarrow>  \\<psi>(x) \\<longleftrightarrow> \\<psi>(y)\" by simp\n  moreover have \"\\<forall>x y. x = y \\<ca> \\<one> \\<longrightarrow>  \\<psi>(x) \\<longleftrightarrow> \\<psi>(y\\<ca>\\<one>)\" by simp\n  moreover have \"\\<forall>x. x = n \\<longrightarrow>  \\<psi>(x) \\<longleftrightarrow> \\<psi>(n)\" by simp\n  moreover note A1\n  moreover from A2 have \"\\<forall>k. k \\<in> \\<nat> \\<longrightarrow> \\<psi>(k) \\<longrightarrow> \\<psi>(k\\<ca>\\<one>)\" by blast\n  ultimately have \"n \\<in> \\<nat> \\<longrightarrow> \\<psi>(n)\" by (rule MMI_nnind)\n  with A3 show \"\\<psi>(n)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1077
    },
    "966": {
        "type": "lemma",
        "text": "text\\<open>I am unable to translate the proof of Metamath's nnleltp1. Isabelle \n  chokes on a comlicated application of nn1suc. A couple of theorems below\n  are proven by hand in Isabelle to wokaround this. \n  In the next theorem we show that $a < a+1$.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "MMI_ax1re",
            "MMI_lt01",
            "MMI_ltaddpos"
        ],
        "statement": "lemma (in MMIsar0) num_le_numplus1: assumes \"a\\<in>\\<real>\"\n  shows \"a \\<ls> a\\<ca>\\<one>\"\n  ",
        "proof": "using assms MMI_ax1re MMI_lt01 MMI_ltaddpos\n  by simp\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1078
    },
    "967": {
        "type": "lemma",
        "text": "text\\<open>There are no natural numbers between $1$ and $2$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<nat>\"\n  ",
        "using": [
            "MMI_1nn",
            "MMI_nnge1t",
            "MMI_nnre",
            "MMI_ltadd1",
            "MMI_lt1nnn"
        ],
        "statement": "lemma (in MMIsar0) no_nat_between12: \n  assumes A1: \"n \\<in> \\<nat>\"\n  shows \"n \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> n \\<lsq> \\<one>\"\n",
        "proof": "proof -\n  have \"\\<one> \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> \\<one> \\<lsq> \\<one>\" \n    using MMI_1nn MMI_nnge1t by simp\n  moreover\n  { fix k assume A2: \"k\\<in>\\<nat>\"\n    { assume A3: \"k\\<ca>\\<one> \\<ls> \\<one>\\<ca>\\<one>\"\n      from A2 MMI_ax1re have T: \"k \\<in> \\<real>\"  \"\\<one> \\<in> \\<real>\" \n\tusing MMI_nnre by auto\n      with A3 have \"k \\<ls> \\<one>\" using MMI_ltadd1 by blast\n      with T A2 have False using MMI_lt1nnn by simp\n    } then have \"\\<not>(k\\<ca>\\<one> \\<ls> \\<one>\\<ca>\\<one>)\" by auto\n    hence\n      \"(k \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> k \\<lsq> \\<one>) \\<longrightarrow> (k\\<ca>\\<one> \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> k \\<ca> \\<one> \\<lsq> \\<one>)\"\n      by simp\n  } then have \"\\<forall>k\\<in>\\<nat>. \n      (k \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> k \\<lsq> \\<one>) \\<longrightarrow> (k\\<ca>\\<one> \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> k \\<ca> \\<one> \\<lsq> \\<one>)\"\n    by simp\n  moreover note A1\n  ultimately show \"n \\<ls> \\<one>\\<ca>\\<one> \\<longrightarrow> n \\<lsq> \\<one>\"\n    by (rule nnind1)\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1080
    },
    "968": {
        "type": "lemma",
        "text": "text\\<open>Natural number greater than $1$ has a predecessor.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<nat>\"\n  ",
        "using": [
            "MMI_ltnr",
            "MMI_nngt1ne1t",
            "MMI_1nn",
            "MMI_peano2nn"
        ],
        "statement": "lemma (in MMIsar0) nat_ge1_has_pred: assumes A1: \"n \\<in> \\<nat>\"\n  shows \"\\<one> \\<ls> n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = j\\<ca>\\<one>)\"\n",
        "proof": "proof -\n  from MMI_ax1re have \"\\<not>(\\<one>\\<ls>\\<one>)\" using MMI_ltnr by simp\n  then have \"\\<one> \\<ls> \\<one> \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. \\<one> = j\\<ca>\\<one>)\" by simp\n  moreover\n  { fix k assume A2: \"k\\<in>\\<nat>\" and A3: \"\\<one> \\<ls> k \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. k = j\\<ca>\\<one>)\" and\n    A4: \"\\<one> \\<ls> k\\<ca>\\<one>\"\n    from A2 have \"k=\\<one> \\<or> \\<one>\\<ls>k\" using MMI_nngt1ne1t by simp\n    moreover\n    { assume \"k=\\<one>\"\n      then have \"\\<one>\\<in>\\<nat>\" and \"k\\<ca>\\<one> = \\<one>\\<ca>\\<one>\"\n\tusing MMI_1nn by auto\n      hence \"\\<exists>i\\<in>\\<nat>. k\\<ca>\\<one> = i\\<ca>\\<one>\" by auto }\n    moreover\n    { assume \"\\<one> \\<ls> k\"\n      with A3 obtain j where \"j\\<in>\\<nat>\" and \"k = j\\<ca>\\<one>\"\n\tby auto\n      then have \"j\\<ca>\\<one> \\<in> \\<nat>\" and \"k\\<ca>\\<one> = j\\<ca>\\<one>\\<ca>\\<one>\"\n\tusing MMI_peano2nn by auto\n      then have \"\\<exists>i\\<in>\\<nat>. k\\<ca>\\<one> = i\\<ca>\\<one>\" by auto }\n    ultimately have \"\\<exists>i\\<in>\\<nat>. k\\<ca>\\<one> = i\\<ca>\\<one>\" by auto\n  } then have \"\\<forall>k\\<in>\\<nat>. \n      (\\<one> \\<ls> k \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. k = j\\<ca>\\<one>)) \\<longrightarrow> (\\<one> \\<ls> k\\<ca>\\<one> \\<longrightarrow> (\\<exists>i\\<in>\\<nat>. k\\<ca>\\<one> = i\\<ca>\\<one>))\"\n    by auto\n  moreover note A1\n  ultimately show \"\\<one> \\<ls> n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = j\\<ca>\\<one>)\"\n    by (rule nnind1)\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1081
    },
    "969": {
        "type": "lemma",
        "text": "text\\<open>If the successor is smaller, then the number is smaller.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"   \"b\\<in>\\<real>\" and A2: \"a\\<ca>\\<one> \\<ls> b\"\n  ",
        "using": [
            "MMI_ax1re",
            "MMI_axaddrcl",
            "num_le_numplus1",
            "MMI_axlttrn"
        ],
        "statement": "lemma (in MMIsar0) succ_le_imp_le: assumes A1: \"a\\<in>\\<real>\"   \"b\\<in>\\<real>\" and A2: \"a\\<ca>\\<one> \\<ls> b\"\n  shows \"a\\<ls>b\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>\\<real>\"  \"a\\<ca>\\<one> \\<in> \\<real>\"  \"b\\<in>\\<real>\"\n    using MMI_ax1re MMI_axaddrcl by auto\n  moreover from A1 A2 have \n    \"a \\<ls> a\\<ca>\\<one>\"   \"a\\<ca>\\<one> \\<ls> b\"\n    using num_le_numplus1 by auto\n  ultimately show \"a\\<ls>b\" using MMI_axlttrn by blast\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1082
    },
    "970": {
        "type": "lemma",
        "text": "text\\<open>For natural numbers greater numbers can be obtained by adding a natural number.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<nat>\"  \"m \\<in> \\<nat>\"\n  ",
        "using": [
            "nat_ge1_has_pred",
            "MMI_nncn",
            "MMI_nnre",
            "succ_le_imp_le",
            "MMI_ltadd2"
        ],
        "statement": "lemma (in MMIsar0) nat_ge_repr: assumes A1: \"n \\<in> \\<nat>\"  \"m \\<in> \\<nat>\"\n  shows \"m\\<ls>n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = m \\<ca> j)\"\n",
        "proof": "proof -\n  { assume \"\\<one> \\<ls> n\"\n    with A1 obtain k where I: \"k\\<in>\\<nat>\" and II: \"n = k\\<ca>\\<one>\"\n      using nat_ge1_has_pred by auto\n    with MMI_axaddcom MMI_ax1re MMI_axresscn have \"k \\<in> \\<complex>\" and \"\\<one> \\<in> \\<complex>\"\n      using MMI_nncn by auto\n    with MMI_axaddcom I II have \"\\<exists>k\\<in>\\<nat>. n = \\<one> \\<ca> k\"\n      by auto\n  } then have \"\\<one> \\<ls> n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = \\<one> \\<ca> j)\" by simp\n  moreover\n  { fix k assume A2: \"k\\<in>\\<nat>\" and \n    A3: \"k\\<ls>n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = k \\<ca> j)\" and A4: \"k\\<ca>\\<one> \\<ls> n\"\n    from A1 A2 have T: \"n\\<in>\\<real>\"  \"k\\<in>\\<real>\" using MMI_nnre by auto\n    with A3 A4 obtain j where III: \"j\\<in>\\<nat>\" and IV: \"n = k \\<ca> j\"\n      using succ_le_imp_le by auto\n    with A4 T III MMI_ax1re have \"\\<one> \\<ls> j\"\n      using MMI_nnre MMI_ltadd2 by blast\n    with III obtain i where V: \"i\\<in>\\<nat>\" and VI: \"j = i\\<ca>\\<one>\"\n      using nat_ge1_has_pred by auto\n    with IV have \"n = k \\<ca> (i\\<ca>\\<one>)\" by simp\n    moreover from V MMI_ax1re MMI_axresscn MMI_axaddcom have  \n      \"k \\<ca> (i\\<ca>\\<one>) = k \\<ca> (\\<one>\\<ca>i)\"\n      using MMI_nncn by auto\n    moreover from T V MMI_ax1re MMI_axresscn MMI_axaddass have\n      \"k \\<ca> \\<one>\\<ca>i = k \\<ca> (\\<one>\\<ca>i)\"\n      using MMI_nncn by blast\n    ultimately have \"n = k \\<ca> \\<one>\\<ca>i\" by simp\n    with V have \"\\<exists>i\\<in>\\<nat>. n = k\\<ca>\\<one> \\<ca> i\" by auto\n  } then have \"\\<forall>k\\<in>\\<nat>. (k\\<ls>n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = k \\<ca> j)) \\<longrightarrow> \n      (k\\<ca>\\<one> \\<ls> n \\<longrightarrow> (\\<exists>i\\<in>\\<nat>. n = k\\<ca>\\<one> \\<ca> i))\" by simp\n  moreover from A1 have \"m \\<in> \\<nat>\" by simp\n  ultimately show \"m\\<ls>n \\<longrightarrow> (\\<exists>j\\<in>\\<nat>. n = m \\<ca> j)\"\n    by (rule nnind1)\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1083
    },
    "971": {
        "type": "lemma",
        "text": "text\\<open>In natural numbers less $a+1$ implies less or equal $a$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<nat>\"  \"m \\<in> \\<nat>\" and A2: \"n \\<ls> m\\<ca>\\<one>\" \n  ",
        "using": [
            "MMI_nncn",
            "MMI_peano2nn",
            "nat_ge_repr",
            "MMI_nngt1ne1t",
            "MMI_addcan2",
            "nat_ge1_has_pred",
            "MMI_1cn",
            "MMI_axaddass",
            "MMI_nnre",
            "MMI_nngt0t",
            "MMI_ltaddpost",
            "MMI_leloet"
        ],
        "statement": "lemma (in MMIsar0) nat_ls_plus_one_imp_lsq:\n  assumes A1: \"n \\<in> \\<nat>\"  \"m \\<in> \\<nat>\" and A2: \"n \\<ls> m\\<ca>\\<one>\" \n  shows \"n \\<lsq> m\"\n",
        "proof": "proof -\n  from MMI_1cn A1 have T: \"m \\<in> \\<complex>\"  \"n \\<in> \\<complex>\"  \"\\<one> \\<in> \\<complex>\" \n    using MMI_nncn by auto\n  from A1 have \"m\\<ca>\\<one> \\<in> \\<nat>\" using MMI_peano2nn by simp\n  with A1 A2 obtain k where I: \"k\\<in>\\<nat>\" and II: \"m\\<ca>\\<one> = n\\<ca>k\"\n    using nat_ge_repr by auto\n  then have \"k = \\<one> \\<or> \\<one>\\<ls>k\" using MMI_nngt1ne1t by auto\n  moreover\n  { assume \"k=\\<one>\"\n    with II T have \"m = n\" using MMI_addcan2 by simp }\n  moreover\n  { assume \"\\<one>\\<ls>k\"\n    with I obtain i where III: \"i\\<in>\\<nat>\" and IV: \"k = i\\<ca>\\<one>\"\n      using nat_ge1_has_pred by auto\n    with A1 II III have \"m\\<ca>\\<one> = n\\<ca>i \\<ca> \\<one>\"\n      using MMI_nncn MMI_1cn MMI_axaddass by simp\n    with MMI_axaddcl T III have \"m = n\\<ca>i\" using MMI_nncn MMI_addcan2\n      by auto\n    moreover from A1 III have \"n\\<in>\\<real>\"  \"i\\<in>\\<real>\"   \"\\<zero> \\<ls> i\"\n      using MMI_nnre MMI_nngt0t by auto\n    ultimately have \"n \\<ls> m\" using MMI_ltaddpost by auto }\n  ultimately have \"n=m \\<or> n \\<ls> m\" by auto\n  with A1 show \"n \\<lsq> m\" using MMI_nnre MMI_leloet by auto\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1084
    },
    "972": {
        "type": "lemma",
        "text": "text\\<open>The next theorem is the reason we proved the theorems above \n  (see the comment to \\<open>num_le_numplus1\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "MMI_nnre",
            "lsq_imp_ls_plus1",
            "nat_ls_plus_one_imp_lsq"
        ],
        "statement": "lemma (in MMIsar0) MMI_nnleltp1t: \n  shows \"A \\<in> \\<nat> \\<and> B \\<in> \\<nat> \\<longrightarrow> A \\<lsq> B \\<longleftrightarrow> A \\<ls> B \\<ca> \\<one>\"\n",
        "proof": "proof\n  assume A1: \"A \\<in> \\<nat> \\<and> B \\<in> \\<nat>\"\n  then have \"A \\<lsq> B \\<longrightarrow> A \\<ls> B \\<ca> \\<one>\" \n    using MMI_nnre lsq_imp_ls_plus1 by simp\n  moreover from A1 have \"A \\<ls> B \\<ca> \\<one> \\<longrightarrow> A \\<lsq> B\"\n    using nat_ls_plus_one_imp_lsq by simp\n  ultimately show  \"A \\<lsq> B \\<longleftrightarrow> A \\<ls> B \\<ca> \\<one>\"\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1085
    },
    "973": {
        "type": "lemma",
        "text": "text\\<open>This theory contains 10 theorems translated from \n  Metamath (with proofs). It is included\n  in the proof document as an illustration of how a translated\n  Metamath proof looks like. The \"known\\_theorems.txt\"\n  file included in the IsarMathLib distribution provides\n  a list of all translated facts.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in MMIsar0) MMI_dividt: \n   shows \"( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> ( A \\<cdiv> A ) = \\<one>\"\n",
        "proof": "proof -\n   have S1: \"( A \\<in> \\<complex> \\<and> A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> \n ( A \\<cdiv> A ) = ( A \\<cdot> ( \\<one> \\<cdiv> A ) )\" by (rule MMI_divrect)\n   from S1 have S2: \"( ( A \\<in> \\<complex> \\<and> A \\<in> \\<complex> ) \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> \n ( A \\<cdiv> A ) = ( A \\<cdot> ( \\<one> \\<cdiv> A ) )\" by (rule MMI_3expa)\n   from S2 have S3: \"( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> \n ( A \\<cdiv> A ) = ( A \\<cdot> ( \\<one> \\<cdiv> A ) )\" by (rule MMI_anabsan)\n   have S4: \"( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> \n ( A \\<cdot> ( \\<one> \\<cdiv> A ) ) = \\<one>\" by (rule MMI_recidt)\n   from S3 S4 show \"( A \\<in> \\<complex> \\<and> A \\<noteq> \\<zero> ) \\<longrightarrow> ( A \\<cdiv> A ) = \\<one>\" by (rule MMI_eqtrd)\nqed\n",
        "imports": [
            "IsarMathLib.MMI_Complex_ZF"
        ],
        "source": "IsarMathLib/MMI_examples.thy",
        "id": 1087
    },
    "974": {
        "type": "lemma",
        "text": "text\\<open>This section contains Metamath theorems that the more advanced \n  theorems from \\<open>MMIsar.thy\\<close> depend on. Most of these theorems \n  are proven automatically by Isabelle, some have to be proven by hand \n  and some have to be modified to convert from Tarski-Megill \n  metalogic used by Metamath to one based on explicit notion of \n  free and bound variables.\\<close>   \n",
        "assumes": "assumes \"\\<phi>\" and \"\\<phi> \\<longrightarrow> \\<psi>\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma MMI_ax_mp: assumes \"\\<phi>\" and \"\\<phi> \\<longrightarrow> \\<psi>\" shows \"\\<psi>\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "IsarMathLib.MMI_prelude"
        ],
        "source": "IsarMathLib/MMI_logic_and_sets.thy",
        "id": 1088
    },
    "975": {
        "type": "definition",
        "text": "text\\<open>The next definition is what Metamath $X\\in V$ is\n  translated to. I am not sure why it works, probably because\n  Isabelle does a type inference and the \"=\" sign\n  indicates that both sides are sets.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsASet :: \"i\\<Rightarrow>o\" (\"_ isASet\" [90] 90) where\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF_1"
        ],
        "source": "IsarMathLib/MMI_prelude.thy",
        "id": 1090
    },
    "976": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states that we can use \n  the theorems proven in the \\<open>MMIsar0\\<close> context in\n  the \\<open>complex0\\<close> context. Unfortunately we have to \n  use low level Isabelle methods \"rule\" and \"unfold\" in the proof, simp\n  and blast fail on the order axioms.\n\\<close>\n",
        "assumes": "",
        "using": [
            "pre_axlttri",
            "pre_axlttrn",
            "pre_axltadd",
            "pre_axmulgt0",
            "pre_axsup",
            "axresscn",
            "ax1ne0",
            "axaddopr",
            "axmulopr",
            "axmulcom",
            "axaddcl",
            "axmulcl",
            "axdistr",
            "axaddcom",
            "axaddass",
            "axmulass",
            "ax1re",
            "axi2m1",
            "ax0id",
            "axicn",
            "axnegex",
            "axrecex",
            "ax1id",
            "axaddrcl",
            "axmulrcl",
            "axrnegex",
            "axrrecex"
        ],
        "statement": "lemma (in complex0) MMIsar_valid: \n  shows \"MMIsar0(\\<real>,\\<complex>,\\<one>,\\<zero>,\\<i>,CplxAdd(R,A),CplxMul(R,A,M),\n  StrictVersion(CplxROrder(R,A,r)))\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?zero = \"\\<zero>\"\n  let ?one = \"\\<one>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"(\\<forall>a b. a \\<in> ?real \\<and> b \\<in> ?real \\<longrightarrow>\n    \\<langle>a, b\\<rangle> \\<in> ?lessrrel \\<longleftrightarrow> \\<not> (a = b \\<or> \\<langle>b, a\\<rangle> \\<in> ?lessrrel))\"\n  proof -\n    have I:\n      \"\\<forall>a b. a \\<in> \\<real> \\<and> b \\<in> \\<real> \\<longrightarrow> (a \\<lsr> b \\<longleftrightarrow> \\<not>(a=b \\<or> b \\<lsr> a))\"\n      using pre_axlttri by blast\n    { fix a b assume \"a \\<in> ?real \\<and> b \\<in> ?real\"\n      with I have \"(a \\<lsr> b \\<longleftrightarrow> \\<not>(a=b \\<or> b \\<lsr> a))\"\n\tby blast\n      hence\n\t\"\\<langle>a, b\\<rangle> \\<in> ?lessrrel \\<longleftrightarrow> \\<not> (a = b \\<or> \\<langle>b, a\\<rangle> \\<in> ?lessrrel)\"\n\tby simp\n    } thus \"(\\<forall>a b. a \\<in> ?real \\<and> b \\<in> ?real \\<longrightarrow>\n\t(\\<langle>a, b\\<rangle> \\<in> ?lessrrel \\<longleftrightarrow> \\<not> (a = b \\<or> \\<langle>b, a\\<rangle> \\<in> ?lessrrel)))\"\n      by blast\n  qed\n  moreover\n  have \"(\\<forall>a b c.\n    a \\<in> ?real \\<and> b \\<in> ?real \\<and> c \\<in> ?real \\<longrightarrow>\n    \\<langle>a, b\\<rangle> \\<in> ?lessrrel \\<and> \\<langle>b, c\\<rangle> \\<in> ?lessrrel \\<longrightarrow> \\<langle>a, c\\<rangle> \\<in> ?lessrrel)\"\n  proof -\n    have II: \"\\<forall>a b c.  a \\<in> \\<real> \\<and> b \\<in> \\<real> \\<and> c \\<in> \\<real> \\<longrightarrow> \n      ((a \\<lsr> b \\<and> b \\<lsr> c) \\<longrightarrow> a \\<lsr> c)\"\n      using pre_axlttrn by blast\n    { fix a b c assume \"a \\<in> ?real \\<and> b \\<in> ?real \\<and> c \\<in> ?real\"\n      with II have \"(a \\<lsr> b \\<and> b \\<lsr> c) \\<longrightarrow> a \\<lsr> c\"\n\tby blast\n      hence \t\n\t\"\\<langle>a, b\\<rangle> \\<in> ?lessrrel \\<and> \\<langle>b, c\\<rangle> \\<in> ?lessrrel \\<longrightarrow> \\<langle>a, c\\<rangle> \\<in> ?lessrrel\"\n\tby simp\n    } thus  \"(\\<forall>a b c.\n\ta \\<in> ?real \\<and> b \\<in> ?real \\<and> c \\<in> ?real \\<longrightarrow>\n\t\\<langle>a, b\\<rangle> \\<in> ?lessrrel \\<and> \\<langle>b, c\\<rangle> \\<in> ?lessrrel \\<longrightarrow> \\<langle>a, c\\<rangle> \\<in> ?lessrrel)\"\n      by blast\n  qed\n  moreover have \"(\\<forall>A B C.\n    A \\<in> ?real \\<and> B \\<in> ?real \\<and> C \\<in> ?real \\<longrightarrow>\n    \\<langle>A, B\\<rangle> \\<in> ?lessrrel \\<longrightarrow>\n    \\<langle>?caddset ` \\<langle>C, A\\<rangle>, ?caddset ` \\<langle>C, B\\<rangle>\\<rangle> \\<in> ?lessrrel)\"\n    using pre_axltadd by simp\n  moreover have \"(\\<forall>A B. A \\<in> ?real \\<and> B \\<in> ?real \\<longrightarrow>\n    \\<langle>?zero, A\\<rangle> \\<in> ?lessrrel \\<and> \\<langle>?zero, B\\<rangle> \\<in> ?lessrrel \\<longrightarrow>\n    \\<langle>?zero, ?cmulset ` \\<langle>A, B\\<rangle>\\<rangle> \\<in> ?lessrrel)\"\n    using pre_axmulgt0 by simp\n  moreover have \n    \"(\\<forall>S. S \\<subseteq> ?real \\<and> S \\<noteq> 0 \\<and> (\\<exists>x\\<in>?real. \\<forall>y\\<in>S. \\<langle>y, x\\<rangle> \\<in> ?lessrrel) \\<longrightarrow>\n    (\\<exists>x\\<in>?real.\n    (\\<forall>y\\<in>S. \\<langle>x, y\\<rangle> \\<notin> ?lessrrel) \\<and>\n    (\\<forall>y\\<in>?real. \\<langle>y, x\\<rangle> \\<in> ?lessrrel \\<longrightarrow> (\\<exists>z\\<in>S. \\<langle>y, z\\<rangle> \\<in> ?lessrrel))))\"\n    using pre_axsup by simp\n  moreover have \"\\<real> \\<subseteq> \\<complex>\" using axresscn by simp\n  moreover have \"\\<one> \\<noteq> \\<zero>\" using ax1ne0 by simp\n  moreover have \"\\<complex> isASet\" by simp\n  moreover have \" CplxAdd(R,A) : \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\" \n    using axaddopr by simp\n  moreover have \"CplxMul(R,A,M) : \\<complex> \\<times> \\<complex> \\<rightarrow> \\<complex>\" \n    using axmulopr by simp\n  moreover have \n    \"\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow> a\\<cdot> b = b \\<cdot> a\"\n    using axmulcom by simp\n  hence \"(\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow>\n          ?cmulset ` \\<langle>a, b\\<rangle> = ?cmulset ` \\<langle>b, a\\<rangle>\n    )\" by simp\n  moreover have \"\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow> a \\<ca> b \\<in> \\<complex>\"\n    using axaddcl by simp\n  hence \"(\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow> \n          ?caddset ` \\<langle>a, b\\<rangle> \\<in> \\<complex>\n      )\" by simp\n  moreover have \"\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow> a \\<cdot> b \\<in> \\<complex>\"\n    using axmulcl by simp\n  hence \"(\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow> \n    ?cmulset ` \\<langle>a, b\\<rangle> \\<in> \\<complex> )\" by simp\n  moreover have \n    \"\\<forall>a b C. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<and> C \\<in> \\<complex> \\<longrightarrow> \n    a \\<cdot> (b \\<ca> C) = a \\<cdot> b \\<ca> a \\<cdot> C\"\n    using axdistr by simp\n  hence \"\\<forall>a b C.\n         a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<and> C \\<in> \\<complex> \\<longrightarrow>\n         ?cmulset ` \\<langle>a, ?caddset ` \\<langle>b, C\\<rangle>\\<rangle> =\n         ?caddset `\n         \\<langle>?cmulset ` \\<langle>a, b\\<rangle>, ?cmulset ` \\<langle>a, C\\<rangle>\\<rangle>\" \n    by simp\n  moreover have \"\\<forall>a b. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow>\n         a \\<ca> b = b \\<ca> a\"\n    using axaddcom by simp\n  hence \"\\<forall>a b.\n          a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<longrightarrow>\n          ?caddset ` \\<langle>a, b\\<rangle> = ?caddset ` \\<langle>b, a\\<rangle>\" by simp\n  moreover have \"\\<forall>a b C. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<and> C \\<in> \\<complex> \\<longrightarrow>\n      a \\<ca> b \\<ca> C = a \\<ca> (b \\<ca> C)\"\n    using axaddass by simp\n  hence \"\\<forall>a b C.\n          a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<and> C \\<in> \\<complex> \\<longrightarrow>\n          ?caddset ` \\<langle>?caddset ` \\<langle>a, b\\<rangle>, C\\<rangle> =\n          ?caddset ` \\<langle>a, ?caddset ` \\<langle>b, C\\<rangle>\\<rangle>\" by simp\n  moreover have \n    \"\\<forall>a b c. a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<and> c \\<in> \\<complex> \\<longrightarrow> a\\<cdot>b\\<cdot>c = a\\<cdot>(b\\<cdot>c)\"\n    using axmulass by simp\n  hence \"\\<forall>a b C.\n          a \\<in> \\<complex> \\<and> b \\<in> \\<complex> \\<and> C \\<in> \\<complex> \\<longrightarrow>\n          ?cmulset ` \\<langle>?cmulset ` \\<langle>a, b\\<rangle>, C\\<rangle> =\n          ?cmulset ` \\<langle>a, ?cmulset ` \\<langle>b, C\\<rangle>\\<rangle>\" by simp\n  moreover have \"\\<one> \\<in> \\<real>\" using ax1re by simp\n  moreover have \"\\<i>\\<cdot>\\<i> \\<ca> \\<one> = \\<zero>\"\n    using axi2m1 by simp\n  hence \"?caddset ` \\<langle>?cmulset ` \\<langle>\\<i>, \\<i>\\<rangle>, \\<one>\\<rangle> = \\<zero>\" by simp\n  moreover have \"\\<forall>a. a \\<in> \\<complex> \\<longrightarrow> a \\<ca> \\<zero> = a\"\n    using ax0id by simp\n  hence \"\\<forall>a. a \\<in> \\<complex> \\<longrightarrow> ?caddset ` \\<langle>a, \\<zero>\\<rangle> = a\" by simp\n  moreover have \"\\<i> \\<in> \\<complex>\" using axicn by simp\n  moreover have \"\\<forall>a. a \\<in> \\<complex> \\<longrightarrow> (\\<exists>x\\<in>\\<complex>. a \\<ca> x = \\<zero>)\"\n    using axnegex by simp\n  hence \"\\<forall>a. a \\<in> \\<complex> \\<longrightarrow> \n    (\\<exists>x\\<in>\\<complex>. ?caddset ` \\<langle>a, x\\<rangle> = \\<zero>)\" by simp\n  moreover have \"\\<forall>a. a \\<in> \\<complex> \\<and> a \\<noteq> \\<zero> \\<longrightarrow> (\\<exists>x\\<in>\\<complex>. a \\<cdot> x = \\<one>)\"\n    using axrecex by simp\n  hence \"\\<forall>a. a \\<in> \\<complex> \\<and> a \\<noteq> \\<zero> \\<longrightarrow> \n      ( \\<exists>x\\<in>\\<complex>. ?cmulset ` \\<langle>a, x\\<rangle> = \\<one> )\" by simp\n  moreover have \"\\<forall>a. a \\<in> \\<complex> \\<longrightarrow> a\\<cdot>\\<one> = a\"\n    using ax1id by simp\n hence \" \\<forall>a. a \\<in> \\<complex> \\<longrightarrow> \n        ?cmulset ` \\<langle>a, \\<one>\\<rangle> = a\" by simp\n moreover have \"\\<forall>a b. a \\<in> \\<real> \\<and> b \\<in> \\<real> \\<longrightarrow> a \\<ca> b \\<in> \\<real>\"\n   using axaddrcl by simp\n hence \"\\<forall>a b. a \\<in> \\<real> \\<and> b \\<in> \\<real> \\<longrightarrow> \n     ?caddset ` \\<langle>a, b\\<rangle> \\<in> \\<real>\" by simp\n moreover have \"\\<forall>a b. a \\<in> \\<real> \\<and> b \\<in> \\<real> \\<longrightarrow> a \\<cdot> b \\<in> \\<real>\"\n   using axmulrcl by simp\n hence \"\\<forall>a b. a \\<in> \\<real> \\<and> b \\<in> \\<real> \\<longrightarrow> \n     ?cmulset ` \\<langle>a, b\\<rangle> \\<in> \\<real>\" by simp\n moreover have \"\\<forall>a. a \\<in> \\<real> \\<longrightarrow> (\\<exists>x\\<in>\\<real>. a \\<ca> x = \\<zero>)\"\n   using axrnegex by simp\n hence \"\\<forall>a. a \\<in> \\<real> \\<longrightarrow> \n   ( \\<exists>x\\<in>\\<real>. ?caddset ` \\<langle>a, x\\<rangle> = \\<zero> )\" by simp\n moreover have \"\\<forall>a. a \\<in> \\<real> \\<and> a\\<noteq>\\<zero> \\<longrightarrow> (\\<exists>x\\<in>\\<real>. a \\<cdot> x = \\<one>)\"\n   using axrrecex by simp\n hence \"\\<forall>a. a \\<in> \\<real> \\<and> a \\<noteq> \\<zero> \\<longrightarrow> \n   ( \\<exists>x\\<in>\\<real>. ?cmulset ` \\<langle>a, x\\<rangle> = \\<one>)\" by simp\n",
        "imports": [
            "IsarMathLib.Complex_ZF",
            "IsarMathLib.MMI_prelude"
        ],
        "source": "IsarMathLib/Metamath_Interface.thy",
        "id": 1091
    },
    "977": {
        "type": "lemma",
        "text": "text\\<open>Metamath uses the set of real numbers extended with $+\\infty$ and $-\\infty$. \n  The $+\\infty$ and $-\\infty$ symbols are defined quite arbitrarily as $\\mathbb{C}$\n  and $\\mathbb{\\{ C\\} }$, respectively. The next lemma that corresponds to \n  Metamath's \\<open>renfdisj\\<close> states that $+\\infty$ and $-\\infty$ are not \n  elements of $\\mathbb{R}$.\\<close>\n",
        "assumes": "",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) renfdisj: shows \"\\<real> \\<inter> {\\<cpnf>,\\<cmnf>} = 0\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have \"?real \\<inter> {?complex, {?complex}} = 0\"\n    by (rule MMIsar0.MMI_renfdisj)\n  thus \"\\<real> \\<inter> {\\<cpnf>,\\<cmnf>} = 0\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1092
    },
    "978": {
        "type": "lemma",
        "text": "text\\<open>The order relation used most often in Metamath is defined on \n  the set of complex reals extended with   $+\\infty$ and $-\\infty$. \n  The next lemma\n  allows to use Metamath's \\<open>xrltso\\<close> that states that the \\<open>\\<ls>\\<close>\n  relations is a strict linear order on the extended set.\\<close>\n",
        "assumes": "",
        "using": [
            "MMIsar_valid",
            "cplx_strict_ord_on_cplx_reals"
        ],
        "statement": "lemma (in complex0) xrltso: shows \"\\<cltrrset> Orders \\<real>\\<^sup>*\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have \n    \"(?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n      {{?complex}} \\<times> ?real) Orders (?real \\<union> {?complex, {?complex}})\"\n    by (rule MMIsar0.MMI_xrltso)\n  moreover have \"?lessrrel \\<inter> ?real \\<times> ?real = ?lessrrel\"\n    using cplx_strict_ord_on_cplx_reals by auto\n  ultimately show \"\\<cltrrset> Orders \\<real>\\<^sup>*\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1093
    },
    "979": {
        "type": "lemma",
        "text": "text\\<open>Metamath defines the usual $<$ and $\\leq$ ordering relations for the\n  extended real line, including $+\\infty$ and $-\\infty$.\\<close>\n",
        "assumes": "assumes A1: \"x \\<in> \\<real>\\<^sup>*\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) xrrebndt: assumes A1: \"x \\<in> \\<real>\\<^sup>*\"\n  shows \"x \\<in> \\<real> \\<longleftrightarrow> ( \\<cmnf> \\<ls> x \\<and> x \\<ls> \\<cpnf> )\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have \"x \\<in> \\<real> \\<union> {\\<complex>, {\\<complex>}} \\<longrightarrow>\n    x \\<in> \\<real> \\<longleftrightarrow> \\<langle>{\\<complex>}, x\\<rangle> \\<in> ?lessrrel \\<inter> \\<real> \\<times> \\<real> \\<union> {\\<langle>{\\<complex>}, \\<complex>\\<rangle>} \\<union> \n    \\<real> \\<times> {\\<complex>} \\<union> {{\\<complex>}} \\<times> \\<real> \\<and>\n    \\<langle>x, \\<complex>\\<rangle> \\<in> ?lessrrel \\<inter> \\<real> \\<times> \\<real> \\<union> {\\<langle>{\\<complex>}, \\<complex>\\<rangle>} \\<union> \n    \\<real> \\<times> {\\<complex>} \\<union> {{\\<complex>}} \\<times> \\<real>\"\n    by (rule MMIsar0.MMI_xrrebndt)\n  then have \"x \\<in> \\<real>\\<^sup>* \\<longrightarrow> ( x \\<in> \\<real> \\<longleftrightarrow> ( \\<cmnf> \\<ls> x \\<and> x \\<ls> \\<cpnf> ) )\"\n    by simp\n  with A1 show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1094
    },
    "980": {
        "type": "lemma",
        "text": "text\\<open>A quite involved inequality.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<real>\"  \"b \\<in> \\<real>\"  \"c \\<in> \\<real>\"  \"d \\<in> \\<real>\" and\n  A2: \"\\<zero> \\<ls> b\"  \"\\<zero> \\<ls> d\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) lt2mul2divt: \n  assumes A1: \"a \\<in> \\<real>\"  \"b \\<in> \\<real>\"  \"c \\<in> \\<real>\"  \"d \\<in> \\<real>\" and\n  A2: \"\\<zero> \\<ls> b\"  \"\\<zero> \\<ls> d\"\n  shows \"a\\<cdot>b \\<ls> c\\<cdot>d \\<longleftrightarrow> a\\<cdiv>d \\<ls> c\\<cdiv>b\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have\n    \"(a \\<in> ?real \\<and> b \\<in> ?real) \\<and>\n    (c \\<in> ?real \\<and> d \\<in> ?real) \\<and>\n    \\<langle>?zero, b\\<rangle> \\<in> ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real \\<and>\n    \\<langle>?zero, d\\<rangle> \\<in> ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real \\<longrightarrow>\n    \\<langle>?cmulset ` \\<langle>a, b\\<rangle>, ?cmulset ` \\<langle>c, d\\<rangle>\\<rangle> \\<in>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real \\<longleftrightarrow>\n    \\<langle>\\<Union>{x \\<in> ?complex . ?cmulset ` \\<langle>d, x\\<rangle> = a}, \n    \\<Union>{x \\<in> ?complex . ?cmulset ` \\<langle>b, x\\<rangle> = c}\\<rangle> \\<in>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real\" \n    by (rule MMIsar0.MMI_lt2mul2divt)\n  with A1 A2 show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1095
    },
    "981": {
        "type": "lemma",
        "text": "text\\<open>A real number is smaller than its half iff it is positive.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> \\<real>\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) halfpos: assumes A1: \"a \\<in> \\<real>\"\n  shows \"\\<zero> \\<ls> a \\<longleftrightarrow> a\\<cdiv>\\<two> \\<ls> a\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  from A1 have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    and \"a \\<in> ?real\"\n    using MMIsar_valid by auto\n  then have\n    \"\\<langle>?zero, a\\<rangle> \\<in>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real \\<longleftrightarrow>\n    \\<langle>\\<Union>{x \\<in> ?complex . ?cmulset ` \\<langle>?caddset ` \\<langle>?one, ?one\\<rangle>, x\\<rangle> = a}, a\\<rangle> \\<in>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real\"\n    by (rule MMIsar0.MMI_halfpos)\n  then show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1096
    },
    "982": {
        "type": "lemma",
        "text": "text\\<open>One more inequality.\\<close>\n",
        "assumes": "assumes A1:  \"a \\<in> \\<real>\"   \"b \\<in> \\<real>\" and\n  A2: \"\\<zero> \\<lsq> a\"  \"\\<zero> \\<lsq> b\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) ledivp1t: \n  assumes A1:  \"a \\<in> \\<real>\"   \"b \\<in> \\<real>\" and\n  A2: \"\\<zero> \\<lsq> a\"  \"\\<zero> \\<lsq> b\"\n  shows \"(a\\<cdiv>(b \\<ca> \\<one>))\\<cdot>b \\<lsq> a\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have\n    \"(a \\<in> ?real \\<and> \\<langle>a, ?zero\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real) \\<and> \n    b \\<in> ?real \\<and> \\<langle>b, ?zero\\<rangle> \\<notin> ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real \\<longrightarrow>\n    \\<langle>a,?cmulset`\\<langle>\\<Union>{x \\<in> ?complex . ?cmulset`\\<langle>?caddset`\\<langle>b, ?one\\<rangle>, x\\<rangle> = a}, b\\<rangle>\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real\"\n    by (rule MMIsar0.MMI_ledivp1t)\n  with A1 A2 show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1097
    },
    "983": {
        "type": "lemma",
        "text": "text\\<open>Two ways of saying that there are no natural numbers between $n$ and $n+1$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> \\<nat>\"  \"k \\<in> \\<nat>\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) no_nats_between: \n  assumes A1: \"n \\<in> \\<nat>\"  \"k \\<in> \\<nat>\"\n  shows \n  \"n\\<lsq>k \\<longleftrightarrow> n \\<ls> k\\<ca>\\<one>\"\n  \"n \\<ls> k \\<longleftrightarrow> n \\<ca> \\<one> \\<lsq> k\" \n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have I: \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have \n    \"n \\<in> \\<Inter>{N \\<in> Pow(?real) . ?one \\<in> N \\<and> \n    (\\<forall>n. n \\<in> N \\<longrightarrow> ?caddset ` \\<langle>n, ?one\\<rangle> \\<in> N)} \\<and>\n    k \\<in> \\<Inter>{N \\<in> Pow(?real) . ?one \\<in> N \\<and> \n    (\\<forall>n. n \\<in> N \\<longrightarrow> ?caddset ` \\<langle>n, ?one\\<rangle> \\<in> N)} \\<longrightarrow>\n    \\<langle>k, n\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real \\<longleftrightarrow>\n    \\<langle>n, ?caddset ` \\<langle>k, ?one\\<rangle>\\<rangle> \\<in>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real\" by (rule MMIsar0.MMI_nnleltp1t)\n  then have \"n \\<in> \\<nat> \\<and> k \\<in> \\<nat> \\<longrightarrow> n \\<lsq> k \\<longleftrightarrow> n \\<ls> k \\<ca> \\<one>\"\n    by simp\n  with A1 show \"n\\<lsq>k \\<longleftrightarrow> n \\<ls> k\\<ca>\\<one>\" by simp\n  from I have\n    \"n \\<in> \\<Inter>{N \\<in> Pow(?real) . ?one \\<in> N \\<and> \n    (\\<forall>n. n \\<in> N \\<longrightarrow> ?caddset ` \\<langle>n, ?one\\<rangle> \\<in> N)} \\<and>\n    k \\<in> \\<Inter>{N \\<in> Pow(?real) . ?one \\<in> N \\<and> \n    (\\<forall>n. n \\<in> N \\<longrightarrow> ?caddset ` \\<langle>n, ?one\\<rangle> \\<in> N)} \\<longrightarrow>\n    \\<langle>n, k\\<rangle> \\<in>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real \\<longleftrightarrow>  \\<langle>k, ?caddset ` \\<langle>n, ?one\\<rangle>\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real\" by (rule MMIsar0.MMI_nnltp1let)\n  then have \"n \\<in> \\<nat> \\<and> k \\<in> \\<nat> \\<longrightarrow>  n \\<ls> k \\<longleftrightarrow> n \\<ca> \\<one> \\<lsq> k\"\n    by simp\n  with A1 show \"n \\<ls> k \\<longleftrightarrow> n \\<ca> \\<one> \\<lsq> k\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1098
    },
    "984": {
        "type": "lemma",
        "text": "text\\<open>Metamath has some very complicated and general version of induction\n  on (complex) natural numbers that I can't even understand. As an exercise\n  I derived a more standard version that is imported to the \\<open>complex0\\<close> \n  context below.\\<close>\n",
        "assumes": "assumes A1: \"\\<psi>(\\<one>)\" and \n  A2: \"\\<forall>k \\<in> \\<nat>. \\<psi>(k) \\<longrightarrow> \\<psi>(k\\<ca>\\<one>)\" and\n  A3: \"n \\<in> \\<nat>\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) cplx_nat_ind: assumes A1: \"\\<psi>(\\<one>)\" and \n  A2: \"\\<forall>k \\<in> \\<nat>. \\<psi>(k) \\<longrightarrow> \\<psi>(k\\<ca>\\<one>)\" and\n  A3: \"n \\<in> \\<nat>\"\n  shows \"\\<psi>(n)\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have I: \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  moreover from A1 A2 A3 have\n    \"\\<psi>(?one)\"\n    \"\\<forall>k\\<in>\\<Inter>{N \\<in> Pow(?real) . ?one \\<in> N \\<and> \n    (\\<forall>n. n \\<in> N \\<longrightarrow> ?caddset ` \\<langle>n, ?one\\<rangle> \\<in> N)}.\n    \\<psi>(k) \\<longrightarrow> \\<psi>(?caddset ` \\<langle>k, ?one\\<rangle>)\"\n    \"n \\<in> \\<Inter>{N \\<in> Pow(?real) . ?one \\<in> N \\<and> \n    (\\<forall>n. n \\<in> N \\<longrightarrow> ?caddset ` \\<langle>n, ?one\\<rangle> \\<in> N)}\"\n    by auto\n  ultimately show \"\\<psi>(n)\" by (rule MMIsar0.nnind1)\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1099
    },
    "985": {
        "type": "lemma",
        "text": "text\\<open>Some simple arithmetics.\\<close>\n",
        "assumes": "",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) arith: shows\n  \"\\<two> \\<ca> \\<two> = \\<four>\"\n  \"\\<two>\\<cdot>\\<two> = \\<four>\"\n  \"\\<three>\\<cdot>\\<two> = \\<six>\"\n  \"\\<three>\\<cdot>\\<three> = \\<nine>\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\"\n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have I: \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have\n    \"?caddset ` \\<langle>?caddset ` \\<langle>?one, ?one\\<rangle>, ?caddset ` \\<langle>?one, ?one\\<rangle>\\<rangle> =\n    ?caddset ` \\<langle>?caddset ` \\<langle>?caddset ` \\<langle>?one, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>\"\n    by (rule MMIsar0.MMI_2p2e4)\n  thus \"\\<two> \\<ca> \\<two> = \\<four>\" by simp\n  from I have\n    \"?cmulset`\\<langle>?caddset`\\<langle>?one, ?one\\<rangle>, ?caddset`\\<langle>?one, ?one\\<rangle>\\<rangle> =\n    ?caddset`\\<langle>?caddset`\\<langle>?caddset`\\<langle>?one, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>\"\n    by (rule MMIsar0.MMI_2t2e4)\n  thus \"\\<two>\\<cdot>\\<two> = \\<four>\" by simp\n  from I have\n    \"?cmulset`\\<langle>?caddset`\\<langle>?caddset`\\<langle>?one, ?one\\<rangle>, ?one\\<rangle>, ?caddset`\\<langle>?one, ?one\\<rangle>\\<rangle> =\n    ?caddset `\\<langle>?caddset`\\<langle>?caddset`\\<langle>?caddset`\\<langle>?caddset`\n    \\<langle>?one, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>\"\n    by (rule MMIsar0.MMI_3t2e6)\n  thus \"\\<three>\\<cdot>\\<two> = \\<six>\" by simp\n  from I have \"?cmulset `\n    \\<langle>?caddset`\\<langle>?caddset`\\<langle>?one, ?one\\<rangle>, ?one\\<rangle>,\n    ?caddset`\\<langle>?caddset`\\<langle>?one, ?one\\<rangle>, ?one\\<rangle>\\<rangle> =\n    ?caddset`\\<langle>?caddset`\\<langle>?caddset `\\<langle>?caddset `\n    \\<langle>?caddset`\\<langle>?caddset`\\<langle>?caddset`\\<langle>?caddset`\\<langle>?one, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>,\n    ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>, ?one\\<rangle>\"\n    by (rule MMIsar0.MMI_3t3e9)\n  thus \"\\<three>\\<cdot>\\<three> = \\<nine>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1100
    },
    "986": {
        "type": "lemma",
        "text": "text\\<open>If a set $S$ has a smallest element, then the infimum of $S$ belongs\n  to it.\\<close>\n",
        "assumes": "assumes A1: \"S \\<subseteq> \\<real>\" and \n  A2: \"\\<exists>x\\<in>S. \\<forall>y\\<in>S. x \\<lsq> y\"\n  ",
        "using": [
            "MMIsar_valid",
            "Infim_def"
        ],
        "statement": "lemma (in complex0) lbinfmcl: assumes A1: \"S \\<subseteq> \\<real>\" and \n  A2: \"\\<exists>x\\<in>S. \\<forall>y\\<in>S. x \\<lsq> y\"\n  shows  \"Infim(S,\\<real>,\\<cltrrset>) \\<in> S\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\" \n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have I: \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have\n    \"S \\<subseteq> ?real \\<and> (\\<exists>x\\<in>S. \\<forall>y\\<in>S. \\<langle>y, x\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union>\n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real) \\<longrightarrow>\n    Sup(S, ?real,  \n    converse(?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real)) \\<in> S\"\n    by (rule MMIsar0.MMI_lbinfmcl)\n  then have \n    \"S \\<subseteq>\\<real> \\<and> ( \\<exists>x\\<in>S. \\<forall>y\\<in>S. x \\<lsq> y) \\<longrightarrow>  \n    Sup(S,\\<real>,converse(\\<cltrrset>)) \\<in> S\" by simp\n  with A1 A2 show ?thesis using Infim_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1101
    },
    "987": {
        "type": "lemma",
        "text": "text\\<open>Supremum of any subset of reals that is bounded above is real.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<real> \" and \"A \\<noteq> 0\" and \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. y \\<lsq> x\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) sup_is_real: \n  assumes \"A \\<subseteq> \\<real> \" and \"A \\<noteq> 0\" and \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. y \\<lsq> x\"\n  shows \"Sup(A,\\<real>,\\<cltrrset>) \\<in> \\<real>\"  \n",
        "proof": "proof -\n  let ?real = \"\\<real>\" \n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have \n    \"A \\<subseteq> ?real \\<and> A \\<noteq> 0 \\<and> (\\<exists>x\\<in>?real.  \\<forall>y\\<in>A. \\<langle>x, y\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real) \\<longrightarrow> \n    Sup(A, ?real,\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real) \\<in> ?real\" \n    by (rule MMIsar0.MMI_suprcl)\n  with assms show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1102
    },
    "988": {
        "type": "lemma",
        "text": "text\\<open>If a real number is smaller that the supremum of $A$, then \n  we can find an element of $A$ greater than it.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq>\\<real>\" and \"A \\<noteq> 0\" and \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. y \\<lsq> x\" \n  and \"B \\<in> \\<real>\"  and \"B \\<ls> Sup(A,\\<real>,\\<cltrrset>)\"\n  ",
        "using": [
            "MMIsar_valid"
        ],
        "statement": "lemma (in complex0) suprlub: \n  assumes \"A \\<subseteq>\\<real>\" and \"A \\<noteq> 0\" and \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. y \\<lsq> x\" \n  and \"B \\<in> \\<real>\"  and \"B \\<ls> Sup(A,\\<real>,\\<cltrrset>)\"\n  shows \"\\<exists>z\\<in>A. B \\<ls> z\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\" \n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have \"(A \\<subseteq> ?real \\<and> A \\<noteq> 0 \\<and> (\\<exists>x\\<in>?real. \\<forall>y\\<in>A. \\<langle>x, y\\<rangle> \\<notin>\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> \n    {{?complex}} \\<times> ?real)) \\<and> B \\<in> ?real \\<and> \\<langle>B, Sup(A, ?real,\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real)\\<rangle> \\<in> ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real \\<longrightarrow>\n    (\\<exists>z\\<in>A. \\<langle>B, z\\<rangle> \\<in> ?lessrrel \\<inter> ?real \\<times> ?real \\<union> \n    {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real)\"\n    by (rule MMIsar0.MMI_suprlub)\n  with assms show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1103
    },
    "989": {
        "type": "lemma",
        "text": "text\\<open>Something a bit more interesting: infimum of a set that is bounded\n  below is real and equal to the\n  minus supremum of the set flipped around zero.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<real>\" and \"A \\<noteq> 0\" and \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. x \\<lsq> y\"\n  ",
        "using": [
            "MMIsar_valid",
            "Infim_def"
        ],
        "statement": "lemma (in complex0) infmsup: \n  assumes \"A \\<subseteq> \\<real>\" and \"A \\<noteq> 0\" and \"\\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. x \\<lsq> y\"\n  shows\n  \"Infim(A,\\<real>,\\<cltrrset>) \\<in> \\<real>\"\n  \"Infim(A,\\<real>,\\<cltrrset>) = ( \\<cn>Sup({z \\<in> \\<real>. (\\<cn>z) \\<in> A },\\<real>,\\<cltrrset>) )\"\n",
        "proof": "proof -\n  let ?real = \"\\<real>\" \n  let ?complex = \"\\<complex>\"\n  let ?one = \"\\<one>\"\n  let ?zero = \"\\<zero>\"\n  let ?iunit = \"\\<i>\"\n  let ?caddset = \"CplxAdd(R,A)\"\n  let ?cmulset = \"CplxMul(R,A,M)\"\n  let ?lessrrel = \"StrictVersion(CplxROrder(R,A,r))\"\n  have I: \"MMIsar0\n    (?real, ?complex, ?one, ?zero, ?iunit, ?caddset, ?cmulset, ?lessrrel)\"\n    using MMIsar_valid by simp\n  then have\n    \"A \\<subseteq> ?real \\<and> A \\<noteq> 0 \\<and> (\\<exists>x\\<in>?real. \\<forall>y\\<in>A. \\<langle>y, x\\<rangle> \\<notin> \n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real) \\<longrightarrow> Sup(A, ?real, converse\n    (?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real)) =\n    \\<Union>{x \\<in> ?complex . ?caddset`\n    \\<langle>Sup({z \\<in> ?real . \\<Union>{x \\<in> ?complex . ?caddset`\\<langle>z, x\\<rangle> = ?zero} \\<in> A}, ?real,\n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real), x\\<rangle> = ?zero}\"\n    by (rule MMIsar0.MMI_infmsup)\n  then have \"A \\<subseteq>\\<real> \\<and> \\<not>(A = 0) \\<and> ( \\<exists>x\\<in>\\<real>. \\<forall>y\\<in>A. x \\<lsq> y) \\<longrightarrow> \n    Sup(A,\\<real>,converse(\\<cltrrset>)) = ( \\<cn>Sup({z \\<in> \\<real>. (\\<cn>z) \\<in> A },\\<real>,\\<cltrrset>) )\"\n    by simp\n  with assms show\n    \"Infim(A,\\<real>,\\<cltrrset>) = ( \\<cn>Sup({z \\<in> \\<real>. (\\<cn>z) \\<in> A },\\<real>,\\<cltrrset>) )\"\n    using Infim_def by simp\n  from I have\n    \"A \\<subseteq> ?real \\<and> A \\<noteq> 0 \\<and> (\\<exists>x\\<in>?real. \\<forall>y\\<in>A. \\<langle>y, x\\<rangle> \\<notin> \n    ?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union>\n    {{?complex}} \\<times> ?real) \\<longrightarrow> Sup(A, ?real, converse\n    (?lessrrel \\<inter> ?real \\<times> ?real \\<union> {\\<langle>{?complex}, ?complex\\<rangle>} \\<union> \n    ?real \\<times> {?complex} \\<union> {{?complex}} \\<times> ?real)) \\<in> ?real\"\n    by (rule MMIsar0.MMI_infmrcl)\n  with assms show \"Infim(A,\\<real>,\\<cltrrset>) \\<in> \\<real>\"\n    using Infim_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Metamath_Interface",
            "IsarMathLib.MMI_Complex_ZF_2"
        ],
        "source": "IsarMathLib/Metamath_Sampler.thy",
        "id": 1104
    },
    "990": {
        "type": "definition",
        "text": "text\\<open> First we define a pseudo-metric, which has the axioms of a metric, but without the second part\n  of the identity of indiscernibles. In our definition \\<open>IsApseudoMetric\\<close> is a predicate on five sets: the function $d$, \n  the set $X$ on which the metric is defined, the loop carrier $G$, the loop operation $A$ \n  and the order $r$ on $G$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"IsApseudoMetric(d,X,G,A,r) \\<equiv> d:X\\<times>X \\<rightarrow> Nonnegative(G,A,r) \n    \\<and> (\\<forall>x\\<in>X. d`\\<langle>x,x\\<rangle> = TheNeutralElement(G,A))\n    \\<and> (\\<forall>x\\<in>X.\\<forall>y\\<in>X. d`\\<langle>x,y\\<rangle> = d`\\<langle>y,x\\<rangle>)\n    \\<and> (\\<forall>x\\<in>X.\\<forall>y\\<in>X.\\<forall>z\\<in>X. \\<langle>d`\\<langle>x,z\\<rangle>, A`\\<langle>d`\\<langle>x,y\\<rangle>,d`\\<langle>y,z\\<rangle>\\<rangle>\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1105
    },
    "991": {
        "type": "definition",
        "text": "text\\<open>We add the full axiom of identity of indiscernibles to the definition of a pseudometric\n  to get the definition of metric.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"IsAmetric(d,X,G,A,r) \\<equiv> \n    IsApseudoMetric(d,X,G,A,r) \\<and> (\\<forall>x\\<in>X.\\<forall>y\\<in>X. d`\\<langle>x,y\\<rangle> = TheNeutralElement(G,A) \\<longrightarrow> x=y)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1106
    },
    "992": {
        "type": "definition",
        "text": "text\\<open>A disk is defined as set of points located less than the radius from the center.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \"Disk(X,d,r,c,R) \\<equiv> {x\\<in>X. \\<langle>d`\\<langle>c,x\\<rangle>,R\\<rangle> \\<in> StrictVersion(r)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1107
    },
    "993": {
        "type": "lemma",
        "text": "text\\<open> The next lemma shows the definition of the pseudometric in the notation used in the \n  \\<open>metric_space\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "pmetricAssum",
            "IsApseudoMetric_def"
        ],
        "statement": "lemma (in pmetric_space) pmetric_properties: shows \n  \"d: X\\<times>X \\<rightarrow> L\\<^sup>+\"\n  \"\\<forall>x\\<in>X. d`\\<langle>x,x\\<rangle> = \\<zero>\"\n  \"\\<forall>x\\<in>X.\\<forall>y\\<in>X. d`\\<langle>x,y\\<rangle> = d`\\<langle>y,x\\<rangle>\"\n  \"\\<forall>x\\<in>X.\\<forall>y\\<in>X.\\<forall>z\\<in>X. d`\\<langle>x,z\\<rangle> \\<lsq> d`\\<langle>x,y\\<rangle> \\<ra> d`\\<langle>y,z\\<rangle>\"\n  ",
        "proof": "using pmetricAssum unfolding IsApseudoMetric_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1108
    },
    "994": {
        "type": "lemma",
        "text": "text\\<open>The values of the metric are in the loop.\\<close>\n",
        "assumes": "assumes \"x\\<in>X\" \"y\\<in>X\"\n  ",
        "using": [
            "pmetric_properties(1)",
            "apply_funtype",
            "Nonnegative_def"
        ],
        "statement": "lemma (in pmetric_space) pmetric_loop_valued: assumes \"x\\<in>X\" \"y\\<in>X\"\n  shows \"d`\\<langle>x,y\\<rangle> \\<in> L\\<^sup>+\" \"d`\\<langle>x,y\\<rangle> \\<in> L\"\n",
        "proof": "proof -\n  from assms show \"d`\\<langle>x,y\\<rangle> \\<in> L\\<^sup>+\" using pmetric_properties(1) apply_funtype\n    by simp\n  then show \"d`\\<langle>x,y\\<rangle> \\<in> L\" using Nonnegative_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1109
    },
    "995": {
        "type": "lemma",
        "text": "text\\<open>The definition of the disk in the notation used in the \\<open>pmetric_space\\<close> context:\\<close>\n",
        "assumes": "",
        "using": [
            "def_of_strict_ver"
        ],
        "statement": "lemma (in pmetric_space) disk_definition: shows \"disk(c,R) = {x\\<in>X. d`\\<langle>c,x\\<rangle> \\<ls> R}\"\n",
        "proof": "proof -\n  have \"disk(c,R) = Disk(X,d,r,c,R)\" by simp\n  then have \"disk(c,R) = {x\\<in>X. \\<langle>d`\\<langle>c,x\\<rangle>,R\\<rangle> \\<in> StrictVersion(r)}\" unfolding Disk_def by simp\n  moreover have \"\\<forall>x\\<in>X. \\<langle>d`\\<langle>c,x\\<rangle>,R\\<rangle> \\<in> StrictVersion(r) \\<longleftrightarrow> d`\\<langle>c,x\\<rangle> \\<ls> R\"\n    using def_of_strict_ver by simp\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1110
    },
    "996": {
        "type": "lemma",
        "text": "text\\<open>If the radius is positive then the center is in disk.\\<close>\n",
        "assumes": "assumes \"c\\<in>X\" and \"R\\<in>L\\<^sub>+\" ",
        "using": [
            "pmetricAssum",
            "assms",
            "IsApseudoMetric_def",
            "PositiveSet_def",
            "disk_definition"
        ],
        "statement": "lemma (in pmetric_space) center_in_disk: assumes \"c\\<in>X\" and \"R\\<in>L\\<^sub>+\" shows \"c \\<in> disk(c,R)\"\n  ",
        "proof": "using pmetricAssum assms IsApseudoMetric_def PositiveSet_def disk_definition by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1111
    },
    "997": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma that allows us to shorten some proofs: \\<close>\n",
        "assumes": "assumes \"c\\<in>X\" and \"x \\<in> disk(c,R)\"\n  ",
        "using": [
            "disk_definition",
            "pmetric_properties(1)",
            "apply_funtype",
            "nonneg_definition",
            "loop_strict_ord_trans",
            "posset_definition",
            "PositiveSet_def",
            "ls_other_side(2)"
        ],
        "statement": "lemma (in pmetric_space) radius_in_loop: assumes \"c\\<in>X\" and \"x \\<in> disk(c,R)\"\n  shows \"R\\<in>L\" \"\\<zero>\\<ls>R\" \"R\\<in>L\\<^sub>+\" \"(\\<rm>d`\\<langle>c,x\\<rangle> \\<ad> R) \\<in> L\\<^sub>+\"\n",
        "proof": "proof -\n  from assms(2) have \"x\\<in>X\" and \"d`\\<langle>c,x\\<rangle> \\<ls> R\" using disk_definition by auto\n  with assms(1) show \"\\<zero>\\<ls>R\" using pmetric_properties(1) apply_funtype \n      nonneg_definition loop_strict_ord_trans by blast\n  then show \"R\\<in>L\" and \"R\\<in>L\\<^sub>+\" using posset_definition PositiveSet_def by auto\n  from \\<open>d`\\<langle>c,x\\<rangle> \\<ls> R\\<close> show \"(\\<rm>d`\\<langle>c,x\\<rangle> \\<ad> R) \\<in> L\\<^sub>+\"\n    using ls_other_side(2) by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1112
    },
    "998": {
        "type": "lemma",
        "text": "text\\<open>If a point $x$ is inside a disk $B$ and $m\\leq R-d(c,x)$ then the disk centered \n  at the point $x$ and with radius $m$ is contained in the disk $B$. \\<close>\n",
        "assumes": "assumes \"c\\<in>X\"  and \"x \\<in> disk(c,R)\" and \"m \\<lsq> (\\<rm>d`\\<langle>c,x\\<rangle> \\<ad> R)\"\n  ",
        "using": [
            "disk_definition",
            "radius_in_loop(1)",
            "pmetric_properties(4)",
            "pmetric_properties(1)",
            "apply_funtype",
            "nonneg_subset",
            "loop_strict_ord_trans1",
            "strict_ord_trans_inv(2)",
            "lrdiv_props(6)",
            "loop_strict_ord_trans"
        ],
        "statement": "lemma (in pmetric_space) disk_in_disk: \n  assumes \"c\\<in>X\"  and \"x \\<in> disk(c,R)\" and \"m \\<lsq> (\\<rm>d`\\<langle>c,x\\<rangle> \\<ad> R)\"\n  shows \"disk(x,m) \\<subseteq> disk(c,R)\"\n",
        "proof": "proof\n  fix y assume \"y \\<in> disk(x,m)\"\n  then have \"d`\\<langle>x,y\\<rangle> \\<ls> m\" using disk_definition by simp\n  from assms(1,2) \\<open>y \\<in> disk(x,m)\\<close> have \"R\\<in>L\" \"x\\<in>X\" \"y\\<in>X\" \n    using radius_in_loop(1) disk_definition by auto\n  with assms(1) have \"d`\\<langle>c,y\\<rangle> \\<lsq> d`\\<langle>c,x\\<rangle> \\<ra> d`\\<langle>x,y\\<rangle>\" using pmetric_properties(4) by simp\n  from assms(1) \\<open>x\\<in>X\\<close> have \"d`\\<langle>c,x\\<rangle> \\<in> L\" \n    using pmetric_properties(1) apply_funtype nonneg_subset by auto\n  with \\<open>d`\\<langle>x,y\\<rangle> \\<ls> m\\<close> assms(3) have \"d`\\<langle>c,x\\<rangle> \\<ra> d`\\<langle>x,y\\<rangle> \\<ls> d`\\<langle>c,x\\<rangle> \\<ra> (\\<rm>d`\\<langle>c,x\\<rangle> \\<ad> R)\"\n    using loop_strict_ord_trans1 strict_ord_trans_inv(2) by blast\n  with \\<open>d`\\<langle>c,x\\<rangle> \\<in> L\\<close> \\<open>R\\<in>L\\<close> \\<open>d`\\<langle>c,y\\<rangle> \\<lsq> d`\\<langle>c,x\\<rangle> \\<ra> d`\\<langle>x,y\\<rangle>\\<close> \\<open>y\\<in>X\\<close> show \"y \\<in> disk(c,R)\"\n    using lrdiv_props(6) loop_strict_ord_trans disk_definition by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1113
    },
    "999": {
        "type": "lemma",
        "text": "text\\<open> If we assume that the order on the group makes the positive set a meet semi-lattice (i.e.\n  every two-element subset of $G_+$ has a greatest lower bound) then \n  the collection of disks centered at points of the space and with radii in the positive set \n  of the group satisfies the base condition. The meet semi-lattice assumption can be weakened \n  to \"each two-element subset of $G_+$ has a lower bound in $G_+$\", but we don't do that here. \\<close>\n",
        "assumes": "assumes \"r {down-directs} L\\<^sub>+\"\n  defines \"B \\<equiv> \\<Union>c\\<in>X. {disk(c,R). R\\<in>L\\<^sub>+}\"\n  ",
        "using": [
            "disk_definition",
            "radius_in_loop(4)",
            "disk_in_disk",
            "center_in_disk"
        ],
        "statement": "lemma (in pmetric_space) disks_form_base: \n  assumes \"r {down-directs} L\\<^sub>+\"\n  defines \"B \\<equiv> \\<Union>c\\<in>X. {disk(c,R). R\\<in>L\\<^sub>+}\"\n  shows \"B {satisfies the base condition}\"\n",
        "proof": "proof -\n  { fix U V assume \"U\\<in>B\" \"V\\<in>B\"\n    fix x assume \"x\\<in>U\\<inter>V\"\n    have \"\\<exists>W\\<in>B. x\\<in>W \\<and> W\\<subseteq>U\\<inter>V\"\n    proof -\n      from assms(2) \\<open>U\\<in>B\\<close> \\<open>V\\<in>B\\<close> obtain c\\<^sub>U  c\\<^sub>V R\\<^sub>U  R\\<^sub>V \n        where \"c\\<^sub>U \\<in> X\" \"R\\<^sub>U \\<in> L\\<^sub>+\" \"c\\<^sub>V \\<in> X\" \"R\\<^sub>V \\<in> L\\<^sub>+\" \"U = disk(c\\<^sub>U,R\\<^sub>U)\" \"V = disk(c\\<^sub>V,R\\<^sub>V)\"\n        by auto\n      with \\<open>x\\<in>U\\<inter>V\\<close> have \"x \\<in> disk(c\\<^sub>U,R\\<^sub>U)\" and \"x \\<in> disk(c\\<^sub>V,R\\<^sub>V)\" by auto\n      then have \"x\\<in>X\" \"d`\\<langle>c\\<^sub>U,x\\<rangle> \\<ls> R\\<^sub>U\" \"d`\\<langle>c\\<^sub>V,x\\<rangle> \\<ls> R\\<^sub>V\" using disk_definition by auto\n      let ?m\\<^sub>U = \"\\<rm> d`\\<langle>c\\<^sub>U,x\\<rangle> \\<ad> R\\<^sub>U\"\n      let ?m\\<^sub>V = \"\\<rm> d`\\<langle>c\\<^sub>V,x\\<rangle> \\<ad> R\\<^sub>V\"\n      from \\<open>c\\<^sub>U\\<in>X\\<close> \\<open>x\\<in>disk(c\\<^sub>U,R\\<^sub>U)\\<close> \\<open>c\\<^sub>V\\<in>X\\<close> \\<open>x\\<in>disk(c\\<^sub>V,R\\<^sub>V)\\<close> have \"?m\\<^sub>U\\<in>L\\<^sub>+\" and \"?m\\<^sub>V\\<in>L\\<^sub>+\" \n        using radius_in_loop(4) by auto\n      with assms(1) obtain m where \"m \\<in> L\\<^sub>+\" \"m \\<lsq> ?m\\<^sub>U\" \"m \\<lsq> ?m\\<^sub>V\"\n        unfolding DownDirects_def by auto\n      let ?W = \"disk(x,m)\"\n      from \\<open>m \\<in> L\\<^sub>+\\<close> \\<open>m \\<lsq> ?m\\<^sub>U\\<close> \\<open>m \\<lsq> ?m\\<^sub>V\\<close> \n        \\<open>c\\<^sub>U \\<in> X\\<close> \\<open>x \\<in> disk(c\\<^sub>U,R\\<^sub>U)\\<close> \\<open>c\\<^sub>V \\<in> X\\<close> \\<open>x \\<in> disk(c\\<^sub>V,R\\<^sub>V)\\<close> \n        \\<open>U = disk(c\\<^sub>U,R\\<^sub>U)\\<close> \\<open>V = disk(c\\<^sub>V,R\\<^sub>V)\\<close>\n        have \"?W \\<subseteq> U\\<inter>V\" using disk_in_disk by blast\n      moreover from assms(2) \\<open>x\\<in>X\\<close> \\<open>m \\<in> L\\<^sub>+\\<close> have \"?W \\<in> B\" and \"x\\<in>?W\" using center_in_disk\n        by auto\n      ultimately show ?thesis by auto\n    qed      \n  } then show ?thesis unfolding SatisfiesBaseCondition_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1114
    },
    "1000": {
        "type": "lemma",
        "text": "text\\<open> If we have a loop element that is smaller than the distance between two points, then\n  we can separate these points with disks.\\<close>\n",
        "assumes": "assumes \"x\\<in>X\" \"y\\<in>X\" \"r\\<^sub>x\\<ls>d`\\<langle>x,y\\<rangle>\"\n  ",
        "using": [
            "ls_other_side",
            "posset_definition1",
            "less_members(1)",
            "pmetric_loop_valued(2)",
            "lrdiv_props(6)",
            "loop_ord_refl",
            "far_disks"
        ],
        "statement": "lemma (in pmetric_space) disjoint_disks:\n  assumes \"x\\<in>X\" \"y\\<in>X\" \"r\\<^sub>x\\<ls>d`\\<langle>x,y\\<rangle>\"\n  shows \"(\\<rm>r\\<^sub>x\\<ad>(d`\\<langle>x,y\\<rangle>)) \\<in> L\\<^sub>+\" and \"disk(x,r\\<^sub>x)\\<inter>disk(y,\\<rm>r\\<^sub>x\\<ad>(d`\\<langle>x,y\\<rangle>)) = 0\"\n",
        "proof": "proof -\n  from assms(3) show \"(\\<rm>r\\<^sub>x\\<ad>(d`\\<langle>x,y\\<rangle>)) \\<in> L\\<^sub>+\"\n    using ls_other_side posset_definition1 by simp\n  from assms(1,2,3) have \"r\\<^sub>x\\<in>L\" and \"d`\\<langle>x,y\\<rangle> \\<in> L\" \n    using less_members(1) pmetric_loop_valued(2) by auto\n  then have \"r\\<^sub>x\\<ra>(\\<rm>r\\<^sub>x\\<ad>(d`\\<langle>x,y\\<rangle>)) = d`\\<langle>x,y\\<rangle>\" using lrdiv_props(6) by simp\n  with assms(1,2) \\<open>d`\\<langle>x,y\\<rangle> \\<in> L\\<close> show \"disk(x,r\\<^sub>x)\\<inter>disk(y,\\<rm>r\\<^sub>x\\<ad>(d`\\<langle>x,y\\<rangle>)) = 0\"\n    using loop_ord_refl far_disks by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1115
    },
    "1001": {
        "type": "theorem",
        "text": "text\\<open>Unions of disks form a topology, hence (pseudo)metric spaces are topological spaces. \\<close>\n",
        "assumes": "assumes  \"r {down-directs} L\\<^sub>+\" \n  defines \"B \\<equiv> \\<Union>c\\<in>X. {disk(c,R). R\\<in>L\\<^sub>+}\" \n  defines \"T \\<equiv> {\\<Union>A. A \\<in> Pow(B)}\"\n  ",
        "using": [
            "disks_form_base",
            "Top_1_2_T1",
            "Top_1_2_L5",
            "disk_definition",
            "center_in_disk"
        ],
        "statement": "theorem (in pmetric_space) pmetric_is_top: \n  assumes  \"r {down-directs} L\\<^sub>+\" \n  defines \"B \\<equiv> \\<Union>c\\<in>X. {disk(c,R). R\\<in>L\\<^sub>+}\" \n  defines \"T \\<equiv> {\\<Union>A. A \\<in> Pow(B)}\"\n  shows \"T {is a topology}\"  \"B {is a base for} T\"  \"\\<Union>T = X\"\n",
        "proof": "proof -\n  from assms  show  \"T {is a topology}\"  \"B {is a base for} T\" \n    using disks_form_base Top_1_2_T1 by auto\n  then have \"\\<Union>T = \\<Union>B\" using Top_1_2_L5 by simp\n  moreover have \"\\<Union>B = X\"\n  proof\n    from assms(2) show \"\\<Union>B \\<subseteq> X\" using disk_definition by auto\n    { fix x assume \"x\\<in>X\"\n      from assms(1) obtain R where \"R\\<in>L\\<^sub>+\" unfolding DownDirects_def by blast\n      with assms(2) \\<open>x\\<in>X\\<close> have \"x \\<in> \\<Union>B\" using center_in_disk by auto\n    } thus \"X \\<subseteq> \\<Union>B\" by auto\n  qed \n  ultimately show \"\\<Union>T = X\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1116
    },
    "1002": {
        "type": "lemma",
        "text": "text\\<open>Distance of different points is greater than zero. \\<close>\n",
        "assumes": "assumes \"x\\<in>X\" \"y\\<in>X\" \"x\\<noteq>y\"\n  ",
        "using": [
            "pmetric_properties(1)",
            "apply_funtype",
            "Nonnegative_def",
            "ident_indisc",
            "posset_definition",
            "posset_definition1"
        ],
        "statement": "lemma (in metric_space) dist_pos: assumes \"x\\<in>X\" \"y\\<in>X\" \"x\\<noteq>y\"\n  shows \"\\<zero>\\<ls>d`\\<langle>x,y\\<rangle>\" \"d`\\<langle>x,y\\<rangle> \\<in> L\\<^sub>+\"\n",
        "proof": "proof -\n  from assms(1,2) have \"d`\\<langle>x,y\\<rangle> \\<in> L\\<^sup>+\" \n    using pmetric_properties(1) apply_funtype by simp  \n  then have \"\\<zero> \\<lsq> d`\\<langle>x,y\\<rangle>\" using Nonnegative_def by auto\n  with assms show \"d`\\<langle>x,y\\<rangle> \\<in> L\\<^sub>+\" and \"\\<zero>\\<ls>d`\\<langle>x,y\\<rangle>\" \n    using ident_indisc posset_definition posset_definition1 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1118
    },
    "1003": {
        "type": "lemma",
        "text": "text\\<open>The propositions proven in the \\<open>pmetric_space\\<close> context defined in \\<open>Metric_Space_ZF\\<close> theory \n  are valid in the \\<open>pmetric_space1\\<close> context. \\<close>\n",
        "assumes": "",
        "using": [
            "pmetricAssum",
            "reals_loop"
        ],
        "statement": "lemma (in pmetric_space1) pmetric_space_pmetric_space1_valid: \n  shows \"pmetric_space(\\<real>,Add,ROrd,\\<d>,X)\"\n  unfolding pmetric_space_def pmetric_space_axioms_def loop1_def\n  ",
        "proof": "using pmetricAssum reals_loop by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF_2"
        ],
        "source": "IsarMathLib/MetricSpace_ZF_1.thy",
        "id": 1120
    },
    "1004": {
        "type": "definition",
        "text": "text\\<open>It is convenient to have the collection of all open balls in given (p) metrics defined\n  as a separate notion.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in pmetric_space1) Open_Balls\n  where \"Open_Balls \\<equiv> \\<Union>c\\<in>X. {ball(c,r). r \\<in> \\<real>\\<^sub>+}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Real_ZF_2"
        ],
        "source": "IsarMathLib/MetricSpace_ZF_1.thy",
        "id": 1121
    },
    "1005": {
        "type": "definition",
        "text": "text\\<open>Topology on a metric space is defined as the collection of sets that are unions\n  of open balls of the (p)metric. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in pmetric_space1) Metric_Topology\n  where \"Metric_Topology \\<equiv> {\\<Union>A. A \\<in> Pow(Open_Balls)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Real_ZF_2"
        ],
        "source": "IsarMathLib/MetricSpace_ZF_1.thy",
        "id": 1122
    },
    "1006": {
        "type": "lemma",
        "text": "text\\<open>The propositions proven in the \\<open>metric_space\\<close> context defined in \\<open>Metric_Space_ZF\\<close> theory \n  are valid in the \\<open>metric_space1\\<close> context. \\<close>\n",
        "assumes": "",
        "using": [
            "pmetric_space_pmetric_space1_valid",
            "ident_indisc"
        ],
        "statement": "lemma (in metric_space1) metric_space_metric_space1_valid: \n  shows \"metric_space(\\<real>,Add,ROrd,\\<d>,X)\"\n  unfolding metric_space_def metric_space_axioms_def\n  ",
        "proof": "using pmetric_space_pmetric_space1_valid ident_indisc\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF_2"
        ],
        "source": "IsarMathLib/MetricSpace_ZF_1.thy",
        "id": 1123
    },
    "1007": {
        "type": "theorem",
        "text": "text\\<open>Since in the \\<open>pmetric_space1\\<close> context $\\mathfrak{d}$ is a pseudometrics\n  the (p)metric topology as defined above is indeed a topology,\n  the set of open balls is the base of that topology and the carrier of the\n  topology is the underlying (p)metric space carrier $X$. \\<close>\n",
        "assumes": "",
        "using": [
            "rord_down_directs",
            "pmetric_space_pmetric_space1_valid",
            "pmetric_space.pmetric_is_top"
        ],
        "statement": "theorem (in pmetric_space1) rpmetric_is_top:\n  shows \n    \"Metric_Topology {is a topology}\"\n    \"Open_Balls {is a base for} Metric_Topology\"\n    \"\\<Union> Metric_Topology = X\"\n  unfolding Open_Balls_def Metric_Topology_def\n  ",
        "proof": "using rord_down_directs pmetric_space_pmetric_space1_valid \n    pmetric_space.pmetric_is_top by simp_all\n",
        "imports": [
            "IsarMathLib.Real_ZF_2"
        ],
        "source": "IsarMathLib/MetricSpace_ZF_1.thy",
        "id": 1124
    },
    "1008": {
        "type": "theorem",
        "text": "text\\<open>The topology generated by a metric is Hausdorff (i.e. $T_2$). \\<close>\n",
        "assumes": "",
        "using": [
            "rord_down_directs",
            "metric_space_metric_space1_valid",
            "metric_space.metric_space_T2"
        ],
        "statement": "theorem (in metric_space1) rmetric_space_T2: shows \"Metric_Topology {is T\\<^sub>2}\"\n  unfolding Open_Balls_def Metric_Topology_def\n  ",
        "proof": "using rord_down_directs metric_space_metric_space1_valid\n    metric_space.metric_space_T2 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF_2"
        ],
        "source": "IsarMathLib/MetricSpace_ZF_1.thy",
        "id": 1125
    },
    "1009": {
        "type": "definition",
        "text": "text\\<open>Monoid is a set $G$ with an associative operation and a neutral element.\n  The operation is a function on $G\\times G$ with values in $G$. \n  In the context of ZF set theory this means that it is a set of pairs\n  $\\langle x,y \\rangle$, where $x\\in G\\times G$ and $y\\in G$. In other words \n  the operation is a certain subset of $(G\\times G)\\times G$. We express\n  all this by defing a predicate \\<open>IsAmonoid(G,f)\\<close>. Here $G$ is the \n ''carrier'' of the monoid and $f$ is the binary operation on it.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAmonoid(G,f) \\<equiv>\n  f {is associative on} G \\<and> \n  (\\<exists>e\\<in>G. (\\<forall>g\\<in>G. ( (f`(\\<langle>e,g\\<rangle>) = g) \\<and> (f`(\\<langle>g,e\\<rangle>) = g))))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1126
    },
    "1010": {
        "type": "lemma",
        "text": "text\\<open>Propositions proven in the \\<open>semigr0\\<close> locale are valid in the \\<open>monoid0\\<close> locale.\\<close>\n",
        "assumes": "",
        "using": [
            "monoidAssum",
            "IsAmonoid_def",
            "semigr0_def"
        ],
        "statement": "lemma (in monoid0) semigr0_valid_in_monoid0: shows \"semigr0(G,f)\"\n  ",
        "proof": "using monoidAssum IsAmonoid_def semigr0_def by simp\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1127
    },
    "1011": {
        "type": "lemma",
        "text": "text\\<open>The result of the monoid operation is in the monoid (carrier).\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" ",
        "using": [
            "assms",
            "monoidAssum",
            "IsAmonoid_def",
            "IsAssociative_def",
            "apply_funtype"
        ],
        "statement": "lemma (in monoid0) group0_1_L1: \n  assumes \"a\\<in>G\"  \"b\\<in>G\" shows \"a\\<oplus>b \\<in> G\" \n  ",
        "proof": "using assms monoidAssum IsAmonoid_def IsAssociative_def apply_funtype\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1128
    },
    "1012": {
        "type": "lemma",
        "text": "text\\<open>There is only one neutral element in a monoid.\\<close>\n",
        "assumes": "",
        "using": [
            "IsAmonoid_def"
        ],
        "statement": "lemma (in monoid0) group0_1_L2: shows\n  \"\\<exists>!e. e\\<in>G \\<and> (\\<forall> g\\<in>G. ( (e\\<oplus>g = g) \\<and> g\\<oplus>e = g))\"\n",
        "proof": "proof\n  fix e y\n  assume \"e \\<in> G \\<and> (\\<forall>g\\<in>G. e \\<oplus> g = g \\<and> g \\<oplus> e = g)\"\n    and \"y \\<in> G \\<and> (\\<forall>g\\<in>G. y \\<oplus> g = g \\<and> g \\<oplus> y = g)\"\n  then have \"y\\<oplus>e = y\" \"y\\<oplus>e = e\" by auto\n  thus \"e = y\" by simp\nnext from monoidAssum show \n    \"\\<exists>e. e\\<in> G \\<and> (\\<forall> g\\<in>G. e\\<oplus>g = g \\<and> g\\<oplus>e = g)\"\n    using IsAmonoid_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1129
    },
    "1013": {
        "type": "lemma",
        "text": "text\\<open>The neutral element is neutral.\\<close>\n",
        "assumes": "assumes A1: \"e = TheNeutralElement(G,f)\"\n  ",
        "using": [
            "group0_1_L2",
            "TheNeutralElement_def"
        ],
        "statement": "lemma (in monoid0) unit_is_neutral:\n  assumes A1: \"e = TheNeutralElement(G,f)\"\n  shows \"e \\<in> G \\<and> (\\<forall>g\\<in>G. e \\<oplus> g = g \\<and> g \\<oplus> e = g)\"\n",
        "proof": "proof -\n  let ?n = \"THE b. b\\<in> G \\<and> (\\<forall> g\\<in>G. b\\<oplus>g = g \\<and> g\\<oplus>b = g)\"\n  have \"\\<exists>!b. b\\<in> G \\<and> (\\<forall> g\\<in>G. b\\<oplus>g = g \\<and> g\\<oplus>b = g)\"\n    using group0_1_L2 by simp\n  then have \"?n\\<in> G \\<and> (\\<forall> g\\<in>G. ?n\\<oplus>g = g \\<and> g\\<oplus>?n = g)\"\n    by (rule theI)\n  with A1 show ?thesis \n    using TheNeutralElement_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1130
    },
    "1014": {
        "type": "lemma",
        "text": "text\\<open>The monoid carrier is not empty.\\<close>\n",
        "assumes": "",
        "using": [
            "unit_is_neutral"
        ],
        "statement": "lemma (in monoid0) group0_1_L3A: shows \"G\\<noteq>0\"\n",
        "proof": "proof -\n  have \"TheNeutralElement(G,f) \\<in> G\" using unit_is_neutral\n    by simp\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1131
    },
    "1015": {
        "type": "lemma",
        "text": "text\\<open>The range of the monoid operation is the whole monoid carrier.\\<close>\n",
        "assumes": "",
        "using": [
            "IsAmonoid_def",
            "IsAssociative_def",
            "func1_1_L5B",
            "unit_is_neutral",
            "func1_1_L5A"
        ],
        "statement": "lemma (in monoid0) group0_1_L3B: shows \"range(f) = G\"\n",
        "proof": "proof\n  from monoidAssum have \"f : G\\<times>G\\<rightarrow>G\"\n     using IsAmonoid_def IsAssociative_def by simp\n  then show \"range(f) \\<subseteq> G\" \n    using func1_1_L5B by simp\n  show \"G \\<subseteq> range(f)\"\n  proof\n    fix g assume A1: \"g\\<in>G\"\n    let ?e = \"TheNeutralElement(G,f)\"\n    from A1 have \"\\<langle>?e,g\\<rangle> \\<in> G\\<times>G\" \"g = f`\\<langle>?e,g\\<rangle>\"\n      using unit_is_neutral by auto\n    with \\<open>f : G\\<times>G\\<rightarrow>G\\<close> show \"g \\<in> range(f)\"\n      using func1_1_L5A by blast\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1132
    },
    "1016": {
        "type": "lemma",
        "text": "text\\<open>Another way to state that the range of the monoid operation\n  is the whole monoid carrier.\\<close>\n",
        "assumes": "",
        "using": [
            "monoidAssum",
            "IsAmonoid_def",
            "IsAssociative_def",
            "group0_1_L3B",
            "range_image_domain"
        ],
        "statement": "lemma (in monoid0) range_carr: shows \"f``(G\\<times>G) = G\"\n  ",
        "proof": "using monoidAssum IsAmonoid_def IsAssociative_def\n    group0_1_L3B range_image_domain by auto\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1133
    },
    "1017": {
        "type": "lemma",
        "text": "text\\<open>In a monoid any neutral element is the neutral element.\\<close>\n",
        "assumes": "assumes A1: \"e \\<in> G \\<and> (\\<forall>g\\<in>G. e \\<oplus> g = g \\<and> g \\<oplus> e = g)\"\n  ",
        "using": [
            "group0_1_L2",
            "TheNeutralElement_def"
        ],
        "statement": "lemma (in monoid0) group0_1_L4: \n  assumes A1: \"e \\<in> G \\<and> (\\<forall>g\\<in>G. e \\<oplus> g = g \\<and> g \\<oplus> e = g)\"\n  shows \"e = TheNeutralElement(G,f)\"\n",
        "proof": "proof -\n  let ?n = \"THE b. b\\<in> G \\<and> (\\<forall> g\\<in>G. b\\<oplus>g = g \\<and> g\\<oplus>b = g)\"\n  have \"\\<exists>!b. b\\<in> G \\<and> (\\<forall> g\\<in>G. b\\<oplus>g = g \\<and> g\\<oplus>b = g)\"\n    using group0_1_L2 by simp\n  moreover note A1\n  ultimately have \"?n = e\" by (rule the_equality2)\n  then show ?thesis using TheNeutralElement_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1134
    },
    "1018": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows that if the if we restrict the monoid operation to\n  a subset of $G$ that contains the neutral element, then the \n  neutral element of the monoid operation is also neutral with the \n  restricted operation. \\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>H.\\<forall>y\\<in>H. x\\<oplus>y \\<in> H\"\n  and A2: \"H\\<subseteq>G\"\n  and A3: \"e = TheNeutralElement(G,f)\"\n  and A4: \"g = restrict(f,H\\<times>H)\"\n  and A5: \"e\\<in>H\"\n  and A6: \"h\\<in>H\"\n  ",
        "using": [
            "restrict_if",
            "unit_is_neutral"
        ],
        "statement": "lemma (in monoid0) group0_1_L5:\n  assumes A1: \"\\<forall>x\\<in>H.\\<forall>y\\<in>H. x\\<oplus>y \\<in> H\"\n  and A2: \"H\\<subseteq>G\"\n  and A3: \"e = TheNeutralElement(G,f)\"\n  and A4: \"g = restrict(f,H\\<times>H)\"\n  and A5: \"e\\<in>H\"\n  and A6: \"h\\<in>H\"\n  shows \"g`\\<langle>e,h\\<rangle> = h \\<and> g`\\<langle>h,e\\<rangle> = h\"\n",
        "proof": "proof -\n  from A4 A6 A5 have \n    \"g`\\<langle>e,h\\<rangle> = e\\<oplus>h \\<and> g`\\<langle>h,e\\<rangle> = h\\<oplus>e\"\n    using restrict_if by simp\n  with A3 A4 A6 A2 show \n    \"g`\\<langle>e,h\\<rangle> = h \\<and> g`\\<langle>h,e\\<rangle> = h\"\n    using  unit_is_neutral by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1135
    },
    "1019": {
        "type": "theorem",
        "text": "text\\<open>The next theorem shows that if the monoid operation is closed\n  on a subset of $G$ then this set is a (sub)monoid (although \n  we do not define this notion). This fact will be \n  useful when we study subgroups.\\<close>\n",
        "assumes": "assumes A1: \"H {is closed under} f\"\n  and A2: \"H\\<subseteq>G\"\n  and A3: \"TheNeutralElement(G,f) \\<in> H\"\n  ",
        "using": [
            "IsAmonoid_def",
            "IsAssociative_def",
            "IsOpClosed_def",
            "func1_2_L4",
            "restrict_if",
            "group0_1_L5"
        ],
        "statement": "theorem (in monoid0) group0_1_T1: \n  assumes A1: \"H {is closed under} f\"\n  and A2: \"H\\<subseteq>G\"\n  and A3: \"TheNeutralElement(G,f) \\<in> H\"\n  shows  \"IsAmonoid(H,restrict(f,H\\<times>H))\"\n",
        "proof": "proof -\n  let ?g = \"restrict(f,H\\<times>H)\"\n  let ?e = \"TheNeutralElement(G,f)\"\n  from monoidAssum have \"f \\<in> G\\<times>G\\<rightarrow>G\" \n    using IsAmonoid_def IsAssociative_def by simp\n  moreover from A2 have \"H\\<times>H \\<subseteq> G\\<times>G\" by auto\n  moreover from A1 have \"\\<forall>p \\<in> H\\<times>H. f`(p) \\<in> H\"\n    using IsOpClosed_def by auto\n  ultimately have \"?g \\<in> H\\<times>H\\<rightarrow>H\"\n    using func1_2_L4 by simp\n  moreover have \"\\<forall>x\\<in>H.\\<forall>y\\<in>H.\\<forall>z\\<in>H. \n    ?g`\\<langle>?g`\\<langle>x,y\\<rangle> ,z\\<rangle> = ?g`\\<langle>x,?g`\\<langle>y,z\\<rangle>\\<rangle>\"\n  proof -\n    from A1 have \"\\<forall>x\\<in>H.\\<forall>y\\<in>H.\\<forall>z\\<in>H.\n      ?g`\\<langle>?g`\\<langle>x,y\\<rangle>,z\\<rangle> = x\\<oplus>y\\<oplus>z\"\n      using IsOpClosed_def restrict_if by simp\n    moreover have \"\\<forall>x\\<in>H.\\<forall>y\\<in>H.\\<forall>z\\<in>H. x\\<oplus>y\\<oplus>z = x\\<oplus>(y\\<oplus>z)\"\n    proof -\n      from monoidAssum have \n\t\"\\<forall>x\\<in>G.\\<forall>y\\<in>G.\\<forall>z\\<in>G. x\\<oplus>y\\<oplus>z = x\\<oplus>(y\\<oplus>z)\"\n\tusing IsAmonoid_def IsAssociative_def \n\tby simp\n      with A2 show ?thesis by auto\n    qed\n    moreover from A1 have \n      \"\\<forall>x\\<in>H.\\<forall>y\\<in>H.\\<forall>z\\<in>H. x\\<oplus>(y\\<oplus>z) = ?g`\\<langle> x,?g`\\<langle>y,z\\<rangle> \\<rangle>\"\n      using IsOpClosed_def restrict_if by simp\n    ultimately show ?thesis by simp \n  qed\n  moreover have \n    \"\\<exists>n\\<in>H. (\\<forall>h\\<in>H. ?g`\\<langle>n,h\\<rangle> = h \\<and> ?g`\\<langle>h,n\\<rangle> = h)\"\n  proof -\n    from A1 have \"\\<forall>x\\<in>H.\\<forall>y\\<in>H. x\\<oplus>y \\<in> H\"\n      using IsOpClosed_def by simp\n    with A2 A3 have \n      \"\\<forall> h\\<in>H. ?g`\\<langle>?e,h\\<rangle> = h \\<and> ?g`\\<langle>h,?e\\<rangle> = h\"\n      using group0_1_L5 by blast\n    with A3 show ?thesis by auto\n  qed\n  ultimately show ?thesis using IsAmonoid_def IsAssociative_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1136
    },
    "1020": {
        "type": "lemma",
        "text": "text\\<open>Under the assumptions of \\<open>group0_1_T1\\<close>\n  the neutral element of a \n  submonoid is the same as that of the monoid.\\<close>\n",
        "assumes": "assumes A1: \"IsAmonoid(G,f)\"\n  and A2: \"H {is closed under} f\"\n  and A3: \"H\\<subseteq>G\"\n  and A4: \"TheNeutralElement(G,f) \\<in> H\"\n  ",
        "using": [
            "monoid0_def",
            "monoid0.group0_1_T1",
            "IsOpClosed_def"
        ],
        "statement": "lemma group0_1_L6: \n  assumes A1: \"IsAmonoid(G,f)\"\n  and A2: \"H {is closed under} f\"\n  and A3: \"H\\<subseteq>G\"\n  and A4: \"TheNeutralElement(G,f) \\<in> H\"\n  shows \"TheNeutralElement(H,restrict(f,H\\<times>H)) = TheNeutralElement(G,f)\"\n",
        "proof": "proof -\n  let ?e = \"TheNeutralElement(G,f)\"\n  let ?g = \"restrict(f,H\\<times>H)\"\n  from assms have \"monoid0(H,?g)\"\n    using monoid0_def monoid0.group0_1_T1 \n    by simp\n  moreover have \n    \"?e \\<in> H \\<and> (\\<forall>h\\<in>H. ?g`\\<langle>?e,h\\<rangle> = h \\<and> ?g`\\<langle>h,?e\\<rangle> = h)\"\n  proof -\n    { fix h assume \"h \\<in> H\"\n      with assms have\n\t\"monoid0(G,f)\"  \"\\<forall>x\\<in>H.\\<forall>y\\<in>H. f`\\<langle>x,y\\<rangle> \\<in> H\" \n\t\"H\\<subseteq>G\"  \"?e = TheNeutralElement(G,f)\"  \"?g = restrict(f,H\\<times>H)\"\n\t\"?e \\<in> H\"  \"h \\<in> H\" \n\tusing monoid0_def IsOpClosed_def by auto\n      then have \"?g`\\<langle>?e,h\\<rangle> = h \\<and> ?g`\\<langle>h,?e\\<rangle> = h\"\n\tby (rule monoid0.group0_1_L5)\n    } hence \"\\<forall>h\\<in>H. ?g`\\<langle>?e,h\\<rangle> = h \\<and> ?g`\\<langle>h,?e\\<rangle> = h\" by simp\n    with A4 show ?thesis by simp\n  qed\n  ultimately have \"?e =  TheNeutralElement(H,?g)\"\n    by (rule monoid0.group0_1_L4)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1137
    },
    "1021": {
        "type": "lemma",
        "text": "text\\<open>If a sum of two elements is not zero, \n  then at least one has to be nonzero.\\<close>\n",
        "assumes": "assumes \"a \\<oplus> b \\<noteq> TheNeutralElement(G,f)\"\n  ",
        "using": [
            "assms",
            "unit_is_neutral"
        ],
        "statement": "lemma (in monoid0) sum_nonzero_elmnt_nonzero: \n  assumes \"a \\<oplus> b \\<noteq> TheNeutralElement(G,f)\"\n  shows \"a \\<noteq> TheNeutralElement(G,f) \\<or> b \\<noteq> TheNeutralElement(G,f)\"\n  ",
        "proof": "using assms unit_is_neutral by auto\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1138
    },
    "1022": {
        "type": "lemma",
        "text": "text\\<open>The monoid operation is associative.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\"\n  ",
        "using": [
            "assms",
            "monoidAssum",
            "IsAmonoid_def",
            "IsAssociative_def"
        ],
        "statement": "lemma (in monoid0) sum_associative:\n  assumes \"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\"\n  shows \"(a\\<oplus>b)\\<oplus>c = a\\<oplus>(b\\<oplus>c)\"\n  ",
        "proof": "using assms monoidAssum unfolding IsAmonoid_def IsAssociative_def\n  by auto\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1139
    },
    "1023": {
        "type": "lemma",
        "text": "text\\<open>Let's recall that the neutral element of the monoid is an element of the monoid (carrier) $G$\n  and the monoid operation ($f$ in our notation) is a function that maps $G\\times G$\n  to $G$.\\<close>\n",
        "assumes": "",
        "using": [
            "monoidAssum",
            "unit_is_neutral",
            "IsAmonoid_def",
            "IsAssociative_def"
        ],
        "statement": "lemma (in monoid1) zero_monoid_oper: shows \"\\<zero>\\<in>G\" and \"f:G\\<times>G \\<rightarrow> G\"\n  ",
        "proof": "using monoidAssum unit_is_neutral unfolding IsAmonoid_def IsAssociative_def \n  by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1141
    },
    "1024": {
        "type": "lemma",
        "text": "text\\<open>The sum of a list of monoid elements is a monoid element.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"\\<forall>k\\<in>n. q(k)\\<in>G\"\n  ",
        "using": [
            "zero_monoid_oper",
            "ZF_fun_from_total",
            "fold_props"
        ],
        "statement": "lemma (in monoid1) sum_in_mono: assumes \"n\\<in>nat\" \"\\<forall>k\\<in>n. q(k)\\<in>G\"\n  shows \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n}) \\<in> G\"\n",
        "proof": "proof -\n  let ?a = \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n}\"\n  from assms have \"n \\<in> nat\" \"f:G\\<times>G \\<rightarrow> G\" \"?a:n \\<rightarrow> G\" \"\\<zero>\\<in>G\" \"G\\<noteq>0\"\n    using zero_monoid_oper ZF_fun_from_total by auto\n  then show ?thesis using fold_props by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1142
    },
    "1025": {
        "type": "lemma",
        "text": "text\\<open>The reason we start from $0$ in the definition of the summation sign in the \\<open>monoid1\\<close> locale\n  is that we want to be able to sum the empty list. Such sum of the empty list is $0$. \\<close>\n",
        "assumes": "assumes \"s:0\\<rightarrow>G\" ",
        "using": [
            "assms",
            "zero_monoid_oper",
            "fold_empty",
            "group0_1_L3A"
        ],
        "statement": "lemma (in monoid1) sum_empty: assumes \"s:0\\<rightarrow>G\" shows \"(\\<Sum>s) = \\<zero>\"\n  ",
        "proof": "using assms zero_monoid_oper fold_empty group0_1_L3A by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1143
    },
    "1026": {
        "type": "lemma",
        "text": "text\\<open>For nonempty lists our $\\Sigma$ is the same as \\<open>Fold1\\<close>. \\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"s:succ(n)\\<rightarrow>G\"\n  ",
        "using": [
            "empty_in_every_succ",
            "apply_funtype",
            "zero_monoid_oper",
            "fold_detach_first",
            "unit_is_neutral"
        ],
        "statement": "lemma (in monoid1) sum_nonempty:  assumes \"n \\<in> nat\" \"s:succ(n)\\<rightarrow>G\"\n  shows \n    \"(\\<Sum>s) = Fold(f,s`(0),Tail(s))\"\n    \"(\\<Sum>s) = Fold1(f,s)\"\n",
        "proof": "proof -\n  from assms have \"s`(0) \\<in> G\" using empty_in_every_succ apply_funtype \n    by simp\n  with assms have \"(\\<Sum>s) = Fold(f,\\<zero>\\<oplus>s`(0),Tail(s))\"\n    using zero_monoid_oper fold_detach_first by simp\n  with \\<open>s`(0) \\<in> G\\<close> show \"(\\<Sum>s) = Fold(f,s`(0),Tail(s))\"\n    using unit_is_neutral by simp\n  then show \"(\\<Sum>s) = Fold1(f,s)\" unfolding Fold1_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1144
    },
    "1027": {
        "type": "lemma",
        "text": "text\\<open>We can pull the first component of a sum of a nonempty list of monoid elements\n  before the summation sign. \\<close>  \n",
        "assumes": "assumes \"n \\<in> nat\" \"s:succ(n)\\<rightarrow>G\"\n  ",
        "using": [
            "empty_in_every_succ",
            "apply_funtype",
            "tail_props(1)",
            "sum_nonempty(1)",
            "sum_empty",
            "zero_monoid_oper(2)",
            "group0_1_L3A",
            "fold_empty",
            "unit_is_neutral",
            "Nat_ZF_1_L3",
            "pair_func_singleton",
            "succ_explained",
            "semigr0_valid_in_monoid0",
            "semigr0.prod_conc_distr",
            "semigr0.prod_of_1elem",
            "pair_val",
            "sum_nonempty(2)",
            "first_concat_tail"
        ],
        "statement": "lemma (in monoid1) seq_sum_pull_first0: assumes \"n \\<in> nat\" \"s:succ(n)\\<rightarrow>G\"\n  shows \"(\\<Sum>s) = s`(0) \\<oplus> (\\<Sum>Tail(s))\"\n",
        "proof": "proof -\n  from assms have \"s`(0) \\<in> G\" using empty_in_every_succ apply_funtype \n    by simp\n  { assume \"n=0\"\n    with assms have \"Tail(s):0\\<rightarrow>G\" using tail_props(1) by blast\n    with assms \\<open>s`(0) \\<in> G\\<close> have \"(\\<Sum>s) = s`(0) \\<oplus> (\\<Sum>Tail(s))\"\n      using sum_nonempty(1) sum_empty zero_monoid_oper(2) group0_1_L3A \n        fold_empty unit_is_neutral by simp\n  }\n  moreover\n  { assume \"n\\<noteq>0\"\n    with assms(1) obtain m where \"m\\<in>nat\" and \"n = succ(m)\"\n      using Nat_ZF_1_L3 by blast\n    with assms have \"Tail(s):succ(m)\\<rightarrow>G\" using tail_props(1) \n      by simp\n    let ?a = \"{\\<langle>0,s`(0)\\<rangle>}\"\n    from \\<open>s`(0) \\<in> G\\<close> have \"0\\<in>nat\" \"?a:succ(0)\\<rightarrow>G\"\n      using pair_func_singleton succ_explained by simp_all\n    with \\<open>m\\<in>nat\\<close> \\<open>Tail(s):succ(m)\\<rightarrow>G\\<close> \n    have \"f`\\<langle>Fold1(f,?a),Fold1(f,Tail(s))\\<rangle> = Fold1(f,Concat(?a,Tail(s)))\"\n      using semigr0_valid_in_monoid0 semigr0.prod_conc_distr\n      by blast\n    with assms \\<open>?a:succ(0)\\<rightarrow>G\\<close> \\<open>m\\<in>nat\\<close> \\<open>Tail(s):succ(m)\\<rightarrow>G\\<close> \n    have \"(\\<Sum>s) = s`(0) \\<oplus> (\\<Sum>Tail(s))\" \n      using semigr0_valid_in_monoid0 semigr0.prod_of_1elem pair_val \n        sum_nonempty(2) first_concat_tail by simp\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1145
    },
    "1028": {
        "type": "theorem",
        "text": "text\\<open>The first assertion of the next theorem is similar in content to \\<open>seq_sum_pull_first0\\<close> \n  formulated in terms of the expression defining the list of monoid elements. The second\n  one shows the dual statement: the last element of a sequence can be pulled out of the\n  sequence and put after the summation sign. So, we are showing here that \n  $\\sum_{k=0}^{n} q_k = q_0 \\oplus \\sum_{k=0}^{n-1} q_{k+1} = (\\sum_{k=0}^{n-1} q_k) \\oplus q_n. $ \\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> G\"\n  ",
        "using": [
            "empty_in_every_succ",
            "succ_add_one(1)",
            "seq_sum_pull_first0",
            "tail_formula",
            "zero_monoid_oper",
            "fold_detach_last"
        ],
        "statement": "theorem (in monoid1) seq_sum_pull_one_elem: \n  assumes \"n \\<in> nat\" \"\\<forall>k\\<in>n #+ 1. q(k) \\<in> G\"\n  shows \n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}) = q(0) \\<oplus> (\\<Sum>{\\<langle>k,q(k #+ 1)\\<rangle>. k\\<in>n})\"\n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}) = (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n}) \\<oplus> q(n)\"\n",
        "proof": "proof -\n  let ?s = \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}\"\n  from assms(1) have \"0 \\<in> n #+ 1\" using empty_in_every_succ succ_add_one(1)\n    by simp\n  then have \"?s`(0) = q(0)\" by (rule ZF_fun_from_tot_val1)\n  from assms(2) have \"?s: n #+ 1 \\<rightarrow> G\" by (rule ZF_fun_from_total)\n  with assms(1) \\<open>?s`(0) = q(0)\\<close> have \"(\\<Sum>?s) = q(0) \\<oplus> (\\<Sum>Tail(?s))\"\n    using seq_sum_pull_first0 by simp\n  moreover from assms have \"Tail(?s) = {\\<langle>k,q(k #+ 1)\\<rangle>. k \\<in> n}\"\n    using tail_formula by simp\n  ultimately show \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}) =  q(0) \\<oplus> (\\<Sum>{\\<langle>k,q(k #+ 1)\\<rangle>. k\\<in>n})\" \n    by simp\n  from assms show \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n #+ 1}) =  (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n}) \\<oplus> q(n)\"\n    using zero_monoid_oper fold_detach_last by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1146
    },
    "1029": {
        "type": "lemma",
        "text": "text\\<open>The sum of a singleton list is its only element,\\<close>\n",
        "assumes": "assumes \"q(0) \\<in> G\"\n  ",
        "using": [
            "sum_empty",
            "unit_is_neutral"
        ],
        "statement": "lemma (in monoid1) seq_sum_singleton: assumes \"q(0) \\<in> G\"\n  shows \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>1}) = q(0)\"\n",
        "proof": "proof -\n  from assms have \"0\\<in>nat\" and \"\\<forall>k\\<in>0 #+ 1. q(k) \\<in> G\" by simp_all\n  then have \n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>0 #+ 1}) = q(0) \\<oplus> (\\<Sum>{\\<langle>k,q(k #+ 1)\\<rangle>. k\\<in>0})\"\n    by (rule seq_sum_pull_one_elem)\n  with assms show ?thesis using sum_empty unit_is_neutral by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1147
    },
    "1030": {
        "type": "lemma",
        "text": "text\\<open>If the monoid operation is commutative, then the sum of a nonempty sequence\n  added to another sum of a nonempty sequence of the same length is equal \n  to the sum of pointwise sums of the sequence elements. \n  This is the same as the theorem \\<open>prod_comm_distrib\\<close> from the \n  \\<open>Semigroup_ZF\\<close> theory, just written in the notation used in the \\<open>monoid1\\<close> locale.\\<close>\n",
        "assumes": "assumes  \"f {is commutative on} G\" \"n\\<in>nat\" and\n  \"a : n #+ 1 \\<rightarrow> G\"  \"b : n #+ 1 \\<rightarrow> G\"  \"c : n #+ 1 \\<rightarrow> G\" and\n  \"\\<forall>j\\<in>n #+ 1. c`(j) = a`(j) \\<oplus> b`(j)\"\n  ",
        "using": [
            "assms",
            "succ_add_one(1)",
            "sum_nonempty",
            "semigr0_valid_in_monoid0",
            "semigr0.prod_comm_distrib"
        ],
        "statement": "lemma (in monoid1) sum_comm_distrib0:\n  assumes  \"f {is commutative on} G\" \"n\\<in>nat\" and\n  \"a : n #+ 1 \\<rightarrow> G\"  \"b : n #+ 1 \\<rightarrow> G\"  \"c : n #+ 1 \\<rightarrow> G\" and\n  \"\\<forall>j\\<in>n #+ 1. c`(j) = a`(j) \\<oplus> b`(j)\"\n  shows \"(\\<Sum> c) = (\\<Sum> a) \\<oplus> (\\<Sum> b)\"\n  ",
        "proof": "using assms succ_add_one(1) sum_nonempty \n    semigr0_valid_in_monoid0 semigr0.prod_comm_distrib by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1148
    },
    "1031": {
        "type": "theorem",
        "text": "text\\<open>Another version of \\<open>sum_comm_distrib0\\<close> written in terms of the expressions\n  defining the sequences, shows that for commutative monoids we have \n  $\\sum_{k=0}^{n-1}q(k) \\oplus p(k) = (\\sum_{k=0}^{n-1} p(k))\\oplus (\\sum_{k=0}^{n-1} q(k))$. \\<close>\n",
        "assumes": "assumes  \"f {is commutative on} G\" \"n\\<in>nat\" and\n  \"\\<forall>k\\<in>n. p(k) \\<in> G\" \"\\<forall>k\\<in>n. q(k) \\<in> G\"\n  ",
        "using": [
            "sum_empty",
            "unit_is_neutral",
            "nat_not0_succ",
            "group0_1_L1",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val1",
            "sum_comm_distrib0"
        ],
        "statement": "theorem (in monoid1) sum_comm_distrib: \n  assumes  \"f {is commutative on} G\" \"n\\<in>nat\" and\n  \"\\<forall>k\\<in>n. p(k) \\<in> G\" \"\\<forall>k\\<in>n. q(k) \\<in> G\"\n  shows \n    \"(\\<Sum>{\\<langle>k,p(k)\\<oplus>q(k)\\<rangle>. k\\<in>n}) = (\\<Sum>{\\<langle>k,p(k)\\<rangle>. k\\<in>n}) \\<oplus> (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n})\" \n",
        "proof": "proof -\n  let ?a = \"{\\<langle>k,p(k)\\<rangle>. k\\<in>n}\"\n  let ?b = \"{\\<langle>k,q(k)\\<rangle>. k\\<in>n}\"\n  let ?c = \"{\\<langle>k,p(k)\\<oplus>q(k)\\<rangle>. k\\<in>n}\"\n  { assume \"n=0\"\n    then have \"(\\<Sum>?c) = (\\<Sum>?a) \\<oplus> (\\<Sum>?b)\"\n      using sum_empty unit_is_neutral by simp\n  }\n  moreover\n  { assume \"n\\<noteq>0\"\n    with assms(2) obtain m where \"m\\<in>nat\" and  \"n = m #+ 1\"\n      using nat_not0_succ by blast\n    from assms(3,4) have \"?a:n\\<rightarrow>G\" \"?b:n\\<rightarrow>G\" \"?c:n\\<rightarrow>G\" \n      using group0_1_L1 ZF_fun_from_total by simp_all\n    with assms(1) \\<open>m\\<in>nat\\<close> \\<open>n = m #+ 1\\<close> have \n      \"f {is commutative on} G\" \"m\\<in>nat\" and\n      \"?a:m #+ 1\\<rightarrow>G\" \"?b:m #+ 1\\<rightarrow>G\" \"?c:m #+ 1\\<rightarrow>G\"\n      by simp_all\n    moreover have \"\\<forall>k\\<in>m #+ 1. ?c`(k) = ?a`(k) \\<oplus> ?b`(k)\"\n    proof -\n      { fix k assume \"k \\<in> m #+ 1\"\n        with \\<open>n = m #+ 1\\<close> have \"k\\<in>n\" by simp\n        then have \"?c`(k) = ?a`(k) \\<oplus> ?b`(k)\"\n          using ZF_fun_from_tot_val1 by simp_all\n      } thus ?thesis by simp\n    qed\n    ultimately have \"(\\<Sum>?c) = (\\<Sum>?a) \\<oplus> (\\<Sum>?b)\"\n      using sum_comm_distrib0 by simp\n  }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1149
    },
    "1032": {
        "type": "lemma",
        "text": "text\\<open>Any multiple of a monoid element is a monoid element.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>G\"\n  ",
        "using": [
            "assms",
            "sum_in_mono"
        ],
        "statement": "lemma (in monoid1) nat_mult_type: assumes \"n\\<in>nat\" \"x\\<in>G\"\n  shows \"n\\<cdot>x \\<in> G\" ",
        "proof": "using assms sum_in_mono by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1151
    },
    "1033": {
        "type": "lemma",
        "text": "text\\<open>Taking one more multiple of $x$ adds $x$. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>G\" \n  ",
        "using": [],
        "statement": "lemma (in monoid1) nat_mult_add_one: assumes \"n\\<in>nat\" \"x\\<in>G\" \n  shows \"(n #+ 1)\\<cdot>x = n\\<cdot>x \\<oplus> x\" and \"(n #+ 1)\\<cdot>x = x \\<oplus> n\\<cdot>x\"\n",
        "proof": "proof -\n  from assms(2) have I: \"\\<forall>k\\<in>n #+ 1. x \\<in> G\" by simp\n  with assms(1) have \"(\\<Sum>{\\<langle>k,x\\<rangle>. k \\<in> n #+ 1}) = x \\<oplus> (\\<Sum>{\\<langle>k,x\\<rangle>. k\\<in>n})\"\n    by (rule seq_sum_pull_one_elem)\n  thus \"(n #+ 1)\\<cdot>x = x \\<oplus> n\\<cdot>x\" by simp\n  from assms(1) I have \"(\\<Sum>{\\<langle>k,x\\<rangle>. k\\<in>n #+ 1}) =  (\\<Sum>{\\<langle>k,x\\<rangle>. k\\<in>n}) \\<oplus> x\"\n    by (rule seq_sum_pull_one_elem)\n  thus \"(n #+ 1)\\<cdot>x = n\\<cdot>x \\<oplus> x\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1152
    },
    "1034": {
        "type": "lemma",
        "text": "text\\<open>One element of a monoid is that element.\\<close>\n",
        "assumes": "assumes \"x\\<in>G\" ",
        "using": [
            "nat_mult_add_one(1)",
            "nat_mult_zero",
            "unit_is_neutral"
        ],
        "statement": "lemma (in monoid1) nat_mult_one: assumes \"x\\<in>G\" shows \"1\\<cdot>x = x\"\n",
        "proof": "proof -\n  from assms have \"(0 #+ 1)\\<cdot>x = 0\\<cdot>x \\<oplus> x\" using nat_mult_add_one(1) by blast\n  with assms show ?thesis using nat_mult_zero unit_is_neutral by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1153
    },
    "1035": {
        "type": "lemma",
        "text": "text\\<open>Multiplication of $x$ by a natural number induces a homomorphism between natural numbers \n  with addition and and the natural multiples of $x$. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"m\\<in>nat\" \"x\\<in>G\"\n  ",
        "using": [
            "nat_mult_type",
            "unit_is_neutral",
            "nat_mult_zero",
            "nat_mult_add_one(1)",
            "sum_associative"
        ],
        "statement": "lemma (in monoid1) nat_mult_add: assumes \"n\\<in>nat\" \"m\\<in>nat\" \"x\\<in>G\"\n  shows \"(n #+ m)\\<cdot>x = n\\<cdot>x \\<oplus> m\\<cdot>x\"\n",
        "proof": "proof -\n  from assms have \"m\\<in>nat\" and \"(n #+ 0)\\<cdot>x = n\\<cdot>x \\<oplus> 0\\<cdot>x\" \n    using nat_mult_type unit_is_neutral nat_mult_zero by simp_all\n  moreover from assms(1,3) have\n    \"\\<forall>k\\<in>nat. (n #+ k)\\<cdot>x = n\\<cdot>x \\<oplus> k\\<cdot>x \\<longrightarrow> (n #+ (k #+ 1))\\<cdot>x = n\\<cdot>x \\<oplus> (k #+ 1)\\<cdot>x\"\n     using nat_mult_type nat_mult_add_one(1) sum_associative by simp\n  ultimately show ?thesis by (rule ind_on_nat1)\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1154
    },
    "1036": {
        "type": "lemma",
        "text": "text \\<open>Naturals are a subset of integers.\\<close>\n",
        "assumes": "",
        "using": [
            "int_interpr.small_less_zf_newbig"
        ],
        "statement": "lemma \"nat \\<subseteq> int_obj\" ",
        "proof": "using int_interpr.small_less_zf_newbig by auto\n",
        "imports": [
            "ZF.Int",
            "IsarMathLib.Generalization_ZF"
        ],
        "source": "IsarMathLib/NatGenIntEx_ZF.thy",
        "id": 1155
    },
    "1037": {
        "type": "definition",
        "text": "text \\<open>An example of defining an operation on the generalization set.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition add where\n  \"add(x,y) \\<equiv> int_interpr.zf_move`(int_interpr.ret`x $+ int_interpr.ret`y)\"\n",
        "proof": "",
        "imports": [
            "ZF.Int",
            "IsarMathLib.Generalization_ZF"
        ],
        "source": "IsarMathLib/NatGenIntEx_ZF.thy",
        "id": 1156
    },
    "1038": {
        "type": "lemma",
        "text": "text\\<open>To prove that $\\leq$ is a total order, we use a result on ordinals.\\<close>\n",
        "assumes": "assumes \"a\\<in>nat\" and \"b\\<in>nat\"\n  ",
        "using": [
            "nat_into_Ord",
            "Ord_linear",
            "ltI",
            "le_iff"
        ],
        "statement": "lemma NatOrder_ZF_1_L1:\n  assumes \"a\\<in>nat\" and \"b\\<in>nat\"\n  shows \"a \\<le> b \\<or> b \\<le> a\"\n",
        "proof": "proof -\n  from assms have I: \"Ord(a) \\<and> Ord(b)\"\n    using nat_into_Ord by auto\n  then have \"a \\<in> b \\<or> a = b \\<or> b \\<in> a\"\n    using Ord_linear by simp\n  with I have \"a < b \\<or> a = b \\<or> b < a\"\n    using ltI by auto\n  with I show \"a \\<le> b \\<or> b \\<le> a\"\n    using le_iff by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/NatOrder_ZF.thy",
        "id": 1157
    },
    "1039": {
        "type": "lemma",
        "text": "text\\<open>$\\leq$ is antisymmetric, transitive, total, and linear. Proofs by\n  rewrite using definitions.\\<close>\n",
        "assumes": "",
        "using": [
            "antisym_def",
            "Le_def",
            "le_anti_sym",
            "trans_def",
            "le_trans",
            "IsTotal_def",
            "NatOrder_ZF_1_L1",
            "IsLinOrder_def"
        ],
        "statement": "lemma NatOrder_ZF_1_L2:\n  shows\n  \"antisym(Le)\"\n  \"trans(Le)\"\n  \"Le {is total on} nat\"\n  \"IsLinOrder(nat,Le)\"\n",
        "proof": "proof -\n  show \"antisym(Le)\"\n    using antisym_def Le_def le_anti_sym by auto\n  moreover show \"trans(Le)\"\n    using trans_def Le_def le_trans by blast\n  moreover show \"Le {is total on} nat\"\n    using IsTotal_def Le_def NatOrder_ZF_1_L1 by simp\n  ultimately show \"IsLinOrder(nat,Le)\"\n    using IsLinOrder_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/NatOrder_ZF.thy",
        "id": 1158
    },
    "1040": {
        "type": "lemma",
        "text": "text\\<open>The order on natural numbers is linear on every natural number.\n  Recall that each natural number is a subset of the set of \n  all natural numbers (as well as a member).\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" ",
        "using": [
            "nat_subset_nat",
            "NatOrder_ZF_1_L2",
            "ord_linear_subset"
        ],
        "statement": "lemma natord_lin_on_each_nat: \n  assumes A1: \"n \\<in> nat\" shows \"IsLinOrder(n,Le)\"\n",
        "proof": "proof -\n  from A1 have \"n \\<subseteq> nat\" using nat_subset_nat\n    by simp\n  then show ?thesis using NatOrder_ZF_1_L2 ord_linear_subset\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/NatOrder_ZF.thy",
        "id": 1159
    },
    "1041": {
        "type": "theorem",
        "text": "text\\<open>The next theorem is a version of induction on natural numbers\n  that I was thought in school.\\<close>\n",
        "assumes": "assumes A1: \"n\\<in>nat\" and A2: \"P(0)\" and A3: \"\\<forall>k\\<in>nat. P(k)\\<longrightarrow>P(succ(k))\"\n  ",
        "using": [],
        "statement": "theorem ind_on_nat: \n  assumes A1: \"n\\<in>nat\" and A2: \"P(0)\" and A3: \"\\<forall>k\\<in>nat. P(k)\\<longrightarrow>P(succ(k))\"\n  shows \"P(n)\"\n",
        "proof": "proof -\n  note A1 A2\n  moreover\n  { fix x\n    assume \"x\\<in>nat\"  \"P(x)\"\n    with A3 have \"P(succ(x))\" by simp }\n  ultimately show  \"P(n)\" by (rule nat_induct)\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1160
    },
    "1042": {
        "type": "lemma",
        "text": "text\\<open>A nonzero natural number has a predecessor.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"n\\<noteq>0\"\n  ",
        "using": [
            "nat_unfold"
        ],
        "statement": "lemma Nat_ZF_1_L3: assumes A1: \"n \\<in> nat\" and A2: \"n\\<noteq>0\"\n  shows \"\\<exists>k\\<in>nat. n = succ(k)\"\n",
        "proof": "proof -\n  from A1 have \"n \\<in> {0} \\<union> {succ(k). k\\<in>nat}\"\n    using nat_unfold by simp\n  with A2 show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1161
    },
    "1043": {
        "type": "lemma",
        "text": "text\\<open>What is \\<open>succ\\<close>, anyway? It's a union with the singleton of the set.\\<close>\n",
        "assumes": "",
        "using": [
            "succ_iff"
        ],
        "statement": "lemma succ_explained: shows \"succ(n) = n \\<union> {n}\"\n  ",
        "proof": "using succ_iff by auto\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1162
    },
    "1044": {
        "type": "lemma",
        "text": "text\\<open>The singleton containing the empty set is a natural number.\\<close>\n",
        "assumes": "",
        "using": [
            "succ_explained"
        ],
        "statement": "lemma one_is_nat: shows \"{0} \\<in> nat\" \"{0} = succ(0)\" \"{0} = 1\"\n",
        "proof": "proof -\n  show \"{0} = succ(0)\" using succ_explained by simp\n  then show \"{0} \\<in> nat\" by simp\n  show \"{0}=1\" by blast\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1163
    },
    "1045": {
        "type": "lemma",
        "text": "text\\<open>Empty set is an element of every natural number which is not zero.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"\n  ",
        "using": [],
        "statement": "lemma empty_in_every_succ: assumes A1: \"n \\<in> nat\"\n  shows \"0 \\<in> succ(n)\"\n",
        "proof": "proof -\n  note A1\n  moreover have \"0 \\<in> succ(0)\" by simp\n  moreover\n  { fix k assume \"k \\<in> nat\" and A2: \"0 \\<in> succ(k)\"\n    then have \"succ(k) \\<subseteq> succ(succ(k))\" by auto\n    with A2 have \"0 \\<in> succ(succ(k))\" by auto\n  } then have \"\\<forall>k \\<in> nat. 0 \\<in> succ(k) \\<longrightarrow> 0 \\<in> succ(succ(k))\"\n    by simp\n  ultimately show \"0 \\<in> succ(n)\" by (rule ind_on_nat)\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1165
    },
    "1046": {
        "type": "lemma",
        "text": "text\\<open>Various forms of saying that for natural numbers taking the successor \n  is the same as adding one. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \n  ",
        "using": [
            "empty_in_every_succ",
            "succ_explained"
        ],
        "statement": "lemma succ_add_one: assumes \"n\\<in>nat\" \n  shows \n    \"n #+ 1 = succ(n)\" \n    \"n #+ 1 \\<in> nat\" \n    \"{0} #+ n = succ(n)\" \n    \"n #+ {0} = succ(n)\"\n    \"succ(n) \\<in> nat\"\n    \"0 \\<in> n #+ 1\"\n    \"n \\<subseteq> n #+ 1\"\n",
        "proof": "proof -\n  from assms show \"n #+ 1 = succ(n)\" \"n #+ 1 \\<in> nat\" \"succ(n) \\<in> nat\" by simp_all\n  moreover from assms have \"{0} = 1\" and \"n #+ 1 = 1 #+ n\" by auto\n  ultimately show \"{0} #+ n = succ(n)\" and \"n #+ {0} = succ(n)\"\n    by simp_all\n  from assms \\<open>n #+ 1 = succ(n)\\<close> show \"0 \\<in> n #+ 1\" using empty_in_every_succ\n    by simp\n  from assms \\<open>n #+ 1 = succ(n)\\<close> show \"n \\<subseteq> n #+ 1\" using succ_explained\n    by auto\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1166
    },
    "1047": {
        "type": "lemma",
        "text": "text\\<open>A more direct way of stating that empty set is an element of every non-zero natural number:\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"n\\<noteq>0\"\n  ",
        "using": [
            "assms",
            "Nat_ZF_1_L3",
            "empty_in_every_succ"
        ],
        "statement": "lemma empty_in_non_empty: assumes \"n\\<in>nat\" \"n\\<noteq>0\"\n  shows \"0\\<in>n\"\n  ",
        "proof": "using assms Nat_ZF_1_L3 empty_in_every_succ by auto\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1167
    },
    "1048": {
        "type": "lemma",
        "text": "text\\<open>If one natural number is less than another then their successors\n  are in the same relation.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"\n  ",
        "using": [],
        "statement": "lemma succ_ineq: assumes A1: \"n \\<in> nat\"\n  shows \"\\<forall>i \\<in> n. succ(i) \\<in> succ(n)\"\n",
        "proof": "proof -\n  note A1\n  moreover have \"\\<forall>k \\<in> 0. succ(k) \\<in> succ(0)\" by simp \n  moreover\n  { fix k assume A2: \"\\<forall>i\\<in>k. succ(i) \\<in> succ(k)\"\n    { fix i assume \"i \\<in> succ(k)\"\n      then have \"i \\<in> k \\<or> i = k\" by auto\n      moreover\n      { assume \"i\\<in>k\"\n\twith A2 have \"succ(i) \\<in> succ(k)\" by simp\n\thence \"succ(i) \\<in> succ(succ(k))\" by auto }\n      moreover\n      { assume \"i = k\"\n\tthen have \"succ(i) \\<in> succ(succ(k))\" by auto }\n      ultimately have \"succ(i) \\<in> succ(succ(k))\" by auto\n    } then have \"\\<forall>i \\<in> succ(k). succ(i) \\<in> succ(succ(k))\"\n      by simp\n  } then have \"\\<forall>k \\<in> nat. \n      ( (\\<forall>i\\<in>k. succ(i) \\<in> succ(k)) \\<longrightarrow> (\\<forall>i \\<in> succ(k). succ(i) \\<in> succ(succ(k))) )\"\n    by simp\n  ultimately show \"\\<forall>i \\<in> n. succ(i) \\<in> succ(n)\" by (rule ind_on_nat)\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1168
    },
    "1049": {
        "type": "lemma",
        "text": "text\\<open>For natural numbers if $k\\subseteq n$ the similar holds for \n  their successors.\\<close>\n",
        "assumes": "assumes A1: \"k \\<in> nat\"  \"n \\<in> nat\" and A2: \"k\\<subseteq>n\" \n  ",
        "using": [
            "nat_into_Ord",
            "subset_imp_le",
            "le_imp_subset"
        ],
        "statement": "lemma succ_subset: assumes A1: \"k \\<in> nat\"  \"n \\<in> nat\" and A2: \"k\\<subseteq>n\" \n  shows \"succ(k) \\<subseteq> succ(n)\"\n",
        "proof": "proof -\n  from A1 have T: \"Ord(k)\" and \"Ord(n)\"\n    using nat_into_Ord by auto\n  with A2 have \"succ(k) \\<le> succ(n)\"\n    using subset_imp_le by simp\n  then show \"succ(k) \\<subseteq> succ(n)\" using le_imp_subset\n    by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1169
    },
    "1050": {
        "type": "lemma",
        "text": "text\\<open>For any two natural numbers one of them is contained in the other.\\<close>\n",
        "assumes": "assumes A1: \"i \\<in> nat\"  \"j \\<in> nat\"\n  ",
        "using": [
            "nat_into_Ord",
            "Ord_linear",
            "lt_def",
            "leI",
            "le_imp_subset"
        ],
        "statement": "lemma nat_incl_total: assumes A1: \"i \\<in> nat\"  \"j \\<in> nat\"\n  shows \"i \\<subseteq> j \\<or> j \\<subseteq> i\"\n",
        "proof": "proof -\n  from A1 have T: \"Ord(i)\"   \"Ord(j)\" \n    using nat_into_Ord by auto\n  then have \"i\\<in>j \\<or> i=j \\<or> j\\<in>i\" using Ord_linear\n    by simp\n  moreover\n  { assume \"i\\<in>j\"\n    with T have \"i\\<subseteq>j \\<or> j\\<subseteq>i\"\n      using lt_def leI le_imp_subset by simp }\n  moreover\n  { assume \"i=j\"\n    then have \"i\\<subseteq>j \\<or> j\\<subseteq>i\" by simp }\n  moreover\n  { assume \"j\\<in>i\"\n    with T have \"i\\<subseteq>j \\<or> j\\<subseteq>i\" \n      using lt_def leI  le_imp_subset by simp }\n  ultimately show \"i \\<subseteq> j \\<or> j \\<subseteq> i\" by auto\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1170
    },
    "1051": {
        "type": "lemma",
        "text": "text\\<open>The set of natural numbers is the union of all successors of natural\n  numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "nat_into_Ord",
            "lt_def",
            "le_in_nat"
        ],
        "statement": "lemma nat_union_succ: shows \"nat = (\\<Union>n \\<in> nat. succ(n))\"\n",
        "proof": "proof\n  show \"nat \\<subseteq> (\\<Union>n \\<in> nat. succ(n))\" by auto\nnext\n  { fix k assume A2: \"k \\<in> (\\<Union>n \\<in> nat. succ(n))\"\n    then obtain n where T: \"n \\<in> nat\" and I: \"k \\<in> succ(n)\"\n      by auto\n    then have \"k \\<le> n\" using nat_into_Ord lt_def\n      by simp\n    with T have \"k \\<in> nat\" using le_in_nat by simp\n  } then show  \"(\\<Union>n \\<in> nat. succ(n)) \\<subseteq> nat\" by auto\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1171
    },
    "1052": {
        "type": "lemma",
        "text": "text\\<open>Successors of natural numbers are subsets of the \n  set of natural numbers.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" ",
        "using": [
            "nat_union_succ"
        ],
        "statement": "lemma succnat_subset_nat: assumes A1: \"n \\<in> nat\" shows \"succ(n) \\<subseteq> nat\"\n",
        "proof": "proof -\n  from A1 have \"succ(n) \\<subseteq> (\\<Union>n \\<in> nat. succ(n))\" by auto\n  then show \"succ(n) \\<subseteq> nat\" using nat_union_succ by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1172
    },
    "1053": {
        "type": "lemma",
        "text": "text\\<open>Element $k$ of a natural number $n$ is a natural number that is smaller than $n$.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  and A2: \"k\\<in>n\"\n  ",
        "using": [
            "nat_into_Ord",
            "lt_def",
            "lt_nat_in_nat",
            "leI",
            "Le_def"
        ],
        "statement": "lemma elem_nat_is_nat: assumes A1: \"n \\<in> nat\"  and A2: \"k\\<in>n\"\n  shows \"k < n\"  \"k \\<in> nat\"  \"k \\<le> n\"  \"\\<langle>k,n\\<rangle> \\<in> Le\"\n",
        "proof": "proof -\n  from A1 A2 show \"k < n\" using nat_into_Ord lt_def by simp\n  with A1 show \"k \\<in> nat\" using lt_nat_in_nat by simp\n  from \\<open>k < n\\<close> show \"k \\<le> n\" using leI by simp\n  with A1 \\<open>k \\<in> nat\\<close> show \"\\<langle>k,n\\<rangle> \\<in> Le\" using Le_def\n    by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1173
    },
    "1054": {
        "type": "lemma",
        "text": "text\\<open>A version of \\<open>succ_ineq\\<close> without a quantifier, with additional assertion\n  using the \\<open>n #+ 1\\<close> notation.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"i\\<in>n\"\n  ",
        "using": [
            "assms",
            "succ_ineq",
            "succ_add_one(1,7)",
            "elem_nat_is_nat(2)"
        ],
        "statement": "lemma succ_ineq1:  assumes \"n \\<in> nat\" \"i\\<in>n\"\n  shows \"succ(i) \\<in> succ(n)\" \"i #+ 1 \\<in> n #+ 1\" \"i \\<in> n #+ 1\" \n  ",
        "proof": "using assms succ_ineq succ_add_one(1,7) elem_nat_is_nat(2) \n  by auto\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1174
    },
    "1055": {
        "type": "lemma",
        "text": "text\\<open>For natural numbers membership and inequality are the same\n  and $k \\leq n$ is the same as $k \\in \\textrm{succ}(n)$. \n  The proof relies on lemmas in the standard Isabelle's \\<open>Nat\\<close> and \\<open>Ordinal\\<close> theories. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \n  ",
        "using": [
            "assms",
            "nat_into_Ord",
            "Ord_mem_iff_lt"
        ],
        "statement": "lemma nat_mem_lt: assumes \"n\\<in>nat\" \n  shows \"k<n \\<longleftrightarrow> k\\<in>n\" and \"k\\<le>n \\<longleftrightarrow> k \\<in> succ(n)\"\n  ",
        "proof": "using assms nat_into_Ord Ord_mem_iff_lt by auto\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1175
    },
    "1056": {
        "type": "lemma",
        "text": "text\\<open>The term $k \\leq n$ is the same as $k < \\textrm{succ}(n)$.  \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma leq_mem_succ: shows \"k\\<le>n \\<longleftrightarrow> k < succ(n)\" by simp\n",
        "proof": "",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1176
    },
    "1057": {
        "type": "lemma",
        "text": "text\\<open>If the successor of a natural number $k$ is an element of the successor\n  of $n$ then a similar relations holds for the numbers themselves.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"succ(k) \\<in> succ(n)\"\n  ",
        "using": [
            "assms",
            "elem_nat_is_nat(1)",
            "succ_leE",
            "nat_into_Ord",
            "lt_def"
        ],
        "statement": "lemma succ_mem: \n  assumes \"n \\<in> nat\" \"succ(k) \\<in> succ(n)\"\n  shows \"k\\<in>n\"\n  ",
        "proof": "using assms elem_nat_is_nat(1) succ_leE nat_into_Ord \n    unfolding lt_def by blast\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1177
    },
    "1058": {
        "type": "lemma",
        "text": "text\\<open>The set of natural numbers is the union of its elements.\\<close>\n",
        "assumes": "",
        "using": [
            "elem_nat_is_nat"
        ],
        "statement": "lemma nat_union_nat: shows \"nat = \\<Union> nat\"\n  ",
        "proof": "using elem_nat_is_nat by blast\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1178
    },
    "1059": {
        "type": "lemma",
        "text": "text\\<open>A natural number is a subset of the set of natural numbers.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" ",
        "using": [
            "nat_union_nat"
        ],
        "statement": "lemma nat_subset_nat: assumes A1: \"n \\<in> nat\" shows \"n \\<subseteq> nat\"\n",
        "proof": "proof -\n  from A1 have \"n \\<subseteq> \\<Union> nat\" by auto\n  then show \"n \\<subseteq> nat\" using nat_union_nat by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1179
    },
    "1060": {
        "type": "lemma",
        "text": "text\\<open>Adding natural numbers does not decrease what we add to.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  and A2: \"k \\<in> nat\"\n  ",
        "using": [
            "nat_le_refl",
            "nat_0_le",
            "add_0_right",
            "le_imp_subset",
            "add_commute"
        ],
        "statement": "lemma add_nat_le: assumes A1: \"n \\<in> nat\"  and A2: \"k \\<in> nat\"\n  shows \n  \"n \\<le> n #+ k\"\n  \"n \\<subseteq> n #+ k\"\n  \"n \\<subseteq> k #+ n\"\n",
        "proof": "proof -\n  from A1 A2 have \"n \\<le> n\"  \"0 \\<le> k\"  \"n \\<in> nat\"  \"k \\<in> nat\"\n    using nat_le_refl nat_0_le by auto\n  then have \"n #+ 0 \\<le> n #+ k\" by (rule add_le_mono)\n  with A1 show \"n \\<le> n #+ k\" using add_0_right by simp\n  then show \"n \\<subseteq> n #+ k\" using le_imp_subset by simp\n  then show \"n \\<subseteq> k #+ n\" using add_commute by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1180
    },
    "1061": {
        "type": "lemma",
        "text": "text\\<open>Result of adding an element of $k$ is smaller than of adding $k$.\\<close>\n",
        "assumes": "assumes \"k \\<in> nat\" and \"j\\<in>k\"\n  ",
        "using": [
            "elem_nat_is_nat",
            "add_lt_mono2",
            "ltD"
        ],
        "statement": "lemma add_lt_mono: \n  assumes \"k \\<in> nat\" and \"j\\<in>k\"\n  shows \n  \"(n #+ j) < (n #+ k)\"\n  \"(n #+ j) \\<in> (n #+ k)\"\n",
        "proof": "proof -\n  from assms have \"j < k\" using elem_nat_is_nat by blast\n  moreover note \\<open>k \\<in> nat\\<close>\n  ultimately show \"(n #+ j) < (n #+ k)\"   \"(n #+ j) \\<in> (n #+ k)\"\n    using add_lt_mono2 ltD by auto\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1181
    },
    "1062": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about a decomposition of a sum of two natural\n  numbers: if a number $i$ is from $m + n$ then it is either from $m$\n  or can be written as a sum of $m$ and a number from $n$. \n  The proof by induction w.r.t. to $m$ seems to be a bit heavy-handed, but I could\n  not figure out how to do this directly from results from standard Isabelle/ZF.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  and A2: \"m \\<in> nat\"\n  ",
        "using": [
            "add_0_right",
            "add_succ_right"
        ],
        "statement": "lemma nat_sum_decomp: assumes A1: \"n \\<in> nat\"  and A2: \"m \\<in> nat\"\n  shows \"\\<forall>i \\<in> m #+ n. i \\<in> m \\<or> (\\<exists>j \\<in> n. i = m #+ j)\" \n",
        "proof": "proof -\n  note A1\n  moreover from A2 have \"\\<forall>i \\<in> m #+ 0. i \\<in> m \\<or> (\\<exists>j \\<in> 0. i = m #+ j)\"\n    using add_0_right by simp\n  moreover have \"\\<forall>k\\<in>nat.\n    (\\<forall>i \\<in> m #+ k. i \\<in> m \\<or> (\\<exists>j \\<in> k. i = m #+ j)) \\<longrightarrow>\n    (\\<forall>i \\<in> m #+ succ(k). i \\<in> m \\<or> (\\<exists>j \\<in> succ(k). i = m #+ j))\"\n  proof -\n    { fix k assume A3: \"k \\<in> nat\"\n      { assume A4: \"\\<forall>i \\<in> m #+ k. i \\<in> m \\<or> (\\<exists>j \\<in> k. i = m #+ j)\"\n\t  { fix i assume \"i \\<in>  m #+ succ(k)\"\n\t    then have \"i \\<in> m #+ k \\<or> i = m #+ k\" using add_succ_right\n\t      by auto\n\t    moreover from A4 A3 have\n\t      \"i \\<in> m #+ k \\<longrightarrow> i \\<in> m \\<or> (\\<exists>j \\<in> succ(k). i = m #+ j)\"\n\t      by auto\n\t    ultimately have \"i \\<in> m \\<or> (\\<exists>j \\<in> succ(k). i = m #+ j)\"\n\t      by auto\n\t  } then have \"\\<forall>i \\<in> m #+ succ(k). i \\<in> m \\<or> (\\<exists>j \\<in> succ(k). i = m #+ j)\"\n\t    by simp\n      } then have \"(\\<forall>i \\<in> m #+ k. i \\<in> m \\<or> (\\<exists>j \\<in> k. i = m #+ j)) \\<longrightarrow>\n\t  (\\<forall>i \\<in> m #+ succ(k). i \\<in> m \\<or> (\\<exists>j \\<in> succ(k). i = m #+ j))\"\n\tby simp\n    } then show ?thesis by simp\n  qed\n  ultimately show \"\\<forall>i \\<in> m #+ n. i \\<in> m \\<or> (\\<exists>j \\<in> n. i = m #+ j)\"\n    by (rule ind_on_nat)\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1182
    },
    "1063": {
        "type": "lemma",
        "text": "text\\<open>A variant of induction useful for finite sequences.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and A2: \"k \\<in> succ(n)\"\n  and A3: \"P(0)\" and A4: \"\\<forall>j\\<in>n. P(j)  \\<longrightarrow> P(succ(j))\"\n  ",
        "using": [
            "elem_nat_is_nat",
            "nat_into_Ord",
            "Ord_succ_mem_iff"
        ],
        "statement": "lemma fin_nat_ind: assumes A1: \"n \\<in> nat\" and A2: \"k \\<in> succ(n)\"\n  and A3: \"P(0)\" and A4: \"\\<forall>j\\<in>n. P(j)  \\<longrightarrow> P(succ(j))\"\n  shows \"P(k)\"\n",
        "proof": "proof -\n  from A2 have \"k \\<in> n \\<or> k=n\" by auto\n  with A1 have \"k \\<in> nat\" using elem_nat_is_nat by blast\n  moreover from A3 have \"0 \\<in> succ(n) \\<longrightarrow> P(0)\" by simp\n  moreover from A1 A4 have\n    \"\\<forall>k \\<in> nat. (k \\<in> succ(n) \\<longrightarrow> P(k)) \\<longrightarrow> (succ(k) \\<in> succ(n) \\<longrightarrow> P(succ(k)))\"\n    using nat_into_Ord Ord_succ_mem_iff by auto\n  ultimately have \"k \\<in> succ(n) \\<longrightarrow> P(k)\"\n    by (rule ind_on_nat)\n  with A2 show \"P(k)\" by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1183
    },
    "1064": {
        "type": "lemma",
        "text": "text\\<open>Some properties of positive natural numbers.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"  \"k \\<in> nat\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma succ_plus: assumes \"n \\<in> nat\"  \"k \\<in> nat\"\n  shows \n  \"succ(n #+ j) \\<in> nat\" \n  \"succ(n) #+ succ(j) = succ(succ(n #+ j))\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1184
    },
    "1065": {
        "type": "lemma",
        "text": "text\\<open>If $k$ is in the successor of $n$, then the predecessor of $k$ is in $n$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"n\\<noteq>0\" \"k\\<in>succ(n)\" ",
        "using": [
            "succnat_subset_nat",
            "Nat_ZF_1_L3",
            "succ_mem",
            "pred_succ_eq",
            "pred_0",
            "empty_in_non_empty"
        ],
        "statement": "lemma pred_succ_mem: assumes \"n\\<in>nat\" \"n\\<noteq>0\" \"k\\<in>succ(n)\" shows \"pred(k)\\<in>n\"\n",
        "proof": "proof -\n  from assms(1,3) have \"k\\<in>nat\" using succnat_subset_nat by blast\n  { assume \"k\\<noteq>0\"\n    with \\<open>k\\<in>nat\\<close> obtain j where \"j\\<in>nat\" and \"k=succ(j)\"\n      using Nat_ZF_1_L3 by auto\n    with assms(1,3) have \"pred(k)\\<in>n\" using succ_mem pred_succ_eq\n      by simp\n  }\n  moreover\n  { assume \"k=0\"\n    with assms(1,2) have \"pred(k)\\<in>n\" \n      using pred_0 empty_in_non_empty by simp\n  } ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1185
    },
    "1066": {
        "type": "lemma",
        "text": "text\\<open>For non-zero natural numbers $\\textrm{pred}(n) = n-1$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"n\\<noteq>0\" \n  ",
        "using": [
            "Nat_ZF_1_L3",
            "pred_succ_eq",
            "eq_succ_imp_eq_m1"
        ],
        "statement": "lemma pred_minus_one: assumes \"n\\<in>nat\" \"n\\<noteq>0\" \n  shows \"n #- 1 = pred(n)\"\n",
        "proof": "proof -\n  from assms obtain k where \"n=succ(k)\" \n    using Nat_ZF_1_L3 by blast\n  with assms show ?thesis\n    using pred_succ_eq eq_succ_imp_eq_m1 by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1186
    },
    "1067": {
        "type": "lemma",
        "text": "text\\<open>For natural numbers if $j\\in n$ then $j+1 \\subseteq n$.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"k\\<in>n\" ",
        "using": [
            "elem_nat_is_nat(2)",
            "succ_ineq1",
            "succ_add_one(1)",
            "nat_mem_lt(2)",
            "le_imp_subset"
        ],
        "statement": "lemma mem_add_one_subset: assumes \"n \\<in> nat\" \"k\\<in>n\" shows \"k #+ 1 \\<subseteq> n\"\n",
        "proof": "proof -\n  from assms have \"k #+ 1 \\<in> succ(n)\"\n    using elem_nat_is_nat(2) succ_ineq1 succ_add_one(1) by simp\n  with assms(1) show \"k #+ 1 \\<subseteq> n\" using nat_mem_lt(2) le_imp_subset \n    by blast\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1187
    },
    "1068": {
        "type": "lemma",
        "text": "text\\<open>For a natural $n$ if $k\\in n+1$ then $k+1\\leq n+1$.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" \"k \\<in> n #+ 1\"\n  ",
        "using": [
            "succ_add_one(1)",
            "nat_mem_lt(2)",
            "add_le_mono1"
        ],
        "statement": "lemma succ_ineq2: assumes \"n \\<in> nat\" \"k \\<in> n #+ 1\"\n  shows \"k #+ 1 \\<le> n #+ 1\" and \"k\\<le>n\"\n",
        "proof": "proof -\n  from assms show \"k\\<le>n\" using succ_add_one(1) nat_mem_lt(2)\n    by simp\n  with assms(1) show  \"k #+ 1 \\<le> n #+ 1\" using add_le_mono1 by blast\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1188
    },
    "1069": {
        "type": "lemma",
        "text": "text\\<open>A nonzero natural number is of the form $n=m+1$ for some natural number $m$.\n  This is very similar to \\<open>Nat_ZF_1_L3\\<close> except that we use $n+1$ instead of \\<open>succ(n)\\<close>. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"n\\<noteq>0\"\n  ",
        "using": [
            "assms",
            "Nat_ZF_1_L3",
            "succ_add_one(1)"
        ],
        "statement": "lemma nat_not0_succ: assumes \"n\\<in>nat\" \"n\\<noteq>0\"\n  shows \"\\<exists>m\\<in>nat. n = m #+1\"\n  ",
        "proof": "using assms Nat_ZF_1_L3 succ_add_one(1) by simp\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1189
    },
    "1070": {
        "type": "lemma",
        "text": "text\\<open>Adding and subtracting a natural number cancel each other.\\<close>\n",
        "assumes": "assumes \"m\\<in>nat\" ",
        "using": [
            "assms",
            "diff_add_inverse2"
        ],
        "statement": "lemma add_subctract: assumes \"m\\<in>nat\" shows \"(m #+ n) #- n = m\"\n  ",
        "proof": "using assms diff_add_inverse2 by simp\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1190
    },
    "1071": {
        "type": "lemma",
        "text": "text\\<open>A version of induction on natural numbers that uses the $n+1$ notation\n  instead of $\\<open>succ(n)\\<close>$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and \"P(0)\" and \"\\<forall>k\\<in>nat. P(k)\\<longrightarrow>P(k #+ 1)\"\n  ",
        "using": [
            "assms",
            "succ_add_one(1)",
            "ind_on_nat"
        ],
        "statement": "lemma ind_on_nat1: \n  assumes \"n\\<in>nat\" and \"P(0)\" and \"\\<forall>k\\<in>nat. P(k)\\<longrightarrow>P(k #+ 1)\"\n  shows \"P(n)\" ",
        "proof": "using assms succ_add_one(1) ind_on_nat by simp  \n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1191
    },
    "1072": {
        "type": "lemma",
        "text": "text\\<open>A version of induction for finite sequences using the $n+1$ notation\n  instead of \\<open>succ(n)\\<close>:\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and \"P(0)\" and \"\\<forall>j\\<in>n. P(j)\\<longrightarrow>P(j #+ 1)\"\n  ",
        "using": [
            "succ_add_one(1)",
            "elem_nat_is_nat(2)"
        ],
        "statement": "lemma fin_nat_ind1: \n  assumes \"n\\<in>nat\" and \"P(0)\" and \"\\<forall>j\\<in>n. P(j)\\<longrightarrow>P(j #+ 1)\"\n  shows \"\\<forall>k\\<in>n #+ 1. P(k)\" and \"P(n)\"\n",
        "proof": "proof -\n  { fix k assume \"k\\<in>n #+ 1\"\n    with assms have \n      \"n\\<in>nat\" \"k\\<in>succ(n)\" \"P(0)\" \"\\<forall>j\\<in>n. P(j)  \\<longrightarrow> P(succ(j))\"\n      using succ_add_one(1) elem_nat_is_nat(2) by simp_all\n    then have \"P(k)\" by (rule fin_nat_ind)\n  } thus \"\\<forall>k\\<in>n #+ 1. P(k)\" by simp\n  with assms(1) show \"P(n)\" by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1192
    },
    "1073": {
        "type": "lemma",
        "text": "text\\<open>A simplification rule for natural numbers: if $k<n$ then $n-(k+1)+1 = n-k$: \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"k\\<in>n\" \n  ",
        "using": [
            "nat_not0_succ",
            "elem_nat_is_nat(2)",
            "succ_add_one",
            "diff_succ",
            "succ_ineq2(2)",
            "diff_cancel2"
        ],
        "statement": "lemma nat_subtr_simpl0: assumes \"n\\<in>nat\" \"k\\<in>n\" \n  shows \"n #- (k #+ 1) #+ 1 = n #- k\"\n",
        "proof": "proof -\n  from assms obtain m where \"m\\<in>nat\" and \"n = m #+1\"\n    using nat_not0_succ by blast\n  with assms have \"succ(m) = m #+ 1\" \"succ(m #- k) = m #- k #+ 1\"\n    using elem_nat_is_nat(2) succ_add_one by simp_all\n  moreover from assms(2) \\<open>m\\<in>nat\\<close> \\<open>n = m #+1\\<close> have \n    \"succ(m) #- k = succ(m #- k)\" \n    using diff_succ succ_ineq2(2) by simp\n  ultimately have \"m  #- k #+ 1 = m #+ 1 #- k\" by simp\n  with \\<open>n = m #+1\\<close> show ?thesis using diff_cancel2 by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1193
    },
    "1074": {
        "type": "definition",
        "text": "text\\<open>The interval is determined by two parameters: starting point and length.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n",
        "proof": "",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1194
    },
    "1075": {
        "type": "lemma",
        "text": "text\\<open>Subtracting the beginning af the interval results in a number from\n  the length of the interval. It may sound weird, but note that the length of\n  such interval is a natural number, hence a set.\\<close>\n",
        "assumes": "assumes A1: \"k \\<in> nat\" and A2: \"i \\<in> NatInterval(n,k)\"\n  ",
        "using": [
            "NatInterval_def",
            "elem_nat_is_nat",
            "diff_add_inverse"
        ],
        "statement": "lemma inter_diff_in_len: \n  assumes A1: \"k \\<in> nat\" and A2: \"i \\<in> NatInterval(n,k)\"\n  shows \"i #- n \\<in> k\"\n",
        "proof": "proof -\n  from A2 obtain j where I: \"i = n #+ j\" and II: \"j \\<in> k\"\n    using NatInterval_def by auto\n  from A1 II have \"j \\<in> nat\" using elem_nat_is_nat by blast\n  moreover from I have \"i #- n = natify(j)\" using diff_add_inverse\n    by simp\n  ultimately have \"i #- n = j\" by simp\n  with II show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1195
    },
    "1076": {
        "type": "lemma",
        "text": "text\\<open>Intervals don't overlap with their starting point and \n  the union of an interval with its starting point is the sum of the starting\n  point and the length of the interval.\\<close>\n",
        "assumes": "assumes  A1: \"n \\<in> nat\"  \"k \\<in> nat\"\n  ",
        "using": [
            "NatInterval_def",
            "elem_nat_is_nat",
            "add_nat_le",
            "le_imp_not_lt",
            "add_lt_mono2",
            "ltD",
            "nat_sum_decomp"
        ],
        "statement": "lemma length_start_decomp: assumes  A1: \"n \\<in> nat\"  \"k \\<in> nat\"\n  shows \n  \"n \\<inter> NatInterval(n,k) = 0\"\n  \"n \\<union> NatInterval(n,k) = n #+ k\"\n",
        "proof": "proof -\n  { fix i assume A2: \"i \\<in> n\" and \"i \\<in> NatInterval(n,k)\"\n    then obtain j where I: \"i = n #+ j\" and II: \"j \\<in> k\"\n      using NatInterval_def by auto\n    from A1 have \"k \\<in> nat\" using elem_nat_is_nat by blast\n    with II have \"j \\<in> nat\" using elem_nat_is_nat by blast\n    with A1 I have \"n \\<le> i\" using add_nat_le by simp\n    moreover from A1 A2 have \"i < n\" using elem_nat_is_nat by blast\n    ultimately have False using le_imp_not_lt by blast\n  } thus \"n \\<inter> NatInterval(n,k) = 0\" by auto\n  from A1 have \"n \\<subseteq> n #+ k\" using add_nat_le by simp\n  moreover\n  { fix i assume \"i \\<in> NatInterval(n,k)\"\n    then obtain j where III: \"i = n #+ j\" and IV: \"j \\<in> k\"\n      using NatInterval_def by auto\n    with A1 have \"j < k\" using elem_nat_is_nat by blast\n    with A1 III have \"i \\<in> n #+ k\" using add_lt_mono2 ltD\n      by simp }\n  ultimately have \"n \\<union> NatInterval(n,k) \\<subseteq> n #+ k\" by auto\n  moreover from A1 have \"n #+ k \\<subseteq> n \\<union> NatInterval(n,k)\" \n    using nat_sum_decomp NatInterval_def by auto\n  ultimately show \"n \\<union> NatInterval(n,k) = n #+ k\" by auto\nqed\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1196
    },
    "1077": {
        "type": "lemma",
        "text": "text\\<open>Some properties of three adjacent intervals.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\"\n  ",
        "using": [
            "assms",
            "add_assoc",
            "length_start_decomp"
        ],
        "statement": "lemma adjacent_intervals3: assumes \"n \\<in> nat\"  \"k \\<in> nat\"  \"m \\<in> nat\"\n  shows \n  \"n #+ k #+ m = (n #+ k) \\<union> NatInterval(n #+ k,m)\"\n  \"n #+ k #+ m = n \\<union> NatInterval(n,k #+  m)\"\n  \"n #+ k #+ m = n \\<union> NatInterval(n,k) \\<union> NatInterval(n #+ k,m)\"\n  ",
        "proof": "using assms add_assoc length_start_decomp by auto\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1197
    },
    "1078": {
        "type": "definition",
        "text": "text\\<open>A relation $r$ is ''total'' on a set $X$ if for all elements \n  $a,b$ of $X$ we have $a$ is in relation with $b$ or $b$ is in relation\n  with $a$. An example is the $\\leq $ relation on numbers.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsTotal (infixl \"{is total on}\" 65) where\n  \"r {is total on} X \\<equiv> (\\<forall>a\\<in>X.\\<forall>b\\<in>X. \\<langle> a,b\\<rangle> \\<in> r \\<or> \\<langle> b,a\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1198
    },
    "1079": {
        "type": "definition",
        "text": "text\\<open>A relation $r$ is a partial order on $X$ if it is reflexive on $X$\n  (i.e. $\\langle x,x \\rangle$ for every $x\\in X$), antisymmetric \n  (if $\\langle x, y\\rangle \\in r $ and $\\langle y, x\\rangle \\in r $, then\n  $x=y$) and transitive $\\langle x, y\\rangle \\in r $ and \n  $\\langle y, z\\rangle \\in r $ implies $\\langle x, z\\rangle \\in r $). \n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsPartOrder(X,r) \\<equiv> refl(X,r) \\<and> antisym(r) \\<and> trans(r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1199
    },
    "1080": {
        "type": "definition",
        "text": "text\\<open>A relation that is reflexive and transitive is called a \\<open>preorder\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsPreorder(X,r) \\<equiv> refl(X,r) \\<and> trans(r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1200
    },
    "1081": {
        "type": "definition",
        "text": "text\\<open>We say that a relation $r$ up-directs a set\n  if every two-element subset of $X$ has an upper bound. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  UpDirects (\"_ {up-directs} _\" 90)\n  where \"r {up-directs} X \\<equiv> X\\<noteq>0 \\<and> (\\<forall>x\\<in>X.\\<forall>y\\<in>X.\\<exists>z\\<in>X. \\<langle>x,z\\<rangle> \\<in> r \\<and> \\<langle>y,z\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1201
    },
    "1082": {
        "type": "definition",
        "text": "text\\<open>Analogously we say that a relation $r$ down-directs a set\n  if every two-element subset of $X$ has a lower bound. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  DownDirects (\"_ {down-directs} _\" 90)\n  where \"r {down-directs} X \\<equiv> X\\<noteq>0 \\<and> (\\<forall>x\\<in>X.\\<forall>y\\<in>X.\\<exists>z\\<in>X. \\<langle>z,x\\<rangle> \\<in> r \\<and> \\<langle>z,y\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1202
    },
    "1083": {
        "type": "definition",
        "text": "text\\<open>Typically the notion that is actually defined is the notion of a \\<open>directed set\\<close>. \n  or an \\<open>upward directed set\\<close>, rather than $r$ down-directs $X$ (or $r$ up-directs $X$). \n  This is a nonempty set $X$ together which a preorder $r$ \n  such that $r$ up-directs $X$. We set that up in separate definitions as we sometimes want to\n  use an upward or downward directed set with a partial order rather than a preorder. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsUpDirectedSet(X,r) \\<equiv>  IsPreorder(X,r) \\<and> (r {up-directs} X)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1203
    },
    "1084": {
        "type": "definition",
        "text": "text\\<open>We define the notion of a \\<open>downward directed set\\<close> analogously.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsDownDirectedSet(X,r) \\<equiv> IsPreorder(X,r) \\<and> (r {down-directs} X)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1204
    },
    "1085": {
        "type": "definition",
        "text": "text\\<open>We define a linear order as a binary relation that is antisymmetric, \n  transitive and total. Note that this terminology is different than the\n  one used the standard Order.thy file.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsLinOrder(X,r) \\<equiv> antisym(r) \\<and> trans(r) \\<and> (r {is total on} X)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1205
    },
    "1086": {
        "type": "definition",
        "text": "text\\<open>A set is bounded above if there is that is an upper\n  bound for it,  i.e. there are some $u$ such that \n  $\\langle x, u\\rangle \\in r$ for all $x\\in A$. \n  In addition, the empty set is defined as bounded.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsBoundedAbove(A,r) \\<equiv> ( A=0 \\<or> (\\<exists>u. \\<forall>x\\<in>A. \\<langle> x,u\\<rangle> \\<in> r))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1206
    },
    "1087": {
        "type": "definition",
        "text": "text\\<open>We define sets bounded below analogously.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsBoundedBelow(A,r) \\<equiv> (A=0 \\<or> (\\<exists>l. \\<forall>x\\<in>A. \\<langle> l,x\\<rangle> \\<in> r))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1207
    },
    "1088": {
        "type": "definition",
        "text": "text\\<open>A set is bounded if it is bounded below and above.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsBounded(A,r) \\<equiv> (IsBoundedAbove(A,r) \\<and> IsBoundedBelow(A,r))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1208
    },
    "1089": {
        "type": "definition",
        "text": "text\\<open>The notation for the definition of an interval may be mysterious for some\n  readers, see lemma \\<open>Order_ZF_2_L1\\<close> for more intuitive notation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Interval(r,a,b) \\<equiv> r``{a} \\<inter> r-``{b}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1209
    },
    "1090": {
        "type": "definition",
        "text": "text\\<open>We also define the maximum (the greater of) two elemnts \n  in the obvious way.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"GreaterOf(r,a,b) \\<equiv> (if \\<langle> a,b\\<rangle> \\<in> r then b else a)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1210
    },
    "1091": {
        "type": "definition",
        "text": "text\\<open>The definition a a minimum (the smaller of) two elements.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SmallerOf(r,a,b) \\<equiv> (if \\<langle> a,b\\<rangle> \\<in> r then a else b)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1211
    },
    "1092": {
        "type": "definition",
        "text": "text\\<open>We say that a set has a maximum if it has an element that is \n  not smaller that any other one. We show that\n  under some conditions this element of the set is unique (if exists).\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasAmaximum(r,A) \\<equiv> \\<exists>M\\<in>A.\\<forall>x\\<in>A. \\<langle>x,M\\<rangle> \\<in> r\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1212
    },
    "1093": {
        "type": "definition",
        "text": "text\\<open>A similar definition what it means that a set has a minimum.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasAminimum(r,A) \\<equiv> \\<exists>m\\<in>A.\\<forall>x\\<in>A. \\<langle>m,x\\<rangle> \\<in> r\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1213
    },
    "1094": {
        "type": "definition",
        "text": "text\\<open>Definition of the maximum of a set.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Maximum(r,A) \\<equiv> THE M. M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle>x,M\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1214
    },
    "1095": {
        "type": "definition",
        "text": "text\\<open>Definition of a minimum of a set.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Minimum(r,A) \\<equiv> THE m. m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle>m,x\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1215
    },
    "1096": {
        "type": "definition",
        "text": "text\\<open>The supremum of a set $A$ is defined as the minimum of the set of\n  upper bounds, i.e. the set \n  $\\{u.\\forall_{a\\in A} \\langle a,u\\rangle \\in r\\}=\\bigcap_{a\\in A} r\\{a\\}$. \n   Recall that in Isabelle/ZF\n  \\<open>r-``(A)\\<close> denotes the inverse image of the set $A$ by relation $r$\n  (i.e. \\<open>r-``(A)\\<close>=$\\{ x: \\langle x,y\\rangle\\in r$ for some $y\\in A\\}$).\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Supremum(r,A) \\<equiv> Minimum(r,\\<Inter>a\\<in>A. r``{a})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1216
    },
    "1097": {
        "type": "definition",
        "text": "text\\<open> The notion of \"having a supremum\" is the same as the set of upper bounds having a\n  minimum, but having it a a separate notion does simplify notation in some cases.\n  The definition is written in terms of \n  images of singletons $\\{ x\\}$ under relation. To understand this formulation note\n  that the set of upper bounds of a set $A\\subseteq X$ is \n  $\\bigcap_{x\\in A}\\{ y\\in X | \\langle x,y\\rangle \\in r \\}$, which is the same\n  as $\\bigcap_{x\\in A} r(\\{ x \\})$, where $r(\\{ x \\})$ is the image of the singleton $\\{ x\\}$ under\n  relation $r$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasAsupremum(r,A) \\<equiv> HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1217
    },
    "1098": {
        "type": "definition",
        "text": "text\\<open> The notion of \"having an infimum\" is the same as the set of lower bounds having a\n  maximum. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasAnInfimum(r,A) \\<equiv> HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1218
    },
    "1099": {
        "type": "definition",
        "text": "text\\<open>Infimum is defined analogously.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Infimum(r,A) \\<equiv> Maximum(r,\\<Inter>a\\<in>A. r-``{a})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1219
    },
    "1100": {
        "type": "definition",
        "text": "text\\<open>We define a relation to be complete if every nonempty bounded\n  above set has a supremum.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsComplete (\"_ {is complete}\") where\n  \"r {is complete} \\<equiv> \n  \\<forall>A. IsBoundedAbove(A,r) \\<and> A\\<noteq>0 \\<longrightarrow> HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1220
    },
    "1101": {
        "type": "lemma",
        "text": "text\\<open>If a relation down-directs a set, then a larger one does as well.\\<close>\n",
        "assumes": "assumes \"r {down-directs} X\" \"r\\<subseteq>R\"\n  ",
        "using": [
            "assms",
            "DownDirects_def"
        ],
        "statement": "lemma down_dir_mono: assumes \"r {down-directs} X\" \"r\\<subseteq>R\"\n  shows \"R {down-directs} X\" ",
        "proof": "using assms unfolding DownDirects_def\n  by blast\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1221
    },
    "1102": {
        "type": "lemma",
        "text": "text\\<open>If a relation up-directs a set, then a larger one does as well.\\<close>\n",
        "assumes": "assumes \"r {up-directs} X\" \"r\\<subseteq>R\"\n  ",
        "using": [
            "assms",
            "UpDirects_def"
        ],
        "statement": "lemma up_dir_mono: assumes \"r {up-directs} X\" \"r\\<subseteq>R\"\n  shows \"R {up-directs} X\" ",
        "proof": "using assms unfolding UpDirects_def\n  by blast\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1222
    },
    "1103": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that a total relation is reflexive.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\" and \"a\\<in>X\"\n  ",
        "using": [
            "assms",
            "IsTotal_def"
        ],
        "statement": "lemma Order_ZF_1_L1: assumes \"r {is total on} X\" and \"a\\<in>X\"\n  shows \"\\<langle>a,a\\<rangle> \\<in> r\" ",
        "proof": "using assms IsTotal_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1223
    },
    "1104": {
        "type": "lemma",
        "text": "text\\<open>A total relation is reflexive.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\"\n  ",
        "using": [
            "assms",
            "Order_ZF_1_L1",
            "refl_def"
        ],
        "statement": "lemma total_is_refl:\n  assumes \"r {is total on} X\"\n  shows \"refl(X,r)\" ",
        "proof": "using assms Order_ZF_1_L1 refl_def by simp\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1224
    },
    "1105": {
        "type": "lemma",
        "text": "text\\<open>A linear order is partial order.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \n  ",
        "using": [
            "assms",
            "IsLinOrder_def",
            "IsPartOrder_def",
            "refl_def",
            "Order_ZF_1_L1"
        ],
        "statement": "lemma Order_ZF_1_L2: assumes \"IsLinOrder(X,r)\" \n  shows \"IsPartOrder(X,r)\" \n  ",
        "proof": "using assms IsLinOrder_def IsPartOrder_def refl_def Order_ZF_1_L1\n  by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1225
    },
    "1106": {
        "type": "lemma",
        "text": "text\\<open>Partial order that is total is linear.\\<close>\n",
        "assumes": "assumes \"IsPartOrder(X,r)\" and \"r {is total on} X\"\n  ",
        "using": [
            "assms",
            "IsPartOrder_def",
            "IsLinOrder_def"
        ],
        "statement": "lemma Order_ZF_1_L3: \n  assumes \"IsPartOrder(X,r)\" and \"r {is total on} X\"\n  shows \"IsLinOrder(X,r)\"\n  ",
        "proof": "using assms IsPartOrder_def IsLinOrder_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1226
    },
    "1107": {
        "type": "lemma",
        "text": "text\\<open>Relation that is total on a set is total on any subset.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\" and \"A\\<subseteq>X\"\n  ",
        "using": [
            "assms",
            "IsTotal_def"
        ],
        "statement": "lemma Order_ZF_1_L4: assumes \"r {is total on} X\" and \"A\\<subseteq>X\"\n  shows \"r {is total on} A\"\n  ",
        "proof": "using assms IsTotal_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1227
    },
    "1108": {
        "type": "lemma",
        "text": "text\\<open>We can restrict a partial order relation to the domain. \\<close>\n",
        "assumes": "assumes \"IsPartOrder(X,r)\"\n  ",
        "using": [
            "assms",
            "IsPartOrder_def",
            "refl_def",
            "antisym_def",
            "trans_def"
        ],
        "statement": "lemma part_ord_restr: assumes \"IsPartOrder(X,r)\"\n  shows \"IsPartOrder(X,r \\<inter> X\\<times>X)\"\n  ",
        "proof": "using assms unfolding IsPartOrder_def refl_def antisym_def trans_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1228
    },
    "1109": {
        "type": "lemma",
        "text": "text\\<open> We can restrict a total order relation to the domain. \\<close>\n",
        "assumes": "assumes \"r {is total on} X\"\n  ",
        "using": [
            "assms",
            "IsTotal_def"
        ],
        "statement": "lemma total_ord_restr: assumes \"r {is total on} X\"\n  shows \"(r \\<inter> X\\<times>X) {is total on} X\"\n  ",
        "proof": "using assms unfolding IsTotal_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1229
    },
    "1110": {
        "type": "lemma",
        "text": "text\\<open>A linear relation is linear on any subset and we can restrict it to any subset.\\<close>\n",
        "assumes": "assumes  \"IsLinOrder(X,r)\" and \"A\\<subseteq>X\"\n  ",
        "using": [
            "IsLinOrder_def",
            "Order_ZF_1_L4",
            "Order_ZF_1_L2",
            "part_ord_restr",
            "total_ord_restr",
            "Order_ZF_1_L3"
        ],
        "statement": "lemma ord_linear_subset: assumes  \"IsLinOrder(X,r)\" and \"A\\<subseteq>X\"\n  shows  \"IsLinOrder(A,r)\" and  \"IsLinOrder(A,r \\<inter> A\\<times>A)\"\n",
        "proof": "proof -\n  from assms show \"IsLinOrder(A,r)\" using IsLinOrder_def Order_ZF_1_L4 by blast\n  then have \"IsPartOrder(A,r \\<inter> A\\<times>A)\" and \"(r \\<inter> A\\<times>A) {is total on} A\"\n    using Order_ZF_1_L2 part_ord_restr total_ord_restr unfolding IsLinOrder_def \n    by auto\n  then show \"IsLinOrder(A,r \\<inter> A\\<times>A)\" using Order_ZF_1_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1230
    },
    "1111": {
        "type": "lemma",
        "text": "text\\<open>If the relation is total, then every set is a union of those elements\n  that are nongreater than a given one and nonsmaller than a given one.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\" and \"A\\<subseteq>X\" and \"a\\<in>X\"\n  ",
        "using": [
            "assms",
            "IsTotal_def"
        ],
        "statement": "lemma Order_ZF_1_L5: \n  assumes \"r {is total on} X\" and \"A\\<subseteq>X\" and \"a\\<in>X\"\n  shows \"A = {x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r} \\<union> {x\\<in>A. \\<langle>a,x\\<rangle> \\<in> r}\"\n  ",
        "proof": "using assms IsTotal_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1231
    },
    "1112": {
        "type": "lemma",
        "text": "text\\<open>A technical fact about reflexive relations.\\<close>\n",
        "assumes": "assumes \"refl(X,r)\" and \"A \\<subseteq> B \\<union> {x}\" and \"B \\<subseteq> X\" and\n  \"x \\<in> X\" and \"\\<forall>y\\<in>B. \\<langle>y,x\\<rangle> \\<in> r\"\n  ",
        "using": [
            "assms",
            "refl_def"
        ],
        "statement": "lemma refl_add_point: \n  assumes \"refl(X,r)\" and \"A \\<subseteq> B \\<union> {x}\" and \"B \\<subseteq> X\" and\n  \"x \\<in> X\" and \"\\<forall>y\\<in>B. \\<langle>y,x\\<rangle> \\<in> r\"\n  shows \"\\<forall>a\\<in>A. \\<langle>a,x\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms refl_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1232
    },
    "1113": {
        "type": "lemma",
        "text": "text\\<open>The next lemma explains the notation of the definition of an interval.\\<close>\n",
        "assumes": "",
        "using": [
            "Interval_def"
        ],
        "statement": "lemma Order_ZF_2_L1: \n  shows \"x \\<in> Interval(r,a,b) \\<longleftrightarrow> \\<langle> a,x\\<rangle> \\<in> r \\<and> \\<langle> x,b\\<rangle> \\<in> r\"\n  ",
        "proof": "using Interval_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1233
    },
    "1114": {
        "type": "lemma",
        "text": "text\\<open> \\<open>Order_ZF_2_L1\\<close>, implication from right to left.\\<close>\n",
        "assumes": "assumes \"\\<langle> a,x\\<rangle> \\<in> r\"  \"\\<langle> x,b\\<rangle> \\<in> r\"\n  ",
        "using": [
            "assms",
            "Order_ZF_2_L1"
        ],
        "statement": "lemma Order_ZF_2_L1B: assumes \"\\<langle> a,x\\<rangle> \\<in> r\"  \"\\<langle> x,b\\<rangle> \\<in> r\"\n  shows \"x \\<in> Interval(r,a,b)\"\n  ",
        "proof": "using assms Order_ZF_2_L1 by simp\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1235
    },
    "1115": {
        "type": "lemma",
        "text": "text\\<open>If the relation is reflexive, the endpoints belong to the interval.\\<close>\n",
        "assumes": "assumes \"refl(X,r)\" \n  and \"a\\<in>X\"  \"b\\<in>X\" and \"\\<langle> a,b\\<rangle> \\<in> r\"\n  ",
        "using": [
            "assms",
            "refl_def",
            "Order_ZF_2_L1"
        ],
        "statement": "lemma Order_ZF_2_L2: assumes \"refl(X,r)\" \n  and \"a\\<in>X\"  \"b\\<in>X\" and \"\\<langle> a,b\\<rangle> \\<in> r\"\n  shows \n  \"a \\<in> Interval(r,a,b)\"  \n  \"b \\<in> Interval(r,a,b)\"  \n  ",
        "proof": "using assms refl_def Order_ZF_2_L1 by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1236
    },
    "1116": {
        "type": "lemma",
        "text": "text\\<open>Under the assumptions of \\<open>Order_ZF_2_L2\\<close>, the interval is \n  nonempty.\\<close>\n",
        "assumes": "assumes \"refl(X,r)\" \n  and \"a\\<in>X\"  \"b\\<in>X\" and \"\\<langle> a,b\\<rangle> \\<in> r\"\n  ",
        "using": [
            "Order_ZF_2_L2"
        ],
        "statement": "lemma Order_ZF_2_L2A: assumes \"refl(X,r)\" \n  and \"a\\<in>X\"  \"b\\<in>X\" and \"\\<langle> a,b\\<rangle> \\<in> r\"\n  shows \"Interval(r,a,b) \\<noteq> 0\"\n",
        "proof": "proof -\n  from assms have \"a \\<in> Interval(r,a,b)\"\n    using Order_ZF_2_L2 by simp\n  then show \"Interval(r,a,b) \\<noteq> 0\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1237
    },
    "1117": {
        "type": "lemma",
        "text": "text\\<open>If $a,b,c,d$ are in this order, then $[b,c]\\subseteq [a,d]$. We\n  only need trasitivity for this to be true.\\<close>\n",
        "assumes": "assumes A1: \"trans(r)\" and A2:\"\\<langle> a,b\\<rangle>\\<in>r\"  \"\\<langle> b,c\\<rangle>\\<in>r\"  \"\\<langle> c,d\\<rangle>\\<in>r\"\n",
        "using": [
            "Order_ZF_2_L1A",
            "Order_ZF_2_L1B"
        ],
        "statement": "lemma Order_ZF_2_L3: \n  assumes A1: \"trans(r)\" and A2:\"\\<langle> a,b\\<rangle>\\<in>r\"  \"\\<langle> b,c\\<rangle>\\<in>r\"  \"\\<langle> c,d\\<rangle>\\<in>r\"\nshows \"Interval(r,b,c) \\<subseteq> Interval(r,a,d)\"\n",
        "proof": "proof\n  fix x assume A3: \"x \\<in> Interval(r, b, c)\"\n  note A1\n  moreover from A2 A3 have \"\\<langle> a,b\\<rangle> \\<in> r \\<and> \\<langle> b,x\\<rangle> \\<in> r\" using Order_ZF_2_L1A\n    by simp\n  ultimately have T1: \"\\<langle> a,x\\<rangle> \\<in> r\" by (rule Fol1_L3)\n  note A1\n  moreover from A2 A3 have \"\\<langle> x,c\\<rangle> \\<in> r \\<and> \\<langle> c,d\\<rangle> \\<in> r\" using Order_ZF_2_L1A\n    by simp\n  ultimately have \"\\<langle> x,d\\<rangle> \\<in> r\" by (rule Fol1_L3)\n  with T1 show \"x \\<in> Interval(r,a,d)\" using Order_ZF_2_L1B\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1238
    },
    "1118": {
        "type": "lemma",
        "text": "text\\<open>For transitive relations the endpoints have to be in the relation for\n  the interval to be nonempty.\\<close>\n",
        "assumes": "assumes A1: \"trans(r)\" and A2: \"\\<langle> a,b\\<rangle> \\<notin> r\"\n  ",
        "using": [
            "Order_ZF_2_L1A",
            "Fol1_L3"
        ],
        "statement": "lemma Order_ZF_2_L5: assumes A1: \"trans(r)\" and A2: \"\\<langle> a,b\\<rangle> \\<notin> r\"\n  shows \"Interval(r,a,b) = 0\"\n",
        "proof": "proof -\n  { assume \"Interval(r,a,b)\\<noteq>0\" then obtain x where \"x \\<in> Interval(r,a,b)\"\n    by auto\n  with A1 A2 have False using Order_ZF_2_L1A Fol1_L3 by fast\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1240
    },
    "1119": {
        "type": "lemma",
        "text": "text\\<open>If a relation is defined on a set, then intervals are subsets of that\n  set.\\<close>\n",
        "assumes": "assumes A1: \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "assms",
            "Interval_def"
        ],
        "statement": "lemma Order_ZF_2_L6: assumes A1: \"r \\<subseteq> X\\<times>X\"\n  shows \"Interval(r,a,b) \\<subseteq> X\"\n  ",
        "proof": "using assms Interval_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1241
    },
    "1120": {
        "type": "lemma",
        "text": "text\\<open>For reflexive relations singletons are bounded.\\<close>\n",
        "assumes": "assumes \"refl(X,r)\" and \"a\\<in>X\"\n  ",
        "using": [
            "assms",
            "refl_def",
            "IsBoundedAbove_def",
            "IsBoundedBelow_def",
            "IsBounded_def"
        ],
        "statement": "lemma Order_ZF_3_L1: assumes \"refl(X,r)\" and \"a\\<in>X\"\n  shows \"IsBounded({a},r)\"\n  ",
        "proof": "using assms refl_def IsBoundedAbove_def IsBoundedBelow_def\n    IsBounded_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1242
    },
    "1121": {
        "type": "lemma",
        "text": "text\\<open>Sets that are bounded above are contained in the domain of \n  the relation.\\<close>\n",
        "assumes": "assumes \"r \\<subseteq> X\\<times>X\" \n  and \"IsBoundedAbove(A,r)\"\n  ",
        "using": [
            "assms",
            "IsBoundedAbove_def"
        ],
        "statement": "lemma Order_ZF_3_L1A: assumes \"r \\<subseteq> X\\<times>X\" \n  and \"IsBoundedAbove(A,r)\"\n  shows \"A\\<subseteq>X\" ",
        "proof": "using assms IsBoundedAbove_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1243
    },
    "1122": {
        "type": "lemma",
        "text": "text\\<open>For a total relation, the greater of two elements, \n  as defined above, is indeed greater of any of the two.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\"\n  and \"x\\<in>X\" \"y\\<in>X\"\n  ",
        "using": [
            "assms",
            "IsTotal_def",
            "Order_ZF_1_L1",
            "GreaterOf_def",
            "SmallerOf_def"
        ],
        "statement": "lemma Order_ZF_3_L2: assumes \"r {is total on} X\"\n  and \"x\\<in>X\" \"y\\<in>X\"\n  shows \n  \"\\<langle>x,GreaterOf(r,x,y)\\<rangle> \\<in> r\" \n  \"\\<langle>y,GreaterOf(r,x,y)\\<rangle> \\<in> r\"\n  \"\\<langle>SmallerOf(r,x,y),x\\<rangle> \\<in> r\" \n  \"\\<langle>SmallerOf(r,x,y),y\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms IsTotal_def Order_ZF_1_L1 GreaterOf_def SmallerOf_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1245
    },
    "1123": {
        "type": "lemma",
        "text": "text\\<open>If $A$ is bounded above by $u$, $B$ is bounded above by $w$,\n  then $A\\cup B$ is bounded above by the greater of $u,w$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"u\\<in>X\" \"w\\<in>X\" \n  and A4: \"\\<forall>x\\<in>A. \\<langle> x,u\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> x,w\\<rangle> \\<in> r\"\n  ",
        "using": [
            "Order_ZF_3_L2"
        ],
        "statement": "lemma Order_ZF_3_L2B:  \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"u\\<in>X\" \"w\\<in>X\" \n  and A4: \"\\<forall>x\\<in>A. \\<langle> x,u\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> x,w\\<rangle> \\<in> r\"\n  shows \"\\<forall>x\\<in>A\\<union>B. \\<langle>x,GreaterOf(r,u,w)\\<rangle> \\<in> r\"\n",
        "proof": "proof\n  let ?v = \"GreaterOf(r,u,w)\"\n  from A1 A3 have T1: \"\\<langle> u,?v\\<rangle> \\<in> r\" and T2: \"\\<langle> w,?v\\<rangle> \\<in> r\"\n    using Order_ZF_3_L2 by auto\n  fix x assume A5: \"x\\<in>A\\<union>B\" show \"\\<langle>x,?v\\<rangle> \\<in> r\"\n  proof -\n    { assume \"x\\<in>A\"\n    with A4 T1 have \"\\<langle> x,u\\<rangle> \\<in> r \\<and> \\<langle> u,?v\\<rangle> \\<in> r\" by simp\n    with A2 have \"\\<langle>x,?v\\<rangle> \\<in> r\" by (rule Fol1_L3) }\n  moreover\n  { assume \"x\\<notin>A\" \n    with A5 A4 T2 have \"\\<langle> x,w\\<rangle> \\<in> r \\<and> \\<langle> w,?v\\<rangle> \\<in> r\" by simp\n    with A2 have \"\\<langle>x,?v\\<rangle> \\<in> r\" by (rule Fol1_L3) }\n  ultimately show ?thesis by auto\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1246
    },
    "1124": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relation the union of two sets bounded \n  above is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedAbove(A,r)\" \"IsBoundedAbove(B,r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "IsBoundedAbove_def",
            "Order_ZF_3_L2B"
        ],
        "statement": "lemma Order_ZF_3_L3: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedAbove(A,r)\" \"IsBoundedAbove(B,r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\"\n  shows \"IsBoundedAbove(A\\<union>B,r)\"\n",
        "proof": "proof -\n  { assume \"A=0 \\<or> B=0\" \n    with A3 have \"IsBoundedAbove(A\\<union>B,r)\" by auto }\n  moreover\n  { assume \"\\<not> (A = 0 \\<or> B = 0)\"\n    then have T1: \"A\\<noteq>0\" \"B\\<noteq>0\" by auto\n    with A3 obtain u w where D1: \"\\<forall>x\\<in>A. \\<langle> x,u\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> x,w\\<rangle> \\<in> r\"\n      using IsBoundedAbove_def by auto\n    let ?U = \"GreaterOf(r,u,w)\"\n    from T1 A4 D1 have \"u\\<in>X\" \"w\\<in>X\" by auto\n    with A1 A2 D1 have \"\\<forall>x\\<in>A\\<union>B.\\<langle> x,?U\\<rangle> \\<in> r\"\n      using Order_ZF_3_L2B by blast\n    then have \"IsBoundedAbove(A\\<union>B,r)\"\n      using IsBoundedAbove_def by auto }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1247
    },
    "1125": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations if a set $A$ is bounded above then \n  $A\\cup \\{a\\}$ is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedAbove(A,r)\" and A4: \"a\\<in>X\" and A5: \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "total_is_refl",
            "Order_ZF_3_L1",
            "IsBounded_def",
            "Order_ZF_3_L3"
        ],
        "statement": "lemma Order_ZF_3_L4: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedAbove(A,r)\" and A4: \"a\\<in>X\" and A5: \"r \\<subseteq> X\\<times>X\"\n  shows \"IsBoundedAbove(A\\<union>{a},r)\"\n",
        "proof": "proof -\n  from A1 have \"refl(X,r)\"\n    using total_is_refl by simp\n  with assms show ?thesis using\n    Order_ZF_3_L1 IsBounded_def Order_ZF_3_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1248
    },
    "1126": {
        "type": "lemma",
        "text": "text\\<open>If $A$ is bounded below by $l$, $B$ is bounded below by $m$,\n  then $A\\cup B$ is bounded below by the smaller of $u,w$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"l\\<in>X\" \"m\\<in>X\" \n  and A4: \"\\<forall>x\\<in>A. \\<langle> l,x\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> m,x\\<rangle> \\<in> r\"\n  ",
        "using": [
            "Order_ZF_3_L2"
        ],
        "statement": "lemma Order_ZF_3_L5B:  \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"l\\<in>X\" \"m\\<in>X\" \n  and A4: \"\\<forall>x\\<in>A. \\<langle> l,x\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> m,x\\<rangle> \\<in> r\"\n  shows \"\\<forall>x\\<in>A\\<union>B. \\<langle>SmallerOf(r,l,m),x\\<rangle> \\<in> r\"\n",
        "proof": "proof\n  let ?k = \"SmallerOf(r,l,m)\"\n  from A1 A3 have T1: \"\\<langle> ?k,l\\<rangle> \\<in> r\" and T2: \"\\<langle> ?k,m\\<rangle> \\<in> r\"\n    using Order_ZF_3_L2 by auto\n  fix x assume A5: \"x\\<in>A\\<union>B\" show \"\\<langle>?k,x\\<rangle> \\<in> r\"\n  proof -\n    { assume \"x\\<in>A\"\n      with A4 T1 have \"\\<langle> ?k,l\\<rangle> \\<in> r \\<and> \\<langle> l,x\\<rangle> \\<in> r\" by simp\n      with A2 have \"\\<langle>?k,x\\<rangle> \\<in> r\" by (rule Fol1_L3) }\n    moreover\n    { assume \"x\\<notin>A\" \n      with A5 A4 T2 have \"\\<langle> ?k,m\\<rangle> \\<in> r \\<and> \\<langle> m,x\\<rangle> \\<in> r\" by simp\n      with A2 have \"\\<langle>?k,x\\<rangle> \\<in> r\" by (rule Fol1_L3) }\n    ultimately show ?thesis by auto\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1249
    },
    "1127": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relation the union of two sets bounded \n  below is bounded below.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedBelow(A,r)\" \"IsBoundedBelow(B,r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "IsBoundedBelow_def",
            "Order_ZF_3_L5B"
        ],
        "statement": "lemma Order_ZF_3_L6: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedBelow(A,r)\" \"IsBoundedBelow(B,r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\"\n  shows \"IsBoundedBelow(A\\<union>B,r)\"\n",
        "proof": "proof -\n  { assume \"A=0 \\<or> B=0\" \n    with A3 have ?thesis by auto }\n  moreover\n  { assume \"\\<not> (A = 0 \\<or> B = 0)\"\n    then have T1: \"A\\<noteq>0\" \"B\\<noteq>0\" by auto\n    with A3 obtain l m where D1: \"\\<forall>x\\<in>A. \\<langle> l,x\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> m,x\\<rangle> \\<in> r\"\n      using IsBoundedBelow_def by auto\n    let ?L = \"SmallerOf(r,l,m)\"\n    from T1 A4 D1 have T1: \"l\\<in>X\" \"m\\<in>X\" by auto\n    with A1 A2 D1 have \"\\<forall>x\\<in>A\\<union>B.\\<langle> ?L,x\\<rangle> \\<in> r\"\n      using Order_ZF_3_L5B by blast\n    then have \"IsBoundedBelow(A\\<union>B,r)\"\n      using IsBoundedBelow_def by auto }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1250
    },
    "1128": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations if a set $A$ is bounded below then \n  $A\\cup \\{a\\}$ is bounded below.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedBelow(A,r)\" and A4: \"a\\<in>X\" and A5: \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "total_is_refl",
            "Order_ZF_3_L1",
            "IsBounded_def",
            "Order_ZF_3_L6"
        ],
        "statement": "lemma Order_ZF_3_L7:\n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"IsBoundedBelow(A,r)\" and A4: \"a\\<in>X\" and A5: \"r \\<subseteq> X\\<times>X\"\n  shows \"IsBoundedBelow(A\\<union>{a},r)\"\n",
        "proof": "proof -\n  from A1 have \"refl(X,r)\"\n    using total_is_refl by simp\n  with assms show ?thesis using\n    Order_ZF_3_L1 IsBounded_def Order_ZF_3_L6 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1251
    },
    "1129": {
        "type": "theorem",
        "text": "text\\<open>For total and transitive relations unions of two bounded sets are \n  bounded.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\" and \"trans(r)\" \n  and \"IsBounded(A,r)\" \"IsBounded(B,r)\"\n  and \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "assms",
            "Order_ZF_3_L3",
            "Order_ZF_3_L6",
            "Order_ZF_3_L7",
            "IsBounded_def"
        ],
        "statement": "theorem Order_ZF_3_T1: \n  assumes \"r {is total on} X\" and \"trans(r)\" \n  and \"IsBounded(A,r)\" \"IsBounded(B,r)\"\n  and \"r \\<subseteq> X\\<times>X\"\n  shows \"IsBounded(A\\<union>B,r)\"\n  ",
        "proof": "using assms Order_ZF_3_L3 Order_ZF_3_L6 Order_ZF_3_L7 IsBounded_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1252
    },
    "1130": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations if a set $A$ is bounded then \n  $A\\cup \\{a\\}$ is bounded.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\" and \"trans(r)\"\n  and \"IsBounded(A,r)\" and \"a\\<in>X\" and \"r \\<subseteq> X\\<times>X\"\n  ",
        "using": [
            "assms",
            "total_is_refl",
            "Order_ZF_3_L1",
            "Order_ZF_3_T1"
        ],
        "statement": "lemma Order_ZF_3_L8: \n  assumes \"r {is total on} X\" and \"trans(r)\"\n  and \"IsBounded(A,r)\" and \"a\\<in>X\" and \"r \\<subseteq> X\\<times>X\"\n  shows \"IsBounded(A\\<union>{a},r)\"\n  ",
        "proof": "using assms total_is_refl Order_ZF_3_L1 Order_ZF_3_T1 by blast\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1253
    },
    "1131": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for a set to be bounded below.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>a\\<in>A. \\<langle>l,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "IsBoundedBelow_def"
        ],
        "statement": "lemma Order_ZF_3_L9: assumes A1: \"\\<forall>a\\<in>A. \\<langle>l,a\\<rangle> \\<in> r\"\n  shows \"IsBoundedBelow(A,r)\"\n",
        "proof": "proof -\n  from A1 have \"\\<exists>l. \\<forall>x\\<in>A. \\<langle>l,x\\<rangle> \\<in> r\"\n    by auto\n  then show \"IsBoundedBelow(A,r)\"\n    using IsBoundedBelow_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1254
    },
    "1132": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for a set to be bounded above.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>a\\<in>A. \\<langle>a,u\\<rangle> \\<in> r\"\n  ",
        "using": [
            "IsBoundedAbove_def"
        ],
        "statement": "lemma Order_ZF_3_L10: assumes A1: \"\\<forall>a\\<in>A. \\<langle>a,u\\<rangle> \\<in> r\"\n  shows \"IsBoundedAbove(A,r)\"\n",
        "proof": "proof -\n  from A1 have \"\\<exists>u. \\<forall>x\\<in>A. \\<langle>x,u\\<rangle> \\<in> r\"\n    by auto\n  then show \"IsBoundedAbove(A,r)\"\n    using IsBoundedAbove_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1255
    },
    "1133": {
        "type": "lemma",
        "text": "text\\<open>Intervals are bounded.\\<close>\n",
        "assumes": "",
        "using": [
            "Order_ZF_2_L1A",
            "IsBoundedAbove_def",
            "IsBoundedBelow_def",
            "IsBounded_def"
        ],
        "statement": "lemma Order_ZF_3_L11: shows \n  \"IsBoundedAbove(Interval(r,a,b),r)\"\n  \"IsBoundedBelow(Interval(r,a,b),r)\"\n  \"IsBounded(Interval(r,a,b),r)\"\n",
        "proof": "proof -\n  { fix x assume \"x \\<in> Interval(r,a,b)\" \n    then have \"\\<langle> x,b\\<rangle> \\<in> r\"  \"\\<langle> a,x\\<rangle> \\<in> r\" \n      using Order_ZF_2_L1A by auto\n  } then have \n      \"\\<exists>u. \\<forall>x\\<in>Interval(r,a,b). \\<langle> x,u\\<rangle> \\<in> r\" \n      \"\\<exists>l. \\<forall>x\\<in>Interval(r,a,b). \\<langle> l,x\\<rangle> \\<in> r\"\n    by auto\n  then show \n    \"IsBoundedAbove(Interval(r,a,b),r)\"\n    \"IsBoundedBelow(Interval(r,a,b),r)\"\n    \"IsBounded(Interval(r,a,b),r)\"\n    using IsBoundedAbove_def IsBoundedBelow_def IsBounded_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1256
    },
    "1134": {
        "type": "lemma",
        "text": "text\\<open>A subset of a set that is bounded below is bounded below.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedBelow(A,r)\" and A2: \"B\\<subseteq>A\"\n  ",
        "using": [
            "IsBoundedBelow_def"
        ],
        "statement": "lemma Order_ZF_3_L12: assumes A1: \"IsBoundedBelow(A,r)\" and A2: \"B\\<subseteq>A\"\n  shows \"IsBoundedBelow(B,r)\"\n",
        "proof": "proof -\n  { assume \"A = 0\"\n    with assms have \"IsBoundedBelow(B,r)\" \n      using IsBoundedBelow_def by auto }\n  moreover\n  { assume \"A \\<noteq> 0\"\n    with A1 have \"\\<exists>l. \\<forall>x\\<in>A. \\<langle>l,x\\<rangle> \\<in> r\"\n      using IsBoundedBelow_def by simp\n    with A2 have \"\\<exists>l.\\<forall>x\\<in>B. \\<langle>l,x\\<rangle> \\<in> r\" by auto\n    then have \"IsBoundedBelow(B,r)\" using IsBoundedBelow_def\n      by auto }\n  ultimately show \"IsBoundedBelow(B,r)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1257
    },
    "1135": {
        "type": "lemma",
        "text": "text\\<open>A subset of a set that is bounded above is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(A,r)\" and A2: \"B\\<subseteq>A\"\n  ",
        "using": [
            "IsBoundedAbove_def"
        ],
        "statement": "lemma Order_ZF_3_L13: assumes A1: \"IsBoundedAbove(A,r)\" and A2: \"B\\<subseteq>A\"\n  shows \"IsBoundedAbove(B,r)\"\n",
        "proof": "proof -\n  { assume \"A = 0\"\n    with assms have \"IsBoundedAbove(B,r)\" \n      using IsBoundedAbove_def by auto }\n  moreover\n  { assume \"A \\<noteq> 0\"\n    with A1 have \"\\<exists>u. \\<forall>x\\<in>A. \\<langle>x,u\\<rangle> \\<in> r\"\n      using IsBoundedAbove_def by simp\n    with A2 have \"\\<exists>u.\\<forall>x\\<in>B. \\<langle>x,u\\<rangle> \\<in> r\" by auto\n    then have \"IsBoundedAbove(B,r)\" using IsBoundedAbove_def\n      by auto }\n  ultimately show \"IsBoundedAbove(B,r)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1258
    },
    "1136": {
        "type": "lemma",
        "text": "text\\<open>The set of elements in a set $A$ that are nongreater than \n  a given element is bounded above.\\<close>\n",
        "assumes": "",
        "using": [
            "IsBoundedAbove_def"
        ],
        "statement": "lemma Order_ZF_3_L15: shows \"IsBoundedAbove({x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r},r)\"\n  ",
        "proof": "using IsBoundedAbove_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1260
    },
    "1137": {
        "type": "lemma",
        "text": "text\\<open>If $A$ is bounded below, then the set of elements in a set $A$ \n  that are nongreater than a given element is bounded.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedBelow(A,r)\"\n  ",
        "using": [
            "IsBoundedBelow_def",
            "IsBoundedAbove_def",
            "IsBounded_def",
            "Order_ZF_3_L15"
        ],
        "statement": "lemma Order_ZF_3_L16: assumes A1: \"IsBoundedBelow(A,r)\"\n  shows \"IsBounded({x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r},r)\"\n",
        "proof": "proof -\n  { assume \"A=0\" \n    then have \"IsBounded({x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r},r)\"\n      using IsBoundedBelow_def IsBoundedAbove_def IsBounded_def\n      by auto }\n  moreover\n  { assume \"A\\<noteq>0\"\n    with A1 obtain l where I: \"\\<forall>x\\<in>A. \\<langle>l,x\\<rangle> \\<in> r\"\n      using IsBoundedBelow_def by auto\n    then have \"\\<forall>y\\<in>{x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r}. \\<langle>l,y\\<rangle> \\<in> r\" by simp\n    then have \"IsBoundedBelow({x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r},r)\"\n      by (rule Order_ZF_3_L9)\n    then have \"IsBounded({x\\<in>A. \\<langle>x,a\\<rangle> \\<in> r},r)\" \n      using Order_ZF_3_L15 IsBounded_def by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1261
    },
    "1138": {
        "type": "definition",
        "text": "text\\<open>The next definition is the strict version of the linear order.\n  What we write as \\<open>R Orders A\\<close> is written $R Ord A$ in Metamath.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\nStrictOrder (infix \"Orders\" 65) where\n  \"R Orders A \\<equiv> \\<forall>x y z. (x\\<in>A \\<and> y\\<in>A \\<and> z\\<in>A) \\<longrightarrow> \n  (\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)) \\<and> \n  (\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R)\"\n",
        "proof": "",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1262
    },
    "1139": {
        "type": "definition",
        "text": "text\\<open>The definition of supremum for a (strict) linear order.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Sup(B,A,R) \\<equiv> \n  \\<Union> {x \\<in> A. (\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> \n  (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> (\\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))}\"\n",
        "proof": "",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1263
    },
    "1140": {
        "type": "definition",
        "text": "text\\<open>Definition of infimum for a linear order. \n  It is defined in terms of supremum.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Infim(B,A,R) \\<equiv> Sup(B,A,converse(R))\"\n",
        "proof": "",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1264
    },
    "1141": {
        "type": "lemma",
        "text": "text\\<open>If relation $R$ orders a set $A$, (in Metamath sense) then $R$ \n  is irreflexive, transitive and linear therefore is a total order on $A$ \n  (in Isabelle sense).\\<close>\n",
        "assumes": "assumes A1: \"R Orders A\"\n  ",
        "using": [
            "irrefl_def",
            "part_ord_def",
            "tot_ord_def"
        ],
        "statement": "lemma orders_imp_tot_ord: assumes A1: \"R Orders A\"\n  shows \n  \"irrefl(A,R)\"\n  \"trans[A](R)\"\n  \"part_ord(A,R)\"\n  \"linear(A,R)\"\n  \"tot_ord(A,R)\"\n",
        "proof": "proof -\n  from A1 have I:\n    \"\\<forall>x y z. (x\\<in>A \\<and> y\\<in>A \\<and> z\\<in>A) \\<longrightarrow> \n    (\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)) \\<and> \n    (\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R)\"\n    unfolding StrictOrder_def by simp\n  then have \"\\<forall>x\\<in>A. \\<langle>x,x\\<rangle> \\<notin> R\" by blast\n  then show \"irrefl(A,R)\" using irrefl_def by simp\n  moreover\n  from I have \n    \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. \\<forall>z\\<in>A. \\<langle>x,y\\<rangle> \\<in> R \\<longrightarrow> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R\"\n    by blast\n  then show \"trans[A](R)\" unfolding trans_on_def by blast\n  ultimately show \"part_ord(A,R)\" using part_ord_def\n    by simp\n  moreover\n  from I have\n    \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> R \\<or> x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R\"\n    by blast\n  then show \"linear(A,R)\" unfolding linear_def by blast\n  ultimately show \"tot_ord(A,R)\" using tot_ord_def\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1265
    },
    "1142": {
        "type": "lemma",
        "text": "text\\<open>A converse of \\<open>orders_imp_tot_ord\\<close>. Together with that\n  theorem this shows that Metamath's notion of an order relation is equivalent to\n  Isabelles \\<open>tot_ord\\<close> predicate.\\<close>\n",
        "assumes": "assumes A1: \"tot_ord(A,R)\"\n  ",
        "using": [
            "tot_ord_def",
            "part_ord_def",
            "part_ord_Imp_asym",
            "irrefl_def",
            "StrictOrder_def"
        ],
        "statement": "lemma tot_ord_imp_orders: assumes A1: \"tot_ord(A,R)\"\n  shows \"R Orders A\"\n",
        "proof": "proof -\n  from A1 have \n    I: \"linear(A,R)\" and  \n    II: \"irrefl(A,R)\" and \n    III: \"trans[A](R)\" and\n    IV: \"part_ord(A,R)\"\n    using tot_ord_def part_ord_def by auto\n  from IV have \"asym(R \\<inter> A\\<times>A)\"\n    using part_ord_Imp_asym by simp\n  then have V: \"\\<forall>x y. \\<langle>x,y\\<rangle> \\<in> (R \\<inter> A\\<times>A) \\<longrightarrow> \\<not>(\\<langle>y,x\\<rangle> \\<in> (R \\<inter> A\\<times>A))\"\n    unfolding asym_def by blast\n  from I have VI: \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> R \\<or> x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R\"\n    unfolding linear_def by blast\n  from III have VII:\n    \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. \\<forall>z\\<in>A. \\<langle>x,y\\<rangle> \\<in> R \\<longrightarrow> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R\"\n    unfolding trans_on_def by blast\n  { fix x y z\n    assume T: \"x\\<in>A\" \"y\\<in>A\" \"z\\<in>A\"\n    have \"\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)\"\n    proof\n      assume A2: \"\\<langle>x,y\\<rangle> \\<in> R\"\n      with V T have  \"\\<not>(\\<langle>y,x\\<rangle> \\<in> R)\" by blast\n      moreover from II T A2 have \"x\\<noteq>y\" using irrefl_def\n\tby auto\n      ultimately show \"\\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)\" by simp\n    next assume  \"\\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)\"\n      with VI T show \"\\<langle>x,y\\<rangle> \\<in> R\" by auto\n    qed\n    moreover from VII T have\n      \"\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R\"\n      by blast\n    ultimately have \"(\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)) \\<and> \n      (\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R)\"\n      by simp\n  } then have \"\\<forall>x y z. (x\\<in>A \\<and> y\\<in>A \\<and> z\\<in>A) \\<longrightarrow> \n      (\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)) \\<and> \n      (\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R)\"\n    by auto\n  then show \"R Orders A\" using StrictOrder_def by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1266
    },
    "1143": {
        "type": "lemma",
        "text": "text\\<open>Supremum is unique, if it exists.\\<close>\n",
        "assumes": "assumes A1: \"R Orders A\" and A2: \"x\\<in>A\" and\n  A3: \"\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R\" and A4: \"\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R  \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R)\"\n   ",
        "using": [
            "orders_imp_tot_ord",
            "tot_ord_def"
        ],
        "statement": "lemma supeu: assumes A1: \"R Orders A\" and A2: \"x\\<in>A\" and\n  A3: \"\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R\" and A4: \"\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R  \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R)\"\n   shows \n  \"\\<exists>!x. x\\<in>A\\<and>(\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n",
        "proof": "proof\n  from A2 A3 A4 show\n    \"\\<exists> x. x\\<in>A\\<and>(\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n    by auto\nnext fix x\\<^sub>1 x\\<^sub>2\n  assume A5:\n    \"x\\<^sub>1 \\<in> A \\<and> (\\<forall>y\\<in>B. \\<langle>x\\<^sub>1,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<^sub>1\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n    \"x\\<^sub>2 \\<in> A \\<and> (\\<forall>y\\<in>B. \\<langle>x\\<^sub>2,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<^sub>2\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n  from A1 have \"linear(A,R)\" using orders_imp_tot_ord tot_ord_def\n    by simp\n  then have \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> R \\<or> x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R\"\n    unfolding linear_def by blast\n  with A5 have \"\\<langle>x\\<^sub>1,x\\<^sub>2\\<rangle> \\<in> R \\<or> x\\<^sub>1=x\\<^sub>2 \\<or> \\<langle>x\\<^sub>2,x\\<^sub>1\\<rangle> \\<in> R\" by blast\n  moreover \n  { assume \"\\<langle>x\\<^sub>1,x\\<^sub>2\\<rangle> \\<in> R\"\n    with A5 obtain z where \"z\\<in>B\" and \"\\<langle>x\\<^sub>1,z\\<rangle> \\<in> R\" by auto\n    with A5 have False by auto }\n  moreover\n  { assume \"\\<langle>x\\<^sub>2,x\\<^sub>1\\<rangle> \\<in> R\"\n    with A5 obtain z where \"z\\<in>B\" and \"\\<langle>x\\<^sub>2,z\\<rangle> \\<in> R\" by auto\n    with A5 have False by auto }\n  ultimately  show \"x\\<^sub>1 = x\\<^sub>2\" by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1268
    },
    "1144": {
        "type": "lemma",
        "text": "text\\<open>Supremum has expected properties if it exists.\\<close>\n",
        "assumes": "assumes A1: \"R Orders A\" and \n  A2: \"\\<exists>x\\<in>A. (\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n  ",
        "using": [
            "supeu",
            "Sup_def"
        ],
        "statement": "lemma sup_props: assumes A1: \"R Orders A\" and \n  A2: \"\\<exists>x\\<in>A. (\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n  shows \n  \"Sup(B,A,R) \\<in> A\"\n  \"\\<forall>y\\<in>B. \\<langle>Sup(B,A,R),y\\<rangle> \\<notin> R\"\n  \"\\<forall>y\\<in>A. \\<langle>y,Sup(B,A,R)\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R )\"\n",
        "proof": "proof -\n  let ?S = \"{x\\<in>A. (\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R ) ) }\"\n  from A2 obtain x where \n    \"x\\<in>A\" and \"(\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R)\" and \"\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R)\"\n    by auto\n  with A1 have I:\n    \"\\<exists>!x. x\\<in>A\\<and>(\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n    using supeu by simp\n  then have \"( \\<Union>?S ) \\<in> A\" by (rule ZF1_1_L9)\n  then show \"Sup(B,A,R) \\<in> A\" using Sup_def by simp\n  from I have II:\n    \"(\\<forall>y\\<in>B. \\<langle>\\<Union>?S ,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,\\<Union>?S\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n    by (rule ZF1_1_L9)\n  hence \"\\<forall>y\\<in>B. \\<langle>\\<Union>?S,y\\<rangle> \\<notin> R\" by blast\n  moreover have III: \"(\\<Union>?S) = Sup(B,A,R)\" using Sup_def by simp\n  ultimately show \"\\<forall>y\\<in>B. \\<langle>Sup(B,A,R),y\\<rangle> \\<notin> R\" by simp\n  from II have IV: \"\\<forall>y\\<in>A. \\<langle>y,\\<Union>?S\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R)\"\n    by blast\n  { fix y assume A3: \"y\\<in>A\" and \"\\<langle>y,Sup(B,A,R)\\<rangle> \\<in> R\"\n    with III have \"\\<langle>y,\\<Union>?S\\<rangle> \\<in> R\" by simp\n    with IV A3 have \"\\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R\" by blast\n  } thus  \"\\<forall>y\\<in>A. \\<langle>y,Sup(B,A,R)\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R )\"\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1269
    },
    "1145": {
        "type": "lemma",
        "text": "text\\<open>Elements greater or equal than any element of $B$ are \n  greater or equal than supremum of $B$.\\<close>\n",
        "assumes": "assumes A1: \"R Orders A\" and A2: \n  \"\\<exists>x\\<in>A. (\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n  and A3: \"c \\<in> A\" and A4: \"\\<forall>z\\<in>B. \\<langle>c,z\\<rangle> \\<notin> R\"\n  ",
        "using": [],
        "statement": "lemma supnub: assumes A1: \"R Orders A\" and A2: \n  \"\\<exists>x\\<in>A. (\\<forall>y\\<in>B. \\<langle>x,y\\<rangle> \\<notin> R) \\<and> (\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R))\"\n  and A3: \"c \\<in> A\" and A4: \"\\<forall>z\\<in>B. \\<langle>c,z\\<rangle> \\<notin> R\"\n  shows \"\\<langle>c, Sup(B,A,R)\\<rangle> \\<notin> R\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"\\<forall>y\\<in>A. \\<langle>y,Sup(B,A,R)\\<rangle> \\<in> R \\<longrightarrow> ( \\<exists>z\\<in>B. \\<langle>y,z\\<rangle> \\<in> R )\"\n    by (rule sup_props)\n  with A3 A4 show \"\\<langle>c, Sup(B,A,R)\\<rangle> \\<notin> R\" by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1270
    },
    "1146": {
        "type": "lemma",
        "text": "text\\<open>A somewhat technical fact that allows to reduce the number of premises in some\n  theorems: the assumption that a set has a maximum implies that it is not empty. \\<close>\n",
        "assumes": "assumes \"HasAmaximum(r,A)\" ",
        "using": [
            "assms",
            "HasAmaximum_def"
        ],
        "statement": "lemma set_max_not_empty: assumes \"HasAmaximum(r,A)\" shows \"A\\<noteq>0\"\n  ",
        "proof": "using assms unfolding HasAmaximum_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1271
    },
    "1147": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum implies that it is not empty. \\<close>\n",
        "assumes": "assumes \"HasAminimum(r,A)\" ",
        "using": [
            "assms",
            "HasAminimum_def"
        ],
        "statement": "lemma set_min_not_empty: assumes \"HasAminimum(r,A)\" shows \"A\\<noteq>0\"\n  ",
        "proof": "using assms unfolding HasAminimum_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1272
    },
    "1148": {
        "type": "lemma",
        "text": "text\\<open>If a set has a supremum then it cannot be empty. We are probably using the fact that \n  $\\bigcap  \\emptyset = \\emptyset $, which makes me a bit anxious \n  as this I think is just a convention. \\<close>\n",
        "assumes": "assumes \"HasAsupremum(r,A)\" ",
        "using": [
            "set_min_not_empty"
        ],
        "statement": "lemma set_sup_not_empty: assumes \"HasAsupremum(r,A)\" shows \"A\\<noteq>0\"\n",
        "proof": "proof -\n  from assms have \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\" unfolding HasAsupremum_def\n    by simp \n  then have \"(\\<Inter>a\\<in>A. r``{a}) \\<noteq> 0\" using set_min_not_empty by simp\n  then obtain x where \"x \\<in> (\\<Inter>y\\<in>A. r``{y})\" by blast\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1273
    },
    "1149": {
        "type": "lemma",
        "text": "text\\<open>If a set has an infimum then it cannot be empty.  \\<close>\n",
        "assumes": "assumes \"HasAnInfimum(r,A)\" ",
        "using": [
            "set_max_not_empty"
        ],
        "statement": "lemma set_inf_not_empty: assumes \"HasAnInfimum(r,A)\" shows \"A\\<noteq>0\"\n",
        "proof": "proof -\n  from assms have \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\" unfolding HasAnInfimum_def\n    by simp \n  then have \"(\\<Inter>a\\<in>A. r-``{a}) \\<noteq> 0\" using set_max_not_empty by simp\n  then obtain x where \"x \\<in> (\\<Inter>y\\<in>A. r-``{y})\" by blast\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1274
    },
    "1150": {
        "type": "lemma",
        "text": "text\\<open>For antisymmetric relations maximum of a set is unique if it exists.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "HasAmaximum_def"
        ],
        "statement": "lemma Order_ZF_4_L1: assumes A1: \"antisym(r)\" and A2: \"HasAmaximum(r,A)\"\n  shows \"\\<exists>!M. M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> x,M\\<rangle> \\<in> r)\"\n",
        "proof": "proof\n  from A2 show \"\\<exists>M. M \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>x, M\\<rangle> \\<in> r)\"\n    using HasAmaximum_def by auto\n  fix M1 M2 assume \n    A2: \"M1 \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>x, M1\\<rangle> \\<in> r)\" \"M2 \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>x, M2\\<rangle> \\<in> r)\"\n    then have \"\\<langle>M1,M2\\<rangle> \\<in> r\" \"\\<langle>M2,M1\\<rangle> \\<in> r\" by auto\n    with A1 show \"M1=M2\" by (rule Fol1_L4)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1275
    },
    "1151": {
        "type": "lemma",
        "text": "text\\<open>Maximum of a set has desired properties.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "Maximum_def"
        ],
        "statement": "lemma Order_ZF_4_L3: assumes A1: \"antisym(r)\" and A2: \"HasAmaximum(r,A)\"\n  shows \"Maximum(r,A) \\<in> A\" \"\\<forall>x\\<in>A. \\<langle>x,Maximum(r,A)\\<rangle> \\<in> r\"\n",
        "proof": "proof - \n  let ?Max = \"THE M. M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> x,M\\<rangle> \\<in> r)\" \n  from A1 A2 have \"\\<exists>!M. M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> x,M\\<rangle> \\<in> r)\"\n    by (rule Order_ZF_4_L1)\n  then have \"?Max \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle> x,?Max\\<rangle> \\<in> r)\"\n    by (rule theI)\n  then show \"Maximum(r,A) \\<in> A\" \"\\<forall>x\\<in>A. \\<langle>x,Maximum(r,A)\\<rangle> \\<in> r\"\n    using Maximum_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1277
    },
    "1152": {
        "type": "lemma",
        "text": "text\\<open>Minimum of a set has desired properties.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"HasAminimum(r,A)\"\n  ",
        "using": [
            "Minimum_def"
        ],
        "statement": "lemma Order_ZF_4_L4: assumes A1: \"antisym(r)\" and A2: \"HasAminimum(r,A)\"\n  shows \"Minimum(r,A) \\<in> A\" \"\\<forall>x\\<in>A. \\<langle>Minimum(r,A),x\\<rangle> \\<in> r\"\n",
        "proof": "proof - \n  let ?Min = \"THE m. m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> m,x\\<rangle> \\<in> r)\" \n  from A1 A2 have \"\\<exists>!m. m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> m,x\\<rangle> \\<in> r)\"\n    by (rule Order_ZF_4_L2)\n  then have \"?Min \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle> ?Min,x\\<rangle> \\<in> r)\"\n    by (rule theI)\n  then show \"Minimum(r,A) \\<in> A\" \"\\<forall>x\\<in>A. \\<langle>Minimum(r,A),x\\<rangle> \\<in> r\"\n    using Minimum_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1278
    },
    "1153": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations a union a of two sets that have \n  maxima has a maximum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} (A\\<union>B)\" and A2: \"trans(r)\"\n  and A3: \"HasAmaximum(r,A)\" \"HasAmaximum(r,B)\"\n  ",
        "using": [
            "HasAmaximum_def",
            "GreaterOf_def",
            "IsTotal_def"
        ],
        "statement": "lemma Order_ZF_4_L5: \n  assumes A1: \"r {is total on} (A\\<union>B)\" and A2: \"trans(r)\"\n  and A3: \"HasAmaximum(r,A)\" \"HasAmaximum(r,B)\"\n  shows \"HasAmaximum(r,A\\<union>B)\"\n",
        "proof": "proof -\n  from A3 obtain M K where \n    D1: \"M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> x,M\\<rangle> \\<in> r)\" \"K\\<in>B \\<and> (\\<forall>x\\<in>B. \\<langle> x,K\\<rangle> \\<in> r)\" \n    using HasAmaximum_def by auto\n  let ?L = \"GreaterOf(r,M,K)\"\n  from D1 have T1: \"M \\<in> A\\<union>B\" \"K \\<in> A\\<union>B\" \n    \"\\<forall>x\\<in>A. \\<langle> x,M\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> x,K\\<rangle> \\<in> r\"\n    by auto\n  with A1 A2 have \"\\<forall>x\\<in>A\\<union>B.\\<langle> x,?L\\<rangle> \\<in> r\" by (rule Order_ZF_3_L2B)\n  moreover from T1 have \"?L \\<in> A\\<union>B\" using GreaterOf_def IsTotal_def \n    by simp\n  ultimately show \"HasAmaximum(r,A\\<union>B)\" using HasAmaximum_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1279
    },
    "1154": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations A union a of two sets that have \n  minima has a minimum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} (A\\<union>B)\" and A2: \"trans(r)\"\n  and A3: \"HasAminimum(r,A)\" \"HasAminimum(r,B)\"\n  ",
        "using": [
            "HasAminimum_def",
            "SmallerOf_def",
            "IsTotal_def"
        ],
        "statement": "lemma Order_ZF_4_L6: \n  assumes A1: \"r {is total on} (A\\<union>B)\" and A2: \"trans(r)\"\n  and A3: \"HasAminimum(r,A)\" \"HasAminimum(r,B)\"\n  shows \"HasAminimum(r,A\\<union>B)\"\n",
        "proof": "proof -\n  from A3 obtain m k where \n    D1: \"m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> m,x\\<rangle> \\<in> r)\" \"k\\<in>B \\<and> (\\<forall>x\\<in>B. \\<langle> k,x\\<rangle> \\<in> r)\" \n    using HasAminimum_def by auto\n  let ?l = \"SmallerOf(r,m,k)\"\n  from D1 have T1: \"m \\<in> A\\<union>B\" \"k \\<in> A\\<union>B\" \n    \"\\<forall>x\\<in>A. \\<langle> m,x\\<rangle> \\<in> r\" \"\\<forall>x\\<in>B. \\<langle> k,x\\<rangle> \\<in> r\"\n    by auto\n  with A1 A2 have \"\\<forall>x\\<in>A\\<union>B.\\<langle> ?l,x\\<rangle> \\<in> r\" by (rule Order_ZF_3_L5B)\n  moreover from T1 have \"?l \\<in> A\\<union>B\" using SmallerOf_def IsTotal_def \n    by simp\n  ultimately show \"HasAminimum(r,A\\<union>B)\" using HasAminimum_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1280
    },
    "1155": {
        "type": "lemma",
        "text": "text\\<open>Set that has a maximum is bounded above.\\<close>\n",
        "assumes": "assumes \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "assms",
            "HasAmaximum_def",
            "IsBoundedAbove_def"
        ],
        "statement": "lemma Order_ZF_4_L7:\n  assumes \"HasAmaximum(r,A)\"\n  shows \"IsBoundedAbove(A,r)\"\n  ",
        "proof": "using assms HasAmaximum_def IsBoundedAbove_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1281
    },
    "1156": {
        "type": "lemma",
        "text": "text\\<open>Set that has a minimum is bounded below.\\<close>\n",
        "assumes": "assumes \"HasAminimum(r,A)\"\n  ",
        "using": [
            "assms",
            "HasAminimum_def",
            "IsBoundedBelow_def"
        ],
        "statement": "lemma Order_ZF_4_L8A:\n  assumes \"HasAminimum(r,A)\"\n  shows \"IsBoundedBelow(A,r)\"\n  ",
        "proof": "using assms HasAminimum_def IsBoundedBelow_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1282
    },
    "1157": {
        "type": "lemma",
        "text": "text\\<open>For reflexive relations singletons have a minimum and maximum.\\<close>\n",
        "assumes": "assumes \"refl(X,r)\" and \"a\\<in>X\"\n  ",
        "using": [
            "assms",
            "refl_def",
            "HasAmaximum_def",
            "HasAminimum_def"
        ],
        "statement": "lemma Order_ZF_4_L8: assumes \"refl(X,r)\" and \"a\\<in>X\"\n  shows \"HasAmaximum(r,{a})\" \"HasAminimum(r,{a})\"\n  ",
        "proof": "using assms refl_def HasAmaximum_def HasAminimum_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1283
    },
    "1158": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations if we add an element to a set \n  that has a minimum, the set still has a minimum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<subseteq>X\" and A4: \"a\\<in>X\" and A5: \"HasAminimum(r,A)\"\n  ",
        "using": [
            "Order_ZF_1_L4",
            "total_is_refl",
            "Order_ZF_4_L8"
        ],
        "statement": "lemma Order_ZF_4_L10: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<subseteq>X\" and A4: \"a\\<in>X\" and A5: \"HasAminimum(r,A)\"\n  shows \"HasAminimum(r,A\\<union>{a})\"\n",
        "proof": "proof -\n  from A3 A4 have \"A\\<union>{a} \\<subseteq> X\" by auto\n  with A1 have \"r {is total on} (A\\<union>{a})\"\n    using Order_ZF_1_L4 by blast\n  moreover from A1 A2 A4 A5 have\n    \"trans(r)\" \"HasAminimum(r,A)\" by auto\n  moreover from A1 A4 have \"HasAminimum(r,{a})\"\n    using total_is_refl Order_ZF_4_L8 by blast\n  ultimately show \"HasAminimum(r,A\\<union>{a})\" by (rule Order_ZF_4_L6)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1285
    },
    "1159": {
        "type": "lemma",
        "text": "text\\<open>If the order relation has a property that every nonempty bounded set \n  attains a minimum (for example integers are like that), \n  then every nonempty set bounded below attains a minimum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and \n  A2: \"trans(r)\" and \n  A3: \"r \\<subseteq> X\\<times>X\" and\n  A4: \"\\<forall>A. IsBounded(A,r) \\<and> A\\<noteq>0 \\<longrightarrow> HasAminimum(r,A)\" and \n  A5: \"B\\<noteq>0\" and A6: \"IsBoundedBelow(B,r)\"\n  ",
        "using": [
            "Order_ZF_3_L1B",
            "total_is_refl",
            "refl_def",
            "Order_ZF_3_L12",
            "IsBounded_def",
            "HasAminimum_def",
            "Order_ZF_1_L5"
        ],
        "statement": "lemma Order_ZF_4_L11: \n  assumes A1: \"r {is total on} X\" and \n  A2: \"trans(r)\" and \n  A3: \"r \\<subseteq> X\\<times>X\" and\n  A4: \"\\<forall>A. IsBounded(A,r) \\<and> A\\<noteq>0 \\<longrightarrow> HasAminimum(r,A)\" and \n  A5: \"B\\<noteq>0\" and A6: \"IsBoundedBelow(B,r)\"\n  shows \"HasAminimum(r,B)\"\n",
        "proof": "proof -\n  from A5 obtain b where T: \"b\\<in>B\" by auto\n  let ?L = \"{x\\<in>B. \\<langle>x,b\\<rangle> \\<in> r}\"\n  from A3 A6 T have T1: \"b\\<in>X\" using Order_ZF_3_L1B by blast\n  with A1 T have T2: \"b \\<in> ?L\"\n    using total_is_refl refl_def by simp\n  then have \"?L \\<noteq> 0\" by auto\n  moreover have \"IsBounded(?L,r)\"\n  proof -\n    have \"?L \\<subseteq> B\" by auto\n    with A6 have \"IsBoundedBelow(?L,r)\"\n      using Order_ZF_3_L12 by simp\n    moreover have \"IsBoundedAbove(?L,r)\"\n      by (rule Order_ZF_3_L15)\n    ultimately have \"IsBoundedAbove(?L,r) \\<and> IsBoundedBelow(?L,r)\"\n      by blast\n    then show \"IsBounded(?L,r)\" using IsBounded_def\n      by simp\n  qed\n  ultimately have \"IsBounded(?L,r) \\<and> ?L \\<noteq> 0\" by blast\n  with A4 have \"HasAminimum(r,?L)\" by simp\n  then obtain m where I: \"m\\<in>?L\" and II: \"\\<forall>x\\<in>?L. \\<langle> m,x\\<rangle> \\<in> r\" \n    using HasAminimum_def by auto\n  then have III: \"\\<langle>m,b\\<rangle> \\<in> r\" by simp\n  from I have \"m\\<in>B\" by simp\n  moreover have \"\\<forall>x\\<in>B. \\<langle>m,x\\<rangle> \\<in> r\"\n  proof\n    fix x assume A7: \"x\\<in>B\"\n    from A3 A6 have \"B\\<subseteq>X\" using Order_ZF_3_L1B by blast\n    with A1 A7 T1 have \"x \\<in>  ?L \\<union> {x\\<in>B. \\<langle>b,x\\<rangle> \\<in> r}\"\n      using Order_ZF_1_L5 by simp\n    then have \"x\\<in>?L \\<or> \\<langle>b,x\\<rangle> \\<in> r\" by auto\n    moreover\n    { assume \"x\\<in>?L\"\n      with II have \"\\<langle>m,x\\<rangle> \\<in> r\" by simp }\n    moreover\n    { assume \"\\<langle>b,x\\<rangle> \\<in> r\"\n      with A2 III have \"trans(r)\" and \"\\<langle>m,b\\<rangle> \\<in> r \\<and> \\<langle>b,x\\<rangle> \\<in> r\"\n\tby auto\n      then have  \"\\<langle>m,x\\<rangle> \\<in> r\" by (rule Fol1_L3) }\n    ultimately show \"\\<langle>m,x\\<rangle> \\<in> r\" by auto\n  qed\n  ultimately show \"HasAminimum(r,B)\" using HasAminimum_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1286
    },
    "1160": {
        "type": "lemma",
        "text": "text\\<open>A dual to \\<open>Order_ZF_4_L11\\<close>: \n  If the order relation has a property that every nonempty bounded set \n  attains a maximum (for example integers are like that), \n  then every nonempty set bounded above attains a maximum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and \n  A2: \"trans(r)\" and \n  A3: \"r \\<subseteq> X\\<times>X\" and\n  A4: \"\\<forall>A. IsBounded(A,r) \\<and> A\\<noteq>0 \\<longrightarrow> HasAmaximum(r,A)\" and \n  A5: \"B\\<noteq>0\" and A6: \"IsBoundedAbove(B,r)\"\n  ",
        "using": [
            "Order_ZF_3_L1A",
            "total_is_refl",
            "refl_def",
            "Order_ZF_3_L13",
            "IsBoundedBelow_def",
            "IsBounded_def",
            "HasAmaximum_def",
            "Order_ZF_1_L5"
        ],
        "statement": "lemma Order_ZF_4_L11A: \n  assumes A1: \"r {is total on} X\" and \n  A2: \"trans(r)\" and \n  A3: \"r \\<subseteq> X\\<times>X\" and\n  A4: \"\\<forall>A. IsBounded(A,r) \\<and> A\\<noteq>0 \\<longrightarrow> HasAmaximum(r,A)\" and \n  A5: \"B\\<noteq>0\" and A6: \"IsBoundedAbove(B,r)\"\n  shows \"HasAmaximum(r,B)\"\n",
        "proof": "proof -\n  from A5 obtain b where T: \"b\\<in>B\" by auto\n  let ?U = \"{x\\<in>B. \\<langle>b,x\\<rangle> \\<in> r}\"\n  from A3 A6 T have T1: \"b\\<in>X\" using Order_ZF_3_L1A by blast\n  with A1 T have T2: \"b \\<in> ?U\"\n    using total_is_refl refl_def by simp\n  then have \"?U \\<noteq> 0\" by auto\n  moreover have \"IsBounded(?U,r)\"\n  proof -\n    have \"?U \\<subseteq> B\" by auto\n    with A6 have \"IsBoundedAbove(?U,r)\"\n      using Order_ZF_3_L13 by blast\n    moreover have \"IsBoundedBelow(?U,r)\"\n      using IsBoundedBelow_def by auto\n    ultimately have \"IsBoundedAbove(?U,r) \\<and> IsBoundedBelow(?U,r)\"\n      by blast\n    then show \"IsBounded(?U,r)\" using IsBounded_def\n      by simp\n  qed\n  ultimately have \"IsBounded(?U,r) \\<and> ?U \\<noteq> 0\" by blast\n  with A4 have \"HasAmaximum(r,?U)\" by simp\n  then obtain m where I: \"m\\<in>?U\" and II: \"\\<forall>x\\<in>?U. \\<langle>x,m\\<rangle> \\<in> r\"\n    using HasAmaximum_def by auto\n  then have III: \"\\<langle>b,m\\<rangle> \\<in> r\" by simp\n  from I have \"m\\<in>B\" by simp\n  moreover have \"\\<forall>x\\<in>B. \\<langle>x,m\\<rangle> \\<in> r\"\n  proof\n    fix x assume A7: \"x\\<in>B\"\n    from A3 A6 have \"B\\<subseteq>X\" using Order_ZF_3_L1A by blast\n    with A1 A7 T1 have \"x \\<in> {x\\<in>B. \\<langle>x,b\\<rangle> \\<in> r} \\<union> ?U\"\n      using Order_ZF_1_L5 by simp\n    then have \"x\\<in>?U \\<or> \\<langle>x,b\\<rangle> \\<in> r\" by auto\n    moreover\n    { assume \"x\\<in>?U\"\n      with II have \"\\<langle>x,m\\<rangle> \\<in> r\" by simp }\n    moreover\n    { assume \"\\<langle>x,b\\<rangle> \\<in> r\"\n      with A2 III have \"trans(r)\" and \"\\<langle>x,b\\<rangle> \\<in> r \\<and> \\<langle>b,m\\<rangle> \\<in> r\"\n\tby auto\n      then have  \"\\<langle>x,m\\<rangle> \\<in> r\" by (rule Fol1_L3) }\n    ultimately show \"\\<langle>x,m\\<rangle> \\<in> r\" by auto\n  qed\n  ultimately show \"HasAmaximum(r,B)\" using HasAmaximum_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1287
    },
    "1161": {
        "type": "lemma",
        "text": "text\\<open>If a set has a minimum and $L$ is less or equal than \n  all elements of the set, then $L$ is less or equal than the minimum.\\<close>\n",
        "assumes": "assumes \"antisym(r)\" and \"HasAminimum(r,A)\" and \"\\<forall>a\\<in>A. \\<langle>L,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "assms",
            "Order_ZF_4_L4"
        ],
        "statement": "lemma Order_ZF_4_L12: \n  assumes \"antisym(r)\" and \"HasAminimum(r,A)\" and \"\\<forall>a\\<in>A. \\<langle>L,a\\<rangle> \\<in> r\"\n  shows \"\\<langle>L,Minimum(r,A)\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms Order_ZF_4_L4 by simp\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1288
    },
    "1162": {
        "type": "lemma",
        "text": "text\\<open>If an element belongs to a set and is greater or equal\n  than all elements of that set, then it is the maximum of that set.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"M \\<in> A\" and \n  A3: \"\\<forall>a\\<in>A. \\<langle>a,M\\<rangle> \\<in> r\"\n  ",
        "using": [
            "HasAmaximum_def",
            "Order_ZF_4_L1",
            "Order_ZF_4_L3"
        ],
        "statement": "lemma Order_ZF_4_L14: \n  assumes A1: \"antisym(r)\" and A2: \"M \\<in> A\" and \n  A3: \"\\<forall>a\\<in>A. \\<langle>a,M\\<rangle> \\<in> r\"\n  shows \"Maximum(r,A) = M\"\n",
        "proof": "proof -\n  from A2 A3 have I: \"HasAmaximum(r,A)\" using HasAmaximum_def\n    by auto\n  with A1 have \"\\<exists>!M. M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle>x,M\\<rangle> \\<in> r)\"\n    using Order_ZF_4_L1 by simp\n  moreover from A2 A3 have \"M\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle>x,M\\<rangle> \\<in> r)\" by simp\n  moreover from A1 I have \n    \"Maximum(r,A) \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>x,Maximum(r,A)\\<rangle> \\<in> r)\"\n    using Order_ZF_4_L3 by simp\n  ultimately show \"Maximum(r,A) = M\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1290
    },
    "1163": {
        "type": "lemma",
        "text": "text\\<open>If an element belongs to a set and is less or equal\n  than all elements of that set, then it is the minimum of that set.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"m \\<in> A\" and \n  A3: \"\\<forall>a\\<in>A. \\<langle>m,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "HasAminimum_def",
            "Order_ZF_4_L2",
            "Order_ZF_4_L4"
        ],
        "statement": "lemma Order_ZF_4_L15: \n  assumes A1: \"antisym(r)\" and A2: \"m \\<in> A\" and \n  A3: \"\\<forall>a\\<in>A. \\<langle>m,a\\<rangle> \\<in> r\"\n  shows \"Minimum(r,A) = m\"\n",
        "proof": "proof -\n  from A2 A3 have I: \"HasAminimum(r,A)\" using HasAminimum_def\n    by auto\n  with A1 have \"\\<exists>!m. m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle>m,x\\<rangle> \\<in> r)\"\n    using Order_ZF_4_L2 by simp\n  moreover from A2 A3 have \"m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle>m,x\\<rangle> \\<in> r)\" by simp\n  moreover from A1 I have \n    \"Minimum(r,A) \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>Minimum(r,A),x\\<rangle> \\<in> r)\"\n    using Order_ZF_4_L4 by simp\n  ultimately show \"Minimum(r,A) = m\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1291
    },
    "1164": {
        "type": "lemma",
        "text": "text\\<open>If a set does not have a maximum, then for any its element we can\n  find one that is (strictly) greater.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"r {is total on} X\" and \n  A3: \"A\\<subseteq>X\" and\n  A4: \"\\<not>HasAmaximum(r,A)\" and \n  A5: \"x\\<in>A\"\n  ",
        "using": [
            "IsTotal_def",
            "Order_ZF_1_L1",
            "HasAmaximum_def"
        ],
        "statement": "lemma Order_ZF_4_L16: \n  assumes A1: \"antisym(r)\" and A2: \"r {is total on} X\" and \n  A3: \"A\\<subseteq>X\" and\n  A4: \"\\<not>HasAmaximum(r,A)\" and \n  A5: \"x\\<in>A\"\n  shows \"\\<exists>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> r \\<and> y\\<noteq>x\"\n",
        "proof": "proof -\n  { assume A6: \"\\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<notin> r \\<or> y=x\"\n    have \"\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\"\n    proof\n      fix y assume A7: \"y\\<in>A\"\n      with A6 have \"\\<langle>x,y\\<rangle> \\<notin> r \\<or> y=x\" by simp\n      with A2 A3 A5 A7 show \"\\<langle>y,x\\<rangle> \\<in> r\"\n\tusing IsTotal_def Order_ZF_1_L1 by auto\n    qed\n    with A5 have \"\\<exists>x\\<in>A.\\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\"\n      by auto\n    with A4 have False using HasAmaximum_def by simp\n  } then show \"\\<exists>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> r \\<and> y\\<noteq>x\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1292
    },
    "1165": {
        "type": "lemma",
        "text": "text\\<open>Elements of the set of upper bounds are indeed upper bounds.\n  Isabelle also thinks it is obvious.\\<close>\n",
        "assumes": "assumes \"u \\<in> (\\<Inter>a\\<in>A. r``{a})\" and \"a\\<in>A\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma Order_ZF_5_L1: assumes \"u \\<in> (\\<Inter>a\\<in>A. r``{a})\" and \"a\\<in>A\"\n  shows \"\\<langle>a,u\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1293
    },
    "1166": {
        "type": "lemma",
        "text": "text\\<open>Elements of the set of lower bounds are indeed lower bounds.\n  Isabelle also thinks it is obvious.\\<close>\n",
        "assumes": "assumes \"l \\<in> (\\<Inter>a\\<in>A. r-``{a})\" and \"a\\<in>A\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma Order_ZF_5_L2: assumes \"l \\<in> (\\<Inter>a\\<in>A. r-``{a})\" and \"a\\<in>A\"\n  shows \"\\<langle>l,a\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1294
    },
    "1167": {
        "type": "lemma",
        "text": "text\\<open>If the set of upper bounds has a minimum, then the supremum \n  is less or equal than any upper bound. We can probably do away with\n  the assumption that $A$ is not empty, (ab)using the fact that \n  intersection over an empty family is defined in Isabelle to be empty.\n  This lemma is obsolete and will be removed in the future. Use \\<open>sup_leq_up_bnd\\<close> instead.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"A\\<noteq>0\" and\n  A3: \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\" and \n  A4: \"\\<forall>a\\<in>A. \\<langle>a,u\\<rangle> \\<in> r\"\n  ",
        "using": [
            "image_singleton_iff",
            "Order_ZF_4_L4",
            "Supremum_def"
        ],
        "statement": "lemma Order_ZF_5_L3: assumes A1: \"antisym(r)\" and A2: \"A\\<noteq>0\" and\n  A3: \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\" and \n  A4: \"\\<forall>a\\<in>A. \\<langle>a,u\\<rangle> \\<in> r\"\n  shows \"\\<langle>Supremum(r,A),u\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  let ?U = \"\\<Inter>a\\<in>A. r``{a}\"\n  from A4 have \"\\<forall>a\\<in>A. u \\<in> r``{a}\" using image_singleton_iff\n    by simp\n  with A2 have \"u\\<in>?U\" by auto\n  with A1 A3 show \"\\<langle>Supremum(r,A),u\\<rangle> \\<in> r\"\n    using Order_ZF_4_L4 Supremum_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1295
    },
    "1168": {
        "type": "lemma",
        "text": "text\\<open>Infimum is greater or equal than any lower bound. \n  This lemma is obsolete and will be removed. Use \\<open>inf_geq_lo_bnd\\<close> instead.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"A\\<noteq>0\" and\n  A3: \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\" and \n  A4: \"\\<forall>a\\<in>A. \\<langle>l,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "vimage_singleton_iff",
            "Order_ZF_4_L3",
            "Infimum_def"
        ],
        "statement": "lemma Order_ZF_5_L4: assumes A1: \"antisym(r)\" and A2: \"A\\<noteq>0\" and\n  A3: \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\" and \n  A4: \"\\<forall>a\\<in>A. \\<langle>l,a\\<rangle> \\<in> r\"\n  shows \"\\<langle>l,Infimum(r,A)\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  let ?L = \"\\<Inter>a\\<in>A. r-``{a}\"\n  from A4 have \"\\<forall>a\\<in>A. l \\<in> r-``{a}\" using vimage_singleton_iff\n    by simp\n  with A2 have \"l\\<in>?L\" by auto \n  with A1 A3 show \"\\<langle>l,Infimum(r,A)\\<rangle> \\<in> r\"\n    using Order_ZF_4_L3 Infimum_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1297
    },
    "1169": {
        "type": "lemma",
        "text": "text\\<open>Infimum is greater or equal than any upper bound. \\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"HasAnInfimum(r,A)\" \"\\<forall>a\\<in>A. \\<langle>u,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "vimage_singleton_iff",
            "set_inf_not_empty",
            "Order_ZF_4_L3"
        ],
        "statement": "lemma inf_geq_lo_bnd: assumes \"antisym(r)\" \"HasAnInfimum(r,A)\" \"\\<forall>a\\<in>A. \\<langle>u,a\\<rangle> \\<in> r\"\n  shows \"\\<langle>u,Infimum(r,A)\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  let ?U = \"\\<Inter>a\\<in>A. r-``{a}\"\n  from assms(3) have  \"\\<forall>a\\<in>A. u \\<in> r-``{a}\" using vimage_singleton_iff by simp\n  with assms(2) have \"u\\<in>?U\" using set_inf_not_empty by auto\n  with assms(1,2) show  \"\\<langle>u,Infimum(r,A)\\<rangle> \\<in> r\" \n    unfolding HasAnInfimum_def Infimum_def using Order_ZF_4_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1298
    },
    "1170": {
        "type": "lemma",
        "text": "text\\<open>If $z$ is an upper bound for $A$ and is less or equal than\n  any other upper bound, then $z$ is the supremum of $A$.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"A\\<noteq>0\" and\n  A3: \"\\<forall>x\\<in>A. \\<langle>x,z\\<rangle> \\<in> r\" and \n  A4: \"\\<forall>y. (\\<forall>x\\<in>A. \\<langle>x,y\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>z,y\\<rangle> \\<in> r\"\n  ",
        "using": [
            "HasAminimum_def",
            "Order_ZF_4_L15",
            "Supremum_def"
        ],
        "statement": "lemma Order_ZF_5_L5: assumes A1: \"antisym(r)\" and A2: \"A\\<noteq>0\" and\n  A3: \"\\<forall>x\\<in>A. \\<langle>x,z\\<rangle> \\<in> r\" and \n  A4: \"\\<forall>y. (\\<forall>x\\<in>A. \\<langle>x,y\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>z,y\\<rangle> \\<in> r\"\n  shows \n  \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n  \"z = Supremum(r,A)\"\n",
        "proof": "proof -\n  let ?B = \"\\<Inter>a\\<in>A. r``{a}\"\n  from A2 A3 A4 have I: \"z \\<in> ?B\"   \"\\<forall>y\\<in>?B. \\<langle>z,y\\<rangle> \\<in> r\"\n    by auto\n  then show \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n    using HasAminimum_def by auto\n  from A1 I show \"z = Supremum(r,A)\"\n    using Order_ZF_4_L15 Supremum_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1299
    },
    "1171": {
        "type": "lemma",
        "text": "text\\<open> Supremum and infimum of a singleton is the element. \\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"refl(X,r)\" \"z\\<in>X\"\n  ",
        "using": [
            "inf_glb",
            "Order_ZF_5_L5",
            "refl_def",
            "HasAsupremum_def",
            "HasAnInfimum_def"
        ],
        "statement": "lemma sup_inf_singl: assumes \"antisym(r)\" \"refl(X,r)\" \"z\\<in>X\"\n  shows \n    \"HasAsupremum(r,{z})\" \"Supremum(r,{z}) = z\" and \n    \"HasAnInfimum(r,{z})\" \"Infimum(r,{z}) = z\"\n",
        "proof": "proof -\n  from assms show \"Supremum(r,{z}) = z\" and \"Infimum(r,{z}) = z\" \n    using inf_glb Order_ZF_5_L5 unfolding refl_def by auto\n  from assms show  \"HasAsupremum(r,{z})\" \n    using Order_ZF_5_L5 unfolding HasAsupremum_def refl_def by blast\n  from assms show \"HasAnInfimum(r,{z})\"\n    using inf_glb unfolding HasAnInfimum_def refl_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1301
    },
    "1172": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum, then the maximum is the supremum. This lemma is obsolete, use\n  \\<open>max_is_sup\\<close> instead.\\<close>\n",
        "assumes": "assumes A1:  \"antisym(r)\" and A2: \"A\\<noteq>0\" and \n  A3: \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "Order_ZF_4_L3"
        ],
        "statement": "lemma Order_ZF_5_L6: \n  assumes A1:  \"antisym(r)\" and A2: \"A\\<noteq>0\" and \n  A3: \"HasAmaximum(r,A)\"\n  shows \n  \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n  \"Maximum(r,A) = Supremum(r,A)\"\n",
        "proof": "proof -\n  let ?M = \"Maximum(r,A)\"\n  from A1 A3 have I: \"?M \\<in> A\" and II: \"\\<forall>x\\<in>A. \\<langle>x,?M\\<rangle> \\<in> r\"\n    using Order_ZF_4_L3 by auto\n  from I have III: \"\\<forall>y. (\\<forall>x\\<in>A. \\<langle>x,y\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>?M,y\\<rangle> \\<in> r\"\n    by simp\n  with A1 A2 II show \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n    by (rule Order_ZF_5_L5)\n  from A1 A2 II III show \"?M = Supremum(r,A)\"\n    by (rule Order_ZF_5_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1302
    },
    "1173": {
        "type": "lemma",
        "text": "text\\<open>Another version of \\<open>Order_ZF_5_L6\\<close> that: if a sat has a maximum then it has a supremum and \n  the maximum is the supremum. \\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"A\\<noteq>0\" \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "Order_ZF_4_L3",
            "Order_ZF_5_L5(1)",
            "Order_ZF_5_L5(2)"
        ],
        "statement": "lemma max_is_sup: assumes \"antisym(r)\" \"A\\<noteq>0\" \"HasAmaximum(r,A)\"\n  shows \"HasAsupremum(r,A)\" and \"Maximum(r,A) = Supremum(r,A)\"\n",
        "proof": "proof -\n  let ?M = \"Maximum(r,A)\"\n  from assms(1,3) have \"?M \\<in> A\" and I: \"\\<forall>x\\<in>A. \\<langle>x,?M\\<rangle> \\<in> r\" using Order_ZF_4_L3 \n    by auto\n  with assms(1,2) have \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\" using Order_ZF_5_L5(1) \n    by blast\n  then show \"HasAsupremum(r,A)\" unfolding HasAsupremum_def by simp\n  from assms(1,2) \\<open>?M \\<in> A\\<close> I show \"?M = Supremum(r,A)\" using Order_ZF_5_L5(2) \n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1303
    },
    "1174": {
        "type": "lemma",
        "text": "text\\<open> Minimum is the infimum if it exists.\\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"A\\<noteq>0\" \"HasAminimum(r,A)\"\n  ",
        "using": [
            "Order_ZF_4_L4",
            "inf_glb(1)",
            "inf_glb(2)"
        ],
        "statement": "lemma min_is_inf: assumes \"antisym(r)\" \"A\\<noteq>0\" \"HasAminimum(r,A)\"\n  shows \"HasAnInfimum(r,A)\" and \"Minimum(r,A) = Infimum(r,A)\"\n",
        "proof": "proof -\n  let ?M = \"Minimum(r,A)\"\n  from assms(1,3) have \"?M\\<in>A\" and I: \"\\<forall>x\\<in>A. \\<langle>?M,x\\<rangle> \\<in> r\" using  Order_ZF_4_L4 \n    by auto\n  with assms(1,2) have \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\" using inf_glb(1) by blast\n  then show \"HasAnInfimum(r,A)\" unfolding HasAnInfimum_def by simp\n  from assms(1,2) \\<open>?M \\<in> A\\<close> I show \"?M = Infimum(r,A)\" using inf_glb(2) by blast\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1304
    },
    "1175": {
        "type": "lemma",
        "text": "text\\<open>For reflexive and total relations two-element set has a minimum and a maximum. \\<close>\n",
        "assumes": "assumes \"r {is total on} X\" \"x\\<in>X\" \"y\\<in>X\"\n  ",
        "using": [
            "assms",
            "IsTotal_def",
            "HasAminimum_def",
            "HasAmaximum_def"
        ],
        "statement": "lemma min_max_two_el: assumes \"r {is total on} X\" \"x\\<in>X\" \"y\\<in>X\"\n  shows \"HasAminimum(r,{x,y})\" and \"HasAmaximum(r,{x,y})\"\n  ",
        "proof": "using assms unfolding IsTotal_def HasAminimum_def HasAmaximum_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1305
    },
    "1176": {
        "type": "lemma",
        "text": "text\\<open>For antisymmetric, reflexive and total relations two-element set has a supremum and infimum. \\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"r {is total on} X\" \"x\\<in>X\" \"y\\<in>X\"\n  ",
        "using": [
            "assms",
            "min_max_two_el",
            "max_is_sup",
            "min_is_inf"
        ],
        "statement": "lemma inf_sup_two_el:assumes \"antisym(r)\" \"r {is total on} X\" \"x\\<in>X\" \"y\\<in>X\"\n  shows \n    \"HasAnInfimum(r,{x,y})\"\n    \"Minimum(r,{x,y}) = Infimum(r,{x,y})\"\n    \"HasAsupremum(r,{x,y})\"\n    \"Maximum(r,{x,y}) = Supremum(r,{x,y})\"\n  ",
        "proof": "using assms min_max_two_el max_is_sup min_is_inf by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1306
    },
    "1177": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for the infimum to be in the space.\\<close>\n",
        "assumes": "assumes \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\"\n  ",
        "using": [
            "set_inf_not_empty",
            "HasAnInfimum_def",
            "Order_ZF_4_L3",
            "Order_ZF_5_L1"
        ],
        "statement": "lemma inf_in_space: \n  assumes \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\"\n  shows \"Infimum(r,A) \\<in> X\" and \"\\<forall>x\\<in>A. \\<langle>Infimum(r,A),x\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from assms(3) have \"A\\<noteq>0\" using set_inf_not_empty unfolding HasAnInfimum_def by simp\n  then obtain a where \"a\\<in>A\" by auto\n  with assms(1,2,3) show \"Infimum(r,A) \\<in> X\" unfolding Infimum_def \n    using Order_ZF_4_L3 Order_ZF_5_L1 by blast\n  from assms(2,3) show \"\\<forall>x\\<in>A. \\<langle>Infimum(r,A),x\\<rangle> \\<in> r\" unfolding Infimum_def\n    using Order_ZF_4_L3 by blast\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1308
    },
    "1178": {
        "type": "lemma",
        "text": "text\\<open>Properties of supremum of a set for complete relations.\\<close>\n",
        "assumes": "assumes A1: \"r \\<subseteq> X\\<times>X\" and A2: \"antisym(r)\" and \n  A3: \"r {is complete}\" and\n  A4: \"A\\<noteq>0\" and A5: \"\\<exists>x\\<in>X. \\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\"\n  ",
        "using": [
            "sup_in_space"
        ],
        "statement": "lemma Order_ZF_5_L7: \n  assumes A1: \"r \\<subseteq> X\\<times>X\" and A2: \"antisym(r)\" and \n  A3: \"r {is complete}\" and\n  A4: \"A\\<noteq>0\" and A5: \"\\<exists>x\\<in>X. \\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\"\n  shows \"Supremum(r,A) \\<in> X\" and \"\\<forall>x\\<in>A. \\<langle>x,Supremum(r,A)\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A3 A4 A5 have \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n    unfolding IsBoundedAbove_def IsComplete_def by blast\n  with A1 A2 show \"Supremum(r,A) \\<in> X\" and \"\\<forall>x\\<in>A. \\<langle>x,Supremum(r,A)\\<rangle> \\<in> r\"\n    using sup_in_space by auto\nqed \n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1309
    },
    "1179": {
        "type": "lemma",
        "text": "text\\<open> Supremum of the set of suprema of a collection of sets is supremum of the union. \\<close>\n",
        "assumes": "assumes \n    \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"trans(r)\" \n    \"\\<forall>T\\<in>\\<T>. HasAsupremum(r,T)\"\n    \"HasAsupremum(r,{Supremum(r,T).T\\<in>\\<T>})\"\n  ",
        "using": [
            "set_sup_not_empty",
            "sup_in_space(2)",
            "sup_leq_up_bnd"
        ],
        "statement": "lemma sup_sup:\n  assumes \n    \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"trans(r)\" \n    \"\\<forall>T\\<in>\\<T>. HasAsupremum(r,T)\"\n    \"HasAsupremum(r,{Supremum(r,T).T\\<in>\\<T>})\"\n  shows \n    \"HasAsupremum(r,\\<Union>\\<T>)\" and \"Supremum(r,{Supremum(r,T).T\\<in>\\<T>}) = Supremum(r,\\<Union>\\<T>)\"\n",
        "proof": "proof -\n  let ?s = \"Supremum(r,{Supremum(r,T).T\\<in>\\<T>})\"\n  note assms(2)\n  moreover from assms(4,5) have \"\\<Union>\\<T> \\<noteq> 0\" using set_sup_not_empty by blast\n  moreover\n  have \"\\<forall>T\\<in>\\<T>.\\<forall>t\\<in>T. \\<langle>t,?s\\<rangle> \\<in> r\"\n  proof -\n    { fix T t assume \"T\\<in>\\<T>\" \"t\\<in>T\"\n      with assms(1,2,4) have \"\\<langle>t,Supremum(r,T)\\<rangle> \\<in> r\"\n        unfolding HasAsupremum_def using sup_in_space(2) by blast\n      moreover from assms(1,2,5) \\<open>T\\<in>\\<T>\\<close> have \"\\<langle>Supremum(r,T),?s\\<rangle> \\<in> r\"\n        unfolding HasAsupremum_def using sup_in_space(2) by blast\n      moreover note assms(3)\n      ultimately have \"\\<langle>t,?s\\<rangle> \\<in> r\" unfolding trans_def by blast\n    } thus ?thesis by simp\n  qed\n  hence I: \"\\<forall>t\\<in>\\<Union>\\<T>. \\<langle>t,?s\\<rangle> \\<in> r\" by auto\n  moreover have J: \"\\<forall>y. (\\<forall>x\\<in>\\<Union>\\<T>. \\<langle>x,y\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>?s,y\\<rangle> \\<in> r\"\n  proof -\n    { fix y x assume A: \"\\<forall>x\\<in>\\<Union>\\<T>. \\<langle>x,y\\<rangle> \\<in> r\"\n      with assms(2,4) have \"\\<forall>a\\<in>{Supremum(r,T).T\\<in>\\<T>}. \\<langle>a,y\\<rangle> \\<in> r\" using sup_leq_up_bnd\n        by simp\n      with assms(2,5) have \"\\<langle>?s,y\\<rangle> \\<in> r\" by (rule sup_leq_up_bnd)\n    } thus ?thesis by simp\n  qed \n  ultimately have \"HasAminimum(r,\\<Inter>a\\<in>\\<Union>\\<T>. r``{a})\" by (rule Order_ZF_5_L5)\n  then show \"HasAsupremum(r,\\<Union>\\<T>)\" unfolding HasAsupremum_def by simp\n  from assms(2) \\<open>\\<Union>\\<T> \\<noteq> 0\\<close> I J show \"?s = Supremum(r,\\<Union>\\<T>)\" by (rule Order_ZF_5_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1311
    },
    "1180": {
        "type": "lemma",
        "text": "text\\<open>If the relation is a linear order then for any \n  element $y$ smaller than the supremum of a set we can\n  find one element of the set that is greater than $y$.\\<close>\n",
        "assumes": "assumes A1: \"r \\<subseteq> X\\<times>X\"  and A2: \"IsLinOrder(X,r)\" and \n  A3: \"r {is complete}\" and\n  A4: \"A\\<subseteq>X\"  \"A\\<noteq>0\" and A5: \"\\<exists>x\\<in>X. \\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\" and\n  A6: \"\\<langle>y,Supremum(r,A)\\<rangle> \\<in> r\"   \"y \\<noteq> Supremum(r,A)\"\n  ",
        "using": [
            "IsLinOrder_def",
            "IsTotal_def",
            "total_is_refl",
            "refl_def",
            "IsBoundedAbove_def",
            "IsComplete_def",
            "Order_ZF_5_L3"
        ],
        "statement": "lemma Order_ZF_5_L8:\n  assumes A1: \"r \\<subseteq> X\\<times>X\"  and A2: \"IsLinOrder(X,r)\" and \n  A3: \"r {is complete}\" and\n  A4: \"A\\<subseteq>X\"  \"A\\<noteq>0\" and A5: \"\\<exists>x\\<in>X. \\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\" and\n  A6: \"\\<langle>y,Supremum(r,A)\\<rangle> \\<in> r\"   \"y \\<noteq> Supremum(r,A)\"\n  shows \"\\<exists>z\\<in>A. \\<langle>y,z\\<rangle> \\<in> r \\<and> y \\<noteq> z\"\n",
        "proof": "proof -\n  from A2 have \n    I: \"antisym(r)\" and\n    II: \"trans(r)\" and\n    III: \"r {is total on} X\"\n    using IsLinOrder_def by auto\n  from A1 A6 have T1: \"y\\<in>X\" by auto\n  { assume A7: \"\\<forall>z \\<in> A. \\<langle>y,z\\<rangle> \\<notin> r \\<or> y=z\"\n    from A4 I have \"antisym(r)\" and \"A\\<noteq>0\" by auto\n    moreover have \"\\<forall>x\\<in>A. \\<langle>x,y\\<rangle> \\<in> r\"  \n    proof      \n      fix x assume A8: \"x\\<in>A\"\n      with A4 have T2: \"x\\<in>X\" by auto\n      from A7 A8 have \"\\<langle>y,x\\<rangle> \\<notin> r \\<or> y=x\" by simp\n      with III T1 T2 show \"\\<langle>x,y\\<rangle> \\<in> r\"\n\tusing IsTotal_def total_is_refl refl_def by auto\n    qed\n    moreover have \"\\<forall>u. (\\<forall>x\\<in>A. \\<langle>x,u\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>y,u\\<rangle> \\<in> r\"\n    proof-\n      { fix u assume A9: \"\\<forall>x\\<in>A. \\<langle>x,u\\<rangle> \\<in> r\"\n\tfrom A4 A5 have \"IsBoundedAbove(A,r)\" and \"A\\<noteq>0\"\n\t  using IsBoundedAbove_def by auto\n\twith  A3 A4 A6 I A9  have \n\t  \"\\<langle>y,Supremum(r,A)\\<rangle> \\<in> r \\<and> \\<langle>Supremum(r,A),u\\<rangle> \\<in> r\"\n\t  using IsComplete_def Order_ZF_5_L3 by simp\n\twith II have \"\\<langle>y,u\\<rangle> \\<in> r\" by (rule Fol1_L3)\n      } then show \"\\<forall>u. (\\<forall>x\\<in>A. \\<langle>x,u\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>y,u\\<rangle> \\<in> r\"\n\tby simp\n    qed\n    ultimately have \"y = Supremum(r,A)\"\n      by (rule Order_ZF_5_L5)\n    with A6 have False by simp\n  } then show \"\\<exists>z\\<in>A. \\<langle>y,z\\<rangle> \\<in> r \\<and> y \\<noteq> z\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1312
    },
    "1181": {
        "type": "definition",
        "text": "text\\<open>We define a strict version of a relation by removing the $y=x$ line \n  from the relation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"StrictVersion(r) \\<equiv> r - {\\<langle>x,x\\<rangle>. x \\<in> domain(r)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1313
    },
    "1182": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of the definition of a strict version of an order.\n\\<close>\n",
        "assumes": "",
        "using": [
            "StrictVersion_def",
            "domain_def"
        ],
        "statement": "lemma def_of_strict_ver: shows \n  \"\\<langle>x,y\\<rangle> \\<in> StrictVersion(r) \\<longleftrightarrow> \\<langle>x,y\\<rangle> \\<in> r \\<and> x\\<noteq>y\"\n  ",
        "proof": "using StrictVersion_def domain_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1314
    },
    "1183": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is about the strict version of an antisymmetric\n  relation.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"\\<langle>a,b\\<rangle> \\<in> StrictVersion(r)\"\n  ",
        "using": [
            "def_of_strict_ver"
        ],
        "statement": "lemma strict_of_antisym: \n  assumes A1: \"antisym(r)\" and A2: \"\\<langle>a,b\\<rangle> \\<in> StrictVersion(r)\"\n  shows \"\\<langle>b,a\\<rangle> \\<notin> StrictVersion(r)\"\n",
        "proof": "proof -\n  { assume A3: \"\\<langle>b,a\\<rangle> \\<in> StrictVersion(r)\"\n    with A2 have \"\\<langle>a,b\\<rangle> \\<in> r\"  and \"\\<langle>b,a\\<rangle> \\<in> r\"\n      using def_of_strict_ver by auto\n    with A1 have \"a=b\" by (rule Fol1_L4)\n    with A2 have False using def_of_strict_ver\n      by simp\n  } then show \"\\<langle>b,a\\<rangle> \\<notin> StrictVersion(r)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1315
    },
    "1184": {
        "type": "lemma",
        "text": "text\\<open>The strict version of totality.\\<close>\n",
        "assumes": "assumes \"r {is total on} X\" and \"a\\<in>X\"  \"b\\<in>X\"  \"a\\<noteq>b\"\n  ",
        "using": [
            "assms",
            "IsTotal_def",
            "def_of_strict_ver"
        ],
        "statement": "lemma strict_of_tot:\n  assumes \"r {is total on} X\" and \"a\\<in>X\"  \"b\\<in>X\"  \"a\\<noteq>b\"\n  shows \"\\<langle>a,b\\<rangle> \\<in> StrictVersion(r) \\<or> \\<langle>b,a\\<rangle> \\<in> StrictVersion(r)\"\n  ",
        "proof": "using assms IsTotal_def def_of_strict_ver by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1316
    },
    "1185": {
        "type": "lemma",
        "text": "text\\<open>A trichotomy law for the strict version of a total \n  and antisymmetric\n  relation. It is kind of interesting that one does not need\n  the full linear order for this.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"r {is total on} X\"\n  and A3: \"a\\<in>X\"  \"b\\<in>X\"\n  and A4: \"s = StrictVersion(r)\"\n  ",
        "using": [
            "strict_of_tot",
            "def_of_strict_ver",
            "strict_of_antisym"
        ],
        "statement": "lemma strict_ans_tot_trich: \n  assumes A1: \"antisym(r)\" and A2: \"r {is total on} X\"\n  and A3: \"a\\<in>X\"  \"b\\<in>X\"\n  and A4: \"s = StrictVersion(r)\"\n  shows \"Exactly_1_of_3_holds(\\<langle>a,b\\<rangle> \\<in> s, a=b,\\<langle>b,a\\<rangle> \\<in> s)\"\n",
        "proof": "proof -\n  let ?p = \"\\<langle>a,b\\<rangle> \\<in> s\"\n  let ?q = \"a=b\"\n  let ?r = \"\\<langle>b,a\\<rangle> \\<in> s\"\n  from A2 A3 A4 have \"?p \\<or> ?q \\<or> ?r\"\n    using strict_of_tot by auto\n  moreover from A1 A4 have \"?p \\<longrightarrow> \\<not>?q \\<and> \\<not>?r\"\n    using def_of_strict_ver strict_of_antisym by simp\n  moreover from A4 have \"?q \\<longrightarrow> \\<not>?p \\<and> \\<not>?r\"\n    using def_of_strict_ver by simp\n  moreover from A1 A4 have \"?r \\<longrightarrow> \\<not>?p \\<and> \\<not>?q\"\n    using def_of_strict_ver strict_of_antisym by auto\n  ultimately show \"Exactly_1_of_3_holds(?p, ?q, ?r)\"\n    by (rule Fol1_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1317
    },
    "1186": {
        "type": "corollary",
        "text": "text\\<open>A trichotomy law for linear order. This is a special\n  case of \\<open>strict_ans_tot_trich\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\" and\n  A2: \"a\\<in>X\"  \"b\\<in>X\" and \n  A3: \"s = StrictVersion(r)\"\n  ",
        "using": [
            "assms",
            "IsLinOrder_def",
            "strict_ans_tot_trich"
        ],
        "statement": "corollary strict_lin_trich: assumes A1: \"IsLinOrder(X,r)\" and\n  A2: \"a\\<in>X\"  \"b\\<in>X\" and \n  A3: \"s = StrictVersion(r)\"\n  shows \"Exactly_1_of_3_holds(\\<langle>a,b\\<rangle> \\<in> s, a=b,\\<langle>b,a\\<rangle> \\<in> s)\"\n  ",
        "proof": "using assms IsLinOrder_def strict_ans_tot_trich by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1318
    },
    "1187": {
        "type": "lemma",
        "text": "text\\<open>For an antisymmetric relation if a pair is in relation then\n  the reversed pair is not in the strict version of the relation. \n\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"\\<langle>a,b\\<rangle> \\<in> r\"\n  ",
        "using": [
            "def_of_strict_ver",
            "strict_of_antisym"
        ],
        "statement": "lemma geq_impl_not_less: \n  assumes A1: \"antisym(r)\" and A2: \"\\<langle>a,b\\<rangle> \\<in> r\"\n  shows \"\\<langle>b,a\\<rangle> \\<notin> StrictVersion(r)\"\n",
        "proof": "proof -\n  { assume A3: \"\\<langle>b,a\\<rangle> \\<in>  StrictVersion(r)\"\n    with A2 have \"\\<langle>a,b\\<rangle> \\<in> StrictVersion(r)\"\n      using def_of_strict_ver by auto\n    with A1 A3 have False using strict_of_antisym\n      by blast\n  } then show \"\\<langle>b,a\\<rangle> \\<notin> StrictVersion(r)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1319
    },
    "1188": {
        "type": "lemma",
        "text": "text\\<open>If an antisymmetric relation is transitive, \n  then the strict version is also transitive, an explicit\n  version \\<open>strict_of_transB\\<close> below.\\<close>\n",
        "assumes": "assumes A1: \"trans(r)\" and A2: \"antisym(r)\" and  \n  A3: \"s= StrictVersion(r)\" and  A4: \"\\<langle>a,b\\<rangle> \\<in> s\"  \"\\<langle>b,c\\<rangle> \\<in> s\"\n  ",
        "using": [
            "def_of_strict_ver"
        ],
        "statement": "lemma strict_of_transA: \n  assumes A1: \"trans(r)\" and A2: \"antisym(r)\" and  \n  A3: \"s= StrictVersion(r)\" and  A4: \"\\<langle>a,b\\<rangle> \\<in> s\"  \"\\<langle>b,c\\<rangle> \\<in> s\"\n  shows \"\\<langle>a,c\\<rangle> \\<in> s\"\n",
        "proof": "proof -\n  from A3 A4 have I: \"\\<langle>a,b\\<rangle> \\<in> r \\<and> \\<langle>b,c\\<rangle> \\<in> r\"\n    using def_of_strict_ver by simp\n  with A1 have \"\\<langle>a,c\\<rangle> \\<in> r\" by (rule Fol1_L3)\n  moreover\n  { assume \"a=c\"\n    with I have \"\\<langle>a,b\\<rangle> \\<in> r\" and \"\\<langle>b,a\\<rangle> \\<in> r\" by auto\n    with A2 have \"a=b\" by (rule Fol1_L4)\n    with A3 A4 have False using def_of_strict_ver by simp\n  } then have \"a\\<noteq>c\" by auto\n  ultimately have  \"\\<langle>a,c\\<rangle> \\<in> StrictVersion(r)\"\n    using def_of_strict_ver by simp\n  with A3 show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1320
    },
    "1189": {
        "type": "lemma",
        "text": "text\\<open>If an antisymmetric relation is transitive, \n  then the strict version is also transitive.\\<close>\n",
        "assumes": "assumes A1: \"trans(r)\" and A2: \"antisym(r)\"\n  ",
        "using": [
            "strict_of_transA"
        ],
        "statement": "lemma strict_of_transB: \n  assumes A1: \"trans(r)\" and A2: \"antisym(r)\"\n  shows \"trans(StrictVersion(r))\"\n",
        "proof": "proof -\n  let ?s = \"StrictVersion(r)\"\n  from A1 A2 have \n    \"\\<forall> x y z. \\<langle>x, y\\<rangle> \\<in> ?s \\<and> \\<langle>y, z\\<rangle> \\<in> ?s \\<longrightarrow> \\<langle>x, z\\<rangle> \\<in> ?s\"\n    using strict_of_transA by blast\n  then show \"trans(StrictVersion(r))\" by (rule Fol1_L2)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1321
    },
    "1190": {
        "type": "lemma",
        "text": "text\\<open>The next lemma provides a condition that is satisfied by\n  the strict version of a relation if the original relation \n  is a complete linear order.\\<close>\n",
        "assumes": "assumes A1: \"r \\<subseteq> X\\<times>X\" and A2: \"IsLinOrder(X,r)\" and \n  A3: \"r {is complete}\" and \n  A4: \"A\\<subseteq>X\"  \"A\\<noteq>0\" and A5: \"s = StrictVersion(r)\" and \n  A6: \"\\<exists>u\\<in>X. \\<forall>y\\<in>A. \\<langle>y,u\\<rangle> \\<in> s\"\n  ",
        "using": [
            "IsLinOrder_def",
            "def_of_strict_ver",
            "Order_ZF_5_L7",
            "geq_impl_not_less",
            "Order_ZF_5_L8"
        ],
        "statement": "lemma strict_of_compl: \n  assumes A1: \"r \\<subseteq> X\\<times>X\" and A2: \"IsLinOrder(X,r)\" and \n  A3: \"r {is complete}\" and \n  A4: \"A\\<subseteq>X\"  \"A\\<noteq>0\" and A5: \"s = StrictVersion(r)\" and \n  A6: \"\\<exists>u\\<in>X. \\<forall>y\\<in>A. \\<langle>y,u\\<rangle> \\<in> s\"\n  shows \n  \"\\<exists>x\\<in>X. ( \\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<notin> s ) \\<and> (\\<forall>y\\<in>X. \\<langle>y,x\\<rangle> \\<in> s \\<longrightarrow> (\\<exists>z\\<in>A. \\<langle>y,z\\<rangle> \\<in> s))\"\n",
        "proof": "proof -\n  let ?x = \"Supremum(r,A)\"\n  from A2 have I: \"antisym(r)\" using IsLinOrder_def\n    by simp\n  moreover from A5 A6 have \"\\<exists>u\\<in>X. \\<forall>y\\<in>A. \\<langle>y,u\\<rangle> \\<in> r\"\n    using def_of_strict_ver by auto\n  moreover note A1 A3 A4 \n  ultimately have II: \"?x \\<in> X\"   \"\\<forall>y\\<in>A. \\<langle>y,?x\\<rangle> \\<in> r\"\n    using Order_ZF_5_L7 by auto\n  then have III: \"\\<exists>x\\<in>X. \\<forall>y\\<in>A. \\<langle>y,x\\<rangle> \\<in> r\" by auto\n  from A5 I II have \"?x \\<in> X\"   \"\\<forall>y\\<in>A. \\<langle>?x,y\\<rangle> \\<notin> s\"\n    using geq_impl_not_less by auto\n  moreover from A1 A2 A3 A4 A5 III have \n    \"\\<forall>y\\<in>X. \\<langle>y,?x\\<rangle> \\<in> s \\<longrightarrow> (\\<exists>z\\<in>A. \\<langle>y,z\\<rangle> \\<in> s)\"\n    using def_of_strict_ver Order_ZF_5_L8 by simp\n  ultimately show\n    \"\\<exists>x\\<in>X. ( \\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<notin> s ) \\<and> (\\<forall>y\\<in>X. \\<langle>y,x\\<rangle> \\<in> s \\<longrightarrow> (\\<exists>z\\<in>A. \\<langle>y,z\\<rangle> \\<in> s))\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1322
    },
    "1191": {
        "type": "lemma",
        "text": "text\\<open>Strict version of a relation on a set is a relation on that\n  set.\\<close>\n",
        "assumes": "assumes A1: \"r \\<subseteq> A\\<times>A\"\n  ",
        "using": [
            "assms",
            "StrictVersion_def"
        ],
        "statement": "lemma strict_ver_rel: assumes A1: \"r \\<subseteq> A\\<times>A\"\n  shows \"StrictVersion(r) \\<subseteq> A\\<times>A\"\n  ",
        "proof": "using assms StrictVersion_def by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1323
    },
    "1192": {
        "type": "definition",
        "text": "text\\<open>Ordered field is a notrivial ordered ring such that all \n  non-zero elements have an inverse. We define the notion of being a ordered \n  field as\n  a statement about four sets. The first set, denoted \\<open>K\\<close> is the \n  carrier of the field. The second set, denoted \\<open>A\\<close> represents the \n  additive operation on \\<open>K\\<close> (recall that in ZF set theory functions \n  are sets). The third set \\<open>M\\<close> represents the multiplicative operation \n  on \\<open>K\\<close>. The fourth set \\<open>r\\<close> is the order \n  relation on \\<open>K\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAnOrdField(K,A,M,r) \\<equiv> (IsAnOrdRing(K,A,M,r) \\<and>\n  (M {is commutative on} K) \\<and>\n  TheNeutralElement(K,A) \\<noteq> TheNeutralElement(K,M) \\<and>\n  (\\<forall>a\\<in>K. a\\<noteq>TheNeutralElement(K,A)\\<longrightarrow>\n  (\\<exists>b\\<in>K. M`\\<langle>a,b\\<rangle> = TheNeutralElement(K,M))))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1324
    },
    "1193": {
        "type": "lemma",
        "text": "text\\<open>The next lemma assures us that we are talking fields \n  in the \\<open>field1\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "OrdRing_ZF_1_L1",
            "mult_commute",
            "not_triv",
            "inv_exists",
            "IsAnOrdField_def"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L1: shows \"IsAnOrdField(R,A,M,r)\"\n  ",
        "proof": "using OrdRing_ZF_1_L1 mult_commute not_triv inv_exists IsAnOrdField_def\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1325
    },
    "1194": {
        "type": "lemma",
        "text": "text\\<open>Ordered field is a field, of course.\\<close>\n",
        "assumes": "assumes \"IsAnOrdField(K,A,M,r)\"\n  ",
        "using": [
            "assms",
            "IsAnOrdField_def",
            "IsAnOrdRing_def",
            "IsAfield_def"
        ],
        "statement": "lemma OrdField_ZF_1_L1A: assumes \"IsAnOrdField(K,A,M,r)\"\n  shows \"IsAfield(K,A,M)\"\n  ",
        "proof": "using assms IsAnOrdField_def IsAnOrdRing_def IsAfield_def\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1326
    },
    "1195": {
        "type": "lemma",
        "text": "text\\<open>Theorems proven in \\<open>field0\\<close> (about fields) context are valid\n  in the \\<open>field1\\<close> context (about ordered fields).\\<close>\n",
        "assumes": "",
        "using": [
            "OrdField_ZF_1_L1",
            "OrdField_ZF_1_L1A",
            "field_field0"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L1B: shows \"field0(R,A,M)\"\n  ",
        "proof": "using OrdField_ZF_1_L1 OrdField_ZF_1_L1A field_field0\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1327
    },
    "1196": {
        "type": "lemma",
        "text": "text\\<open>We can use theorems proven in the \\<open>field1\\<close> context whenever we\n  talk about an ordered field.\\<close>\n",
        "assumes": "assumes \"IsAnOrdField(K,A,M,r)\"\n  ",
        "using": [
            "assms",
            "IsAnOrdField_def",
            "OrdRing_ZF_1_L2",
            "ring1_def",
            "field1_axioms_def",
            "field1_def"
        ],
        "statement": "lemma OrdField_ZF_1_L2: assumes \"IsAnOrdField(K,A,M,r)\"\n  shows \"field1(K,A,M,r)\"\n  ",
        "proof": "using assms IsAnOrdField_def OrdRing_ZF_1_L2 ring1_def\n    IsAnOrdField_def field1_axioms_def field1_def\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1328
    },
    "1197": {
        "type": "lemma",
        "text": "text\\<open>In ordered rings the existence of a right inverse for all positive\n  elements implies the existence of an inverse for all non zero elements.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>a\\<in>R\\<^sub>+. \\<exists>b\\<in>R. a\\<cdot>b = \\<one>\" and A2: \"c\\<in>R\"  \"c\\<noteq>\\<zero>\"\n  ",
        "using": [
            "OrdRing_ZF_3_L2A",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L7"
        ],
        "statement": "lemma (in ring1) OrdField_ZF_1_L3: \n  assumes A1: \"\\<forall>a\\<in>R\\<^sub>+. \\<exists>b\\<in>R. a\\<cdot>b = \\<one>\" and A2: \"c\\<in>R\"  \"c\\<noteq>\\<zero>\"\n  shows \"\\<exists>b\\<in>R. c\\<cdot>b = \\<one>\"\n",
        "proof": "proof -\n  { assume \"c\\<in>R\\<^sub>+\"\n    with A1 have \"\\<exists>b\\<in>R. c\\<cdot>b = \\<one>\" by simp }\n  moreover\n  { assume \"c\\<notin>R\\<^sub>+\"\n    with A2 have \"(\\<rm>c) \\<in> R\\<^sub>+\"\n      using OrdRing_ZF_3_L2A by simp\n    with A1 obtain b where \"b\\<in>R\" and \"(\\<rm>c)\\<cdot>b = \\<one>\"\n      by auto\n    with A2 have \"(\\<rm>b) \\<in> R\"  \"c\\<cdot>(\\<rm>b) = \\<one>\"\n      using Ring_ZF_1_L3 Ring_ZF_1_L7 by auto\n    then have \"\\<exists>b\\<in>R. c\\<cdot>b = \\<one>\" by auto }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1329
    },
    "1198": {
        "type": "lemma",
        "text": "text\\<open>Ordered fields are easier to deal with, because it is sufficient \n  to show the existence of an inverse for the set of positive elements.\\<close>\n",
        "assumes": "assumes \"\\<zero> \\<noteq> \\<one>\" and \"M {is commutative on} R\" \n  and \"\\<forall>a\\<in>R\\<^sub>+. \\<exists>b\\<in>R. a\\<cdot>b = \\<one>\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L1",
            "OrdField_ZF_1_L3",
            "IsAnOrdField_def"
        ],
        "statement": "lemma (in ring1) OrdField_ZF_1_L4: \n  assumes \"\\<zero> \\<noteq> \\<one>\" and \"M {is commutative on} R\" \n  and \"\\<forall>a\\<in>R\\<^sub>+. \\<exists>b\\<in>R. a\\<cdot>b = \\<one>\"\n  shows \"IsAnOrdField(R,A,M,r)\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L1 OrdField_ZF_1_L3 IsAnOrdField_def\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1330
    },
    "1199": {
        "type": "lemma",
        "text": "text\\<open>The set of positive field elements is closed under multiplication.\\<close>\n",
        "assumes": "",
        "using": [
            "OrdField_ZF_1_L1B",
            "field0.field_has_no_zero_divs",
            "OrdRing_ZF_3_L3"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L5: shows \"R\\<^sub>+ {is closed under} M\"\n  ",
        "proof": "using OrdField_ZF_1_L1B field0.field_has_no_zero_divs OrdRing_ZF_3_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1331
    },
    "1200": {
        "type": "lemma",
        "text": "text\\<open>The set of positive field elements is closed under multiplication:\n  the explicit version.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero> \\<ls> a\"  \"\\<zero> \\<ls> b\"\n  ",
        "using": [
            "OrdRing_ZF_3_L14",
            "OrdField_ZF_1_L5",
            "IsOpClosed_def",
            "PositiveSet_def"
        ],
        "statement": "lemma (in field1) pos_mul_closed: \n  assumes A1: \"\\<zero> \\<ls> a\"  \"\\<zero> \\<ls> b\"\n  shows \"\\<zero> \\<ls> a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have \"a \\<in> R\\<^sub>+\" and  \"b \\<in> R\\<^sub>+\"\n    using OrdRing_ZF_3_L14 by auto\n  then show \"\\<zero> \\<ls> a\\<cdot>b\" \n    using OrdField_ZF_1_L5 IsOpClosed_def PositiveSet_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1332
    },
    "1201": {
        "type": "lemma",
        "text": "text\\<open>The next lemma restates the fact \\<open>Field_ZF\\<close> that out notation\n  for the field inverse means what it is supposed to mean.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "OrdField_ZF_1_L1B",
            "field0.Field_ZF_1_L6"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L7: assumes \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"\n  shows \"a\\<cdot>(a\\<inverse>) = \\<one>\"  \"(a\\<inverse>)\\<cdot>a = \\<one>\"\n  ",
        "proof": "using assms OrdField_ZF_1_L1B field0.Field_ZF_1_L6\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1334
    },
    "1202": {
        "type": "lemma",
        "text": "text\\<open>A simple lemma about multiplication and cancelling of a positive field\n   element.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b \\<in> R\\<^sub>+\"\n  ",
        "using": [
            "PositiveSet_def",
            "OrdField_ZF_1_L1B",
            "field0.Field_ZF_1_L7"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L7A: \n  assumes A1: \"a\\<in>R\"  \"b \\<in> R\\<^sub>+\"\n  shows \n  \"a\\<cdot>b\\<cdot>b\\<inverse> = a\"\n  \"a\\<cdot>b\\<inverse>\\<cdot>b = a\"\n",
        "proof": "proof -\n  from A1 have \"b\\<in>R\"  \"b\\<noteq>\\<zero>\" using PositiveSet_def\n    by auto\n  with A1 show  \"a\\<cdot>b\\<cdot>b\\<inverse> = a\" and \"a\\<cdot>b\\<inverse>\\<cdot>b = a\"\n    using OrdField_ZF_1_L1B field0.Field_ZF_1_L7\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1335
    },
    "1203": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is smaller than $b$, then $(b-a)^{-1}$ is positive.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L14",
            "OrdField_ZF_1_L8"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L9: assumes \"a\\<ls>b\"\n  shows  \"(b\\<rs>a)\\<inverse> \\<in> R\\<^sub>+\"  \n  ",
        "proof": "using assms OrdRing_ZF_1_L14 OrdField_ZF_1_L8\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1337
    },
    "1204": {
        "type": "lemma",
        "text": "text\\<open>In ordered fields if at least one of $a,b$ is not zero, then\n  $a^2+b^2 > 0$, in particular $a^2+b^2\\neq 0$ and exists the \n  (multiplicative) inverse of $a^2+b^2$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\" and A2: \"a \\<noteq> \\<zero> \\<or> b \\<noteq> \\<zero>\"\n  ",
        "using": [
            "OrdField_ZF_1_L1B",
            "field0.field_has_no_zero_divs",
            "OrdRing_ZF_3_L19",
            "OrdRing_ZF_1_L3",
            "PositiveSet_def",
            "OrdField_ZF_1_L8"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L10: \n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\" and A2: \"a \\<noteq> \\<zero> \\<or> b \\<noteq> \\<zero>\"\n  shows \"\\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\"  and \"\\<exists>c\\<in>R. (a\\<^sup>2 \\<ra> b\\<^sup>2)\\<cdot>c = \\<one>\"\n",
        "proof": "proof -\n  from A1 A2 show \"\\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\"\n    using OrdField_ZF_1_L1B field0.field_has_no_zero_divs \n      OrdRing_ZF_3_L19 by simp\n  then have \n    \"(a\\<^sup>2 \\<ra> b\\<^sup>2)\\<inverse> \\<in> R\" and \"(a\\<^sup>2 \\<ra> b\\<^sup>2)\\<cdot>(a\\<^sup>2 \\<ra> b\\<^sup>2)\\<inverse> = \\<one>\"\n    using OrdRing_ZF_1_L3 PositiveSet_def OrdField_ZF_1_L8\n    by auto\n  then show \"\\<exists>c\\<in>R. (a\\<^sup>2 \\<ra> b\\<^sup>2)\\<cdot>c = \\<one>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1338
    },
    "1205": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>OrdField_ZF_2_L1\\<close> when we multiply\n  an inverse by an element.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\\<^sub>+\" and A2: \"a\\<inverse> \\<ls> b\"\n  ",
        "using": [
            "OrdField_ZF_2_L1",
            "OrdField_ZF_1_L8"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L2: \n  assumes A1: \"a\\<in>R\\<^sub>+\" and A2: \"a\\<inverse> \\<ls> b\"\n  shows \"\\<one> \\<ls> b\\<cdot>a\"\n",
        "proof": "proof -\n  from A1 A2 have \"(a\\<inverse>)\\<cdot>a \\<ls> b\\<cdot>a\"\n    using OrdField_ZF_2_L1 by simp\n  with A1 show \"\\<one> \\<ls> b\\<cdot>a\"\n    using OrdField_ZF_1_L8 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1340
    },
    "1206": {
        "type": "lemma",
        "text": "text\\<open>We can multiply an inequality by the inverse of a positive element.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"  and \"c\\<in>R\\<^sub>+\" ",
        "using": [
            "assms",
            "OrdField_ZF_1_L8",
            "OrdRing_ZF_1_L9A"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L3:\n  assumes \"a\\<lsq>b\"  and \"c\\<in>R\\<^sub>+\" shows \"a\\<cdot>(c\\<inverse>) \\<lsq> b\\<cdot>(c\\<inverse>)\"\n  ",
        "proof": "using assms OrdField_ZF_1_L8 OrdRing_ZF_1_L9A\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1341
    },
    "1207": {
        "type": "lemma",
        "text": "text\\<open>We can multiply a strict inequality by a  positive element\n  or its inverse.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" and \"c\\<in>R\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "OrdField_ZF_1_L1B",
            "field0.field_has_no_zero_divs",
            "OrdField_ZF_1_L8",
            "OrdRing_ZF_3_L13"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L4:\n  assumes \"a\\<ls>b\" and \"c\\<in>R\\<^sub>+\"\n  shows \n  \"a\\<cdot>c \\<ls> b\\<cdot>c\"\n  \"c\\<cdot>a \\<ls> c\\<cdot>b\"\n  \"a\\<cdot>c\\<inverse> \\<ls> b\\<cdot>c\\<inverse>\"\n   ",
        "proof": "using assms OrdField_ZF_1_L1B field0.field_has_no_zero_divs\n    OrdField_ZF_1_L8 OrdRing_ZF_3_L13 by auto\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1342
    },
    "1208": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of an inequality,\n  changing it to its inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\\<^sub>+\" and A2: \"a\\<cdot>b \\<lsq> c\"\n  ",
        "using": [
            "OrdField_ZF_2_L3",
            "OrdField_ZF_1_L7A"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L5:\n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\\<^sub>+\" and A2: \"a\\<cdot>b \\<lsq> c\"\n  shows \"a \\<lsq> c\\<cdot>b\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>b\\<cdot>b\\<inverse> \\<lsq> c\\<cdot>b\\<inverse>\"\n    using OrdField_ZF_2_L3 by simp\n  with A1 show \"a \\<lsq> c\\<cdot>b\\<inverse>\" using OrdField_ZF_1_L7A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1343
    },
    "1209": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of an inequality,\n  changing it to its inverse, version with a product initially on the \n  right hand side.\\<close>\n",
        "assumes": "assumes A1: \"b\\<in>R\"  \"c\\<in>R\\<^sub>+\" and A2: \"a \\<lsq> b\\<cdot>c\"\n  ",
        "using": [
            "OrdField_ZF_2_L3",
            "OrdField_ZF_1_L7A"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L5A:\n  assumes A1: \"b\\<in>R\"  \"c\\<in>R\\<^sub>+\" and A2: \"a \\<lsq> b\\<cdot>c\"\n  shows \"a\\<cdot>c\\<inverse> \\<lsq> b\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>c\\<inverse> \\<lsq> b\\<cdot>c\\<cdot>c\\<inverse>\"\n    using OrdField_ZF_2_L3 by simp\n  with A1 show \"a\\<cdot>c\\<inverse> \\<lsq> b\" using OrdField_ZF_1_L7A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1344
    },
    "1210": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of a strict\n  inequality, changing it to its inverse, version with a product\n  initially on the left hand side.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\\<^sub>+\" and A2: \"a\\<cdot>b \\<ls> c\"\n  ",
        "using": [
            "OrdField_ZF_2_L4",
            "OrdField_ZF_1_L7A"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L6:\n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\\<^sub>+\" and A2: \"a\\<cdot>b \\<ls> c\"\n  shows \"a \\<ls> c\\<cdot>b\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>b\\<cdot>b\\<inverse> \\<ls> c\\<cdot>b\\<inverse>\"\n    using OrdField_ZF_2_L4 by simp\n  with A1 show \"a \\<ls> c\\<cdot>b\\<inverse>\" using OrdField_ZF_1_L7A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1345
    },
    "1211": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of a strict\n  inequality, changing it to its inverse, version with a product\n  initially on the right hand side.\\<close>\n",
        "assumes": "assumes A1: \"b\\<in>R\"  \"c\\<in>R\\<^sub>+\" and A2: \"a \\<ls> b\\<cdot>c\"\n  ",
        "using": [
            "OrdField_ZF_2_L4",
            "OrdField_ZF_1_L7A"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L6A:\n  assumes A1: \"b\\<in>R\"  \"c\\<in>R\\<^sub>+\" and A2: \"a \\<ls> b\\<cdot>c\"\n  shows \"a\\<cdot>c\\<inverse> \\<ls> b\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>c\\<inverse> \\<ls> b\\<cdot>c\\<cdot>c\\<inverse>\"\n    using OrdField_ZF_2_L4 by simp\n  with A1 show \"a\\<cdot>c\\<inverse> \\<ls> b\" using OrdField_ZF_1_L7A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1346
    },
    "1212": {
        "type": "lemma",
        "text": "text\\<open>Sometimes we can reverse an inequality by taking inverse\n  on both sides.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\\<^sub>+\" and A2: \"a\\<inverse> \\<lsq> b\"\n  ",
        "using": [
            "OrdField_ZF_1_L8",
            "OrdRing_ZF_3_L7",
            "OrdRing_ZF_1_L9A",
            "PositiveSet_def",
            "OrdRing_ZF_1_L3",
            "OrdField_ZF_1_L1B",
            "field0.Field_ZF_1_L7",
            "field0.Field_ZF_1_L6",
            "Ring_ZF_1_L3"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L7: \n  assumes A1: \"a\\<in>R\\<^sub>+\" and A2: \"a\\<inverse> \\<lsq> b\"\n  shows \"b\\<inverse> \\<lsq> a\"\n",
        "proof": "proof -\n  from A1 have \"a\\<inverse> \\<in> R\\<^sub>+\" using OrdField_ZF_1_L8\n    by simp\n  with A2 have \"b \\<in> R\\<^sub>+\" using  OrdRing_ZF_3_L7\n    by blast\n  then have T: \"b \\<in> R\\<^sub>+\"  \"b\\<inverse> \\<in> R\\<^sub>+\" using OrdField_ZF_1_L8\n    by auto\n  with A1 A2 have \"b\\<inverse>\\<cdot>a\\<inverse>\\<cdot>a \\<lsq> b\\<inverse>\\<cdot>b\\<cdot>a\"\n    using OrdRing_ZF_1_L9A by simp\n  moreover \n  from A1 A2 T have\n    \"b\\<inverse> \\<in> R\"  \"a\\<in>R\" \"a\\<noteq>\\<zero>\"  \"b\\<in>R\"  \"b\\<noteq>\\<zero>\"\n    using PositiveSet_def OrdRing_ZF_1_L3 by auto\n  then have \"b\\<inverse>\\<cdot>a\\<inverse>\\<cdot>a = b\\<inverse>\" and  \"b\\<inverse>\\<cdot>b\\<cdot>a = a\"\n    using OrdField_ZF_1_L1B field0.Field_ZF_1_L7 \n      field0.Field_ZF_1_L6 Ring_ZF_1_L3\n    by auto\n  ultimately show \"b\\<inverse> \\<lsq> a\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1347
    },
    "1213": {
        "type": "lemma",
        "text": "text\\<open>Sometimes we can reverse a strict inequality by taking inverse\n  on both sides.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\\<^sub>+\" and A2: \"a\\<inverse> \\<ls> b\"\n  ",
        "using": [
            "OrdField_ZF_1_L8",
            "OrdRing_ZF_3_L7",
            "PositiveSet_def",
            "OrdField_ZF_1_L1B",
            "field0.Field_ZF_2_L4",
            "OrdField_ZF_2_L7"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L8: \n  assumes A1: \"a\\<in>R\\<^sub>+\" and A2: \"a\\<inverse> \\<ls> b\"\n  shows \"b\\<inverse> \\<ls> a\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<inverse> \\<in> R\\<^sub>+\"  \"a\\<inverse> \\<lsq>b\"\n    using OrdField_ZF_1_L8 by auto\n  then have \"b \\<in> R\\<^sub>+\" using OrdRing_ZF_3_L7\n    by blast\n  then have \"b\\<in>R\"  \"b\\<noteq>\\<zero>\" using PositiveSet_def by auto\n  with A2 have \"b\\<inverse> \\<noteq> a\"\n    using OrdField_ZF_1_L1B field0.Field_ZF_2_L4\n    by simp\n  with A1 A2 show \"b\\<inverse> \\<ls> a\"\n    using OrdField_ZF_2_L7 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1348
    },
    "1214": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about solving a strict inequality with three\n  field elements and inverse of a difference.\\<close>\n",
        "assumes": "assumes A1: \"a\\<ls>b\" and A2: \"(b\\<rs>a)\\<inverse> \\<ls> c\"\n  ",
        "using": [
            "OrdField_ZF_1_L9",
            "OrdRing_ZF_3_L7",
            "OrdRing_ZF_1_L3",
            "OrdField_ZF_1_L8",
            "PositiveSet_def",
            "OrdRing_ZF_1_L14",
            "OrdField_ZF_2_L8",
            "ring_strict_ord_trans_inv",
            "Ring_ZF_2_L1A",
            "OrdField_ZF_2_L1",
            "ring_oper_distr"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L9: \n  assumes A1: \"a\\<ls>b\" and A2: \"(b\\<rs>a)\\<inverse> \\<ls> c\"\n  shows \"\\<one> \\<ra> a\\<cdot>c \\<ls> b\\<cdot>c\"\n",
        "proof": "proof -\n  from A1 A2 have \"(b\\<rs>a)\\<inverse> \\<in> R\\<^sub>+\"  \"(b\\<rs>a)\\<inverse> \\<lsq> c\" \n    using OrdField_ZF_1_L9 by auto\n  then have T1: \"c \\<in> R\\<^sub>+\" using OrdRing_ZF_3_L7 by blast\n  with A1 A2 have T2: \n    \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"c\\<noteq>\\<zero>\"   \"c\\<inverse> \\<in> R\"\n    using OrdRing_ZF_1_L3 OrdField_ZF_1_L8 PositiveSet_def \n    by auto\n  with A1 A2  have \"c\\<inverse> \\<ra> a \\<ls> b\\<rs>a \\<ra> a\"\n    using OrdRing_ZF_1_L14 OrdField_ZF_2_L8 ring_strict_ord_trans_inv\n    by simp\n  with T1 T2 have \"(c\\<inverse> \\<ra> a)\\<cdot>c \\<ls> b\\<cdot>c\"\n    using Ring_ZF_2_L1A OrdField_ZF_2_L1 by simp\n  with T1 T2 show \"\\<one> \\<ra> a\\<cdot>c \\<ls> b\\<cdot>c\"\n    using ring_oper_distr OrdField_ZF_1_L8\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1349
    },
    "1215": {
        "type": "definition",
        "text": "text\\<open>We define model of real numbers as any quadruple of sets $(K,A,M,r)$ \n  such that $(K,A,M,r)$ is an ordered field and the order relation $r$\n  is complete, that is every set that is nonempty and bounded above in this \n  relation has a supremum.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAmodelOfReals(K,A,M,r) \\<equiv> IsAnOrdField(K,A,M,r) \\<and> (r {is complete})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1350
    },
    "1216": {
        "type": "definition",
        "text": "text\\<open>An ordered group is a group equipped with a partial order that is\n  \"translation invariant\", that is if $a\\leq b$ then $a\\cdot g \\leq b\\cdot g$\n  and $g\\cdot a \\leq g\\cdot b$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAnOrdGroup(G,P,r) \\<equiv> \n  (IsAgroup(G,P) \\<and> r\\<subseteq>G\\<times>G \\<and> IsPartOrder(G,r) \\<and> (\\<forall>g\\<in>G. \\<forall>a b. \n  \\<langle>a,b\\<rangle> \\<in> r \\<longrightarrow> \\<langle>P`\\<langle> a,g\\<rangle>,P`\\<langle> b,g\\<rangle> \\<rangle> \\<in> r \\<and> \\<langle> P`\\<langle> g,a\\<rangle>,P`\\<langle> g,b\\<rangle> \\<rangle> \\<in> r ) )\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1351
    },
    "1217": {
        "type": "definition",
        "text": "text\\<open>The odd functions are defined as those having property \n  $f(a^{-1})=(f(a))^{-1}$. This looks a bit strange in the \n  multiplicative notation, I have to admit.\n  For linearly ordered groups a function $f$ defined on the set of positive\n  elements iniquely defines an odd function of the whole group. This function\n  is called an odd extension of $f$\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"OddExtension(G,P,r,f) \\<equiv> \n  (f \\<union> {\\<langle>a, GroupInv(G,P)`(f`(GroupInv(G,P)`(a)))\\<rangle>. \n  a \\<in> GroupInv(G,P)``(PositiveSet(G,P,r))} \\<union> \n  {\\<langle>TheNeutralElement(G,P),TheNeutralElement(G,P)\\<rangle>})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1353
    },
    "1218": {
        "type": "lemma",
        "text": "text\\<open>In \\<open>group3\\<close> context we can use the theorems proven in the \n  \\<open>group0\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "ordGroupAssum",
            "IsAnOrdGroup_def",
            "group0_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L1: shows \"group0(G,P)\"\n  ",
        "proof": "using ordGroupAssum IsAnOrdGroup_def group0_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1354
    },
    "1219": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is just to see the definition of the positive set\n  in our notation.\\<close>\n",
        "assumes": "",
        "using": [
            "ordGroupAssum",
            "IsAnOrdGroup_def",
            "PositiveSet_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L2A: \n  shows \"g\\<in>G\\<^sub>+ \\<longleftrightarrow> (\\<one>\\<lsq>g \\<and> g\\<noteq>\\<one>)\"\n  ",
        "proof": "using ordGroupAssum IsAnOrdGroup_def PositiveSet_def \n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1357
    },
    "1220": {
        "type": "lemma",
        "text": "text\\<open>For total order if $g$ is not in $G^{+}$, then it has to be \n  less or equal the unit.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G-G\\<^sup>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L2",
            "IsTotal_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L2B: \n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G-G\\<^sup>+\"\n  shows \"a\\<lsq>\\<one>\"\n",
        "proof": "proof -\n  from A2 have \"a\\<in>G\"   \"\\<one> \\<in> G\"  \"\\<not>(\\<one>\\<lsq>a)\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2 OrderedGroup_ZF_1_L2 \n    by auto\n  with A1 show ?thesis using IsTotal_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1358
    },
    "1221": {
        "type": "lemma",
        "text": "text\\<open>In this context $a \\leq b$ implies that both $a$ and $b$ belong \n  to $G$.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L4: \n  assumes \"a\\<lsq>b\" shows \"a\\<in>G\" \"b\\<in>G\"\n  ",
        "proof": "using ordGroupAssum assms IsAnOrdGroup_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1361
    },
    "1222": {
        "type": "lemma",
        "text": "text\\<open>Similarly in this context $a \\le b$ implies that both $a$ and $b$ belong \n  to $G$.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) less_are_members: \n  assumes \"a\\<ls>b\" shows \"a\\<in>G\" \"b\\<in>G\"\n  ",
        "proof": "using ordGroupAssum assms IsAnOrdGroup_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1362
    },
    "1223": {
        "type": "lemma",
        "text": "text\\<open>It is good to have transitivity handy.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>c\" ",
        "using": [
            "IsAnOrdGroup_def",
            "IsPartOrder_def"
        ],
        "statement": "lemma (in group3) Group_order_transitive:\n  assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>c\" shows \"a\\<lsq>c\"\n",
        "proof": "proof -\n  from ordGroupAssum have \"trans(r)\"\n    using IsAnOrdGroup_def IsPartOrder_def\n    by simp\n  moreover from A1 have \"\\<langle> a,b\\<rangle> \\<in> r \\<and> \\<langle> b,c\\<rangle> \\<in> r\" by simp\n  ultimately have \"\\<langle> a,c\\<rangle> \\<in> r\" by (rule Fol1_L3)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1363
    },
    "1224": {
        "type": "lemma",
        "text": "text\\<open>The order in an ordered group is antisymmetric.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>a\" ",
        "using": [
            "IsAnOrdGroup_def",
            "IsPartOrder_def"
        ],
        "statement": "lemma (in group3) group_order_antisym:\n  assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>a\" shows \"a=b\"\n",
        "proof": "proof -\n  from ordGroupAssum A1 have \n    \"antisym(r)\"  \"\\<langle> a,b\\<rangle> \\<in> r\"  \"\\<langle> b,a\\<rangle> \\<in> r\"\n    using IsAnOrdGroup_def IsPartOrder_def by auto\n  then show \"a=b\" by (rule Fol1_L4) \nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1364
    },
    "1225": {
        "type": "lemma",
        "text": "text\\<open>Transitivity for the strict order: if $a < b$ and $b\\leq c$, then $a < c$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<ls>b\"  and A2: \"b\\<lsq>c\"\n  ",
        "using": [
            "group_order_antisym"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L4A:\n  assumes A1: \"a\\<ls>b\"  and A2: \"b\\<lsq>c\"\n  shows \"a\\<ls>c\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<lsq>b\"  \"b\\<lsq>c\" by auto\n  then have \"a\\<lsq>c\" by (rule Group_order_transitive)\n  moreover from A1 A2 have \"a\\<noteq>c\" using group_order_antisym by auto\n  ultimately show \"a\\<ls>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1365
    },
    "1226": {
        "type": "lemma",
        "text": "text\\<open>Another version of transitivity for the strict order: \n  if $a\\leq b$ and $b < c$, then $a < c$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"b\\<ls>c\"\n  ",
        "using": [
            "group_order_antisym"
        ],
        "statement": "lemma (in group3) group_strict_ord_transit:\n  assumes A1: \"a\\<lsq>b\" and A2: \"b\\<ls>c\"\n  shows \"a\\<ls>c\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<lsq>b\"  \"b\\<lsq>c\" by auto\n  then have  \"a\\<lsq>c\" by (rule Group_order_transitive)\n  moreover from A1 A2 have \"a\\<noteq>c\" using group_order_antisym by auto\n  ultimately show \"a\\<ls>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1366
    },
    "1227": {
        "type": "lemma",
        "text": "text\\<open>The order is translation invariant. \\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" \"c\\<in>G\"\n  ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) ord_transl_inv: assumes \"a\\<lsq>b\" \"c\\<in>G\"\n  shows \"a\\<cdot>c \\<lsq> b\\<cdot>c\" and \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n  ",
        "proof": "using ordGroupAssum assms unfolding IsAnOrdGroup_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1367
    },
    "1228": {
        "type": "lemma",
        "text": "text\\<open>Strict order is preserved by translations.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" and \"c\\<in>G\"\n  ",
        "using": [
            "assms",
            "ord_transl_inv",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L19"
        ],
        "statement": "lemma (in group3) group_strict_ord_transl_inv: \n  assumes \"a\\<ls>b\" and \"c\\<in>G\"\n  shows \"a\\<cdot>c \\<ls> b\\<cdot>c\" and \"c\\<cdot>a \\<ls> c\\<cdot>b\"\n  ",
        "proof": "using assms ord_transl_inv OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 group0.group0_2_L19 \n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1368
    },
    "1229": {
        "type": "lemma",
        "text": "text\\<open>If the group order is total, then the group is ordered linearly.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\"\n  ",
        "using": [
            "assms",
            "ordGroupAssum",
            "IsAnOrdGroup_def",
            "Order_ZF_1_L3"
        ],
        "statement": "lemma (in group3) group_ord_total_is_lin:\n  assumes \"r {is total on} G\"\n  shows \"IsLinOrder(G,r)\"\n  ",
        "proof": "using assms ordGroupAssum IsAnOrdGroup_def Order_ZF_1_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1369
    },
    "1230": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered groups elements in the nonnegative set are\n  greater than those in the complement.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\" \n  and \"a\\<in>G\\<^sup>+\" and \"b \\<in> G-G\\<^sup>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_1_L2B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L4B:\n  assumes \"r {is total on} G\" \n  and \"a\\<in>G\\<^sup>+\" and \"b \\<in> G-G\\<^sup>+\"\n  shows \"b\\<lsq>a\"\n",
        "proof": "proof -\n  from assms have \"b\\<lsq>\\<one>\" \"\\<one>\\<lsq>a\"\n    using OrderedGroup_ZF_1_L2 OrderedGroup_ZF_1_L2B by auto\n  then show ?thesis by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1370
    },
    "1231": {
        "type": "lemma",
        "text": "text\\<open>If $a\\leq 1$ and $a\\neq 1$, then $a \\in G\\setminus G^{+}$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>\\<one>\" and A2: \"a\\<noteq>\\<one>\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L2",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "antisym_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L4C:\n  assumes A1: \"a\\<lsq>\\<one>\" and A2: \"a\\<noteq>\\<one>\"\n  shows \"a \\<in> G-G\\<^sup>+\"\n",
        "proof": "proof - \n  { assume \"a \\<notin> G-G\\<^sup>+\" \n    with ordGroupAssum A1 A2 have False \n      using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L2\n\tOrderedGroup_ZF_1_L4 IsAnOrdGroup_def IsPartOrder_def antisym_def\n      by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1371
    },
    "1232": {
        "type": "lemma",
        "text": "text\\<open>An element smaller than an element in $G\\setminus G^+$ is in \n  $G\\setminus G^+$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G-G\\<^sup>+\" and A2: \"b\\<lsq>a\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L4D:\n  assumes A1: \"a\\<in>G-G\\<^sup>+\" and A2: \"b\\<lsq>a\"\n  shows \"b\\<in>G-G\\<^sup>+\"\n",
        "proof": "proof - \n  { assume \"b \\<notin> G - G\\<^sup>+\"\n    with A2 have \"\\<one>\\<lsq>b\" \"b\\<lsq>a\"\n      using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L2 by auto\n    then have \"\\<one>\\<lsq>a\" by (rule Group_order_transitive)\n    with A1 have False using OrderedGroup_ZF_1_L2 by simp\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1372
    },
    "1233": {
        "type": "lemma",
        "text": "text\\<open>Taking the inverse on both sides reverses the inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.group0_2_L6",
            "group0.group0_2_L2",
            "group0.group_oper_assoc"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5:\n  assumes A1: \"a\\<lsq>b\" shows \"b\\<inverse>\\<lsq>a\\<inverse>\"\n",
        "proof": "proof -\n  from A1 have T1: \"a\\<in>G\" \"b\\<in>G\" \"a\\<inverse>\\<in>G\" \"b\\<inverse>\\<in>G\" \n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 \n      group0.inverse_in_group by auto\n  with A1 ordGroupAssum have \"a\\<cdot>a\\<inverse>\\<lsq>b\\<cdot>a\\<inverse>\" using IsAnOrdGroup_def\n    by simp\n  with T1 ordGroupAssum have \"b\\<inverse>\\<cdot>\\<one>\\<lsq>b\\<inverse>\\<cdot>(b\\<cdot>a\\<inverse>)\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L6 IsAnOrdGroup_def\n    by simp\n  with T1 show ?thesis using\n    OrderedGroup_ZF_1_L1 group0.group0_2_L2 group0.group_oper_assoc\n    group0.group0_2_L6 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1375
    },
    "1234": {
        "type": "lemma",
        "text": "text\\<open>If an element is smaller that the unit, then its inverse is greater.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>\\<one>\" ",
        "using": [
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_one"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5A: \n  assumes A1: \"a\\<lsq>\\<one>\" shows \"\\<one>\\<lsq>a\\<inverse>\"\n",
        "proof": "proof -\n  from A1 have \"\\<one>\\<inverse>\\<lsq>a\\<inverse>\" using OrderedGroup_ZF_1_L5\n    by simp\n  then show ?thesis using OrderedGroup_ZF_1_L1 group0.group_inv_of_one \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1376
    },
    "1235": {
        "type": "lemma",
        "text": "text\\<open>If an the inverse of an element is greater that the unit, \n  then the element is smaller.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"\\<one>\\<lsq>a\\<inverse>\"  \n  ",
        "using": [
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv",
            "group0.group_inv_of_one"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AA: \n  assumes A1: \"a\\<in>G\" and A2: \"\\<one>\\<lsq>a\\<inverse>\"  \n  shows \"a\\<lsq>\\<one>\"\n",
        "proof": "proof -\n  from A2 have \"(a\\<inverse>)\\<inverse>\\<lsq>\\<one>\\<inverse>\" using OrderedGroup_ZF_1_L5\n    by simp\n  with A1 show \"a\\<lsq>\\<one>\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv group0.group_inv_of_one\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1377
    },
    "1236": {
        "type": "lemma",
        "text": "text\\<open>If an element is nonnegative, then the inverse is \n  not greater that the unit.\n  Also shows that nonnegative elements cannot be negative\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\" ",
        "using": [
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_one",
            "group_order_antisym"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AB:\n  assumes A1: \"\\<one>\\<lsq>a\" shows \"a\\<inverse>\\<lsq>\\<one>\" and \"\\<not>(a\\<lsq>\\<one> \\<and> a\\<noteq>\\<one>)\"\n",
        "proof": "proof -\n  from A1 have \"a\\<inverse>\\<lsq>\\<one>\\<inverse>\"\n    using OrderedGroup_ZF_1_L5 by simp\n  then show \"a\\<inverse>\\<lsq>\\<one>\" using OrderedGroup_ZF_1_L1 group0.group_inv_of_one\n    by simp\n  { assume \"a\\<lsq>\\<one>\" and \"a\\<noteq>\\<one>\"\n    with A1 have False using group_order_antisym\n      by blast\n  } then show \"\\<not>(a\\<lsq>\\<one> \\<and> a\\<noteq>\\<one>)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1378
    },
    "1237": {
        "type": "lemma",
        "text": "text\\<open>If two elements are greater or equal than the unit, then the inverse\n  of one is not greater than the other.\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\"  \"\\<one>\\<lsq>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L5AB"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AC:\n  assumes A1: \"\\<one>\\<lsq>a\"  \"\\<one>\\<lsq>b\"\n  shows \"a\\<inverse> \\<lsq> b\"\n",
        "proof": "proof -\n  from A1 have \"a\\<inverse>\\<lsq>\\<one>\"  \"\\<one>\\<lsq>b\"\n    using OrderedGroup_ZF_1_L5AB by auto\n  then show \"a\\<inverse> \\<lsq> b\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1379
    },
    "1238": {
        "type": "lemma",
        "text": "text\\<open>Taking negative on both sides reverses the inequality, case with\n  an inverse on one side.\\<close>\n",
        "assumes": "assumes A1: \"b \\<in> G\" and A2: \"a\\<lsq>b\\<inverse>\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AD:\n  assumes A1: \"b \\<in> G\" and A2: \"a\\<lsq>b\\<inverse>\"\n  shows \"b \\<lsq> a\\<inverse>\"\n",
        "proof": "proof -\n  from A2 have \"(b\\<inverse>)\\<inverse> \\<lsq> a\\<inverse>\"\n    using OrderedGroup_ZF_1_L5 by simp\n  with A1 show \"b \\<lsq> a\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1380
    },
    "1239": {
        "type": "lemma",
        "text": "text\\<open>We can cancel the same element on both sides of an inequality, right side.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and \"a\\<cdot>b \\<lsq> c\\<cdot>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "ord_transl_inv(1)",
            "group0.inv_cancel_two(2)"
        ],
        "statement": "lemma (in group3) ineq_cancel_right:\n  assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and \"a\\<cdot>b \\<lsq> c\\<cdot>b\"\n  shows \"a\\<lsq>c\"\n",
        "proof": "proof -\n  from assms(2,4) have \"(a\\<cdot>b)\\<cdot>b\\<inverse> \\<lsq> (c\\<cdot>b)\\<cdot>b\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group ord_transl_inv(1) by simp\n  with assms(1,2,3) show \"a\\<lsq>c\" using OrderedGroup_ZF_1_L1 group0.inv_cancel_two(2) \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1382
    },
    "1240": {
        "type": "lemma",
        "text": "text\\<open>We can cancel the same element on both sides of an inequality,\n  a version with an inverse on both sides.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<lsq> a\\<cdot>c\\<inverse>\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "OrderedGroup_ZF_1_L5AE",
            "OrderedGroup_ZF_1_L5",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AF:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<lsq> a\\<cdot>c\\<inverse>\"\n  shows \"c\\<lsq>b\"\n",
        "proof": "proof -\n  from A1 A2 have \"(c\\<inverse>)\\<inverse> \\<lsq> (b\\<inverse>)\\<inverse>\"\n     using OrderedGroup_ZF_1_L1 group0.inverse_in_group \n      OrderedGroup_ZF_1_L5AE OrderedGroup_ZF_1_L5 by simp\n  with A1 show \"c\\<lsq>b\" \n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1383
    },
    "1241": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the sides of two inequalities.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<lsq>d\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5B:\n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<lsq>d\"\n  shows \"a\\<cdot>c \\<lsq> b\\<cdot>d\"\n",
        "proof": "proof -\n  from A1 A2 have \"c\\<in>G\" \"b\\<in>G\" using OrderedGroup_ZF_1_L4 by auto\n  with A1 A2 ordGroupAssum have \"a\\<cdot>c\\<lsq> b\\<cdot>c\" \"b\\<cdot>c\\<lsq>b\\<cdot>d\"\n    using IsAnOrdGroup_def by auto\n  then show \"a\\<cdot>c \\<lsq> b\\<cdot>d\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1385
    },
    "1242": {
        "type": "lemma",
        "text": "text\\<open>We can replace first of the factors on one side of an inequality \n  with a greater one.\\<close>\n",
        "assumes": "assumes A1: \"c\\<in>G\" and A2: \"a\\<lsq>b\\<cdot>c\" and A3: \"b\\<lsq>b\\<^sub>1\" \n  ",
        "using": [
            "OrderedGroup_ZF_1_L3",
            "OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5C: \n  assumes A1: \"c\\<in>G\" and A2: \"a\\<lsq>b\\<cdot>c\" and A3: \"b\\<lsq>b\\<^sub>1\" \n  shows \"a\\<lsq>b\\<^sub>1\\<cdot>c\"\n",
        "proof": "proof -\n  from A1 A3 have \"b\\<cdot>c \\<lsq> b\\<^sub>1\\<cdot>c\"\n    using OrderedGroup_ZF_1_L3 OrderedGroup_ZF_1_L5B by simp\n  with A2 show \"a\\<lsq>b\\<^sub>1\\<cdot>c\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1386
    },
    "1243": {
        "type": "lemma",
        "text": "text\\<open>We can replace second of the factors on one side of an inequality \n  with a greater one.\\<close>\n",
        "assumes": "assumes A1: \"b\\<in>G\" and A2: \"a \\<lsq> b\\<cdot>c\" and A3: \"c\\<lsq>b\\<^sub>1\" \n  ",
        "using": [
            "OrderedGroup_ZF_1_L3",
            "OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5D: \n  assumes A1: \"b\\<in>G\" and A2: \"a \\<lsq> b\\<cdot>c\" and A3: \"c\\<lsq>b\\<^sub>1\" \n  shows \"a \\<lsq> b\\<cdot>b\\<^sub>1\"\n",
        "proof": "proof -\n  from A1 A3 have \"b\\<cdot>c \\<lsq> b\\<cdot>b\\<^sub>1\"\n    using OrderedGroup_ZF_1_L3 OrderedGroup_ZF_1_L5B by auto\n  with A2 show \"a\\<lsq>b\\<cdot>b\\<^sub>1\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1387
    },
    "1244": {
        "type": "lemma",
        "text": "text\\<open>We can replace factors on one side of an inequality \n  with greater ones.\\<close>\n",
        "assumes": "assumes A1: \"a \\<lsq> b\\<cdot>c\" and A2: \"b\\<lsq>b\\<^sub>1\"  \"c\\<lsq>c\\<^sub>1\"  \n  ",
        "using": [
            "OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5E: \n  assumes A1: \"a \\<lsq> b\\<cdot>c\" and A2: \"b\\<lsq>b\\<^sub>1\"  \"c\\<lsq>c\\<^sub>1\"  \n  shows \"a \\<lsq> b\\<^sub>1\\<cdot>c\\<^sub>1\"\n",
        "proof": "proof -\n  from A2 have \"b\\<cdot>c \\<lsq> b\\<^sub>1\\<cdot>c\\<^sub>1\" using OrderedGroup_ZF_1_L5B \n    by simp\n  with A1 show \"a\\<lsq>b\\<^sub>1\\<cdot>c\\<^sub>1\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1388
    },
    "1245": {
        "type": "lemma",
        "text": "text\\<open>We don't decrease an element of the group by multiplying by one that is\n  nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\" and A2: \"b\\<in>G\"\n  ",
        "using": [
            "IsAnOrdGroup_def",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5F:\n  assumes A1: \"\\<one>\\<lsq>a\" and A2: \"b\\<in>G\"\n  shows \"b\\<lsq>a\\<cdot>b\"  \"b\\<lsq>b\\<cdot>a\" \n",
        "proof": "proof -\n  from ordGroupAssum A1 A2 have  \n    \"\\<one>\\<cdot>b\\<lsq>a\\<cdot>b\"  \"b\\<cdot>\\<one>\\<lsq>b\\<cdot>a\"\n    using IsAnOrdGroup_def by auto\n  with A2 show \"b\\<lsq>a\\<cdot>b\"  \"b\\<lsq>b\\<cdot>a\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1389
    },
    "1246": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the right hand side of an inequality by a nonnegative\n  element.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"\n  and A2: \"\\<one>\\<lsq>c\" ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L5F"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5G: assumes A1: \"a\\<lsq>b\"\n  and A2: \"\\<one>\\<lsq>c\" shows \"a\\<lsq>b\\<cdot>c\"  \"a\\<lsq>c\\<cdot>b\" \n",
        "proof": "proof -\n  from A1 A2 have I: \"b\\<lsq>b\\<cdot>c\"  and II: \"b\\<lsq>c\\<cdot>b\"\n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L5F by auto\n  from A1 I show \"a\\<lsq>b\\<cdot>c\" by (rule Group_order_transitive)\n  from A1 II show \"a\\<lsq>c\\<cdot>b\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1390
    },
    "1247": {
        "type": "lemma",
        "text": "text\\<open>We can put two elements on the other side of inequality, \n  changing their sign.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<lsq> c\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5H: \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<lsq> c\"\n  shows \n  \"a \\<lsq> c\\<cdot>b\"\n  \"c\\<inverse>\\<cdot>a \\<lsq> b\"\n",
        "proof": "proof -\n  from A2 have T: \"c\\<in>G\"  \"c\\<inverse> \\<in> G\"\n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 \n      group0.inverse_in_group by auto\n  from ordGroupAssum A1 A2 have \"a\\<cdot>b\\<inverse>\\<cdot>b \\<lsq> c\\<cdot>b\"\n    using IsAnOrdGroup_def by simp\n  with A1 show \"a \\<lsq> c\\<cdot>b\" \n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\n  with ordGroupAssum A2 T have \"c\\<inverse>\\<cdot>a \\<lsq> c\\<inverse>\\<cdot>(c\\<cdot>b)\"\n    using IsAnOrdGroup_def by simp\n  with A1 T show \"c\\<inverse>\\<cdot>a \\<lsq> b\"  \n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1391
    },
    "1248": {
        "type": "lemma",
        "text": "text\\<open>We can put an element on the other side of an inequality\n  changing its sign, version with the inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"c \\<lsq> a\\<cdot>b\\<inverse>\"\n  ",
        "using": [
            "IsAnOrdGroup_def",
            "OrderedGroup_ZF_1_L1",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5J:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"c \\<lsq> a\\<cdot>b\\<inverse>\"\n  shows \"c\\<cdot>b \\<lsq> a\"\n",
        "proof": "proof -\n  from ordGroupAssum A1 A2 have \"c\\<cdot>b \\<lsq> a\\<cdot>b\\<inverse>\\<cdot>b\"\n    using IsAnOrdGroup_def by simp\n  with A1 show \"c\\<cdot>b \\<lsq> a\" \n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1393
    },
    "1249": {
        "type": "lemma",
        "text": "text\\<open>We can put an element on the other side of an inequality\n  changing its sign, version with the inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"c \\<lsq> a\\<inverse>\\<cdot>b\"\n  ",
        "using": [
            "IsAnOrdGroup_def",
            "OrderedGroup_ZF_1_L1",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5JA:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"c \\<lsq> a\\<inverse>\\<cdot>b\"\n  shows \"a\\<cdot>c\\<lsq> b\"\n",
        "proof": "proof -\n  from ordGroupAssum A1 A2 have \"a\\<cdot>c \\<lsq> a\\<cdot>(a\\<inverse>\\<cdot>b)\"\n    using IsAnOrdGroup_def by simp\n  with A1 show \"a\\<cdot>c\\<lsq> b\" \n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1394
    },
    "1250": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>OrderedGroup_ZF_1_L5J\\<close> where $c=1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"\\<one> \\<lsq> a\\<cdot>b\\<inverse>\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L5J",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "corollary (in group3) OrderedGroup_ZF_1_L5K: \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"\\<one> \\<lsq> a\\<cdot>b\\<inverse>\"\n  shows \"b \\<lsq> a\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<one>\\<cdot>b \\<lsq> a\"\n    using OrderedGroup_ZF_1_L5J by simp\n  with A1 show \"b \\<lsq> a\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1395
    },
    "1251": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>OrderedGroup_ZF_1_L5JA\\<close> where $c=1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"\\<one> \\<lsq> a\\<inverse>\\<cdot>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L5JA",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "corollary (in group3) OrderedGroup_ZF_1_L5KA: \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"\\<one> \\<lsq> a\\<inverse>\\<cdot>b\"\n  shows \"a \\<lsq> b\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>\\<one> \\<lsq> b\"\n    using OrderedGroup_ZF_1_L5JA by simp\n  with A1 show \"a \\<lsq> b\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1396
    },
    "1252": {
        "type": "lemma",
        "text": "text\\<open>If the order is total, the elements that do not belong\n  to the positive set are negative. We also show here that the group inverse\n  of an element that does not belong to the nonnegative set does belong to the\n  nonnegative set.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G-G\\<^sup>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L2",
            "IsTotal_def",
            "OrderedGroup_ZF_1_L5A",
            "restrict"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L6: \n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G-G\\<^sup>+\"\n  shows \"a\\<lsq>\\<one>\"  \"a\\<inverse> \\<in> G\\<^sup>+\"  \"restrict(GroupInv(G,P),G-G\\<^sup>+)`(a) \\<in> G\\<^sup>+\" \n",
        "proof": "proof - \n  from A2 have T1: \"a\\<in>G\" \"a\\<notin>G\\<^sup>+\" \"\\<one>\\<in>G\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2 by auto\n  with A1 show \"a\\<lsq>\\<one>\" using OrderedGroup_ZF_1_L2 IsTotal_def\n    by auto\n  then show \"a\\<inverse> \\<in> G\\<^sup>+\" using OrderedGroup_ZF_1_L5A OrderedGroup_ZF_1_L2\n    by simp\n  with A2 show \"restrict(GroupInv(G,P),G-G\\<^sup>+)`(a) \\<in> G\\<^sup>+\"\n    using restrict by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1397
    },
    "1253": {
        "type": "lemma",
        "text": "text\\<open>If a property is invariant with respect to taking the inverse\n  and it is true on the nonnegative set, than it is true on the whole\n  group.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"\\<forall>a\\<in>G\\<^sup>+.\\<forall>b\\<in>G\\<^sup>+. Q(a,b)\"\n  and A3: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. Q(a,b)\\<longrightarrow>Q(a\\<inverse>,b)\"\n  and A4: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. Q(a,b)\\<longrightarrow>Q(a,b\\<inverse>)\"\n  and A5: \"a\\<in>G\" \"b\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L6",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L7:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"\\<forall>a\\<in>G\\<^sup>+.\\<forall>b\\<in>G\\<^sup>+. Q(a,b)\"\n  and A3: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. Q(a,b)\\<longrightarrow>Q(a\\<inverse>,b)\"\n  and A4: \"\\<forall>a\\<in>G.\\<forall>b\\<in>G. Q(a,b)\\<longrightarrow>Q(a,b\\<inverse>)\"\n  and A5: \"a\\<in>G\" \"b\\<in>G\"\n  shows \"Q(a,b)\"\n",
        "proof": "proof -\n  { assume A6: \"a\\<in>G\\<^sup>+\" have \"Q(a,b)\"\n    proof -\n      { assume \"b\\<in>G\\<^sup>+\" \n\twith A6 A2 have \"Q(a,b)\" by simp }\n      moreover\n      { assume \"b\\<notin>G\\<^sup>+\"\n\twith A1 A2 A4 A5 A6 have \"Q(a,(b\\<inverse>)\\<inverse>)\"  \n\t  using OrderedGroup_ZF_1_L6 OrderedGroup_ZF_1_L1 group0.inverse_in_group\n\t  by simp\n\twith A5 have \"Q(a,b)\" using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n\t  by simp }\n      ultimately show \"Q(a,b)\" by auto\n    qed }\n  moreover\n  { assume \"a\\<notin>G\\<^sup>+\"\n    with A1 A5 have T1: \"a\\<inverse> \\<in> G\\<^sup>+\" using OrderedGroup_ZF_1_L6 by simp\n    have \"Q(a,b)\"\n    proof -\n      { assume \"b\\<in>G\\<^sup>+\"\n\twith A2 A3 A5 T1 have \"Q((a\\<inverse>)\\<inverse>,b)\" \n\t  using OrderedGroup_ZF_1_L1 group0.inverse_in_group by simp\n\twith A5 have \"Q(a,b)\" using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n\t  by simp }\n      moreover\n      { assume \"b\\<notin>G\\<^sup>+\"\n\twith A1 A2 A3 A4 A5 T1 have \"Q((a\\<inverse>)\\<inverse>,(b\\<inverse>)\\<inverse>)\"\n\t  using OrderedGroup_ZF_1_L6 OrderedGroup_ZF_1_L1 group0.inverse_in_group\n\t  by simp\n\twith A5 have \"Q(a,b)\" using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n\t  by simp }\n      ultimately show \"Q(a,b)\" by auto\n    qed }\n  ultimately show \"Q(a,b)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1398
    },
    "1254": {
        "type": "lemma",
        "text": "text\\<open>A lemma about splitting the ordered group \"plane\" into 6 subsets. Useful\n  for proofs by cases.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" \n  and A2:  \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group_op_closed",
            "group0.group0_2_L2",
            "IsTotal_def"
        ],
        "statement": "lemma (in group3) OrdGroup_6cases: assumes A1: \"r {is total on} G\" \n  and A2:  \"a\\<in>G\"  \"b\\<in>G\"\n  shows \n  \"\\<one>\\<lsq>a \\<and> \\<one>\\<lsq>b  \\<or>  a\\<lsq>\\<one> \\<and> b\\<lsq>\\<one>  \\<or>  \n  a\\<lsq>\\<one> \\<and> \\<one>\\<lsq>b \\<and> \\<one> \\<lsq> a\\<cdot>b  \\<or> a\\<lsq>\\<one> \\<and> \\<one>\\<lsq>b \\<and> a\\<cdot>b \\<lsq> \\<one>  \\<or>  \n  \\<one>\\<lsq>a \\<and> b\\<lsq>\\<one> \\<and> \\<one> \\<lsq> a\\<cdot>b  \\<or>  \\<one>\\<lsq>a \\<and> b\\<lsq>\\<one> \\<and> a\\<cdot>b \\<lsq> \\<one>\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"\\<one>\\<lsq>a \\<or> a\\<lsq>\\<one>\"   \n    \"\\<one>\\<lsq>b \\<or> b\\<lsq>\\<one>\"\n    \"\\<one> \\<lsq> a\\<cdot>b \\<or> a\\<cdot>b \\<lsq> \\<one>\"\n    using OrderedGroup_ZF_1_L1 group0.group_op_closed group0.group0_2_L2\n      IsTotal_def by auto\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1399
    },
    "1255": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows what happens when one element of a totally \n  ordered group is not greater or equal than another.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  and A3: \"\\<not>(a\\<lsq>b)\"\n  ",
        "using": [],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L8:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  and A3: \"\\<not>(a\\<lsq>b)\"\n  shows \"b \\<lsq> a\"  \"a\\<inverse> \\<lsq> b\\<inverse>\"  \"a\\<noteq>b\"  \"b\\<ls>a\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1400
    },
    "1256": {
        "type": "lemma",
        "text": "text\\<open>If one element is greater or equal and not equal to another,\n  then it is not smaller or equal.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"a\\<noteq>b\"\n  ",
        "using": [],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L8AA: \n  assumes A1: \"a\\<lsq>b\" and A2: \"a\\<noteq>b\"\n  shows \"\\<not>(b\\<lsq>a)\"\n",
        "proof": "proof -\n  { note A1\n    moreover assume \"b\\<lsq>a\"\n    ultimately have \"a=b\" by (rule group_order_antisym)\n    with A2 have False by simp\n  } thus \"\\<not>(b\\<lsq>a)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1401
    },
    "1257": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>OrderedGroup_ZF_1_L8\\<close> when one of \n  the elements is the unit.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"a\\<in>G\" and A3: \"\\<not>(\\<one>\\<lsq>a)\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "group0.group_inv_of_one",
            "IsTotal_def"
        ],
        "statement": "corollary (in group3) OrderedGroup_ZF_1_L8A:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"a\\<in>G\" and A3: \"\\<not>(\\<one>\\<lsq>a)\"\n  shows \"\\<one> \\<lsq> a\\<inverse>\"  \"\\<one>\\<noteq>a\"  \"a\\<lsq>\\<one>\"\n",
        "proof": "proof -\n  from A1 A2 A3 have I:\n    \"r {is total on} G\"\n    \"\\<one>\\<in>G\"  \"a\\<in>G\"\n     \"\\<not>(\\<one>\\<lsq>a)\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by auto\n  then have \"\\<one>\\<inverse> \\<lsq> a\\<inverse>\"\n    by (rule OrderedGroup_ZF_1_L8)\n  then show \"\\<one> \\<lsq> a\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_one by simp\n  from I show \"\\<one>\\<noteq>a\" by (rule OrderedGroup_ZF_1_L8)\n  from A1 I show \"a\\<lsq>\\<one>\" using IsTotal_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1402
    },
    "1258": {
        "type": "lemma",
        "text": "text\\<open>A negative element can not be nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>\\<one>\"  and A2: \"a\\<noteq>\\<one>\" ",
        "using": [
            "group_order_antisym"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L8B:\n  assumes A1: \"a\\<lsq>\\<one>\"  and A2: \"a\\<noteq>\\<one>\" shows \"\\<not>(\\<one>\\<lsq>a)\"\n",
        "proof": "proof -\n  { assume  \"\\<one>\\<lsq>a\" \n    with A1 have \"a=\\<one>\" using group_order_antisym\n      by auto\n    with A2 have False by simp\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1403
    },
    "1259": {
        "type": "lemma",
        "text": "text\\<open>An element is greater or equal than another iff the difference is \n  nonpositive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.group0_2_L6",
            "group0.inv_cancel_two",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a\\<lsq>b \\<longleftrightarrow> a\\<cdot>b\\<inverse> \\<lsq> \\<one>\"\n",
        "proof": "proof\n  assume \"a \\<lsq> b\"\n  with ordGroupAssum A1 have \"a\\<cdot>b\\<inverse> \\<lsq> b\\<cdot>b\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group\n    IsAnOrdGroup_def by simp\n  with A1 show \"a\\<cdot>b\\<inverse> \\<lsq> \\<one>\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L6\n    by simp\nnext assume A2: \"a\\<cdot>b\\<inverse> \\<lsq> \\<one>\"\n  with ordGroupAssum A1 have \"a\\<cdot>b\\<inverse>\\<cdot>b \\<lsq> \\<one>\\<cdot>b\"\n    using IsAnOrdGroup_def by simp\n  with A1 show \"a \\<lsq> b\"\n    using OrderedGroup_ZF_1_L1 \n      group0.inv_cancel_two group0.group0_2_L2 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1404
    },
    "1260": {
        "type": "lemma",
        "text": "text\\<open>We can move an element to the other side of an inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9A:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \"a\\<cdot>b \\<lsq> c  \\<longleftrightarrow> a \\<lsq> c\\<cdot>b\\<inverse>\"\n",
        "proof": "proof\n  assume \"a\\<cdot>b \\<lsq> c\"\n  with ordGroupAssum A1 have \"a\\<cdot>b\\<cdot>b\\<inverse> \\<lsq> c\\<cdot>b\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group IsAnOrdGroup_def\n    by simp\n  with A1 show \"a \\<lsq> c\\<cdot>b\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two by simp\nnext assume \"a \\<lsq> c\\<cdot>b\\<inverse>\"\n  with ordGroupAssum A1 have \"a\\<cdot>b \\<lsq> c\\<cdot>b\\<inverse>\\<cdot>b\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group IsAnOrdGroup_def\n    by simp\n  with A1 show \"a\\<cdot>b \\<lsq> c\"\n     using OrderedGroup_ZF_1_L1 group0.inv_cancel_two by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1405
    },
    "1261": {
        "type": "lemma",
        "text": "text\\<open>A one side version of the previous lemma with weaker assuptions.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<lsq> c\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L9A",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9B:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<lsq> c\"\n  shows \"a \\<lsq> c\\<cdot>b\"\n",
        "proof": "proof - \n  from A1 A2 have \"a\\<in>G\"  \"b\\<inverse>\\<in>G\"  \"c\\<in>G\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group \n      OrderedGroup_ZF_1_L4 by auto\n  with A1 A2 show \"a \\<lsq> c\\<cdot>b\"\n    using OrderedGroup_ZF_1_L9A OrderedGroup_ZF_1_L1 \n      group0.group_inv_of_inv by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1406
    },
    "1262": {
        "type": "lemma",
        "text": "text\\<open>We can put en element on the other side of inequality, \n  changing its sign.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"c\\<lsq>a\\<cdot>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9C:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"c\\<lsq>a\\<cdot>b\"\n  shows \n  \"c\\<cdot>b\\<inverse> \\<lsq> a\"\n  \"a\\<inverse>\\<cdot>c \\<lsq> b\"\n",
        "proof": "proof -\n  from ordGroupAssum A1 A2 have\n    \"c\\<cdot>b\\<inverse> \\<lsq> a\\<cdot>b\\<cdot>b\\<inverse>\"\n    \"a\\<inverse>\\<cdot>c \\<lsq> a\\<inverse>\\<cdot>(a\\<cdot>b)\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group IsAnOrdGroup_def\n    by auto\n  with A1 show  \n    \"c\\<cdot>b\\<inverse> \\<lsq> a\"\n    \"a\\<inverse>\\<cdot>c \\<lsq> b\"\n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1407
    },
    "1263": {
        "type": "lemma",
        "text": "text\\<open>If an element is greater or equal than another then the difference is \n  nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.group0_2_L6"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9D: assumes A1: \"a\\<lsq>b\"\n  shows \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>G\"  \"b\\<in>G\"   \"a\\<inverse> \\<in> G\" \n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 \n      group0.inverse_in_group by auto\n  with ordGroupAssum A1 have \"a\\<cdot>a\\<inverse> \\<lsq> b\\<cdot>a\\<inverse>\"\n    using IsAnOrdGroup_def by simp\n  with T show \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L6\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1408
    },
    "1264": {
        "type": "lemma",
        "text": "text\\<open>If an element is greater than another then the difference is \n  positive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  \"a\\<noteq>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L9D",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L11A",
            "OrderedGroup_ZF_1_L2A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9E: \n  assumes A1: \"a\\<lsq>b\"  \"a\\<noteq>b\"\n  shows \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\"  \"\\<one> \\<noteq> b\\<cdot>a\\<inverse>\"  \"b\\<cdot>a\\<inverse> \\<in> G\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>G\"  \"b\\<in>G\" using OrderedGroup_ZF_1_L4\n    by auto\n  from A1 show I: \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\" using OrderedGroup_ZF_1_L9D\n    by simp\n  { assume \"b\\<cdot>a\\<inverse> = \\<one>\" \n    with T have \"a=b\"\n      using OrderedGroup_ZF_1_L1 group0.group0_2_L11A\n      by auto\n    with A1 have False by simp \n  } then show \"\\<one> \\<noteq> b\\<cdot>a\\<inverse>\" by auto\n  then have \"b\\<cdot>a\\<inverse> \\<noteq> \\<one>\" by auto\n  with I show \"b\\<cdot>a\\<inverse> \\<in> G\\<^sub>+\" using OrderedGroup_ZF_1_L2A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1409
    },
    "1265": {
        "type": "lemma",
        "text": "text\\<open>If the difference is nonnegative, then $a\\leq b$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L9A",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L9F: \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\"\n  shows \"a\\<lsq>b\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<one>\\<cdot>a \\<lsq> b\"\n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L9A\n    by simp\n  with A1 show \"a\\<lsq>b\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1410
    },
    "1266": {
        "type": "lemma",
        "text": "text\\<open>If we increase the middle term in a product, the whole product \n  increases.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" and \"c\\<lsq>d\"\n  ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L10: \n  assumes \"a\\<in>G\"  \"b\\<in>G\" and \"c\\<lsq>d\"\n  shows \"a\\<cdot>c\\<cdot>b \\<lsq> a\\<cdot>d\\<cdot>b\"\n  ",
        "proof": "using ordGroupAssum assms IsAnOrdGroup_def by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1411
    },
    "1267": {
        "type": "lemma",
        "text": "text\\<open>A product of (strictly) positive elements is not the unit.\\<close>\n",
        "assumes": "assumes A1: \"\\<one>\\<lsq>a\"  \"\\<one>\\<lsq>b\"\n  and A2: \"\\<one> \\<noteq> a\"  \"\\<one> \\<noteq> b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L9",
            "OrderedGroup_ZF_1_L5AA"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L11: \n  assumes A1: \"\\<one>\\<lsq>a\"  \"\\<one>\\<lsq>b\"\n  and A2: \"\\<one> \\<noteq> a\"  \"\\<one> \\<noteq> b\"\n  shows \"\\<one> \\<noteq> a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have T1: \"a\\<in>G\"  \"b\\<in>G\"\n    using OrderedGroup_ZF_1_L4 by auto\n  { assume \"\\<one> = a\\<cdot>b\"\n    with A1 T1 have \"a\\<lsq>\\<one>\"  \"\\<one>\\<lsq>a\"\n      using OrderedGroup_ZF_1_L1 group0.group0_2_L9 OrderedGroup_ZF_1_L5AA \n      by auto\n    then have \"a = \\<one>\" by (rule group_order_antisym)\n    with A2 have False by simp\n  } then show \"\\<one> \\<noteq> a\\<cdot>b\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1412
    },
    "1268": {
        "type": "lemma",
        "text": "text\\<open>A product of nonnegative elements is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"\\<one> \\<lsq> a\"  \"\\<one> \\<lsq> b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L5B",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L12:\n  assumes A1: \"\\<one> \\<lsq> a\"  \"\\<one> \\<lsq> b\"\n  shows \"\\<one> \\<lsq> a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have \"\\<one>\\<cdot>\\<one> \\<lsq> a\\<cdot>b\"\n    using  OrderedGroup_ZF_1_L5B by simp\n  then show \"\\<one> \\<lsq> a\\<cdot>b\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1413
    },
    "1269": {
        "type": "lemma",
        "text": "text\\<open>We can move an element to the other side of a strict inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and  A2: \"a\\<cdot>b\\<inverse> \\<ls> c\"\n  ",
        "using": [
            "group_strict_ord_transl_inv",
            "OrderedGroup_ZF_1_L1",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L12B:  \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and  A2: \"a\\<cdot>b\\<inverse> \\<ls> c\"\n  shows \"a \\<ls> c\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>b\\<inverse>\\<cdot>b \\<ls> c\\<cdot>b\"\n    using group_strict_ord_transl_inv by auto\n  moreover from A1 have \"a\\<cdot>b\\<inverse>\\<cdot>b = a\"\n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\n  ultimately show \"a \\<ls> c\\<cdot>b\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1415
    },
    "1270": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the sides of two inequalities,\n  first of them strict and we get a strict inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<ls>b\" and A2: \"c\\<lsq>d\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "IsAnOrdGroup_def",
            "group_strict_ord_transl_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L12C:\n  assumes A1: \"a\\<ls>b\" and A2: \"c\\<lsq>d\"\n  shows \"a\\<cdot>c \\<ls> b\\<cdot>d\"\n",
        "proof": "proof -\n  from A1 A2 have T: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n    using OrderedGroup_ZF_1_L4 by auto\n  with ordGroupAssum A2 have \"a\\<cdot>c \\<lsq> a\\<cdot>d\"\n    using IsAnOrdGroup_def by simp\n  moreover from A1 T have \"a\\<cdot>d \\<ls> b\\<cdot>d\"\n    using group_strict_ord_transl_inv by simp\n  ultimately show \"a\\<cdot>c \\<ls> b\\<cdot>d\"\n    by (rule group_strict_ord_transit)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1416
    },
    "1271": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the sides of two inequalities,\n  second of them strict and we get a strict inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<ls>d\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "group_strict_ord_transl_inv",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L12D:\n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<ls>d\"\n  shows \"a\\<cdot>c \\<ls> b\\<cdot>d\"\n",
        "proof": "proof -\n  from A1 A2 have T: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n    using OrderedGroup_ZF_1_L4 by auto\n  with A2 have \"a\\<cdot>c \\<ls> a\\<cdot>d\" \n    using group_strict_ord_transl_inv by simp\n  moreover from ordGroupAssum A1 T have \"a\\<cdot>d \\<lsq> b\\<cdot>d\"\n     using IsAnOrdGroup_def by simp\n   ultimately show \"a\\<cdot>c \\<ls> b\\<cdot>d\"\n     by (rule OrderedGroup_ZF_1_L4A)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1417
    },
    "1272": {
        "type": "lemma",
        "text": "text\\<open>The positive set is closed under the group operation.\\<close>\n",
        "assumes": "",
        "using": [
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L11",
            "OrderedGroup_ZF_1_L12",
            "OrderedGroup_ZF_1_L4",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L13: shows \"G\\<^sub>+ {is closed under} P\"\n",
        "proof": "proof -\n  { fix a b assume \"a\\<in>G\\<^sub>+\"  \"b\\<in>G\\<^sub>+\"\n    then have T1: \"\\<one> \\<lsq> a\\<cdot>b\"   and \"\\<one> \\<noteq> a\\<cdot>b\"\n      using PositiveSet_def OrderedGroup_ZF_1_L11 OrderedGroup_ZF_1_L12\n      by auto\n    moreover from T1 have \"a\\<cdot>b \\<in> G\"\n      using OrderedGroup_ZF_1_L4 by simp\n    ultimately have \"a\\<cdot>b \\<in> G\\<^sub>+\" using PositiveSet_def by simp\n  } then show \"G\\<^sub>+ {is closed under} P\" using IsOpClosed_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1418
    },
    "1273": {
        "type": "lemma",
        "text": "text\\<open>For totally ordered groups every nonunit element is positive or its \n  inverse is positive.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \n  ",
        "using": [
            "IsTotal_def",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "group0.group0_2_L8B",
            "OrderedGroup_ZF_1_L5A",
            "OrderedGroup_ZF_1_L2A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L14:\n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \n  shows \"a=\\<one> \\<or> a\\<in>G\\<^sub>+ \\<or> a\\<inverse>\\<in>G\\<^sub>+\"\n",
        "proof": "proof -\n  { assume A3: \"a\\<noteq>\\<one>\"\n    moreover from A1 A2 have \"a\\<lsq>\\<one> \\<or> \\<one>\\<lsq>a\"\n      using IsTotal_def OrderedGroup_ZF_1_L1 group0.group0_2_L2\n      by simp\n    moreover from A3 A2 have T1: \"a\\<inverse> \\<noteq> \\<one>\"\n      using OrderedGroup_ZF_1_L1 group0.group0_2_L8B\n      by simp\n    ultimately have \"a\\<inverse>\\<in>G\\<^sub>+ \\<or> a\\<in>G\\<^sub>+\"\n      using OrderedGroup_ZF_1_L5A OrderedGroup_ZF_1_L2A\n      by auto\n  } thus \"a=\\<one> \\<or> a\\<in>G\\<^sub>+ \\<or> a\\<inverse>\\<in>G\\<^sub>+\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1419
    },
    "1274": {
        "type": "lemma",
        "text": "text\\<open>If an element belongs to the positive set, then it is not the unit\n  and its inverse does not belong to the positive set.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\\<^sub>+\"  ",
        "using": [
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L5AA"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L15:\n   assumes A1: \"a\\<in>G\\<^sub>+\"  shows \"a\\<noteq>\\<one>\"  \"a\\<inverse>\\<notin>G\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 show T1: \"a\\<noteq>\\<one>\" using PositiveSet_def by auto\n  { assume \"a\\<inverse> \\<in> G\\<^sub>+\" \n    with A1 have \"a\\<lsq>\\<one>\"  \"\\<one>\\<lsq>a\"\n      using OrderedGroup_ZF_1_L5AA PositiveSet_def by auto\n    then have \"a=\\<one>\" by (rule group_order_antisym)\n    with T1 have False by simp\n  } then show \"a\\<inverse>\\<notin>G\\<^sub>+\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1420
    },
    "1275": {
        "type": "lemma",
        "text": "text\\<open>If $a^{-1}$ is positive, then $a$ can not be positive or the unit.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"a\\<inverse>\\<in>G\\<^sub>+\" ",
        "using": [
            "OrderedGroup_ZF_1_L15",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L8C",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L16:\n  assumes A1: \"a\\<in>G\" and A2: \"a\\<inverse>\\<in>G\\<^sub>+\" shows \"a\\<noteq>\\<one>\"  \"a\\<notin>G\\<^sub>+\"\n",
        "proof": "proof -\n  from A2 have \"a\\<inverse>\\<noteq>\\<one>\"  \"(a\\<inverse>)\\<inverse> \\<notin> G\\<^sub>+\"\n    using OrderedGroup_ZF_1_L15 by auto\n  with A1 show \"a\\<noteq>\\<one>\"  \"a\\<notin>G\\<^sub>+\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L8C group0.group_inv_of_inv \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1421
    },
    "1276": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered groups each element is either the unit, \n  positive or its inverse is positive.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \n  ",
        "using": [
            "OrderedGroup_ZF_1_L14",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_one",
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L15",
            "OrderedGroup_ZF_1_L16"
        ],
        "statement": "lemma (in group3) OrdGroup_decomp: \n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \n  shows \"Exactly_1_of_3_holds (a=\\<one>,a\\<in>G\\<^sub>+,a\\<inverse>\\<in>G\\<^sub>+)\"\n",
        "proof": "proof -\n  from A1 A2 have \"a=\\<one> \\<or> a\\<in>G\\<^sub>+ \\<or> a\\<inverse>\\<in>G\\<^sub>+\"\n    using OrderedGroup_ZF_1_L14 by simp\n  moreover from A2 have \"a=\\<one> \\<longrightarrow> (a\\<notin>G\\<^sub>+ \\<and> a\\<inverse>\\<notin>G\\<^sub>+)\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_one\n    PositiveSet_def by simp\n  moreover from A2 have \"a\\<in>G\\<^sub>+ \\<longrightarrow> (a\\<noteq>\\<one> \\<and> a\\<inverse>\\<notin>G\\<^sub>+)\"\n    using OrderedGroup_ZF_1_L15 by simp\n  moreover from A2 have \"a\\<inverse>\\<in>G\\<^sub>+ \\<longrightarrow> (a\\<noteq>\\<one> \\<and> a\\<notin>G\\<^sub>+)\"\n    using OrderedGroup_ZF_1_L16 by simp\n  ultimately show \"Exactly_1_of_3_holds (a=\\<one>,a\\<in>G\\<^sub>+,a\\<inverse>\\<in>G\\<^sub>+)\"\n    by (rule Fol1_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1422
    },
    "1277": {
        "type": "lemma",
        "text": "text\\<open>A if $a$ is a nonunit element that is not positive, then $a^{-1}$ is \n  is positive. This is useful for some proofs by cases.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \n  and A3: \"a\\<noteq>\\<one>\"  \"a\\<notin>G\\<^sub>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L14"
        ],
        "statement": "lemma (in group3) OrdGroup_cases:\n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \n  and A3: \"a\\<noteq>\\<one>\"  \"a\\<notin>G\\<^sub>+\"\n  shows \"a\\<inverse> \\<in> G\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \"a=\\<one> \\<or> a\\<in>G\\<^sub>+ \\<or> a\\<inverse>\\<in>G\\<^sub>+\"\n    using OrderedGroup_ZF_1_L14 by simp\n  with A3 show \"a\\<inverse> \\<in> G\\<^sub>+\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1423
    },
    "1278": {
        "type": "lemma",
        "text": "text\\<open>Elements from $G\\setminus G_+$ are not greater that the unit.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a \\<in> G-G\\<^sub>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L3",
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L8A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L17:\n  assumes A1: \"r {is total on} G\" and A2: \"a \\<in> G-G\\<^sub>+\"\n  shows \"a\\<lsq>\\<one>\"\n",
        "proof": "proof -\n  { assume \"a=\\<one>\"\n    with A2 have \"a\\<lsq>\\<one>\" using OrderedGroup_ZF_1_L3 by simp }\n  moreover\n  { assume \"a\\<noteq>\\<one>\"\n    with A1 A2 have \"a\\<lsq>\\<one>\" \n      using PositiveSet_def OrderedGroup_ZF_1_L8A\n      by auto }\n  ultimately show \"a\\<lsq>\\<one>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1424
    },
    "1279": {
        "type": "lemma",
        "text": "text\\<open>The next lemma allows to split proofs that something holds \n  for all $a\\in G$ into cases $a=1$, $a\\in G_+$, $-a\\in G_+$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"b\\<in>G\"\n  and A3: \"Q(\\<one>)\" and A4: \"\\<forall>a\\<in>G\\<^sub>+. Q(a)\" and A5: \"\\<forall>a\\<in>G\\<^sub>+. Q(a\\<inverse>)\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L14",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L18: \n  assumes A1: \"r {is total on} G\" and A2: \"b\\<in>G\"\n  and A3: \"Q(\\<one>)\" and A4: \"\\<forall>a\\<in>G\\<^sub>+. Q(a)\" and A5: \"\\<forall>a\\<in>G\\<^sub>+. Q(a\\<inverse>)\"\n  shows \"Q(b)\"\n",
        "proof": "proof -\n  from A1 A2 A3 A4 A5 have \"Q(b) \\<or> Q((b\\<inverse>)\\<inverse>)\"\n    using OrderedGroup_ZF_1_L14 by auto\n  with A2 show \"Q(b)\" using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1425
    },
    "1280": {
        "type": "lemma",
        "text": "text\\<open>All elements greater or equal than an element of \\<open>G\\<^sub>+\\<close>\n  belong to \\<open>G\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> G\\<^sub>+\" and A2: \"a\\<lsq>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L2A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L19:\n  assumes A1: \"a \\<in> G\\<^sub>+\" and A2: \"a\\<lsq>b\"\n  shows \"b \\<in> G\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 have I: \"\\<one>\\<lsq>a\"  and II: \"a\\<noteq>\\<one>\"\n    using OrderedGroup_ZF_1_L2A by auto\n  from I A2 have \"\\<one>\\<lsq>b\" by (rule Group_order_transitive)\n  moreover have \"b\\<noteq>\\<one>\"\n  proof -\n    { assume \"b=\\<one>\"\n      with I A2 have \"\\<one>\\<lsq>a\"  \"a\\<lsq>\\<one>\"\n\tby auto\n      then have \"\\<one>=a\" by (rule group_order_antisym)\n      with II have False by simp\n    } then show \"b\\<noteq>\\<one>\" by auto\n  qed\n  ultimately show \"b \\<in> G\\<^sub>+\" \n    using OrderedGroup_ZF_1_L2A by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1426
    },
    "1281": {
        "type": "lemma",
        "text": "text\\<open>The inverse of an element of \\<open>G\\<^sub>+\\<close> cannot be in \\<open>G\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a \\<in> G\\<^sub>+\" \n  ",
        "using": [
            "PositiveSet_def",
            "OrdGroup_decomp"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L20:\n  assumes A1: \"r {is total on} G\" and A2: \"a \\<in> G\\<^sub>+\" \n  shows \"a\\<inverse> \\<notin> G\\<^sub>+\"\n",
        "proof": "proof -\n  from A2 have \"a\\<in>G\" using PositiveSet_def\n    by simp\n  with A1 have \"Exactly_1_of_3_holds (a=\\<one>,a\\<in>G\\<^sub>+,a\\<inverse>\\<in>G\\<^sub>+)\"\n    using OrdGroup_decomp by simp\n  with A2 show \"a\\<inverse> \\<notin> G\\<^sub>+\" by (rule Fol1_L7)\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1427
    },
    "1282": {
        "type": "lemma",
        "text": "text\\<open>The set of positive elements of a \n  nontrivial linearly ordered group is not empty.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L14"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L21:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  shows \"G\\<^sub>+ \\<noteq> 0\"\n",
        "proof": "proof -\n  have \"\\<one> \\<in> G\" using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by simp\n  with A2 obtain a where \"a\\<in>G\"  \"a\\<noteq>\\<one>\" by auto\n  with A1 have \"a\\<in>G\\<^sub>+ \\<or> a\\<inverse>\\<in>G\\<^sub>+\" \n    using OrderedGroup_ZF_1_L14 by auto\n  then show \"G\\<^sub>+ \\<noteq> 0\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1428
    },
    "1283": {
        "type": "lemma",
        "text": "text\\<open>If $b\\in$\\<open>G\\<^sub>+\\<close>, then $a < a\\cdot b$. \n  Multiplying $a$ by a positive elemnt increases $a$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\\<^sub>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L2A",
            "IsAnOrdGroup_def",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L4",
            "PositiveSet_def",
            "group0.group0_2_L7"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L22:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\\<^sub>+\"\n  shows \"a\\<lsq>a\\<cdot>b\"  \"a \\<noteq> a\\<cdot>b\"  \"a\\<cdot>b \\<in> G\"\n",
        "proof": "proof -\n  from ordGroupAssum A1 have \"a\\<cdot>\\<one> \\<lsq> a\\<cdot>b\"\n    using OrderedGroup_ZF_1_L2A IsAnOrdGroup_def\n    by simp\n  with A1 show \"a\\<lsq>a\\<cdot>b\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by simp\n  then show \"a\\<cdot>b \\<in> G\"\n    using OrderedGroup_ZF_1_L4 by simp\n  { from A1 have \"a\\<in>G\"  \"b\\<in>G\"  \n      using PositiveSet_def by auto\n    moreover assume \"a = a\\<cdot>b\"\n    ultimately have \"b = \\<one>\"\n      using OrderedGroup_ZF_1_L1 group0.group0_2_L7\n      by simp\n    with A1 have False using PositiveSet_def\n      by simp\n  } then show \"a \\<noteq> a\\<cdot>b\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1429
    },
    "1284": {
        "type": "lemma",
        "text": "text\\<open>If $G$ is a nontrivial linearly ordered hroup, \n  then for every element of $G$ we can find one in \\<open>G\\<^sub>+\\<close> that is\n  greater or equal.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  and A3: \"a\\<in>G\"\n  ",
        "using": [
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L3",
            "OrderedGroup_ZF_1_L17",
            "OrderedGroup_ZF_1_L21"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L23: \n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  and A3: \"a\\<in>G\"\n  shows \"\\<exists>b\\<in>G\\<^sub>+. a\\<lsq>b\"\n",
        "proof": "proof -\n  { assume A4: \"a\\<in>G\\<^sub>+\" then have \"a\\<lsq>a\"\n      using PositiveSet_def OrderedGroup_ZF_1_L3\n      by simp\n    with A4 have \"\\<exists>b\\<in>G\\<^sub>+. a\\<lsq>b\" by auto }\n  moreover\n  { assume \"a\\<notin>G\\<^sub>+\"\n    with A1 A3 have I: \"a\\<lsq>\\<one>\" using OrderedGroup_ZF_1_L17\n      by simp\n    from A1 A2 obtain b where II: \"b\\<in>G\\<^sub>+\" \n      using OrderedGroup_ZF_1_L21 by auto\n    then have \"\\<one>\\<lsq>b\" using PositiveSet_def by simp\n    with I have \"a\\<lsq>b\" by (rule Group_order_transitive)\n    with II have \"\\<exists>b\\<in>G\\<^sub>+. a\\<lsq>b\" by auto }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1430
    },
    "1285": {
        "type": "lemma",
        "text": "text\\<open>If the inverse of $a$ is in \\<open>G\\<^sub>+\\<close>, then $a$ is in the inverse\n  of \\<open>G\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"a\\<inverse> \\<in> G\\<^sub>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group_inv_of_inv",
            "OrderedGroup_ZF_1_L25"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L26:\n  assumes A1: \"a\\<in>G\" and A2: \"a\\<inverse> \\<in> G\\<^sub>+\"\n  shows \"a \\<in> (\\<sm>G\\<^sub>+)\"\n",
        "proof": "proof -\n  from A1 have \"a\\<inverse> \\<in> G\"  \"a = (a\\<inverse>)\\<inverse>\" using OrderedGroup_ZF_1_L1 \n    group0.inverse_in_group group0.group_inv_of_inv\n    by auto\n  with A2 show \"a \\<in> (\\<sm>G\\<^sub>+)\" using OrderedGroup_ZF_1_L25\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1432
    },
    "1286": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is in the inverse of  \\<open>G\\<^sub>+\\<close>, \n  then its inverse is in $G_+$.\\<close>\n",
        "assumes": "assumes \"a \\<in> (\\<sm>G\\<^sub>+)\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_1_L25",
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L27:\n  assumes \"a \\<in> (\\<sm>G\\<^sub>+)\"\n  shows \"a\\<inverse> \\<in> G\\<^sub>+\"\n  ",
        "proof": "using assms OrderedGroup_ZF_1_L25 PositiveSet_def \n    OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1433
    },
    "1287": {
        "type": "lemma",
        "text": "text\\<open>If $a\\cdot b^{-1}$ is nonnegative, then $b \\leq a$. This maybe used to\n  recover the order from the set of nonnegative elements and serve as a way\n  to define order by prescibing that set (see the \"Alternative definitions\"\n  section).\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<in> G\\<^sup>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_1_L5K"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L28:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<in> G\\<^sup>+\"\n  shows \"b\\<lsq>a\"\n",
        "proof": "proof -\n  from A2 have \"\\<one> \\<lsq> a\\<cdot>b\\<inverse>\" using OrderedGroup_ZF_1_L2\n    by simp\n  with A1 show \"b\\<lsq>a\" using OrderedGroup_ZF_1_L5K\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1435
    },
    "1288": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>OrderedGroup_ZF_1_L28\\<close> when\n  $a\\cdot b^{-1}$ is positive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<in> G\\<^sub>+\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L2A",
            "OrderedGroup_ZF_1_L5K",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L6"
        ],
        "statement": "corollary (in group3) OrderedGroup_ZF_1_L29:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\" and A2: \"a\\<cdot>b\\<inverse> \\<in> G\\<^sub>+\"\n  shows \"b\\<lsq>a\"  \"b\\<noteq>a\"\n",
        "proof": "proof -\n  from A2 have \"\\<one> \\<lsq> a\\<cdot>b\\<inverse>\" and I: \"a\\<cdot>b\\<inverse> \\<noteq> \\<one>\"\n    using OrderedGroup_ZF_1_L2A by auto\n  with A1 show \"b\\<lsq>a\" using OrderedGroup_ZF_1_L5K\n    by simp\n  from A1 I show \"b\\<noteq>a\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L6\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1436
    },
    "1289": {
        "type": "lemma",
        "text": "text\\<open>A bit stronger that \\<open>OrderedGroup_ZF_1_L29\\<close>, adds\n   case when two elements are equal.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" and \"a=b \\<or> b\\<cdot>a\\<inverse> \\<in> G\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_1_L3",
            "OrderedGroup_ZF_1_L29"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L30:\n  assumes \"a\\<in>G\"  \"b\\<in>G\" and \"a=b \\<or> b\\<cdot>a\\<inverse> \\<in> G\\<^sub>+\"\n  shows \"a\\<lsq>b\"\n  ",
        "proof": "using assms OrderedGroup_ZF_1_L3 OrderedGroup_ZF_1_L29\n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1437
    },
    "1290": {
        "type": "lemma",
        "text": "text\\<open>A different take on decomposition: we can have $a=b$ or $a<b$\n  or $b<a$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group_op_closed",
            "OrderedGroup_ZF_1_L14",
            "group0.inv_cancel_two",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L29",
            "group0.group0_2_L12"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L31: \n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a=b \\<or> (a\\<lsq>b \\<and> a\\<noteq>b) \\<or> (b\\<lsq>a \\<and> b\\<noteq>a)\"\n",
        "proof": "proof -\n  from A2 have \"a\\<cdot>b\\<inverse> \\<in> G\" using OrderedGroup_ZF_1_L1\n    group0.inverse_in_group group0.group_op_closed\n    by simp\n  with A1 have \"a\\<cdot>b\\<inverse> = \\<one> \\<or> a\\<cdot>b\\<inverse> \\<in> G\\<^sub>+ \\<or> (a\\<cdot>b\\<inverse>)\\<inverse> \\<in> G\\<^sub>+\"\n    using OrderedGroup_ZF_1_L14 by simp\n  moreover\n  { assume \"a\\<cdot>b\\<inverse> = \\<one>\"\n    then have \"a\\<cdot>b\\<inverse>\\<cdot>b = \\<one>\\<cdot>b\" by simp\n    with A2 have \"a=b \\<or> (a\\<lsq>b \\<and> a\\<noteq>b) \\<or> (b\\<lsq>a \\<and> b\\<noteq>a)\"\n      using OrderedGroup_ZF_1_L1\n\tgroup0.inv_cancel_two group0.group0_2_L2 by auto }\n  moreover\n  { assume \"a\\<cdot>b\\<inverse> \\<in> G\\<^sub>+\"\n    with A2 have \"a=b \\<or> (a\\<lsq>b \\<and> a\\<noteq>b) \\<or> (b\\<lsq>a \\<and> b\\<noteq>a)\"\n      using OrderedGroup_ZF_1_L29 by auto }\n  moreover\n  { assume \"(a\\<cdot>b\\<inverse>)\\<inverse> \\<in> G\\<^sub>+\"\n    with A2 have \"b\\<cdot>a\\<inverse> \\<in> G\\<^sub>+\" using OrderedGroup_ZF_1_L1\n      group0.group0_2_L12 by simp\n    with A2 have \"a=b \\<or> (a\\<lsq>b \\<and> a\\<noteq>b) \\<or> (b\\<lsq>a \\<and> b\\<noteq>a)\"\n      using OrderedGroup_ZF_1_L29 by auto }\n  ultimately show \"a=b \\<or> (a\\<lsq>b \\<and> a\\<noteq>b) \\<or> (b\\<lsq>a \\<and> b\\<noteq>a)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1438
    },
    "1291": {
        "type": "lemma",
        "text": "text\\<open>A bounded set can be translated to put it in  $G^+$ and then it is \n still bounded above.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>g\\<in>A. L\\<lsq>g \\<and> g\\<lsq>M\"\n  and A2: \"S = RightTranslation(G,P,L\\<inverse>)\" \n  and A3: \"a \\<in> S``(A)\"\n  ",
        "using": [
            "func1_1_L13A",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group0_5_L1",
            "func_imagedef",
            "IsAnOrdGroup_def",
            "group0.group0_5_L2",
            "group0.group0_2_L6"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L1: \n  assumes A1: \"\\<forall>g\\<in>A. L\\<lsq>g \\<and> g\\<lsq>M\"\n  and A2: \"S = RightTranslation(G,P,L\\<inverse>)\" \n  and A3: \"a \\<in> S``(A)\"\n  shows \"a \\<lsq> M\\<cdot>L\\<inverse>\"   \"\\<one>\\<lsq>a\"\n",
        "proof": "proof -\n  from A3 have \"A\\<noteq>0\" using func1_1_L13A by fast\n  then obtain g where \"g\\<in>A\" by auto\n  with A1 have T1: \"L\\<in>G\" \"M\\<in>G\" \"L\\<inverse>\\<in>G\" \n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 \n    group0.inverse_in_group by auto\n  with A2 have \"S : G\\<rightarrow>G\" using OrderedGroup_ZF_1_L1 group0.group0_5_L1\n    by simp\n  moreover from A1 have T2: \"A\\<subseteq>G\" using OrderedGroup_ZF_1_L4 by auto\n  ultimately have \"S``(A) = {S`(b). b\\<in>A}\" using func_imagedef\n    by simp\n  with A3 obtain b where T3: \"b\\<in>A\" \"a = S`(b)\" by auto\n  with A1 ordGroupAssum T1 have \"b\\<cdot>L\\<inverse>\\<lsq>M\\<cdot>L\\<inverse>\" \"L\\<cdot>L\\<inverse>\\<lsq>b\\<cdot>L\\<inverse>\"\n    using IsAnOrdGroup_def by auto\n  with T3 A2 T1 T2 show \"a\\<lsq>M\\<cdot>L\\<inverse>\" \"\\<one>\\<lsq>a\"\n    using OrderedGroup_ZF_1_L1 group0.group0_5_L2 group0.group0_2_L6 \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1439
    },
    "1292": {
        "type": "lemma",
        "text": "text\\<open>Every bounded set is an image of a subset of an interval that starts at \n  $1$.\\<close>\n",
        "assumes": "assumes A1: \"IsBounded(A,r)\" \n  ",
        "using": [
            "OrderedGroup_ZF_1_L3A",
            "func1_3_L1",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "IsBounded_def",
            "IsBoundedBelow_def",
            "IsBoundedAbove_def",
            "OrderedGroup_ZF_1_L4",
            "group0.inverse_in_group",
            "Group_order_transitive",
            "IsAnOrdGroup_def",
            "group0.group0_2_L6",
            "OrderedGroup_ZF_1_L2",
            "group0.group0_5_L1",
            "group0.group0_5_L6",
            "group0.group_oper_assoc",
            "OrderedGroup_ZF_2_L1",
            "Interval_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L2:\n  assumes A1: \"IsBounded(A,r)\" \n  shows \"\\<exists>B.\\<exists>g\\<in>G\\<^sup>+.\\<exists>T\\<in>G\\<rightarrow>G. A = T``(B) \\<and> B \\<subseteq> Interval(r,\\<one>,g)\"\n",
        "proof": "proof - \n  { assume A2: \"A=0\" \n    let ?B = \"0\"\n    let ?g = \"\\<one>\"\n    let ?T = \"ConstantFunction(G,\\<one>)\"\n    have \"?g\\<in>G\\<^sup>+\" using OrderedGroup_ZF_1_L3A by simp\n    moreover have \"?T : G\\<rightarrow>G\"\n      using func1_3_L1 OrderedGroup_ZF_1_L1 group0.group0_2_L2 by simp\n    moreover from A2 have \"A = T``(?B)\" by simp\n    moreover have \"?B \\<subseteq> Interval(r,\\<one>,?g)\" by simp\n    ultimately have\n      \"\\<exists>B.\\<exists>g\\<in>G\\<^sup>+.\\<exists>T\\<in>G\\<rightarrow>G. A = T``(B) \\<and> B \\<subseteq> Interval(r,\\<one>,g)\"\n      by auto }\n  moreover\n  { assume A3: \"A\\<noteq>0\"\n    with A1 have \"\\<exists>L. \\<forall>x\\<in>A. L\\<lsq>x\" and \"\\<exists>U. \\<forall>x\\<in>A. x\\<lsq>U\"\n      using IsBounded_def IsBoundedBelow_def IsBoundedAbove_def \n      by auto\n    then obtain L U where D1: \"\\<forall>x\\<in>A. L\\<lsq>x \\<and> x\\<lsq>U \"\n      by auto\n    with A3 have T1: \"A\\<subseteq>G\" using OrderedGroup_ZF_1_L4 by auto\n    from A3 obtain a where \"a\\<in>A\" by auto\n    with D1 have T2: \"L\\<lsq>a\" \"a\\<lsq>U\" by auto\n    then have T3: \"L\\<in>G\" \"L\\<inverse>\\<in> G\" \"U\\<in>G\" \n      using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 \n\tgroup0.inverse_in_group by auto\n    let ?T = \"RightTranslation(G,P,L)\"\n    let ?B = \"RightTranslation(G,P,L\\<inverse>)``(A)\"\n    let ?g = \"U\\<cdot>L\\<inverse>\"\n    have \"?g\\<in>G\\<^sup>+\"\n    proof -\n      from T2 have \"L\\<lsq>U\" using Group_order_transitive by fast\n      with ordGroupAssum T3 have \"L\\<cdot>L\\<inverse>\\<lsq>?g\" \n\tusing IsAnOrdGroup_def by simp\n      with T3 show ?thesis using OrderedGroup_ZF_1_L1 group0.group0_2_L6\n\tOrderedGroup_ZF_1_L2 by simp\n    qed\n    moreover from T3 have \"?T : G\\<rightarrow>G\"\n      using OrderedGroup_ZF_1_L1 group0.group0_5_L1\n      by simp\n    moreover have \"A = ?T``(?B)\"\n    proof -\n      from T3 T1 have \"?T``(?B) = {a\\<cdot>L\\<inverse>\\<cdot>L. a\\<in>A}\"\n\tusing OrderedGroup_ZF_1_L1 group0.group0_5_L6\n\tby simp\n      moreover from T3 T1 have \"\\<forall>a\\<in>A. a\\<cdot>L\\<inverse>\\<cdot>L = a\\<cdot>(L\\<inverse>\\<cdot>L)\"\n\tusing OrderedGroup_ZF_1_L1 group0.group_oper_assoc by auto\n      ultimately have \"?T``(?B) = {a\\<cdot>(L\\<inverse>\\<cdot>L). a\\<in>A}\" by simp\n      with T3 have \"?T``(?B) = {a\\<cdot>\\<one>. a\\<in>A}\"\n\tusing OrderedGroup_ZF_1_L1 group0.group0_2_L6 by simp\n      moreover from T1 have \"\\<forall>a\\<in>A. a\\<cdot>\\<one>=a\"\n\tusing OrderedGroup_ZF_1_L1 group0.group0_2_L2 by auto\n      ultimately show ?thesis by simp\n    qed\n    moreover have \"?B \\<subseteq> Interval(r,\\<one>,?g)\"\n    proof\n      fix y assume A4: \"y \\<in> ?B\"\n      let ?S = \"RightTranslation(G,P,L\\<inverse>)\"\n      from D1 have T4: \"\\<forall>x\\<in>A. L\\<lsq>x \\<and> x\\<lsq>U\" by simp\n      moreover have T5: \"?S = RightTranslation(G,P,L\\<inverse>)\" \n\tby simp \n      moreover from A4 have T6: \"y \\<in> ?S``(A)\" by simp\n      ultimately have \"y\\<lsq>U\\<cdot>L\\<inverse>\" using OrderedGroup_ZF_2_L1\n\tby blast\n      moreover from T4 T5 T6 have \"\\<one>\\<lsq>y\" by (rule OrderedGroup_ZF_2_L1)\n      ultimately show \"y \\<in> Interval(r,\\<one>,?g)\" using Interval_def by auto\n    qed\n    ultimately have\n      \"\\<exists>B.\\<exists>g\\<in>G\\<^sup>+.\\<exists>T\\<in>G\\<rightarrow>G. A = T``(B) \\<and> B \\<subseteq> Interval(r,\\<one>,g)\"\n      by auto }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1440
    },
    "1293": {
        "type": "theorem",
        "text": "text\\<open>If every interval starting at $1$ is finite, then every bounded set is \n  finite. I find it interesting that this does not require the group to be \n  linearly ordered (the order to be total).\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>g\\<in>G\\<^sup>+. Interval(r,\\<one>,g) \\<in> Fin(G)\"\n  and A2: \"IsBounded(A,r)\" \n  ",
        "using": [
            "OrderedGroup_ZF_2_L2",
            "Fin_subset_lemma",
            "Finite1_L6A"
        ],
        "statement": "theorem (in group3) OrderedGroup_ZF_2_T1:\n  assumes A1: \"\\<forall>g\\<in>G\\<^sup>+. Interval(r,\\<one>,g) \\<in> Fin(G)\"\n  and A2: \"IsBounded(A,r)\" \n  shows \"A \\<in> Fin(G)\"\n",
        "proof": "proof -\n  from A2 have\n    \"\\<exists>B.\\<exists>g\\<in>G\\<^sup>+.\\<exists>T\\<in>G\\<rightarrow>G. A = T``(B) \\<and> B \\<subseteq> Interval(r,\\<one>,g)\"\n    using OrderedGroup_ZF_2_L2 by simp\n  then obtain B g T where D1: \"g\\<in>G\\<^sup>+\" \"B \\<subseteq> Interval(r,\\<one>,g)\" \n    and D2: \"T : G\\<rightarrow>G\" \"A = T``(B)\" by auto\n  from D1 A1 have \"B\\<in>Fin(G)\" using Fin_subset_lemma by blast\n  with D2 show ?thesis using Finite1_L6A by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1441
    },
    "1294": {
        "type": "theorem",
        "text": "text\\<open>In linearly ordered groups finite sets are bounded.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\" and \"B\\<in>Fin(G)\" \n  ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "Finite_ZF_1_T1"
        ],
        "statement": "theorem (in group3) ord_group_fin_bounded:\n  assumes \"r {is total on} G\" and \"B\\<in>Fin(G)\" \n  shows \"IsBounded(B,r)\"\n  ",
        "proof": "using ordGroupAssum assms IsAnOrdGroup_def IsPartOrder_def Finite_ZF_1_T1\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1442
    },
    "1295": {
        "type": "lemma",
        "text": "text\\<open>For nontrivial linearly ordered groups  if for every element $G$ \n  we can find one in $A$ \n  that is greater or equal (not necessarily strictly greater), then $A$\n  can neither be finite nor bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  and A3: \"\\<forall>a\\<in>G. \\<exists>b\\<in>A. a\\<lsq>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L21",
            "OrderedGroup_ZF_1_L22",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "OrderedGroup_ZF_1_L1A",
            "Order_ZF_3_L14",
            "Finite_ZF_1_1_L3"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L2A:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  and A3: \"\\<forall>a\\<in>G. \\<exists>b\\<in>A. a\\<lsq>b\"\n  shows \n  \"\\<forall>a\\<in>G. \\<exists>b\\<in>A. a\\<noteq>b \\<and> a\\<lsq>b\"\n  \"\\<not>IsBoundedAbove(A,r)\"\n  \"A \\<notin> Fin(G)\"\n",
        "proof": "proof -\n  { fix a\n    from A1 A2 obtain c where \"c \\<in> G\\<^sub>+\"\n      using OrderedGroup_ZF_1_L21 by auto\n    moreover assume \"a\\<in>G\"\n    ultimately have \n      \"a\\<cdot>c \\<in> G\"  and I: \"a \\<ls> a\\<cdot>c\"\n      using OrderedGroup_ZF_1_L22 by auto\n    with A3 obtain b where II: \"b\\<in>A\"  and III: \"a\\<cdot>c \\<lsq> b\"\n      by auto\n    moreover from I III have \"a\\<ls>b\" by (rule OrderedGroup_ZF_1_L4A)\n    ultimately have \"\\<exists>b\\<in>A. a\\<noteq>b \\<and> a\\<lsq>b\" by auto\n  } thus \"\\<forall>a\\<in>G. \\<exists>b\\<in>A. a\\<noteq>b \\<and> a\\<lsq>b\" by simp\n  with ordGroupAssum A1 show \n    \"\\<not>IsBoundedAbove(A,r)\"\n    \"A \\<notin> Fin(G)\"\n    using IsAnOrdGroup_def IsPartOrder_def \n    OrderedGroup_ZF_1_L1A Order_ZF_3_L14 Finite_ZF_1_1_L3\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1443
    },
    "1296": {
        "type": "theorem",
        "text": "text\\<open>Nontrivial linearly ordered groups are infinite. Recall \n  that \\<open>Fin(A)\\<close> is the collection of finite subsets of $A$. \n  In this lemma we show that $G\\notin$ \\<open>Fin(G)\\<close>, that is that\n  $G$ is not a finite subset of itself. This is a way of saying that $G$ \n  is infinite. We also show that for nontrivial linearly ordered groups \n  \\<open>G\\<^sub>+\\<close> is infinite.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L23",
            "OrderedGroup_ZF_2_L2A",
            "PositiveSet_def",
            "Fin_subset_lemma"
        ],
        "statement": "theorem (in group3) Linord_group_infinite:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\"\n  shows \n  \"G\\<^sub>+ \\<notin> Fin(G)\"\n  \"G \\<notin> Fin(G)\"\n",
        "proof": "proof -\n  from A1 A2 show I: \"G\\<^sub>+ \\<notin> Fin(G)\"\n    using OrderedGroup_ZF_1_L23 OrderedGroup_ZF_2_L2A\n    by simp\n  { assume \"G \\<in> Fin(G)\"\n    moreover have \"G\\<^sub>+ \\<subseteq> G\" using PositiveSet_def by auto\n    ultimately have \"G\\<^sub>+ \\<in> Fin(G)\" using Fin_subset_lemma\n      by blast\n    with I have False by simp\n  } then show \"G \\<notin> Fin(G)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1444
    },
    "1297": {
        "type": "lemma",
        "text": "text\\<open>A property of nonempty subsets of linearly ordered groups that don't\n  have a maximum: for any element in such subset we can find one that\n  is strictly greater.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"A\\<subseteq>G\" and \n  A3: \"\\<not>HasAmaximum(r,A)\" and A4: \"x\\<in>A\"\n  ",
        "using": [
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "Order_ZF_4_L16"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L2B:\n  assumes A1: \"r {is total on} G\" and A2: \"A\\<subseteq>G\" and \n  A3: \"\\<not>HasAmaximum(r,A)\" and A4: \"x\\<in>A\"\n  shows \"\\<exists>y\\<in>A. x\\<ls>y\"\n",
        "proof": "proof -\n  from ordGroupAssum assms have\n    \"antisym(r)\"\n    \"r {is total on} G\"\n    \"A\\<subseteq>G\"  \"\\<not>HasAmaximum(r,A)\"  \"x\\<in>A\"\n    using IsAnOrdGroup_def IsPartOrder_def\n    by auto\n  then have \"\\<exists>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> r \\<and> y\\<noteq>x\"\n    using Order_ZF_4_L16 by simp\n  then show \"\\<exists>y\\<in>A. x\\<ls>y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1445
    },
    "1298": {
        "type": "lemma",
        "text": "text\\<open>In linearly ordered groups $G\\setminus G_+$ is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" ",
        "using": [
            "OrderedGroup_ZF_1_L17",
            "IsBoundedAbove_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L3:\n  assumes A1: \"r {is total on} G\" shows \"IsBoundedAbove(G-G\\<^sub>+,r)\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>a\\<in>G-G\\<^sub>+. a\\<lsq>\\<one>\"\n    using OrderedGroup_ZF_1_L17 by simp\n  then show \"IsBoundedAbove(G-G\\<^sub>+,r)\" \n    using IsBoundedAbove_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1446
    },
    "1299": {
        "type": "lemma",
        "text": "text\\<open>In linearly ordered groups if $A\\cap G_+$ is finite, \n  then $A$ is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"A\\<subseteq>G\" \n  and A3: \"A \\<inter> G\\<^sub>+ \\<in> Fin(G)\"\n  ",
        "using": [
            "OrderedGroup_ZF_2_L3",
            "Order_ZF_3_L13",
            "ord_group_fin_bounded",
            "IsBounded_def",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "Order_ZF_3_L3"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L4:\n  assumes A1: \"r {is total on} G\" and A2: \"A\\<subseteq>G\" \n  and A3: \"A \\<inter> G\\<^sub>+ \\<in> Fin(G)\"\n  shows \"IsBoundedAbove(A,r)\"\n",
        "proof": "proof -\n  have \"A \\<inter> (G-G\\<^sub>+) \\<subseteq> G-G\\<^sub>+\" by auto\n  with A1 have \"IsBoundedAbove(A \\<inter> (G-G\\<^sub>+),r)\"\n    using OrderedGroup_ZF_2_L3 Order_ZF_3_L13\n    by blast\n  moreover from A1 A3 have \"IsBoundedAbove(A \\<inter> G\\<^sub>+,r)\"\n    using ord_group_fin_bounded IsBounded_def \n    by simp\n  moreover from A1 ordGroupAssum have\n    \"r {is total on} G\"  \"trans(r)\"  \"r\\<subseteq>G\\<times>G\"\n    using IsAnOrdGroup_def IsPartOrder_def by auto\n  ultimately have \"IsBoundedAbove(A \\<inter> (G-G\\<^sub>+) \\<union> A \\<inter> G\\<^sub>+,r)\"\n    using Order_ZF_3_L3 by simp\n  moreover from A2 have \"A = A \\<inter> (G-G\\<^sub>+) \\<union> A \\<inter> G\\<^sub>+\"\n    by auto\n  ultimately show  \"IsBoundedAbove(A,r)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1447
    },
    "1300": {
        "type": "lemma",
        "text": "text\\<open>If a set $-A\\subseteq G$ is bounded above, then $A$ is bounded below.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>G\" and A2: \"IsBoundedAbove(\\<sm>A,r)\"\n  ",
        "using": [
            "IsBoundedBelow_def",
            "IsAnOrdGroup_def",
            "group0_2_T2",
            "func1_1_L15A",
            "IsBoundedAbove_def",
            "func_imagedef",
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv",
            "Order_ZF_3_L9"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L5:\n  assumes A1: \"A\\<subseteq>G\" and A2: \"IsBoundedAbove(\\<sm>A,r)\"\n  shows \"IsBoundedBelow(A,r)\"\n",
        "proof": "proof -\n  { assume \"A = 0\" then have \"IsBoundedBelow(A,r)\"\n      using IsBoundedBelow_def by auto }\n  moreover\n  { assume A3: \"A\\<noteq>0\"\n    from ordGroupAssum have I: \"GroupInv(G,P) : G\\<rightarrow>G\"\n      using IsAnOrdGroup_def group0_2_T2 by simp\n    with A1 A2 A3 obtain u where D: \"\\<forall>a\\<in>(\\<sm>A). a\\<lsq>u\"\n      using func1_1_L15A IsBoundedAbove_def by auto\n    { fix b assume \"b\\<in>A\"\n      with A1 I D have \"b\\<inverse> \\<lsq> u\" and T: \"b\\<in>G\"\n\tusing func_imagedef by auto\n      then have \"u\\<inverse>\\<lsq>(b\\<inverse>)\\<inverse>\" using OrderedGroup_ZF_1_L5\n\tby simp\n      with T have \"u\\<inverse>\\<lsq>b\"\n\tusing OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n\tby simp\n    } then have \"\\<forall>b\\<in>A. \\<langle>u\\<inverse>,b\\<rangle> \\<in> r\" by simp\n    then have \"IsBoundedBelow(A,r)\"\n      using Order_ZF_3_L9 by blast }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1448
    },
    "1301": {
        "type": "lemma",
        "text": "text\\<open>If $a\\leq b$, then the image of the interval $a..b$ by any function is\n  nonempty.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"f:G\\<rightarrow>G\"\n  ",
        "using": [
            "ordGroupAssum",
            "assms",
            "OrderedGroup_ZF_1_L4",
            "Order_ZF_2_L6",
            "Order_ZF_2_L2A",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "func1_1_L15A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_2_L6: \n  assumes \"a\\<lsq>b\" and \"f:G\\<rightarrow>G\"\n  shows \"f``(Interval(r,a,b)) \\<noteq> 0\"\n  ",
        "proof": "using ordGroupAssum assms OrderedGroup_ZF_1_L4 \n    Order_ZF_2_L6 Order_ZF_2_L2A \n    IsAnOrdGroup_def IsPartOrder_def func1_1_L15A\n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1449
    },
    "1302": {
        "type": "lemma",
        "text": "text\\<open>If $a\\in G^+$, then $|a| = a$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\\<^sup>+\" ",
        "using": [
            "IsAnOrdGroup_def",
            "group0_2_T2",
            "func1_1_L1",
            "OrderedGroup_ZF_1_L4E",
            "fun_disjoint_apply1",
            "AbsoluteValue_def",
            "id_conv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L2:\n  assumes A1: \"a\\<in>G\\<^sup>+\" shows \"\\<bar>a\\<bar> = a\"\n",
        "proof": "proof -\n  from ordGroupAssum have \"GroupInv(G,P) : G\\<rightarrow>G\"\n    using IsAnOrdGroup_def group0_2_T2 by simp\n  with A1 show ?thesis using\n    func1_1_L1 OrderedGroup_ZF_1_L4E fun_disjoint_apply1\n    AbsoluteValue_def id_conv by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1451
    },
    "1303": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is positive, then $|a| = a$.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\\<^sub>+\" ",
        "using": [
            "assms",
            "PositiveSet_def",
            "Nonnegative_def",
            "OrderedGroup_ZF_3_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L2B:\n  assumes \"a\\<in>G\\<^sub>+\" shows \"\\<bar>a\\<bar> = a\"\n  ",
        "proof": "using assms PositiveSet_def Nonnegative_def OrderedGroup_ZF_3_L2\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1453
    },
    "1304": {
        "type": "lemma",
        "text": "text\\<open>If $a\\in G\\setminus G^+$, then $|a| = a^{-1}$.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> G-G\\<^sup>+\" ",
        "using": [
            "id_type",
            "func1_1_L1",
            "fun_disjoint_apply2",
            "AbsoluteValue_def",
            "restrict"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L3:\n   assumes A1: \"a \\<in> G-G\\<^sup>+\" shows \"\\<bar>a\\<bar> = a\\<inverse>\"\n",
        "proof": "proof -\n  have \"domain(id(G\\<^sup>+)) = G\\<^sup>+\"\n    using id_type func1_1_L1 by auto\n  with A1 show ?thesis using fun_disjoint_apply2 AbsoluteValue_def\n    restrict by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1454
    },
    "1305": {
        "type": "lemma",
        "text": "text\\<open>For elements that not greater than the unit, the absolute value is\n  the inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>\\<one>\" \n  ",
        "using": [
            "OrderedGroup_ZF_3_L2A",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_one",
            "OrderedGroup_ZF_1_L4C",
            "OrderedGroup_ZF_3_L3"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L3A:\n  assumes A1: \"a\\<lsq>\\<one>\" \n  shows \"\\<bar>a\\<bar> = a\\<inverse>\"\n",
        "proof": "proof -\n  { assume \"a=\\<one>\" then have \"\\<bar>a\\<bar> = a\\<inverse>\" \n      using OrderedGroup_ZF_3_L2A OrderedGroup_ZF_1_L1 group0.group_inv_of_one\n      by simp }\n  moreover\n  { assume \"a\\<noteq>\\<one>\" \n    with A1 have \"\\<bar>a\\<bar> = a\\<inverse>\" using OrderedGroup_ZF_1_L4C OrderedGroup_ZF_3_L3\n      by simp }\n  ultimately show \"\\<bar>a\\<bar> = a\\<inverse>\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1455
    },
    "1306": {
        "type": "lemma",
        "text": "text\\<open>In linearly ordered groups the absolute value of any element \n  is in $G^+$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L2",
            "OrderedGroup_ZF_3_L3",
            "OrderedGroup_ZF_1_L6"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L3B: \n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"\n  shows \"\\<bar>a\\<bar> \\<in> G\\<^sup>+\"\n",
        "proof": "proof -\n  { assume \"a \\<in> G\\<^sup>+\" then have \"\\<bar>a\\<bar> \\<in> G\\<^sup>+\" \n      using OrderedGroup_ZF_3_L2 by simp }\n  moreover\n  { assume \"a \\<notin> G\\<^sup>+\" \n    with A1 A2 have \"\\<bar>a\\<bar> \\<in> G\\<^sup>+\" using OrderedGroup_ZF_3_L3\n      OrderedGroup_ZF_1_L6 by simp }\n  ultimately show \"\\<bar>a\\<bar> \\<in> G\\<^sup>+\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1456
    },
    "1307": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered groups (where the order is total), the absolute\n  value maps the group into the positive set.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L1",
            "OrderedGroup_ZF_3_L3B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L3C:\n  assumes A1: \"r {is total on} G\"\n  shows \"AbsoluteValue(G,P,r) : G\\<rightarrow>G\\<^sup>+\"\n",
        "proof": "proof-\n  have \"AbsoluteValue(G,P,r) : G\\<rightarrow>G\" using OrderedGroup_ZF_3_L1\n    by simp\n  moreover from A1 have T2: \n    \"\\<forall>g\\<in>G. AbsoluteValue(G,P,r)`(g)  \\<in> G\\<^sup>+\" \n    using OrderedGroup_ZF_3_L3B by simp\n  ultimately show ?thesis by (rule func1_1_L1A)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1457
    },
    "1308": {
        "type": "lemma",
        "text": "text\\<open>If the absolute value is the unit, then the elemnent is the unit.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"\\<bar>a\\<bar> = \\<one>\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L2",
            "OrderedGroup_ZF_3_L3",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L8A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L3D: \n  assumes A1: \"a\\<in>G\" and A2: \"\\<bar>a\\<bar> = \\<one>\"\n  shows \"a = \\<one>\"\n",
        "proof": "proof -\n  { assume \"a \\<in> G\\<^sup>+\" \n    with A2 have \"a = \\<one>\" using OrderedGroup_ZF_3_L2 by simp }\n  moreover\n  { assume \"a \\<notin> G\\<^sup>+\"\n    with A1 A2 have \"a = \\<one>\" using \n      OrderedGroup_ZF_3_L3 OrderedGroup_ZF_1_L1 group0.group0_2_L8A\n      by auto }\n  ultimately show \"a = \\<one>\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1458
    },
    "1309": {
        "type": "lemma",
        "text": "text\\<open>In linearly ordered groups the unit is not greater than the absolute \n  value of any element.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\" and \"a\\<in>G\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_3_L3B",
            "OrderedGroup_ZF_1_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L3E: \n  assumes \"r {is total on} G\" and \"a\\<in>G\"\n  shows \"\\<one> \\<lsq> \\<bar>a\\<bar>\"\n  ",
        "proof": "using assms OrderedGroup_ZF_3_L3B OrderedGroup_ZF_1_L2 by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1459
    },
    "1310": {
        "type": "lemma",
        "text": "text\\<open>In linearly ordered groups $a\\leq |a|$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L2",
            "OrderedGroup_ZF_1_L3",
            "OrderedGroup_ZF_3_L3B",
            "OrderedGroup_ZF_1_L4B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L5: \n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"\n  shows \"a \\<lsq> \\<bar>a\\<bar>\"\n",
        "proof": "proof -\n  { assume \"a \\<in> G\\<^sup>+\"\n    with A2 have \"a \\<lsq> \\<bar>a\\<bar>\" \n      using OrderedGroup_ZF_3_L2 OrderedGroup_ZF_1_L3 by simp }\n  moreover\n  { assume \"a \\<notin> G\\<^sup>+\"\n    with A1 A2 have \"a \\<lsq> \\<bar>a\\<bar>\"\n      using OrderedGroup_ZF_3_L3B OrderedGroup_ZF_1_L4B by simp }\n  ultimately show \"a \\<lsq> \\<bar>a\\<bar>\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1461
    },
    "1311": {
        "type": "lemma",
        "text": "text\\<open> $a^{-1}\\leq |a|$ (in additive notation it would be $-a\\leq |a|$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" ",
        "using": [
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_3_L2",
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_one",
            "OrderedGroup_ZF_3_L1",
            "apply_funtype",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "refl_def",
            "OrderedGroup_ZF_3_L3"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L6: \n  assumes A1: \"a\\<in>G\" shows \"a\\<inverse> \\<lsq> \\<bar>a\\<bar>\"\n",
        "proof": "proof -\n  { assume \"a \\<in> G\\<^sup>+\"\n    then have T1: \"\\<one>\\<lsq>a\" and T2: \"\\<bar>a\\<bar> = a\" using OrderedGroup_ZF_1_L2  \n      OrderedGroup_ZF_3_L2 by auto\n    then have \"a\\<inverse>\\<lsq>\\<one>\\<inverse>\" using OrderedGroup_ZF_1_L5 by simp\n    then have T3: \"a\\<inverse>\\<lsq>\\<one>\" \n      using OrderedGroup_ZF_1_L1 group0.group_inv_of_one by simp\n    from T3 T1 have \"a\\<inverse>\\<lsq>a\" by (rule Group_order_transitive)\n    with T2 have \"a\\<inverse> \\<lsq> \\<bar>a\\<bar>\" by simp }\n  moreover \n  { assume A2: \"a \\<notin> G\\<^sup>+\"\n    from A1 have \"\\<bar>a\\<bar> \\<in> G\" \n      using OrderedGroup_ZF_3_L1 apply_funtype by auto\n    with ordGroupAssum have \"\\<bar>a\\<bar> \\<lsq> \\<bar>a\\<bar>\" \n      using IsAnOrdGroup_def IsPartOrder_def refl_def by simp\n    with A1 A2 have \"a\\<inverse> \\<lsq> \\<bar>a\\<bar>\" using OrderedGroup_ZF_3_L3 by simp }\n  ultimately show \"a\\<inverse> \\<lsq> \\<bar>a\\<bar>\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1462
    },
    "1312": {
        "type": "lemma",
        "text": "text\\<open>Some inequalities about the product of two elements of a linearly \n  ordered group and its absolute value.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\" and \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_3_L5",
            "OrderedGroup_ZF_3_L6",
            "OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L6A:\n  assumes \"r {is total on} G\" and \"a\\<in>G\"  \"b\\<in>G\"\n  shows\n  \"a\\<cdot>b \\<lsq>\\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n  \"a\\<cdot>b\\<inverse> \\<lsq>\\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n  \"a\\<inverse>\\<cdot>b \\<lsq>\\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n  \"a\\<inverse>\\<cdot>b\\<inverse> \\<lsq>\\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n  ",
        "proof": "using assms OrderedGroup_ZF_3_L5 OrderedGroup_ZF_3_L6\n    OrderedGroup_ZF_1_L5B by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1463
    },
    "1313": {
        "type": "lemma",
        "text": "text\\<open> $|a^{-1}|\\leq |a|$.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\" and \"a\\<in>G\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_3_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv",
            "OrderedGroup_ZF_3_L6",
            "OrderedGroup_ZF_3_L4"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7:\n  assumes \"r {is total on} G\" and \"a\\<in>G\"\n  shows \"\\<bar>a\\<inverse>\\<bar>\\<lsq>\\<bar>a\\<bar>\"\n  ",
        "proof": "using assms OrderedGroup_ZF_3_L5 OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n    OrderedGroup_ZF_3_L6 OrderedGroup_ZF_3_L4 by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1464
    },
    "1314": {
        "type": "lemma",
        "text": "text\\<open>$|a^{-1}| = |a|$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "OrderedGroup_ZF_3_L7",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7A:\n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\"\n  shows \"\\<bar>a\\<inverse>\\<bar> = \\<bar>a\\<bar>\"\n",
        "proof": "proof -\n  from A2 have \"a\\<inverse>\\<in>G\" using OrderedGroup_ZF_1_L1 group0.inverse_in_group\n    by simp\n  with A1 have \"\\<bar>(a\\<inverse>)\\<inverse>\\<bar> \\<lsq> \\<bar>a\\<inverse>\\<bar>\" using OrderedGroup_ZF_3_L7 by simp\n  with A1 A2 have \"\\<bar>a\\<inverse>\\<bar> \\<lsq> \\<bar>a\\<bar>\"  \"\\<bar>a\\<bar> \\<lsq> \\<bar>a\\<inverse>\\<bar>\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv OrderedGroup_ZF_3_L7\n    by auto\n  then show ?thesis by (rule group_order_antisym)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1465
    },
    "1315": {
        "type": "lemma",
        "text": "text\\<open> $|a\\cdot b^{-1}| = |b\\cdot a^{-1}|$. It doesn't look so strange in the \n  additive notation: $|a-b| = |b-a|$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \"b\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group0_2_L1",
            "monoid0.group0_1_L1",
            "OrderedGroup_ZF_3_L7A",
            "group0.group0_2_L12"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7B:\n  assumes A1: \"r {is total on} G\" and A2: \"a\\<in>G\" \"b\\<in>G\"\n  shows \"\\<bar>a\\<cdot>b\\<inverse>\\<bar> = \\<bar>b\\<cdot>a\\<inverse>\\<bar>\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<bar>(a\\<cdot>b\\<inverse>)\\<inverse>\\<bar> = \\<bar>a\\<cdot>b\\<inverse>\\<bar>\" using\n    OrderedGroup_ZF_1_L1 group0.inverse_in_group group0.group0_2_L1 \n    monoid0.group0_1_L1 OrderedGroup_ZF_3_L7A by simp\n  moreover from A2 have \"(a\\<cdot>b\\<inverse>)\\<inverse> =  b\\<cdot>a\\<inverse>\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L12 by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1466
    },
    "1316": {
        "type": "theorem",
        "text": "text\\<open>Triangle inequality for linearly ordered abelian groups. \n  It would be nice to drop commutativity or give an example that shows we\n  can't do that.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\" \n  ",
        "using": [
            "OrderedGroup_ZF_3_L5",
            "OrderedGroup_ZF_3_L6",
            "OrderedGroup_ZF_1_L5B",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_two",
            "IsCommutative_def",
            "OrderedGroup_ZF_3_L4"
        ],
        "statement": "theorem (in group3) OrdGroup_triangle_ineq:\n  assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\" \n  shows \"\\<bar>a\\<cdot>b\\<bar> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \n    \"a \\<lsq> \\<bar>a\\<bar>\" \"b \\<lsq> \\<bar>b\\<bar>\" \"a\\<inverse> \\<lsq> \\<bar>a\\<bar>\" \"b\\<inverse> \\<lsq> \\<bar>b\\<bar>\"\n    using OrderedGroup_ZF_3_L5 OrderedGroup_ZF_3_L6 by auto\n  then have \"a\\<cdot>b \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\" \"a\\<inverse>\\<cdot>b\\<inverse> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n    using OrderedGroup_ZF_1_L5B by auto\n  with A1 A3 show \"\\<bar>a\\<cdot>b\\<bar> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_two IsCommutative_def \n    OrderedGroup_ZF_3_L4 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1467
    },
    "1317": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the sides of an inequality with absolute value.\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\" \n  and \"r {is total on} G\" \"a\\<in>G\" \"b\\<in>G\"\n  and \"\\<bar>a\\<bar> \\<lsq> c\"  \"\\<bar>b\\<bar> \\<lsq> d\"\n  ",
        "using": [
            "OrdGroup_triangle_ineq",
            "OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7C:\n  assumes \"P {is commutative on} G\" \n  and \"r {is total on} G\" \"a\\<in>G\" \"b\\<in>G\"\n  and \"\\<bar>a\\<bar> \\<lsq> c\"  \"\\<bar>b\\<bar> \\<lsq> d\"\n  shows \"\\<bar>a\\<cdot>b\\<bar> \\<lsq> c\\<cdot>d\"\n",
        "proof": "proof -\n  from assms(1,2,3,4) have \"\\<bar>a\\<cdot>b\\<bar> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n    using OrdGroup_triangle_ineq by simp\n  moreover from assms(5,6) have \"\\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar> \\<lsq> c\\<cdot>d\"\n    using OrderedGroup_ZF_1_L5B by simp\n  ultimately show ?thesis by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1468
    },
    "1318": {
        "type": "lemma",
        "text": "text\\<open>A version of the \\<open>OrderedGroup_ZF_3_L7C\\<close> \n  but with multiplying by the inverse.\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\" \n  and \"r {is total on} G\" and \"a\\<in>G\"  \"b\\<in>G\"\n  and \"\\<bar>a\\<bar> \\<lsq> c\"  \"\\<bar>b\\<bar> \\<lsq> d\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "OrderedGroup_ZF_3_L7A",
            "OrderedGroup_ZF_3_L7C"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7CA:\n  assumes \"P {is commutative on} G\" \n  and \"r {is total on} G\" and \"a\\<in>G\"  \"b\\<in>G\"\n  and \"\\<bar>a\\<bar> \\<lsq> c\"  \"\\<bar>b\\<bar> \\<lsq> d\"\n  shows \"\\<bar>a\\<cdot>b\\<inverse>\\<bar> \\<lsq> c\\<cdot>d\"\n  ",
        "proof": "using assms OrderedGroup_ZF_1_L1 group0.inverse_in_group\n  OrderedGroup_ZF_3_L7A OrderedGroup_ZF_3_L7C by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1469
    },
    "1319": {
        "type": "lemma",
        "text": "text\\<open>Triangle inequality with three integers.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group_op_closed",
            "OrderedGroup_ZF_3_L1",
            "apply_funtype",
            "OrdGroup_triangle_ineq",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in group3) OrdGroup_triangle_ineq3:\n  assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" \n  shows \"\\<bar>a\\<cdot>b\\<cdot>c\\<bar> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\\<cdot>\\<bar>c\\<bar>\"\n",
        "proof": "proof -\n  from A3 have T: \"a\\<cdot>b \\<in> G\"  \"\\<bar>c\\<bar> \\<in> G\"\n    using OrderedGroup_ZF_1_L1 group0.group_op_closed\n      OrderedGroup_ZF_3_L1 apply_funtype by auto\n  with A1 A2 A3 have \"\\<bar>a\\<cdot>b\\<cdot>c\\<bar> \\<lsq> \\<bar>a\\<cdot>b\\<bar>\\<cdot>\\<bar>c\\<bar>\"\n    using OrdGroup_triangle_ineq by simp\n  moreover from ordGroupAssum A1 A2 A3 T have\n    \"\\<bar>a\\<cdot>b\\<bar>\\<cdot>\\<bar>c\\<bar> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\\<cdot>\\<bar>c\\<bar>\"\n    using OrdGroup_triangle_ineq IsAnOrdGroup_def by simp\n  ultimately show \"\\<bar>a\\<cdot>b\\<cdot>c\\<bar> \\<lsq> \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\\<cdot>\\<bar>c\\<bar>\"\n    by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1470
    },
    "1320": {
        "type": "lemma",
        "text": "text\\<open>Some variants of the triangle inequality.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\"\n  and A4: \"\\<bar>a\\<cdot>b\\<inverse>\\<bar> \\<lsq> c\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group0_2_L1",
            "monoid0.group0_1_L1",
            "OrderedGroup_ZF_3_L1",
            "apply_funtype",
            "OrderedGroup_ZF_1_L4",
            "group0.inv_cancel_two",
            "OrdGroup_triangle_ineq",
            "OrderedGroup_ZF_1_L5C",
            "IsCommutative_def",
            "OrderedGroup_ZF_3_L5",
            "OrderedGroup_ZF_1_L5H"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7D:\n  assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\"\n  and A4: \"\\<bar>a\\<cdot>b\\<inverse>\\<bar> \\<lsq> c\"\n  shows \n  \"\\<bar>a\\<bar> \\<lsq> c\\<cdot>\\<bar>b\\<bar>\" \n  \"\\<bar>a\\<bar> \\<lsq> \\<bar>b\\<bar>\\<cdot>c\"\n  \"c\\<inverse>\\<cdot>a \\<lsq> b\"\n  \"a\\<cdot>c\\<inverse> \\<lsq> b\"\n  \"a \\<lsq> b\\<cdot>c\"\n",
        "proof": "proof -\n  from A3 A4 have \n    T: \"a\\<cdot>b\\<inverse> \\<in> G\"  \"\\<bar>b\\<bar> \\<in> G\"  \"c\\<in>G\"  \"c\\<inverse> \\<in> G\"\n    using OrderedGroup_ZF_1_L1 \n      group0.inverse_in_group group0.group0_2_L1 monoid0.group0_1_L1\n      OrderedGroup_ZF_3_L1 apply_funtype  OrderedGroup_ZF_1_L4 \n    by auto\n  from A3 have \"\\<bar>a\\<bar> = \\<bar>a\\<cdot>b\\<inverse>\\<cdot>b\\<bar>\"\n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\n  with A1 A2 A3 T have \"\\<bar>a\\<bar> \\<lsq> \\<bar>a\\<cdot>b\\<inverse>\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n    using OrdGroup_triangle_ineq by simp\n  with T A4 show \"\\<bar>a\\<bar> \\<lsq> c\\<cdot>\\<bar>b\\<bar>\" using OrderedGroup_ZF_1_L5C\n    by blast\n  with T A1 show \"\\<bar>a\\<bar> \\<lsq> \\<bar>b\\<bar>\\<cdot>c\"\n    using IsCommutative_def by simp\n  from A2 T have \"a\\<cdot>b\\<inverse> \\<lsq> \\<bar>a\\<cdot>b\\<inverse>\\<bar>\"\n    using OrderedGroup_ZF_3_L5 by simp\n  moreover note A4\n  ultimately have I: \"a\\<cdot>b\\<inverse> \\<lsq> c\"\n    by (rule Group_order_transitive)\n  with A3 show \"c\\<inverse>\\<cdot>a \\<lsq> b\"\n    using OrderedGroup_ZF_1_L5H by simp\n  with A1 A3 T show \"a\\<cdot>c\\<inverse> \\<lsq> b\"\n    using IsCommutative_def by simp\n  from A1 A3 T I show \"a \\<lsq> b\\<cdot>c\"\n    using OrderedGroup_ZF_1_L5H IsCommutative_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1471
    },
    "1321": {
        "type": "lemma",
        "text": "text\\<open>Some more variants of the triangle inequality.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\"\n  and A4: \"\\<bar>a\\<cdot>b\\<inverse>\\<bar> \\<lsq> c\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group_op_closed",
            "OrderedGroup_ZF_3_L7A",
            "group0.group0_2_L12",
            "OrderedGroup_ZF_3_L7D"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7E:\n  assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and A3: \"a\\<in>G\"  \"b\\<in>G\"\n  and A4: \"\\<bar>a\\<cdot>b\\<inverse>\\<bar> \\<lsq> c\"\n  shows \"b\\<cdot>c\\<inverse> \\<lsq> a\"\n",
        "proof": "proof -\n  from A3 have \"a\\<cdot>b\\<inverse> \\<in> G\"\n    using OrderedGroup_ZF_1_L1 \n      group0.inverse_in_group group0.group_op_closed\n    by auto\n  with A2 have \"\\<bar>(a\\<cdot>b\\<inverse>)\\<inverse>\\<bar> = \\<bar>a\\<cdot>b\\<inverse>\\<bar>\"\n    using OrderedGroup_ZF_3_L7A by simp\n  moreover from A3 have \"(a\\<cdot>b\\<inverse>)\\<inverse> = b\\<cdot>a\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.group0_2_L12\n    by simp\n  ultimately have \"\\<bar>b\\<cdot>a\\<inverse>\\<bar> = \\<bar>a\\<cdot>b\\<inverse>\\<bar>\"\n    by simp\n  with A1 A2 A3 A4 show \"b\\<cdot>c\\<inverse> \\<lsq> a\"\n    using OrderedGroup_ZF_3_L7D by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1472
    },
    "1322": {
        "type": "lemma",
        "text": "text\\<open>An application of the triangle inequality with four group\n  elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and \n  A3: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "group0.group_op_closed",
            "OrdGroup_triangle_ineq3",
            "OrderedGroup_ZF_3_L7A",
            "group0.group0_4_L8"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L7F:\n  assumes A1: \"P {is commutative on} G\" \n  and A2: \"r {is total on} G\" and \n  A3: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \"\\<bar>a\\<cdot>c\\<inverse>\\<bar> \\<lsq> \\<bar>a\\<cdot>b\\<bar>\\<cdot>\\<bar>c\\<cdot>d\\<bar>\\<cdot>\\<bar>b\\<cdot>d\\<inverse>\\<bar>\"\n",
        "proof": "proof -\n  from A3 have T:\n    \"a\\<cdot>c\\<inverse> \\<in> G\"  \"a\\<cdot>b \\<in> G\"  \"c\\<cdot>d \\<in> G\"  \"b\\<cdot>d\\<inverse> \\<in> G\"\n    \"(c\\<cdot>d)\\<inverse> \\<in> G\"  \"(b\\<cdot>d\\<inverse>)\\<inverse> \\<in> G\"\n    using OrderedGroup_ZF_1_L1 \n      group0.inverse_in_group group0.group_op_closed\n    by auto\n  with A1 A2 have \"\\<bar>(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\\<inverse>\\<bar> \\<lsq> \\<bar>a\\<cdot>b\\<bar>\\<cdot>\\<bar>(c\\<cdot>d)\\<inverse>\\<bar>\\<cdot>\\<bar>(b\\<cdot>d\\<inverse>)\\<inverse>\\<bar>\"\n    using OrdGroup_triangle_ineq3 by simp\n  moreover from A2 T have \"\\<bar>(c\\<cdot>d)\\<inverse>\\<bar> =\\<bar>c\\<cdot>d\\<bar>\" and \"\\<bar>(b\\<cdot>d\\<inverse>)\\<inverse>\\<bar> = \\<bar>b\\<cdot>d\\<inverse>\\<bar>\"\n    using OrderedGroup_ZF_3_L7A by auto\n  moreover from A1 A3 have \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(b\\<cdot>d\\<inverse>)\\<inverse> = a\\<cdot>c\\<inverse>\"\n    using OrderedGroup_ZF_1_L1 group0.group0_4_L8\n    by simp\n  ultimately show \"\\<bar>a\\<cdot>c\\<inverse>\\<bar> \\<lsq> \\<bar>a\\<cdot>b\\<bar>\\<cdot>\\<bar>c\\<cdot>d\\<bar>\\<cdot>\\<bar>b\\<cdot>d\\<inverse>\\<bar>\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1473
    },
    "1323": {
        "type": "lemma",
        "text": "text\\<open>$|a|\\leq L$ implies $L^{-1} \\leq a$\n  (it would be $-L \\leq a$ in the additive notation).\\<close>\n",
        "assumes": "assumes A1:  \"a\\<in>G\" and A2: \"\\<bar>a\\<bar>\\<lsq>L\"\n   ",
        "using": [
            "OrderedGroup_ZF_3_L6",
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L8:\n  assumes A1:  \"a\\<in>G\" and A2: \"\\<bar>a\\<bar>\\<lsq>L\"\n   shows \n  \"L\\<inverse>\\<lsq>a\"\n",
        "proof": "proof -\n  from A1 have I: \"a\\<inverse> \\<lsq> \\<bar>a\\<bar>\" using OrderedGroup_ZF_3_L6 by simp\n  from I A2 have \"a\\<inverse> \\<lsq> L\" by (rule Group_order_transitive)\n  then have \"L\\<inverse>\\<lsq>(a\\<inverse>)\\<inverse>\" using OrderedGroup_ZF_1_L5 by simp\n  with A1 show \"L\\<inverse>\\<lsq>a\" using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1474
    },
    "1324": {
        "type": "lemma",
        "text": "text\\<open>In linearly ordered groups $|a|\\leq L$ implies $a \\leq L$\n  (it would be $a \\leq L$ in the additive notation).\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" \n  and A2: \"a\\<in>G\" and A3: \"\\<bar>a\\<bar>\\<lsq>L\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L5",
            "OrderedGroup_ZF_3_L3B",
            "OrderedGroup_ZF_1_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L8A:\n  assumes A1: \"r {is total on} G\" \n  and A2: \"a\\<in>G\" and A3: \"\\<bar>a\\<bar>\\<lsq>L\"\n  shows \n  \"a\\<lsq>L\"\n  \"\\<one>\\<lsq>L\"\n",
        "proof": "proof -\n  from A1 A2 have I: \"a \\<lsq> \\<bar>a\\<bar>\" using OrderedGroup_ZF_3_L5 by simp\n  from I A3 show \"a\\<lsq>L\" by (rule Group_order_transitive)\n  from A1 A2 A3 have \"\\<one> \\<lsq> \\<bar>a\\<bar>\"  \"\\<bar>a\\<bar>\\<lsq>L\"\n     using OrderedGroup_ZF_3_L3B OrderedGroup_ZF_1_L2 by auto\n   then show \"\\<one>\\<lsq>L\" by (rule Group_order_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1475
    },
    "1325": {
        "type": "lemma",
        "text": "text\\<open>A somewhat generalized version of the above lemma.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"\\<bar>a\\<bar>\\<lsq>L\" and A3: \"\\<one>\\<lsq>c\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L8",
            "OrderedGroup_ZF_1_L5AB",
            "OrderedGroup_ZF_1_L5B",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_two",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L8B:\n  assumes A1: \"a\\<in>G\" and A2: \"\\<bar>a\\<bar>\\<lsq>L\" and A3: \"\\<one>\\<lsq>c\"\n  shows \"(L\\<cdot>c)\\<inverse> \\<lsq> a\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \"c\\<inverse>\\<cdot>L\\<inverse> \\<lsq> \\<one>\\<cdot>a\"\n    using OrderedGroup_ZF_3_L8 OrderedGroup_ZF_1_L5AB\n    OrderedGroup_ZF_1_L5B by simp\n  with A1 A2 A3 show \"(L\\<cdot>c)\\<inverse> \\<lsq> a\"\n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1\n      group0.group_inv_of_two group0.group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1476
    },
    "1326": {
        "type": "lemma",
        "text": "text\\<open>If $b$ is between $a$ and $a\\cdot c$, then $b\\cdot a^{-1}\\leq c$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>G\" and A3: \"b\\<lsq>c\\<cdot>a\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L9C",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L9",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.group0_2_L6",
            "group0.inv_cancel_two",
            "group0.group0_2_L12",
            "OrderedGroup_ZF_3_L4"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L8C:\n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>G\" and A3: \"b\\<lsq>c\\<cdot>a\"\n  shows \"\\<bar>b\\<cdot>a\\<inverse>\\<bar> \\<lsq> c\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \"b\\<cdot>a\\<inverse> \\<lsq> c\"\n    using OrderedGroup_ZF_1_L9C OrderedGroup_ZF_1_L4\n    by simp\n  moreover have \"(b\\<cdot>a\\<inverse>)\\<inverse> \\<lsq> c\"\n  proof -\n    from A1 have T: \"a\\<in>G\"  \"b\\<in>G\"\n      using OrderedGroup_ZF_1_L4 by auto\n    with A1 have \"a\\<cdot>b\\<inverse> \\<lsq> \\<one>\"\n      using OrderedGroup_ZF_1_L9 by blast\n    moreover\n    from A1 A3 have \"a\\<lsq>c\\<cdot>a\"\n      by (rule Group_order_transitive)\n    with ordGroupAssum T have \"a\\<cdot>a\\<inverse> \\<lsq> c\\<cdot>a\\<cdot>a\\<inverse>\"\n      using OrderedGroup_ZF_1_L1 group0.inverse_in_group\n      IsAnOrdGroup_def by simp\n    with T A2 have \"\\<one> \\<lsq> c\"\n      using OrderedGroup_ZF_1_L1 \n\tgroup0.group0_2_L6 group0.inv_cancel_two\n      by simp\n    ultimately have \"a\\<cdot>b\\<inverse> \\<lsq> c\"\n      by (rule Group_order_transitive)\n    with T show \"(b\\<cdot>a\\<inverse>)\\<inverse> \\<lsq> c\"\n      using OrderedGroup_ZF_1_L1 group0.group0_2_L12\n      by simp\n  qed\n  ultimately show \"\\<bar>b\\<cdot>a\\<inverse>\\<bar> \\<lsq> c\"\n    using OrderedGroup_ZF_3_L4 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1477
    },
    "1327": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered groups if the absolute values of elements in a set\n  are bounded, then the set is bounded.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"A\\<subseteq>G\" and A3: \"\\<forall>a\\<in>A. \\<bar>a\\<bar> \\<lsq> L\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L8",
            "OrderedGroup_ZF_3_L8A",
            "IsBoundedAbove_def",
            "IsBoundedBelow_def",
            "IsBounded_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L9:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"A\\<subseteq>G\" and A3: \"\\<forall>a\\<in>A. \\<bar>a\\<bar> \\<lsq> L\"\n  shows \"IsBounded(A,r)\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \n    \"\\<forall>a\\<in>A. a\\<lsq>L\"  \"\\<forall>a\\<in>A. L\\<inverse>\\<lsq>a\" \n    using OrderedGroup_ZF_3_L8 OrderedGroup_ZF_3_L8A by auto\n  then show \"IsBounded(A,r)\" using\n    IsBoundedAbove_def IsBoundedBelow_def IsBounded_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1478
    },
    "1328": {
        "type": "lemma",
        "text": "text\\<open>A slightly more general version of the previous lemma, stating the same\n  fact for a set defined by separation.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"\\<forall>x\\<in>X. b(x)\\<in>G \\<and> \\<bar>b(x)\\<bar>\\<lsq>L\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L9"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L9A:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"\\<forall>x\\<in>X. b(x)\\<in>G \\<and> \\<bar>b(x)\\<bar>\\<lsq>L\"\n  shows \"IsBounded({b(x). x\\<in>X},r)\"\n",
        "proof": "proof -\n  from A2 have \"{b(x). x\\<in>X} \\<subseteq> G\" \"\\<forall>a\\<in>{b(x). x\\<in>X}. \\<bar>a\\<bar> \\<lsq> L\" \n    by auto\n  with A1 show ?thesis using OrderedGroup_ZF_3_L9 by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1479
    },
    "1329": {
        "type": "lemma",
        "text": "text\\<open>A special form of the previous lemma stating a similar fact for an\n  image of a set by a function with values in a linearly ordered group.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"f:X\\<rightarrow>G\" and A3: \"A\\<subseteq>X\"\n  and A4: \"\\<forall>x\\<in>A. \\<bar>f`(x)\\<bar> \\<lsq> L\"\n  ",
        "using": [
            "apply_funtype",
            "func_imagedef"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L9B:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"f:X\\<rightarrow>G\" and A3: \"A\\<subseteq>X\"\n  and A4: \"\\<forall>x\\<in>A. \\<bar>f`(x)\\<bar> \\<lsq> L\"\n  shows \"IsBounded(f``(A),r)\"\n",
        "proof": "proof -\n  from A2 A3 A4 have \"\\<forall>x\\<in>A. f`(x) \\<in> G \\<and>  \\<bar>f`(x)\\<bar> \\<lsq> L\"\n    using apply_funtype by auto\n  with A1 have  \"IsBounded({f`(x). x\\<in>A},r)\"\n    by (rule OrderedGroup_ZF_3_L9A)\n  with A2 A3 show \"IsBounded(f``(A),r)\"\n    using func_imagedef by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1480
    },
    "1330": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered groups if $l\\leq a\\leq u$ then \n  $|a|$ is smaller than the greater of $|l|,|u|$.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"l\\<lsq>a\"  \"a\\<lsq>u\" \n  ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_3_L1",
            "apply_funtype",
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_3_L2",
            "Order_ZF_3_L2",
            "OrderedGroup_ZF_1_L4D",
            "OrderedGroup_ZF_3_L3",
            "OrderedGroup_ZF_1_L5"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L10:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"l\\<lsq>a\"  \"a\\<lsq>u\" \n  shows \n  \"\\<bar>a\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n",
        "proof": "proof -\n  from A2 have T1: \"\\<bar>l\\<bar> \\<in> G\" \"\\<bar>a\\<bar> \\<in> G\" \"\\<bar>u\\<bar> \\<in> G\"\n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_3_L1 apply_funtype\n    by auto\n  { assume A3: \"a\\<in>G\\<^sup>+\"\n    with A2 have \"\\<one>\\<lsq>a\" \"a\\<lsq>u\" \n      using OrderedGroup_ZF_1_L2 by auto\n    then have \"\\<one>\\<lsq>u\" by (rule Group_order_transitive)\n    with A2 A3 have \"\\<bar>a\\<bar>\\<lsq>\\<bar>u\\<bar>\" \n      using OrderedGroup_ZF_1_L2 OrderedGroup_ZF_3_L2 by simp\n    moreover from A1 T1 have \"\\<bar>u\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n      using Order_ZF_3_L2 by simp\n    ultimately have \"\\<bar>a\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n      by (rule Group_order_transitive) }\n  moreover\n  { assume A4: \"a\\<notin>G\\<^sup>+\"\n    with A2 have T2: \n      \"l\\<in>G\" \"\\<bar>l\\<bar> \\<in> G\" \"\\<bar>a\\<bar> \\<in> G\" \"\\<bar>u\\<bar> \\<in> G\" \"a \\<in> G-G\\<^sup>+\"\n      using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_3_L1 apply_funtype\n      by auto\n    with A2 have \"l \\<in> G-G\\<^sup>+\" using OrderedGroup_ZF_1_L4D by fast\n    with T2 A2 have \"\\<bar>a\\<bar> \\<lsq> \\<bar>l\\<bar>\" \n      using OrderedGroup_ZF_3_L3 OrderedGroup_ZF_1_L5\n      by simp\n    moreover from A1 T2 have \"\\<bar>l\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n      using Order_ZF_3_L2 by simp \n    ultimately have \"\\<bar>a\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n      by (rule Group_order_transitive) }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1481
    },
    "1331": {
        "type": "lemma",
        "text": "text\\<open>For linearly ordered groups if a set is bounded then the absolute \n  values are bounded.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"IsBounded(A,r)\"\n  ",
        "using": [
            "IsBounded_def",
            "IsBoundedAbove_def",
            "IsBoundedBelow_def",
            "OrderedGroup_ZF_3_L10"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L10A:\n  assumes A1: \"r {is total on} G\"\n  and A2: \"IsBounded(A,r)\"\n  shows \"\\<exists>L. \\<forall>a\\<in>A. \\<bar>a\\<bar> \\<lsq> L\"\n",
        "proof": "proof -\n  { assume \"A = 0\" then have ?thesis by auto }\n  moreover\n  { assume A3: \"A\\<noteq>0\" \n    with A2 have \"\\<exists>u. \\<forall>g\\<in>A. g\\<lsq>u\" and \"\\<exists>l.\\<forall>g\\<in>A. l\\<lsq>g\"\n      using IsBounded_def IsBoundedAbove_def IsBoundedBelow_def\n      by auto\n    then obtain u l where \"\\<forall>g\\<in>A. l\\<lsq>g \\<and>  g\\<lsq>u\" \n      by auto\n    with A1 have \"\\<forall>a\\<in>A. \\<bar>a\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n      using OrderedGroup_ZF_3_L10 by simp\n    then have ?thesis by auto }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1482
    },
    "1332": {
        "type": "lemma",
        "text": "text\\<open>A slightly more general version of the previous lemma, stating the same\n  fact for a set defined by separation.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\"\n  and \"IsBounded({b(x).x\\<in>X},r)\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_3_L10A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L11:\n  assumes \"r {is total on} G\"\n  and \"IsBounded({b(x).x\\<in>X},r)\"\n  shows \"\\<exists>L. \\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> L\"\n  ",
        "proof": "using assms OrderedGroup_ZF_3_L10A by blast\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1483
    },
    "1333": {
        "type": "lemma",
        "text": "text\\<open>Absolute values of elements of a finite image of a nonempty set are \n  bounded by an element of the group.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" \n  and A2: \"X\\<noteq>0\" and A3: \"{b(x). x\\<in>X} \\<in> Fin(G)\"\n  ",
        "using": [
            "ord_group_fin_bounded",
            "OrderedGroup_ZF_3_L11",
            "OrderedGroup_ZF_1_L4"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L11A:\n  assumes A1: \"r {is total on} G\" \n  and A2: \"X\\<noteq>0\" and A3: \"{b(x). x\\<in>X} \\<in> Fin(G)\"\n  shows \"\\<exists>L\\<in>G. \\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> L\"\n",
        "proof": "proof -\n  from A1 A3 have \"\\<exists>L. \\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> L\"\n     using  ord_group_fin_bounded OrderedGroup_ZF_3_L11\n     by simp\n  then obtain L where I: \"\\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> L\"\n    using OrderedGroup_ZF_3_L11 by auto\n  from A2 obtain x where \"x\\<in>X\" by auto\n  with I show ?thesis using OrderedGroup_ZF_1_L4\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1484
    },
    "1334": {
        "type": "lemma",
        "text": "text\\<open>In totally ordered groups the absolute value of a \n  nonunit element is in \\<open>G\\<^sub>+\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" \n  and A2: \"a\\<in>G\"  and A3: \"a\\<noteq>\\<one>\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L1",
            "apply_funtype",
            "OrderedGroup_ZF_3_L3B",
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_3_L3D",
            "PositiveSet_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L12:\n  assumes A1: \"r {is total on} G\" \n  and A2: \"a\\<in>G\"  and A3: \"a\\<noteq>\\<one>\"\n  shows \"\\<bar>a\\<bar> \\<in> G\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<bar>a\\<bar> \\<in> G\"  \"\\<one> \\<lsq> \\<bar>a\\<bar>\" \n    using OrderedGroup_ZF_3_L1 apply_funtype\n      OrderedGroup_ZF_3_L3B OrderedGroup_ZF_1_L2 \n    by auto\n  moreover from A2 A3 have \"\\<bar>a\\<bar> \\<noteq> \\<one>\"\n    using OrderedGroup_ZF_3_L3D by auto\n  ultimately show \"\\<bar>a\\<bar> \\<in> G\\<^sub>+\"\n    using PositiveSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1485
    },
    "1335": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum and minimum, then the greater of the \n  absolute value of the maximum and minimum bounds absolute values of all \n  elements of the set.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  and A2: \"HasAmaximum(r,A)\"  \"HasAminimum(r,A)\"\n  and A3: \"a\\<in>A\"\n  ",
        "using": [
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "Order_ZF_4_L3",
            "Order_ZF_4_L4"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_4_L2: \n  assumes A1: \"r {is total on} G\"\n  and A2: \"HasAmaximum(r,A)\"  \"HasAminimum(r,A)\"\n  and A3: \"a\\<in>A\"\n  shows \"\\<bar>a\\<bar>\\<lsq> GreaterOf(r,\\<bar>Minimum(r,A)\\<bar>,\\<bar>Maximum(r,A)\\<bar>)\" \n",
        "proof": "proof -\n  from ordGroupAssum A2 A3 have \n    \"Minimum(r,A)\\<lsq> a\" \"a\\<lsq> Maximum(r,A)\" \n    using IsAnOrdGroup_def IsPartOrder_def Order_ZF_4_L3 Order_ZF_4_L4\n    by auto\n  with A1 show ?thesis by (rule OrderedGroup_ZF_3_L10)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1487
    },
    "1336": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum and minimum, then the set of absolute values \n  also has a maximum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"A \\<subseteq> G\"\n  and A3: \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  ",
        "using": [
            "OrderedGroup_ZF_4_L1",
            "OrderedGroup_ZF_4_L3",
            "HasAmaximum_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_4_L4:\n  assumes A1: \"r {is total on} G\" and A2: \"A \\<subseteq> G\"\n  and A3: \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  shows \"HasAmaximum(r,AbsoluteValue(G,P,r)``(A))\"\n",
        "proof": "proof -\n  let ?M = \"GreaterOf(r,\\<bar>Minimum(r,A)\\<bar>,\\<bar>Maximum(r,A)\\<bar>)\"\n  from A2 A3 have \"?M \\<in> AbsoluteValue(G,P,r)``(A)\"\n    using OrderedGroup_ZF_4_L1 by simp\n  moreover from A1 A2 A3 have \n    \"\\<forall>b \\<in> AbsoluteValue(G,P,r)``(A). b \\<lsq> ?M\"\n    using OrderedGroup_ZF_4_L3 by simp\n  ultimately show ?thesis using HasAmaximum_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1489
    },
    "1337": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum and a minimum, then all absolute values are\n  bounded by the maximum of the set of absolute values.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"A \\<subseteq> G\"\n  and A3: \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  and A4: \"a\\<in>A\"\n  ",
        "using": [
            "OrderedGroup_ZF_3_L1",
            "func_imagedef",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "OrderedGroup_ZF_4_L4",
            "Order_ZF_4_L3"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_4_L5:\n  assumes A1: \"r {is total on} G\" and A2: \"A \\<subseteq> G\"\n  and A3: \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  and A4: \"a\\<in>A\"\n  shows \"\\<bar>a\\<bar> \\<lsq> Maximum(r,AbsoluteValue(G,P,r)``(A))\"\n",
        "proof": "proof -\n  from A2 A4 have \"\\<bar>a\\<bar> \\<in> AbsoluteValue(G,P,r)``(A)\" \n    using OrderedGroup_ZF_3_L1 func_imagedef by auto\n  with ordGroupAssum A1 A2 A3 show ?thesis using \n    IsAnOrdGroup_def IsPartOrder_def OrderedGroup_ZF_4_L4\n    Order_ZF_4_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1490
    },
    "1338": {
        "type": "lemma",
        "text": "text\\<open>The order defined by a positive set is the same as the order defined by\n  a nonnegative set.\\<close>\n",
        "assumes": "assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  ",
        "using": [
            "group0_2_L6",
            "inverse_in_group",
            "group0_2_L9",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) OrderedGroup_ZF_5_L1:\n  assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  shows \"\\<langle>a,b\\<rangle> \\<in> r  \\<longleftrightarrow> a\\<in>G \\<and> b\\<in>G \\<and> a\\<inverse>\\<cdot>b \\<in> H \\<union> {\\<one>}\"\n",
        "proof": "proof\n  assume \"\\<langle>a,b\\<rangle> \\<in> r\"\n  with A1 show \"a\\<in>G \\<and> b\\<in>G \\<and> a\\<inverse>\\<cdot>b \\<in> H \\<union> {\\<one>}\" \n    using group0_2_L6 by auto\nnext assume \"a\\<in>G \\<and> b\\<in>G \\<and> a\\<inverse>\\<cdot>b \\<in> H \\<union> {\\<one>}\"\n   then have \"a\\<in>G \\<and> b\\<in>G \\<and> b=(a\\<inverse>)\\<inverse> \\<or>  a\\<in>G \\<and> b\\<in>G \\<and> a\\<inverse>\\<cdot>b \\<in> H\"\n    using  inverse_in_group group0_2_L9 by auto\n  with A1 show \"\\<langle>a,b\\<rangle> \\<in> r\" using group_inv_of_inv\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1491
    },
    "1339": {
        "type": "lemma",
        "text": "text\\<open>The relation defined by a positive set is antisymmetric.\\<close>\n",
        "assumes": "assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  and A2: \"\\<forall>a\\<in>G. a\\<noteq>\\<one> \\<longrightarrow> (a\\<in>H) Xor (a\\<inverse>\\<in>H)\"\n  ",
        "using": [
            "inverse_in_group",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "group0_2_L12",
            "Xor_def",
            "group0_2_L11"
        ],
        "statement": "lemma (in group0) OrderedGroup_ZF_5_L2:\n  assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  and A2: \"\\<forall>a\\<in>G. a\\<noteq>\\<one> \\<longrightarrow> (a\\<in>H) Xor (a\\<inverse>\\<in>H)\"\n  shows \"antisym(r)\"\n",
        "proof": "proof -\n  { fix a b assume A3: \"\\<langle>a,b\\<rangle> \\<in> r\"  \"\\<langle>b,a\\<rangle> \\<in> r\"\n    with A1 have T: \"a\\<in>G\"  \"b\\<in>G\" by auto\n    { assume A4: \"a\\<noteq>b\"\n      with A1 A3 have \"a\\<inverse>\\<cdot>b \\<in> G\"  \"a\\<inverse>\\<cdot>b \\<in> H\"  \"(a\\<inverse>\\<cdot>b)\\<inverse> \\<in> H\"\n\tusing inverse_in_group group0_2_L1 monoid0.group0_1_L1 group0_2_L12\n\tby auto\n      with A2 have \"a\\<inverse>\\<cdot>b = \\<one>\" using Xor_def by auto\n      with T A4 have False using group0_2_L11 by auto\n    } then have \"a=b\" by auto\n  } then show \"antisym(r)\" by (rule antisymI)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1492
    },
    "1340": {
        "type": "lemma",
        "text": "text\\<open>The relation defined by a positive set is transitive.\\<close>\n",
        "assumes": "assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  and A2: \"H\\<subseteq>G\"  \"H {is closed under} P\"\n  ",
        "using": [
            "OrderedGroup_ZF_5_L1",
            "inverse_in_group",
            "group0_2_L17",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in group0) OrderedGroup_ZF_5_L3:\n  assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  and A2: \"H\\<subseteq>G\"  \"H {is closed under} P\"\n  shows \"trans(r)\"\n",
        "proof": "proof -\n  { fix a b c assume \"\\<langle>a,b\\<rangle> \\<in> r\"  \"\\<langle>b,c\\<rangle> \\<in> r\"\n    with A1 have \n      \"a\\<in>G \\<and> b\\<in>G \\<and> a\\<inverse>\\<cdot>b \\<in> H \\<union> {\\<one>}\"\n      \"b\\<in>G \\<and> c\\<in>G \\<and> b\\<inverse>\\<cdot>c \\<in> H \\<union> {\\<one>}\"\n      using OrderedGroup_ZF_5_L1 by auto\n    with A2 have \n      I: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n      and \"(a\\<inverse>\\<cdot>b)\\<cdot>(b\\<inverse>\\<cdot>c) \\<in>  H \\<union> {\\<one>}\"\n      using inverse_in_group group0_2_L17 IsOpClosed_def\n      by auto\n    moreover from I have \"a\\<inverse>\\<cdot>c = (a\\<inverse>\\<cdot>b)\\<cdot>(b\\<inverse>\\<cdot>c)\"\n      by (rule group0_2_L14A)\n    ultimately have \"\\<langle>a,c\\<rangle> \\<in> G\\<times>G\"  \"a\\<inverse>\\<cdot>c  \\<in>  H \\<union> {\\<one>}\"\n      by auto\n    with A1 have \"\\<langle>a,c\\<rangle> \\<in> r\" using OrderedGroup_ZF_5_L1\n      by auto\n  } then have \"\\<forall> a b c. \\<langle>a, b\\<rangle> \\<in> r \\<and> \\<langle>b, c\\<rangle> \\<in> r \\<longrightarrow> \\<langle>a, c\\<rangle> \\<in> r\"\n    by blast\n  then show  \"trans(r)\" by (rule Fol1_L2)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1493
    },
    "1341": {
        "type": "lemma",
        "text": "text\\<open>The relation defined by a positive set is translation invariant.\n  With our definition this step requires the group to be abelian.\\<close>\n",
        "assumes": "assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  and A2: \"P {is commutative on} G\"\n  and A3: \"\\<langle>a,b\\<rangle> \\<in> r\"  and A4: \"c\\<in>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_5_L1",
            "group_op_closed",
            "group0_4_L6D",
            "IsCommutative_def"
        ],
        "statement": "lemma (in group0) OrderedGroup_ZF_5_L4:\n  assumes A1: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  and A2: \"P {is commutative on} G\"\n  and A3: \"\\<langle>a,b\\<rangle> \\<in> r\"  and A4: \"c\\<in>G\"\n  shows \"\\<langle>a\\<cdot>c,b\\<cdot>c\\<rangle> \\<in> r \\<and> \\<langle>c\\<cdot>a,c\\<cdot>b\\<rangle> \\<in> r\"\n",
        "proof": "proof\n  from A1 A3 A4 have \n    I: \"a\\<in>G\"  \"b\\<in>G\"  \"a\\<cdot>c \\<in> G\"  \"b\\<cdot>c \\<in> G\"\n    and II: \"a\\<inverse>\\<cdot>b \\<in> H \\<union> {\\<one>}\"\n    using OrderedGroup_ZF_5_L1 group_op_closed \n    by auto\n  with A2 A4 have \"(a\\<cdot>c)\\<inverse>\\<cdot>(b\\<cdot>c) \\<in> H \\<union> {\\<one>}\"\n    using group0_4_L6D by simp\n  with A1 I show \"\\<langle>a\\<cdot>c,b\\<cdot>c\\<rangle> \\<in> r\" using  OrderedGroup_ZF_5_L1\n    by auto\n  with A2 A4 I show \"\\<langle>c\\<cdot>a,c\\<cdot>b\\<rangle> \\<in> r\"\n    using IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1494
    },
    "1342": {
        "type": "lemma",
        "text": "text\\<open>If $H\\subseteq G$ is closed under the group operation\n  $1\\notin H$ and for every $a\\in H$ we have either $a\\in H$ or \n  $a^{-1}\\in H$, then the relation \"$\\leq$\" defined by \n  $a\\leq b \\Leftrightarrow a^{-1}b \\in H$ orders the group $G$.\n  In such order $H$ may be the set of positive or nonnegative\n  elements.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"H\\<subseteq>G\"  \"H {is closed under} P\"\n  and A3: \"\\<forall>a\\<in>G. a\\<noteq>\\<one> \\<longrightarrow> (a\\<in>H) Xor (a\\<inverse>\\<in>H)\"\n  and A4: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  ",
        "using": [
            "refl_def",
            "OrderedGroup_ZF_5_L2",
            "OrderedGroup_ZF_5_L3",
            "IsPartOrder_def",
            "OrderedGroup_ZF_5_L4",
            "IsAnOrdGroup_def",
            "group3_def",
            "group3.OrderedGroup_ZF_1_L24",
            "inverse_in_group",
            "group_op_closed",
            "group0_2_L11",
            "Xor_def",
            "group0_2_L12",
            "IsTotal_def"
        ],
        "statement": "lemma (in group0) OrderedGroup_ZF_5_L5: \n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"H\\<subseteq>G\"  \"H {is closed under} P\"\n  and A3: \"\\<forall>a\\<in>G. a\\<noteq>\\<one> \\<longrightarrow> (a\\<in>H) Xor (a\\<inverse>\\<in>H)\"\n  and A4: \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  shows \n  \"IsAnOrdGroup(G,P,r)\"\n  \"r {is total on} G\"\n  \"Nonnegative(G,P,r) = PositiveSet(G,P,r) \\<union> {\\<one>}\"\n",
        "proof": "proof -\n  from groupAssum A2 A3 A4 have \n    \"IsAgroup(G,P)\"  \"r \\<subseteq> G\\<times>G\"  \"IsPartOrder(G,r)\"\n    using refl_def OrderedGroup_ZF_5_L2 OrderedGroup_ZF_5_L3\n      IsPartOrder_def by auto\n  moreover from A1 A4 have \n    \"\\<forall>g\\<in>G. \\<forall>a b. \\<langle> a,b\\<rangle> \\<in> r \\<longrightarrow> \\<langle>a\\<cdot>g,b\\<cdot>g\\<rangle> \\<in> r \\<and> \\<langle>g\\<cdot>a,g\\<cdot>b\\<rangle> \\<in> r\"\n    using OrderedGroup_ZF_5_L4 by blast\n  ultimately show \"IsAnOrdGroup(G,P,r)\" \n    using IsAnOrdGroup_def by simp\n  then show \"Nonnegative(G,P,r) = PositiveSet(G,P,r) \\<union> {\\<one>}\"\n    using group3_def group3.OrderedGroup_ZF_1_L24\n    by simp\n  { fix a b \n    assume T: \"a\\<in>G\"  \"b\\<in>G\"\n    then have T1: \"a\\<inverse>\\<cdot>b \\<in> G\"\n      using inverse_in_group group_op_closed by simp\n    { assume \"\\<langle> a,b\\<rangle> \\<notin> r\"\n      with A4 T have I: \"a\\<noteq>b\" and II: \"a\\<inverse>\\<cdot>b \\<notin> H\" \n\tby auto\n      from A3 T T1 I have \"(a\\<inverse>\\<cdot>b \\<in> H) Xor ((a\\<inverse>\\<cdot>b)\\<inverse> \\<in> H)\"\n\tusing group0_2_L11 by auto\n      with A4 T II have \"\\<langle> b,a\\<rangle> \\<in> r\"\n\tusing Xor_def group0_2_L12 by simp\n    } then have \"\\<langle> a,b\\<rangle> \\<in> r \\<or> \\<langle> b,a\\<rangle> \\<in> r\" by auto\n  } then show \"r {is total on} G\" using IsTotal_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1495
    },
    "1343": {
        "type": "lemma",
        "text": "text\\<open>If the set defined as in \\<open>OrderedGroup_ZF_5_L4\\<close> does not \n  contain the neutral element, then it is the positive set for the resulting\n  order.\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\"\n  and \"H\\<subseteq>G\" and \"\\<one> \\<notin> H\"\n  and \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  ",
        "using": [
            "assms",
            "group_inv_of_one",
            "group0_2_L2",
            "PositiveSet_def"
        ],
        "statement": "lemma (in group0) OrderedGroup_ZF_5_L6: \n  assumes \"P {is commutative on} G\"\n  and \"H\\<subseteq>G\" and \"\\<one> \\<notin> H\"\n  and \"r = {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> fst(p)\\<inverse>\\<cdot>snd(p) \\<in> H}\"\n  shows \"PositiveSet(G,P,r) = H\"\n  ",
        "proof": "using assms group_inv_of_one group0_2_L2 PositiveSet_def\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1496
    },
    "1344": {
        "type": "theorem",
        "text": "text\\<open>The next theorem rephrases lemmas \n  \\<open>OrderedGroup_ZF_5_L5\\<close> and \\<open>OrderedGroup_ZF_5_L6\\<close>\n  using the definition of the order from the positive set \n  \\<open>OrderFromPosSet\\<close>. To summarize, this is what it says:\n  Suppose that $H\\subseteq G$ is a set closed under that group operation\n  such that $1\\notin H$ and for every nonunit group element $a$ either $a\\in H$\n  or $a^{-1}\\in H$. Define the order as $a\\leq b$ iff $a=b$ or \n  $a^{-1}\\cdot b \\in H$. Then this order makes $G$ into a linearly ordered \n  group such $H$ is the set of positive elements (and then of course \n  $H \\cup \\{1\\}$ is the set of nonnegative elements).\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\"\n  and \"H\\<subseteq>G\"   \"H {is closed under} P\"   \"\\<one> \\<notin> H\"\n  and \"\\<forall>a\\<in>G. a\\<noteq>\\<one> \\<longrightarrow> (a\\<in>H) Xor (a\\<inverse>\\<in>H)\"\n  ",
        "using": [
            "assms",
            "OrderFromPosSet_def",
            "OrderedGroup_ZF_5_L5",
            "OrderedGroup_ZF_5_L6"
        ],
        "statement": "theorem (in group0) Group_ord_by_positive_set: \n  assumes \"P {is commutative on} G\"\n  and \"H\\<subseteq>G\"   \"H {is closed under} P\"   \"\\<one> \\<notin> H\"\n  and \"\\<forall>a\\<in>G. a\\<noteq>\\<one> \\<longrightarrow> (a\\<in>H) Xor (a\\<inverse>\\<in>H)\"\n  shows \n  \"IsAnOrdGroup(G,P,OrderFromPosSet(G,P,H))\"\n  \"OrderFromPosSet(G,P,H) {is total on} G\"\n  \"PositiveSet(G,P,OrderFromPosSet(G,P,H)) = H\"\n  \"Nonnegative(G,P,OrderFromPosSet(G,P,H)) = H \\<union> {\\<one>}\" \n  ",
        "proof": "using assms OrderFromPosSet_def OrderedGroup_ZF_5_L5 OrderedGroup_ZF_5_L6\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1498
    },
    "1345": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is just to see the definition of the odd extension\n  in the notation used in the \\<open>group1\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "OddExtension_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_6_L1:\n  shows \"f\\<degree> = f \\<union> {\\<langle>a, (f`(a\\<inverse>))\\<inverse>\\<rangle>. a \\<in> \\<sm>G\\<^sub>+} \\<union> {\\<langle>\\<one>,\\<one>\\<rangle>}\"\n  ",
        "proof": "using OddExtension_def by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1499
    },
    "1346": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma that states that from a function defined on \n  \\<open>G\\<^sub>+\\<close> with values in $G$ we have $(f(a^{-1}))^{-1}\\in G$.\\<close>\n",
        "assumes": "assumes \"f: G\\<^sub>+\\<rightarrow>G\" and \"a\\<in>\\<sm>G\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_1_L27",
            "apply_funtype",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_6_L2:\n  assumes \"f: G\\<^sub>+\\<rightarrow>G\" and \"a\\<in>\\<sm>G\\<^sub>+\"\n  shows \n  \"f`(a\\<inverse>) \\<in> G\"  \n  \"(f`(a\\<inverse>))\\<inverse> \\<in> G\"\n  ",
        "proof": "using assms OrderedGroup_ZF_1_L27 apply_funtype\n    OrderedGroup_ZF_1_L1 group0.inverse_in_group\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1500
    },
    "1347": {
        "type": "lemma",
        "text": "text\\<open>The main theorem about odd extensions. It basically says that the odd \n  extension of a function is what we want to to be.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"f: G\\<^sub>+\\<rightarrow>G\"\n  ",
        "using": [
            "OrderedGroup_ZF_6_L2",
            "OrdGroup_decomp2",
            "OrderedGroup_ZF_6_L1",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) odd_ext_props: \n  assumes A1: \"r {is total on} G\" and A2: \"f: G\\<^sub>+\\<rightarrow>G\"\n  shows \n  \"f\\<degree> : G \\<rightarrow> G\"\n  \"\\<forall>a\\<in>G\\<^sub>+. (f\\<degree>)`(a) = f`(a)\"\n  \"\\<forall>a\\<in>(\\<sm>G\\<^sub>+). (f\\<degree>)`(a) = (f`(a\\<inverse>))\\<inverse>\"\n  \"(f\\<degree>)`(\\<one>) = \\<one>\"\n",
        "proof": "proof -\n  from A1 A2 have I:\n    \"f: G\\<^sub>+\\<rightarrow>G\"\n    \"\\<forall>a\\<in>\\<sm>G\\<^sub>+. (f`(a\\<inverse>))\\<inverse> \\<in> G\"\n    \"G\\<^sub>+\\<inter>(\\<sm>G\\<^sub>+) = 0\"  \n    \"\\<one> \\<notin> G\\<^sub>+\\<union>(\\<sm>G\\<^sub>+)\"\n    \"f\\<degree> = f \\<union> {\\<langle>a, (f`(a\\<inverse>))\\<inverse>\\<rangle>. a \\<in> \\<sm>G\\<^sub>+} \\<union> {\\<langle>\\<one>,\\<one>\\<rangle>}\"\n    using OrderedGroup_ZF_6_L2 OrdGroup_decomp2 OrderedGroup_ZF_6_L1\n    by auto\n  then have \"f\\<degree>: G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+) \\<union> {\\<one>} \\<rightarrow>G\\<union>G\\<union>{\\<one>}\"\n    by (rule func1_1_L11E)\n  moreover from A1 have \n    \"G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+) \\<union> {\\<one>} = G\"\n    \"G\\<union>G\\<union>{\\<one>} = G\"\n    using OrdGroup_decomp2 OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by auto\n  ultimately show \"f\\<degree> : G \\<rightarrow> G\" by simp\n  from I show \"\\<forall>a\\<in>G\\<^sub>+. (f\\<degree>)`(a) = f`(a)\"\n    by (rule func1_1_L11E)\n  from I show \"\\<forall>a\\<in>(\\<sm>G\\<^sub>+). (f\\<degree>)`(a) = (f`(a\\<inverse>))\\<inverse>\"\n    by (rule func1_1_L11E)\n  from I show \"(f\\<degree>)`(\\<one>) = \\<one>\"\n    by (rule func1_1_L11E)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1501
    },
    "1348": {
        "type": "lemma",
        "text": "text\\<open>Odd extensions are odd, of course.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"f: G\\<^sub>+\\<rightarrow>G\"\n  and A3: \"a\\<in>G\"\n  ",
        "using": [
            "OrdGroup_decomp2",
            "OrderedGroup_ZF_1_L25",
            "odd_ext_props",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv",
            "OrderedGroup_ZF_1_L27",
            "OrderedGroup_ZF_6_L2",
            "group0.group_inv_of_one"
        ],
        "statement": "lemma (in group3) oddext_is_odd:\n  assumes A1: \"r {is total on} G\" and A2: \"f: G\\<^sub>+\\<rightarrow>G\"\n  and A3: \"a\\<in>G\"\n  shows \"(f\\<degree>)`(a\\<inverse>) = ((f\\<degree>)`(a))\\<inverse>\"\n",
        "proof": "proof -\n  from A1 A3 have \"a\\<in>G\\<^sub>+ \\<or> a \\<in> (\\<sm>G\\<^sub>+) \\<or> a=\\<one>\"\n    using OrdGroup_decomp2 by blast\n  moreover\n  { assume \"a\\<in>G\\<^sub>+\"  \n    with A1 A2 have \"a\\<inverse> \\<in> \\<sm>G\\<^sub>+\" and  \"(f\\<degree>)`(a) = f`(a)\"\n      using OrderedGroup_ZF_1_L25 odd_ext_props by auto\n    with A1 A2 have \n      \"(f\\<degree>)`(a\\<inverse>) = (f`((a\\<inverse>)\\<inverse>))\\<inverse>\"  and \"(f`(a))\\<inverse> = ((f\\<degree>)`(a))\\<inverse>\"\n      using odd_ext_props by auto\n    with A3 have \"(f\\<degree>)`(a\\<inverse>) = ((f\\<degree>)`(a))\\<inverse>\"\n      using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n      by simp } \n  moreover\n  { assume A4: \"a \\<in> \\<sm>G\\<^sub>+\"\n    with A1 A2  have \"a\\<inverse> \\<in> G\\<^sub>+\" and  \"(f\\<degree>)`(a) = (f`(a\\<inverse>))\\<inverse>\"\n      using OrderedGroup_ZF_1_L27 odd_ext_props\n      by auto\n    with A1 A2 A4 have \"(f\\<degree>)`(a\\<inverse>) = ((f\\<degree>)`(a))\\<inverse>\"\n      using odd_ext_props OrderedGroup_ZF_6_L2 \n\tOrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n      by simp }\n  moreover\n  { assume \"a = \\<one>\" \n    with A1 A2 have \"(f\\<degree>)`(a\\<inverse>) = ((f\\<degree>)`(a))\\<inverse>\"\n      using OrderedGroup_ZF_1_L1 group0.group_inv_of_one \n\todd_ext_props by simp\n  }\n  ultimately show \"(f\\<degree>)`(a\\<inverse>) = ((f\\<degree>)`(a))\\<inverse>\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1502
    },
    "1349": {
        "type": "lemma",
        "text": "text\\<open>Another way of saying that odd extensions are odd.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"f: G\\<^sub>+\\<rightarrow>G\"\n  and A3: \"a\\<in>G\"\n  ",
        "using": [
            "odd_ext_props",
            "oddext_is_odd",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_6_L2"
        ],
        "statement": "lemma (in group3) oddext_is_odd_alt:\n  assumes A1: \"r {is total on} G\" and A2: \"f: G\\<^sub>+\\<rightarrow>G\"\n  and A3: \"a\\<in>G\"\n  shows \"((f\\<degree>)`(a\\<inverse>))\\<inverse> = (f\\<degree>)`(a)\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"f\\<degree> : G \\<rightarrow> G\"\n    \"\\<forall>a\\<in>G. (f\\<degree>)`(a\\<inverse>) = ((f\\<degree>)`(a))\\<inverse>\"\n    using odd_ext_props oddext_is_odd by auto\n  then have \"\\<forall>a\\<in>G. ((f\\<degree>)`(a\\<inverse>))\\<inverse> = (f\\<degree>)`(a)\"\n    using OrderedGroup_ZF_1_L1 group0.group0_6_L2 by simp\n  with A3 show \"((f\\<degree>)`(a\\<inverse>))\\<inverse> = (f\\<degree>)`(a)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1503
    },
    "1350": {
        "type": "lemma",
        "text": "text\\<open>If an image of a set by a function with infinite positive limit \n  is bounded above, then the set itself is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"f:G\\<rightarrow>G\" and \n  A4: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and \n  A5: \"A\\<subseteq>G\" and \n  A6: \"IsBoundedAbove(f``(A),r)\"\n  ",
        "using": [
            "IsBoundedAbove_def",
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L8",
            "func_imagedef",
            "OrderedGroup_ZF_2_L2A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_7_L1:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"f:G\\<rightarrow>G\" and \n  A4: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and \n  A5: \"A\\<subseteq>G\" and \n  A6: \"IsBoundedAbove(f``(A),r)\"\n  shows \"IsBoundedAbove(A,r)\"\n",
        "proof": "proof -\n  { assume \"\\<not>IsBoundedAbove(A,r)\"\n    then have I: \"\\<forall>u. \\<exists>x\\<in>A. \\<not>(x\\<lsq>u)\"\n      using IsBoundedAbove_def by auto\n    have \"\\<forall>a\\<in>G. \\<exists>y\\<in>f``(A). a\\<lsq>y\"\n    proof -\n      { fix a assume \"a\\<in>G\" \n\twith A4 obtain b where \n\t  II: \"b\\<in>G\\<^sub>+\" and III: \"\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\"\n\t  by auto\n\tfrom I obtain x where IV: \"x\\<in>A\" and \"\\<not>(x\\<lsq>b)\"\n\t  by auto\n\twith A1 A5 II have \n\t  \"r {is total on} G\"\n\t  \"x\\<in>G\"  \"b\\<in>G\"  \"\\<not>(x\\<lsq>b)\"\n\t  using PositiveSet_def by auto\n\twith III have \"a \\<lsq> f`(x)\"\n\t  using OrderedGroup_ZF_1_L8 by blast\n\twith A3 A5 IV have \"\\<exists>y\\<in>f``(A). a\\<lsq>y\"\n\t  using func_imagedef by auto\n      } thus ?thesis by simp\n    qed\n    with A1 A2 A6 have False using OrderedGroup_ZF_2_L2A\n      by simp\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1504
    },
    "1351": {
        "type": "lemma",
        "text": "text\\<open>If an image of a set defined by separation \n  by a function with infinite positive limit \n  is bounded above, then the set itself is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"X\\<noteq>0\" and A4: \"f:G\\<rightarrow>G\" and \n  A5: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> f`(y)\" and \n  A6: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> f`(b(x)) \\<lsq> U\"\n  ",
        "using": [
            "func_imagedef",
            "OrderedGroup_ZF_7_L1",
            "IsBoundedAbove_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_7_L2:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"X\\<noteq>0\" and A4: \"f:G\\<rightarrow>G\" and \n  A5: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> f`(y)\" and \n  A6: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> f`(b(x)) \\<lsq> U\"\n  shows \"\\<exists>u.\\<forall>x\\<in>X. b(x) \\<lsq> u\"\n",
        "proof": "proof -\n  let ?A = \"{b(x). x\\<in>X}\"\n  from A6 have I: \"?A\\<subseteq>G\" by auto\n  moreover note assms\n  moreover have \"IsBoundedAbove(f``(?A),r)\"\n  proof -\n    from A4 A6 I have \"\\<forall>z\\<in>f``(?A). \\<langle>z,U\\<rangle> \\<in> r\"\n      using func_imagedef by simp\n    then show \"IsBoundedAbove(f``(?A),r)\"\n      by (rule Order_ZF_3_L10)\n  qed\n  ultimately have \"IsBoundedAbove(?A,r)\" using OrderedGroup_ZF_7_L1\n    by simp\n  with A3 have \"\\<exists>u.\\<forall>y\\<in>?A. y \\<lsq> u\"\n    using IsBoundedAbove_def by simp\n  then show \"\\<exists>u.\\<forall>x\\<in>X. b(x) \\<lsq> u\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1505
    },
    "1352": {
        "type": "lemma",
        "text": "text\\<open>If the image of a set defined by separation \n  by a function with infinite negative limit \n  is bounded below, then the set itself is bounded above.\n  This is dual to \\<open>OrderedGroup_ZF_7_L2\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"X\\<noteq>0\" and A4: \"f:G\\<rightarrow>G\" and \n  A5: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(y\\<inverse>) \\<lsq> a\" and \n  A6: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> L \\<lsq> f`(b(x))\"\n  ",
        "using": [
            "IsAnOrdGroup_def",
            "group0_2_T2",
            "func1_1_L18",
            "comp_fun",
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "OrderedGroup_ZF_1_L5AD",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L5",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_7_L3:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"X\\<noteq>0\" and A4: \"f:G\\<rightarrow>G\" and \n  A5: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(y\\<inverse>) \\<lsq> a\" and \n  A6: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> L \\<lsq> f`(b(x))\"\n  shows \"\\<exists>l.\\<forall>x\\<in>X. l \\<lsq> b(x)\"\n",
        "proof": "proof -\n  let ?g = \"GroupInv(G,P) O f O GroupInv(G,P)\"\n  from ordGroupAssum have I: \"GroupInv(G,P) : G\\<rightarrow>G\"\n    using IsAnOrdGroup_def group0_2_T2 by simp\n  with A4 have II: \"\\<forall>x\\<in>G. ?g`(x) = (f`(x\\<inverse>))\\<inverse>\"\n    using func1_1_L18 by simp\n  note A1 A2 A3\n  moreover from A4 I have \"?g : G\\<rightarrow>G\"\n    using comp_fun by blast\n  moreover have \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> ?g`(y)\"\n  proof -\n  { fix a assume A7: \"a\\<in>G\"\n    then have \"a\\<inverse> \\<in> G\"\n      using OrderedGroup_ZF_1_L1 group0.inverse_in_group\n      by simp\n    with A5 obtain b where \n      III: \"b\\<in>G\\<^sub>+\" and \"\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(y\\<inverse>) \\<lsq> a\\<inverse>\"\n      by auto\n    with II A7 have \"\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> ?g`(y)\"\n      using OrderedGroup_ZF_1_L5AD OrderedGroup_ZF_1_L4\n      by simp\n    with III have \"\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> ?g`(y)\"\n      by auto\n  } then show \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> ?g`(y)\"\n    by simp\n  qed\n  moreover have \"\\<forall>x\\<in>X. b(x)\\<inverse> \\<in> G \\<and> ?g`(b(x)\\<inverse>) \\<lsq> L\\<inverse>\"\n  proof-\n    { fix x assume \"x\\<in>X\"\n      with A6 have \n\tT: \"b(x) \\<in> G\"  \"b(x)\\<inverse> \\<in> G\" and \"L \\<lsq> f`(b(x))\"\n\tusing OrderedGroup_ZF_1_L1 group0.inverse_in_group\n\tby auto\n      then have \"(f`(b(x)))\\<inverse> \\<lsq> L\\<inverse>\"\n\tusing OrderedGroup_ZF_1_L5 by simp\n      moreover from II T have \"(f`(b(x)))\\<inverse> =  ?g`(b(x)\\<inverse>)\"\n\tusing OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n\tby simp\n      ultimately have \"?g`(b(x)\\<inverse>) \\<lsq> L\\<inverse>\" by simp\n      with T have \"b(x)\\<inverse> \\<in> G \\<and> ?g`(b(x)\\<inverse>) \\<lsq> L\\<inverse>\"\n\tby simp\n    } then show \"\\<forall>x\\<in>X. b(x)\\<inverse> \\<in> G \\<and> ?g`(b(x)\\<inverse>) \\<lsq> L\\<inverse>\"\n      by simp\n  qed\n  ultimately have \"\\<exists>u.\\<forall>x\\<in>X. (b(x))\\<inverse> \\<lsq> u\"\n    by (rule OrderedGroup_ZF_7_L2)\n  then have \"\\<exists>u.\\<forall>x\\<in>X. u\\<inverse> \\<lsq> (b(x)\\<inverse>)\\<inverse>\"\n    using OrderedGroup_ZF_1_L5 by auto\n  with A6 show \"\\<exists>l.\\<forall>x\\<in>X. l \\<lsq> b(x)\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1506
    },
    "1353": {
        "type": "lemma",
        "text": "text\\<open>The next lemma combines \\<open>OrderedGroup_ZF_7_L2\\<close> and \n  \\<open>OrderedGroup_ZF_7_L3\\<close> to show that if an image of a set \n  defined by separation by a function with infinite limits is bounded,\n  then the set itself i bounded.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"X\\<noteq>0\" and A4: \"f:G\\<rightarrow>G\" and \n  A5: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> f`(y)\" and \n  A6: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(y\\<inverse>) \\<lsq> a\" and \n  A7: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> L \\<lsq> f`(b(x)) \\<and> f`(b(x)) \\<lsq> U\"\n",
        "using": [
            "OrderedGroup_ZF_3_L10"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_7_L4:\n  assumes A1: \"r {is total on} G\" and A2: \"G \\<noteq> {\\<one>}\" and\n  A3: \"X\\<noteq>0\" and A4: \"f:G\\<rightarrow>G\" and \n  A5: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> a \\<lsq> f`(y)\" and \n  A6: \"\\<forall>a\\<in>G.\\<exists>b\\<in>G\\<^sub>+.\\<forall>y. b\\<lsq>y \\<longrightarrow> f`(y\\<inverse>) \\<lsq> a\" and \n  A7: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> L \\<lsq> f`(b(x)) \\<and> f`(b(x)) \\<lsq> U\"\nshows \"\\<exists>M.\\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> M\"\n",
        "proof": "proof -\n  from A7 have \n    I: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> f`(b(x)) \\<lsq> U\" and\n    II: \"\\<forall>x\\<in>X. b(x) \\<in> G \\<and> L \\<lsq> f`(b(x))\"\n    by auto\n  from A1 A2 A3 A4 A5 I have \"\\<exists>u.\\<forall>x\\<in>X. b(x) \\<lsq> u\"\n    by (rule OrderedGroup_ZF_7_L2)\n  moreover from  A1 A2 A3 A4 A6 II have \"\\<exists>l.\\<forall>x\\<in>X. l \\<lsq> b(x)\"\n    by (rule OrderedGroup_ZF_7_L3)\n  ultimately have \"\\<exists>u l. \\<forall>x\\<in>X. l\\<lsq>b(x) \\<and> b(x) \\<lsq> u\"\n    by auto\n  with A1 have \"\\<exists>u l.\\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> GreaterOf(r,\\<bar>l\\<bar>,\\<bar>u\\<bar>)\"\n    using OrderedGroup_ZF_3_L10 by blast\n  then show \"\\<exists>M.\\<forall>x\\<in>X. \\<bar>b(x)\\<bar> \\<lsq> M\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1507
    },
    "1354": {
        "type": "definition",
        "text": "text\\<open> A triple $(G,A,r)$ is an ordered loop if $(G,A)$ is a loop and $r$ is a relation\n  on $G$ (i.e. a subset of $G\\times G$ with is a partial order and for all elements $x,y,z \\in G$\n  the condition $\\langle x,y\\rangle \\in r$ is equivalent to both\n  $\\langle A\\langle x,z\\rangle, A\\langle x,z\\rangle\\rangle \\in r$ and \n  $\\langle A\\langle z,x\\rangle, A\\langle z,x\\rangle\\rangle \\in r$. \n  This looks a bit awkward in the basic set theory notation, but using the additive notation \n  for the group operation and $x\\leq y$ to instead of $\\langle x,y \\rangle \\in r$ this just means that\n  $x\\leq y$ if and only if $x+z\\leq y+z$ and $x\\leq y$ if and only if $z+x\\leq z+y$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAnOrdLoop(L,A,r) \\<equiv> \n  IsAloop(L,A) \\<and> r\\<subseteq>L\\<times>L \\<and> IsPartOrder(L,r) \\<and> (\\<forall>x\\<in>L. \\<forall>y\\<in>L. \\<forall>z\\<in>L. \n  ((\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>A`\\<langle> x,z\\<rangle>,A`\\<langle>y,z\\<rangle>\\<rangle> \\<in> r) \\<and> (\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>A`\\<langle>z,x\\<rangle>,A`\\<langle>z,y\\<rangle>\\<rangle> \\<in> r )))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1508
    },
    "1355": {
        "type": "definition",
        "text": "text\\<open>We define the set of nonnegative elements  in the obvious way as $L^+ =\\{x\\in L: 0 \\leq x\\}$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Nonnegative(L,A,r) \\<equiv> {x\\<in>L. \\<langle> TheNeutralElement(L,A),x\\<rangle> \\<in> r}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1509
    },
    "1356": {
        "type": "lemma",
        "text": "text\\<open>In this context $x \\leq y$ implies that both $x$ and $y$ belong\n  to $L$.\\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" ",
        "using": [
            "ordLoopAssum",
            "assms",
            "IsAnOrdLoop_def"
        ],
        "statement": "lemma (in loop1) lsq_members: assumes \"x\\<lsq>y\" shows \"x\\<in>L\" and \"y\\<in>L\" \n  ",
        "proof": "using ordLoopAssum assms IsAnOrdLoop_def by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1511
    },
    "1357": {
        "type": "lemma",
        "text": "text\\<open>In this context $x < y$ implies that both $x$ and $y$ belong\n  to $L$.\\<close>\n",
        "assumes": "assumes \"x\\<ls>y\" ",
        "using": [
            "ordLoopAssum",
            "assms",
            "IsAnOrdLoop_def"
        ],
        "statement": "lemma (in loop1) less_members: assumes \"x\\<ls>y\" shows \"x\\<in>L\" and \"y\\<in>L\" \n  ",
        "proof": "using ordLoopAssum assms IsAnOrdLoop_def by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1512
    },
    "1358": {
        "type": "lemma",
        "text": "text\\<open> In an ordered loop the order is translation invariant. \\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" \"z\\<in>L\"\n  ",
        "using": [
            "lsq_members",
            "IsAnOrdLoop_def"
        ],
        "statement": "lemma (in loop1) ord_trans_inv: assumes \"x\\<lsq>y\" \"z\\<in>L\"\n  shows \"x\\<ra>z \\<lsq> y\\<ra>z\" and \"z\\<ra>x \\<lsq> z\\<ra>y\"\n",
        "proof": "proof -\n  from ordLoopAssum assms have \n    \"(\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>A`\\<langle> x,z\\<rangle>,A`\\<langle>y,z\\<rangle>\\<rangle> \\<in> r) \\<and> (\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>A`\\<langle>z,x\\<rangle>,A`\\<langle>z,y\\<rangle>\\<rangle> \\<in> r )\"\n    using lsq_members unfolding IsAnOrdLoop_def by blast\n  with assms(1) show \"x\\<ra>z \\<lsq> y\\<ra>z\" and \"z\\<ra>x \\<lsq> z\\<ra>y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1513
    },
    "1359": {
        "type": "lemma",
        "text": "text\\<open> In an ordered loop the strict order is translation invariant. \\<close>\n",
        "assumes": "assumes \"x\\<ls>y\" \"z\\<in>L\"\n  ",
        "using": [
            "ord_trans_inv",
            "less_members",
            "qg_cancel_right",
            "qg_cancel_left"
        ],
        "statement": "lemma (in loop1) strict_ord_trans_inv: assumes \"x\\<ls>y\" \"z\\<in>L\"\n  shows \"x\\<ra>z \\<ls> y\\<ra>z\" and \"z\\<ra>x \\<ls> z\\<ra>y\"\n",
        "proof": "proof -\n  from assms have \"x\\<ra>z \\<lsq> y\\<ra>z\" and \"z\\<ra>x \\<lsq> z\\<ra>y\"\n    using ord_trans_inv by auto\n  moreover have \"x\\<ra>z \\<noteq> y\\<ra>z\" and \"z\\<ra>x \\<noteq> z\\<ra>y\"\n  proof -\n    { assume \"x\\<ra>z = y\\<ra>z\"\n      with assms have \"x=y\" using less_members qg_cancel_right by blast\n      with assms(1) have False by simp\n    } thus \"x\\<ra>z \\<noteq> y\\<ra>z\" by auto\n    { assume \"z\\<ra>x = z\\<ra>y\"\n      with assms have \"x=y\" using less_members qg_cancel_left by blast\n      with assms(1) have False by simp\n    } thus \"z\\<ra>x \\<noteq> z\\<ra>y\" by auto\n  qed\n  ultimately show \"x\\<ra>z \\<ls> y\\<ra>z\" and \"z\\<ra>x \\<ls> z\\<ra>y\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1514
    },
    "1360": {
        "type": "lemma",
        "text": "text\\<open>We can cancel an element from both sides of an inequality on the right side. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"x\\<ra>z \\<lsq> y\\<ra>z\" \n  ",
        "using": [],
        "statement": "lemma (in loop1) ineq_cancel_right: assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"x\\<ra>z \\<lsq> y\\<ra>z\" \n  shows  \"x\\<lsq>y\"\n",
        "proof": "proof -\n  from ordLoopAssum assms(1,2,3) have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>A`\\<langle> x,z\\<rangle>,A`\\<langle>y,z\\<rangle>\\<rangle> \\<in> r\"\n    unfolding IsAnOrdLoop_def by blast\n  with assms(4) show \"x\\<lsq>y\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1515
    },
    "1361": {
        "type": "lemma",
        "text": "text\\<open>We can cancel an element from both sides of a strict inequality on the right side. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"x\\<ra>z \\<ls> y\\<ra>z\" \n  ",
        "using": [
            "assms",
            "ineq_cancel_right"
        ],
        "statement": "lemma (in loop1) strict_ineq_cancel_right: assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"x\\<ra>z \\<ls> y\\<ra>z\" \n  shows  \"x\\<ls>y\"\n  ",
        "proof": "using assms ineq_cancel_right by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1516
    },
    "1362": {
        "type": "lemma",
        "text": "text\\<open>We can cancel an element from both sides of an inequality on the left side. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"z\\<ra>x \\<lsq> z\\<ra>y\" \n  ",
        "using": [],
        "statement": "lemma (in loop1) ineq_cancel_left: assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"z\\<ra>x \\<lsq> z\\<ra>y\" \n  shows  \"x\\<lsq>y\"\n",
        "proof": "proof -\n  from ordLoopAssum assms(1,2,3) have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>A`\\<langle>z,x\\<rangle>,A`\\<langle>z,y\\<rangle>\\<rangle> \\<in> r\"\n    unfolding IsAnOrdLoop_def by blast\n  with assms(4) show \"x\\<lsq>y\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1517
    },
    "1363": {
        "type": "lemma",
        "text": "text\\<open>We can cancel an element from both sides of a strict inequality on the left side. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"z\\<ra>x \\<ls> z\\<ra>y\" \n  ",
        "using": [
            "assms",
            "ineq_cancel_left"
        ],
        "statement": "lemma (in loop1) strict_ineq_cancel_left: \n  assumes \"x\\<in>L\" \"y\\<in>L\" \"z\\<in>L\" and \"z\\<ra>x \\<ls> z\\<ra>y\" \n  shows  \"x\\<ls>y\"\n  ",
        "proof": "using assms ineq_cancel_left by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1518
    },
    "1364": {
        "type": "lemma",
        "text": "text\\<open>The definition of the nonnegative set in the notation used in the \\<open>loop1\\<close> locale: \\<close>\n",
        "assumes": "",
        "using": [
            "ordLoopAssum",
            "IsAnOrdLoop_def",
            "Nonnegative_def"
        ],
        "statement": "lemma (in loop1) nonneg_definition: \n  shows \"x \\<in> L\\<^sup>+ \\<longleftrightarrow> \\<zero> \\<lsq> x\" ",
        "proof": "using ordLoopAssum IsAnOrdLoop_def Nonnegative_def by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1519
    },
    "1365": {
        "type": "lemma",
        "text": "text\\<open>The nonnegative set is contained in the loop.\\<close>\n",
        "assumes": "",
        "using": [
            "Nonnegative_def"
        ],
        "statement": "lemma (in loop1) nonneg_subset: shows \"L\\<^sup>+ \\<subseteq> L\"\n  ",
        "proof": "using Nonnegative_def by auto \n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1520
    },
    "1366": {
        "type": "lemma",
        "text": "text\\<open>The positive set is contained in the loop.\\<close>\n",
        "assumes": "",
        "using": [
            "PositiveSet_def"
        ],
        "statement": "lemma (in loop1) positive_subset: shows \"L\\<^sub>+ \\<subseteq> L\"\n  ",
        "proof": "using PositiveSet_def by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1521
    },
    "1367": {
        "type": "lemma",
        "text": "text\\<open>The definition of the positive set in the notation used in the \\<open>loop1\\<close> locale: \\<close>\n",
        "assumes": "",
        "using": [
            "ordLoopAssum",
            "IsAnOrdLoop_def",
            "PositiveSet_def"
        ],
        "statement": "lemma (in loop1) posset_definition: \n  shows \"x \\<in> L\\<^sub>+ \\<longleftrightarrow> (\\<zero>\\<lsq>x \\<and> x\\<noteq>\\<zero>)\" \n  ",
        "proof": "using ordLoopAssum IsAnOrdLoop_def PositiveSet_def by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1522
    },
    "1368": {
        "type": "lemma",
        "text": "text\\<open>Another form of the definition of the positive set in the notation used in the \\<open>loop1\\<close> locale: \\<close>\n",
        "assumes": "",
        "using": [
            "ordLoopAssum",
            "IsAnOrdLoop_def",
            "PositiveSet_def"
        ],
        "statement": "lemma (in loop1) posset_definition1: \n  shows \"x \\<in> L\\<^sub>+ \\<longleftrightarrow> \\<zero>\\<ls>x\" \n  ",
        "proof": "using ordLoopAssum IsAnOrdLoop_def PositiveSet_def by auto\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1523
    },
    "1369": {
        "type": "lemma",
        "text": "text\\<open> The order in an ordered loop is antisymmeric. \\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" and \"y\\<lsq>x\"\n  ",
        "using": [],
        "statement": "lemma (in loop1) loop_ord_antisym: assumes \"x\\<lsq>y\" and \"y\\<lsq>x\"\n  shows \"x=y\"\n",
        "proof": "proof -\n  from ordLoopAssum assms have \"antisym(r)\" \"\\<langle>x,y\\<rangle> \\<in> r\" \"\\<langle>y,x\\<rangle> \\<in> r\" \n    unfolding IsAnOrdLoop_def IsPartOrder_def by auto\n  then show \"x=y\" by (rule Fol1_L4)\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1524
    },
    "1370": {
        "type": "lemma",
        "text": "text\\<open> The loop order is transitive. \\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" and \"y\\<lsq>z\" ",
        "using": [],
        "statement": "lemma (in loop1) loop_ord_trans: assumes \"x\\<lsq>y\" and \"y\\<lsq>z\" shows \"x\\<lsq>z\"\n",
        "proof": "proof - \n  from ordLoopAssum assms have \"trans(r)\" and \"\\<langle>x,y\\<rangle> \\<in> r \\<and> \\<langle>y,z\\<rangle> \\<in> r\"\n    unfolding IsAnOrdLoop_def IsPartOrder_def by auto\n  then have \"\\<langle>x,z\\<rangle> \\<in> r\" by (rule Fol1_L3)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1525
    },
    "1371": {
        "type": "lemma",
        "text": "text\\<open> A form of mixed transitivity for the strict order: \\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" and \"y\\<ls>z\"\n  ",
        "using": [
            "loop_ord_antisym"
        ],
        "statement": "lemma (in loop1) loop_strict_ord_trans: assumes \"x\\<lsq>y\" and \"y\\<ls>z\"\n  shows \"x\\<ls>z\"\n",
        "proof": "proof -\n  from assms have \"x\\<lsq>y\" and \"y\\<lsq>z\" by auto\n  then have \"x\\<lsq>z\" by (rule loop_ord_trans)\n  with assms show \"x\\<ls>z\" using loop_ord_antisym by auto\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1526
    },
    "1372": {
        "type": "lemma",
        "text": "text\\<open> Another form of mixed transitivity for the strict order: \\<close>\n",
        "assumes": "assumes \"x\\<ls>y\" and \"y\\<lsq>z\"\n  ",
        "using": [
            "loop_ord_antisym"
        ],
        "statement": "lemma (in loop1) loop_strict_ord_trans1: assumes \"x\\<ls>y\" and \"y\\<lsq>z\"\n  shows \"x\\<ls>z\"\n",
        "proof": "proof -\n  from assms have \"x\\<lsq>y\" and \"y\\<lsq>z\" by auto\n  then have \"x\\<lsq>z\" by (rule loop_ord_trans)\n  with assms show \"x\\<ls>z\" using loop_ord_antisym by auto\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1527
    },
    "1373": {
        "type": "lemma",
        "text": "text\\<open> Yet another form of mixed transitivity for the strict order: \\<close>\n",
        "assumes": "assumes \"x\\<ls>y\" and \"y\\<ls>z\"\n  ",
        "using": [
            "loop_ord_antisym"
        ],
        "statement": "lemma (in loop1) loop_strict_ord_trans2: assumes \"x\\<ls>y\" and \"y\\<ls>z\"\n  shows \"x\\<ls>z\"\n",
        "proof": "proof -\n  from assms have \"x\\<lsq>y\" and \"y\\<lsq>z\" by auto\n  then have \"x\\<lsq>z\" by (rule loop_ord_trans)\n  with assms show \"x\\<ls>z\" using loop_ord_antisym by auto\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1528
    },
    "1374": {
        "type": "lemma",
        "text": "text\\<open> We can move an element to the other side of an inequality. Well, not exactly, but\n  our notation creates an illusion to that effect. \\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" \n  ",
        "using": [
            "lsq_members",
            "neut_props_loop(1)",
            "lrdiv_props(2,5)",
            "neut_props_loop(2)",
            "lrdiv_props(6)",
            "ineq_cancel_left",
            "nonneg_definition",
            "lrdiv_props(3)",
            "ineq_cancel_right"
        ],
        "statement": "lemma (in loop1) lsq_other_side: assumes \"x\\<lsq>y\" \n  shows \"\\<zero> \\<lsq> \\<rm>x\\<ad>y\"  \"(\\<rm>x\\<ad>y) \\<in> L\\<^sup>+\" \"\\<zero> \\<lsq> y\\<rs>x\" \"(y\\<rs>x) \\<in> L\\<^sup>+\"\n",
        "proof": "proof -\n  from assms have \"x\\<in>L\" \"y\\<in>L\" \"\\<zero>\\<in>L\" \"(\\<rm>x\\<ad>y) \\<in> L\" \"(y\\<rs>x) \\<in> L\" \n    using lsq_members neut_props_loop(1) lrdiv_props(2,5) by auto\n  then have \"x = x\\<ra>\\<zero>\" and \"y = x\\<ra>(\\<rm>x\\<ad>y)\" using neut_props_loop(2) lrdiv_props(6)\n    by auto\n  with assms have \"x\\<ra>\\<zero> \\<lsq> x\\<ra>(\\<rm>x\\<ad>y)\" by simp\n  with \\<open>x\\<in>L\\<close> \\<open>\\<zero>\\<in>L\\<close> \\<open>(\\<rm>x\\<ad>y) \\<in> L\\<close> show \"\\<zero> \\<lsq> \\<rm>x\\<ad>y\" using ineq_cancel_left\n    by simp\n  then show \"(\\<rm>x\\<ad>y) \\<in> L\\<^sup>+\" using nonneg_definition by simp\n  from \\<open>x\\<in>L\\<close> \\<open>y\\<in>L\\<close> have \"x = \\<zero>\\<ra>x\" and \"y = (y\\<rs>x)\\<ra>x\"\n    using neut_props_loop(2) lrdiv_props(3) by auto\n  with assms have \"\\<zero>\\<ra>x \\<lsq> (y\\<rs>x)\\<ra>x\" by simp\n  with \\<open>x\\<in>L\\<close> \\<open>\\<zero>\\<in>L\\<close> \\<open>(y\\<rs>x) \\<in> L\\<close> show \"\\<zero> \\<lsq> y\\<rs>x\" using ineq_cancel_right\n    by simp\n  then show \"(y\\<rs>x) \\<in> L\\<^sup>+\" using  nonneg_definition by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1529
    },
    "1375": {
        "type": "lemma",
        "text": "text\\<open> We can move an element to the other side of a strict inequality. \\<close>\n",
        "assumes": "assumes \"x\\<ls>y\" \n  ",
        "using": [
            "lsq_members",
            "neut_props_loop(1)",
            "lrdiv_props(2,5)",
            "neut_props_loop(2)",
            "lrdiv_props(6)",
            "strict_ineq_cancel_left",
            "posset_definition1",
            "lrdiv_props(3)",
            "strict_ineq_cancel_right"
        ],
        "statement": "lemma (in loop1) ls_other_side: assumes \"x\\<ls>y\" \n  shows \"\\<zero> \\<ls> \\<rm>x\\<ad>y\"  \"(\\<rm>x\\<ad>y) \\<in> L\\<^sub>+\" \"\\<zero> \\<ls> y\\<rs>x\" \"(y\\<rs>x) \\<in> L\\<^sub>+\"\n",
        "proof": "proof -\n  from assms have \"x\\<in>L\" \"y\\<in>L\" \"\\<zero>\\<in>L\" \"(\\<rm>x\\<ad>y) \\<in> L\" \"(y\\<rs>x) \\<in> L\" \n    using lsq_members neut_props_loop(1) lrdiv_props(2,5) by auto\n  then have \"x = x\\<ra>\\<zero>\" and \"y = x\\<ra>(\\<rm>x\\<ad>y)\" using neut_props_loop(2) lrdiv_props(6)\n    by auto\n  with assms have \"x\\<ra>\\<zero> \\<ls> x\\<ra>(\\<rm>x\\<ad>y)\" by simp\n  with \\<open>x\\<in>L\\<close> \\<open>\\<zero>\\<in>L\\<close> \\<open>(\\<rm>x\\<ad>y) \\<in> L\\<close> show \"\\<zero> \\<ls> \\<rm>x\\<ad>y\" using strict_ineq_cancel_left\n    by simp\n  then show \"(\\<rm>x\\<ad>y) \\<in> L\\<^sub>+\" using posset_definition1 by simp\n  from \\<open>x\\<in>L\\<close> \\<open>y\\<in>L\\<close> have \"x = \\<zero>\\<ra>x\" and \"y = (y\\<rs>x)\\<ra>x\"\n    using neut_props_loop(2) lrdiv_props(3) by auto\n  with assms have \"\\<zero>\\<ra>x \\<ls> (y\\<rs>x)\\<ra>x\" by simp\n  with \\<open>x\\<in>L\\<close> \\<open>\\<zero>\\<in>L\\<close> \\<open>(y\\<rs>x) \\<in> L\\<close> show \"\\<zero> \\<ls> y\\<rs>x\" using strict_ineq_cancel_right\n    by simp\n  then show \"(y\\<rs>x) \\<in> L\\<^sub>+\" using posset_definition1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1530
    },
    "1376": {
        "type": "lemma",
        "text": "text\\<open>We can add sides of inequalities.\\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" \"z\\<lsq>t\" \n  ",
        "using": [
            "lsq_members(1)",
            "ord_trans_inv(1)",
            "lsq_members(2)",
            "ord_trans_inv(2)",
            "loop_ord_trans"
        ],
        "statement": "lemma (in loop1) add_ineq: assumes \"x\\<lsq>y\" \"z\\<lsq>t\" \n  shows \"x\\<ra>z \\<lsq> y\\<ra>t\"\n",
        "proof": "proof -\n  from assms have \"x\\<ra>z \\<lsq> y\\<ra>z\" \n    using lsq_members(1) ord_trans_inv(1) by simp\n  with assms show ?thesis using lsq_members(2) ord_trans_inv(2) loop_ord_trans\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1531
    },
    "1377": {
        "type": "lemma",
        "text": "text\\<open>We can add sides of strict inequalities. The proof uses a lemma that\n  relies on the antisymmetry of the order relation.\\<close>\n",
        "assumes": "assumes \"x\\<ls>y\" \"z\\<ls>t\" \n  ",
        "using": [
            "less_members(1)",
            "strict_ord_trans_inv(1)",
            "less_members(2)",
            "strict_ord_trans_inv(2)"
        ],
        "statement": "lemma (in loop1) add_ineq_strict: assumes \"x\\<ls>y\" \"z\\<ls>t\" \n  shows \"x\\<ra>z \\<ls> y\\<ra>t\"\n",
        "proof": "proof -\n  from assms have \"x\\<ra>z \\<ls> y\\<ra>z\" \n    using less_members(1) strict_ord_trans_inv(1) by auto\n  moreover from assms have \"y\\<ra>z \\<ls> y\\<ra>t\"\n    using less_members(2) strict_ord_trans_inv(2) by auto\n  ultimately show ?thesis by (rule loop_strict_ord_trans2)\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1532
    },
    "1378": {
        "type": "lemma",
        "text": "text\\<open>We can add sides of inequalities one of which is strict. \\<close>\n",
        "assumes": "assumes \"x\\<lsq>y\" \"z\\<ls>t\" \n  ",
        "using": [
            "less_members(1)",
            "ord_trans_inv(1)",
            "lsq_members(2)",
            "strict_ord_trans_inv(2)",
            "loop_strict_ord_trans",
            "lsq_members(1)",
            "strict_ord_trans_inv(1)",
            "less_members(2)",
            "ord_trans_inv(2)",
            "loop_strict_ord_trans1"
        ],
        "statement": "lemma (in loop1) add_ineq_strict1: assumes \"x\\<lsq>y\" \"z\\<ls>t\" \n  shows \"x\\<ra>z \\<ls> y\\<ra>t\" and \"z\\<ra>x \\<ls> t\\<ra>y\" \n",
        "proof": "proof -\n    from assms have \"x\\<ra>z \\<lsq> y\\<ra>z\" \n      using less_members(1) ord_trans_inv(1) by auto\n    with assms show \"x\\<ra>z \\<ls> y\\<ra>t\"\n      using lsq_members(2) strict_ord_trans_inv(2) loop_strict_ord_trans\n      by blast\n    from assms have \"z\\<ra>x \\<ls> t\\<ra>x\"\n      using lsq_members(1) strict_ord_trans_inv(1) by simp\n    with assms show \"z\\<ra>x \\<ls> t\\<ra>y\"\n      using less_members(2) ord_trans_inv(2) loop_strict_ord_trans1\n      by blast\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1533
    },
    "1379": {
        "type": "lemma",
        "text": "text\\<open>Subtracting a positive element decreases the value. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" \"\\<zero>\\<ls>y\"\n  ",
        "using": [
            "less_members(2)",
            "ordLoopAssum",
            "IsAnOrdLoop_def",
            "IsPartOrder_def",
            "refl_def",
            "add_ineq_strict1(1)",
            "neut_props_loop(2)",
            "lrdiv_props(3)",
            "lrdiv_props(2)",
            "strict_ineq_cancel_right",
            "add_ineq_strict1(2)",
            "lrdiv_props(6)",
            "lrdiv_props(5)",
            "strict_ineq_cancel_left"
        ],
        "statement": "lemma (in loop1) subtract_pos: assumes \"x\\<in>L\" \"\\<zero>\\<ls>y\"\n  shows \"x\\<rs>y \\<ls> x\" and \"(\\<rm>y\\<ad>x) \\<ls> x\"\n",
        "proof": "proof -\n  from assms(2) have \"y\\<in>L\" using less_members(2) by simp\n  from assms(1) have \"x\\<lsq>x\" \n    using ordLoopAssum unfolding IsAnOrdLoop_def IsPartOrder_def refl_def\n    by simp\n  with assms(2) have \"x\\<ra>\\<zero> \\<ls> x\\<ra>y\"\n    using add_ineq_strict1(1) by simp \n  with assms \\<open>y\\<in>L\\<close> show \"x\\<rs>y \\<ls> x\"\n    using neut_props_loop(2) lrdiv_props(3) lrdiv_props(2) strict_ineq_cancel_right\n    by simp\n  from assms(2) \\<open>x\\<lsq>x\\<close> have \"\\<zero>\\<ra>x \\<ls> y\\<ra>x\"\n    using add_ineq_strict1(2) by simp\n  with assms \\<open>y\\<in>L\\<close> show \"(\\<rm>y\\<ad>x) \\<ls> x\"\n    using neut_props_loop(2) lrdiv_props(6) lrdiv_props(5) strict_ineq_cancel_left\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1534
    },
    "1380": {
        "type": "definition",
        "text": "text\\<open>We define ordered ring as a commutative ring with linear order \n  that is preserved by \n  translations and such that the set of nonnegative elements is closed\n  under multiplication. Note that this definition does not guarantee \n  that there are no zero divisors in the ring.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAnOrdRing(R,A,M,r) \\<equiv> \n  ( IsAring(R,A,M) \\<and> (M {is commutative on} R) \\<and> \n  r\\<subseteq>R\\<times>R \\<and> IsLinOrder(R,r) \\<and>\n  (\\<forall>a b. \\<forall> c\\<in>R. \\<langle> a,b\\<rangle> \\<in> r \\<longrightarrow> \\<langle>A`\\<langle> a,c\\<rangle>,A`\\<langle> b,c\\<rangle>\\<rangle> \\<in> r) \\<and>\n  (Nonnegative(R,A,r) {is closed under} M))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1535
    },
    "1381": {
        "type": "lemma",
        "text": "text\\<open>The next lemma assures us that we are talking about ordered rings \n  in the \\<open>ring1\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "ring0_def",
            "ringAssum",
            "mult_commut",
            "ordincl",
            "linord",
            "ordgroup",
            "pos_mult_closed",
            "IsAnOrdRing_def"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L1: shows \"IsAnOrdRing(R,A,M,r)\"\n  ",
        "proof": "using ring0_def ringAssum mult_commut ordincl linord ordgroup \n    pos_mult_closed IsAnOrdRing_def by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1536
    },
    "1382": {
        "type": "lemma",
        "text": "text\\<open>We can use theorems proven in the \\<open>ring1\\<close> context whenever we\n  talk about an ordered ring.\\<close>\n",
        "assumes": "assumes \"IsAnOrdRing(R,A,M,r)\"\n  ",
        "using": [
            "assms",
            "IsAnOrdRing_def",
            "ring1_axioms.intro",
            "ring0_def",
            "ring1_def"
        ],
        "statement": "lemma OrdRing_ZF_1_L2: assumes \"IsAnOrdRing(R,A,M,r)\"\n  shows \"ring1(R,A,M,r)\"\n  ",
        "proof": "using assms IsAnOrdRing_def ring1_axioms.intro ring0_def ring1_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1537
    },
    "1383": {
        "type": "lemma",
        "text": "text\\<open>In the \\<open>ring1\\<close> context $a\\leq b$ implies that $a,b$ are\n  elements of the ring.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "ordincl"
        ],
        "statement": "lemma (in  ring1) OrdRing_ZF_1_L3: assumes \"a\\<lsq>b\"\n  shows \"a\\<in>R\"  \"b\\<in>R\"\n  ",
        "proof": "using assms ordincl by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1538
    },
    "1384": {
        "type": "lemma",
        "text": "text\\<open>Ordered ring is an ordered group, hence we can use theorems\n  proven in the \\<open>group3\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "OrdRing_ZF_1_L3",
            "IsAring_def",
            "IsCommutative_def",
            "Order_ZF_1_L2",
            "IsAnOrdGroup_def",
            "group3_def",
            "IsLinOrder_def"
        ],
        "statement": "lemma (in  ring1) OrdRing_ZF_1_L4: shows \n  \"IsAnOrdGroup(R,A,r)\"\n  \"r {is total on} R\"\n  \"A {is commutative on} R\"\n  \"group3(R,A,r)\"\n",
        "proof": "proof -\n  { fix a b g assume A1: \"g\\<in>R\" and A2: \"a\\<lsq>b\" \n    with ordgroup have \"a\\<ra>g \\<lsq> b\\<ra>g\"\n      by simp\n    moreover from ringAssum A1 A2 have \n      \"a\\<ra>g = g\\<ra>a\"  \"b\\<ra>g = g\\<ra>b\"\n      using OrdRing_ZF_1_L3 IsAring_def IsCommutative_def by auto\n    ultimately have\n      \"a\\<ra>g \\<lsq> b\\<ra>g\"  \"g\\<ra>a \\<lsq> g\\<ra>b\"\n      by auto\n  } hence \n    \"\\<forall>g\\<in>R. \\<forall>a b. a\\<lsq>b \\<longrightarrow> a\\<ra>g \\<lsq> b\\<ra>g \\<and> g\\<ra>a \\<lsq> g\\<ra>b\"\n    by simp\n  with ringAssum ordincl linord show  \n    \"IsAnOrdGroup(R,A,r)\"\n    \"group3(R,A,r)\"\n    \"r {is total on} R\"\n    \"A {is commutative on} R\"\n    using IsAring_def Order_ZF_1_L2 IsAnOrdGroup_def group3_def IsLinOrder_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1539
    },
    "1385": {
        "type": "lemma",
        "text": "text\\<open>The order relation in rings is transitive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>c\"\n  ",
        "using": [
            "OrdRing_ZF_1_L4"
        ],
        "statement": "lemma (in ring1) ring_ord_transitive: assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>c\"\n  shows \"a\\<lsq>c\"\n",
        "proof": "proof -\n  from A1 have \n    \"group3(R,A,r)\"  \"\\<langle>a,b\\<rangle> \\<in> r\"   \"\\<langle>b,c\\<rangle> \\<in> r\"\n    using OrdRing_ZF_1_L4 by auto\n  then have \"\\<langle>a,c\\<rangle> \\<in> r\" by (rule group3.Group_order_transitive)\n  then show  \"a\\<lsq>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1540
    },
    "1386": {
        "type": "lemma",
        "text": "text\\<open>Transitivity for the strict order: if $a<b$ and $b\\leq c$, then $a<c$. \n  Property of ordered groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<ls>b\" and A2: \"b\\<lsq>c\"\n  ",
        "using": [
            "OrdRing_ZF_1_L4"
        ],
        "statement": "lemma (in ring1) ring_strict_ord_trans:  \n  assumes A1: \"a\\<ls>b\" and A2: \"b\\<lsq>c\"\n  shows \"a\\<ls>c\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"group3(R,A,r)\"  \n    \"\\<langle>a,b\\<rangle> \\<in> r \\<and> a\\<noteq>b\"  \"\\<langle>b,c\\<rangle> \\<in> r\"\n    using OrdRing_ZF_1_L4 by auto\n    then have \"\\<langle>a,c\\<rangle> \\<in> r \\<and> a\\<noteq>c\" by (rule group3.OrderedGroup_ZF_1_L4A)\n    then show \"a\\<ls>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1541
    },
    "1387": {
        "type": "lemma",
        "text": "text\\<open>Another version of transitivity for the strict order: \n  if $a\\leq b$ and $b<c$, then $a<c$. Property of ordered groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"b\\<ls>c\"\n  ",
        "using": [
            "OrdRing_ZF_1_L4"
        ],
        "statement": "lemma (in ring1) ring_strict_ord_transit: \n  assumes A1: \"a\\<lsq>b\" and A2: \"b\\<ls>c\"\n  shows \"a\\<ls>c\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"group3(R,A,r)\"  \n    \"\\<langle>a,b\\<rangle> \\<in> r\"  \"\\<langle>b,c\\<rangle> \\<in> r \\<and> b\\<noteq>c\"\n    using OrdRing_ZF_1_L4 by auto\n  then have \"\\<langle>a,c\\<rangle> \\<in> r \\<and> a\\<noteq>c\" by (rule group3.group_strict_ord_transit)\n  then show \"a\\<ls>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1542
    },
    "1388": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows what happens when one element of an ordered\n  ring is not greater or equal than another.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"\n  and A2: \"\\<not>(a\\<lsq>b)\"\n  ",
        "using": [
            "OrdRing_ZF_1_L4"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L4A: assumes A1: \"a\\<in>R\"  \"b\\<in>R\"\n  and A2: \"\\<not>(a\\<lsq>b)\"\n  shows \"b \\<lsq> a\"  \"(\\<rm>a) \\<lsq> (\\<rm>b)\"  \"a\\<noteq>b\"\n",
        "proof": "proof -\n  from A1 A2 have I: \n    \"group3(R,A,r)\"\n    \"r {is total on} R\"\n    \"a \\<in> R\"  \"b \\<in> R\"  \"\\<langle>a, b\\<rangle> \\<notin> r\"\n    using OrdRing_ZF_1_L4 by auto\n  then have \"\\<langle>b,a\\<rangle> \\<in> r\" by (rule group3.OrderedGroup_ZF_1_L8)\n  then show \"b \\<lsq> a\" by simp\n  from I have \"\\<langle>GroupInv(R,A)`(a),GroupInv(R,A)`(b)\\<rangle> \\<in> r\"\n    by (rule group3.OrderedGroup_ZF_1_L8)\n  then show  \"(\\<rm>a) \\<lsq> (\\<rm>b)\" by simp\n  from I show \"a\\<noteq>b\" by (rule group3.OrderedGroup_ZF_1_L8)\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1543
    },
    "1389": {
        "type": "lemma",
        "text": "text\\<open>Taking minus on both sides reverses an inequality.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L5"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L4B: assumes \"a\\<lsq>b\"\n  shows \"(\\<rm>b) \\<lsq> (\\<rm>a)\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L5\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1545
    },
    "1390": {
        "type": "lemma",
        "text": "text\\<open>The next lemma just expands the condition that requires the set\n  of nonnegative elements to be closed with respect to multiplication.\n  These are properties of totally ordered groups.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\"  \"\\<zero>\\<lsq>b\"\n  ",
        "using": [
            "pos_mult_closed",
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L2",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in  ring1) OrdRing_ZF_1_L5: \n  assumes \"\\<zero>\\<lsq>a\"  \"\\<zero>\\<lsq>b\"\n  shows \"\\<zero> \\<lsq> a\\<cdot>b\"\n  ",
        "proof": "using pos_mult_closed assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L2\n  IsOpClosed_def by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1546
    },
    "1391": {
        "type": "lemma",
        "text": "text\\<open>A sufficient (somewhat redundant) condition for a structure to be an \n  ordered ring. It says that a commutative ring that is a totally ordered\n  group with respect to the additive operation such that set of nonnegative \n  elements is closed under multiplication, is an ordered ring.\\<close>\n",
        "assumes": "assumes  \n  \"IsAring(R,A,M)\"   \n  \"M {is commutative on} R\"\n  \"Nonnegative(R,A,r) {is closed under} M\"\n  \"IsAnOrdGroup(R,A,r)\"  \n  \"r {is total on} R\"\n  ",
        "using": [
            "assms",
            "IsAnOrdGroup_def",
            "Order_ZF_1_L3",
            "IsAnOrdRing_def"
        ],
        "statement": "lemma OrdRing_ZF_1_L6:\n  assumes  \n  \"IsAring(R,A,M)\"   \n  \"M {is commutative on} R\"\n  \"Nonnegative(R,A,r) {is closed under} M\"\n  \"IsAnOrdGroup(R,A,r)\"  \n  \"r {is total on} R\"\n  shows \"IsAnOrdRing(R,A,M,r)\"\n  ",
        "proof": "using assms IsAnOrdGroup_def Order_ZF_1_L3 IsAnOrdRing_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1548
    },
    "1392": {
        "type": "lemma",
        "text": "text\\<open> $a\\leq b$ iff $a-b\\leq 0$. This is a fact from \n  \\<open>OrderedGroup.thy\\<close>, where it is stated in multiplicative notation.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L9"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L7:\n  assumes \"a\\<in>R\"  \"b\\<in>R\"\n  shows \"a\\<lsq>b \\<longleftrightarrow> a\\<rs>b \\<lsq> \\<zero>\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L9\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1549
    },
    "1393": {
        "type": "lemma",
        "text": "text\\<open>Negative times positive is negative.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>\\<zero>\"  and A2: \"\\<zero>\\<lsq>b\"\n  ",
        "using": [
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L4",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L5A",
            "OrdRing_ZF_1_L5",
            "Ring_ZF_1_L7",
            "group3.OrderedGroup_ZF_1_L5AA"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L8:\n  assumes A1: \"a\\<lsq>\\<zero>\"  and A2: \"\\<zero>\\<lsq>b\"\n  shows \"a\\<cdot>b \\<lsq> \\<zero>\"\n",
        "proof": "proof -\n  from A1 A2 have T1: \"a\\<in>R\"  \"b\\<in>R\"  \"a\\<cdot>b \\<in> R\"\n    using OrdRing_ZF_1_L3 Ring_ZF_1_L4 by auto\n  from A1 A2 have \"\\<zero>\\<lsq>(\\<rm>a)\\<cdot>b\" \n    using OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L5A OrdRing_ZF_1_L5\n    by simp\n  with T1 show \"a\\<cdot>b \\<lsq> \\<zero>\"\n    using Ring_ZF_1_L7 OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L5AA\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1550
    },
    "1394": {
        "type": "lemma",
        "text": "text\\<open>We can multiply both sides of an inequality by a nonnegative ring\n  element. This property is sometimes (not here) used to define\n  ordered rings.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"\\<zero>\\<lsq>c\"\n  ",
        "using": [
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L4",
            "OrdRing_ZF_1_L7",
            "OrdRing_ZF_1_L8",
            "Ring_ZF_1_L8",
            "IsCommutative_def"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L9:\n  assumes A1: \"a\\<lsq>b\" and A2: \"\\<zero>\\<lsq>c\"\n  shows \n  \"a\\<cdot>c \\<lsq> b\\<cdot>c\"  \n  \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 A2 have T1:\n    \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"a\\<cdot>c \\<in> R\"  \"b\\<cdot>c \\<in> R\"\n    using OrdRing_ZF_1_L3 Ring_ZF_1_L4 by auto\n  with A1 A2 have \"(a\\<rs>b)\\<cdot>c \\<lsq> \\<zero>\"\n    using OrdRing_ZF_1_L7 OrdRing_ZF_1_L8 by simp\n  with T1 show \"a\\<cdot>c \\<lsq> b\\<cdot>c\"\n    using Ring_ZF_1_L8 OrdRing_ZF_1_L7 by simp\n  with mult_commut T1 show \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n    using IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1551
    },
    "1395": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>OrdRing_ZF_1_L9\\<close>: we can multiply\n  an inequality by a positive ring element.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>R\\<^sub>+\"\n  ",
        "using": [
            "PositiveSet_def",
            "OrdRing_ZF_1_L9"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L9A:\n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>R\\<^sub>+\"\n  shows  \n  \"a\\<cdot>c \\<lsq> b\\<cdot>c\"  \n  \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n",
        "proof": "proof -\n  from A2 have \"\\<zero> \\<lsq> c\" using PositiveSet_def\n    by simp\n  with A1 show \"a\\<cdot>c \\<lsq> b\\<cdot>c\"  \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n    using OrdRing_ZF_1_L9 by auto\nqed    \n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1552
    },
    "1396": {
        "type": "lemma",
        "text": "text\\<open>A square is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\" ",
        "using": [
            "OrdRing_ZF_1_L5",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L8A",
            "Ring_ZF_1_L14"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L10:\n  assumes A1: \"a\\<in>R\" shows \"\\<zero>\\<lsq>(a\\<^sup>2)\"\n",
        "proof": "proof -\n  { assume \"\\<zero>\\<lsq>a\"\n    then have \"\\<zero>\\<lsq>(a\\<^sup>2)\" using OrdRing_ZF_1_L5 by simp}\n  moreover\n  { assume \"\\<not>(\\<zero>\\<lsq>a)\"\n    with A1 have \"\\<zero>\\<lsq>((\\<rm>a)\\<^sup>2)\"\n      using OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L8A\n\tOrdRing_ZF_1_L5 by simp\n    with A1 have \"\\<zero>\\<lsq>(a\\<^sup>2)\" using Ring_ZF_1_L14 by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1553
    },
    "1397": {
        "type": "corollary",
        "text": "text\\<open>$1$ is nonnegative.\\<close>\n",
        "assumes": "",
        "using": [
            "Ring_ZF_1_L2",
            "OrdRing_ZF_1_L10",
            "Ring_ZF_1_L3"
        ],
        "statement": "corollary (in ring1) ordring_one_is_nonneg: shows \"\\<zero> \\<lsq> \\<one>\"\n",
        "proof": "proof -\n  have \"\\<zero> \\<lsq> (\\<one>\\<^sup>2)\" using Ring_ZF_1_L2 OrdRing_ZF_1_L10\n    by simp\n  then show \"\\<zero> \\<lsq> \\<one>\" using Ring_ZF_1_L2 Ring_ZF_1_L3\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1554
    },
    "1398": {
        "type": "lemma",
        "text": "text\\<open>In nontrivial rings one is positive.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<noteq>\\<one>\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L2",
            "ordring_one_is_nonneg",
            "PositiveSet_def"
        ],
        "statement": "lemma (in ring1) ordring_one_is_pos: assumes \"\\<zero>\\<noteq>\\<one>\"\n  shows \"\\<one> \\<in> R\\<^sub>+\"\n  ",
        "proof": "using assms Ring_ZF_1_L2 ordring_one_is_nonneg PositiveSet_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1555
    },
    "1399": {
        "type": "lemma",
        "text": "text\\<open>Nonnegative is not negative. Property of ordered groups.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L5AB"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L11: assumes \"\\<zero>\\<lsq>a\"\n  shows \"\\<not>(a\\<lsq>\\<zero> \\<and> a\\<noteq>\\<zero>)\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L5AB\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1556
    },
    "1400": {
        "type": "lemma",
        "text": "text\\<open>A negative element cannot be a square.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>\\<zero>\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "OrdRing_ZF_1_L10",
            "OrdRing_ZF_1_L11"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L12: \n  assumes A1: \"a\\<lsq>\\<zero>\"  \"a\\<noteq>\\<zero>\"\n  shows \"\\<not>(\\<exists>b\\<in>R. a = (b\\<^sup>2))\"\n",
        "proof": "proof -\n  { assume \"\\<exists>b\\<in>R. a = (b\\<^sup>2)\"\n    with A1 have False using OrdRing_ZF_1_L10 OrdRing_ZF_1_L11\n      by auto\n  } then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1557
    },
    "1401": {
        "type": "lemma",
        "text": "text\\<open>If $a\\leq b$, then $0\\leq b-a$.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L9D"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L13: assumes \"a\\<lsq>b\"\n  shows \"\\<zero> \\<lsq> b\\<rs>a\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L9D\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1558
    },
    "1402": {
        "type": "lemma",
        "text": "text\\<open>If $a<b$, then $0 < b-a$.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"  \"a\\<noteq>b\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L9E"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L14: assumes \"a\\<lsq>b\"  \"a\\<noteq>b\"\n  shows \n  \"\\<zero> \\<lsq> b\\<rs>a\"  \"\\<zero> \\<noteq> b\\<rs>a\"  \n  \"b\\<rs>a \\<in> R\\<^sub>+\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L9E\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1559
    },
    "1403": {
        "type": "lemma",
        "text": "text\\<open>If the difference is nonnegative, then $a\\leq b$.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\" \"b\\<in>R\" and \"\\<zero> \\<lsq> b\\<rs>a\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L9F"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L15: \n  assumes \"a\\<in>R\" \"b\\<in>R\" and \"\\<zero> \\<lsq> b\\<rs>a\"\n  shows \"a\\<lsq>b\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L9F\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1560
    },
    "1404": {
        "type": "lemma",
        "text": "text\\<open>A nonnegative number is does not decrease when multiplied by \n  a number greater or equal $1$.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<lsq>a\" and A2: \"\\<one>\\<lsq>b\"\n  ",
        "using": [
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L4",
            "OrdRing_ZF_1_L13",
            "OrdRing_ZF_1_L5",
            "Ring_ZF_1_L8",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L3",
            "OrdRing_ZF_1_L15"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L16: \n  assumes A1: \"\\<zero>\\<lsq>a\" and A2: \"\\<one>\\<lsq>b\"\n  shows \"a\\<lsq>a\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 A2 have T: \"a\\<in>R\"  \"b\\<in>R\"  \"a\\<cdot>b \\<in> R\"\n    using OrdRing_ZF_1_L3 Ring_ZF_1_L4 by auto\n  from A1 A2 have \"\\<zero> \\<lsq> a\\<cdot>(b\\<rs>\\<one>)\"\n    using OrdRing_ZF_1_L13 OrdRing_ZF_1_L5 by simp\n  with T show \"a\\<lsq>a\\<cdot>b\"\n    using Ring_ZF_1_L8 Ring_ZF_1_L2 Ring_ZF_1_L3 OrdRing_ZF_1_L15\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1561
    },
    "1405": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the right hand side of an inequality between\n  nonnegative ring elements by an element greater or equal $1$.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<lsq>a\" and A2: \"a\\<lsq>b\" and A3: \"\\<one>\\<lsq>c\"\n  ",
        "using": [
            "OrdRing_ZF_1_L16"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L17: \n  assumes A1: \"\\<zero>\\<lsq>a\" and A2: \"a\\<lsq>b\" and A3: \"\\<one>\\<lsq>c\"\n  shows \"a\\<lsq>b\\<cdot>c\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<zero>\\<lsq>b\" by (rule ring_ord_transitive)\n  with A3 have \"b\\<lsq>b\\<cdot>c\" using OrdRing_ZF_1_L16\n    by simp\n  with A2 show \"a\\<lsq>b\\<cdot>c\" by (rule ring_ord_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1562
    },
    "1406": {
        "type": "lemma",
        "text": "text\\<open>Strict order is preserved by translations.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" and \"c\\<in>R\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.group_strict_ord_transl_inv"
        ],
        "statement": "lemma (in ring1) ring_strict_ord_trans_inv: \n  assumes \"a\\<ls>b\" and \"c\\<in>R\"\n  shows  \n  \"a\\<ra>c \\<ls> b\\<ra>c\"\n  \"c\\<ra>a \\<ls> c\\<ra>b\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.group_strict_ord_transl_inv\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1563
    },
    "1407": {
        "type": "lemma",
        "text": "text\\<open>We can put an element on the other side of a strict inequality,\n  changing its sign.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\" and  \"a\\<rs>b \\<ls> c\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L12B"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L18:\n  assumes \"a\\<in>R\"  \"b\\<in>R\" and  \"a\\<rs>b \\<ls> c\"\n  shows \"a \\<ls> c\\<ra>b\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L12B\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1564
    },
    "1408": {
        "type": "lemma",
        "text": "text\\<open>We can add the sides of two inequalities,\n  the first of them strict, and we get a strict inequality. \n  Property of ordered groups.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" and \"c\\<lsq>d\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L12C"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L19:\n  assumes \"a\\<ls>b\" and \"c\\<lsq>d\"\n  shows \"a\\<ra>c \\<ls> b\\<ra>d\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L12C\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1565
    },
    "1409": {
        "type": "lemma",
        "text": "text\\<open>We can add the sides of two inequalities,\n  the second of them strict and we get a strict inequality. \n  Property of ordered groups.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"c\\<ls>d\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L12D"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_1_L20:\n  assumes \"a\\<lsq>b\" and \"c\\<ls>d\"\n  shows \"a\\<ra>c \\<ls> b\\<ra>d\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L12D\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1566
    },
    "1410": {
        "type": "lemma",
        "text": "text\\<open>Absolute value of a product is the product of absolute values: \n  the case when both elements of the ring are nonnegative.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\" \"\\<zero>\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L5",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L2",
            "group3.OrderedGroup_ZF_3_L2"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_2_L1: \n  assumes \"\\<zero>\\<lsq>a\" \"\\<zero>\\<lsq>b\"\n  shows \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L5 OrdRing_ZF_1_L4 \n    group3.OrderedGroup_ZF_1_L2 group3.OrderedGroup_ZF_3_L2\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1567
    },
    "1411": {
        "type": "lemma",
        "text": "text\\<open>The absolue value of an element and its negative are the same.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_3_L7A"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_2_L2: assumes \"a\\<in>R\"\n  shows \"\\<bar>\\<rm>a\\<bar> = \\<bar>a\\<bar>\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_3_L7A by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1568
    },
    "1412": {
        "type": "lemma",
        "text": "text\\<open>The next lemma states that \n  $|a\\cdot (-b)| = |(-a)\\cdot b| = |(-a)\\cdot (-b)| = |a\\cdot b|$.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L4",
            "Ring_ZF_1_L7",
            "Ring_ZF_1_L7A",
            "OrdRing_ZF_2_L2"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_2_L3:\n  assumes \"a\\<in>R\"  \"b\\<in>R\"\n  shows \n  \"\\<bar>(\\<rm>a)\\<cdot>b\\<bar> = \\<bar>a\\<cdot>b\\<bar>\"\n  \"\\<bar>a\\<cdot>(\\<rm>b)\\<bar> = \\<bar>a\\<cdot>b\\<bar>\"\n  \"\\<bar>(\\<rm>a)\\<cdot>(\\<rm>b)\\<bar> = \\<bar>a\\<cdot>b\\<bar>\"\n  ",
        "proof": "using assms Ring_ZF_1_L4 Ring_ZF_1_L7 Ring_ZF_1_L7A \n   OrdRing_ZF_2_L2 by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1569
    },
    "1413": {
        "type": "lemma",
        "text": "text\\<open>This lemma allows to prove theorems for the case of positive and \n  negative elements of the ring separately.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\" and \"\\<not>(\\<zero>\\<lsq>a)\" \n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L8A"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_2_L4: assumes \"a\\<in>R\" and \"\\<not>(\\<zero>\\<lsq>a)\" \n  shows \"\\<zero> \\<lsq> (\\<rm>a)\"  \"\\<zero>\\<noteq>a\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L8A\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1570
    },
    "1414": {
        "type": "lemma",
        "text": "text\\<open>Absolute value of a product is the product of absolute values.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\" \"b\\<in>R\"\n  ",
        "using": [
            "OrdRing_ZF_2_L1",
            "OrdRing_ZF_2_L4",
            "OrdRing_ZF_2_L2",
            "OrdRing_ZF_2_L3"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_2_L5:\n  assumes A1: \"a\\<in>R\" \"b\\<in>R\"\n  shows \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n",
        "proof": "proof -\n  { assume A2: \"\\<zero>\\<lsq>a\" have \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n    proof -\n      { assume \"\\<zero>\\<lsq>b\"\n\twith A2 have \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n\t  using OrdRing_ZF_2_L1 by simp }\n      moreover\n      { assume \"\\<not>(\\<zero>\\<lsq>b)\" \n\twith A1 A2 have \"\\<bar>a\\<cdot>(\\<rm>b)\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>\\<rm>b\\<bar>\"\n\t  using OrdRing_ZF_2_L4 OrdRing_ZF_2_L1 by simp\n\twith A1 have \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n\t  using OrdRing_ZF_2_L2 OrdRing_ZF_2_L3 by simp }\n      ultimately show ?thesis by blast\n    qed }\n  moreover\n  { assume \"\\<not>(\\<zero>\\<lsq>a)\"\n    with A1 have A3: \"\\<zero> \\<lsq> (\\<rm>a)\"\n      using OrdRing_ZF_2_L4 by simp\n    have \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n    proof -\n      { assume \"\\<zero>\\<lsq>b\" \n\twith A3 have \"\\<bar>(\\<rm>a)\\<cdot>b\\<bar> = \\<bar>\\<rm>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n\t  using OrdRing_ZF_2_L1 by simp\n\twith A1 have \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n\t  using OrdRing_ZF_2_L2 OrdRing_ZF_2_L3 by simp }\n      moreover\n      { assume \"\\<not>(\\<zero>\\<lsq>b)\"\n\twith A1 A3 have \"\\<bar>(\\<rm>a)\\<cdot>(\\<rm>b)\\<bar> = \\<bar>\\<rm>a\\<bar>\\<cdot>\\<bar>\\<rm>b\\<bar>\"\n\t  using OrdRing_ZF_2_L4 OrdRing_ZF_2_L1 by simp\n\twith A1 have \"\\<bar>a\\<cdot>b\\<bar> = \\<bar>a\\<bar>\\<cdot>\\<bar>b\\<bar>\"\n\t  using OrdRing_ZF_2_L2 OrdRing_ZF_2_L3 by simp }\n      ultimately show ?thesis by blast\n    qed }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1571
    },
    "1415": {
        "type": "lemma",
        "text": "text\\<open>Triangle inequality. Property of linearly ordered abelian groups.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\" \"b\\<in>R\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrdGroup_triangle_ineq"
        ],
        "statement": "lemma (in ring1) ord_ring_triangle_ineq:  assumes \"a\\<in>R\" \"b\\<in>R\"\n  shows \"\\<bar>a\\<ra>b\\<bar> \\<lsq> \\<bar>a\\<bar>\\<ra>\\<bar>b\\<bar>\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrdGroup_triangle_ineq \n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1572
    },
    "1416": {
        "type": "lemma",
        "text": "text\\<open>If $a\\leq c$ and $b\\leq c$, then $a+b\\leq 2\\cdot c$.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>c\"  \"b\\<lsq>c\" ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L5B",
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L3"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_2_L6:\n  assumes \"a\\<lsq>c\"  \"b\\<lsq>c\" shows \"a\\<ra>b \\<lsq> \\<two>\\<cdot>c\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L5B \n    OrdRing_ZF_1_L3 Ring_ZF_1_L3 by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1573
    },
    "1417": {
        "type": "lemma",
        "text": "text\\<open>The set of positive elements is closed under ring addition. \n  This is a property of ordered groups, we just reference a theorem\n  from \\<open>OrderedGroup_ZF\\<close> theory in the proof.\\<close>\n",
        "assumes": "",
        "using": [
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L13"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L1: shows \"R\\<^sub>+ {is closed under} A\"\n  ",
        "proof": "using OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L13\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1574
    },
    "1418": {
        "type": "lemma",
        "text": "text\\<open>Every element of a ring can be either in the postitive set, equal to\n  zero or its opposite (the additive inverse) is in the positive set. \n  This is a property of ordered groups, we just reference a theorem\n  from \\<open>OrderedGroup_ZF\\<close> theory.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrdGroup_decomp"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L2: assumes \"a\\<in>R\"\n  shows \"Exactly_1_of_3_holds (a=\\<zero>, a\\<in>R\\<^sub>+, (\\<rm>a) \\<in> R\\<^sub>+)\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrdGroup_decomp\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1575
    },
    "1419": {
        "type": "lemma",
        "text": "text\\<open>If a ring element $a\\neq 0$, and it is not positive, then \n  $-a$ is positive.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"  \"a \\<notin> R\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrdGroup_cases"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L2A: assumes \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"  \"a \\<notin> R\\<^sub>+\"\n  shows \"(\\<rm>a) \\<in>  R\\<^sub>+\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrdGroup_cases\n  by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1576
    },
    "1420": {
        "type": "lemma",
        "text": "text\\<open>\\<open>R\\<^sub>+\\<close> is closed under\n  multiplication iff the ring has no zero divisors.\\<close>\n",
        "assumes": "",
        "using": [
            "PositiveSet_def",
            "OrdRing_ZF_1_L5",
            "Ring_ZF_1_L2",
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L12",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L2A",
            "IsOpClosed_def",
            "group3.OrderedGroup_ZF_3_L12",
            "OrdRing_ZF_2_L5",
            "Ring_ZF_1_L4",
            "group3.OrderedGroup_ZF_3_L2A",
            "HasNoZeroDivs_def"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L3: \n  shows \"(R\\<^sub>+ {is closed under} M)\\<longleftrightarrow> HasNoZeroDivs(R,A,M)\"\n",
        "proof": "proof\n  assume A1: \"HasNoZeroDivs(R,A,M)\"\n  { fix a b assume \"a\\<in>R\\<^sub>+\"  \"b\\<in>R\\<^sub>+\"\n    then have \"\\<zero>\\<lsq>a\"  \"a\\<noteq>\\<zero>\"  \"\\<zero>\\<lsq>b\"  \"b\\<noteq>\\<zero>\"\n      using PositiveSet_def by auto\n    with A1 have \"a\\<cdot>b \\<in> R\\<^sub>+\"\n      using OrdRing_ZF_1_L5 Ring_ZF_1_L2 OrdRing_ZF_1_L3 Ring_ZF_1_L12\n\tOrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L2A\n      by simp\n  } then show  \"R\\<^sub>+ {is closed under} M\" using IsOpClosed_def\n    by simp\nnext assume A2: \"R\\<^sub>+ {is closed under} M\"\n  { fix a b assume A3: \"a\\<in>R\"  \"b\\<in>R\"  and \"a\\<noteq>\\<zero>\"  \"b\\<noteq>\\<zero>\"\n    with A2 have \"\\<bar>a\\<cdot>b\\<bar> \\<in> R\\<^sub>+\"\n      using OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_3_L12 IsOpClosed_def\n        OrdRing_ZF_2_L5 by simp\n    with A3 have \"a\\<cdot>b \\<noteq> \\<zero>\" \n      using PositiveSet_def Ring_ZF_1_L4 \n\tOrdRing_ZF_1_L4 group3.OrderedGroup_ZF_3_L2A \n      by auto\n  } then show \"HasNoZeroDivs(R,A,M)\" using HasNoZeroDivs_def \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1577
    },
    "1421": {
        "type": "theorem",
        "text": "text\\<open>Another (in addition to \\<open>OrdRing_ZF_1_L6\\<close> sufficient condition \n  that defines order in an ordered ring starting from the positive set.\\<close>\n",
        "assumes": "assumes\n  A1: \"M {is commutative on} R\" and \n  A2: \"P\\<subseteq>R\"  \"P {is closed under} A\"  \"\\<zero> \\<notin> P\" and\n  A3: \"\\<forall>a\\<in>R. a\\<noteq>\\<zero> \\<longrightarrow> (a\\<in>P) Xor ((\\<rm>a) \\<in> P)\" and\n  A4: \"P {is closed under} M\" and \n  A5: \"r = OrderFromPosSet(R,A,P)\"\n  ",
        "using": [
            "Ring_ZF_1_L1",
            "group0.Group_ord_",
            "Ring_ZF_1_L16",
            "OrdRing_ZF_1_L6",
            "OrdRing_ZF_1_L2",
            "ring1.OrdRing_ZF_3_L3"
        ],
        "statement": "theorem (in ring0) ring_ord_by_positive_set:\n  assumes\n  A1: \"M {is commutative on} R\" and \n  A2: \"P\\<subseteq>R\"  \"P {is closed under} A\"  \"\\<zero> \\<notin> P\" and\n  A3: \"\\<forall>a\\<in>R. a\\<noteq>\\<zero> \\<longrightarrow> (a\\<in>P) Xor ((\\<rm>a) \\<in> P)\" and\n  A4: \"P {is closed under} M\" and \n  A5: \"r = OrderFromPosSet(R,A,P)\"\n  shows\n  \"IsAnOrdGroup(R,A,r)\"\n  \"IsAnOrdRing(R,A,M,r)\"\n  \"r {is total on} R\"\n  \"PositiveSet(R,A,r) = P\"\n  \"Nonnegative(R,A,r) = P \\<union> {\\<zero>}\"\n  \"HasNoZeroDivs(R,A,M)\"\n",
        "proof": "proof -\n  from A2 A3 A5 show\n    I: \"IsAnOrdGroup(R,A,r)\"  \"r {is total on} R\" and \n    II: \"PositiveSet(R,A,r) = P\" and \n    III: \"Nonnegative(R,A,r) = P \\<union> {\\<zero>}\"\n    using Ring_ZF_1_L1 group0.Group_ord_by_positive_set\n    by auto\n  from A2 A4 III have \"Nonnegative(R,A,r) {is closed under} M\"\n    using Ring_ZF_1_L16 by simp\n  with ringAssum A1 I show \"IsAnOrdRing(R,A,M,r)\"\n    using OrdRing_ZF_1_L6 by simp\n  with A4 II show \"HasNoZeroDivs(R,A,M)\"\n    using OrdRing_ZF_1_L2 ring1.OrdRing_ZF_3_L3\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1578
    },
    "1422": {
        "type": "theorem",
        "text": "text\\<open>Nontrivial ordered rings are infinite. More precisely we assume \n  that the neutral\n  element of the additive operation is not equal to the multiplicative neutral\n  element and show that the the set of positive elements of the ring is not a \n  finite subset of the ring and the ring is not a finite subset of itself.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<noteq>\\<one>\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L17",
            "OrdRing_ZF_1_L4",
            "group3.Linord_group_infinite"
        ],
        "statement": "theorem (in ring1) ord_ring_infinite: assumes \"\\<zero>\\<noteq>\\<one>\"\n  shows \n  \"R\\<^sub>+ \\<notin> Fin(R)\"\n  \"R \\<notin> Fin(R)\"\n  ",
        "proof": "using assms Ring_ZF_1_L17 OrdRing_ZF_1_L4 group3.Linord_group_infinite\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1579
    },
    "1423": {
        "type": "lemma",
        "text": "text\\<open>If every element of a nontrivial ordered ring can be dominated\n  by an element from $B$, then we $B$ is not bounded and not finite.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<noteq>\\<one>\" and \"\\<forall>a\\<in>R. \\<exists>b\\<in>B. a\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L17",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_2_L2A"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L4: \n  assumes \"\\<zero>\\<noteq>\\<one>\" and \"\\<forall>a\\<in>R. \\<exists>b\\<in>B. a\\<lsq>b\"\n  shows \n  \"\\<not>IsBoundedAbove(B,r)\"\n  \"B \\<notin> Fin(R)\"\n  ",
        "proof": "using assms Ring_ZF_1_L17 OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_2_L2A\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1580
    },
    "1424": {
        "type": "lemma",
        "text": "text\\<open>If $m$ is greater or equal the multiplicative unit, then the set\n  $\\{m\\cdot n: n\\in R\\}$ is infinite (unless the ring is trivial).\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"\\<one>\\<lsq>m\"\n  ",
        "using": [
            "OrdRing_ZF_1_L3",
            "ordring_one_is_nonneg",
            "ord_ring_split2",
            "ordring_one_is_pos",
            "Ring_ZF_1_L3",
            "PositiveSet_def",
            "OrdRing_ZF_1_L9",
            "OrdRing_ZF_3_L4",
            "Fin_subset",
            "Ring_ZF_1_L18"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L5: assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"\\<one>\\<lsq>m\"\n  shows\n  \"{m\\<cdot>x. x\\<in>R\\<^sub>+} \\<notin> Fin(R)\"\n  \"{m\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\"\n  \"{(\\<rm>m)\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\"\n",
        "proof": "proof -\n  from A2 have T: \"m\\<in>R\" using OrdRing_ZF_1_L3 by simp\n  from A2 have \"\\<zero>\\<lsq>\\<one>\"  \"\\<one>\\<lsq>m\"\n    using ordring_one_is_nonneg by auto\n  then have I: \"\\<zero>\\<lsq>m\" by (rule ring_ord_transitive)\n  let ?B = \"{m\\<cdot>x. x\\<in>R\\<^sub>+}\"\n  { fix a assume A3: \"a\\<in>R\"\n    then have \"a\\<lsq>\\<zero> \\<or> (\\<zero>\\<lsq>a \\<and> a\\<noteq>\\<zero>)\"\n      using ord_ring_split2 by simp\n    moreover\n    { assume A4: \"a\\<lsq>\\<zero>\"\n      from A1 have \"m\\<cdot>\\<one> \\<in> ?B\" using ordring_one_is_pos\n\tby auto\n      with T have \"m\\<in>?B\" using Ring_ZF_1_L3 by simp\n      moreover from A4 I have \"a\\<lsq>m\" by (rule ring_ord_transitive)\n      ultimately have \"\\<exists>b\\<in>?B. a\\<lsq>b\" by blast }\n    moreover\n    { assume A4: \"\\<zero>\\<lsq>a \\<and> a\\<noteq>\\<zero>\"\n      with A3 have \"m\\<cdot>a \\<in> ?B\" using PositiveSet_def\n\tby auto\n      moreover\n      from A2 A4 have \"\\<one>\\<cdot>a \\<lsq> m\\<cdot>a\" using OrdRing_ZF_1_L9\n\tby simp\n      with A3 have \"a \\<lsq> m\\<cdot>a\" using Ring_ZF_1_L3 \n\tby simp\n      ultimately have \"\\<exists>b\\<in>?B. a\\<lsq>b\" by auto }\n    ultimately have \"\\<exists>b\\<in>?B. a\\<lsq>b\" by auto\n  } then have \"\\<forall>a\\<in>R. \\<exists>b\\<in>?B. a\\<lsq>b\"\n    by simp\n  with A1 show \"?B \\<notin> Fin(R)\" using OrdRing_ZF_3_L4\n    by simp\n  moreover have \"?B \\<subseteq> {m\\<cdot>x. x\\<in>R}\"\n    using PositiveSet_def by auto\n  ultimately show \"{m\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\" using Fin_subset\n    by auto\n  with T show \"{(\\<rm>m)\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\" using Ring_ZF_1_L18\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1581
    },
    "1425": {
        "type": "lemma",
        "text": "text\\<open>If $m$ is less or equal than the negative of \n  multiplicative unit, then the set\n  $\\{m\\cdot n: n\\in R\\}$ is infinite (unless the ring is trivial).\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"m \\<lsq> \\<rm>\\<one>\"\n  ",
        "using": [
            "OrdRing_ZF_1_L4B",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L3",
            "OrdRing_ZF_3_L5",
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L18"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L6: assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"m \\<lsq> \\<rm>\\<one>\"\n  shows \"{m\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\"\n",
        "proof": "proof -\n  from A2 have \"(\\<rm>(\\<rm>\\<one>)) \\<lsq> \\<rm>m\"\n    using OrdRing_ZF_1_L4B by simp\n  with A1 have \"{(\\<rm>m)\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\"\n    using Ring_ZF_1_L2 Ring_ZF_1_L3 OrdRing_ZF_3_L5\n    by simp\n  with A2 show \"{m\\<cdot>x. x\\<in>R} \\<notin> Fin(R)\"\n    using OrdRing_ZF_1_L3 Ring_ZF_1_L18 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1582
    },
    "1426": {
        "type": "lemma",
        "text": "text\\<open>All elements greater or equal than an element of \\<open>R\\<^sub>+\\<close>\n  belong to \\<open>R\\<^sub>+\\<close>. Property of ordered groups.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> R\\<^sub>+\" and A2: \"a\\<lsq>b\"\n  ",
        "using": [
            "OrdRing_ZF_1_L4"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L7: assumes A1: \"a \\<in> R\\<^sub>+\" and A2: \"a\\<lsq>b\"\n  shows \"b \\<in> R\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \n    \"group3(R,A,r)\"\n    \"a \\<in> PositiveSet(R,A,r)\"\n    \"\\<langle>a,b\\<rangle> \\<in> r\"\n    using OrdRing_ZF_1_L4 by auto\n  then have \"b \\<in> PositiveSet(R,A,r)\" \n    by (rule group3.OrderedGroup_ZF_1_L19)\n  then show \"b \\<in> R\\<^sub>+\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1583
    },
    "1427": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>OrdRing_ZF_3_L7\\<close>: a ring element greater\n  or equal than $1$ is positive.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"\\<one>\\<lsq>a\"\n  ",
        "using": [
            "ordring_one_is_pos"
        ],
        "statement": "corollary (in ring1) OrdRing_ZF_3_L8: assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"\\<one>\\<lsq>a\"\n  shows \"a \\<in> R\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<one> \\<in> R\\<^sub>+\"  \"\\<one>\\<lsq>a\"\n    using ordring_one_is_pos by auto\n  then show \"a \\<in> R\\<^sub>+\" by (rule OrdRing_ZF_3_L7)\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1584
    },
    "1428": {
        "type": "lemma",
        "text": "text\\<open>Adding a positive element to $a$ strictly increases $a$.\n  Property of ordered groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L22"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L9: assumes A1: \"a\\<in>R\"  \"b\\<in>R\\<^sub>+\"\n  shows \"a \\<lsq> a\\<ra>b\"  \"a \\<noteq> a\\<ra>b\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L22\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1585
    },
    "1429": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is not greater than $b$, then it is strictly less than\n  $b+1$.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"a\\<lsq>b\"\n  ",
        "using": [
            "OrdRing_ZF_1_L3",
            "OrdRing_ZF_3_L10"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L11: assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"a\\<lsq>b\"\n  shows \"a\\<ls> b\\<ra>\\<one>\"\n",
        "proof": "proof -\n  from A1 A2 have I: \"b \\<ls> b\\<ra>\\<one>\"\n    using OrdRing_ZF_1_L3 OrdRing_ZF_3_L10 by auto\n  with A2 show \"a\\<ls> b\\<ra>\\<one>\" by (rule ring_strict_ord_transit)\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1587
    },
    "1430": {
        "type": "lemma",
        "text": "text\\<open>For any ring element $a$ the greater of $a$ and $1$ is a positive\n  element that is greater or equal than $m$. If we add $1$ to it we\n  get a positive element that is strictly greater than $m$. This holds\n  in nontrivial rings.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"a\\<in>R\"\n  ",
        "using": [
            "IsLinOrder_def",
            "Ring_ZF_1_L2",
            "Order_ZF_3_L2",
            "OrdRing_ZF_3_L8",
            "ordring_one_is_pos",
            "OrdRing_ZF_3_L1",
            "IsOpClosed_def",
            "OrdRing_ZF_3_L11"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L12: assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"a\\<in>R\"\n  shows \n  \"a \\<lsq> GreaterOf(r,\\<one>,a)\"\n  \"GreaterOf(r,\\<one>,a) \\<in> R\\<^sub>+\"\n  \"GreaterOf(r,\\<one>,a) \\<ra> \\<one> \\<in> R\\<^sub>+\"\n  \"a \\<lsq> GreaterOf(r,\\<one>,a) \\<ra> \\<one>\"  \"a \\<noteq> GreaterOf(r,\\<one>,a) \\<ra> \\<one>\"\n",
        "proof": "proof -\n  from linord have \"r {is total on} R\" using IsLinOrder_def\n    by simp\n  moreover from A2 have \"\\<one> \\<in> R\"  \"a\\<in>R\"\n    using Ring_ZF_1_L2 by auto\n  ultimately have\n    \"\\<one> \\<lsq> GreaterOf(r,\\<one>,a)\" and\n    I: \"a \\<lsq> GreaterOf(r,\\<one>,a)\"\n    using Order_ZF_3_L2 by auto\n  with A1 show \n    \"a \\<lsq> GreaterOf(r,\\<one>,a)\" and \n    \"GreaterOf(r,\\<one>,a) \\<in> R\\<^sub>+\"\n    using OrdRing_ZF_3_L8 by auto\n  with A1 show \"GreaterOf(r,\\<one>,a) \\<ra> \\<one> \\<in> R\\<^sub>+\"\n    using ordring_one_is_pos OrdRing_ZF_3_L1 IsOpClosed_def\n    by simp\n  from A1 I show \n    \"a \\<lsq> GreaterOf(r,\\<one>,a) \\<ra> \\<one>\"  \"a \\<noteq> GreaterOf(r,\\<one>,a) \\<ra> \\<one>\"\n    using OrdRing_ZF_3_L11 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1588
    },
    "1431": {
        "type": "lemma",
        "text": "text\\<open>We can multiply strict inequality by a positive element.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\" and \n  A2: \"a\\<ls>b\" and A3: \"c\\<in>R\\<^sub>+\"\n  ",
        "using": [
            "OrdRing_ZF_1_L3",
            "PositiveSet_def",
            "OrdRing_ZF_1_L9A",
            "Ring_ZF_1_L12A",
            "IsCommutative_def"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L13: \n  assumes A1: \"HasNoZeroDivs(R,A,M)\" and \n  A2: \"a\\<ls>b\" and A3: \"c\\<in>R\\<^sub>+\"\n  shows \n  \"a\\<cdot>c \\<ls> b\\<cdot>c\"\n  \"c\\<cdot>a \\<ls> c\\<cdot>b\"\n",
        "proof": "proof -\n  from A2 A3 have T: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"c\\<noteq>\\<zero>\"\n    using OrdRing_ZF_1_L3 PositiveSet_def by auto\n  from A2 A3 have \"a\\<cdot>c \\<lsq> b\\<cdot>c\" using OrdRing_ZF_1_L9A\n    by simp\n  moreover from A1 A2 T have \"a\\<cdot>c \\<noteq> b\\<cdot>c\"\n    using Ring_ZF_1_L12A by auto\n  ultimately show \"a\\<cdot>c \\<ls> b\\<cdot>c\" by simp\n  moreover from mult_commut T have \"a\\<cdot>c = c\\<cdot>a\" and \"b\\<cdot>c = c\\<cdot>b\"\n    using IsCommutative_def by auto\n  ultimately show \"c\\<cdot>a \\<ls> c\\<cdot>b\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1589
    },
    "1432": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for an element to be in the set\n  of positive ring elements.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\" and \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L3",
            "PositiveSet_def"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L14: assumes \"\\<zero>\\<lsq>a\" and \"a\\<noteq>\\<zero>\"\n  shows \"a \\<in> R\\<^sub>+\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L3 PositiveSet_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1590
    },
    "1433": {
        "type": "lemma",
        "text": "text\\<open>In rings with no zero divisors we can (strictly) increase a \n  positive element by  multiplying it by an element that is greater than $1$.\\<close>\n",
        "assumes": "assumes \"HasNoZeroDivs(R,A,M)\" and \"a \\<in> R\\<^sub>+\" and \"\\<one>\\<lsq>b\"  \"\\<one>\\<noteq>b\"\n  ",
        "using": [
            "assms",
            "PositiveSet_def",
            "OrdRing_ZF_1_L16",
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L12C"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L16: \n  assumes \"HasNoZeroDivs(R,A,M)\" and \"a \\<in> R\\<^sub>+\" and \"\\<one>\\<lsq>b\"  \"\\<one>\\<noteq>b\"\n  shows \"a\\<lsq>a\\<cdot>b\"  \"a \\<noteq> a\\<cdot>b\"\n  ",
        "proof": "using assms PositiveSet_def OrdRing_ZF_1_L16 OrdRing_ZF_1_L3 \n    Ring_ZF_1_L12C by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1592
    },
    "1434": {
        "type": "lemma",
        "text": "text\\<open>If the right hand side of an inequality is positive we can multiply it \n  by a number that is greater than one.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"b\\<in>R\\<^sub>+\" and \n  A3: \"a\\<lsq>b\"  and A4: \"\\<one>\\<ls>c\"\n  ",
        "using": [
            "OrdRing_ZF_3_L16"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L17: \n   assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"b\\<in>R\\<^sub>+\" and \n  A3: \"a\\<lsq>b\"  and A4: \"\\<one>\\<ls>c\"\n  shows \"a\\<ls>b\\<cdot>c\"\n",
        "proof": "proof -\n  from A1 A2 A4 have \"b \\<ls> b\\<cdot>c\"\n    using OrdRing_ZF_3_L16 by auto\n  with A3 show \"a\\<ls>b\\<cdot>c\" by (rule ring_strict_ord_transit)\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1593
    },
    "1435": {
        "type": "lemma",
        "text": "text\\<open>We can multiply a right hand side of an inequality between\n  positive numbers by a number that is greater than one.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"a \\<in> R\\<^sub>+\" and \n  A3: \"a\\<lsq>b\" and A4: \"\\<one>\\<ls>c\"\n  ",
        "using": [
            "OrdRing_ZF_3_L7",
            "OrdRing_ZF_3_L17"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L18: \n  assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"a \\<in> R\\<^sub>+\" and \n  A3: \"a\\<lsq>b\" and A4: \"\\<one>\\<ls>c\"\n  shows \"a\\<ls>b\\<cdot>c\"\n",
        "proof": "proof -\n  from A2 A3 have \"b \\<in> R\\<^sub>+\" using OrdRing_ZF_3_L7\n    by blast\n  with A1 A3 A4 show \"a\\<ls>b\\<cdot>c\"\n    using OrdRing_ZF_3_L17 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1594
    },
    "1436": {
        "type": "lemma",
        "text": "text\\<open>In ordered rings with no zero divisors if at \n  least one of $a,b$ is not zero, then\n  $0 < a^2+b^2$, in particular $a^2+b^2\\neq 0$.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"a\\<in>R\"  \"b\\<in>R\" and\n  A3: \"a \\<noteq> \\<zero> \\<or> b \\<noteq> \\<zero>\"\n  ",
        "using": [
            "OrdRing_ZF_3_L15",
            "OrdRing_ZF_1_L10",
            "OrdRing_ZF_1_L19",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L6",
            "Ring_ZF_1_L4"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L19: \n  assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"a\\<in>R\"  \"b\\<in>R\" and\n  A3: \"a \\<noteq> \\<zero> \\<or> b \\<noteq> \\<zero>\"\n  shows \"\\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\"\n",
        "proof": "proof -\n  { assume \"a \\<noteq> \\<zero>\"\n    with A1 A2 have \"\\<zero> \\<lsq> a\\<^sup>2\"  \"a\\<^sup>2 \\<noteq> \\<zero>\"  \n      using OrdRing_ZF_3_L15 by auto\n    then have \"\\<zero> \\<ls> a\\<^sup>2\" by auto\n    moreover from A2 have \"\\<zero> \\<lsq> b\\<^sup>2\"\n      using OrdRing_ZF_1_L10 by simp\n    ultimately have \"\\<zero> \\<ra> \\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\"\n      using OrdRing_ZF_1_L19 by simp\n    then have \"\\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\"\n      using Ring_ZF_1_L2 Ring_ZF_1_L3 by simp }\n  moreover\n  { assume A4: \"a = \\<zero>\"\n    then have \"a\\<^sup>2 \\<ra> b\\<^sup>2 = \\<zero> \\<ra> b\\<^sup>2\"\n      using  Ring_ZF_1_L2 Ring_ZF_1_L6 by simp\n    also from A2 have \"\\<dots> = b\\<^sup>2\"\n      using Ring_ZF_1_L4 Ring_ZF_1_L3 by simp\n    finally have \"a\\<^sup>2 \\<ra> b\\<^sup>2 = b\\<^sup>2\" by simp\n    moreover \n    from A3 A4 have \"b \\<noteq> \\<zero>\" by simp\n    with A1 A2 have \"\\<zero> \\<lsq> b\\<^sup>2\" and \"b\\<^sup>2 \\<noteq> \\<zero>\" \n      using OrdRing_ZF_3_L15 by auto\n    hence \"\\<zero> \\<ls> b\\<^sup>2\" by auto\n    ultimately have \"\\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\" by simp }\n  ultimately show \"\\<zero> \\<ls> a\\<^sup>2 \\<ra> b\\<^sup>2\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1595
    },
    "1437": {
        "type": "definition",
        "text": "text\\<open>The set of bisections of a given set $A$ is a set of pairs of nonempty\n  subsets of $A$ that do not overlap and their union is equal to $A$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Bisections(X) = {p \\<in> Pow(X)\\<times>Pow(X). \n  fst(p)\\<noteq>0 \\<and> snd(p)\\<noteq>0 \\<and> fst(p)\\<inter>snd(p) = 0 \\<and> fst(p)\\<union>snd(p) = X}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1596
    },
    "1438": {
        "type": "lemma",
        "text": "text\\<open>Properties of bisections.\\<close>\n",
        "assumes": "assumes \"\\<langle>A,B\\<rangle> \\<in> Bisections(X)\" ",
        "using": [
            "assms",
            "Bisections_def"
        ],
        "statement": "lemma bisec_props: assumes \"\\<langle>A,B\\<rangle> \\<in> Bisections(X)\" shows\n  \"A\\<noteq>0\"  \"B\\<noteq>0\" \"A \\<subseteq> X\"  \"B \\<subseteq> X\"  \"A \\<inter> B = 0\"  \"A \\<union> B = X\"  \"X \\<noteq> 0\"\n  ",
        "proof": "using assms Bisections_def by auto\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1597
    },
    "1439": {
        "type": "lemma",
        "text": "text\\<open>Bisection of $X$ is a pair of subsets of $X$.\\<close>\n",
        "assumes": "assumes \"Q \\<in> Bisections(X)\"\n  ",
        "using": [
            "assms",
            "Bisections_def"
        ],
        "statement": "lemma bisec_is_pair: assumes \"Q \\<in> Bisections(X)\"\n  shows \"Q = \\<langle>fst(Q), snd(Q)\\<rangle>\"\n  ",
        "proof": "using assms Bisections_def by auto\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1599
    },
    "1440": {
        "type": "lemma",
        "text": "text\\<open>The set of bisections of the empty set is empty.\\<close>\n",
        "assumes": "",
        "using": [
            "Bisections_def"
        ],
        "statement": "lemma bisec_empty: shows \"Bisections(0) = 0\"\n  ",
        "proof": "using Bisections_def by auto\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1600
    },
    "1441": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows what can we say about bisections of a set\n  with another element added.\\<close>\n",
        "assumes": "assumes A1: \"x \\<notin> X\" and A2: \"\\<langle>A,B\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  ",
        "using": [
            "singl_diff_empty",
            "Bisections_def"
        ],
        "statement": "lemma bisec_add_point: \n  assumes A1: \"x \\<notin> X\" and A2: \"\\<langle>A,B\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  shows \"(A = {x} \\<or> B = {x}) \\<or> (\\<langle>A - {x}, B - {x}\\<rangle> \\<in> Bisections(X))\"\n  ",
        "proof": "proof -\n    { assume \"A \\<noteq> {x}\" and \"B \\<noteq> {x}\"\n      with A2 have \"A - {x} \\<noteq> 0\" and \"B - {x} \\<noteq> 0\"\n\tusing singl_diff_empty Bisections_def\n\tby auto\n      moreover have \"(A - {x}) \\<union> (B - {x}) = X\"\n      proof -\n\thave \"(A - {x}) \\<union> (B - {x}) = (A \\<union> B) - {x}\"\n\t  by auto\n\talso from assms have \"(A \\<union> B) - {x} = X\"\n\t  using Bisections_def by auto\n\tfinally show ?thesis by simp\n      qed\n      moreover from A2 have \"(A - {x}) \\<inter> (B - {x}) = 0\"\n\tusing Bisections_def by auto\n      ultimately have \"\\<langle>A - {x}, B - {x}\\<rangle> \\<in> Bisections(X)\"\n\tusing Bisections_def by auto\n    } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1601
    },
    "1442": {
        "type": "lemma",
        "text": "text\\<open>A continuation of the lemma \\<open>bisec_add_point\\<close>\n  that refines the case when the pair with removed point bisects\n  the original set.\\<close>\n",
        "assumes": "assumes A1: \"\\<langle>A,B\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  and A2: \"\\<langle>A - {x}, B - {x}\\<rangle> \\<in> Bisections(X)\"\n  ",
        "using": [
            "Bisections_def",
            "singl_diff_eq"
        ],
        "statement": "lemma bisec_add_point_case3: \n  assumes A1: \"\\<langle>A,B\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  and A2: \"\\<langle>A - {x}, B - {x}\\<rangle> \\<in> Bisections(X)\"\n  shows \n  \"(\\<langle>A, B - {x}\\<rangle> \\<in> Bisections(X) \\<and> x \\<in> B) \\<or> \n  (\\<langle>A - {x}, B\\<rangle> \\<in> Bisections(X) \\<and> x \\<in> A)\"\n",
        "proof": "proof -\n  from A1 have \"x \\<in> A \\<union> B\"\n    using Bisections_def by auto\n  hence \"x\\<in>A \\<or> x\\<in>B\" by simp\n  from A1 have \"A - {x} = A \\<or> B - {x} = B\"\n    using Bisections_def by auto\n  moreover\n  { assume \"A - {x} = A\"\n    with A2 \\<open>x \\<in> A \\<union> B\\<close> have \n      \"\\<langle>A, B - {x}\\<rangle> \\<in> Bisections(X) \\<and> x \\<in> B\" \n      using singl_diff_eq by simp }\n  moreover\n  { assume \"B - {x} = B\"\n    with A2 \\<open>x \\<in> A \\<union> B\\<close> have \n      \"\\<langle>A - {x}, B\\<rangle> \\<in> Bisections(X) \\<and> x \\<in> A\"\n      using singl_diff_eq by simp }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1602
    },
    "1443": {
        "type": "lemma",
        "text": "text\\<open>Another lemma about bisecting a set with an added point.\\<close>\n",
        "assumes": "assumes A1: \"x \\<notin> X\" and A2: \"\\<langle>{x}, A\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  ",
        "using": [
            "Bisections_def"
        ],
        "statement": "lemma point_set_bisec: \n  assumes A1: \"x \\<notin> X\" and A2: \"\\<langle>{x}, A\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  shows \"A = X\" and \"X \\<noteq> 0\"\n",
        "proof": "proof -\n  from A2 have \"A \\<subseteq> X\" using Bisections_def by auto\n  moreover\n  { fix a assume \"a\\<in>X\"\n    with A2 have \"a \\<in> {x} \\<union> A\" using Bisections_def by simp\n    with A1 \\<open>a\\<in>X\\<close> have \"a \\<in> A\" by auto }\n  ultimately show \"A = X\" by auto\n  with A2 show \"X \\<noteq> 0\" using Bisections_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1603
    },
    "1444": {
        "type": "lemma",
        "text": "text\\<open>Yet another lemma about bisecting a set with an added point,\n  very similar to \\<open> point_set_bisec\\<close> with almost the same proof.\\<close>\n",
        "assumes": "assumes A1: \"x \\<notin> X\" and A2: \"\\<langle>A, {x}\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  ",
        "using": [
            "Bisections_def"
        ],
        "statement": "lemma set_point_bisec: \n  assumes A1: \"x \\<notin> X\" and A2: \"\\<langle>A, {x}\\<rangle> \\<in> Bisections(X \\<union> {x})\"\n  shows \"A = X\" and \"X \\<noteq> 0\"\n",
        "proof": "proof -\n  from A2 have \"A \\<subseteq> X\" using Bisections_def by auto\n  moreover\n  { fix a assume \"a\\<in>X\"\n    with A2 have \"a \\<in> A \\<union> {x}\" using Bisections_def by simp\n    with A1 \\<open>a\\<in>X\\<close> have \"a \\<in> A\" by auto }\n  ultimately show \"A = X\" by auto\n  with A2 show \"X \\<noteq> 0\" using Bisections_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1604
    },
    "1445": {
        "type": "lemma",
        "text": "text\\<open>If a pair of sets bisects a finite set, then both \n  elements of the pair are finite.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" and A2: \"Q \\<in> Bisections(A)\"\n  ",
        "using": [
            "bisec_is_pair",
            "bisec_props",
            "FinPow_def",
            "subset_Finite"
        ],
        "statement": "lemma bisect_fin: \n  assumes A1: \"A \\<in> FinPow(X)\" and A2: \"Q \\<in> Bisections(A)\"\n  shows \"fst(Q) \\<in> FinPow(X)\" and \"snd(Q) \\<in> FinPow(X)\"\n",
        "proof": "proof -\n  from A2 have \"\\<langle>fst(Q), snd(Q)\\<rangle> \\<in> Bisections(A)\"\n    using bisec_is_pair by simp\n  then have \"fst(Q) \\<subseteq> A\" and \"snd(Q) \\<subseteq> A\"\n    using bisec_props by auto\n  with A1 show \"fst(Q) \\<in> FinPow(X)\" and \"snd(Q) \\<in> FinPow(X)\"\n    using FinPow_def subset_Finite by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1605
    },
    "1446": {
        "type": "definition",
        "text": "text\\<open>We define a notion of a partition as a set valued function \n  such that the values for different arguments are disjoint.\n  The name is derived from the fact that such \n  function \"partitions\" the union of its arguments. \n  Please let me know if you have \n  a better idea for a name for such notion. We would prefer to say\n ''is a partition'', but that reserves the letter ''a'' as a keyword(?)\n  which causes problems.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  Partition (\"_ {is partition}\" [90] 91) where\n  \"P {is partition} \\<equiv>  \\<forall>x \\<in> domain(P). \n  P`(x) \\<noteq> 0 \\<and> (\\<forall>y \\<in> domain(P). x\\<noteq>y \\<longrightarrow> P`(x) \\<inter> P`(y) = 0)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1606
    },
    "1447": {
        "type": "lemma",
        "text": "text\\<open>A fact about lists of mutually disjoint sets.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and \n  A2: \"a : succ(n) \\<rightarrow> X\"   \"a {is partition}\"\n  ",
        "using": [
            "mem_imp_not_eq",
            "func1_1_L1",
            "Partition_def"
        ],
        "statement": "lemma list_partition: assumes A1: \"n \\<in> nat\" and \n  A2: \"a : succ(n) \\<rightarrow> X\"   \"a {is partition}\"\n  shows \"(\\<Union>i\\<in>n. a`(i)) \\<inter> a`(n) = 0\"\n",
        "proof": "proof -\n  { assume \"(\\<Union>i\\<in>n. a`(i)) \\<inter> a`(n) \\<noteq> 0\"\n    then have \"\\<exists>x. x \\<in> (\\<Union>i\\<in>n. a`(i)) \\<inter> a`(n)\"\n      by (rule nonempty_has_element)\n    then obtain x where \"x \\<in> (\\<Union>i\\<in>n. a`(i))\" and  I: \"x \\<in> a`(n)\"\n      by auto\n    then obtain i where \"i \\<in> n\" and \"x \\<in> a`(i)\" by auto\n    with A2 I have False \n      using mem_imp_not_eq func1_1_L1 Partition_def\n      by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1607
    },
    "1448": {
        "type": "lemma",
        "text": "text\\<open>We can turn every injection into a partition.\\<close>\n",
        "assumes": "assumes A1: \"b \\<in> inj(X,Y)\" \n  ",
        "using": [
            "inj_def",
            "apply_funtype",
            "ZF_fun_from_total",
            "func1_1_L1",
            "ZF_fun_from_tot_val0",
            "Partition_def"
        ],
        "statement": "lemma inj_partition: \n  assumes A1: \"b \\<in> inj(X,Y)\" \n  shows \n  \"\\<forall>x \\<in> X. {\\<langle>x, {b`(x)}\\<rangle>. x \\<in> X}`(x) = {b`(x)}\" and\n  \"{\\<langle>x, {b`(x)}\\<rangle>. x \\<in> X} {is partition}\"\n",
        "proof": "proof -\n  let ?p = \"{\\<langle>x, {b`(x)}\\<rangle>. x \\<in> X}\"\n  { fix x assume \"x \\<in> X\"\n    from A1 have \"b : X \\<rightarrow> Y\" using inj_def\n      by simp\n    with \\<open>x \\<in> X\\<close> have \"{b`(x)} \\<in> Pow(Y)\"\n       using apply_funtype by simp\n  } hence \"\\<forall>x \\<in> X. {b`(x)} \\<in> Pow(Y)\" by simp\n  then have \"?p : X \\<rightarrow> Pow(Y)\" using ZF_fun_from_total \n    by simp\n  then have \"domain(?p) = X\" using func1_1_L1\n    by simp\n  from \\<open>?p : X \\<rightarrow> Pow(Y)\\<close> show I: \"\\<forall>x \\<in> X. ?p`(x) = {b`(x)}\"\n    using ZF_fun_from_tot_val0 by simp\n  { fix x assume \"x \\<in> X\"\n    with I have \"?p`(x) = {b`(x)}\" by simp\n    hence \"?p`(x) \\<noteq> 0\" by simp\n    moreover\n    { fix t assume \"t \\<in> X\" and \"x \\<noteq> t\"\n      with A1 \\<open>x \\<in> X\\<close> have \"b`(x) \\<noteq> b`(t)\" using inj_def \n\tby auto\n      with I \\<open>x\\<in>X\\<close> \\<open>t \\<in> X\\<close> have \"?p`(x) \\<inter> ?p`(t) = 0\"\n\tby auto }\n    ultimately have \n      \"?p`(x) \\<noteq> 0 \\<and> (\\<forall>t \\<in> X. x\\<noteq>t \\<longrightarrow> ?p`(x) \\<inter> ?p`(t) = 0)\"\n      by simp\n  } with \\<open>domain(?p) = X\\<close> show \"{\\<langle>x, {b`(x)}\\<rangle>. x \\<in> X} {is partition}\"\n    using Partition_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1608
    },
    "1449": {
        "type": "definition",
        "text": "text\\<open> A quasigroup operation does not  have to have the neutral element. The left division is defined \n  as the only solution to the equation $a\\cdot x=b$ (using multiplicative notation). \n  The next definition specifies\n  what does it mean that an operation $A$ has a left division on a set $G$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasLeftDiv(G,A) \\<equiv> \\<forall>a\\<in>G.\\<forall>b\\<in>G.\\<exists>!x. (x\\<in>G \\<and> A`\\<langle>a,x\\<rangle> = b)\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1609
    },
    "1450": {
        "type": "definition",
        "text": "text\\<open> An operation $A$ has the right inverse if for all elements $a,b \\in G$ the equation $x\\cdot a=b$ \n  has a unique solution. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasRightDiv(G,A) \\<equiv> \\<forall>a\\<in>G.\\<forall>b\\<in>G.\\<exists>!x. (x\\<in>G \\<and> A`\\<langle>x,a\\<rangle> = b)\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1610
    },
    "1451": {
        "type": "definition",
        "text": "text\\<open>An operation that has both left and right division is said to have the Latin square property. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  HasLatinSquareProp (infix \"{has Latin square property on}\" 65) where\n    \"A {has Latin square property on} G \\<equiv> HasLeftDiv(G,A) \\<and> HasRightDiv(G,A)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1611
    },
    "1452": {
        "type": "definition",
        "text": "text\\<open> A quasigroup is a set with a binary operation that has the Latin square property. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAquasigroup(G,A) \\<equiv> A:G\\<times>G\\<rightarrow>G \\<and> A {has Latin square property on} G\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1612
    },
    "1453": {
        "type": "definition",
        "text": "text\\<open> The uniqueness of the left inverse allows us to define the left division as a function.\n  The union expression as the value of the function extracts the only element\n  of the set of solutions of the equation $x\\cdot z = y$ for given \n  $\\langle x,y \\rangle = p \\in G\\times G$ using the identity $\\bigcup \\{x\\} =x$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"LeftDiv(G,A) \\<equiv> {\\<langle>p,\\<Union>{z\\<in>G. A`\\<langle>fst(p),z\\<rangle> = snd(p)}\\<rangle>.p\\<in>G\\<times>G}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1613
    },
    "1454": {
        "type": "definition",
        "text": "text\\<open>Similarly the right division is defined as a function on $G\\times G$.  \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"RightDiv(G,A) \\<equiv> {\\<langle>p,\\<Union>{z\\<in>G. A`\\<langle>z,fst(p)\\<rangle> = snd(p)}\\<rangle>.p\\<in>G\\<times>G}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1614
    },
    "1455": {
        "type": "lemma",
        "text": "text\\<open>Left and right divisions are binary operations on $G$. \\<close>\n",
        "assumes": "assumes \"IsAquasigroup(G,A)\" ",
        "using": [
            "ZF1_1_L9(2)",
            "ZF_fun_from_total"
        ],
        "statement": "lemma lrdiv_binop: assumes \"IsAquasigroup(G,A)\" shows \n  \"LeftDiv(G,A):G\\<times>G\\<rightarrow>G\" and  \"RightDiv(G,A):G\\<times>G\\<rightarrow>G\"\n",
        "proof": "proof -\n  { fix p assume \"p\\<in>G\\<times>G\"\n    with assms have \n      \"\\<Union>{x\\<in>G. A`\\<langle>fst(p),x\\<rangle> = snd(p)} \\<in> G\" and  \"\\<Union>{x\\<in>G. A`\\<langle>x,fst(p)\\<rangle> = snd(p)} \\<in> G\"\n      unfolding IsAquasigroup_def HasLatinSquareProp_def HasLeftDiv_def HasRightDiv_def\n      using ZF1_1_L9(2) by auto\n  } then show  \"LeftDiv(G,A):G\\<times>G\\<rightarrow>G\" and \"RightDiv(G,A):G\\<times>G\\<rightarrow>G\" \n    unfolding LeftDiv_def RightDiv_def using ZF_fun_from_total by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1615
    },
    "1456": {
        "type": "lemma",
        "text": "text\\<open> The quasigroup operation is closed on $G$. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \"y\\<in>G\"\n  ",
        "using": [
            "qgroupassum",
            "assms",
            "IsAquasigroup_def",
            "apply_funtype"
        ],
        "statement": "lemma (in quasigroup0) qg_op_closed: assumes \"x\\<in>G\" \"y\\<in>G\"\n  shows \"x\\<cdot>y \\<in> G\"\n  ",
        "proof": "using qgroupassum assms IsAquasigroup_def apply_funtype by auto\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1616
    },
    "1457": {
        "type": "lemma",
        "text": "text\\<open> A couple of properties of right and left division: \\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \"y\\<in>G\"\n  ",
        "using": [
            "lrdiv_binop(2)",
            "ZF_fun_from_tot_val",
            "lrdiv_binop(1)",
            "apply_funtype"
        ],
        "statement": "lemma (in quasigroup0) lrdiv_props: assumes \"x\\<in>G\" \"y\\<in>G\"\n  shows \n  \"\\<exists>!z. z\\<in>G \\<and> z\\<cdot>x = y\" \"y\\<rd>x \\<in> G\" \"(y\\<rd>x)\\<cdot>x = y\" and\n  \"\\<exists>!z. z\\<in>G \\<and> x\\<cdot>z = y\" \"x\\<ld>y \\<in> G\" \"x\\<cdot>(x\\<ld>y) = y\"\n",
        "proof": "proof -\n  let ?z\\<^sub>r = \"\\<Union>{z\\<in>G. z\\<cdot>x = y}\"\n  from qgroupassum have I: \"RightDiv(G,A):G\\<times>G\\<rightarrow>G\" using lrdiv_binop(2) by simp\n  with assms have \"RightDiv(G,A)`\\<langle>x,y\\<rangle> = ?z\\<^sub>r\"\n    unfolding RightDiv_def using ZF_fun_from_tot_val by auto\n  moreover\n  from qgroupassum assms show \"\\<exists>!z. z\\<in>G \\<and> z\\<cdot>x = y\"\n    unfolding IsAquasigroup_def HasLatinSquareProp_def HasRightDiv_def by simp\n  then have \"?z\\<^sub>r\\<cdot>x = y\" by (rule ZF1_1_L9)\n  ultimately show \"(y\\<rd>x)\\<cdot>x = y\" by simp\n  let ?z\\<^sub>l = \"\\<Union>{z\\<in>G. x\\<cdot>z = y}\"\n  from qgroupassum have II: \"LeftDiv(G,A):G\\<times>G\\<rightarrow>G\" using lrdiv_binop(1) by simp\n  with assms have \"LeftDiv(G,A)`\\<langle>x,y\\<rangle> = ?z\\<^sub>l\"\n    unfolding LeftDiv_def using ZF_fun_from_tot_val by auto\n  moreover\n  from qgroupassum assms show \"\\<exists>!z. z\\<in>G \\<and> x\\<cdot>z = y\"\n    unfolding IsAquasigroup_def HasLatinSquareProp_def HasLeftDiv_def by simp\n  then have \"x\\<cdot>?z\\<^sub>l = y\" by (rule ZF1_1_L9)\n  ultimately show \"x\\<cdot>(x\\<ld>y) = y\" by simp\n  from assms I II show \"y\\<rd>x \\<in> G\" and \"x\\<ld>y \\<in> G\" using apply_funtype by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1617
    },
    "1458": {
        "type": "lemma",
        "text": "text\\<open> We can cancel the left element on both sides of an equation. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \"y\\<in>G\" \"z\\<in>G\" and \"x\\<cdot>y = x\\<cdot>z\"\n  ",
        "using": [
            "qgroupassum",
            "assms",
            "qg_op_closed",
            "lrdiv_props(4)"
        ],
        "statement": "lemma (in quasigroup0) qg_cancel_left: \n  assumes \"x\\<in>G\" \"y\\<in>G\" \"z\\<in>G\" and \"x\\<cdot>y = x\\<cdot>z\"\n  shows \"y=z\"\n  ",
        "proof": "using qgroupassum assms qg_op_closed lrdiv_props(4) by blast\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1618
    },
    "1459": {
        "type": "lemma",
        "text": "text\\<open> We can cancel the right element on both sides of an equation. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \"y\\<in>G\" \"z\\<in>G\" and \"y\\<cdot>x = z\\<cdot>x\"\n  ",
        "using": [
            "qgroupassum",
            "assms",
            "qg_op_closed",
            "lrdiv_props(1)"
        ],
        "statement": "lemma (in quasigroup0) qg_cancel_right: \n  assumes \"x\\<in>G\" \"y\\<in>G\" \"z\\<in>G\" and \"y\\<cdot>x = z\\<cdot>x\"\n  shows \"y=z\"\n  ",
        "proof": "using qgroupassum assms qg_op_closed lrdiv_props(1) by blast\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1619
    },
    "1460": {
        "type": "lemma",
        "text": "text\\<open> Two additional identities for right and left division: \\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \"y\\<in>G\"\n  ",
        "using": [
            "qg_op_closed",
            "lrdiv_props(2,3)",
            "qg_cancel_right",
            "lrdiv_props(5,6)",
            "qg_cancel_left"
        ],
        "statement": "lemma (in quasigroup0) lrdiv_ident: assumes \"x\\<in>G\" \"y\\<in>G\"\n  shows \"(y\\<cdot>x)\\<rd>x = y\" and \"x\\<ld>(x\\<cdot>y) = y\"\n",
        "proof": "proof -\n  from assms have \"(y\\<cdot>x)\\<rd>x \\<in> G\" and \"((y\\<cdot>x)\\<rd>x)\\<cdot>x = y\\<cdot>x\"\n    using qg_op_closed lrdiv_props(2,3) by auto\n  with assms show \"(y\\<cdot>x)\\<rd>x = y\" using qg_cancel_right by simp\n  from assms have \"x\\<ld>(x\\<cdot>y) \\<in> G\" and \"x\\<cdot>(x\\<ld>(x\\<cdot>y)) = x\\<cdot>y\"\n    using qg_op_closed lrdiv_props(5,6) by auto\n  with assms show \"x\\<ld>(x\\<cdot>y) = y\" using qg_cancel_left by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Quasigroup_ZF.thy",
        "id": 1620
    },
    "1461": {
        "type": "definition",
        "text": "text\\<open>The set of slopes is defined as the set of almost homomorphisms\n  on the additive group of integers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Slopes \\<equiv> AlmostHoms(int,IntegerAddition)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1621
    },
    "1462": {
        "type": "definition",
        "text": "text\\<open>The first operation on slopes (pointwise addition) is a special case \n  of the first operation on almost homomorphisms.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SlopeOp1 \\<equiv> AlHomOp1(int,IntegerAddition)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1622
    },
    "1463": {
        "type": "definition",
        "text": "text\\<open>The second operation on slopes (composition) is a special case \n  of the second operation on almost homomorphisms.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SlopeOp2 \\<equiv> AlHomOp2(int,IntegerAddition)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1623
    },
    "1464": {
        "type": "definition",
        "text": "text\\<open>Bounded integer maps are functions from integers\n  to integers that have finite range. They play a role of \n  zero in the set of real numbers we are constructing.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"BoundedIntMaps \\<equiv> FinRangeFunctions(int,int)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1624
    },
    "1465": {
        "type": "definition",
        "text": "text\\<open>Bounded integer maps form a normal subgroup of slopes.\n  The equivalence relation on slopes is the (group) quotient \n  relation defined by this subgroup.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SlopeEquivalenceRel \\<equiv> QuotientGroupRel(Slopes,SlopeOp1,BoundedIntMaps)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1625
    },
    "1466": {
        "type": "definition",
        "text": "text\\<open>The set of real numbers is the set of equivalence classes of\n  slopes.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"RealNumbers \\<equiv> Slopes//SlopeEquivalenceRel\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1626
    },
    "1467": {
        "type": "definition",
        "text": "text\\<open>The addition on real numbers is defined as the projection of \n  pointwise addition of slopes on the quotient. This means that\n  the additive group of real numbers is the quotient group: \n  the group of slopes (with pointwise addition) defined by the\n  normal subgroup of bounded integer maps.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"RealAddition \\<equiv> ProjFun2(Slopes,SlopeEquivalenceRel,SlopeOp1)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1627
    },
    "1468": {
        "type": "definition",
        "text": "text\\<open>Multiplication is defined as the projection of composition\n  of slopes on the quotient. The fact that it works is probably the\n  most surprising part of the construction.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"RealMultiplication \\<equiv> ProjFun2(Slopes,SlopeEquivalenceRel,SlopeOp2)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1628
    },
    "1469": {
        "type": "theorem",
        "text": "text\\<open>Real numbers form a ring. This is a special case of the theorem\n  proven in \\<open>Ring_ZF_1.thy\\<close>, where we show the same in general for \n  almost homomorphisms rather than slopes.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L1",
            "group1.Ring_ZF_1_1_T1",
            "Slopes_def",
            "SlopeOp2_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "RealNumbers_def",
            "RealAddition_def",
            "RealMultiplication_def"
        ],
        "statement": "theorem Real_ZF_1_T1: shows \"IsAring(RealNumbers,RealAddition,RealMultiplication)\"\n",
        "proof": "proof -\n  let ?AH = \"AlmostHoms(int,IntegerAddition)\"\n  let ?Op1 = \"AlHomOp1(int,IntegerAddition)\"\n  let ?FR = \"FinRangeFunctions(int,int)\"\n  let ?Op2 = \"AlHomOp2(int,IntegerAddition)\"\n  let ?R = \"QuotientGroupRel(?AH,?Op1,?FR)\"\n  let ?A = \"ProjFun2(?AH,?R,?Op1)\"\n  let ?M = \"ProjFun2(?AH,?R,?Op2)\"\n  have \"IsAring(?AH//?R,?A,?M)\" using Real_ZF_1_L1 group1.Ring_ZF_1_1_T1\n    by simp\n  then show ?thesis using Slopes_def SlopeOp2_def SlopeOp1_def \n    BoundedIntMaps_def SlopeEquivalenceRel_def RealNumbers_def\n    RealAddition_def RealMultiplication_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1630
    },
    "1470": {
        "type": "lemma",
        "text": "text\\<open>We can use theorems proven in \\<open>group0\\<close> and \\<open>group1\\<close>\n  contexts applied to the group of real numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_T1",
            "IsAring_def",
            "group1_axioms.intro",
            "group0_def",
            "group1_def"
        ],
        "statement": "lemma Real_ZF_1_L2: shows\n  \"group0(RealNumbers,RealAddition)\"\n  \"RealAddition {is commutative on} RealNumbers\"\n  \"group1(RealNumbers,RealAddition)\"\n",
        "proof": "proof -\n  have \n    \"IsAgroup(RealNumbers,RealAddition)\"\n    \"RealAddition {is commutative on} RealNumbers\"\n    using Real_ZF_1_T1 IsAring_def by auto\n  then show \n    \"group0(RealNumbers,RealAddition)\"\n    \"RealAddition {is commutative on} RealNumbers\"\n    \"group1(RealNumbers,RealAddition)\"\n    using group1_axioms.intro group0_def group1_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1631
    },
    "1471": {
        "type": "lemma",
        "text": "text\\<open>In \\<open>real0\\<close> context all theorems proven in the \\<open>ring0\\<close>,\n  context are valid.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_T1",
            "ring0_def",
            "ring0.Ring_ZF_1_L1"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L3: shows \n  \"ring0(\\<real>,RealAddition,RealMultiplication)\"\n  ",
        "proof": "using Real_ZF_1_T1 ring0_def ring0.Ring_ZF_1_L1 \n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1632
    },
    "1472": {
        "type": "lemma",
        "text": "text\\<open>Lets try out our notation to see that zero and one are real numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L3",
            "ring0.Ring_ZF_1_L2"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L4: shows \"\\<zero>\\<in>\\<real>\"  \"\\<one>\\<in>\\<real>\"\n  ",
        "proof": "using Real_ZF_1_L3 ring0.Ring_ZF_1_L2 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1633
    },
    "1473": {
        "type": "lemma",
        "text": "text\\<open>The lemma below lists some properties that\n  require one real number to state.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L3",
            "ring0.Ring_ZF_1_L3"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L5: assumes A1: \"a\\<in>\\<real>\"\n  shows \n  \"(\\<rm>a) \\<in> \\<real>\"\n  \"(\\<rm>(\\<rm>a)) = a\"\n  \"a\\<ra>\\<zero> = a\" \n  \"\\<zero>\\<ra>a = a\" \n  \"a\\<cdot>\\<one> = a\" \n  \"\\<one>\\<cdot>a = a\" \n  \"a\\<rs>a = \\<zero>\" \n  \"a\\<rs>\\<zero> = a\"  \n  ",
        "proof": "using assms Real_ZF_1_L3 ring0.Ring_ZF_1_L3 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1634
    },
    "1474": {
        "type": "lemma",
        "text": "text\\<open>The lemma below lists some properties that\n  require two real numbers to state.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L3",
            "ring0.Ring_ZF_1_L4",
            "ring0.Ring_ZF_1_L7"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L6: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  shows \n  \"a\\<ra>b \\<in> \\<real>\" \n  \"a\\<rs>b \\<in> \\<real>\" \n  \"a\\<cdot>b \\<in> \\<real>\" \n  \"a\\<ra>b = b\\<ra>a\"\n  \"(\\<rm>a)\\<cdot>b = \\<rm>(a\\<cdot>b)\" \n  \"a\\<cdot>(\\<rm>b) = \\<rm>(a\\<cdot>b)\"\n  ",
        "proof": "using assms Real_ZF_1_L3 ring0.Ring_ZF_1_L4 ring0.Ring_ZF_1_L7\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1635
    },
    "1475": {
        "type": "lemma",
        "text": "text\\<open>Multiplication of reals is associative.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L3",
            "ring0.Ring_ZF_1_L11"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L6A: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n  shows \"a\\<cdot>(b\\<cdot>c) = (a\\<cdot>b)\\<cdot>c\"\n  ",
        "proof": "using assms Real_ZF_1_L3 ring0.Ring_ZF_1_L11 \n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1636
    },
    "1476": {
        "type": "lemma",
        "text": "text\\<open>Addition is distributive with respect to multiplication.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\" \n  ",
        "using": [
            "assms",
            "Real_ZF_1_L3",
            "ring0.ring_oper_distr",
            "ring0.Ring_ZF_1_L8"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L7: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\" \n  shows \n  \"a\\<cdot>(b\\<ra>c) = a\\<cdot>b \\<ra> a\\<cdot>c\" \n  \"(b\\<ra>c)\\<cdot>a = b\\<cdot>a \\<ra> c\\<cdot>a\"\n  \"a\\<cdot>(b\\<rs>c) = a\\<cdot>b \\<rs> a\\<cdot>c\"  \n  \"(b\\<rs>c)\\<cdot>a = b\\<cdot>a \\<rs> c\\<cdot>a\"\n  ",
        "proof": "using assms Real_ZF_1_L3 ring0.ring_oper_distr  ring0.Ring_ZF_1_L8 \n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1637
    },
    "1477": {
        "type": "lemma",
        "text": "text\\<open>A simple rearrangement with four real numbers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"  \"d\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L2",
            "group0.group0_4_L8A"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L7A: \n  assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"  \"d\\<in>\\<real>\"\n  shows \"a\\<rs>b \\<ra> (c\\<rs>d) = a\\<ra>c\\<rs>b\\<rs>d\"\n  ",
        "proof": "using assms Real_ZF_1_L2 group0.group0_4_L8A by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1638
    },
    "1478": {
        "type": "lemma",
        "text": "text\\<open>The symbol \\<open>\\<zero>\\<close> in the \\<open>real0\\<close> context is defined\n  as the neutral element of real addition. The next lemma shows that this\n  is the same as the neutral element of the appriopriate quotient group.\\<close>\n",
        "assumes": "assumes\n  \"AH = AlmostHoms(int,IntegerAddition)\" and\n  \"Op1 = AlHomOp1(int,IntegerAddition)\" and\n  \"FR = FinRangeFunctions(int,int)\" and \n  \"r = QuotientGroupRel(AH,Op1,FR)\"\n  ",
        "using": [
            "assms",
            "Slopes_def",
            "Real_ZF_1_L8",
            "RealNumbers_def",
            "SlopeEquivalenceRel_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L9: assumes\n  \"AH = AlmostHoms(int,IntegerAddition)\" and\n  \"Op1 = AlHomOp1(int,IntegerAddition)\" and\n  \"FR = FinRangeFunctions(int,int)\" and \n  \"r = QuotientGroupRel(AH,Op1,FR)\"\n  shows \n  \"TheNeutralElement(AH//r,QuotientGroupOp(AH,Op1,FR)) = \\<zero>\"\n  \"SlopeEquivalenceRel = r\"\n  ",
        "proof": "using assms Slopes_def Real_ZF_1_L8 RealNumbers_def\n    SlopeEquivalenceRel_def SlopeOp1_def BoundedIntMaps_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1640
    },
    "1479": {
        "type": "lemma",
        "text": "text\\<open>Zero is the class of any finite range function.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> Slopes\"\n  ",
        "using": [
            "Real_ZF_1_L1",
            "Slopes_def",
            "group1.Group_ZF_3_3_L5",
            "SlopeEquivalenceRel_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "Real_ZF_1_L9"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L10: \n  assumes A1: \"s \\<in> Slopes\"\n  shows \"SlopeEquivalenceRel``{s} = \\<zero> \\<longleftrightarrow> s \\<in> BoundedIntMaps\"\n",
        "proof": "proof -\n  let ?AH = \"AlmostHoms(int,IntegerAddition)\"\n  let ?Op1 = \"AlHomOp1(int,IntegerAddition)\"\n  let ?FR = \"FinRangeFunctions(int,int)\"\n  let ?r = \"QuotientGroupRel(?AH,?Op1,?FR)\"\n  let ?e = \"TheNeutralElement(?AH//?r,QuotientGroupOp(?AH,?Op1,?FR))\"\n  from A1 have \n    \"group1(int,IntegerAddition)\"\n    \"s\\<in>?AH\"\n    using Real_ZF_1_L1 Slopes_def\n    by auto\n  then have \"?r``{s} = ?e \\<longleftrightarrow> s \\<in> ?FR\"\n    using group1.Group_ZF_3_3_L5 by simp\n  moreover have \n    \"?r = SlopeEquivalenceRel\"\n    \"?e = \\<zero>\"\n    \"?FR = BoundedIntMaps\"\n    using SlopeEquivalenceRel_def Slopes_def SlopeOp1_def \n      BoundedIntMaps_def Real_ZF_1_L9 by auto\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1641
    },
    "1480": {
        "type": "lemma",
        "text": "text\\<open>We will need a couple of results from \\<open>Group_ZF_3.thy\\<close> \n  The first two that state that the definition\n  of addition and multiplication of real numbers are consistent, \n  that is the result \n  does not depend on the choice of the slopes representing the numbers.\n  The second one implies that what we call \\<open>SlopeEquivalenceRel\\<close> \n  is actually an equivalence relation on the set of slopes.\n  We also show that the neutral element of the multiplicative operation on\n  reals (in short number $1$) is the class of the identity function on \n  integers.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L1",
            "group1.Group_ZF_3_4_L13A",
            "group1.Group_ZF_3_3_L4",
            "SlopeEquivalenceRel_def",
            "SlopeOp1_def",
            "Slopes_def",
            "BoundedIntMaps_def",
            "SlopeOp2_def",
            "group1.Group_ZF_3_3_L3",
            "equiv_type",
            "group1.Group_ZF_3_4_T2",
            "RealNumbers_def",
            "RealMultiplication_def",
            "group1.Group_ZF_3_3_L1"
        ],
        "statement": "lemma Real_ZF_1_L11: shows\n  \"Congruent2(SlopeEquivalenceRel,SlopeOp1)\"\n  \"Congruent2(SlopeEquivalenceRel,SlopeOp2)\"\n  \"SlopeEquivalenceRel \\<subseteq> Slopes \\<times> Slopes\"\n  \"equiv(Slopes, SlopeEquivalenceRel)\"\n  \"SlopeEquivalenceRel``{id(int)} = \n  TheNeutralElement(RealNumbers,RealMultiplication)\"\n  \"BoundedIntMaps \\<subseteq> Slopes\"\n",
        "proof": "proof -\n  let ?G = \"int\"\n  let ?f = \"IntegerAddition\"\n  let ?AH = \"AlmostHoms(int,IntegerAddition)\"\n  let ?Op1 = \"AlHomOp1(int,IntegerAddition)\"\n  let ?Op2 = \"AlHomOp2(int,IntegerAddition)\"\n  let ?FR = \"FinRangeFunctions(int,int)\"\n  let ?R = \"QuotientGroupRel(?AH,?Op1,?FR)\"\n   have \n     \"Congruent2(?R,?Op1)\"\n     \"Congruent2(?R,?Op2)\"\n    using Real_ZF_1_L1 group1.Group_ZF_3_4_L13A group1.Group_ZF_3_3_L4\n    by auto\n  then show \n    \"Congruent2(SlopeEquivalenceRel,SlopeOp1)\"\n    \"Congruent2(SlopeEquivalenceRel,SlopeOp2)\"\n    using SlopeEquivalenceRel_def SlopeOp1_def Slopes_def \n      BoundedIntMaps_def SlopeOp2_def by auto\n  have \"equiv(?AH,?R)\"\n    using Real_ZF_1_L1 group1.Group_ZF_3_3_L3 by simp\n  then show \"equiv(Slopes,SlopeEquivalenceRel)\"\n    using BoundedIntMaps_def SlopeEquivalenceRel_def SlopeOp1_def Slopes_def\n    by simp\n  then show \"SlopeEquivalenceRel \\<subseteq> Slopes \\<times> Slopes\"\n    using equiv_type by simp\n  have \"?R``{id(int)} = TheNeutralElement(?AH//?R,ProjFun2(?AH,?R,?Op2))\"\n    using Real_ZF_1_L1 group1.Group_ZF_3_4_T2 by simp\n  then show  \"SlopeEquivalenceRel``{id(int)} = \n    TheNeutralElement(RealNumbers,RealMultiplication)\"\n    using Slopes_def RealNumbers_def\n    SlopeEquivalenceRel_def SlopeOp1_def BoundedIntMaps_def\n    RealMultiplication_def SlopeOp2_def\n    by simp\n  have \"?FR \\<subseteq> ?AH\" using Real_ZF_1_L1 group1.Group_ZF_3_3_L1\n    by simp\n  then show \"BoundedIntMaps \\<subseteq> Slopes\"\n    using BoundedIntMaps_def Slopes_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1642
    },
    "1481": {
        "type": "lemma",
        "text": "text\\<open>A one-side implication of the equivalence from \\<open>Real_ZF_1_L10\\<close>:\n  the class of a bounded integer map is the real zero.\\<close>\n",
        "assumes": "assumes \"s \\<in> BoundedIntMaps\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L11",
            "Real_ZF_1_L10"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L11A: assumes \"s \\<in> BoundedIntMaps\"\n  shows \"SlopeEquivalenceRel``{s} = \\<zero>\"\n  ",
        "proof": "using assms Real_ZF_1_L11 Real_ZF_1_L10 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1643
    },
    "1482": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is rephrases the result from \\<open>Group_ZF_3.thy\\<close>\n  that says that the negative (the group inverse with respect to real \n  addition) of the class of a slope is the class of that slope \n  composed with the integer additive group inverse. The result and proof is not\n  very readable as we use mostly generic set theory notation with long names \n  here. \\<open>Real_ZF_1.thy\\<close> contains the same statement written in a more\n  readable notation: $[-s] = -[s]$.\\<close>\n",
        "assumes": "assumes A1: \"s \\<in> Slopes\" and \n  Dr: \"r = QuotientGroupRel(Slopes,SlopeOp1,BoundedIntMaps)\"\n  ",
        "using": [
            "Real_ZF_1_L1",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "group1.Group_ZF_3_3_L6",
            "RealNumbers_def",
            "SlopeEquivalenceRel_def",
            "RealAddition_def"
        ],
        "statement": "lemma (in real0) Real_ZF_1_L12: assumes A1: \"s \\<in> Slopes\" and \n  Dr: \"r = QuotientGroupRel(Slopes,SlopeOp1,BoundedIntMaps)\"\n  shows \"r``{GroupInv(int,IntegerAddition) O s} = \\<rm>(r``{s})\"\n",
        "proof": "proof -\n  let ?G = \"int\"\n  let ?f = \"IntegerAddition\"\n  let ?AH = \"AlmostHoms(int,IntegerAddition)\"\n  let ?Op1 = \"AlHomOp1(int,IntegerAddition)\"\n  let ?FR = \"FinRangeFunctions(int,int)\"\n  let ?F = \"ProjFun2(Slopes,r,SlopeOp1)\"\n  from A1 Dr have \n    \"group1(?G, ?f)\" \n    \"s \\<in> AlmostHoms(?G, ?f)\"\n    \"r = QuotientGroupRel(\n    AlmostHoms(?G, ?f), AlHomOp1(?G, ?f), FinRangeFunctions(?G, ?G))\"\n    and \"?F = ProjFun2(AlmostHoms(?G, ?f), r, AlHomOp1(?G, ?f))\"\n    using Real_ZF_1_L1 Slopes_def SlopeOp1_def BoundedIntMaps_def\n    by auto\n  then have\n    \"r``{GroupInv(?G, ?f) O s} =\n    GroupInv(AlmostHoms(?G, ?f) // r, ?F)`(r `` {s})\"\n    using group1.Group_ZF_3_3_L6 by simp\n  with Dr show ?thesis\n    using RealNumbers_def Slopes_def SlopeEquivalenceRel_def RealAddition_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1644
    },
    "1483": {
        "type": "lemma",
        "text": "text\\<open>Two classes are equal iff the slopes that represent them \n  are almost equal.\\<close>\n",
        "assumes": "assumes \"s \\<in> Slopes\"  \"p \\<in> Slopes\"\n  and \"r = SlopeEquivalenceRel\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L11",
            "eq_equiv_class",
            "equiv_class_eq"
        ],
        "statement": "lemma Real_ZF_1_L13: assumes \"s \\<in> Slopes\"  \"p \\<in> Slopes\"\n  and \"r = SlopeEquivalenceRel\"\n  shows \"r``{s} = r``{p} \\<longleftrightarrow> \\<langle>s,p\\<rangle> \\<in>  r\"\n  ",
        "proof": "using assms Real_ZF_1_L11 eq_equiv_class equiv_class_eq\n  by blast\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1645
    },
    "1484": {
        "type": "lemma",
        "text": "text\\<open>Identity function on integers is a slope.\n  This lemma  concludes the easy part of the construction that follows from\n  the fact that slope equivalence classes form a ring. It is easy to see\n  that multiplication of classes of almost homomorphisms is not \n  commutative in general.\n  The remaining properties of real numbers, like commutativity of \n  multiplication and the existence of multiplicative inverses have to be \n  proven using properties of the group of integers, rather that in general\n  setting of abelian groups. This is done in the \\<open>Real_ZF_1\\<close> theory.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L1",
            "group1.Group_ZF_3_4_L15",
            "Slopes_def"
        ],
        "statement": "lemma Real_ZF_1_L14: shows \"id(int) \\<in> Slopes\"\n",
        "proof": "proof -\n  have \"id(int) \\<in> AlmostHoms(int,IntegerAddition)\"\n    using Real_ZF_1_L1 group1.Group_ZF_3_4_L15\n    by simp\n  then show ?thesis using Slopes_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1646
    },
    "1485": {
        "type": "definition",
        "text": "text\\<open>We define positive slopes as those that take an infinite number of \n  posititive values on the positive integers (see \\<open>Int_ZF_2\\<close> \n  for properties of positive slopes).\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"PositiveSlopes \\<equiv> {s \\<in> Slopes. \n  s``(PositiveIntegers) \\<inter>  PositiveIntegers \\<notin> Fin(int)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1647
    },
    "1486": {
        "type": "definition",
        "text": "text\\<open>The order on the set of real numbers is constructed by \n  specifying the set of positive reals. This set is defined\n  as  the projection of the set of positive slopes.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"PositiveReals \\<equiv> {SlopeEquivalenceRel``{s}. s \\<in> PositiveSlopes}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1648
    },
    "1487": {
        "type": "definition",
        "text": "text\\<open>The order relation on real numbers is constructed from the set of \n  positive elements in a standard way (see section \n  \"Alternative definitions\" in \\<open>OrderedGroup_ZF\\<close>.)\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"OrderOnReals \\<equiv> OrderFromPosSet(RealNumbers,RealAddition,PositiveReals)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1649
    },
    "1488": {
        "type": "lemma",
        "text": "text\\<open>Let's recall a theorem from \\<open>Int_ZF_2.thy\\<close> that states that \n  if $f,g$ are slopes,\n  then $f\\circ g$ is equivalent to $g\\circ f$. \n  Here we conclude from that that\n  the classes of $f\\circ g$ and $g\\circ f$ are the same.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  ",
        "using": [
            "Slopes_def",
            "int1.Arthan_Th_9",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "SlopeOp2_def",
            "Real_ZF_1_L11",
            "equiv_class_eq"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L2: assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  shows \"[f\\<circ>g] = [g\\<circ>f]\"\n",
        "proof": "proof -\n  from A1 have \"f\\<circ>g \\<sim> g\\<circ>f\" \n    using Slopes_def int1.Arthan_Th_9 SlopeOp1_def BoundedIntMaps_def\n      SlopeEquivalenceRel_def SlopeOp2_def by simp\n  then show ?thesis using Real_ZF_1_L11 equiv_class_eq\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1650
    },
    "1489": {
        "type": "lemma",
        "text": "text\\<open>Classes of slopes are real numbers.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"\n  ",
        "using": [
            "Slopes_def",
            "quotientI",
            "RealNumbers_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L3: assumes A1: \"f \\<in> \\<S>\"\n  shows \"[f] \\<in> \\<real>\"\n",
        "proof": "proof -\n  from A1 have \"[f] \\<in> Slopes//SlopeEquivalenceRel\"\n    using Slopes_def quotientI by simp\n  then show \"[f] \\<in> \\<real>\" using RealNumbers_def by simp  \nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1651
    },
    "1490": {
        "type": "lemma",
        "text": "text\\<open>Each real number is a class of a slope.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "RealNumbers_def",
            "Slopes_def",
            "quotient_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L3A: assumes A1: \"a\\<in>\\<real>\"\n  shows \"\\<exists>f\\<in>\\<S> . a = [f]\"\n",
        "proof": "proof -\n  from A1 have \"a \\<in> \\<S>//SlopeEquivalenceRel\" \n    using RealNumbers_def Slopes_def by simp\n  then show ?thesis using quotient_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1652
    },
    "1491": {
        "type": "lemma",
        "text": "text\\<open>It is useful to have the definition of addition and multiplication \n  in the \\<open>real1\\<close> context notation.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  ",
        "using": [
            "RealMultiplication_def",
            "Slopes_def",
            "Real_ZF_1_L11",
            "EquivClass_1_L10",
            "RealAddition_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L4: \n  assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  shows\n  \"[f] \\<ra> [g] = [f\\<fp>g]\"\n  \"[f] \\<cdot> [g] = [f\\<circ>g]\"\n",
        "proof": "proof -\n  let ?r = \"SlopeEquivalenceRel\"\n  have \"[f]\\<cdot>[g] = ProjFun2(\\<S>,?r,SlopeOp2)`\\<langle>[f],[g]\\<rangle>\"\n    using RealMultiplication_def Slopes_def by simp\n  also from A1 have \"\\<dots> = [f\\<circ>g]\"\n    using Real_ZF_1_L11 EquivClass_1_L10 Slopes_def\n    by simp\n  finally show \"[f] \\<cdot> [g] = [f\\<circ>g]\" by simp\n  have \"[f] \\<ra> [g] = ProjFun2(\\<S>,?r,SlopeOp1)`\\<langle>[f],[g]\\<rangle>\"\n    using RealAddition_def Slopes_def by simp\n  also from A1 have \"\\<dots> = [f\\<fp>g]\"\n    using Real_ZF_1_L11 EquivClass_1_L10 Slopes_def\n    by simp\n  finally show \"[f] \\<ra> [g] = [f\\<fp>g]\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1653
    },
    "1492": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is essentially the same as \\<open> Real_ZF_1_L12\\<close>, but\n  written in the notation defined in the \\<open>real1\\<close> context. It states\n  that if $f$ is a slope, then $-[f] = [-f]$.\\<close>\n",
        "assumes": "assumes \"f \\<in> \\<S>\"\n  ",
        "using": [
            "assms",
            "Slopes_def",
            "SlopeEquivalenceRel_def",
            "Real_ZF_1_L12"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L4A: assumes \"f \\<in> \\<S>\"\n  shows \"[\\<fm>f] = \\<rm>[f]\"\n  ",
        "proof": "using assms Slopes_def SlopeEquivalenceRel_def Real_ZF_1_L12\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1654
    },
    "1493": {
        "type": "lemma",
        "text": "text\\<open>Subtracting real numbers correspods to adding the opposite slope.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  ",
        "using": [
            "Slopes_def",
            "BoundedIntMaps_def",
            "int1.Int_ZF_2_1_L12",
            "Real_ZF_1_1_L4",
            "Real_ZF_1_1_L4A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L4B: assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  shows \"[f] \\<rs> [g] = [f\\<fp>(\\<fm>g)]\"\n",
        "proof": "proof -\n  from A1 have \"[f\\<fp>(\\<fm>g)] = [f] \\<ra> [\\<fm>g]\"\n    using Slopes_def BoundedIntMaps_def int1.Int_ZF_2_1_L12\n      Real_ZF_1_1_L4 by simp\n  with A1 show \"[f] \\<rs> [g] = [f\\<fp>(\\<fm>g)]\"\n    using Real_ZF_1_1_L4A by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1655
    },
    "1494": {
        "type": "theorem",
        "text": "text\\<open>Multiplication of real numbers is commutative.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_1_L3A",
            "Real_ZF_1_1_L4",
            "Real_ZF_1_1_L2"
        ],
        "statement": "theorem (in real1) real_mult_commute: assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  shows \"a\\<cdot>b = b\\<cdot>a\"\n",
        "proof": "proof -\n  from A1 have \n    \"\\<exists>f\\<in>\\<S> . a = [f]\"\n    \"\\<exists>g\\<in>\\<S> . b = [g]\"\n    using Real_ZF_1_1_L3A by auto\n  then obtain f g where \n    \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\" and \"a = [f]\"  \"b = [g]\" \n    by auto\n  then show \"a\\<cdot>b = b\\<cdot>a\"\n    using Real_ZF_1_1_L4 Real_ZF_1_1_L2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1656
    },
    "1495": {
        "type": "lemma",
        "text": "text\\<open>Multiplication is commutative on reals.\\<close>\n",
        "assumes": "",
        "using": [
            "real1.real_mult_commute",
            "IsCommutative_def"
        ],
        "statement": "lemma real_mult_commutative: shows\n  \"RealMultiplication {is commutative on} RealNumbers\"\n  ",
        "proof": "using real1.real_mult_commute IsCommutative_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1657
    },
    "1496": {
        "type": "lemma",
        "text": "text\\<open>The neutral element of multiplication of reals \n  (denoted as \\<open>\\<one>\\<close> in the \\<open>real1\\<close> context) \n  is the class of identity function on integers. This is really shown\n  in \\<open>Real_ZF_1_L11\\<close>, here we only rewrite it in the notation used\n  in the \\<open>real1\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L11"
        ],
        "statement": "lemma (in real1) real_one_cl_identity: shows \"[id(int)] = \\<one>\"\n  ",
        "proof": "using Real_ZF_1_L11 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1658
    },
    "1497": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is bounded, then its class is the neutral element of additive \n  operation on reals (denoted as \\<open>\\<zero>\\<close> in the \\<open>real1\\<close> context).\\<close>\n",
        "assumes": "assumes \"f \\<in> BoundedIntMaps\" ",
        "using": [
            "assms",
            "Real_ZF_1_L11A"
        ],
        "statement": "lemma (in real1) real_zero_cl_bounded_map: \n  assumes \"f \\<in> BoundedIntMaps\" shows \"[f] = \\<zero>\"\n  ",
        "proof": "using assms Real_ZF_1_L11A by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1659
    },
    "1498": {
        "type": "lemma",
        "text": "text\\<open>Two real numbers are equal iff the slopes that represent them are \n  almost equal. This is proven in \\<open>Real_ZF_1_L13\\<close>, here we just \n  rewrite it in the notation used in the \\<open>real1\\<close> context.\\<close>\n",
        "assumes": "assumes \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  ",
        "using": [
            "assms",
            "Slopes_def",
            "Real_ZF_1_L13"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L5: \n  assumes \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  shows \"[f] = [g] \\<longleftrightarrow> f \\<sim> g\"\n  ",
        "proof": "using assms Slopes_def Real_ZF_1_L13 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1660
    },
    "1499": {
        "type": "lemma",
        "text": "text\\<open>If the pair of function belongs to the slope equivalence relation, then\n  their classes are equal. This is convenient, because we don't need to assume\n  that $f,g$ are slopes (follows from the fact that $f\\sim g$).\\<close>\n",
        "assumes": "assumes \"f \\<sim> g\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_L11",
            "Slopes_def",
            "Real_ZF_1_1_L5"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L5A: assumes \"f \\<sim> g\"\n  shows \"[f] = [g]\"\n  ",
        "proof": "using assms Real_ZF_1_L11 Slopes_def Real_ZF_1_1_L5\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1661
    },
    "1500": {
        "type": "lemma",
        "text": "text\\<open>Identity function on integers is a slope. \n  This is proven in \\<open>Real_ZF_1_L13\\<close>, here we just \n  rewrite it in the notation used in the \\<open>real1\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L14",
            "Slopes_def"
        ],
        "statement": "lemma (in real1) id_on_int_is_slope: shows \"id(int) \\<in> \\<S>\"\n  ",
        "proof": "using Real_ZF_1_L14 Slopes_def by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1662
    },
    "1501": {
        "type": "lemma",
        "text": "text\\<open>A result from \\<open>Int_ZF_2.thy\\<close>: the identity function on integers\n  is not almost equal to any bounded function.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> BoundedIntMaps\"\n  ",
        "using": [
            "assms",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "int1.Int_ZF_2_3_L12"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L7:\n  assumes A1: \"f \\<in> BoundedIntMaps\"\n  shows \"\\<not>(id(int) \\<sim> f)\"\n  ",
        "proof": "using assms Slopes_def SlopeOp1_def BoundedIntMaps_def \n    SlopeEquivalenceRel_def BoundedIntMaps_def int1.Int_ZF_2_3_L12 \n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1663
    },
    "1502": {
        "type": "lemma",
        "text": "text\\<open>Zero is not one.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_L4",
            "Real_ZF_1_1_L3A",
            "real_one_cl_identity",
            "Real_ZF_1_1_L5",
            "Slopes_def",
            "Real_ZF_1_L10",
            "Real_ZF_1_1_L7",
            "id_on_int_is_slope"
        ],
        "statement": "lemma (in real1) real_zero_not_one: shows \"\\<one>\\<noteq>\\<zero>\"\n",
        "proof": "proof -\n  { assume A1: \"\\<one>=\\<zero>\"\n    have \"\\<exists>f \\<in> \\<S>. \\<zero> = [f]\"\n      using  Real_ZF_1_L4 Real_ZF_1_1_L3A by simp\n    with A1 have \n      \"\\<exists>f \\<in> \\<S>. [id(int)] = [f] \\<and> [f] = \\<zero>\"\n      using real_one_cl_identity by auto\n    then have False using Real_ZF_1_1_L5 Slopes_def \n      Real_ZF_1_L10 Real_ZF_1_1_L7 id_on_int_is_slope\n      by auto\n  } then show \"\\<one>\\<noteq>\\<zero>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1664
    },
    "1503": {
        "type": "lemma",
        "text": "text\\<open>Negative of a real number is a real number. Property of groups.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\" ",
        "using": [
            "assms",
            "Real_ZF_1_L2",
            "group0.inverse_in_group"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L8: assumes \"a\\<in>\\<real>\" shows \"(\\<rm>a) \\<in> \\<real>\"\n  ",
        "proof": "using assms Real_ZF_1_L2 group0.inverse_in_group\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1665
    },
    "1504": {
        "type": "lemma",
        "text": "text\\<open>Positive slopes are slopes and positive reals are real.\\<close>\n",
        "assumes": "",
        "using": [
            "PositiveSlopes_def",
            "EquivClass_1_L1A",
            "PositiveReals_def",
            "RealNumbers_def"
        ],
        "statement": "lemma Real_ZF_1_2_L1: shows \n  \"PositiveSlopes \\<subseteq> Slopes\"\n  \"PositiveReals \\<subseteq> RealNumbers\"\n",
        "proof": "proof -\n  have \"PositiveSlopes = \n    {s \\<in> Slopes. s``(PositiveIntegers) \\<inter> PositiveIntegers \\<notin> Fin(int)}\"\n    using PositiveSlopes_def by simp\n  then show \"PositiveSlopes \\<subseteq> Slopes\" by (rule subset_with_property)\n  then have \n    \"{SlopeEquivalenceRel``{s}. s \\<in> PositiveSlopes } \\<subseteq> \n    Slopes//SlopeEquivalenceRel\"\n    using EquivClass_1_L1A by simp\n  then show \"PositiveReals \\<subseteq> RealNumbers\"\n    using PositiveReals_def RealNumbers_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1667
    },
    "1505": {
        "type": "lemma",
        "text": "text\\<open>Positive reals are the same as classes of a positive slopes.\\<close>\n",
        "assumes": "",
        "using": [
            "PositiveReals_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L2: \n  shows \"a \\<in> PositiveReals \\<longleftrightarrow> (\\<exists>f\\<in>\\<S>\\<^sub>+. a = [f])\"\n",
        "proof": "proof\n  assume \"a \\<in> PositiveReals\"\n  then have \"a \\<in> {([s]). s \\<in> \\<S>\\<^sub>+}\" using PositiveReals_def \n    by simp \n  then show \"\\<exists>f\\<in>\\<S>\\<^sub>+. a = [f]\" by auto\nnext assume \"\\<exists>f\\<in>\\<S>\\<^sub>+. a = [f]\"\n  then have  \"a \\<in> {([s]). s \\<in> \\<S>\\<^sub>+}\" by auto\n  then show \"a \\<in> PositiveReals\" using PositiveReals_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1668
    },
    "1506": {
        "type": "lemma",
        "text": "text\\<open>Let's recall from \\<open>Int_ZF_2.thy\\<close> that the sum and composition \n  of positive slopes is a positive slope.\\<close>\n",
        "assumes": "assumes \"f\\<in>\\<S>\\<^sub>+\"  \"g\\<in>\\<S>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "Slopes_def",
            "PositiveSlopes_def",
            "PositiveIntegers_def",
            "SlopeOp1_def",
            "int1.sum_of_pos_sls_is_pos_sl",
            "SlopeOp2_def",
            "int1.comp_of_pos_sls_is_pos_sl"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L3:\n  assumes \"f\\<in>\\<S>\\<^sub>+\"  \"g\\<in>\\<S>\\<^sub>+\"\n  shows \n  \"f\\<fp>g \\<in> \\<S>\\<^sub>+\"\n  \"f\\<circ>g \\<in> \\<S>\\<^sub>+\"\n  ",
        "proof": "using assms Slopes_def PositiveSlopes_def PositiveIntegers_def\n    SlopeOp1_def int1.sum_of_pos_sls_is_pos_sl\n    SlopeOp2_def int1.comp_of_pos_sls_is_pos_sl\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1669
    },
    "1507": {
        "type": "lemma",
        "text": "text\\<open>Bounded integer maps are not positive slopes.\\<close>\n",
        "assumes": "assumes \"f \\<in> BoundedIntMaps\"\n  ",
        "using": [
            "assms",
            "BoundedIntMaps_def",
            "Slopes_def",
            "PositiveSlopes_def",
            "PositiveIntegers_def",
            "int1.Int_ZF_2_3_L1B"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L5:\n  assumes \"f \\<in> BoundedIntMaps\"\n  shows \"f \\<notin> \\<S>\\<^sub>+\"\n  ",
        "proof": "using assms BoundedIntMaps_def Slopes_def PositiveSlopes_def\n    PositiveIntegers_def int1.Int_ZF_2_3_L1B by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1670
    },
    "1508": {
        "type": "lemma",
        "text": "text\\<open>The set of positive reals is closed under addition and multiplication.\n  Zero (the neutral element of addition) is not a positive number.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_2_L2",
            "Real_ZF_1_2_L1",
            "Slopes_def",
            "Real_ZF_1_1_L4",
            "Real_ZF_1_2_L3",
            "IsOpClosed_def",
            "Real_ZF_1_L10",
            "Real_ZF_1_2_L5"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L6: shows \n  \"PositiveReals {is closed under} RealAddition\"\n  \"PositiveReals {is closed under} RealMultiplication\"\n  \"\\<zero> \\<notin> PositiveReals\"\n",
        "proof": "proof -\n  { fix a fix b\n    assume \"a \\<in> PositiveReals\" and \"b \\<in> PositiveReals\"\n    then obtain f g where\n      I: \"f \\<in> \\<S>\\<^sub>+\"  \"g \\<in> \\<S>\\<^sub>+\" and\n      II: \"a = [f]\"  \"b = [g]\"\n      using Real_ZF_1_2_L2 by auto\n    then have \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\" using Real_ZF_1_2_L1 Slopes_def \n      by auto\n    with I II have \n      \"a\\<ra>b \\<in> PositiveReals \\<and> a\\<cdot>b \\<in> PositiveReals\"\n       using Real_ZF_1_1_L4 Real_ZF_1_2_L3 Real_ZF_1_2_L2\n       by auto\n  } then show \n      \"PositiveReals {is closed under} RealAddition\"\n      \"PositiveReals {is closed under} RealMultiplication\"\n    using IsOpClosed_def\n    by auto\n  { assume \"\\<zero> \\<in> PositiveReals\"\n    then obtain f where \"f \\<in> \\<S>\\<^sub>+\" and \"\\<zero> = [f]\"\n      using Real_ZF_1_2_L2 by auto\n    then have False\n      using Real_ZF_1_2_L1 Slopes_def Real_ZF_1_L10 Real_ZF_1_2_L5\n      by auto\n  } then show \"\\<zero> \\<notin> PositiveReals\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1671
    },
    "1509": {
        "type": "lemma",
        "text": "text\\<open>If a class of a slope $f$ is not zero, then either $f$ is \n  a positive slope or $-f$ is a positive slope. The real proof is in\n  \\<open>Int_ZF_2.thy.\\<close>\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\" and A2: \"[f] \\<noteq> \\<zero>\"\n  ",
        "using": [
            "assms",
            "Slopes_def",
            "SlopeEquivalenceRel_def",
            "BoundedIntMaps_def",
            "PositiveSlopes_def",
            "PositiveIntegers_def",
            "Real_ZF_1_L10",
            "int1.Int_ZF_2_3_L8"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L7: \n  assumes A1: \"f \\<in> \\<S>\" and A2: \"[f] \\<noteq> \\<zero>\"\n  shows \"(f \\<in> \\<S>\\<^sub>+) Xor ((\\<fm>f) \\<in> \\<S>\\<^sub>+)\"\n  ",
        "proof": "using assms Slopes_def SlopeEquivalenceRel_def BoundedIntMaps_def\n    PositiveSlopes_def PositiveIntegers_def \n    Real_ZF_1_L10 int1.Int_ZF_2_3_L8 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1672
    },
    "1510": {
        "type": "lemma",
        "text": "text\\<open>The next lemma rephrases \\<open> Int_ZF_2_3_L10\\<close> in the notation\n  used in \\<open>real1\\<close> context.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  and A2: \"(f \\<in> \\<S>\\<^sub>+) Xor (g \\<in> \\<S>\\<^sub>+)\"\n  ",
        "using": [
            "assms",
            "PositiveReals_def",
            "SlopeEquivalenceRel_def",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "PositiveSlopes_def",
            "PositiveIntegers_def",
            "int1.Int_ZF_2_3_L10"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L8: \n  assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\"\n  and A2: \"(f \\<in> \\<S>\\<^sub>+) Xor (g \\<in> \\<S>\\<^sub>+)\"\n  shows \"([f] \\<in> PositiveReals) Xor ([g] \\<in> PositiveReals)\"\n  ",
        "proof": "using assms PositiveReals_def SlopeEquivalenceRel_def Slopes_def \n    SlopeOp1_def BoundedIntMaps_def PositiveSlopes_def PositiveIntegers_def\n    int1.Int_ZF_2_3_L10 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1673
    },
    "1511": {
        "type": "lemma",
        "text": "text\\<open>The trichotomy law for the (potential) order on reals: if $a\\neq 0$,\n  then either $a$ is positive or $-a$ is potitive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\" and A2: \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "Real_ZF_1_1_L3A",
            "Slopes_def",
            "BoundedIntMaps_def",
            "int1.Int_ZF_2_1_L12",
            "Real_ZF_1_2_L7",
            "Real_ZF_1_2_L8",
            "Real_ZF_1_1_L4A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L9: \n  assumes A1: \"a\\<in>\\<real>\" and A2: \"a\\<noteq>\\<zero>\"\n  shows \"(a \\<in> PositiveReals) Xor ((\\<rm>a) \\<in> PositiveReals)\"\n",
        "proof": "proof -\n  from A1 obtain f where I: \"f \\<in> \\<S>\"  \"a = [f]\"\n    using Real_ZF_1_1_L3A by auto\n  with A2 have \"([f] \\<in> PositiveReals) Xor ([\\<fm>f] \\<in> PositiveReals)\"\n    using Slopes_def BoundedIntMaps_def int1.Int_ZF_2_1_L12\n      Real_ZF_1_2_L7 Real_ZF_1_2_L8 by simp\n  with I show \"(a \\<in> PositiveReals) Xor ((\\<rm>a) \\<in> PositiveReals)\"\n    using Real_ZF_1_1_L4A by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1674
    },
    "1512": {
        "type": "theorem",
        "text": "text\\<open>Finally we are ready to prove that real numbers form an ordered ring\n with no zero divisors.\\<close>\n",
        "assumes": "",
        "using": [
            "real0.Real_ZF_1_L3",
            "real_mult_commutative",
            "Real_ZF_1_2_L1",
            "real1.Real_ZF_1_2_L6",
            "real1.Real_ZF_1_2_L9",
            "OrderOnReals_def"
        ],
        "statement": "theorem reals_are_ord_ring: shows\n  \"IsAnOrdRing(RealNumbers,RealAddition,RealMultiplication,OrderOnReals)\"\n  \"OrderOnReals {is total on} RealNumbers\"\n  \"PositiveSet(RealNumbers,RealAddition,OrderOnReals) = PositiveReals\"\n  \"HasNoZeroDivs(RealNumbers,RealAddition,RealMultiplication)\"\n",
        "proof": "proof -\n  let ?R = \"RealNumbers\"\n  let ?A = \"RealAddition\"\n  let ?M = \"RealMultiplication\"\n  let ?P = \"PositiveReals\"\n  let ?r = \"OrderOnReals\"\n  let ?z = \"TheNeutralElement(?R, ?A)\"\n  have I:\n    \"ring0(?R, ?A, ?M)\" \n    \"?M {is commutative on} ?R\"\n    \"?P \\<subseteq> ?R\"\n    \"?P {is closed under} ?A\"\n    \"TheNeutralElement(?R, ?A) \\<notin> ?P\"\n    \"\\<forall>a\\<in>?R. a \\<noteq> ?z \\<longrightarrow> (a \\<in> ?P) Xor (GroupInv(?R, ?A)`(a) \\<in> ?P)\"\n    \"?P {is closed under} ?M\" \n    \"?r = OrderFromPosSet(?R, ?A, ?P)\"\n    using real0.Real_ZF_1_L3 real_mult_commutative Real_ZF_1_2_L1\n      real1.Real_ZF_1_2_L6 real1.Real_ZF_1_2_L9 OrderOnReals_def\n    by auto\n  then show \"IsAnOrdRing(?R, ?A, ?M, ?r)\" \n    by (rule ring0.ring_ord_by_positive_set)\n  from I show \"?r {is total on} ?R\"\n    by (rule ring0.ring_ord_by_positive_set)\n  from I show \"PositiveSet(?R,?A,?r) = ?P\"\n    by (rule ring0.ring_ord_by_positive_set)\n  from I show \"HasNoZeroDivs(?R,?A,?M)\"\n    by (rule ring0.ring_ord_by_positive_set)\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1675
    },
    "1513": {
        "type": "lemma",
        "text": "text\\<open>All theorems proven in the \\<open>ring1\\<close>\n  (about ordered rings), \\<open>group3\\<close> (about ordered groups) and\n  \\<open>group1\\<close> (about groups)\n  contexts are valid as applied to ordered real numbers with addition \n  and (real) order.\\<close>\n",
        "assumes": "",
        "using": [
            "reals_are_ord_ring",
            "OrdRing_ZF_1_L2",
            "ring1.OrdRing_ZF_1_L4"
        ],
        "statement": "lemma Real_ZF_1_2_L10: shows \n  \"ring1(RealNumbers,RealAddition,RealMultiplication,OrderOnReals)\"\n  \"IsAnOrdGroup(RealNumbers,RealAddition,OrderOnReals)\"\n  \"group3(RealNumbers,RealAddition,OrderOnReals)\"\n  \"OrderOnReals {is total on} RealNumbers\"\n",
        "proof": "proof -\n  show \"ring1(RealNumbers,RealAddition,RealMultiplication,OrderOnReals)\"\n    using reals_are_ord_ring OrdRing_ZF_1_L2 by simp\n  then show \n    \"IsAnOrdGroup(RealNumbers,RealAddition,OrderOnReals)\"\n    \"group3(RealNumbers,RealAddition,OrderOnReals)\"\n    \"OrderOnReals {is total on} RealNumbers\"\n    using ring1.OrdRing_ZF_1_L4 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1676
    },
    "1514": {
        "type": "lemma",
        "text": "text\\<open>If $a=b$ or $b-a$ is positive, then $a$ is less or equal $b$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and\n  A3: \"a=b \\<or> b\\<rs>a \\<in> PositiveReals\"\n  ",
        "using": [
            "assms",
            "reals_are_ord_ring",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L30"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L11: assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and\n  A3: \"a=b \\<or> b\\<rs>a \\<in> PositiveReals\"\n  shows \"a\\<lsq>b\"\n  ",
        "proof": "using assms reals_are_ord_ring Real_ZF_1_2_L10 \n    group3.OrderedGroup_ZF_1_L30 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1677
    },
    "1515": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for two classes to be in the real order.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\" and\n  A2: \"f\\<sim>g \\<or> (g \\<fp> (\\<fm>f)) \\<in> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "Real_ZF_1_1_L5A",
            "Real_ZF_1_2_L2",
            "Real_ZF_1_1_L4B",
            "Real_ZF_1_1_L3",
            "Real_ZF_1_2_L11"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L12: assumes A1: \"f \\<in> \\<S>\"  \"g \\<in> \\<S>\" and\n  A2: \"f\\<sim>g \\<or> (g \\<fp> (\\<fm>f)) \\<in> \\<S>\\<^sub>+\"\n  shows \"[f] \\<lsq> [g]\"\n",
        "proof": "proof -\n  from A1 A2 have \"[f] = [g] \\<or> [g]\\<rs>[f] \\<in> PositiveReals\"\n    using Real_ZF_1_1_L5A Real_ZF_1_2_L2 Real_ZF_1_1_L4B\n    by auto\n  with A1 show \"[f] \\<lsq> [g]\" using  Real_ZF_1_1_L3 Real_ZF_1_2_L11\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1678
    },
    "1516": {
        "type": "lemma",
        "text": "text\\<open>Real order is antisymmetric.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>a\" ",
        "using": [
            "Real_ZF_1_2_L10"
        ],
        "statement": "lemma (in real1) real_ord_antisym: \n  assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>a\" shows \"a=b\"\n",
        "proof": "proof -\n  from A1 have\n    \"group3(RealNumbers,RealAddition,OrderOnReals)\"\n    \"\\<langle>a,b\\<rangle> \\<in> OrderOnReals\"  \"\\<langle>b,a\\<rangle> \\<in> OrderOnReals\"\n    using Real_ZF_1_2_L10 by auto\n  then show \"a=b\" by (rule group3.group_order_antisym)\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1680
    },
    "1517": {
        "type": "lemma",
        "text": "text\\<open>Real order is transitive.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>c\"\n  ",
        "using": [
            "Real_ZF_1_2_L10"
        ],
        "statement": "lemma (in real1) real_ord_transitive: assumes A1: \"a\\<lsq>b\"  \"b\\<lsq>c\"\n  shows \"a\\<lsq>c\"\n",
        "proof": "proof -\n  from A1 have\n    \"group3(RealNumbers,RealAddition,OrderOnReals)\"\n    \"\\<langle>a,b\\<rangle> \\<in> OrderOnReals\"  \"\\<langle>b,c\\<rangle> \\<in> OrderOnReals\"\n    using Real_ZF_1_2_L10 by auto\n  then have \"\\<langle>a,c\\<rangle> \\<in> OrderOnReals\" \n    by (rule group3.Group_order_transitive)\n  then show \"a\\<lsq>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1681
    },
    "1518": {
        "type": "lemma",
        "text": "text\\<open>We can multiply both sides of an inequality \n  by a nonnegative real number.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"\\<zero>\\<lsq>c\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "ring1.OrdRing_ZF_1_L9"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L14:\n  assumes \"a\\<lsq>b\" and \"\\<zero>\\<lsq>c\"\n  shows \n  \"a\\<cdot>c \\<lsq> b\\<cdot>c\"  \n  \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 ring1.OrdRing_ZF_1_L9\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1682
    },
    "1519": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>Real_ZF_1_2_L14\\<close>: we can multiply\n  an inequality by a real number.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>\\<real>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "ring1.OrdRing_ZF_1_L9A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L14A:\n  assumes A1: \"a\\<lsq>b\" and A2: \"c\\<in>\\<real>\\<^sub>+\"\n  shows \"c\\<cdot>a \\<lsq> c\\<cdot>b\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 ring1.OrdRing_ZF_1_L9A\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1683
    },
    "1520": {
        "type": "lemma",
        "text": "text\\<open>In the \\<open>real1\\<close> context notation $a\\leq b$ \n  implies that $a$ and $b$ are real numbers.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L15: assumes \"a\\<lsq>b\" shows \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1684
    },
    "1521": {
        "type": "lemma",
        "text": "text\\<open>$a\\leq b$ implies that $0 \\leq b -a$.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L12A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L16: assumes \"a\\<lsq>b\"\n  shows \"\\<zero> \\<lsq> b\\<rs>a\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L12A\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1685
    },
    "1522": {
        "type": "lemma",
        "text": "text\\<open>A sum of nonnegative elements is nonnegative.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>a\" \"\\<zero>\\<lsq>b\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L12"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L17: assumes \"\\<zero>\\<lsq>a\" \"\\<zero>\\<lsq>b\"\n  shows \"\\<zero> \\<lsq> a\\<ra>b\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L12\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1686
    },
    "1523": {
        "type": "lemma",
        "text": "text\\<open>The order on real is reflexive.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\" ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L3"
        ],
        "statement": "lemma (in real1) real_ord_refl: assumes \"a\\<in>\\<real>\" shows \"a\\<lsq>a\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1688
    },
    "1524": {
        "type": "lemma",
        "text": "text\\<open>We can add a real number to both sides of an inequality.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"c\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in real1) add_num_to_ineq: assumes \"a\\<lsq>b\" and \"c\\<in>\\<real>\"\n  shows \"a\\<ra>c \\<lsq> b\\<ra>c\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 IsAnOrdGroup_def by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1689
    },
    "1525": {
        "type": "lemma",
        "text": "text\\<open>We can put a number on the other side of an inequality,\n  changing its sign.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"c \\<lsq> a\\<ra>b\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L9C"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L19: \n  assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"c \\<lsq> a\\<ra>b\"\n  shows \"c\\<rs>b \\<lsq> a\"\n  ",
        "proof": "using assms  Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L9C\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1690
    },
    "1526": {
        "type": "lemma",
        "text": "text\\<open>What happens when one real number is not greater or equal than another?\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"\\<not>(a\\<lsq>b)\"\n  ",
        "using": [
            "Real_ZF_1_2_L10"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L20: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"\\<not>(a\\<lsq>b)\"\n  shows \"b \\<ls> a\"\n",
        "proof": "proof -\n  from assms have I:\n    \"group3(\\<real>,RealAddition,OrderOnReals)\"\n    \"OrderOnReals {is total on} \\<real>\"\n    \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"\\<not>(\\<langle>a,b\\<rangle> \\<in> OrderOnReals)\"\n    using Real_ZF_1_2_L10 by auto\n  then have \"\\<langle>b,a\\<rangle> \\<in> OrderOnReals\"\n    by (rule group3.OrderedGroup_ZF_1_L8)\n  then have \"b \\<lsq> a\" by simp\n  moreover from I have \"a\\<noteq>b\" by (rule group3.OrderedGroup_ZF_1_L8)\n  ultimately show \"b \\<ls> a\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1691
    },
    "1527": {
        "type": "lemma",
        "text": "text\\<open>We can put a number on the other side of an inequality,\n  changing its sign, version with a minus.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"c \\<lsq> a\\<rs>b\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L5J"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L21: \n  assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"c \\<lsq> a\\<rs>b\"\n  shows \"c\\<ra>b \\<lsq> a\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L5J\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1692
    },
    "1528": {
        "type": "lemma",
        "text": "text\\<open>The order on reals is a relation on reals.\\<close>\n",
        "assumes": "",
        "using": [
            "Real_ZF_1_2_L10",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L22: shows \"OrderOnReals \\<subseteq> \\<real>\\<times>\\<real>\"\n  ",
        "proof": "using Real_ZF_1_2_L10 IsAnOrdGroup_def \n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1693
    },
    "1529": {
        "type": "lemma",
        "text": "text\\<open>A set that is bounded above in the sense defined by order \n  on reals is a subset of real numbers.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(A,OrderOnReals)\"\n  ",
        "using": [
            "A1",
            "Real_ZF_1_2_L22",
            "Order_ZF_3_L1A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L23: \n  assumes A1: \"IsBoundedAbove(A,OrderOnReals)\"\n  shows \"A \\<subseteq> \\<real>\"\n  ",
        "proof": "using A1 Real_ZF_1_2_L22 Order_ZF_3_L1A\n  by blast \n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1694
    },
    "1530": {
        "type": "lemma",
        "text": "text\\<open>Properties of the maximum of three real numbers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_2_L10",
            "group3.group_ord_total_is_lin",
            "Finite_ZF_1_L2A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L24:\n  assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n  shows\n  \"Maximum(OrderOnReals,{a,b,c}) \\<in> {a,b,c}\"\n  \"Maximum(OrderOnReals,{a,b,c}) \\<in> \\<real>\"\n  \"a \\<lsq> Maximum(OrderOnReals,{a,b,c})\"\n  \"b \\<lsq> Maximum(OrderOnReals,{a,b,c})\"\n  \"c \\<lsq> Maximum(OrderOnReals,{a,b,c})\"\n",
        "proof": "proof -\n  have \"IsLinOrder(\\<real>,OrderOnReals)\"\n    using Real_ZF_1_2_L10 group3.group_ord_total_is_lin\n    by simp\n  with A1 show \n    \"Maximum(OrderOnReals,{a,b,c}) \\<in> {a,b,c}\"\n    \"Maximum(OrderOnReals,{a,b,c}) \\<in> \\<real>\"\n    \"a \\<lsq> Maximum(OrderOnReals,{a,b,c})\"\n    \"b \\<lsq> Maximum(OrderOnReals,{a,b,c})\"\n    \"c \\<lsq> Maximum(OrderOnReals,{a,b,c})\"\n    using Finite_ZF_1_L2A by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1695
    },
    "1531": {
        "type": "lemma",
        "text": "text\\<open>A form of transitivity for the order on reals.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"b\\<ls>c\"\n  ",
        "using": [
            "Real_ZF_1_2_L10"
        ],
        "statement": "lemma (in real1) real_strict_ord_transit:\n  assumes A1: \"a\\<lsq>b\" and A2: \"b\\<ls>c\"\n  shows \"a\\<ls>c\"\n",
        "proof": "proof -\n  from A1 A2 have I:\n    \"group3(\\<real>,RealAddition,OrderOnReals)\"  \n    \"\\<langle>a,b\\<rangle> \\<in> OrderOnReals\"  \"\\<langle>b,c\\<rangle> \\<in> OrderOnReals \\<and> b\\<noteq>c\"\n    using Real_ZF_1_2_L10 by auto\n  then have \"\\<langle>a,c\\<rangle> \\<in> OrderOnReals \\<and> a\\<noteq>c\" by (rule group3.group_strict_ord_transit)\n  then show \"a\\<ls>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1696
    },
    "1532": {
        "type": "lemma",
        "text": "text\\<open>We can move a real number to the other side of a strict inequality,\n  changing its sign.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and  \"a\\<rs>b \\<ls> c\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L12B"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L26:\n  assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and  \"a\\<rs>b \\<ls> c\"\n  shows \"a \\<ls> c\\<ra>b\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L12B\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1698
    },
    "1533": {
        "type": "lemma",
        "text": "text\\<open>It is convenient to have the transitivity of the order on integers\n  in the notation specific to \\<open>real1\\<close> context. This may be confusing\n  for the presentation readers: even though \\<open>\\<zlq>\\<close> and \n  \\<open>\\<lsq>\\<close> are printed in the same way, they are different symbols\n  in the source. In the \\<open>real1\\<close> context the former denotes \n  inequality between integers, and the latter denotes inequality between real\n  numbers (classes of slopes). The next lemma is about transitivity of the\n  order relation on integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<zlq>b\"  \"b\\<zlq>c\"\n  ",
        "using": [],
        "statement": "lemma (in real1) int_order_transitive: \n  assumes A1: \"a\\<zlq>b\"  \"b\\<zlq>c\"\n  shows \"a\\<zlq>c\"\n",
        "proof": "proof -\n  from A1 have \n    \"\\<langle>a,b\\<rangle> \\<in> IntegerOrder\" and \"\\<langle>b,c\\<rangle> \\<in> IntegerOrder\"\n    by auto\n  then have \"\\<langle>a,c\\<rangle> \\<in> IntegerOrder\"\n    by (rule Int_ZF_2_L5)\n  then show \"a\\<zlq>c\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1700
    },
    "1534": {
        "type": "lemma",
        "text": "text\\<open>A property of nonempty subsets of real numbers that don't\n  have a maximum: for any element we can find one that is (strictly) greater.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>\\<real>\" and \"\\<not>HasAmaximum(OrderOnReals,A)\" and \"x\\<in>A\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_2_L2B"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L27:\n  assumes \"A\\<subseteq>\\<real>\" and \"\\<not>HasAmaximum(OrderOnReals,A)\" and \"x\\<in>A\"\n  shows \"\\<exists>y\\<in>A. x\\<ls>y\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_2_L2B\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1701
    },
    "1535": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows what happens when one real number \n  is not greater or equal than another.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"\\<not>(a\\<lsq>b)\"\n  ",
        "using": [
            "Real_ZF_1_2_L10"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L28:\n  assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" and \"\\<not>(a\\<lsq>b)\"\n  shows \"b\\<ls>a\"\n",
        "proof": "proof -\n  from assms have\n    \"group3(\\<real>,RealAddition,OrderOnReals)\"\n    \"OrderOnReals {is total on} \\<real>\"\n    \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"\\<langle>a,b\\<rangle> \\<notin> OrderOnReals\"\n    using Real_ZF_1_2_L10 by auto\n  then have \"\\<langle>b,a\\<rangle> \\<in> OrderOnReals  \\<and> b\\<noteq>a\"\n    by (rule group3.OrderedGroup_ZF_1_L8)\n  then show \"b\\<ls>a\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1702
    },
    "1536": {
        "type": "lemma",
        "text": "text\\<open>We rewrite the theorem from \\<open>Int_ZF_2.thy\\<close> that shows\n  that for every positive slope we can find one that is almost equal and\n  has an inverse.\\<close>\n",
        "assumes": "assumes \"f \\<in> \\<S>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "PositiveSlopes_def",
            "Slopes_def",
            "PositiveIntegers_def",
            "int1.pos_slope_has_inv",
            "SlopeOp1_def",
            "SlopeOp2_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def"
        ],
        "statement": "lemma (in real1) pos_slopes_have_inv: assumes \"f \\<in> \\<S>\\<^sub>+\"\n  shows \"\\<exists>g\\<in>\\<S>. f\\<sim>g \\<and> (\\<exists>h\\<in>\\<S>. g\\<circ>h \\<sim> id(int))\"\n  ",
        "proof": "using assms PositiveSlopes_def Slopes_def PositiveIntegers_def\n    int1.pos_slope_has_inv SlopeOp1_def SlopeOp2_def \n    BoundedIntMaps_def SlopeEquivalenceRel_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1704
    },
    "1537": {
        "type": "theorem",
        "text": "text\\<open>The set of real numbers we are constructing is an ordered field.\\<close>\n",
        "assumes": "",
        "using": [
            "reals_are_ord_ring",
            "OrdRing_ZF_1_L2",
            "real_zero_not_one",
            "real_mult_commutative",
            "Real_ZF_1_2_L2",
            "pos_slopes_have_inv",
            "Real_ZF_1_2_L1",
            "Slopes_def",
            "Real_ZF_1_1_L5",
            "Real_ZF_1_1_L4",
            "Real_ZF_1_1_L5A",
            "real_one_cl_identity",
            "Real_ZF_1_1_L3",
            "ring1.OrdField_ZF_1_L4"
        ],
        "statement": "theorem (in real1) reals_are_ord_field: shows \n  \"IsAnOrdField(RealNumbers,RealAddition,RealMultiplication,OrderOnReals)\"\n",
        "proof": "proof -\n  let ?R = \"RealNumbers\"\n  let ?A = \"RealAddition\"\n  let ?M = \"RealMultiplication\"\n  let ?r = \"OrderOnReals\"\n  have \"ring1(?R,?A,?M,?r)\" and \"\\<zero> \\<noteq> \\<one>\"\n    using reals_are_ord_ring OrdRing_ZF_1_L2 real_zero_not_one\n    by auto\n  moreover have \"?M {is commutative on} ?R\"\n    using real_mult_commutative by simp\n  moreover have\n    \"\\<forall>a\\<in>PositiveSet(?R,?A,?r). \\<exists>b\\<in>?R. a\\<cdot>b = \\<one>\"\n  proof\n    fix a assume \"a \\<in> PositiveSet(?R,?A,?r)\"\n    then obtain f where I: \"f\\<in>\\<S>\\<^sub>+\" and II: \"a = [f]\"\n      using reals_are_ord_ring Real_ZF_1_2_L2 \n      by auto\n    then have \"\\<exists>g\\<in>\\<S>. f\\<sim>g \\<and> (\\<exists>h\\<in>\\<S>. g\\<circ>h \\<sim> id(int))\"\n      using pos_slopes_have_inv by simp\n    then obtain g where \n      III: \"g\\<in>\\<S>\" and IV: \"f\\<sim>g\" and V: \"\\<exists>h\\<in>\\<S>. g\\<circ>h \\<sim> id(int)\"\n      by auto\n    from V obtain h where VII: \"h\\<in>\\<S>\" and VIII: \"g\\<circ>h \\<sim> id(int)\"\n      by auto\n    from I III IV have \"[f] = [g]\"\n      using Real_ZF_1_2_L1 Slopes_def Real_ZF_1_1_L5\n      by auto\n    with II III VII VIII have \"a\\<cdot>[h] = \\<one>\"\n      using Real_ZF_1_1_L4  Real_ZF_1_1_L5A real_one_cl_identity\n      by simp\n    with VII show \"\\<exists>b\\<in>?R. a\\<cdot>b = \\<one>\" using Real_ZF_1_1_L3\n      by auto\n  qed\n  ultimately show ?thesis using ring1.OrdField_ZF_1_L4\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1705
    },
    "1538": {
        "type": "lemma",
        "text": "text\\<open>Theorem proven in \\<open>field0\\<close> and \\<open>field1\\<close> contexts \n  are valid as applied to real numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "reals_are_field",
            "real1.reals_are_ord_field",
            "field_field0",
            "OrdField_ZF_1_L2"
        ],
        "statement": "lemma field_cntxts_ok: shows \n  \"field0(RealNumbers,RealAddition,RealMultiplication)\"\n  \"field1(RealNumbers,RealAddition,RealMultiplication,OrderOnReals)\"\n  ",
        "proof": "using reals_are_field real1.reals_are_ord_field\n     field_field0 OrdField_ZF_1_L2 by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1707
    },
    "1539": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is positive, then $a^{-1}$ is also positive.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<real>\\<^sub>+\" \n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_1_L8",
            "PositiveSet_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L1: assumes \"a \\<in> \\<real>\\<^sub>+\" \n  shows \"a\\<inverse> \\<in> \\<real>\\<^sub>+\"   \"a\\<inverse> \\<in> \\<real>\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_1_L8 PositiveSet_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1708
    },
    "1540": {
        "type": "lemma",
        "text": "text\\<open>A technical fact about multiplying strict inequality by the inverse\n  of one of the sides.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<real>\\<^sub>+\" and \"a\\<inverse> \\<ls> b\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L2"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L2: \n  assumes \"a \\<in> \\<real>\\<^sub>+\" and \"a\\<inverse> \\<ls> b\"\n  shows \"\\<one> \\<ls> b\\<cdot>a\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L2\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1709
    },
    "1541": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is smaller than $b$, then $(b-a)^{-1}$ is positive.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_1_L9"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L3: assumes \"a\\<ls>b\"\n  shows \"(b\\<rs>a)\\<inverse> \\<in> \\<real>\\<^sub>+\" \n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_1_L9\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1710
    },
    "1542": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of a strict\n  inequality, changing it to its inverse.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\\<^sub>+\" and A2: \"a\\<cdot>b \\<ls> c\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L6"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L4:\n  assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\\<^sub>+\" and A2: \"a\\<cdot>b \\<ls> c\"\n  shows \"a \\<ls> c\\<cdot>b\\<inverse>\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L6\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1711
    },
    "1543": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of a strict\n  inequality, changing it to its inverse, version with the product\n  initially on the right hand side.\\<close>\n",
        "assumes": "assumes A1: \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\\<^sub>+\" and A2: \"a \\<ls> b\\<cdot>c\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L6A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L4A:\n  assumes A1: \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\\<^sub>+\" and A2: \"a \\<ls> b\\<cdot>c\"\n  shows \"a\\<cdot>c\\<inverse> \\<ls> b\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L6A\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1712
    },
    "1544": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of an inequality, \n  changing it to its inverse, version with the product\n  initially on the left hand side.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\\<^sub>+\" and A2: \"a\\<cdot>b \\<lsq> c\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L5"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L4C: \n  assumes A1: \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\\<^sub>+\" and A2: \"a\\<cdot>b \\<lsq> c\"\n  shows \"a \\<lsq> c\\<cdot>b\\<inverse>\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L5\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1714
    },
    "1545": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about solving a strict inequality with three\n  real numbers and inverse of a difference.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" and \"(b\\<rs>a)\\<inverse> \\<ls> c\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L9"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L5:\n  assumes \"a\\<ls>b\" and \"(b\\<rs>a)\\<inverse> \\<ls> c\"\n  shows \"\\<one> \\<ra> a\\<cdot>c \\<ls> b\\<cdot>c\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L9\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1715
    },
    "1546": {
        "type": "lemma",
        "text": "text\\<open>We can multiply an inequality by the inverse of a positive number.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"  and \"c\\<in>\\<real>\\<^sub>+\" ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L3"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L6:\n  assumes \"a\\<lsq>b\"  and \"c\\<in>\\<real>\\<^sub>+\" shows \"a\\<cdot>c\\<inverse> \\<lsq> b\\<cdot>c\\<inverse>\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L3\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1716
    },
    "1547": {
        "type": "lemma",
        "text": "text\\<open>An identity with three real numbers, inverse and cancelling.\\<close>\n",
        "assumes": "assumes\"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" \"b\\<noteq>\\<zero>\"  \"c\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field0.Field_ZF_2_L6"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L8: assumes\"a\\<in>\\<real>\"  \"b\\<in>\\<real>\" \"b\\<noteq>\\<zero>\"  \"c\\<in>\\<real>\"\n  shows \"a\\<cdot>b\\<cdot>(c\\<cdot>b\\<inverse>) = a\\<cdot>c\"\n  ",
        "proof": "using assms field_cntxts_ok field0.Field_ZF_2_L6\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1718
    },
    "1548": {
        "type": "lemma",
        "text": "text\\<open>If $m$ is an integer, then \\<open>m\\<^sup>R\\<close> is a real number.\n  Recall that in \\<open>real1\\<close> context \\<open>m\\<^sup>R\\<close> denotes the class\n  of the slope $n\\mapsto m\\cdot n$.\\<close>\n",
        "assumes": "assumes \"m \\<in> int\"\n  ",
        "using": [
            "assms",
            "int1.Int_ZF_2_5_L1",
            "Real_ZF_1_1_L3"
        ],
        "statement": "lemma (in real1) real_int_is_real: assumes \"m \\<in> int\"\n  shows \"m\\<^sup>R \\<in> \\<real>\"\n  ",
        "proof": "using assms int1.Int_ZF_2_5_L1 Real_ZF_1_1_L3 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1719
    },
    "1549": {
        "type": "lemma",
        "text": "text\\<open>The negative of the real embedding of an integer is the embedding\n  of the negative of the integer.\\<close>\n",
        "assumes": "assumes \"m \\<in> int\"\n  ",
        "using": [
            "assms",
            "int1.Int_ZF_2_5_L3",
            "int1.Int_ZF_2_5_L1",
            "Real_ZF_1_1_L4A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L1: assumes \"m \\<in> int\"\n  shows \"(\\<zm>m)\\<^sup>R = \\<rm>(m\\<^sup>R)\"\n  ",
        "proof": "using assms int1.Int_ZF_2_5_L3 int1.Int_ZF_2_5_L1 Real_ZF_1_1_L4A\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1720
    },
    "1550": {
        "type": "lemma",
        "text": "text\\<open>The embedding of sum of integers is the sum of embeddings.\\<close>\n",
        "assumes": "assumes \"m \\<in> int\"  \"k \\<in> int\"\n  ",
        "using": [
            "assms",
            "int1.Int_ZF_2_5_L1",
            "SlopeOp1_def",
            "int1.Int_ZF_2_5_L3A",
            "Real_ZF_1_1_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L1A: assumes \"m \\<in> int\"  \"k \\<in> int\"\n  shows \"m\\<^sup>R \\<ra> k\\<^sup>R = ((m\\<za>k)\\<^sup>R)\"\n  ",
        "proof": "using assms int1.Int_ZF_2_5_L1 SlopeOp1_def int1.Int_ZF_2_5_L3A \n    Real_ZF_1_1_L4 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1721
    },
    "1551": {
        "type": "lemma",
        "text": "text\\<open>The embedding of a difference of integers is the difference\n  of embeddings.\\<close>\n",
        "assumes": "assumes A1: \"m \\<in> int\"  \"k \\<in> int\"\n  ",
        "using": [
            "int0.Int_ZF_1_1_L4",
            "Real_ZF_1_4_L1A",
            "Real_ZF_1_4_L1"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L1B: assumes A1: \"m \\<in> int\"  \"k \\<in> int\"\n  shows \"m\\<^sup>R \\<rs> k\\<^sup>R = (m\\<zs>k)\\<^sup>R\"\n",
        "proof": "proof -\n  from A1 have \"(\\<zm>k) \\<in> int\" using int0.Int_ZF_1_1_L4\n    by simp\n  with A1 have \"(m\\<zs>k)\\<^sup>R = m\\<^sup>R \\<ra> (\\<zm>k)\\<^sup>R\"\n    using Real_ZF_1_4_L1A by simp\n  with A1 show \"m\\<^sup>R \\<rs> k\\<^sup>R = (m\\<zs>k)\\<^sup>R\"\n    using Real_ZF_1_4_L1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1722
    },
    "1552": {
        "type": "lemma",
        "text": "text\\<open>The embedding of the product of integers is the product of embeddings.\\<close>\n",
        "assumes": "assumes \"m \\<in> int\"  \"k \\<in> int\"\n  ",
        "using": [
            "assms",
            "int1.Int_ZF_2_5_L1",
            "SlopeOp2_def",
            "int1.Int_ZF_2_5_L3B",
            "Real_ZF_1_1_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L1C: assumes \"m \\<in> int\"  \"k \\<in> int\"\n  shows \"m\\<^sup>R \\<cdot> k\\<^sup>R = (m\\<zmu>k)\\<^sup>R\"\n  ",
        "proof": "using assms int1.Int_ZF_2_5_L1 SlopeOp2_def int1.Int_ZF_2_5_L3B\n    Real_ZF_1_1_L4 by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1723
    },
    "1553": {
        "type": "lemma",
        "text": "text\\<open>For any real numbers there is an integer whose real version (embedding) \n  is less or equal.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_1_L8",
            "Real_ZF_1_4_L2",
            "Real_ZF_1_2_L13",
            "Real_ZF_1_4_L1",
            "int0.Int_ZF_1_1_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L3: assumes A1: \"a\\<in>\\<real>\"\n  shows \"{m \\<in> int. m\\<^sup>R \\<lsq> a} \\<noteq> 0\"\n",
        "proof": "proof -\n  from A1 have \"(\\<rm>a) \\<in> \\<real>\" using Real_ZF_1_1_L8\n    by simp\n  then obtain m where I: \"m\\<in>int\" and II: \"(\\<rm>a) \\<lsq> m\\<^sup>R\"\n    using Real_ZF_1_4_L2 by auto\n  let ?k = \"GroupInv(int,IntegerAddition)`(m)\"\n  from A1 I II have \"?k \\<in> int\" and \"?k\\<^sup>R \\<lsq> a\"\n    using Real_ZF_1_2_L13 Real_ZF_1_4_L1 int0.Int_ZF_1_1_L4\n    by auto\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1725
    },
    "1554": {
        "type": "lemma",
        "text": "text\\<open>Embeddings of two integers are equal only if the integers are equal.\\<close>\n",
        "assumes": "assumes A1: \"m \\<in> int\"  \"k \\<in> int\" and A2: \"m\\<^sup>R = k\\<^sup>R\"\n  ",
        "using": [
            "int1.Int_ZF_2_5_L1",
            "AlmostHoms_def",
            "Real_ZF_1_1_L5",
            "SlopeEquivalenceRel_def",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L4: \n  assumes A1: \"m \\<in> int\"  \"k \\<in> int\" and A2: \"m\\<^sup>R = k\\<^sup>R\"\n  shows \"m=k\"\n",
        "proof": "proof -\n  let ?r = \"{\\<langle>n, IntegerMultiplication ` \\<langle>m, n\\<rangle>\\<rangle> . n \\<in> int}\"\n  let ?s = \"{\\<langle>n, IntegerMultiplication ` \\<langle>k, n\\<rangle>\\<rangle> . n \\<in> int}\"\n  from A1 A2 have \"?r \\<sim> ?s\"\n    using int1.Int_ZF_2_5_L1 AlmostHoms_def Real_ZF_1_1_L5\n    by simp\n  with A1 have \n    \"m \\<in> int\"  \"k \\<in> int\"\n    \"\\<langle>?r,?s\\<rangle> \\<in> QuotientGroupRel(AlmostHoms(int, IntegerAddition),\n    AlHomOp1(int, IntegerAddition),FinRangeFunctions(int, int))\"\n    using SlopeEquivalenceRel_def Slopes_def SlopeOp1_def \n      BoundedIntMaps_def by auto\n  then show \"m=k\" by (rule int1.Int_ZF_2_5_L6)\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1726
    },
    "1555": {
        "type": "lemma",
        "text": "text\\<open>The embedding of integers preserves the order.\\<close>\n",
        "assumes": "assumes A1: \"m\\<zlq>k\"\n  ",
        "using": [
            "int0.Int_ZF_2_L1A",
            "int1.Int_ZF_2_5_L1",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "PositiveIntegers_def",
            "PositiveSlopes_def",
            "int1.Int_ZF_2_5_L4",
            "Real_ZF_1_2_L12"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L5: assumes A1: \"m\\<zlq>k\"\n  shows \"m\\<^sup>R \\<lsq> k\\<^sup>R\"\n",
        "proof": "proof -\n  let ?r = \"{\\<langle>n, m\\<zmu>n\\<rangle> . n \\<in> int}\"\n  let ?s = \"{\\<langle>n, k\\<zmu>n\\<rangle> . n \\<in> int}\"\n  from A1 have \"?r \\<in> \\<S>\"  \"?s \\<in> \\<S>\"\n    using int0.Int_ZF_2_L1A int1.Int_ZF_2_5_L1 by auto\n  moreover from A1 have \"?r \\<sim> ?s \\<or> ?s \\<fp> (\\<fm>?r)  \\<in> \\<S>\\<^sub>+\"\n    using Slopes_def SlopeOp1_def BoundedIntMaps_def SlopeEquivalenceRel_def\n      PositiveIntegers_def PositiveSlopes_def\n      int1.Int_ZF_2_5_L4 by simp\n  ultimately show \"m\\<^sup>R \\<lsq> k\\<^sup>R\" using Real_ZF_1_2_L12\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1727
    },
    "1556": {
        "type": "lemma",
        "text": "text\\<open>The embedding of integers preserves the strict order.\\<close>\n",
        "assumes": "assumes A1: \"m\\<zlq>k\"  \"m\\<noteq>k\"\n  ",
        "using": [
            "Real_ZF_1_4_L5",
            "int0.Int_ZF_2_L1A",
            "Real_ZF_1_4_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L5A: assumes A1: \"m\\<zlq>k\"  \"m\\<noteq>k\"\n  shows \"m\\<^sup>R \\<ls> k\\<^sup>R\"\n",
        "proof": "proof -\n  from A1 have \"m\\<^sup>R \\<lsq> k\\<^sup>R\" using Real_ZF_1_4_L5\n    by simp\n  moreover\n  from A1 have T: \"m \\<in> int\"  \"k \\<in> int\"\n    using int0.Int_ZF_2_L1A by auto\n  with A1 have \"m\\<^sup>R \\<noteq> k\\<^sup>R\" using Real_ZF_1_4_L4\n    by auto\n  ultimately show \"m\\<^sup>R \\<ls> k\\<^sup>R\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1728
    },
    "1557": {
        "type": "lemma",
        "text": "text\\<open>For any real number there is a positive integer\n  whose real version is (strictly) greater. \n  This is Lemma 14 i) in  \\cite{Arthan2004}.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_4_L2",
            "int0.Int_ZF_1_5_L7B",
            "Real_ZF_1_4_L5A"
        ],
        "statement": "lemma (in real1) Arthan_Lemma14i: assumes A1: \"a\\<in>\\<real>\"\n  shows \"\\<exists>n\\<in>\\<int>\\<^sub>+. a \\<ls> n\\<^sup>R\"\n",
        "proof": "proof -\n  from A1 obtain m where I: \"m\\<in>int\" and II: \"a \\<lsq> m\\<^sup>R\"\n    using Real_ZF_1_4_L2 by auto\n  let ?n = \"GreaterOf(IntegerOrder,\\<one>\\<^sub>Z,m) \\<za> \\<one>\\<^sub>Z\"\n  from I have T: \"?n \\<in>\\<int>\\<^sub>+\" and \"m \\<zlq> ?n\"  \"m\\<noteq>?n\"\n    using int0.Int_ZF_1_5_L7B by auto\n  then have III: \"m\\<^sup>R \\<ls> ?n\\<^sup>R\"\n    using Real_ZF_1_4_L5A by simp\n  with II have \"a \\<ls> ?n\\<^sup>R\" by (rule real_strict_ord_transit)\n  with T show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1729
    },
    "1558": {
        "type": "lemma",
        "text": "text\\<open>If one embedding is less or equal than another, then the integers\n  are also less or equal.\\<close>\n",
        "assumes": "assumes A1: \"k \\<in> int\"  \"m \\<in> int\" and A2: \"m\\<^sup>R \\<lsq> k\\<^sup>R\"\n  ",
        "using": [
            "Real_ZF_1_4_L5",
            "Real_ZF_1_4_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L6: \n  assumes A1: \"k \\<in> int\"  \"m \\<in> int\" and A2: \"m\\<^sup>R \\<lsq> k\\<^sup>R\"\n  shows \"m\\<zlq>k\"\n",
        "proof": "proof -\n  { assume A3: \"\\<langle>m,k\\<rangle> \\<notin> IntegerOrder\"\n    with A1 have \"\\<langle>k,m\\<rangle> \\<in> IntegerOrder\"\n      by (rule int0.Int_ZF_2_L19)\n    then have \"k\\<^sup>R \\<lsq> m\\<^sup>R\" using Real_ZF_1_4_L5\n      by simp\n    with A2 have \"m\\<^sup>R = k\\<^sup>R\" by (rule real_ord_antisym)\n    with A1 have \"k = m\" using Real_ZF_1_4_L4\n      by auto\n    moreover from A1 A3 have \"k\\<noteq>m\" by (rule int0.Int_ZF_2_L19)\n    ultimately have False by simp\n  } then show \"m\\<zlq>k\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1730
    },
    "1559": {
        "type": "lemma",
        "text": "text\\<open>The floor function is well defined and has expected properties.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_4_L2",
            "Real_ZF_1_4_L6",
            "Real_ZF_1_4_L3"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L7: assumes A1: \"a\\<in>\\<real>\"\n  shows \n  \"IsBoundedAbove({m \\<in> int. m\\<^sup>R \\<lsq> a},IntegerOrder)\"\n  \"{m \\<in> int. m\\<^sup>R \\<lsq> a} \\<noteq> 0\"\n  \"\\<lfloor>a\\<rfloor> \\<in> int\"\n  \"\\<lfloor>a\\<rfloor>\\<^sup>R \\<lsq> a\"  \n",
        "proof": "proof -\n  let ?A = \"{m \\<in> int. m\\<^sup>R \\<lsq> a}\"\n  from A1 obtain K where I: \"K\\<in>int\" and II: \"a \\<lsq> (K\\<^sup>R)\"\n    using Real_ZF_1_4_L2 by auto\n  { fix n assume \"n \\<in> ?A\"\n    then have III: \"n \\<in> int\" and IV: \"n\\<^sup>R \\<lsq> a\"\n      by auto\n    from IV II have \"(n\\<^sup>R) \\<lsq> (K\\<^sup>R)\"\n      by (rule real_ord_transitive)\n    with I III have \"n\\<zlq>K\" using Real_ZF_1_4_L6\n      by simp\n  } then have \"\\<forall>n\\<in>?A. \\<langle>n,K\\<rangle> \\<in> IntegerOrder\"\n    by simp\n  then show \"IsBoundedAbove(?A,IntegerOrder)\"\n    by (rule Order_ZF_3_L10)\n  moreover from A1 show \"?A \\<noteq> 0\" using Real_ZF_1_4_L3\n    by simp\n  ultimately have \"Maximum(IntegerOrder,?A) \\<in> ?A\"\n    by (rule int0.int_bounded_above_has_max)\n  then show \"\\<lfloor>a\\<rfloor> \\<in> int\"   \"\\<lfloor>a\\<rfloor>\\<^sup>R \\<lsq> a\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1731
    },
    "1560": {
        "type": "lemma",
        "text": "text\\<open>Every integer whose embedding is less or equal a real number $a$\n  is less or equal than the floor of $a$.\\<close>\n",
        "assumes": "assumes A1: \"m \\<in> int\" and A2: \"m\\<^sup>R \\<lsq> a\"\n  ",
        "using": [
            "Real_ZF_1_2_L15",
            "Real_ZF_1_4_L7"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L8: \n  assumes A1: \"m \\<in> int\" and A2: \"m\\<^sup>R \\<lsq> a\"\n  shows \"m \\<zlq> \\<lfloor>a\\<rfloor>\"\n",
        "proof": "proof -\n  let ?A = \"{m \\<in> int. m\\<^sup>R \\<lsq> a}\"\n  from A2 have \"IsBoundedAbove(?A,IntegerOrder)\" and \"?A\\<noteq>0\"\n    using Real_ZF_1_2_L15 Real_ZF_1_4_L7 by auto\n  then have \"\\<forall>x\\<in>?A. \\<langle>x,Maximum(IntegerOrder,?A)\\<rangle> \\<in> IntegerOrder\"\n    by (rule int0.int_bounded_above_has_max)\n  with A1 A2 show \"m \\<zlq> \\<lfloor>a\\<rfloor>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1732
    },
    "1561": {
        "type": "lemma",
        "text": "text\\<open>Integer zero and one embed as real zero and one.\\<close>\n",
        "assumes": "",
        "using": [
            "int1.Int_ZF_2_5_L7",
            "BoundedIntMaps_def",
            "real_one_cl_identity",
            "real_zero_cl_bounded_map"
        ],
        "statement": "lemma (in real1) int_0_1_are_real_zero_one: \n  shows \"\\<zero>\\<^sub>Z\\<^sup>R = \\<zero>\"  \"\\<one>\\<^sub>Z\\<^sup>R = \\<one>\"\n  ",
        "proof": "using int1.Int_ZF_2_5_L7 BoundedIntMaps_def \n    real_one_cl_identity real_zero_cl_bounded_map\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1733
    },
    "1562": {
        "type": "lemma",
        "text": "text\\<open>Integer two embeds as the real two.\\<close>\n",
        "assumes": "",
        "using": [
            "int0.int_zero_one_are_int",
            "Real_ZF_1_4_L1A",
            "int_0_1_are_real_zero_one"
        ],
        "statement": "lemma (in real1) int_two_is_real_two: shows \"\\<two>\\<^sub>Z\\<^sup>R = \\<two>\"\n",
        "proof": "proof -\n  have \"\\<two>\\<^sub>Z\\<^sup>R = \\<one>\\<^sub>Z\\<^sup>R \\<ra> \\<one>\\<^sub>Z\\<^sup>R\"\n    using int0.int_zero_one_are_int Real_ZF_1_4_L1A\n    by simp\n  also have \"\\<dots> = \\<two>\" using int_0_1_are_real_zero_one\n    by simp\n  finally show \"\\<two>\\<^sub>Z\\<^sup>R = \\<two>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1734
    },
    "1563": {
        "type": "lemma",
        "text": "text\\<open>A positive integer embeds as a positive (hence nonnegative) real.\\<close>\n",
        "assumes": "assumes A1: \"p\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "PositiveSet_def",
            "real_int_is_real",
            "Real_ZF_1_4_L5",
            "int_0_1_are_real_zero_one",
            "int0.int_zero_one_are_int",
            "Real_ZF_1_4_L4"
        ],
        "statement": "lemma (in real1) int_pos_is_real_pos: assumes A1: \"p\\<in>\\<int>\\<^sub>+\"\n  shows \n  \"p\\<^sup>R \\<in> \\<real>\"\n  \"\\<zero> \\<lsq> p\\<^sup>R\"\n  \"p\\<^sup>R \\<in> \\<real>\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 have I: \"p \\<in> int\"  \"\\<zero>\\<^sub>Z \\<zlq> p\"  \"\\<zero>\\<^sub>Z \\<noteq> p\"\n    using PositiveSet_def by auto\n  then have \"p\\<^sup>R \\<in> \\<real>\"  \"\\<zero>\\<^sub>Z\\<^sup>R \\<lsq> p\\<^sup>R\"\n    using real_int_is_real Real_ZF_1_4_L5 by auto\n  then show \"p\\<^sup>R \\<in> \\<real>\"  \"\\<zero> \\<lsq> p\\<^sup>R\"\n    using int_0_1_are_real_zero_one by auto\n  moreover have \"\\<zero> \\<noteq> p\\<^sup>R\"\n  proof -\n    { assume \"\\<zero> = p\\<^sup>R\"\n      with I have False using int_0_1_are_real_zero_one \t\n\tint0.int_zero_one_are_int Real_ZF_1_4_L4 by auto\n    } then show \"\\<zero> \\<noteq> p\\<^sup>R\" by auto\n  qed\n  ultimately show \"p\\<^sup>R \\<in> \\<real>\\<^sub>+\" using PositiveSet_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1735
    },
    "1564": {
        "type": "lemma",
        "text": "text\\<open>The ordered field of reals we are constructing is archimedean, i.e., \n  if $x,y$ are its elements with $y$ positive, then there is a positive\n  integer $M$ such that $x$ is smaller than $M^R y$. This is Lemma 14 ii) in \\cite{Arthan2004}.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>\\<real>\"  \"y \\<in> \\<real>\\<^sub>+\"\n  ",
        "using": [
            "Real_ZF_1_3_L1",
            "Arthan_Lemma14i",
            "int0.pos_int_closed_mul_unfold",
            "PositiveSet_def",
            "real_int_is_real",
            "Real_ZF_1_L6A",
            "Real_ZF_1_4_L1C",
            "int_pos_is_real_pos",
            "Real_ZF_1_3_L2",
            "Real_ZF_1_2_L25"
        ],
        "statement": "lemma (in real1) Arthan_Lemma14ii: assumes A1: \"x\\<in>\\<real>\"  \"y \\<in> \\<real>\\<^sub>+\"\n  shows \"\\<exists>M\\<in>\\<int>\\<^sub>+. x \\<ls> M\\<^sup>R\\<cdot>y\"\n",
        "proof": "proof -\n  from A1 have \n    \"\\<exists>C\\<in>\\<int>\\<^sub>+. x \\<ls> C\\<^sup>R\" and \"\\<exists>D\\<in>\\<int>\\<^sub>+. y\\<inverse> \\<ls> D\\<^sup>R\"\n    using Real_ZF_1_3_L1 Arthan_Lemma14i by auto\n  then obtain C D where \n    I: \"C\\<in>\\<int>\\<^sub>+\" and II: \"x \\<ls> C\\<^sup>R\" and\n    III: \"D\\<in>\\<int>\\<^sub>+\" and IV: \"y\\<inverse> \\<ls> D\\<^sup>R\"\n    by auto\n  let ?M = \"C\\<zmu>D\"\n  from I III have \n    T: \"?M \\<in> \\<int>\\<^sub>+\"  \"C\\<^sup>R \\<in> \\<real>\"  \"D\\<^sup>R \\<in> \\<real>\"\n    using int0.pos_int_closed_mul_unfold PositiveSet_def real_int_is_real\n    by auto\n  with A1 I III have \"C\\<^sup>R\\<cdot>(D\\<^sup>R\\<cdot>y) = ?M\\<^sup>R\\<cdot>y\"\n    using PositiveSet_def Real_ZF_1_L6A Real_ZF_1_4_L1C\n    by simp\n  moreover from A1 I II IV have \n    \"x \\<ls> C\\<^sup>R\\<cdot>(D\\<^sup>R\\<cdot>y)\"\n    using int_pos_is_real_pos Real_ZF_1_3_L2 Real_ZF_1_2_L25\n    by auto\n  ultimately have \"x \\<ls> ?M\\<^sup>R\\<cdot>y\"\n    by auto\n  with T show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1736
    },
    "1565": {
        "type": "lemma",
        "text": "text\\<open>Taking the floor function preserves the order.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\"\n  ",
        "using": [
            "Real_ZF_1_2_L15",
            "Real_ZF_1_4_L7",
            "Real_ZF_1_4_L8"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L9: assumes A1: \"a\\<lsq>b\"\n  shows \"\\<lfloor>a\\<rfloor> \\<zlq> \\<lfloor>b\\<rfloor>\"\n",
        "proof": "proof -\n  from A1 have T: \"a\\<in>\\<real>\" using Real_ZF_1_2_L15\n    by simp\n  with A1 have \"\\<lfloor>a\\<rfloor>\\<^sup>R \\<lsq> a\" and \"a\\<lsq>b\"\n    using Real_ZF_1_4_L7 by auto\n  then have \"\\<lfloor>a\\<rfloor>\\<^sup>R \\<lsq> b\" by (rule real_ord_transitive)\n  moreover from T have \"\\<lfloor>a\\<rfloor> \\<in> int\" using Real_ZF_1_4_L7\n    by simp\n ultimately show \"\\<lfloor>a\\<rfloor> \\<zlq> \\<lfloor>b\\<rfloor>\" using Real_ZF_1_4_L8\n   by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1737
    },
    "1566": {
        "type": "lemma",
        "text": "text\\<open>If $S$ is bounded above and $p$ is a positive intereger, then\n  $\\Gamma(S,p)$ is well defined.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and A2: \"p\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "IsBoundedAbove_def",
            "int_pos_is_real_pos",
            "Real_ZF_1_2_L14",
            "Real_ZF_1_4_L9"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L10: \n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and A2: \"p\\<in>\\<int>\\<^sub>+\"\n  shows \n  \"IsBoundedAbove({\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S},IntegerOrder)\"\n  \"\\<Gamma>(S,p) \\<in> {\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\"\n  \"\\<Gamma>(S,p) \\<in> int\"\n",
        "proof": "proof -\n  let ?A = \"{\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\"\n  from A1 obtain X where I: \"\\<forall>x\\<in>S. x\\<lsq>X\" \n    using IsBoundedAbove_def by auto\n  { fix m assume \"m \\<in> ?A\"\n    then obtain x where \"x\\<in>S\" and II: \"m = \\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>\"\n      by auto\n    with I have \"x\\<lsq>X\" by simp\n    moreover from A2 have \"\\<zero> \\<lsq> p\\<^sup>R\" using int_pos_is_real_pos\n      by simp\n    ultimately have \"p\\<^sup>R\\<cdot>x \\<lsq> p\\<^sup>R\\<cdot>X\" using Real_ZF_1_2_L14\n      by simp\n    with II have \"m \\<zlq> \\<lfloor>p\\<^sup>R\\<cdot>X\\<rfloor>\" using Real_ZF_1_4_L9\n      by simp\n  } then have \"\\<forall>m\\<in>?A. \\<langle>m,\\<lfloor>p\\<^sup>R\\<cdot>X\\<rfloor>\\<rangle> \\<in> IntegerOrder\"\n    by auto\n  then show II: \"IsBoundedAbove(?A,IntegerOrder)\" \n    by (rule Order_ZF_3_L10)\n  moreover from A1 have III: \"?A \\<noteq> 0\" by simp\n  ultimately have \"Maximum(IntegerOrder,?A) \\<in> ?A\"\n    by (rule int0.int_bounded_above_has_max)\n  moreover from II III have \"Maximum(IntegerOrder,?A) \\<in> int\"\n    by (rule int0.int_bounded_above_has_max)\n  ultimately show \"\\<Gamma>(S,p) \\<in> {\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\" and \"\\<Gamma>(S,p) \\<in> int\" \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1738
    },
    "1567": {
        "type": "lemma",
        "text": "text\\<open>If $p$ is a positive integer, then\n  for all $s\\in S$ the floor of $p\\cdot x$ is not greater that $\\Gamma(S,p)$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and A2: \"x\\<in>S\" and A3: \"p\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "Real_ZF_1_4_L10"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L11:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and A2: \"x\\<in>S\" and A3: \"p\\<in>\\<int>\\<^sub>+\"\n  shows \"\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor> \\<zlq> \\<Gamma>(S,p)\"\n",
        "proof": "proof -\n  let ?A = \"{\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\"\n  from A2 have \"S\\<noteq>0\" by auto\n  with A1 A3 have \"IsBoundedAbove(?A,IntegerOrder)\"  \"?A \\<noteq> 0\"\n    using  Real_ZF_1_4_L10 by auto\n  then have \"\\<forall>x\\<in>?A. \\<langle>x,Maximum(IntegerOrder,?A)\\<rangle> \\<in> IntegerOrder\"\n    by (rule int0.int_bounded_above_has_max)\n  with A2 show \"\\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor> \\<zlq> \\<Gamma>(S,p)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1739
    },
    "1568": {
        "type": "lemma",
        "text": "text\\<open>The candidate for supremum is an integer mapping with values \n  given by $\\Gamma$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and \n  A2: \"g = {\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  ",
        "using": [
            "Real_ZF_1_4_L10",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L12: \n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and \n  A2: \"g = {\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  shows \n  \"g : \\<int>\\<^sub>+\\<rightarrow>int\"\n  \"\\<forall>n\\<in>\\<int>\\<^sub>+. g`(n) = \\<Gamma>(S,n)\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>n\\<in>\\<int>\\<^sub>+. \\<Gamma>(S,n) \\<in> int\" using Real_ZF_1_4_L10\n    by simp\n  with A2 show I: \"g : \\<int>\\<^sub>+\\<rightarrow>int\" using ZF_fun_from_total by simp\n  { fix n assume \"n\\<in>\\<int>\\<^sub>+\"\n    with A2 I have \"g`(n) = \\<Gamma>(S,n)\" using ZF_fun_from_tot_val\n      by simp\n  } then show \"\\<forall>n\\<in>\\<int>\\<^sub>+. g`(n) = \\<Gamma>(S,n)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1740
    },
    "1569": {
        "type": "lemma",
        "text": "text\\<open>Every integer is equal to the floor of its embedding.\\<close>\n",
        "assumes": "assumes A1: \"m \\<in> int\"\n  ",
        "using": [
            "int0.Int_ZF_2_L4",
            "real_int_is_real",
            "real_ord_refl",
            "Real_ZF_1_4_L6",
            "Order_ZF_4_L14"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L14: assumes A1: \"m \\<in> int\"\n  shows \"\\<lfloor>m\\<^sup>R\\<rfloor> = m\"\n",
        "proof": "proof -\n  let ?A = \"{n \\<in> int. n\\<^sup>R \\<lsq> m\\<^sup>R }\"\n  have \"antisym(IntegerOrder)\" using int0.Int_ZF_2_L4\n    by simp  \n  moreover from A1 have \"m \\<in> ?A\" \n    using real_int_is_real real_ord_refl by auto\n  moreover from A1 have \"\\<forall>n \\<in> ?A. \\<langle>n,m\\<rangle> \\<in> IntegerOrder\"\n    using Real_ZF_1_4_L6 by auto\n  ultimately show \"\\<lfloor>m\\<^sup>R\\<rfloor> = m\" using Order_ZF_4_L14\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1741
    },
    "1570": {
        "type": "lemma",
        "text": "text\\<open>Floor of (real) zero is (integer) zero.\\<close>\n",
        "assumes": "",
        "using": [
            "int0.int_zero_one_are_int",
            "Real_ZF_1_4_L14",
            "int_0_1_are_real_zero_one"
        ],
        "statement": "lemma (in real1) floor_01_is_zero_one: shows \n  \"\\<lfloor>\\<zero>\\<rfloor> = \\<zero>\\<^sub>Z\"   \"\\<lfloor>\\<one>\\<rfloor> = \\<one>\\<^sub>Z\"\n",
        "proof": "proof -\n  have \"\\<lfloor>(\\<zero>\\<^sub>Z)\\<^sup>R\\<rfloor> = \\<zero>\\<^sub>Z\" and \"\\<lfloor>(\\<one>\\<^sub>Z)\\<^sup>R\\<rfloor> = \\<one>\\<^sub>Z\"\n    using int0.int_zero_one_are_int Real_ZF_1_4_L14\n    by auto\n  then show \"\\<lfloor>\\<zero>\\<rfloor> = \\<zero>\\<^sub>Z\" and  \"\\<lfloor>\\<one>\\<rfloor> = \\<one>\\<^sub>Z\"\n    using int_0_1_are_real_zero_one\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1742
    },
    "1571": {
        "type": "lemma",
        "text": "text\\<open>Floor of a product of embeddings of integers is equal to the\n  product of integers.\\<close>\n",
        "assumes": "assumes A1: \"m \\<in> int\"  \"k \\<in> int\"\n  ",
        "using": [
            "int0.Int_ZF_1_1_L5",
            "Real_ZF_1_4_L1C",
            "Real_ZF_1_4_L14"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L14A: assumes A1: \"m \\<in> int\"  \"k \\<in> int\"\n  shows  \"\\<lfloor>m\\<^sup>R\\<cdot>k\\<^sup>R\\<rfloor> = m\\<zmu>k\"\n",
        "proof": "proof -\n  from A1 have T: \"m\\<zmu>k \\<in> int\"\n    using int0.Int_ZF_1_1_L5 by simp\n  from A1 have \"\\<lfloor>m\\<^sup>R\\<cdot>k\\<^sup>R\\<rfloor> = \\<lfloor>(m\\<zmu>k)\\<^sup>R\\<rfloor>\" using Real_ZF_1_4_L1C\n    by simp\n  with T show \"\\<lfloor>m\\<^sup>R\\<cdot>k\\<^sup>R\\<rfloor> = m\\<zmu>k\" using Real_ZF_1_4_L14\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1744
    },
    "1572": {
        "type": "lemma",
        "text": "text\\<open>Floor of the sum of a number and the embedding of an\n  integer is the floor of the number plus the integer.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>\\<real>\" and A2: \"p \\<in> int\"\n  ",
        "using": [
            "int0.Int_ZF_2_L4",
            "Real_ZF_1_4_L7",
            "real_int_is_real",
            "add_num_to_ineq",
            "Real_ZF_1_4_L1A",
            "int0.Int_ZF_1_1_L5",
            "Real_ZF_1_2_L19",
            "Real_ZF_1_4_L1B",
            "Real_ZF_1_4_L9",
            "Real_ZF_1_4_L14",
            "int0.Int_ZF_2_L9C",
            "Order_ZF_4_L14"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L15: assumes A1: \"x\\<in>\\<real>\" and A2: \"p \\<in> int\"\n  shows \"\\<lfloor>x \\<ra> p\\<^sup>R\\<rfloor> = \\<lfloor>x\\<rfloor> \\<za> p\"\n",
        "proof": "proof -\n  let ?A = \"{n \\<in> int. n\\<^sup>R \\<lsq> x \\<ra> p\\<^sup>R}\"\n  have \"antisym(IntegerOrder)\" using int0.Int_ZF_2_L4\n    by simp\n  moreover have \"\\<lfloor>x\\<rfloor> \\<za> p \\<in> ?A\"\n  proof -\n    from A1 A2 have \"\\<lfloor>x\\<rfloor>\\<^sup>R \\<lsq> x\" and \"p\\<^sup>R \\<in> \\<real>\"\n      using Real_ZF_1_4_L7 real_int_is_real by auto\n    then have \"\\<lfloor>x\\<rfloor>\\<^sup>R \\<ra> p\\<^sup>R \\<lsq> x \\<ra> p\\<^sup>R\"\n      using add_num_to_ineq by simp\n    moreover from A1 A2 have \"(\\<lfloor>x\\<rfloor> \\<za> p)\\<^sup>R = \\<lfloor>x\\<rfloor>\\<^sup>R \\<ra> p\\<^sup>R\"\n      using Real_ZF_1_4_L7 Real_ZF_1_4_L1A by simp\n    ultimately have \"(\\<lfloor>x\\<rfloor> \\<za> p)\\<^sup>R \\<lsq> x \\<ra> p\\<^sup>R\"\n      by simp\n    moreover from A1 A2 have \"\\<lfloor>x\\<rfloor> \\<za> p \\<in> int\"\n      using Real_ZF_1_4_L7 int0.Int_ZF_1_1_L5 by simp\n    ultimately show \"\\<lfloor>x\\<rfloor> \\<za> p \\<in> ?A\" by auto\n  qed\n  moreover have \"\\<forall>n\\<in>?A. n \\<zlq> \\<lfloor>x\\<rfloor> \\<za> p\"\n  proof\n    fix n assume \"n\\<in>?A\"\n    then have I: \"n \\<in> int\" and \"n\\<^sup>R \\<lsq> x \\<ra> p\\<^sup>R\"\n      by auto\n    with A1 A2 have \"n\\<^sup>R \\<rs> p\\<^sup>R \\<lsq> x\"\n      using real_int_is_real Real_ZF_1_2_L19\n      by simp\n    with A2 I have \"\\<lfloor>(n\\<zs>p)\\<^sup>R\\<rfloor> \\<zlq> \\<lfloor>x\\<rfloor>\"\n      using Real_ZF_1_4_L1B Real_ZF_1_4_L9\n      by simp\n    moreover\n    from A2 I have \"n\\<zs>p \\<in> int\"\n      using int0.Int_ZF_1_1_L5 by simp\n    then have \"\\<lfloor>(n\\<zs>p)\\<^sup>R\\<rfloor> = n\\<zs>p\"\n      using Real_ZF_1_4_L14 by simp\n    ultimately have \"n\\<zs>p \\<zlq> \\<lfloor>x\\<rfloor>\"\n      by simp\n    with A2 I show \"n \\<zlq> \\<lfloor>x\\<rfloor> \\<za> p\"\n      using int0.Int_ZF_2_L9C by simp\n  qed\n  ultimately show \"\\<lfloor>x \\<ra> p\\<^sup>R\\<rfloor> = \\<lfloor>x\\<rfloor> \\<za> p\"\n    using Order_ZF_4_L14 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1745
    },
    "1573": {
        "type": "lemma",
        "text": "text\\<open>Floor of the difference of a number and the embedding of an\n  integer is the floor of the number minus the integer.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>\\<real>\" and A2: \"p \\<in> int\"\n  ",
        "using": [
            "Real_ZF_1_4_L1",
            "int0.Int_ZF_1_1_L4",
            "Real_ZF_1_4_L15"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L16: assumes A1: \"x\\<in>\\<real>\" and A2: \"p \\<in> int\"\n  shows \"\\<lfloor>x \\<rs> p\\<^sup>R\\<rfloor> = \\<lfloor>x\\<rfloor> \\<zs> p\"\n",
        "proof": "proof -\n  from A2 have \"\\<lfloor>x \\<rs> p\\<^sup>R\\<rfloor> = \\<lfloor>x \\<ra> (\\<zm>p)\\<^sup>R\\<rfloor>\"\n     using Real_ZF_1_4_L1 by simp\n  with A1 A2 show \"\\<lfloor>x \\<rs> p\\<^sup>R\\<rfloor> = \\<lfloor>x\\<rfloor> \\<zs> p\"\n    using int0.Int_ZF_1_1_L4 Real_ZF_1_4_L15 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1746
    },
    "1574": {
        "type": "lemma",
        "text": "text\\<open>The floor of sum of embeddings is the sum of the integers.\\<close>\n",
        "assumes": "assumes \"m \\<in> int\"  \"n \\<in> int\"\n  ",
        "using": [
            "assms",
            "real_int_is_real",
            "Real_ZF_1_4_L15",
            "Real_ZF_1_4_L14"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L17: assumes \"m \\<in> int\"  \"n \\<in> int\"\n  shows \"\\<lfloor>(m\\<^sup>R) \\<ra> n\\<^sup>R\\<rfloor> = m \\<za> n\"\n  ",
        "proof": "using assms real_int_is_real Real_ZF_1_4_L15 Real_ZF_1_4_L14\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1747
    },
    "1575": {
        "type": "lemma",
        "text": "text\\<open>The difference between the a number and the embedding of its floor\n  is (strictly) less than one.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_4_L7",
            "real_int_is_real",
            "Real_ZF_1_L6",
            "Real_ZF_1_L4",
            "Real_ZF_1_2_L21",
            "Real_ZF_1_4_L9",
            "int_0_1_are_real_zero_one",
            "int0.int_zero_one_are_int",
            "Real_ZF_1_4_L17",
            "int0.Int_ZF_1_2_L3AA",
            "Real_ZF_1_2_L26",
            "Real_ZF_1_4_L17A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L17B: assumes A1: \"a\\<in>\\<real>\"\n  shows \n  \"a \\<rs> \\<lfloor>a\\<rfloor>\\<^sup>R \\<ls> \\<one>\"\n  \"a \\<ls> (\\<one>\\<^sub>Z \\<za> \\<lfloor>a\\<rfloor>)\\<^sup>R\"\n",
        "proof": "proof -\n  from A1 have T1: \"\\<lfloor>a\\<rfloor> \\<in> int\"  \"\\<lfloor>a\\<rfloor>\\<^sup>R \\<in> \\<real>\" and\n    T2: \"\\<one> \\<in> \\<real>\"  \"a \\<rs>  \\<lfloor>a\\<rfloor>\\<^sup>R \\<in> \\<real>\"\n    using Real_ZF_1_4_L7 real_int_is_real Real_ZF_1_L6 Real_ZF_1_L4\n    by auto\n  { assume \"\\<one> \\<lsq> a \\<rs>  \\<lfloor>a\\<rfloor>\\<^sup>R\"\n    with A1 T1 have \"\\<lfloor>\\<one>\\<^sub>Z\\<^sup>R \\<ra> \\<lfloor>a\\<rfloor>\\<^sup>R\\<rfloor> \\<zlq> \\<lfloor>a\\<rfloor>\"\n      using Real_ZF_1_2_L21 Real_ZF_1_4_L9 int_0_1_are_real_zero_one \n      by simp\n    with T1 have False \n      using int0.int_zero_one_are_int Real_ZF_1_4_L17\n      int0.Int_ZF_1_2_L3AA by simp\n  } then have I: \"\\<not>(\\<one> \\<lsq> a \\<rs> \\<lfloor>a\\<rfloor>\\<^sup>R)\" by auto\n  with T2 show II: \"a \\<rs> \\<lfloor>a\\<rfloor>\\<^sup>R \\<ls> \\<one>\"\n    by (rule Real_ZF_1_2_L20)\n   with A1 T1 I II have \n    \"a \\<ls> \\<one> \\<ra> \\<lfloor>a\\<rfloor>\\<^sup>R\"\n    using Real_ZF_1_2_L26 by simp\n  with A1 show \"a \\<ls> (\\<one>\\<^sub>Z \\<za> \\<lfloor>a\\<rfloor>)\\<^sup>R\"\n    using Real_ZF_1_4_L17A by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1749
    },
    "1576": {
        "type": "lemma",
        "text": "text\\<open>The next lemma corresponds to Lemma 14 iii) in \\cite{Arthan2004}.\n  It says that we can find a rational number between any two different\n  real numbers.\\<close>\n",
        "assumes": "assumes A1: \"x\\<ls>y\"\n  ",
        "using": [
            "Real_ZF_1_3_L3",
            "Arthan_Lemma14i",
            "PositiveSet_def",
            "Real_ZF_1_2_L15",
            "real_int_is_real",
            "Real_ZF_1_L6",
            "int_pos_is_real_pos",
            "int0.int_zero_one_are_int",
            "Real_ZF_1_4_L7",
            "int0.Int_ZF_1_1_L5",
            "Real_ZF_1_4_L17B",
            "Real_ZF_1_L4",
            "real_ord_transl_inv",
            "Real_ZF_1_4_L17A",
            "Real_ZF_1_3_L5"
        ],
        "statement": "lemma (in real1) Arthan_Lemma14iii: assumes A1: \"x\\<ls>y\"\n  shows \"\\<exists>M\\<in>int. \\<exists>N\\<in>\\<int>\\<^sub>+.  x\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R \\<and> M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\"\n",
        "proof": "proof -\n  from A1 have \"(y\\<rs>x)\\<inverse> \\<in> \\<real>\\<^sub>+\" using Real_ZF_1_3_L3\n    by simp\n  then have \n    \"\\<exists>N\\<in>\\<int>\\<^sub>+. (y\\<rs>x)\\<inverse> \\<ls> N\\<^sup>R\"\n    using Arthan_Lemma14i PositiveSet_def by simp\n  then obtain N where I: \"N\\<in>\\<int>\\<^sub>+\" and II: \"(y\\<rs>x)\\<inverse> \\<ls> N\\<^sup>R\"\n    by auto\n  let ?M = \"\\<one>\\<^sub>Z \\<za> \\<lfloor>x\\<cdot>N\\<^sup>R\\<rfloor>\"\n  from A1 I have \n    T1: \"x\\<in>\\<real>\"  \"N\\<^sup>R \\<in> \\<real>\"  \"N\\<^sup>R \\<in> \\<real>\\<^sub>+\"  \"x\\<cdot>N\\<^sup>R \\<in> \\<real>\"\n    using Real_ZF_1_2_L15 PositiveSet_def real_int_is_real\n      Real_ZF_1_L6 int_pos_is_real_pos by auto\n  then have T2: \"?M \\<in> int\" using\n    int0.int_zero_one_are_int Real_ZF_1_4_L7 int0.Int_ZF_1_1_L5 \n    by simp\n  from T1 have III: \"x\\<cdot>N\\<^sup>R \\<ls> ?M\\<^sup>R\"\n    using Real_ZF_1_4_L17B by simp\n  from T1 have \"(\\<one> \\<ra> \\<lfloor>x\\<cdot>N\\<^sup>R\\<rfloor>\\<^sup>R) \\<lsq> (\\<one> \\<ra> x\\<cdot>N\\<^sup>R)\"\n    using Real_ZF_1_4_L7  Real_ZF_1_L4 real_ord_transl_inv \n    by simp\n  with T1 have \"?M\\<^sup>R \\<lsq> (\\<one> \\<ra> x\\<cdot>N\\<^sup>R)\"\n    using Real_ZF_1_4_L17A by simp\n  moreover from A1 II have \"(\\<one> \\<ra> x\\<cdot>N\\<^sup>R) \\<ls> y\\<cdot>N\\<^sup>R\"\n    using Real_ZF_1_3_L5 by simp\n  ultimately have \"?M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\"\n    by (rule real_strict_ord_transit)\n  with I T2 III show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1750
    },
    "1577": {
        "type": "lemma",
        "text": "text\\<open>Some estimates for the homomorphism difference of the floor\n  function.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>\\<real>\"  \"y\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_4_L7",
            "real_int_is_real",
            "Real_ZF_1_L6",
            "Real_ZF_1_2_L16",
            "Real_ZF_1_2_L17",
            "Real_ZF_1_4_L17B",
            "Real_ZF_1_2_L18",
            "Real_ZF_1_L7A",
            "Real_ZF_1_4_L9",
            "floor_01_is_zero_one",
            "floor_2_is_two",
            "Real_ZF_1_4_L16",
            "int0.Int_ZF_2_L16"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L18: assumes A1: \"x\\<in>\\<real>\"  \"y\\<in>\\<real>\"\n  shows \n  \"abs(\\<lfloor>x\\<ra>y\\<rfloor> \\<zs> \\<lfloor>x\\<rfloor> \\<zs> \\<lfloor>y\\<rfloor>) \\<zlq> \\<two>\\<^sub>Z\"\n",
        "proof": "proof -\n  from A1 have T: \n    \"\\<lfloor>x\\<rfloor>\\<^sup>R \\<in> \\<real>\"  \"\\<lfloor>y\\<rfloor>\\<^sup>R \\<in> \\<real>\"  \n    \"x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<in> \\<real>\"\n     using Real_ZF_1_4_L7 real_int_is_real Real_ZF_1_L6\n     by auto\n  from A1 have \n    \"\\<zero> \\<lsq> x \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<ra> (y \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R))\"\n    \"x \\<rs>  (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<ra> (y \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)) \\<lsq> \\<two>\"\n    using Real_ZF_1_4_L7 Real_ZF_1_2_L16 Real_ZF_1_2_L17\n      Real_ZF_1_4_L17B Real_ZF_1_2_L18 by auto\n  moreover from A1 T have \n    \"x \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<ra> (y \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)) = x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\"\n    using Real_ZF_1_L7A by simp\n  ultimately have \n    \"\\<zero> \\<lsq> x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\"\n    \"x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R) \\<lsq> \\<two>\"\n    by auto\n  then have \n    \"\\<lfloor>\\<zero>\\<rfloor> \\<zlq> \\<lfloor>x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\\<rfloor>\"\n    \"\\<lfloor>x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\\<rfloor> \\<zlq> \\<lfloor>\\<two>\\<rfloor>\"\n    using Real_ZF_1_4_L9 by auto\n  then have \n    \"\\<zero>\\<^sub>Z  \\<zlq> \\<lfloor>x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\\<rfloor>\"\n    \"\\<lfloor>x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\\<rfloor> \\<zlq> \\<two>\\<^sub>Z\"\n    using floor_01_is_zero_one floor_2_is_two by auto\n  moreover from A1 have\n    \"\\<lfloor>x\\<ra>y \\<rs> (\\<lfloor>x\\<rfloor>\\<^sup>R) \\<rs> (\\<lfloor>y\\<rfloor>\\<^sup>R)\\<rfloor> = \\<lfloor>x\\<ra>y\\<rfloor> \\<zs> \\<lfloor>x\\<rfloor> \\<zs> \\<lfloor>y\\<rfloor>\"\n    using Real_ZF_1_L6 Real_ZF_1_4_L7 real_int_is_real Real_ZF_1_4_L16\n    by simp\n  ultimately have\n    \"\\<zero>\\<^sub>Z \\<zlq> \\<lfloor>x\\<ra>y\\<rfloor> \\<zs> \\<lfloor>x\\<rfloor> \\<zs> \\<lfloor>y\\<rfloor>\"\n    \"\\<lfloor>x\\<ra>y\\<rfloor> \\<zs> \\<lfloor>x\\<rfloor> \\<zs> \\<lfloor>y\\<rfloor> \\<zlq> \\<two>\\<^sub>Z\"\n    by auto\n  then show \"abs(\\<lfloor>x\\<ra>y\\<rfloor> \\<zs> \\<lfloor>x\\<rfloor> \\<zs> \\<lfloor>y\\<rfloor>) \\<zlq> \\<two>\\<^sub>Z\"\n    using int0.Int_ZF_2_L16 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1751
    },
    "1578": {
        "type": "lemma",
        "text": "text\\<open>Suppose $S\\neq \\emptyset$ is bounded above and \n  $\\Gamma(S,m) =\\lfloor m^R\\cdot x\\rfloor$ for some positive integer $m$\n  and $x\\in S$. Then if $y\\in S, x\\leq y$ we also have \n  $\\Gamma(S,m) =\\lfloor m^R\\cdot y\\rfloor$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and\n  A2: \"n\\<in>\\<int>\\<^sub>+\" \"x\\<in>S\" and\n  A3: \"\\<Gamma>(S,n) = \\<lfloor>n\\<^sup>R\\<cdot>x\\<rfloor>\" and\n  A4: \"y\\<in>S\"  \"x\\<lsq>y\"\n  ",
        "using": [
            "int_pos_is_real_pos",
            "Real_ZF_1_2_L14",
            "Real_ZF_1_4_L9",
            "Real_ZF_1_4_L11"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L20: \n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and\n  A2: \"n\\<in>\\<int>\\<^sub>+\" \"x\\<in>S\" and\n  A3: \"\\<Gamma>(S,n) = \\<lfloor>n\\<^sup>R\\<cdot>x\\<rfloor>\" and\n  A4: \"y\\<in>S\"  \"x\\<lsq>y\"\n  shows \"\\<Gamma>(S,n) = \\<lfloor>n\\<^sup>R\\<cdot>y\\<rfloor>\"\n",
        "proof": "proof -\n  from A2 A4 have \"\\<lfloor>n\\<^sup>R\\<cdot>x\\<rfloor> \\<zlq> \\<lfloor>(n\\<^sup>R)\\<cdot>y\\<rfloor>\"\n    using int_pos_is_real_pos Real_ZF_1_2_L14 Real_ZF_1_4_L9\n    by simp\n  with A3 have \"\\<langle>\\<Gamma>(S,n),\\<lfloor>(n\\<^sup>R)\\<cdot>y\\<rfloor>\\<rangle> \\<in> IntegerOrder\"\n    by simp\n  moreover from A1 A2 A4 have \"\\<langle>\\<lfloor>n\\<^sup>R\\<cdot>y\\<rfloor>,\\<Gamma>(S,n)\\<rangle> \\<in> IntegerOrder\"\n    using Real_ZF_1_4_L11 by simp\n  ultimately show \"\\<Gamma>(S,n) = \\<lfloor>n\\<^sup>R\\<cdot>y\\<rfloor>\"\n    by (rule int0.Int_ZF_2_L3)\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1752
    },
    "1579": {
        "type": "lemma",
        "text": "text\\<open>The homomorphism difference of $n\\mapsto \\Gamma(S,n)$ is bounded\n  by $2$ on positive integers.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and\n  A2: \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\"\n  ",
        "using": [
            "int0.pos_int_closed_add_unfolded",
            "Real_ZF_1_4_L10",
            "Real_ZF_1_2_L23",
            "Real_ZF_1_2_L24",
            "Real_ZF_1_4_L20",
            "Real_ZF_1_4_L1A",
            "PositiveSet_def",
            "real_int_is_real",
            "Real_ZF_1_L7",
            "Real_ZF_1_L6",
            "Real_ZF_1_4_L18"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L21: \n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and\n  A2: \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\"\n  shows \"abs(\\<Gamma>(S,m\\<za>n) \\<zs> \\<Gamma>(S,m) \\<zs> \\<Gamma>(S,n)) \\<zlq>  \\<two>\\<^sub>Z\"\n",
        "proof": "proof -\n  from A2 have T: \"m\\<za>n \\<in> \\<int>\\<^sub>+\" using int0.pos_int_closed_add_unfolded\n    by simp\n  with A1 A2 have \n    \"\\<Gamma>(S,m) \\<in> {\\<lfloor>m\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\" and\n    \"\\<Gamma>(S,n) \\<in> {\\<lfloor>n\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\" and\n    \"\\<Gamma>(S,m\\<za>n) \\<in> {\\<lfloor>(m\\<za>n)\\<^sup>R\\<cdot>x\\<rfloor>. x\\<in>S}\"\n    using Real_ZF_1_4_L10 by auto\n  then obtain a b c where I: \"a\\<in>S\"  \"b\\<in>S\"  \"c\\<in>S\" \n    and II:\n    \"\\<Gamma>(S,m) = \\<lfloor>m\\<^sup>R\\<cdot>a\\<rfloor>\"  \n    \"\\<Gamma>(S,n) = \\<lfloor>n\\<^sup>R\\<cdot>b\\<rfloor>\"  \n    \"\\<Gamma>(S,m\\<za>n) = \\<lfloor>(m\\<za>n)\\<^sup>R\\<cdot>c\\<rfloor>\"\n    by auto\n  let ?d = \"Maximum(OrderOnReals,{a,b,c})\"\n  from A1 I have \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n    using Real_ZF_1_2_L23 by auto\n  then have IV:\n    \"?d \\<in> {a,b,c}\"\n    \"?d \\<in> \\<real>\"\n    \"a \\<lsq> ?d\"\n    \"b \\<lsq> ?d\"\n    \"c \\<lsq> ?d\"\n    using Real_ZF_1_2_L24 by auto\n  with I have V: \"?d \\<in> S\" by auto\n  from A1 T I II IV V have \"\\<Gamma>(S,m\\<za>n) = \\<lfloor>(m\\<za>n)\\<^sup>R\\<cdot>?d\\<rfloor>\"\n    using Real_ZF_1_4_L20 by blast\n  also from A2 have \"\\<dots> = \\<lfloor>((m\\<^sup>R)\\<ra>(n\\<^sup>R))\\<cdot>?d\\<rfloor>\"\n    using Real_ZF_1_4_L1A PositiveSet_def by simp\n  also from A2 IV have \"\\<dots> = \\<lfloor>(m\\<^sup>R)\\<cdot>?d \\<ra> (n\\<^sup>R)\\<cdot>?d\\<rfloor>\"\n    using PositiveSet_def real_int_is_real Real_ZF_1_L7\n    by simp\n  finally have  \"\\<Gamma>(S,m\\<za>n) =  \\<lfloor>(m\\<^sup>R)\\<cdot>?d \\<ra> (n\\<^sup>R)\\<cdot>?d\\<rfloor>\"\n    by simp\n  moreover from A1 A2 I II IV V have \"\\<Gamma>(S,m) = \\<lfloor>m\\<^sup>R\\<cdot>?d\\<rfloor>\"\n    using Real_ZF_1_4_L20 by blast\n  moreover from A1 A2 I II IV V have  \"\\<Gamma>(S,n) = \\<lfloor>n\\<^sup>R\\<cdot>?d\\<rfloor>\"\n    using Real_ZF_1_4_L20 by blast\n  moreover from A1 T I II IV V have \"\\<Gamma>(S,m\\<za>n) = \\<lfloor>(m\\<za>n)\\<^sup>R\\<cdot>?d\\<rfloor>\"\n    using Real_ZF_1_4_L20 by blast\n  ultimately have \"abs(\\<Gamma>(S,m\\<za>n) \\<zs> \\<Gamma>(S,m) \\<zs> \\<Gamma>(S,n)) =\n    abs(\\<lfloor>(m\\<^sup>R)\\<cdot>?d \\<ra> (n\\<^sup>R)\\<cdot>?d\\<rfloor> \\<zs> \\<lfloor>m\\<^sup>R\\<cdot>?d\\<rfloor> \\<zs> \\<lfloor>n\\<^sup>R\\<cdot>?d\\<rfloor>)\"\n    by simp\n  with A2 IV show \n    \"abs(\\<Gamma>(S,m\\<za>n) \\<zs> \\<Gamma>(S,m) \\<zs> \\<Gamma>(S,n)) \\<zlq>  \\<two>\\<^sub>Z\"\n    using PositiveSet_def real_int_is_real Real_ZF_1_L6\n      Real_ZF_1_4_L18 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1753
    },
    "1580": {
        "type": "lemma",
        "text": "text\\<open>The next lemma provides sufficient condition for an odd function \n  to be an almost homomorphism. \n  It says for odd functions we only need to check that \n  the homomorphism difference\n  (denoted \\<open>\\<delta>\\<close> in the \\<open>real1\\<close> context) is bounded on positive \n  integers. This is really proven in \\<open>Int_ZF_2.thy\\<close>, but we\n  restate it here for convenience. Recall from \\<open>Group_ZF_3.thy\\<close> that\n  \\<open>OddExtension\\<close> of a function defined on the set of positive elements\n  (of an ordered group) is the only odd function that is equal to the given\n  one when restricted to positive elements.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<^sub>+\\<rightarrow>int\"  \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<zlq> L\"\n  ",
        "using": [
            "A1",
            "int1.Int_ZF_2_1_L24"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L21A: \n  assumes A1: \"f:\\<int>\\<^sub>+\\<rightarrow>int\"  \"\\<forall>a\\<in>\\<int>\\<^sub>+. \\<forall>b\\<in>\\<int>\\<^sub>+. abs(\\<delta>(f,a,b)) \\<zlq> L\"\n  shows \"OddExtension(int,IntegerAddition,IntegerOrder,f) \\<in> \\<S>\"\n  ",
        "proof": "using A1 int1.Int_ZF_2_1_L24 by auto \n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1754
    },
    "1581": {
        "type": "lemma",
        "text": "text\\<open>The candidate for (a representant of) the supremum of a \n  nonempty bounded above set is a slope.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and\n  A2: \"g = {\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  ",
        "using": [
            "int0.pos_int_closed_add_unfolded"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L22: \n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and\n  A2: \"g = {\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  shows \"OddExtension(int,IntegerAddition,IntegerOrder,g) \\<in> \\<S>\"\n",
        "proof": "proof -\n  from A1 A2 have \"g: \\<int>\\<^sub>+\\<rightarrow>int\" by (rule Real_ZF_1_4_L12)\n  moreover have \"\\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. abs(\\<delta>(g,m,n)) \\<zlq> \\<two>\\<^sub>Z\"\n  proof -\n    { fix m n assume A3: \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\"\n      then have \"m\\<za>n \\<in> \\<int>\\<^sub>+\"  \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\" \n\tusing int0.pos_int_closed_add_unfolded\n\tby auto\n      moreover from A1 A2 have \"\\<forall>n\\<in>\\<int>\\<^sub>+. g`(n) = \\<Gamma>(S,n)\"\n\tby (rule Real_ZF_1_4_L12)\n      ultimately have \"\\<delta>(g,m,n) = \\<Gamma>(S,m\\<za>n) \\<zs> \\<Gamma>(S,m) \\<zs> \\<Gamma>(S,n)\"\n\tby simp\n      moreover from A1 A3 have\n\t\"abs(\\<Gamma>(S,m\\<za>n) \\<zs> \\<Gamma>(S,m) \\<zs> \\<Gamma>(S,n)) \\<zlq>  \\<two>\\<^sub>Z\"\n\tby (rule Real_ZF_1_4_L21)\n      ultimately have \"abs(\\<delta>(g,m,n)) \\<zlq> \\<two>\\<^sub>Z\"\n\tby simp\n    } then show \"\\<forall>m\\<in>\\<int>\\<^sub>+. \\<forall>n\\<in>\\<int>\\<^sub>+. abs(\\<delta>(g,m,n)) \\<zlq> \\<two>\\<^sub>Z\"\n      by simp\n  qed\n  ultimately show ?thesis by (rule Real_ZF_1_4_L21A)\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1755
    },
    "1582": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma used in the proof that all elements\n  of $S$ are less or equal than the candidate for supremum of $S$.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> int\"  \"M \\<in> int\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. M\\<zmu>n \\<zlq> f`(N\\<zmu>n)\"\n  ",
        "using": [
            "int1.Int_ZF_2_5_L1",
            "int1.Int_ZF_2_1_L11",
            "SlopeOp2_def",
            "int1.Int_ZF_2_5_L8",
            "SlopeOp1_def",
            "Slopes_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "PositiveIntegers_def",
            "PositiveSlopes_def",
            "Real_ZF_1_2_L12",
            "Real_ZF_1_1_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L23:\n  assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> int\"  \"M \\<in> int\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. M\\<zmu>n \\<zlq> f`(N\\<zmu>n)\"\n  shows \"M\\<^sup>R \\<lsq> [f]\\<cdot>(N\\<^sup>R)\"\n",
        "proof": "proof -\n  let ?M\\<^sub>S = \"{\\<langle>n, M\\<zmu>n\\<rangle> . n \\<in> int}\"\n  let ?N\\<^sub>S = \"{\\<langle>n, N\\<zmu>n\\<rangle> . n \\<in> int}\"\n  from A1 A2 have T: \"?M\\<^sub>S \\<in> \\<S>\"  \"?N\\<^sub>S \\<in> \\<S>\"  \"f\\<circ>?N\\<^sub>S \\<in> \\<S>\"\n    using int1.Int_ZF_2_5_L1 int1.Int_ZF_2_1_L11 SlopeOp2_def\n    by auto\n  moreover from A1 A2 A3 have \"?M\\<^sub>S \\<sim> f\\<circ>?N\\<^sub>S \\<or> f\\<circ>?N\\<^sub>S \\<fp> (\\<fm>?M\\<^sub>S) \\<in> \\<S>\\<^sub>+\"\n    using int1.Int_ZF_2_5_L8 SlopeOp2_def SlopeOp1_def Slopes_def\n      BoundedIntMaps_def SlopeEquivalenceRel_def PositiveIntegers_def\n      PositiveSlopes_def by simp\n  ultimately have \"[?M\\<^sub>S] \\<lsq> [f\\<circ>?N\\<^sub>S]\" using Real_ZF_1_2_L12\n    by simp\n  with A1 T show \"M\\<^sup>R \\<lsq> [f]\\<cdot>(N\\<^sup>R)\" using Real_ZF_1_1_L4\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1756
    },
    "1583": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma aimed used in the proof the candidate for supremum of \n  $S$ is less or equal than any upper bound for $S$.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> int\"  \"M \\<in> int\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. f`(N\\<zmu>n) \\<zlq>  M\\<zmu>n \"\n  ",
        "using": [
            "int1.Int_ZF_2_5_L1",
            "int1.Int_ZF_2_1_L11",
            "SlopeOp2_def",
            "int1.Int_ZF_2_5_L9",
            "SlopeOp1_def",
            "Slopes_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "PositiveIntegers_def",
            "PositiveSlopes_def",
            "Real_ZF_1_2_L12",
            "Real_ZF_1_1_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L23A:\n  assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> int\"  \"M \\<in> int\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+. f`(N\\<zmu>n) \\<zlq>  M\\<zmu>n \"\n  shows \"[f]\\<cdot>(N\\<^sup>R) \\<lsq> M\\<^sup>R\"\n",
        "proof": "proof -\n  let ?M\\<^sub>S = \"{\\<langle>n, M\\<zmu>n\\<rangle> . n \\<in> int}\"\n  let ?N\\<^sub>S = \"{\\<langle>n, N\\<zmu>n\\<rangle> . n \\<in> int}\"\n  from A1 A2 have T: \"?M\\<^sub>S \\<in> \\<S>\"  \"?N\\<^sub>S \\<in> \\<S>\"  \"f\\<circ>?N\\<^sub>S \\<in> \\<S>\"\n    using int1.Int_ZF_2_5_L1 int1.Int_ZF_2_1_L11 SlopeOp2_def\n    by auto\n  moreover from A1 A2 A3 have \n    \"f\\<circ>?N\\<^sub>S \\<sim> ?M\\<^sub>S \\<or>  ?M\\<^sub>S \\<fp> (\\<fm>(f\\<circ>?N\\<^sub>S)) \\<in> \\<S>\\<^sub>+\"\n    using int1.Int_ZF_2_5_L9 SlopeOp2_def SlopeOp1_def Slopes_def\n      BoundedIntMaps_def SlopeEquivalenceRel_def PositiveIntegers_def\n      PositiveSlopes_def by simp\n  ultimately have \"[f\\<circ>?N\\<^sub>S] \\<lsq> [?M\\<^sub>S]\" using Real_ZF_1_2_L12\n    by simp\n  with A1 T show \" [f]\\<cdot>(N\\<^sup>R)\\<lsq> M\\<^sup>R\" using Real_ZF_1_1_L4\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1757
    },
    "1584": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to claim that the candidate for supremum\n  of $S$ is greater or equal than all elements of $S$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and\n  A2: \"x\\<ls>y\"  \"y\\<in>S\"  and\n  A4: \"N \\<in> \\<int>\\<^sub>+\"  \"M \\<in> int\" and\n  A5: \"M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\" and A6: \"p \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "int_pos_is_real_pos",
            "Real_ZF_1_2_L15",
            "int0.pos_int_closed_mul_unfold",
            "real_int_is_real",
            "PositiveSet_def",
            "Real_ZF_1_3_L4A",
            "Real_ZF_1_3_L7",
            "Real_ZF_1_4_L9",
            "Real_ZF_1_4_L11",
            "Real_ZF_1_4_L1C",
            "Real_ZF_1_3_L8",
            "Real_ZF_1_4_L14A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L24:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and\n  A2: \"x\\<ls>y\"  \"y\\<in>S\"  and\n  A4: \"N \\<in> \\<int>\\<^sub>+\"  \"M \\<in> int\" and\n  A5: \"M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\" and A6: \"p \\<in> \\<int>\\<^sub>+\"\n  shows \"p\\<zmu>M \\<zlq> \\<Gamma>(S,p\\<zmu>N)\"\n",
        "proof": "proof -\n  from A2 A4 A6 have T1:\n    \"N\\<^sup>R \\<in> \\<real>\\<^sub>+\"   \"y\\<in>\\<real>\"   \"p\\<^sup>R \\<in> \\<real>\\<^sub>+\"\n    \"p\\<zmu>N \\<in> \\<int>\\<^sub>+\"   \"(p\\<zmu>N)\\<^sup>R \\<in> \\<real>\\<^sub>+\"    \n    using int_pos_is_real_pos Real_ZF_1_2_L15 \n    int0.pos_int_closed_mul_unfold by auto\n  with A4 A6 have T2: \n    \"p \\<in> int\"   \"p\\<^sup>R \\<in> \\<real>\"   \"N\\<^sup>R \\<in> \\<real>\"  \"N\\<^sup>R \\<noteq> \\<zero>\"   \"M\\<^sup>R \\<in> \\<real>\"\n    using real_int_is_real PositiveSet_def by auto\n  from T1 A5 have \"\\<lfloor>(p\\<zmu>N)\\<^sup>R\\<cdot>(M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>)\\<rfloor> \\<zlq> \\<lfloor>(p\\<zmu>N)\\<^sup>R\\<cdot>y\\<rfloor>\"\n    using Real_ZF_1_3_L4A Real_ZF_1_3_L7 Real_ZF_1_4_L9\n    by simp\n  moreover from A1 A2 T1 have \"\\<lfloor>(p\\<zmu>N)\\<^sup>R\\<cdot>y\\<rfloor> \\<zlq> \\<Gamma>(S,p\\<zmu>N)\"\n    using Real_ZF_1_4_L11 by simp\n  ultimately have I: \"\\<lfloor>(p\\<zmu>N)\\<^sup>R\\<cdot>(M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>)\\<rfloor> \\<zlq> \\<Gamma>(S,p\\<zmu>N)\"\n    by (rule int_order_transitive)\n  from A4 A6 have \"(p\\<zmu>N)\\<^sup>R\\<cdot>(M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>) = p\\<^sup>R\\<cdot>N\\<^sup>R\\<cdot>(M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>)\"\n    using PositiveSet_def Real_ZF_1_4_L1C by simp\n  with A4 T2 have \"\\<lfloor>(p\\<zmu>N)\\<^sup>R\\<cdot>(M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>)\\<rfloor> = p\\<zmu>M\"\n    using Real_ZF_1_3_L8 Real_ZF_1_4_L14A by simp\n  with I show \"p\\<zmu>M \\<zlq> \\<Gamma>(S,p\\<zmu>N)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1758
    },
    "1585": {
        "type": "lemma",
        "text": "text\\<open>An obvious fact about odd extension\n  of a function $p\\mapsto \\Gamma(s,p)$ that is used a couple of times \n  in proofs.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and A2: \"p \\<in> \\<int>\\<^sub>+\"\n  and A3:\n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  ",
        "using": [
            "Real_ZF_1_4_L12",
            "int0.Int_ZF_1_5_L11",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L24A:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and A2: \"p \\<in> \\<int>\\<^sub>+\"\n  and A3:\n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  shows \"h`(p) = \\<Gamma>(S,p)\"\n",
        "proof": "proof -\n  let ?g = \"{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n  from A1 have I: \"?g : \\<int>\\<^sub>+\\<rightarrow>int\" using  Real_ZF_1_4_L12\n    by blast\n  with A2 A3 show \"h`(p) = \\<Gamma>(S,p)\" \n    using int0.Int_ZF_1_5_L11 ZF_fun_from_tot_val\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1759
    },
    "1586": {
        "type": "lemma",
        "text": "text\\<open>The candidate for the supremum of $S$ is not smaller than \n  any element of $S$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and \n  A2: \"\\<not>HasAmaximum(OrderOnReals,S)\" and\n  A3: \"x\\<in>S\" and A4:\n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  ",
        "using": [
            "Real_ZF_1_2_L23",
            "Arthan_Lemma14iii",
            "int_pos_is_real_pos",
            "Real_ZF_1_2_L15",
            "Real_ZF_1_3_L4",
            "Real_ZF_1_4_L22",
            "PositiveSet_def",
            "int0.pos_int_closed_mul_unfold",
            "int0.Int_ZF_1_1_L5",
            "Real_ZF_1_4_L24A",
            "Real_ZF_1_4_L23",
            "Real_ZF_1_1_L3",
            "Real_ZF_1_3_L4B"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L25:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and \n  A2: \"\\<not>HasAmaximum(OrderOnReals,S)\" and\n  A3: \"x\\<in>S\" and A4:\n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  shows \"x \\<lsq> [h]\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \n    \"S \\<subseteq> \\<real>\"  \"\\<not>HasAmaximum(OrderOnReals,S)\"  \"x\\<in>S\" \n    using Real_ZF_1_2_L23 by auto\n  then have \"\\<exists>y\\<in>S. x\\<ls>y\" by (rule Real_ZF_1_2_L27)\n  then obtain y where I: \"y\\<in>S\" and  II: \"x\\<ls>y\"\n    by auto\n  from II have \n    \"\\<exists>M\\<in>int. \\<exists>N\\<in>\\<int>\\<^sub>+.  x\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R \\<and> M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\"\n    using Arthan_Lemma14iii by simp\n  then obtain M N where III: \"M \\<in> int\"  \"N\\<in>\\<int>\\<^sub>+\" and \n    IV: \"x\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R\"  \"M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\"\n    by auto\n  from II III IV have V: \"x \\<lsq> M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>\"\n    using int_pos_is_real_pos Real_ZF_1_2_L15 Real_ZF_1_3_L4\n    by auto\n  from A3 have VI: \"S\\<noteq>0\" by auto\n  with A1 A4 have T1: \"h \\<in> \\<S>\" using Real_ZF_1_4_L22\n    by simp\n  moreover from III have \"N \\<in> int\"  \"M \\<in> int\"\n    using PositiveSet_def by auto\n  moreover have \"\\<forall>n\\<in>\\<int>\\<^sub>+. M\\<zmu>n \\<zlq> h`(N\\<zmu>n)\"\n  proof\n    let ?g = \"{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+}\"\n    fix n assume A5: \"n\\<in>\\<int>\\<^sub>+\"\n    with III have T2: \"N\\<zmu>n \\<in> \\<int>\\<^sub>+\"\n      using int0.pos_int_closed_mul_unfold by simp\n    from III A5 have \n      \"N\\<zmu>n = n\\<zmu>N\"  and \"n\\<zmu>M = M\\<zmu>n\"\n      using PositiveSet_def int0.Int_ZF_1_1_L5 by auto   \n    moreover \n    from A1 I II III IV A5 have\n      \"IsBoundedAbove(S,OrderOnReals)\"\n      \"x\\<ls>y\"  \"y\\<in>S\"\n      \"N \\<in> \\<int>\\<^sub>+\"  \"M \\<in> int\"\n      \"M\\<^sup>R \\<ls> y\\<cdot>N\\<^sup>R\"  \"n \\<in> \\<int>\\<^sub>+\"\n      by auto\n    then have \"n\\<zmu>M \\<zlq> \\<Gamma>(S,n\\<zmu>N)\" by (rule Real_ZF_1_4_L24)\n    moreover from A1 A4 VI T2 have \"h`(N\\<zmu>n) = \\<Gamma>(S,N\\<zmu>n)\"\n      using Real_ZF_1_4_L24A by simp\n    ultimately show \"M\\<zmu>n \\<zlq> h`(N\\<zmu>n)\" by auto\n  qed \n  ultimately have \"M\\<^sup>R \\<lsq> [h]\\<cdot>N\\<^sup>R\" using Real_ZF_1_4_L23\n    by simp\n  with III T1 have \"M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse> \\<lsq> [h]\"\n    using int_pos_is_real_pos Real_ZF_1_1_L3 Real_ZF_1_3_L4B\n    by simp\n  with V show \"x \\<lsq> [h]\" by (rule real_ord_transitive)\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1760
    },
    "1587": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to claim that the candidate for supremum\n  of $S$ is less or equal than any upper bound of $S$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and\n  A2: \"x\\<lsq>y\"  \"x\\<in>S\"  and\n  A4: \"N \\<in> \\<int>\\<^sub>+\"  \"M \\<in> int\" and\n  A5: \"y\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R \" and A6: \"p \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "int0.pos_int_closed_mul_unfold",
            "PositiveSet_def",
            "real_int_is_real",
            "Real_ZF_1_2_L15",
            "int_pos_is_real_pos",
            "Real_ZF_1_2_L14A",
            "Real_ZF_1_4_L1C",
            "Real_ZF_1_3_L7",
            "Real_ZF_1_1_L9",
            "Real_ZF_1_4_L9",
            "int0.Int_ZF_1_1_L5",
            "Real_ZF_1_4_L14"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L26:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\" and\n  A2: \"x\\<lsq>y\"  \"x\\<in>S\"  and\n  A4: \"N \\<in> \\<int>\\<^sub>+\"  \"M \\<in> int\" and\n  A5: \"y\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R \" and A6: \"p \\<in> \\<int>\\<^sub>+\"\n  shows \"\\<lfloor>(N\\<zmu>p)\\<^sup>R\\<cdot>x\\<rfloor> \\<zlq> M\\<zmu>p\"\n",
        "proof": "proof -\n  from A2 A4 A6 have T:\n    \"p\\<zmu>N \\<in> \\<int>\\<^sub>+\"  \"p \\<in> int\"  \"N \\<in> int\"  \n    \"p\\<^sup>R \\<in> \\<real>\\<^sub>+\" \"p\\<^sup>R \\<in> \\<real>\"  \"N\\<^sup>R \\<in> \\<real>\"  \"x \\<in> \\<real>\"  \"y \\<in> \\<real>\"\n    using int0.pos_int_closed_mul_unfold PositiveSet_def\n      real_int_is_real Real_ZF_1_2_L15 int_pos_is_real_pos\n    by auto\n  with A2 have \"(p\\<zmu>N)\\<^sup>R\\<cdot>x \\<lsq> (p\\<zmu>N)\\<^sup>R\\<cdot>y\"\n    using int_pos_is_real_pos Real_ZF_1_2_L14A\n    by simp\n  moreover from A4 T have I: \n    \"(p\\<zmu>N)\\<^sup>R = p\\<^sup>R\\<cdot>N\\<^sup>R\"\n    \"(p\\<zmu>M)\\<^sup>R = p\\<^sup>R\\<cdot>M\\<^sup>R\"\n    using Real_ZF_1_4_L1C by auto\n  ultimately have \"(p\\<zmu>N)\\<^sup>R\\<cdot>x \\<lsq> p\\<^sup>R\\<cdot>N\\<^sup>R\\<cdot>y\"\n    by simp\n  moreover\n  from A5 T I have \"p\\<^sup>R\\<cdot>(y\\<cdot>N\\<^sup>R) \\<ls> (p\\<zmu>M)\\<^sup>R\"\n    using Real_ZF_1_3_L7 by simp\n  with T have \"p\\<^sup>R\\<cdot>N\\<^sup>R\\<cdot>y \\<ls> (p\\<zmu>M)\\<^sup>R\" using Real_ZF_1_1_L9\n    by simp\n  ultimately have \"(p\\<zmu>N)\\<^sup>R\\<cdot>x \\<ls> (p\\<zmu>M)\\<^sup>R\"\n    by (rule real_strict_ord_transit)\n  then have \"\\<lfloor>(p\\<zmu>N)\\<^sup>R\\<cdot>x\\<rfloor> \\<zlq> \\<lfloor>(p\\<zmu>M)\\<^sup>R\\<rfloor>\"\n    using Real_ZF_1_4_L9 by simp\n  moreover \n  from A4 T have \"p\\<zmu>M \\<in> int\" using int0.Int_ZF_1_1_L5\n    by simp\n  then have \"\\<lfloor>(p\\<zmu>M)\\<^sup>R\\<rfloor> = p\\<zmu>M\" using Real_ZF_1_4_L14\n    by simp\n   moreover from A4 A6 have \"p\\<zmu>N = N\\<zmu>p\" and \"p\\<zmu>M = M\\<zmu>p\"\n    using PositiveSet_def int0.Int_ZF_1_1_L5 by auto\n  ultimately show \"\\<lfloor>(N\\<zmu>p)\\<^sup>R\\<cdot>x\\<rfloor> \\<zlq> M\\<zmu>p\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1761
    },
    "1588": {
        "type": "lemma",
        "text": "text\\<open>A piece of the proof of the fact that the candidate for the supremum \n  of $S$ is not greater than any upper bound of $S$, done separately for \n  clarity (of mind).\\<close>\n",
        "assumes": "assumes \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and \n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  and \"p \\<in> \\<int>\\<^sub>+\" \n  ",
        "using": [
            "assms",
            "Real_ZF_1_4_L10",
            "Real_ZF_1_4_L24A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L27:\n  assumes \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\" and \n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  and \"p \\<in> \\<int>\\<^sub>+\" \n  shows \"\\<exists>x\\<in>S. h`(p) = \\<lfloor>p\\<^sup>R\\<cdot>x\\<rfloor>\"\n  ",
        "proof": "using assms Real_ZF_1_4_L10 Real_ZF_1_4_L24A by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1762
    },
    "1589": {
        "type": "lemma",
        "text": "text\\<open>The candidate for the supremum of $S$ is not greater than \n  any upper bound of $S$.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\"\n  and A2: \"\\<forall>x\\<in>S. x\\<lsq>y\" and A3:\n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  ",
        "using": [
            "Real_ZF_1_2_L15",
            "Real_ZF_1_4_L22",
            "Real_ZF_1_1_L3",
            "Real_ZF_1_2_L28",
            "Arthan_Lemma14iii",
            "int_pos_is_real_pos",
            "int0.pos_int_closed_mul_unfold",
            "Real_ZF_1_4_L27",
            "Real_ZF_1_4_L26",
            "PositiveSet_def",
            "Real_ZF_1_4_L23A",
            "Real_ZF_1_3_L4C",
            "Real_ZF_1_3_L4A",
            "Real_ZF_1_2_L29"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L28:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\"\n  and A2: \"\\<forall>x\\<in>S. x\\<lsq>y\" and A3:\n  \"h = OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n  shows \"[h] \\<lsq> y\"\n",
        "proof": "proof -\n  from A1 obtain a where \"a\\<in>S\" by auto\n  with A1 A2 A3 have T: \"y\\<in>\\<real>\"  \"h \\<in> \\<S>\"  \"[h] \\<in> \\<real>\"\n    using Real_ZF_1_2_L15 Real_ZF_1_4_L22 Real_ZF_1_1_L3\n    by auto\n  { assume \"\\<not>([h] \\<lsq> y)\" \n    with T have \"y \\<ls> [h]\" using Real_ZF_1_2_L28\n      by blast\n    then have \"\\<exists>M\\<in>int. \\<exists>N\\<in>\\<int>\\<^sub>+.  y\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R \\<and> M\\<^sup>R \\<ls> [h]\\<cdot>N\\<^sup>R\"\n      using Arthan_Lemma14iii by simp\n    then obtain M N where I: \"M\\<in>int\"  \"N\\<in>\\<int>\\<^sub>+\" and\n      II: \"y\\<cdot>N\\<^sup>R \\<ls> M\\<^sup>R\"  \"M\\<^sup>R \\<ls> [h]\\<cdot>N\\<^sup>R\"\n      by auto\n    from I have III: \"N\\<^sup>R \\<in> \\<real>\\<^sub>+\" using int_pos_is_real_pos\n      by simp\n    have \"\\<forall>p\\<in>\\<int>\\<^sub>+. h`(N\\<zmu>p) \\<zlq>  M\\<zmu>p\"\n    proof\n      fix p assume A4: \"p\\<in>\\<int>\\<^sub>+\"\n      with A1 A3 I have \"\\<exists>x\\<in>S. h`(N\\<zmu>p) = \\<lfloor>(N\\<zmu>p)\\<^sup>R\\<cdot>x\\<rfloor>\"\n\tusing int0.pos_int_closed_mul_unfold Real_ZF_1_4_L27\n\tby simp\n      with A1 A2 I II A4 show \"h`(N\\<zmu>p) \\<zlq>  M\\<zmu>p\"\n\tusing Real_ZF_1_4_L26 by auto\n    qed\n    with T I have \"[h]\\<cdot>N\\<^sup>R \\<lsq> M\\<^sup>R\" \n      using PositiveSet_def Real_ZF_1_4_L23A\n      by simp\n    with T III have \"[h] \\<lsq>  M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse>\"\n      using Real_ZF_1_3_L4C by simp\n    moreover from T II III have \"M\\<^sup>R\\<cdot>(N\\<^sup>R)\\<inverse> \\<ls> [h]\"\n      using Real_ZF_1_3_L4A by simp\n    ultimately have False using Real_ZF_1_2_L29 by blast\n  } then show \"[h] \\<lsq> y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1763
    },
    "1590": {
        "type": "lemma",
        "text": "text\\<open>Now we can prove that every nonempty subset of reals that is bounded\n  above has a supremum. Proof by considering two cases: when the set has a\n  maximum and when it does not.\\<close>\n",
        "assumes": "assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\"\n  ",
        "using": [
            "Real_ZF_1_2_L10",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "Order_ZF_5_L6",
            "Real_ZF_1_4_L25",
            "Real_ZF_1_4_L28"
        ],
        "statement": "lemma (in real1) real_order_complete:\n  assumes A1: \"IsBoundedAbove(S,OrderOnReals)\"  \"S\\<noteq>0\"\n  shows \"HasAminimum(OrderOnReals,\\<Inter>a\\<in>S. OrderOnReals``{a})\"\n",
        "proof": "proof -\n  { assume \"HasAmaximum(OrderOnReals,S)\"\n    with A1 have \"HasAminimum(OrderOnReals,\\<Inter>a\\<in>S. OrderOnReals``{a})\"\n      using Real_ZF_1_2_L10 IsAnOrdGroup_def IsPartOrder_def\n\tOrder_ZF_5_L6 by simp }\n  moreover\n  { assume A2: \"\\<not>HasAmaximum(OrderOnReals,S)\"\n    let ?h = \"OddExtension(int,IntegerAddition,IntegerOrder,{\\<langle>p,\\<Gamma>(S,p)\\<rangle>. p\\<in>\\<int>\\<^sub>+})\"\n    let ?r = \"OrderOnReals\"\n    from A1 have \"antisym(OrderOnReals)\"  \"S\\<noteq>0\"\n      using Real_ZF_1_2_L10 IsAnOrdGroup_def IsPartOrder_def by auto\n    moreover from A1 A2 have \"\\<forall>x\\<in>S. \\<langle>x,[?h]\\<rangle> \\<in> ?r\"\n      using Real_ZF_1_4_L25 by simp\n    moreover from A1 have \"\\<forall>y. (\\<forall>x\\<in>S. \\<langle>x,y\\<rangle> \\<in> ?r) \\<longrightarrow> \\<langle>[?h],y\\<rangle> \\<in> ?r\"\n      using Real_ZF_1_4_L28 by simp\n    ultimately have \"HasAminimum(OrderOnReals,\\<Inter>a\\<in>S. OrderOnReals``{a})\"\n      by (rule Order_ZF_5_L5) }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1764
    },
    "1591": {
        "type": "lemma",
        "text": "text\\<open> The distance function \\<open>dist\\<close> defined in the \\<open>reals\\<close> locale is a metric. \\<close>\n",
        "assumes": "",
        "using": [
            "add_group.group_op_closed",
            "add_group.inverse_in_group",
            "OrdRing_ZF_1_L4",
            "OrderedGroup_ZF_3_L3B",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val0",
            "add_group.group0_2_L6",
            "OrderedGroup_ZF_3_L2A",
            "add_group.group0_2_L12",
            "basic_props(1)",
            "OrderedGroup_ZF_3_L7A",
            "OrderedGroup_ZF_3_L3D",
            "add_group.group0_2_L11A",
            "add_group.cancel_middle(5)",
            "OrdRing_ZF_1_L4(2,3)",
            "OrdGroup_triangle_ineq"
        ],
        "statement": "lemma (in reals) dist_is_metric: shows \n  \"dist : \\<real>\\<times>\\<real> \\<rightarrow> \\<real>\\<^sup>+\" \n  \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle> = \\<bar>x \\<rs> y\\<bar>\"\n  \"\\<forall>x\\<in>\\<real>.dist`\\<langle>x,x\\<rangle> = \\<zero>\"\n  \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle> = dist`\\<langle>y,x\\<rangle>\"\n  \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>.\\<forall>z\\<in>\\<real>. \\<bar>x \\<rs> z\\<bar> \\<lsq> \\<bar>x \\<rs> y\\<bar> \\<ra> \\<bar>y \\<rs> z\\<bar>\"\n  \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>.\\<forall>z\\<in>\\<real>. dist`\\<langle>x,z\\<rangle> \\<lsq> dist`\\<langle>x, y\\<rangle> \\<ra> dist`\\<langle>y,z\\<rangle>\"\n  \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle> = \\<zero> \\<longrightarrow> x=y\" \n  \"IsApseudoMetric(dist,\\<real>,\\<real>,Add,ROrd)\"\n  \"IsAmetric(dist,\\<real>,\\<real>,Add,ROrd)\"\n",
        "proof": "proof -\n  show I: \"dist : \\<real>\\<times>\\<real> \\<rightarrow> \\<real>\\<^sup>+\" using add_group.group_op_closed add_group.inverse_in_group OrdRing_ZF_1_L4 \n      OrderedGroup_ZF_3_L3B  ZF_fun_from_total by simp\n  then show II:\"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle> = \\<bar>x\\<rs>y\\<bar>\" using ZF_fun_from_tot_val0 by auto\n  then show III: \"\\<forall>x\\<in>\\<real>.dist`\\<langle>x,x\\<rangle> = \\<zero>\" using add_group.group0_2_L6 OrderedGroup_ZF_3_L2A by simp\n  { fix x y\n    assume \"x\\<in>\\<real>\" \"y\\<in>\\<real>\"\n    then have \"(\\<rm>(x\\<rs>y)) = y\\<rs>x\" using add_group.group0_2_L12 by simp\n    moreover from \\<open>x\\<in>\\<real>\\<close> \\<open>y\\<in>\\<real>\\<close> have \"\\<bar>\\<rm>(x\\<rs>y)\\<bar> =\\<bar>x\\<rs>y\\<bar>\"\n      using add_group.group_op_closed add_group.inverse_in_group basic_props(1) OrderedGroup_ZF_3_L7A\n      by simp\n    ultimately have \"\\<bar>y\\<rs>x\\<bar> = \\<bar>x\\<rs>y\\<bar>\" by simp\n    with \\<open>x\\<in>\\<real>\\<close> \\<open>y\\<in>\\<real>\\<close> II have \"dist`\\<langle>x,y\\<rangle> = dist`\\<langle>y,x\\<rangle>\" by simp\n  } thus IV: \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle> = dist`\\<langle>y,x\\<rangle>\" by simp\n  { fix x y\n    assume \"x\\<in>\\<real>\" \"y\\<in>\\<real>\" \"dist`\\<langle>x,y\\<rangle> = \\<zero>\"  \n    with II have \"\\<bar>x\\<rs>y\\<bar> = \\<zero>\" by simp\n    with \\<open>x\\<in>\\<real>\\<close> \\<open>y\\<in>\\<real>\\<close> have \"x\\<rs>y = \\<zero>\" \n      using add_group.group_op_closed add_group.inverse_in_group OrderedGroup_ZF_3_L3D by auto\n    with \\<open>x\\<in>\\<real>\\<close> \\<open>y\\<in>\\<real>\\<close> have\"x=y\" using add_group.group0_2_L11A by simp\n  } thus V: \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle> = \\<zero> \\<longrightarrow> x=y\" by auto\n  { fix x y z\n    assume \"x\\<in>\\<real>\" \"y\\<in>\\<real>\" \"z\\<in>\\<real>\"\n    then have \"\\<bar>x\\<rs>z\\<bar> = \\<bar>(x\\<rs>y)\\<ra>(y \\<rs> z)\\<bar>\" using add_group.cancel_middle(5) by simp\n    with \\<open>x\\<in>\\<real>\\<close> \\<open>y\\<in>\\<real>\\<close> \\<open>z\\<in>\\<real>\\<close> have \"\\<bar>x\\<rs>z\\<bar>  \\<lsq> \\<bar>x\\<rs>y\\<bar> \\<ra> \\<bar>y \\<rs> z\\<bar>\"\n      using add_group.group_op_closed add_group.inverse_in_group OrdRing_ZF_1_L4(2,3) OrdGroup_triangle_ineq\n      by simp\n  } thus  \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>.\\<forall>z\\<in>\\<real>. \\<bar>x \\<rs> z\\<bar> \\<lsq> \\<bar>x \\<rs> y\\<bar> \\<ra> \\<bar>y \\<rs> z\\<bar>\" by simp\n  with II show \"\\<forall>x\\<in>\\<real>.\\<forall>y\\<in>\\<real>.\\<forall>z\\<in>\\<real>. dist`\\<langle>x,z\\<rangle> \\<lsq> dist`\\<langle>x, y\\<rangle> \\<ra> dist`\\<langle>y,z\\<rangle>\" by auto\n  with I III IV V show \"IsApseudoMetric(dist,\\<real>,\\<real>,Add,ROrd)\" and \"IsAmetric(dist,\\<real>,\\<real>,Add,ROrd)\"\n    unfolding IsApseudoMetric_def IsAmetric_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1768
    },
    "1592": {
        "type": "lemma",
        "text": "text\\<open>Real numbers form an ordered loop.\\<close>\n",
        "assumes": "",
        "using": [
            "add_group.group_is_loop",
            "IsAmodelOfReals_def",
            "IsAnOrdField_def",
            "IsAnOrdRing_def",
            "Order_ZF_1_L2",
            "ord_transl_inv",
            "ineq_cancel_right",
            "OrderedGroup_ZF_1_L5AE"
        ],
        "statement": "lemma (in reals) reals_loop: shows \"IsAnOrdLoop(\\<real>,Add,ROrd)\"\n",
        "proof": "proof -\n  have \"IsAloop(\\<real>,Add)\" using add_group.group_is_loop by simp\n  moreover from R_are_reals have \"ROrd \\<subseteq> \\<real> \\<times> \\<real>\" and \"IsPartOrder(\\<real>,ROrd)\"\n    using IsAmodelOfReals_def IsAnOrdField_def IsAnOrdRing_def Order_ZF_1_L2 \n    by auto\n  moreover \n  { fix x y z assume A: \"x\\<in>\\<real>\" \"y\\<in>\\<real>\"  \"z\\<in>\\<real>\"\n    then have \"x\\<lsq>y \\<longleftrightarrow> x\\<ra>z \\<lsq> y\\<ra>z\" \n      using ord_transl_inv ineq_cancel_right by blast\n    moreover from A have \"x\\<lsq>y \\<longleftrightarrow> z\\<ra>x \\<lsq> z\\<ra>y\"\n      using ord_transl_inv OrderedGroup_ZF_1_L5AE by blast\n    ultimately have \"(x\\<lsq>y \\<longleftrightarrow> x\\<ra>z \\<lsq> y\\<ra>z) \\<and> (x\\<lsq>y \\<longleftrightarrow> z\\<ra>x \\<lsq> z\\<ra>y)\"\n      by simp\n  }\n  ultimately show \"IsAnOrdLoop(\\<real>,Add,ROrd)\" unfolding IsAnOrdLoop_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1769
    },
    "1593": {
        "type": "lemma",
        "text": "text\\<open> The assumptions of the  \\<open>pmetric_space\\<close> locale hold in the \\<open>reals\\<close> locale. \\<close>\n",
        "assumes": "",
        "using": [
            "reals_loop",
            "dist_is_metric(8)"
        ],
        "statement": "lemma (in reals) pmetric_space_valid: shows \"pmetric_space(\\<real>,Add, ROrd,dist,\\<real>)\" \n  unfolding pmetric_space_def pmetric_space_axioms_def loop1_def\n  ",
        "proof": "using reals_loop dist_is_metric(8) \n  by blast \n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1770
    },
    "1594": {
        "type": "lemma",
        "text": "text\\<open> The assumptions of the  \\<open>metric_space\\<close> locale hold in the \\<open>reals\\<close> locale. \\<close>\n",
        "assumes": "",
        "using": [
            "dist_is_metric(9)",
            "IsAmetric_def",
            "pmetric_space_valid"
        ],
        "statement": "lemma (in reals) metric_space_valid: shows \"metric_space(\\<real>,Add, ROrd,dist,\\<real>)\"\n",
        "proof": "proof -\n  have \"\\<forall>x\\<in>\\<real>. \\<forall>y\\<in>\\<real>. dist`\\<langle>x,y\\<rangle>=\\<zero> \\<longrightarrow> x=y\"\n    using dist_is_metric(9) unfolding IsAmetric_def by auto\n  then show ?thesis unfolding metric_space_def metric_space_axioms_def \n    using pmetric_space_valid by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1771
    },
    "1595": {
        "type": "lemma",
        "text": "text\\<open>Some properties of the order relation on reals: \\<close>\n",
        "assumes": "",
        "using": [
            "OrdRing_ZF_1_L1",
            "IsAnOrdRing_def",
            "pos_set_in_gr",
            "ord_linear_subset(2)",
            "lin_is_latt"
        ],
        "statement": "lemma (in reals) pos_is_lattice: shows \n  \"IsLinOrder(\\<real>,ROrd)\"\n  \"IsLinOrder(\\<real>\\<^sub>+,ROrd \\<inter> \\<real>\\<^sub>+\\<times>\\<real>\\<^sub>+)\"\n  \"(ROrd \\<inter> \\<real>\\<^sub>+\\<times>\\<real>\\<^sub>+) {is a lattice on} \\<real>\\<^sub>+\"\n",
        "proof": "proof -\n  show \"IsLinOrder(\\<real>,ROrd)\" using OrdRing_ZF_1_L1 unfolding IsAnOrdRing_def by simp\n  moreover have \"\\<real>\\<^sub>+ \\<subseteq> \\<real>\" using pos_set_in_gr by simp \n  ultimately show \"IsLinOrder(\\<real>\\<^sub>+,ROrd \\<inter> \\<real>\\<^sub>+\\<times>\\<real>\\<^sub>+)\" using ord_linear_subset(2) by simp\n  moreover have \"(ROrd \\<inter> \\<real>\\<^sub>+\\<times>\\<real>\\<^sub>+) \\<subseteq> \\<real>\\<^sub>+\\<times>\\<real>\\<^sub>+\" by auto\n  ultimately show \"(ROrd \\<inter> \\<real>\\<^sub>+\\<times>\\<real>\\<^sub>+) {is a lattice on} \\<real>\\<^sub>+\" using lin_is_latt by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1772
    },
    "1596": {
        "type": "lemma",
        "text": "text\\<open>Of course the set of positive real numbers is nonempty as one is there.\\<close>\n",
        "assumes": "",
        "using": [
            "R_are_reals",
            "ordring_one_is_pos",
            "IsAmodelOfReals_def",
            "IsAnOrdField_def"
        ],
        "statement": "lemma (in reals) pos_non_empty: shows \"\\<real>\\<^sub>+\\<noteq>0\"\n  ",
        "proof": "using R_are_reals ordring_one_is_pos \n  unfolding IsAmodelOfReals_def IsAnOrdField_def by auto\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1773
    },
    "1597": {
        "type": "lemma",
        "text": "text\\<open>We say that a relation $r$  \\<open>down-directs\\<close> a set $R$ if every two-element subset\n  of $R$ has a lower bound. The next lemma states that the natural order relation on real numbers\n  down-directs the set of positive reals. \\<close>\n",
        "assumes": "",
        "using": [
            "pos_is_lattice(3)",
            "pos_non_empty",
            "meet_down_directs",
            "down_dir_mono",
            "IsAlattice_def"
        ],
        "statement": "lemma (in reals) rord_down_directs: shows \"ROrd {down-directs} \\<real>\\<^sub>+\" \n  ",
        "proof": "using pos_is_lattice(3) pos_non_empty meet_down_directs down_dir_mono\n  unfolding IsAlattice_def by blast\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1774
    },
    "1598": {
        "type": "definition",
        "text": "text\\<open> We define the topology on reals as one consisting of the unions of open disks. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in reals) RealTopology (\"\\<tau>\\<^sub>\\<real>\") \n  where \"\\<tau>\\<^sub>\\<real> \\<equiv> {\\<Union>A. A \\<in> Pow(\\<Union>c\\<in>\\<real>.{disk(c,r). r \\<in> \\<real>\\<^sub>+})}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1775
    },
    "1599": {
        "type": "theorem",
        "text": "text\\<open>Real numbers form a Hausdorff topological space with topology generated by open disks. \\<close>\n",
        "assumes": "",
        "using": [
            "rord_down_directs",
            "metric_space_valid",
            "pmetric_space_valid",
            "pmetric_space.pmetric_is_top",
            "metric_space.metric_space_T2",
            "RealTopology_def"
        ],
        "statement": "theorem (in reals) reals_is_top: \n  shows \"\\<tau>\\<^sub>\\<real> {is a topology}\" \"\\<Union>\\<tau>\\<^sub>\\<real> = \\<real>\" \"\\<tau>\\<^sub>\\<real> {is T\\<^sub>2}\"\n  ",
        "proof": "using rord_down_directs metric_space_valid pmetric_space_valid \n    pmetric_space.pmetric_is_top  metric_space.metric_space_T2\n  unfolding RealTopology_def\n    by simp_all\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1776
    },
    "1600": {
        "type": "lemma",
        "text": "text\\<open>Natural multiple and power of a ring element is a ring element.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\"\n  ",
        "using": [
            "assms",
            "add_monoid.nat_mult_type",
            "mul_monoid.nat_mult_type"
        ],
        "statement": "lemma (in ring3) mult_pow_type: assumes \"n\\<in>nat\" \"x\\<in>R\"\n  shows \"n\\<nm>x \\<in> R\" and \"pow(n,x) \\<in> R\"\n  ",
        "proof": "using assms add_monoid.nat_mult_type mul_monoid.nat_mult_type \n  by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1778
    },
    "1601": {
        "type": "lemma",
        "text": "text\\<open>The usual properties of multiples and powers: $(n+1)x = nx+x$ and \n  $x^n+1=x^n x$. These are just versions of \\<open>nat_mult_add_one\\<close> from \\<open>Monoid_ZF_1\\<close>\n  writtent in the notation defined in the \\<open>ring3\\<close> locale.\\<close>\n",
        "assumes": "assumes  \"n\\<in>nat\" \"x\\<in>R\"\n  ",
        "using": [
            "assms",
            "add_monoid.nat_mult_add_one",
            "mul_monoid.nat_mult_add_one"
        ],
        "statement": "lemma (in ring3) nat_mult_pow_add_one: assumes  \"n\\<in>nat\" \"x\\<in>R\"\n  shows \"(n #+ 1)\\<nm>x = (n\\<nm>x) \\<ra> x\" and \"pow(n #+ 1,x) = pow(n,x)\\<cdot>x\"\n  ",
        "proof": "using assms add_monoid.nat_mult_add_one mul_monoid.nat_mult_add_one \n  by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1779
    },
    "1602": {
        "type": "lemma",
        "text": "text\\<open>Associativity for the multiplication by natural number and the ring multiplication:\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\"\n  ",
        "using": [
            "mult_pow_zero(1)",
            "Ring_ZF_1_L6",
            "nat_mult_pow_add_one(1)",
            "mult_pow_type",
            "ring_oper_distr(2)",
            "Ring_ZF_1_L4(3)"
        ],
        "statement": "lemma (in ring3) nat_mult_assoc: assumes \"n\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\"\n  shows \"n\\<nm>x\\<cdot>y = n\\<nm>(x\\<cdot>y)\"\n",
        "proof": "proof -\n  from assms(1,3) have \"n\\<in>nat\" and \"0\\<nm>x\\<cdot>y = 0\\<nm>(x\\<cdot>y)\"\n    using mult_pow_zero(1) Ring_ZF_1_L6 by simp_all\n  moreover from assms(2,3) have \"\\<forall>k\\<in>nat. \n    k\\<nm>x\\<cdot>y = k\\<nm>(x\\<cdot>y) \\<longrightarrow> (k #+ 1)\\<nm>x\\<cdot>y = (k #+ 1)\\<nm>(x\\<cdot>y)\"\n    using nat_mult_pow_add_one(1) mult_pow_type ring_oper_distr(2) Ring_ZF_1_L4(3)\n      by simp\n  ultimately show ?thesis by (rule ind_on_nat1)\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1780
    },
    "1603": {
        "type": "lemma",
        "text": "text\\<open>Addition of natural numbers is distributive with respect to natural multiple.\n  This is essentially lemma \\<open>nat_mult_add\\<close> from \\<open>Monoid_ZF_1.thy\\<close>, just transferred\n  to the \\<open>ring3\\<close> locale.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"m\\<in>nat\" \"x\\<in>R\"\n  ",
        "using": [
            "assms",
            "add_monoid.nat_mult_add"
        ],
        "statement": "lemma (in ring3) nat_add_mult_distrib: assumes \"n\\<in>nat\" \"m\\<in>nat\" \"x\\<in>R\"\n  shows \"(n #+ m)\\<nm>x = n\\<nm>x \\<ra> m\\<nm>x\"\n  ",
        "proof": "using assms add_monoid.nat_mult_add by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1781
    },
    "1604": {
        "type": "lemma",
        "text": "text\\<open>Associativity for the multiplication by natural number and the ring multiplication\n  extended to three elements of the ring:\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\" \"z\\<in>R\" \n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L4(3)",
            "nat_mult_assoc"
        ],
        "statement": "lemma (in ring3) nat_mult_assoc1: assumes \"n\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\" \"z\\<in>R\" \n  shows \"n\\<nm>x\\<cdot>y\\<cdot>z = n\\<nm>(x\\<cdot>y\\<cdot>z)\"\n  ",
        "proof": "using assms Ring_ZF_1_L4(3) nat_mult_assoc by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1782
    },
    "1605": {
        "type": "lemma",
        "text": "text\\<open>When we multiply an expression whose value belongs to a ring by a ring element \n  and we get an expression whose value belongs to a ring.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\" and \"\\<forall>k\\<in>n. q(k) \\<in> R\" \n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L4(3)",
            "add_monoid.sum_in_mono"
        ],
        "statement": "lemma (in ring3) mult_elem_ring_type: \n  assumes \"n\\<in>nat\" \"x\\<in>R\" and \"\\<forall>k\\<in>n. q(k) \\<in> R\" \n  shows \"\\<forall>k\\<in>n. q(k)\\<cdot>x \\<in> R\" and \"(\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>n}) \\<in> R\"\n  ",
        "proof": "using assms Ring_ZF_1_L4(3) add_monoid.sum_in_mono by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1783
    },
    "1606": {
        "type": "lemma",
        "text": "text\\<open>A \\<open>ring3\\<close> version of \\<open>seq_sum_pull_one_elem\\<close> from \\<open>Monoid_ZF_1\\<close>: \\<close>\n",
        "assumes": "assumes \"j \\<in> nat\" \"\\<forall>k\\<in>j #+ 1. q(k) \\<in> R\"\n  ",
        "using": [
            "assms",
            "add_monoid.seq_sum_pull_one_elem"
        ],
        "statement": "lemma (in ring3) rng_seq_sum_pull_one_elem:\n  assumes \"j \\<in> nat\" \"\\<forall>k\\<in>j #+ 1. q(k) \\<in> R\"\n  shows\n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) = q(0)\\<ra>(\\<Sum>{\\<langle>k,q(k #+ 1)\\<rangle>. k\\<in>j})\"\n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) = (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j})\\<ra> q(j)\"\n  ",
        "proof": "using assms add_monoid.seq_sum_pull_one_elem by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1786
    },
    "1607": {
        "type": "theorem",
        "text": "text\\<open>Distributive laws for finite sums in a ring: \n  $(\\sum_{k=0}^{n-1}q(k))\\cdot x = \\sum_{k=0}^{n-1}q(k)\\cdot x$ and \n  $x\\cdot (\\sum_{k=0}^{n-1}q(k)) = \\sum_{k=0}^{n-1}x\\cdot q(k)$. \\<close>\n",
        "assumes": "assumes \"x\\<in>R\"  \"n\\<in>nat\" \"\\<forall>k\\<in>n. q(k) \\<in> R\" \n  ",
        "using": [
            "add_monoid.sum_empty",
            "Ring_ZF_1_L6(1)",
            "elem_nat_is_nat(2)",
            "mem_add_one_subset",
            "add_monoid.seq_sum_pull_one_elem(2)",
            "add_monoid.sum_in_mono",
            "ring_oper_distr(2)",
            "Ring_ZF_1_L4(3)",
            "Ring_ZF_1_L6(2)",
            "ring_oper_distr(1)"
        ],
        "statement": "theorem (in ring3) fin_sum_distrib: \n  assumes \"x\\<in>R\"  \"n\\<in>nat\" \"\\<forall>k\\<in>n. q(k) \\<in> R\" \n  shows \n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n})\\<cdot>x = \\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>n}\"\n    \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n}) = \\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>n}\"\n",
        "proof": "proof -\n  from assms(1,2) have \"n\\<in>nat\" and \n    \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>0})\\<cdot>x = \\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>0}\"\n    using add_monoid.sum_empty Ring_ZF_1_L6(1) by simp_all\n  moreover have \n    \"\\<forall>j\\<in>n. (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j})\\<cdot>x = (\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j})\n    \\<longrightarrow> (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1})\\<cdot>x = \\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j #+ 1}\"\n  proof -\n    { fix j assume \"j\\<in>n\" and \n        I: \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j})\\<cdot>x = (\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j})\" \n      from assms(2) \\<open>j\\<in>n\\<close> have \"j\\<in>nat\" using elem_nat_is_nat(2) \n        by simp\n      moreover from assms(2,3) \\<open>j\\<in>n\\<close> have II: \"\\<forall>k\\<in>j #+ 1. q(k) \\<in> R\"\n        using mem_add_one_subset by blast\n      ultimately have     \n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) =  (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<ra> q(j)\"\n        using add_monoid.seq_sum_pull_one_elem(2) by simp\n      hence \n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1})\\<cdot>x = ((\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<ra> q(j))\\<cdot>x\"\n        by simp\n      moreover from assms(1) \\<open>j\\<in>nat\\<close> II have\n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<in> R\" \"q(j) \\<in> R\" and \"x\\<in>R\" \n        using add_monoid.sum_in_mono by simp_all\n      ultimately have \n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1})\\<cdot>x = (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j})\\<cdot>x \\<ra> q(j)\\<cdot>x\"\n        using ring_oper_distr(2) by simp\n      with I have \n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1})\\<cdot>x = (\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j})  \\<ra> q(j)\\<cdot>x\" \n        by simp\n      moreover \n      from assms(1) II have \"\\<forall>k\\<in>j #+ 1. q(k)\\<cdot>x \\<in> R\"\n        using Ring_ZF_1_L4(3) by simp\n      with \\<open>j\\<in>nat\\<close> have \n        \"(\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j #+ 1}) = (\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j}) \\<ra> q(j)\\<cdot>x\"\n        using add_monoid.seq_sum_pull_one_elem(2) by simp\n      ultimately have \n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1})\\<cdot>x = (\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>j #+ 1})\"\n        by simp\n    } thus ?thesis by simp\n  qed\n  ultimately show \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n})\\<cdot>x = \\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<rangle>. k\\<in>n}\"\n    by (rule fin_nat_ind1)\n  from assms(1,2) have \"n\\<in>nat\" and \n    \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>0}) = \\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>0}\"\n    using add_monoid.sum_empty Ring_ZF_1_L6(2) by simp_all\n  moreover have \n    \"\\<forall>j\\<in>n. x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) = (\\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j})\n    \\<longrightarrow> x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) = \\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j #+ 1}\" \n  proof -\n    { fix j assume \"j\\<in>n\" and \n        I: \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) = (\\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j})\"\n      from assms(2) \\<open>j\\<in>n\\<close> have \"j\\<in>nat\" using elem_nat_is_nat(2) \n        by simp\n      moreover from assms(2,3) \\<open>j\\<in>n\\<close> have II: \"\\<forall>k\\<in>j #+ 1. q(k) \\<in> R\"\n        using mem_add_one_subset by blast\n      ultimately have     \n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) =  (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<ra> q(j)\"\n        using add_monoid.seq_sum_pull_one_elem(2) by simp\n      hence \n        \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) = x\\<cdot>((\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<ra> q(j))\"\n        by simp\n      moreover from assms(1) \\<open>j\\<in>nat\\<close> II have\n        \"(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<in> R\" \"q(j) \\<in> R\" and \"x\\<in>R\" \n        using add_monoid.sum_in_mono by simp_all\n       ultimately have \n        \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) = x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j}) \\<ra> x\\<cdot>q(j)\"\n        using ring_oper_distr(1) by simp\n       with I have \n        \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) =  (\\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j})  \\<ra> x\\<cdot>q(j)\" \n        by simp\n      moreover \n      from assms(1) II have \"\\<forall>k\\<in>j #+ 1. x\\<cdot>q(k) \\<in> R\"\n        using Ring_ZF_1_L4(3) by simp\n      with \\<open>j\\<in>nat\\<close> have \n        \"(\\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j #+ 1}) = (\\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j}) \\<ra> x\\<cdot>q(j)\"\n        using add_monoid.seq_sum_pull_one_elem(2) by simp\n      ultimately have \n        \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>j #+ 1}) = (\\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>j #+ 1})\"\n        by simp\n    } thus ?thesis by simp\n  qed\n  ultimately show  \"x\\<cdot>(\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n}) = \\<Sum>{\\<langle>k,x\\<cdot>q(k)\\<rangle>. k\\<in>n}\"\n    by (rule fin_nat_ind1)\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1787
    },
    "1608": {
        "type": "lemma",
        "text": "text\\<open>In rings we have \n  $\\sum_{k=0}^{n-1}q(k) + p(k) = (\\sum_{k=0}^{n-1} p(k)) + (\\sum_{k=0}^{n-1} q(k))$. \n  This is the same as theorem \\<open>sum_comm_distrib\\<close> in \\<open>Monoid_ZF_1.thy\\<close>, except that\n  we do not need the assumption about commutativity of the operation as addition in rings\n  is always commutative. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" and  \"\\<forall>k\\<in>n. p(k) \\<in> R\" \"\\<forall>k\\<in>n. q(k) \\<in> R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L1(3)",
            "add_monoid.sum_comm_distrib"
        ],
        "statement": "lemma (in ring3) sum_ring_distrib: \n  assumes \"n\\<in>nat\" and  \"\\<forall>k\\<in>n. p(k) \\<in> R\" \"\\<forall>k\\<in>n. q(k) \\<in> R\"\n  shows\n    \"(\\<Sum>{\\<langle>k,p(k)\\<ra>q(k)\\<rangle>. k\\<in>n}) = (\\<Sum>{\\<langle>k,p(k)\\<rangle>. k\\<in>n}) \\<ra> (\\<Sum>{\\<langle>k,q(k)\\<rangle>. k\\<in>n})\"\n  ",
        "proof": "using assms Ring_ZF_1_L1(3) add_monoid.sum_comm_distrib by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1788
    },
    "1609": {
        "type": "definition",
        "text": "text\\<open>To shorten the notation in the proof of the binomial theorem we give a name to the\n  binomial term ${n \\choose k} x^{n-k} y^k$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring3) BT where\n  \"BT(n,k,x,y) \\<equiv> Binom(n,k)\\<nm>pow(n #- k,x)\\<cdot>pow(k,y)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1789
    },
    "1610": {
        "type": "lemma",
        "text": "text\\<open>If $n,k$ are natural numbers and $x,y$ are ring elements then the binomial term is \n  an element of the ring. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"k\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\" \n  ",
        "using": [
            "assms",
            "mult_pow_type",
            "binom_in_nat",
            "Ring_ZF_1_L4(3)",
            "BT_def"
        ],
        "statement": "lemma (in ring3) bt_type: assumes \"n\\<in>nat\" \"k\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\" \n  shows \"BT(n,k,x,y) \\<in> R\"\n  ",
        "proof": "using assms mult_pow_type binom_in_nat Ring_ZF_1_L4(3)\n  unfolding BT_def by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1790
    },
    "1611": {
        "type": "lemma",
        "text": "text\\<open>The binomial term is $1$ when the $n=0$ and $k=0$. \n  Somehow we do not need the assumption that $x,y$ are ring elements. \\<close>\n",
        "assumes": "",
        "using": [
            "binom_zero_zero",
            "mult_pow_zero(2)",
            "add_monoid.nat_mult_one",
            "Ring_ZF_1_L2(2)",
            "Ring_ZF_1_L3(5)",
            "BT_def"
        ],
        "statement": "lemma (in ring3) bt_at_zero: shows \"BT(0,0,x,y) = \\<one>\"\n  ",
        "proof": "using binom_zero_zero mult_pow_zero(2) add_monoid.nat_mult_one \n        Ring_ZF_1_L2(2) Ring_ZF_1_L3(5)\n  unfolding BT_def by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1791
    },
    "1612": {
        "type": "lemma",
        "text": "text\\<open>The binomial term is $x^n$ when $k=0$. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\"\n  ",
        "using": [
            "assms",
            "mult_pow_zero(2)",
            "binom_left_boundary",
            "mult_pow_type(2)",
            "add_monoid.nat_mult_one",
            "Ring_ZF_1_L3(5)"
        ],
        "statement": "lemma (in ring3) bt_at_zero1: assumes \"n\\<in>nat\" \"x\\<in>R\"\n  shows \"BT(n,0,x,y) = pow(n,x)\" \n  unfolding BT_def ",
        "proof": "using assms mult_pow_zero(2) binom_left_boundary\n    mult_pow_type(2) add_monoid.nat_mult_one Ring_ZF_1_L3(5) \n    by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1792
    },
    "1613": {
        "type": "lemma",
        "text": "text\\<open>When $k=0$ multiplying the binomial term by $x$ is the same as adding one to $n$. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\"\n  ",
        "using": [
            "assms",
            "bt_at_zero1",
            "nat_mult_pow_add_one(2)"
        ],
        "statement": "lemma (in ring3) bt_at_zero2: assumes \"n\\<in>nat\" \"x\\<in>R\"\n  shows \"BT(n,0,x,y)\\<cdot>x = BT(n #+ 1,0,x,y)\"\n  ",
        "proof": "using assms bt_at_zero1 nat_mult_pow_add_one(2) by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1793
    },
    "1614": {
        "type": "lemma",
        "text": "text\\<open>When $k=n$ multiplying the binomial term by $x$ is the same as adding one to $n$. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"y\\<in>R\"\n  ",
        "using": [
            "assms",
            "bt_at_right",
            "nat_mult_pow_add_one(2)"
        ],
        "statement": "lemma (in ring3) bt_at_right1: assumes \"n\\<in>nat\" \"y\\<in>R\"\n  shows \"BT(n,n,x,y)\\<cdot>y = BT(n #+ 1,n #+ 1,x,y)\"\n  ",
        "proof": "using assms bt_at_right nat_mult_pow_add_one(2) by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1795
    },
    "1615": {
        "type": "lemma",
        "text": "text\\<open>A key identity for binomial terms needed for the proof of the binomial theorem:\\<close>\n",
        "assumes": "assumes \"M {is commutative on} R\" \"j\\<in>nat\" \"k\\<in>j\" \"x\\<in>R\" \"y\\<in>R\"\n  ",
        "using": [
            "elem_nat_is_nat(2)",
            "binom_in_nat",
            "mult_pow_type(2)",
            "Ring_ZF_1_L4(3)",
            "nat_mult_assoc1",
            "Ring_ZF_1_L11(2)",
            "nat_mult_pow_add_one(2)",
            "BT_def",
            "Ring_ZF_2_L4(2)",
            "nat_subtr_simpl0",
            "nat_add_mult_distrib",
            "binom_prop2",
            "succ_ineq1(3)",
            "nat_mult_assoc"
        ],
        "statement": "lemma (in ring3) bt_rec_identity: \n  assumes \"M {is commutative on} R\" \"j\\<in>nat\" \"k\\<in>j\" \"x\\<in>R\" \"y\\<in>R\"\n  shows \n    \"BT(j,k #+ 1,x,y)\\<cdot>x \\<ra> BT(j,k,x,y)\\<cdot>y = BT(j #+ 1,k #+ 1,x,y)\"\n",
        "proof": "proof -\n  from assms(2,3,4) have \"k\\<in>nat\" \"Binom(j,k #+ 1) \\<in> nat\" \n    and \"Binom(j,k) \\<in> nat\" \"Binom(j #+ 1,k #+ 1) \\<in> nat\" \n    and I: \"pow(j #- (k #+ 1),x) \\<in> R\" and II: \"pow(j #- k,x) \\<in> R\"\n    using elem_nat_is_nat(2) binom_in_nat mult_pow_type(2)\n    by simp_all\n  with assms(5) have III: \"pow(k #+ 1,y) \\<in> R\"\n    using mult_pow_type(2) by blast\n  let ?L = \"BT(j,k #+ 1,x,y)\\<cdot>x \\<ra> BT(j,k,x,y)\\<cdot>y\"\n  let ?p = \"pow(j #- k,x)\\<cdot>pow(k #+ 1,y)\"\n  from assms(2,4) \\<open>k\\<in>nat\\<close> II III have \"?p \\<in> R\"\n    using mult_pow_type(2) Ring_ZF_1_L4(3) by simp\n  from assms(2,3,4,5) have \"BT(j,k,x,y)\\<cdot>y = Binom(j,k)\\<nm>?p\"\n    using elem_nat_is_nat(2) binom_in_nat mult_pow_type(2) \n      nat_mult_assoc1 Ring_ZF_1_L11(2) nat_mult_pow_add_one(2)\n    unfolding BT_def by simp\n  moreover have \"BT(j,k #+ 1,x,y)\\<cdot>x = Binom(j,k #+ 1)\\<nm>?p\"\n  proof -\n    from assms(1,4) \\<open>Binom(j,k #+ 1) \\<in> nat\\<close> I III have\n      \"Binom(j,k #+ 1)\\<nm>pow(j #- (k #+ 1),x)\\<cdot>pow(k #+ 1,y)\\<cdot>x =\n        Binom(j,k #+ 1)\\<nm>(pow(j #- (k #+ 1) #+ 1,x)\\<cdot>pow(k #+ 1,y))\"\n      using nat_mult_assoc1 Ring_ZF_2_L4(2) nat_mult_pow_add_one(2)\n      by simp\n    with assms(2,3) have \n      \"Binom(j,k #+ 1)\\<nm>pow(j #- (k #+ 1),x)\\<cdot>pow(k #+ 1,y)\\<cdot>x =\n      Binom(j,k #+ 1)\\<nm>(pow(j #- (k #+ 1) #+ 1,x)\\<cdot>pow(k #+ 1,y))\"\n      using nat_subtr_simpl0 by blast\n    moreover from assms(2,3) have \n      \"pow(j #- (k #+ 1) #+ 1,x) = pow(j #- k,x)\"\n      using nat_subtr_simpl0 by simp\n    ultimately show ?thesis unfolding BT_def by simp\n  qed\n  ultimately have \"?L = Binom(j,k #+ 1)\\<nm>?p \\<ra> Binom(j,k)\\<nm>?p\"\n    by simp\n  with assms(2,3) \\<open>Binom(j,k #+ 1) \\<in> nat\\<close> \\<open>Binom(j,k) \\<in> nat\\<close> \\<open>?p \\<in> R\\<close>\n  have \"?L = Binom(j #+ 1,k #+ 1)\\<nm>?p\"\n    using nat_add_mult_distrib binom_prop2 succ_ineq1(3) by simp\n  with assms(2,3) \\<open>Binom(j #+ 1,k #+ 1) \\<in> nat\\<close> II III\n  show ?thesis using nat_mult_assoc nat_subtr_simpl0\n    unfolding BT_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1796
    },
    "1616": {
        "type": "theorem",
        "text": "text\\<open>The binomial theorem: if $x,y$ are elements of a commutative ring, $n\\in \\mathbb{N}$\n   then $(x+y)^n = \\sum_{k=0}^{n} {n \\choose k} x^{n-k} y^k$.\\<close>\n",
        "assumes": "assumes \"M {is commutative on} R\" \"n\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\"\n  ",
        "using": [
            "bt_at_zero",
            "Ring_ZF_1_L2(2)",
            "add_monoid.seq_sum_singleton",
            "mult_pow_zero(2)",
            "elem_nat_is_nat(2)",
            "bt_type",
            "Ring_ZF_1_L4(3)",
            "mult_elem_ring_type(1)",
            "Ring_ZF_1_L4(1)",
            "mult_pow_type",
            "nat_mult_pow_add_one(2)",
            "ring_oper_distr(1)",
            "rng_seq_sum_pull_one_elem(1)",
            "rng_seq_sum_pull_one_elem(2)",
            "add_monoid.sum_in_mono",
            "Ring_ZF_2_L2(3)",
            "sum_ring_distrib",
            "bt_rec_identity",
            "bt_at_zero2",
            "bt_at_right1"
        ],
        "statement": "theorem (in ring3) binomial_theorem: \n  assumes \"M {is commutative on} R\" \"n\\<in>nat\" \"x\\<in>R\" \"y\\<in>R\"\n  shows \n    \"pow(n,x\\<ra>y) = \\<Sum>{\\<langle>k,Binom(n,k)\\<nm>pow(n #- k,x) \\<cdot> pow(k,y)\\<rangle>. k\\<in>n #+ 1}\"\n",
        "proof": "proof -\n  from assms(2) have \"n\\<in>nat\" by simp\n  moreover have \"pow(0,x\\<ra>y) = \\<Sum>{\\<langle>k,BT(0,k,x,y)\\<rangle>. k\\<in>0 #+ 1}\"\n  proof -\n    from assms(3,4) have \"(\\<Sum>{\\<langle>k,BT(0,k,x,y)\\<rangle>. k\\<in>0 #+ 1}) = \\<one>\"\n      using bt_at_zero Ring_ZF_1_L2(2) add_monoid.seq_sum_singleton\n      by simp\n    then show ?thesis using mult_pow_zero(2) by simp\n  qed\n  moreover have \"\\<forall>j\\<in>nat. \n    pow(j,x\\<ra>y) = (\\<Sum>{\\<langle>k,BT(j,k,x,y)\\<rangle>. k\\<in>j #+ 1})  \\<longrightarrow> \n    pow(j #+ 1,x\\<ra>y) = (\\<Sum>{\\<langle>k,BT(j #+ 1,k,x,y)\\<rangle>. k\\<in>j #+ 1 #+ 1})\"\n  proof -\n    { fix j\n      let ?s\\<^sub>0 = \"\\<Sum>{\\<langle>k,BT(j,k,x,y)\\<rangle>. k\\<in>j #+ 1}\"\n      let ?s\\<^sub>1 = \"\\<Sum>{\\<langle>k,BT(j,k,x,y)\\<cdot>x\\<rangle>. k\\<in>j #+ 1}\"\n      let ?s\\<^sub>2 = \"\\<Sum>{\\<langle>k,BT(j,k,x,y)\\<cdot>y\\<rangle>. k\\<in>j #+ 1}\"\n      let ?s\\<^sub>3 = \"\\<Sum>{\\<langle>k,BT(j,k #+ 1,x,y)\\<cdot>x\\<rangle>. k\\<in>j}\"\n      let ?s\\<^sub>4 = \"\\<Sum>{\\<langle>k,BT(j,k,x,y)\\<cdot>y\\<rangle>. k\\<in>j}\"\n      let ?s\\<^sub>5 = \"\\<Sum>{\\<langle>k,BT(j,k #+ 1,x,y)\\<cdot>x \\<ra> BT(j,k,x,y)\\<cdot>y\\<rangle>. k\\<in>j}\"\n      let ?s\\<^sub>6 = \"\\<Sum>{\\<langle>k,BT(j #+ 1,k #+ 1,x,y)\\<rangle>. k\\<in>j}\"\n      let ?s\\<^sub>7 = \"\\<Sum>{\\<langle>k,BT(j #+ 1,k,x,y)\\<rangle>. k\\<in>j #+ 1}\"\n      let ?s\\<^sub>8 = \"\\<Sum>{\\<langle>k,BT(j #+ 1,k,x,y)\\<rangle>. k\\<in>j #+ 1 #+ 1}\"\n      assume \"j\\<in>nat\" and \"pow(j,x\\<ra>y) = ?s\\<^sub>0\"\n      then have \"j #+ 1 \\<in> nat\" and \"j #+ 1 #+ 1 \\<in> nat\" by simp_all\n      have \n        I:  \"\\<forall>k\\<in>j #+ 1. BT(j,k,x,y) \\<in> R\" and\n        II: \"\\<forall>k\\<in>j #+ 1. BT(j,k,x,y)\\<cdot>x \\<in> R\" and\n        III: \"\\<forall>k\\<in>j #+ 1. BT(j,k,x,y)\\<cdot>y \\<in> R\" and\n        IV:  \"\\<forall>k\\<in>j. BT(j,k #+ 1,x,y)\\<cdot>x \\<in> R\" and\n        V:   \"\\<forall>k\\<in>j. BT(j,k,x,y)\\<cdot>y \\<in> R\" and\n        VI:  \"\\<forall>k\\<in>j #+ 1. BT(j #+ 1,k,x,y) \\<in> R\" and\n        VII: \"\\<forall>k\\<in>j #+ 1 #+ 1. BT(j #+ 1,k,x,y) \\<in> R\"\n      proof -\n        from assms(3,4) \\<open>j\\<in>nat\\<close> show \"\\<forall>k\\<in>j #+ 1. BT(j,k,x,y) \\<in> R\"\n          using elem_nat_is_nat(2) bt_type by blast\n        with assms(3,4) \\<open>j\\<in>nat\\<close> show \n          \"\\<forall>k\\<in>j #+ 1. BT(j,k,x,y)\\<cdot>x \\<in> R\" and \n          \"\\<forall>k\\<in>j #+ 1. BT(j,k,x,y)\\<cdot>y \\<in> R\" and\n          \"\\<forall>k\\<in>j. BT(j,k,x,y)\\<cdot>y \\<in> R\"\n          using Ring_ZF_1_L4(3) by simp_all\n        from assms(3,4) \\<open>j\\<in>nat\\<close> have \"\\<forall>k\\<in>j. BT(j,k #+ 1,x,y) \\<in> R\"\n          using elem_nat_is_nat(2) bt_type by simp \n        with \\<open>j\\<in>nat\\<close> assms(3) show \"\\<forall>k\\<in>j. BT(j,k #+ 1,x,y)\\<cdot>x \\<in> R\"\n          using mult_elem_ring_type(1) by simp\n        from assms(3,4) \\<open>j #+ 1 \\<in> nat\\<close> show \n          \"\\<forall>k\\<in>j #+ 1. BT(j #+ 1,k,x,y) \\<in> R\"\n          using elem_nat_is_nat(2) bt_type by blast\n        from assms(3,4) \\<open>j #+ 1 #+ 1 \\<in> nat\\<close> show \n          \"\\<forall>k\\<in>j #+ 1 #+ 1. BT(j #+ 1,k,x,y) \\<in> R\"\n          using elem_nat_is_nat(2) bt_type by blast\n      qed\n      have \"pow(j #+ 1,x\\<ra>y) = ?s\\<^sub>0\\<cdot>x \\<ra> ?s\\<^sub>0\\<cdot>y\"\n      proof - \n        from assms(3,4) \\<open>j\\<in>nat\\<close> have \n          \"pow(j #+ 1,x\\<ra>y) = pow(j,x\\<ra>y)\\<cdot>x \\<ra> pow(j,x\\<ra>y)\\<cdot>y\"\n          using Ring_ZF_1_L4(1) mult_pow_type nat_mult_pow_add_one(2) \n            ring_oper_distr(1) by simp\n        with \\<open>pow(j,x\\<ra>y) = ?s\\<^sub>0\\<close> show  ?thesis by simp\n      qed\n      also have \"?s\\<^sub>0\\<cdot>x \\<ra> ?s\\<^sub>0\\<cdot>y = ?s\\<^sub>1 \\<ra> ?s\\<^sub>2\"\n      proof -\n        from assms(3) \\<open>j #+ 1 \\<in> nat\\<close> I have \"?s\\<^sub>0\\<cdot>x = ?s\\<^sub>1\" \n          by (rule fin_sum_distrib)\n        moreover from assms(4) \\<open>j #+ 1 \\<in> nat\\<close> I\n        have \"?s\\<^sub>0\\<cdot>y = ?s\\<^sub>2\" by (rule fin_sum_distrib)\n        ultimately show ?thesis by simp\n      qed\n      also have \"?s\\<^sub>1 \\<ra> ?s\\<^sub>2 = \n        (BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>3) \\<ra> (?s\\<^sub>4 \\<ra> BT(j,j,x,y)\\<cdot>y)\"\n      proof -\n        from \\<open>j\\<in>nat\\<close> II have \"?s\\<^sub>1 = BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>3\"\n          using rng_seq_sum_pull_one_elem(1) by simp\n        moreover from \\<open>j\\<in>nat\\<close> III have \"?s\\<^sub>2 = ?s\\<^sub>4 \\<ra> BT(j,j,x,y)\\<cdot>y\"\n          using rng_seq_sum_pull_one_elem(2) by simp\n        ultimately show ?thesis by simp\n      qed\n      also from assms(3,4) IV V \\<open>j\\<in>nat\\<close> have\n        \"(BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>3) \\<ra> (?s\\<^sub>4 \\<ra> BT(j,j,x,y)\\<cdot>y) =\n        BT(j,0,x,y)\\<cdot>x \\<ra> (?s\\<^sub>3 \\<ra> ?s\\<^sub>4) \\<ra> BT(j,j,x,y)\\<cdot>y\"\n        using bt_type Ring_ZF_1_L4(3) add_monoid.sum_in_mono Ring_ZF_2_L2(3)\n        by simp\n      also have \"BT(j,0,x,y)\\<cdot>x \\<ra> (?s\\<^sub>3 \\<ra> ?s\\<^sub>4) \\<ra> BT(j,j,x,y)\\<cdot>y = \n        BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>5 \\<ra> BT(j,j,x,y)\\<cdot>y\"\n      proof -\n        from \\<open>j\\<in>nat\\<close> IV V have \"?s\\<^sub>3 \\<ra> ?s\\<^sub>4 = ?s\\<^sub>5\"\n          using sum_ring_distrib by simp\n        thus ?thesis by simp\n      qed\n      also from assms(1,3,4) \\<open>j\\<in>nat\\<close> have \n        \"BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>5 \\<ra> BT(j,j,x,y)\\<cdot>y =\n        BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>6 \\<ra> BT(j,j,x,y)\\<cdot>y\"\n        using bt_rec_identity by simp\n      also have \"BT(j,0,x,y)\\<cdot>x \\<ra> ?s\\<^sub>6 \\<ra> BT(j,j,x,y)\\<cdot>y =\n        ?s\\<^sub>7 \\<ra> BT(j,j,x,y)\\<cdot>y\"\n      proof -\n        from \\<open>j\\<in>nat\\<close> VI have \"?s\\<^sub>7 = BT(j #+ 1,0,x,y) \\<ra> ?s\\<^sub>6\"\n          by (rule rng_seq_sum_pull_one_elem)\n        with assms(3) \\<open>j\\<in>nat\\<close> show ?thesis\n          using bt_at_zero2 by simp\n      qed\n      also have \"?s\\<^sub>7 \\<ra> BT(j,j,x,y)\\<cdot>y = ?s\\<^sub>8\"\n      proof -\n        from \\<open>j #+ 1 \\<in> nat\\<close> VII have \n          \"?s\\<^sub>8 = ?s\\<^sub>7 \\<ra> BT(j #+ 1,j #+ 1,x,y)\"\n          by (rule rng_seq_sum_pull_one_elem)\n        with assms(4) \\<open>j\\<in>nat\\<close> show ?thesis \n          using bt_at_right1 by simp\n      qed\n      finally have \"pow(j #+ 1,x\\<ra>y) =  ?s\\<^sub>8\" by simp\n    } thus ?thesis by simp\n  qed\n  ultimately have \"pow(n,x\\<ra>y) = \\<Sum>{\\<langle>k,BT(n,k,x,y)\\<rangle>. k\\<in>n #+ 1}\" \n    by (rule ind_on_nat1)\n  then show ?thesis unfolding BT_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1797
    },
    "1617": {
        "type": "definition",
        "text": "text\\<open>We also define the notion of having no zero divisors. In\n  standard notation the ring has no zero divisors if for all $a,b \\in R$ we have \n  $a\\cdot b = 0$ implies $a = 0$ or $b = 0$.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HasNoZeroDivs(R,A,M) \\<equiv> (\\<forall>a\\<in>R. \\<forall>b\\<in>R. \n  M`\\<langle> a,b\\<rangle> = TheNeutralElement(R,A) \\<longrightarrow>\n  a = TheNeutralElement(R,A) \\<or> b = TheNeutralElement(R,A))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1799
    },
    "1618": {
        "type": "lemma",
        "text": "text\\<open>In the \\<open>ring0\\<close> context we can use theorems proven in some \n  other contexts.\\<close>\n",
        "assumes": "",
        "using": [
            "ringAssum",
            "IsAring_def",
            "group0_def",
            "monoid0_def"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L1: shows \n  \"monoid0(R,M)\"\n  \"group0(R,A)\" \n  \"A {is commutative on} R\"\n  ",
        "proof": "using ringAssum IsAring_def group0_def monoid0_def by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1800
    },
    "1619": {
        "type": "lemma",
        "text": "text\\<open>The additive operation in a ring is distributive with respect to the\n  multiplicative operation.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [
            "ringAssum",
            "assms",
            "IsAring_def",
            "IsDistributive_def"
        ],
        "statement": "lemma (in ring0) ring_oper_distr: assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \n  \"a\\<cdot>(b\\<ra>c) = a\\<cdot>b \\<ra> a\\<cdot>c\" \n  \"(b\\<ra>c)\\<cdot>a = b\\<cdot>a \\<ra> c\\<cdot>a\"\n  ",
        "proof": "using ringAssum assms IsAring_def IsDistributive_def by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1801
    },
    "1620": {
        "type": "lemma",
        "text": "text\\<open>Zero and one of the ring are elements of the ring. The negative of zero\n  is zero.\\<close>\n",
        "assumes": "",
        "using": [
            "add_group.group0_2_L2",
            "mult_monoid.unit_is_neutral",
            "add_group.group_inv_of_one"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L2: \n  shows \"\\<zero>\\<in>R\"  \"\\<one>\\<in>R\"   \"(\\<rm>\\<zero>) = \\<zero>\"\n  ",
        "proof": "using add_group.group0_2_L2 mult_monoid.unit_is_neutral \n    add_group.group_inv_of_one by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1802
    },
    "1621": {
        "type": "lemma",
        "text": "text\\<open>The next lemma lists some properties of a ring that require one element\n  of a ring.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"\n  ",
        "using": [
            "assms",
            "add_group.inverse_in_group",
            "add_group.group_inv_of_inv",
            "add_group.group0_2_L6",
            "add_group.group0_2_L2",
            "mult_monoid.unit_is_neutral",
            "Ring_ZF_1_L2",
            "ring_oper_distr"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L3: assumes \"a\\<in>R\"\n  shows \n  \"(\\<rm>a) \\<in> R\"\n  \"(\\<rm>(\\<rm>a)) = a\"\n  \"a\\<ra>\\<zero> = a\" \n  \"\\<zero>\\<ra>a = a\" \n  \"a\\<cdot>\\<one> = a\" \n  \"\\<one>\\<cdot>a = a\" \n  \"a\\<rs>a = \\<zero>\" \n  \"a\\<rs>\\<zero> = a\"\n  \"\\<two>\\<cdot>a = a\\<ra>a\"\n  \"(\\<rm>a)\\<ra>a = \\<zero>\"\n  ",
        "proof": "using assms add_group.inverse_in_group add_group.group_inv_of_inv \n    add_group.group0_2_L6 add_group.group0_2_L2 mult_monoid.unit_is_neutral \n    Ring_ZF_1_L2 ring_oper_distr\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1803
    },
    "1622": {
        "type": "lemma",
        "text": "text\\<open>Properties that require two elements of a ring.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\" \"b\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L1(3)",
            "Ring_ZF_1_L3",
            "add_group.monoid.group0_1_L1",
            "mult_monoid.group0_1_L1",
            "IsCommutative_def"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L4: assumes A1: \"a\\<in>R\" \"b\\<in>R\"\n  shows \n  \"a\\<ra>b \\<in> R\" \n  \"a\\<rs>b \\<in> R\" \n  \"a\\<cdot>b \\<in> R\" \n  \"a\\<ra>b = b\\<ra>a\"\n  ",
        "proof": "using assms Ring_ZF_1_L1(3) Ring_ZF_1_L3 \n    add_group.monoid.group0_1_L1 \n    mult_monoid.group0_1_L1\n    unfolding IsCommutative_def\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1804
    },
    "1623": {
        "type": "lemma",
        "text": "text\\<open>Cancellation of an element on both sides of equality. \n  This is a property of groups, written in the (additive) notation\n  we use for the additive operation in rings.\n\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\" \"b\\<in>R\" and A2: \"a \\<ra> b = a\"\n  ",
        "using": [
            "assms",
            "add_group.group0_2_L7"
        ],
        "statement": "lemma (in ring0) ring_cancel_add: \n  assumes A1: \"a\\<in>R\" \"b\\<in>R\" and A2: \"a \\<ra> b = a\"\n  shows \"b = \\<zero>\"\n  ",
        "proof": "using assms add_group.group0_2_L7 by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1805
    },
    "1624": {
        "type": "lemma",
        "text": "text\\<open>Any element of a ring multiplied by zero is zero.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>R\" ",
        "using": [
            "Ring_ZF_1_L2",
            "ring_oper_distr",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L4",
            "ring_cancel_add"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L6: \n  assumes A1: \"x\\<in>R\" shows \"\\<zero>\\<cdot>x = \\<zero>\"   \"x\\<cdot>\\<zero> = \\<zero>\"\n",
        "proof": "proof -\n  let ?a = \"x\\<cdot>\\<one>\"\n  let ?b = \"x\\<cdot>\\<zero>\"\n  let ?c = \"\\<one>\\<cdot>x\"\n  let ?d = \"\\<zero>\\<cdot>x\"\n  from A1 have \n    \"?a \\<ra> ?b = x\\<cdot>(\\<one> \\<ra> \\<zero>)\"   \"?c \\<ra> ?d = (\\<one> \\<ra> \\<zero>)\\<cdot>x\"\n    using Ring_ZF_1_L2 ring_oper_distr by auto\n  moreover have \"x\\<cdot>(\\<one> \\<ra> \\<zero>) = ?a\" \"(\\<one> \\<ra> \\<zero>)\\<cdot>x = ?c\"\n    using Ring_ZF_1_L2 Ring_ZF_1_L3 by auto\n  ultimately have \"?a \\<ra> ?b = ?a\" and T1: \"?c \\<ra> ?d = ?c\" \n    by auto\n  moreover from A1 have \n    \"?a \\<in> R\"  \"?b \\<in> R\" and T2: \"?c \\<in> R\"  \"?d \\<in> R\"\n    using Ring_ZF_1_L2 Ring_ZF_1_L4 by auto\n  ultimately have \"?b = \\<zero>\" using ring_cancel_add\n    by blast\n  moreover from T2 T1 have \"?d = \\<zero>\" using ring_cancel_add\n    by blast\n  ultimately show \"x\\<cdot>\\<zero> = \\<zero>\"  \"\\<zero>\\<cdot>x = \\<zero>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1806
    },
    "1625": {
        "type": "lemma",
        "text": "text\\<open>Negative can be pulled out of a product.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"\n  ",
        "using": [
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L4",
            "ring_oper_distr",
            "add_group.group0_2_L6",
            "Ring_ZF_1_L6",
            "add_group.group0_2_L9"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L7: \n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\"\n  shows \n  \"(\\<rm>a)\\<cdot>b = \\<rm>(a\\<cdot>b)\" \n  \"a\\<cdot>(\\<rm>b) = \\<rm>(a\\<cdot>b)\"\n  \"(\\<rm>a)\\<cdot>b = a\\<cdot>(\\<rm>b)\"\n",
        "proof": "proof -\n  from A1 have I: \n    \"a\\<cdot>b \\<in> R\" \"(\\<rm>a) \\<in> R\" \"((\\<rm>a)\\<cdot>b) \\<in> R\" \n    \"(\\<rm>b) \\<in> R\" \"a\\<cdot>(\\<rm>b) \\<in> R\"\n    using Ring_ZF_1_L3 Ring_ZF_1_L4 by auto\n  moreover have \"(\\<rm>a)\\<cdot>b \\<ra> a\\<cdot>b = \\<zero>\" \n    and II: \"a\\<cdot>(\\<rm>b) \\<ra> a\\<cdot>b = \\<zero>\"\n  proof -\n    from A1 I have \n      \"(\\<rm>a)\\<cdot>b \\<ra> a\\<cdot>b = ((\\<rm>a)\\<ra> a)\\<cdot>b\"\n      \"a\\<cdot>(\\<rm>b) \\<ra> a\\<cdot>b= a\\<cdot>((\\<rm>b)\\<ra>b)\"\n      using ring_oper_distr by auto\n    moreover from A1 have \n      \"((\\<rm>a)\\<ra> a)\\<cdot>b = \\<zero>\" \n      \"a\\<cdot>((\\<rm>b)\\<ra>b) = \\<zero>\"\n      using add_group.group0_2_L6 Ring_ZF_1_L6\n      by auto\n    ultimately show \n      \"(\\<rm>a)\\<cdot>b \\<ra> a\\<cdot>b = \\<zero>\" \n      \"a\\<cdot>(\\<rm>b) \\<ra> a\\<cdot>b = \\<zero>\" \n      by auto\n  qed\n  ultimately show \"(\\<rm>a)\\<cdot>b = \\<rm>(a\\<cdot>b)\"\n    using add_group.group0_2_L9 by simp\n  moreover from I II show \"a\\<cdot>(\\<rm>b) = \\<rm>(a\\<cdot>b)\"\n    using add_group.group0_2_L9 by simp   \n  ultimately show \"(\\<rm>a)\\<cdot>b = a\\<cdot>(\\<rm>b)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1807
    },
    "1626": {
        "type": "lemma",
        "text": "text\\<open>Minus times minus is plus.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L7",
            "Ring_ZF_1_L4"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L7A: assumes \"a\\<in>R\"  \"b\\<in>R\"\n  shows \"(\\<rm>a)\\<cdot>(\\<rm>b) = a\\<cdot>b\"\n  ",
        "proof": "using assms Ring_ZF_1_L3 Ring_ZF_1_L7 Ring_ZF_1_L4\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1808
    },
    "1627": {
        "type": "lemma",
        "text": "text\\<open>Subtraction is distributive with respect to multiplication.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L3",
            "ring_oper_distr",
            "Ring_ZF_1_L7",
            "Ring_ZF_1_L4"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L8: assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \n  \"a\\<cdot>(b\\<rs>c) = a\\<cdot>b \\<rs> a\\<cdot>c\"  \n  \"(b\\<rs>c)\\<cdot>a = b\\<cdot>a \\<rs> c\\<cdot>a\"\n  ",
        "proof": "using assms Ring_ZF_1_L3 ring_oper_distr Ring_ZF_1_L7 Ring_ZF_1_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1809
    },
    "1628": {
        "type": "lemma",
        "text": "text\\<open>Other basic properties involving two elements of a ring.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L1(3)",
            "add_group.group0_4_L4",
            "add_group.group_inv_of_inv"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L9: assumes \"a\\<in>R\"  \"b\\<in>R\"\n  shows \n  \"(\\<rm>b)\\<rs>a = (\\<rm>a)\\<rs>b\" \n  \"(\\<rm>(a\\<ra>b)) = (\\<rm>a)\\<rs>b\"  \n  \"(\\<rm>(a\\<rs>b)) = ((\\<rm>a)\\<ra>b)\"\n  \"a\\<rs>(\\<rm>b) = a\\<ra>b\"\n  ",
        "proof": "using assms Ring_ZF_1_L1(3) add_group.group0_4_L4 add_group.group_inv_of_inv\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1810
    },
    "1629": {
        "type": "lemma",
        "text": "text\\<open>If the difference of two element is zero, then those elements\n  are equal.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\" and A2: \"a\\<rs>b = \\<zero>\"\n  ",
        "using": [
            "add_group.group0_2_L11A",
            "assms"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L9A: \n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\" and A2: \"a\\<rs>b = \\<zero>\"\n  shows \"a=b\" ",
        "proof": "using add_group.group0_2_L11A assms by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1811
    },
    "1630": {
        "type": "lemma",
        "text": "text\\<open>Other basic properties involving three elements of a ring.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [],
        "statement": "lemma (in ring0) Ring_ZF_1_L10: \n  assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \n  \"a\\<ra>(b\\<ra>c) = a\\<ra>b\\<ra>c\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1812
    },
    "1631": {
        "type": "lemma",
        "text": "text\\<open>Another property with three elements.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L10"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L10A: \n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \"a\\<ra>(b\\<rs>c) = a\\<ra>b\\<rs>c\"\n  ",
        "proof": "using assms Ring_ZF_1_L3 Ring_ZF_1_L10 by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1813
    },
    "1632": {
        "type": "lemma",
        "text": "text\\<open>Associativity of addition and multiplication.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [
            "assms",
            "add_group.group_oper_assoc",
            "mult_monoid.sum_associative"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L11: \n  assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \n  \"a\\<ra>b\\<ra>c = a\\<ra>(b\\<ra>c)\"\n  \"a\\<cdot>b\\<cdot>c = a\\<cdot>(b\\<cdot>c)\"\n  ",
        "proof": "using assms add_group.group_oper_assoc mult_monoid.sum_associative\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1814
    },
    "1633": {
        "type": "lemma",
        "text": "text\\<open>An interpretation of what it means that a ring has \n  no zero divisors.\\<close>\n",
        "assumes": "assumes \"HasNoZeroDivs(R,A,M)\"\n  and \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"  \"b\\<in>R\"  \"b\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "HasNoZeroDivs_def"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L12: \n  assumes \"HasNoZeroDivs(R,A,M)\"\n  and \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"  \"b\\<in>R\"  \"b\\<noteq>\\<zero>\"\n  shows \"a\\<cdot>b\\<noteq>\\<zero>\" \n  ",
        "proof": "using assms HasNoZeroDivs_def by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1815
    },
    "1634": {
        "type": "lemma",
        "text": "text\\<open>In rings with no zero divisors we can cancel nonzero factors.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  and A3: \"a\\<cdot>c = b\\<cdot>c\" and A4: \"c\\<noteq>\\<zero>\" \n  ",
        "using": [
            "Ring_ZF_1_L4",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L8",
            "HasNoZeroDivs_def"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L12A: \n  assumes A1: \"HasNoZeroDivs(R,A,M)\" and A2: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  and A3: \"a\\<cdot>c = b\\<cdot>c\" and A4: \"c\\<noteq>\\<zero>\" \n  shows \"a=b\"\n",
        "proof": "proof -\n  from A2 have T: \"a\\<cdot>c \\<in> R\"  \"a\\<rs>b \\<in> R\"\n    using Ring_ZF_1_L4 by auto\n  with A1 A2 A3 have \"a\\<rs>b = \\<zero> \\<or> c=\\<zero>\"\n    using Ring_ZF_1_L3 Ring_ZF_1_L8 HasNoZeroDivs_def\n    by simp\n  with A2 A4 have \"a\\<in>R\"  \"b\\<in>R\"  \"a\\<rs>b = \\<zero>\" \n    by auto\n  then show \"a=b\" by (rule Ring_ZF_1_L9A)\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1816
    },
    "1635": {
        "type": "lemma",
        "text": "text\\<open>In rings with no zero divisors if two elements are different, \n  then after multiplying by a nonzero element they are still different.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\"  \n  \"a\\<in>R\"   \"b\\<in>R\"   \"c\\<in>R\"   \"a\\<noteq>b\"   \"c\\<noteq>\\<zero>\" \n  ",
        "using": [
            "A1",
            "Ring_ZF_1_L12A"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L12B: \n  assumes A1: \"HasNoZeroDivs(R,A,M)\"  \n  \"a\\<in>R\"   \"b\\<in>R\"   \"c\\<in>R\"   \"a\\<noteq>b\"   \"c\\<noteq>\\<zero>\" \n  shows  \"a\\<cdot>c \\<noteq> b\\<cdot>c\"\n  ",
        "proof": "using A1 Ring_ZF_1_L12A by auto \n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1817
    },
    "1636": {
        "type": "lemma",
        "text": "text\\<open>In rings with no zero divisors multiplying a nonzero element \n  by a nonone element changes the value.\\<close>\n",
        "assumes": "assumes A1: \"HasNoZeroDivs(R,A,M)\" and \n  A2: \"a\\<in>R\"  \"b\\<in>R\" and A3: \"\\<zero>\\<noteq>a\"  \"\\<one>\\<noteq>b\"\n  ",
        "using": [
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L8",
            "Ring_ZF_1_L4",
            "HasNoZeroDivs_def",
            "Ring_ZF_1_L9A"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L12C:\n  assumes A1: \"HasNoZeroDivs(R,A,M)\" and \n  A2: \"a\\<in>R\"  \"b\\<in>R\" and A3: \"\\<zero>\\<noteq>a\"  \"\\<one>\\<noteq>b\"\n  shows \"a \\<noteq> a\\<cdot>b\"\n",
        "proof": "proof -\n  { assume \"a = a\\<cdot>b\"\n    with A1 A2 have \"a = \\<zero> \\<or> b\\<rs>\\<one> = \\<zero>\"\n      using Ring_ZF_1_L3 Ring_ZF_1_L2 Ring_ZF_1_L8 \n\tRing_ZF_1_L3 Ring_ZF_1_L2 Ring_ZF_1_L4 HasNoZeroDivs_def\n      by simp\n    with A2 A3 have False\n      using Ring_ZF_1_L2 Ring_ZF_1_L9A by auto\n  } then show \"a \\<noteq> a\\<cdot>b\" by auto\nqed      \n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1818
    },
    "1637": {
        "type": "lemma",
        "text": "text\\<open>If a square is nonzero, then the element is nonzero.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  and \"a\\<^sup>2 \\<noteq> \\<zero>\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L6"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L13:\n  assumes \"a\\<in>R\"  and \"a\\<^sup>2 \\<noteq> \\<zero>\"\n  shows \"a\\<noteq>\\<zero>\"\n  ",
        "proof": "using assms Ring_ZF_1_L2 Ring_ZF_1_L6 by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1819
    },
    "1638": {
        "type": "lemma",
        "text": "text\\<open>Square of an element and its opposite are the same.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\" ",
        "using": [
            "assms",
            "Ring_ZF_1_L7A"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L14:\n  assumes \"a\\<in>R\" shows \"(\\<rm>a)\\<^sup>2 = ((a)\\<^sup>2)\"\n  ",
        "proof": "using assms Ring_ZF_1_L7A by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1820
    },
    "1639": {
        "type": "lemma",
        "text": "text\\<open>Adding zero to a set that is closed under addition results\n  in a set that is also closed under addition. This is a property of groups.\\<close>\n",
        "assumes": "assumes \"H \\<subseteq> R\" and \"H {is closed under} A\"\n  ",
        "using": [
            "assms",
            "add_group.group0_2_L17"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L15: \n  assumes \"H \\<subseteq> R\" and \"H {is closed under} A\"\n  shows \"(H \\<union> {\\<zero>}) {is closed under} A\"\n  ",
        "proof": "using assms add_group.group0_2_L17 by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1821
    },
    "1640": {
        "type": "lemma",
        "text": "text\\<open>Adding zero to a set that is closed under multiplication results\n  in a set that is also closed under multiplication.\\<close>\n",
        "assumes": "assumes A1: \"H \\<subseteq> R\" and A2: \"H {is closed under} M\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L6",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L16:\n  assumes A1: \"H \\<subseteq> R\" and A2: \"H {is closed under} M\"\n  shows \"(H \\<union> {\\<zero>}) {is closed under} M\"\n  ",
        "proof": "using assms Ring_ZF_1_L2 Ring_ZF_1_L6 IsOpClosed_def\n  by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1822
    },
    "1641": {
        "type": "lemma",
        "text": "text\\<open>The ring is trivial iff $0=1$.\\<close>\n",
        "assumes": "",
        "using": [
            "Ring_ZF_1_L2",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L6"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L17: shows \"R = {\\<zero>} \\<longleftrightarrow> \\<zero>=\\<one>\"\n",
        "proof": "proof\n  assume \"R = {\\<zero>}\"\n  then show \"\\<zero>=\\<one>\" using Ring_ZF_1_L2\n    by blast\nnext assume A1: \"\\<zero> = \\<one>\"\n  then have \"R \\<subseteq> {\\<zero>}\"\n    using Ring_ZF_1_L3 Ring_ZF_1_L6 by auto\n  moreover have \"{\\<zero>} \\<subseteq> R\" using Ring_ZF_1_L2 by auto\n  ultimately show \"R = {\\<zero>}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1823
    },
    "1642": {
        "type": "lemma",
        "text": "text\\<open>The sets $\\{m\\cdot x. x\\in R\\}$ and  $\\{-m\\cdot x. x\\in R\\}$\n  are the same.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>R\"\n  ",
        "using": [
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L7A",
            "Ring_ZF_1_L7"
        ],
        "statement": "lemma (in ring0) Ring_ZF_1_L18: assumes A1: \"m\\<in>R\"\n  shows \"{m\\<cdot>x. x\\<in>R} = {(\\<rm>m)\\<cdot>x. x\\<in>R}\"\n",
        "proof": "proof\n  { fix a assume \"a \\<in> {m\\<cdot>x. x\\<in>R}\"\n    then obtain x where \"x\\<in>R\" and \"a = m\\<cdot>x\"\n      by auto\n    with A1 have \"(\\<rm>x) \\<in> R\"  and \"a = (\\<rm>m)\\<cdot>(\\<rm>x)\" \n      using Ring_ZF_1_L3 Ring_ZF_1_L7A by auto\n    then have \"a \\<in> {(\\<rm>m)\\<cdot>x. x\\<in>R}\"\n      by auto\n  } then show \"{m\\<cdot>x. x\\<in>R} \\<subseteq> {(\\<rm>m)\\<cdot>x. x\\<in>R}\"\n    by auto\nnext \n  { fix a assume \"a \\<in> {(\\<rm>m)\\<cdot>x. x\\<in>R}\"\n    then obtain x where \"x\\<in>R\" and \"a = (\\<rm>m)\\<cdot>x\"\n      by auto\n    with A1 have \"(\\<rm>x) \\<in> R\" and \"a = m\\<cdot>(\\<rm>x)\"\n      using Ring_ZF_1_L3 Ring_ZF_1_L7 by auto\n    then have \"a \\<in> {m\\<cdot>x. x\\<in>R}\" by auto\n  } then show \"{(\\<rm>m)\\<cdot>x. x\\<in>R} \\<subseteq> {m\\<cdot>x. x\\<in>R}\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1824
    },
    "1643": {
        "type": "lemma",
        "text": "text\\<open>Rearrangements with two elements and cancelling.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\" \"b\\<in>R\" \n  ",
        "using": [
            "assms",
            "add_group.inv_cancel_two",
            "add_group.group0_4_L6A",
            "Ring_ZF_1_L1(3)"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L1A: assumes \"a\\<in>R\" \"b\\<in>R\" \n  shows\n  \"a\\<rs>b\\<ra>b = a\"\n  \"a\\<ra>b\\<rs>a = b\"\n  \"(\\<rm>a)\\<ra>b\\<ra>a = b\"\n  \"(\\<rm>a)\\<ra>(b\\<ra>a) = b\"\n  \"a\\<ra>(b\\<rs>a) = b\"\n  ",
        "proof": "using assms add_group.inv_cancel_two add_group.group0_4_L6A\n    Ring_ZF_1_L1(3) by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1826
    },
    "1644": {
        "type": "lemma",
        "text": "text\\<open>In rings $a-(b+1)c = (a-d-c)+(d-bc)$ and $a+b+(c+d) = a+(b+c)+d$.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"\n  ",
        "using": [
            "Ring_ZF_1_L4",
            "Ring_ZF_1_L2",
            "ring_oper_distr",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L4(1)",
            "Ring_ZF_1_L10(1)"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L2: \n  assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"\n  shows \n    \"a\\<rs>(b\\<ra>\\<one>)\\<cdot>c = (a\\<rs>d\\<rs>c)\\<ra>(d\\<rs>b\\<cdot>c)\"\n    \"a\\<ra>b\\<ra>(c\\<ra>d) = a\\<ra>b\\<ra>c\\<ra>d\"\n    \"a\\<ra>b\\<ra>(c\\<ra>d) = a\\<ra>(b\\<ra>c)\\<ra>d\"\n",
        "proof": "proof -    \n  let ?B = \"b\\<cdot>c\"\n  from ringAssum assms have\n    \"A {is commutative on} R\" and \"a\\<in>R\" \"?B \\<in> R\" \"c\\<in>R\" \"d\\<in>R\"\n    unfolding IsAring_def using Ring_ZF_1_L4 by auto \n  then have \n    \"a\\<ra>(\\<rm>?B\\<ra>c) = a\\<ra>(\\<rm>d)\\<ra>(\\<rm>c)\\<ra>(d\\<ra>(\\<rm>?B))\"\n    by (rule add_group.group0_4_L8)\n  with assms show \"a\\<rs>(b\\<ra>\\<one>)\\<cdot>c = (a\\<rs>d\\<rs>c)\\<ra>(d\\<rs>b\\<cdot>c)\"\n    using Ring_ZF_1_L2 ring_oper_distr Ring_ZF_1_L3 by simp\n  from assms show \"a\\<ra>b\\<ra>(c\\<ra>d) = a\\<ra>b\\<ra>c\\<ra>d\"\n    using Ring_ZF_1_L4(1) Ring_ZF_1_L10(1) by simp\n  with assms(1,2,3) show \"a\\<ra>b\\<ra>(c\\<ra>d) = a\\<ra>(b\\<ra>c)\\<ra>d\"\n    using Ring_ZF_1_L10(1) by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1827
    },
    "1645": {
        "type": "lemma",
        "text": "text\\<open>Rerrangement about adding linear functions.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"  \"x\\<in>R\"\n  ",
        "using": [
            "Ring_ZF_1_L1",
            "Ring_ZF_1_L4",
            "add_group.group0_4_L8(3)",
            "ring_oper_distr"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L3: \n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"  \"x\\<in>R\"\n  shows \"(a\\<cdot>x \\<ra> b) \\<ra> (c\\<cdot>x \\<ra> d) = (a\\<ra>c)\\<cdot>x \\<ra> (b\\<ra>d)\"\n",
        "proof": "proof -\n  from A1 have\n    \"A {is commutative on} R\"\n    \"a\\<cdot>x \\<in> R\"  \"b\\<in>R\"  \"c\\<cdot>x \\<in> R\"  \"d\\<in>R\" \n    using Ring_ZF_1_L1 Ring_ZF_1_L4 by auto\n  then have \"A`\\<langle>A`\\<langle> a\\<cdot>x,b\\<rangle>,A`\\<langle> c\\<cdot>x,d\\<rangle>\\<rangle> = A`\\<langle>A`\\<langle> a\\<cdot>x,c\\<cdot>x\\<rangle>,A`\\<langle> b,d\\<rangle>\\<rangle>\"\n    using add_group.group0_4_L8(3) by auto\n  with A1 show \n    \"(a\\<cdot>x \\<ra> b) \\<ra> (c\\<cdot>x \\<ra> d) = (a\\<ra>c)\\<cdot>x \\<ra> (b\\<ra>d)\"\n    using ring_oper_distr by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1828
    },
    "1646": {
        "type": "lemma",
        "text": "text\\<open>Rearrangement with three elements\\<close>\n",
        "assumes": "assumes \"M {is commutative on} R\"\n  and \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [
            "assms",
            "IsCommutative_def",
            "Ring_ZF_1_L11"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L4: \n  assumes \"M {is commutative on} R\"\n  and \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \"a\\<cdot>(b\\<cdot>c) = a\\<cdot>c\\<cdot>b\" and \"a\\<cdot>b\\<cdot>c = a\\<cdot>c\\<cdot>b\"\n  ",
        "proof": "using assms IsCommutative_def Ring_ZF_1_L11\n  by simp_all\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1829
    },
    "1647": {
        "type": "lemma",
        "text": "text\\<open>Some other rearrangements with three elements.\\<close>\n",
        "assumes": "assumes A1: \"M {is commutative on} R\" and \n  A2: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  ",
        "using": [
            "Ring_ZF_1_L4",
            "Ring_ZF_1_L7",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L11",
            "ring_oper_distr",
            "IsCommutative_def"
        ],
        "statement": "lemma (in ring0) ring_rearr_3_elemA:\n  assumes A1: \"M {is commutative on} R\" and \n  A2: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"\n  shows \n  \"a\\<cdot>(a\\<cdot>c) \\<rs> b\\<cdot>(\\<rm>b\\<cdot>c) = (a\\<cdot>a \\<ra> b\\<cdot>b)\\<cdot>c\"\n  \"a\\<cdot>(\\<rm>b\\<cdot>c) \\<ra> b\\<cdot>(a\\<cdot>c) = \\<zero>\"\n",
        "proof": "proof -\n  from A2 have T: \n    \"b\\<cdot>c \\<in> R\"  \"a\\<cdot>a \\<in> R\"  \"b\\<cdot>b \\<in> R\"\n    \"b\\<cdot>(b\\<cdot>c) \\<in> R\"  \"a\\<cdot>(b\\<cdot>c) \\<in> R\"\n    using  Ring_ZF_1_L4 by auto\n  with A2 show \n    \"a\\<cdot>(a\\<cdot>c) \\<rs> b\\<cdot>(\\<rm>b\\<cdot>c) = (a\\<cdot>a \\<ra> b\\<cdot>b)\\<cdot>c\"\n    using Ring_ZF_1_L7 Ring_ZF_1_L3 Ring_ZF_1_L11 \n      ring_oper_distr by simp\n  from A2 T have \n    \"a\\<cdot>(\\<rm>b\\<cdot>c) \\<ra> b\\<cdot>(a\\<cdot>c) = (\\<rm>a\\<cdot>(b\\<cdot>c)) \\<ra> b\\<cdot>a\\<cdot>c\"\n    using Ring_ZF_1_L7 Ring_ZF_1_L11 by simp\n  also from A1 A2 T have \"\\<dots> = \\<zero>\"\n    using IsCommutative_def Ring_ZF_1_L11 Ring_ZF_1_L3\n    by simp\n  finally show \"a\\<cdot>(\\<rm>b\\<cdot>c) \\<ra> b\\<cdot>(a\\<cdot>c) = \\<zero>\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1830
    },
    "1648": {
        "type": "lemma",
        "text": "text\\<open>Some rearrangements with four elements. Properties of abelian groups.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L1(3)",
            "add_group.rearr_ab_gr_4_elemB",
            "add_group.rearr_ab_gr_4_elemA"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L5: \n  assumes \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"\n  shows \n  \"a \\<rs> b \\<rs> c \\<rs> d = a \\<rs> d \\<rs> b \\<rs> c\"\n  \"a \\<ra> b \\<ra> c \\<rs> d = a \\<rs> d \\<ra> b \\<ra> c\"\n  \"a \\<ra> b \\<rs> c \\<rs> d = a \\<rs> c \\<ra> (b \\<rs> d)\"\n  \"a \\<ra> b \\<ra> c \\<ra> d = a \\<ra> c \\<ra> (b \\<ra> d)\"\n  ",
        "proof": "using assms Ring_ZF_1_L1(3) add_group.rearr_ab_gr_4_elemB\n    add_group.rearr_ab_gr_4_elemA by auto\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1831
    },
    "1649": {
        "type": "lemma",
        "text": "text\\<open>Two big rearranegements with six elements, useful for\n  proving properties of complex addition and multiplication.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"  \"e\\<in>R\"  \"f\\<in>R\"\n  ",
        "using": [
            "Ring_ZF_1_L4",
            "Ring_ZF_1_L8",
            "ring_oper_distr",
            "Ring_ZF_1_L11",
            "Ring_ZF_1_L10",
            "Ring_ZF_2_L5",
            "Ring_ZF_1_L10A"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L6:\n  assumes A1: \"a\\<in>R\"  \"b\\<in>R\"  \"c\\<in>R\"  \"d\\<in>R\"  \"e\\<in>R\"  \"f\\<in>R\"\n  shows\n  \"a\\<cdot>(c\\<cdot>e \\<rs> d\\<cdot>f) \\<rs> b\\<cdot>(c\\<cdot>f \\<ra> d\\<cdot>e) =\n  (a\\<cdot>c \\<rs> b\\<cdot>d)\\<cdot>e \\<rs> (a\\<cdot>d \\<ra> b\\<cdot>c)\\<cdot>f\"\n  \"a\\<cdot>(c\\<cdot>f \\<ra> d\\<cdot>e) \\<ra> b\\<cdot>(c\\<cdot>e \\<rs> d\\<cdot>f) =\n  (a\\<cdot>c \\<rs> b\\<cdot>d)\\<cdot>f \\<ra> (a\\<cdot>d \\<ra> b\\<cdot>c)\\<cdot>e\"\n  \"a\\<cdot>(c\\<ra>e) \\<rs> b\\<cdot>(d\\<ra>f) = a\\<cdot>c \\<rs> b\\<cdot>d \\<ra> (a\\<cdot>e \\<rs> b\\<cdot>f)\"\n  \"a\\<cdot>(d\\<ra>f) \\<ra> b\\<cdot>(c\\<ra>e) = a\\<cdot>d \\<ra> b\\<cdot>c \\<ra> (a\\<cdot>f \\<ra> b\\<cdot>e)\"\n",
        "proof": "proof -\n  from A1 have T:\n    \"c\\<cdot>e \\<in> R\"  \"d\\<cdot>f \\<in> R\"  \"c\\<cdot>f \\<in> R\"  \"d\\<cdot>e \\<in> R\"\n    \"a\\<cdot>c \\<in> R\"  \"b\\<cdot>d \\<in> R\"  \"a\\<cdot>d \\<in> R\"  \"b\\<cdot>c \\<in> R\"\n    \"b\\<cdot>f \\<in> R\"  \"a\\<cdot>e \\<in> R\"  \"b\\<cdot>e \\<in> R\"  \"a\\<cdot>f \\<in> R\"\n    \"a\\<cdot>c\\<cdot>e \\<in> R\"  \"a\\<cdot>d\\<cdot>f \\<in> R\"\n    \"b\\<cdot>c\\<cdot>f \\<in> R\"  \"b\\<cdot>d\\<cdot>e \\<in> R\"\n    \"b\\<cdot>c\\<cdot>e \\<in> R\"  \"b\\<cdot>d\\<cdot>f \\<in> R\"\n    \"a\\<cdot>c\\<cdot>f \\<in> R\"  \"a\\<cdot>d\\<cdot>e \\<in> R\"\n    \"a\\<cdot>c\\<cdot>e \\<rs> a\\<cdot>d\\<cdot>f \\<in> R\"\n    \"a\\<cdot>c\\<cdot>e \\<rs> b\\<cdot>d\\<cdot>e \\<in> R\"\n    \"a\\<cdot>c\\<cdot>f \\<ra> a\\<cdot>d\\<cdot>e \\<in> R\"\n    \"a\\<cdot>c\\<cdot>f \\<rs> b\\<cdot>d\\<cdot>f \\<in> R\"\n    \"a\\<cdot>c \\<ra> a\\<cdot>e \\<in> R\"\n    \"a\\<cdot>d \\<ra> a\\<cdot>f \\<in> R\"\n    using Ring_ZF_1_L4 by auto\n  with A1 show \"a\\<cdot>(c\\<cdot>e \\<rs> d\\<cdot>f) \\<rs> b\\<cdot>(c\\<cdot>f \\<ra> d\\<cdot>e) =\n    (a\\<cdot>c \\<rs> b\\<cdot>d)\\<cdot>e \\<rs> (a\\<cdot>d \\<ra> b\\<cdot>c)\\<cdot>f\"\n    using Ring_ZF_1_L8 ring_oper_distr Ring_ZF_1_L11\n      Ring_ZF_1_L10 Ring_ZF_2_L5 by simp\n  from A1 T show \n    \"a\\<cdot>(c\\<cdot>f \\<ra> d\\<cdot>e) \\<ra> b\\<cdot>(c\\<cdot>e \\<rs> d\\<cdot>f) =\n    (a\\<cdot>c \\<rs> b\\<cdot>d)\\<cdot>f \\<ra> (a\\<cdot>d \\<ra> b\\<cdot>c)\\<cdot>e\"\n    using Ring_ZF_1_L8 ring_oper_distr Ring_ZF_1_L11\n    Ring_ZF_1_L10A Ring_ZF_2_L5 Ring_ZF_1_L10 \n    by simp\n  from A1 T show \n    \"a\\<cdot>(c\\<ra>e) \\<rs> b\\<cdot>(d\\<ra>f) = a\\<cdot>c \\<rs> b\\<cdot>d \\<ra> (a\\<cdot>e \\<rs> b\\<cdot>f)\"\n    \"a\\<cdot>(d\\<ra>f) \\<ra> b\\<cdot>(c\\<ra>e) = a\\<cdot>d \\<ra> b\\<cdot>c \\<ra> (a\\<cdot>f \\<ra> b\\<cdot>e)\"\n    using ring_oper_distr Ring_ZF_1_L10 Ring_ZF_2_L5\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1832
    },
    "1650": {
        "type": "lemma",
        "text": "text\\<open>The next lemma provides a formula useful for proving that two sides \n  of the distributive law equation for almost homomorphisms are almost \n  equal.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\" \"r\\<in>AH\" \"q\\<in>AH\" and A2: \"n\\<in>G\"\n  ",
        "using": [
            "Group_ZF_3_2_L15",
            "Group_ZF_3_4_T1",
            "AlmostHoms_def",
            "apply_funtype",
            "Group_ZF_3_2_L4B",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "Group_ZF_3_2_L12",
            "Group_ZF_3_4_L2",
            "Group_ZF_3_4_L1",
            "group0_4_L6A"
        ],
        "statement": "lemma (in group1) Ring_ZF_1_1_L1: \n  assumes A1: \"s\\<in>AH\" \"r\\<in>AH\" \"q\\<in>AH\" and A2: \"n\\<in>G\"\n  shows \n  \"((s\\<circ>(r\\<bullet>q))`(n))\\<cdot>(((s\\<circ>r)\\<bullet>(s\\<circ>q))`(n))\\<inverse>= \\<delta>(s,\\<langle> r`(n),q`(n)\\<rangle>)\"\n  \"((r\\<bullet>q)\\<circ>s)`(n) = ((r\\<circ>s)\\<bullet>(q\\<circ>s))`(n)\"\n",
        "proof": "proof -\n  from groupAssum isAbelian A1 have T1:\n    \"r\\<bullet>q \\<in> AH\" \"s\\<circ>r \\<in> AH\"  \"s\\<circ>q \\<in> AH\" \"(s\\<circ>r)\\<bullet>(s\\<circ>q) \\<in> AH\"\n    \"r\\<circ>s \\<in> AH\" \"q\\<circ>s \\<in> AH\"  \"(r\\<circ>s)\\<bullet>(q\\<circ>s) \\<in> AH\"\n    using Group_ZF_3_2_L15 Group_ZF_3_4_T1 by auto\n  from A1 A2 have T2: \"r`(n) \\<in> G\" \"q`(n) \\<in> G\" \"s`(n) \\<in> G\"\n    \"s`(r`(n)) \\<in> G\" \"s`(q`(n)) \\<in> G\" \"\\<delta>(s,\\<langle> r`(n),q`(n)\\<rangle>) \\<in> G\"\n    \"s`(r`(n))\\<cdot>s`(q`(n)) \\<in> G\" \"r`(s`(n)) \\<in> G\" \"q`(s`(n)) \\<in> G\"\n    \"r`(s`(n))\\<cdot>q`(s`(n)) \\<in> G\"\n    using AlmostHoms_def apply_funtype Group_ZF_3_2_L4B \n    group0_2_L1 monoid0.group0_1_L1 by auto\n  with T1 A1 A2 isAbelian show  \n    \"((s\\<circ>(r\\<bullet>q))`(n))\\<cdot>(((s\\<circ>r)\\<bullet>(s\\<circ>q))`(n))\\<inverse>= \\<delta>(s,\\<langle> r`(n),q`(n)\\<rangle>)\"\n    \"((r\\<bullet>q)\\<circ>s)`(n) = ((r\\<circ>s)\\<bullet>(q\\<circ>s))`(n)\"\n    using Group_ZF_3_2_L12 Group_ZF_3_4_L2 Group_ZF_3_4_L1 group0_4_L6A\n    by auto  \nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Ring_ZF_1.thy",
        "id": 1833
    },
    "1651": {
        "type": "lemma",
        "text": "text\\<open>The sides of the distributive law equations for almost homomorphisms \n  are almost equal.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\" \"r\\<in>AH\" \"q\\<in>AH\"\n  ",
        "using": [
            "AlmostHoms_def",
            "apply_funtype",
            "Ring_ZF_1_1_L1",
            "Group_ZF_3_2_L15",
            "Group_ZF_3_4_T1",
            "Group_ZF_3_4_L12",
            "fun_extension_iff"
        ],
        "statement": "lemma (in group1) Ring_ZF_1_1_L2:\n  assumes A1: \"s\\<in>AH\" \"r\\<in>AH\" \"q\\<in>AH\"\n  shows \n  \"s\\<circ>(r\\<bullet>q) \\<cong> (s\\<circ>r)\\<bullet>(s\\<circ>q)\" \n  \"(r\\<bullet>q)\\<circ>s = (r\\<circ>s)\\<bullet>(q\\<circ>s)\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>n\\<in>G. \\<langle> r`(n),q`(n)\\<rangle> \\<in> G\\<times>G\"\n    using AlmostHoms_def apply_funtype by auto\n  moreover from A1 have \"{\\<delta>(s,x). x \\<in> G\\<times>G} \\<in> Fin(G)\"\n    using AlmostHoms_def by simp\n  ultimately have \"{\\<delta>(s,\\<langle> r`(n),q`(n)\\<rangle>). n\\<in>G} \\<in> Fin(G)\"\n    by (rule Finite1_L6B)\n  with A1 have \n    \"{((s\\<circ>(r\\<bullet>q))`(n))\\<cdot>(((s\\<circ>r)\\<bullet>(s\\<circ>q))`(n))\\<inverse>. n \\<in> G} \\<in> Fin(G)\"\n    using Ring_ZF_1_1_L1 by simp\n  moreover from groupAssum isAbelian A1 A1 have \n    \"s\\<circ>(r\\<bullet>q) \\<in> AH\" \"(s\\<circ>r)\\<bullet>(s\\<circ>q) \\<in> AH\"\n    using Group_ZF_3_2_L15 Group_ZF_3_4_T1 by auto\n  ultimately show \"s\\<circ>(r\\<bullet>q) \\<cong> (s\\<circ>r)\\<bullet>(s\\<circ>q)\"\n    using Group_ZF_3_4_L12 by simp\n  from groupAssum isAbelian A1 have \n    \"(r\\<bullet>q)\\<circ>s : G\\<rightarrow>G\" \"(r\\<circ>s)\\<bullet>(q\\<circ>s) : G\\<rightarrow>G\"\n    using Group_ZF_3_2_L15 Group_ZF_3_4_T1 AlmostHoms_def\n    by auto\n  moreover from A1 have\n    \"\\<forall>n\\<in>G. ((r\\<bullet>q)\\<circ>s)`(n) = ((r\\<circ>s)\\<bullet>(q\\<circ>s))`(n)\"\n    using Ring_ZF_1_1_L1 by simp\n  ultimately show \"(r\\<bullet>q)\\<circ>s = (r\\<circ>s)\\<bullet>(q\\<circ>s)\"\n    using fun_extension_iff by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Ring_ZF_1.thy",
        "id": 1834
    },
    "1652": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show the distributivity for the \n  operations defined on classes of almost homomorphisms.\\<close>\n",
        "assumes": "assumes A1: \"R = QuotientGroupRel(AH,Op1,FR)\"\n  and A2: \"a \\<in> AH//R\" \"b \\<in> AH//R\" \"c \\<in> AH//R\"\n  and A3: \"A = ProjFun2(AH,R,Op1)\" \"M = ProjFun2(AH,R,Op2)\"\n  ",
        "using": [
            "quotient_def",
            "Group_ZF_3_3_L3",
            "Group_ZF_3_3_L4",
            "EquivClass_1_L10",
            "Group_ZF_3_2_L15",
            "Group_ZF_3_4_L13A",
            "Ring_ZF_1_1_L2",
            "equiv_class_eq",
            "Group_ZF_3_4_T1"
        ],
        "statement": "lemma (in group1) Ring_ZF_1_1_L3: \n  assumes A1: \"R = QuotientGroupRel(AH,Op1,FR)\"\n  and A2: \"a \\<in> AH//R\" \"b \\<in> AH//R\" \"c \\<in> AH//R\"\n  and A3: \"A = ProjFun2(AH,R,Op1)\" \"M = ProjFun2(AH,R,Op2)\"\n  shows \"M`\\<langle>a,A`\\<langle> b,c\\<rangle>\\<rangle> = A`\\<langle>M`\\<langle> a,b\\<rangle>,M`\\<langle> a,c\\<rangle>\\<rangle> \\<and> \n  M`\\<langle>A`\\<langle> b,c\\<rangle>,a\\<rangle> = A`\\<langle>M`\\<langle> b,a\\<rangle>,M`\\<langle> c,a\\<rangle>\\<rangle>\"\n",
        "proof": "proof\n  from A2 obtain s q r where D1: \"s\\<in>AH\" \"r\\<in>AH\" \"q\\<in>AH\"\n    \"a = R``{s}\" \"b = R``{q}\" \"c = R``{r}\"\n    using quotient_def by auto\n  from A1 have T1:\"equiv(AH,R)\"\n      using Group_ZF_3_3_L3 by simp\n  with A1 A3 D1 groupAssum isAbelian have \n    \"M`\\<langle>  a,A`\\<langle> b,c\\<rangle> \\<rangle> = R``{s\\<circ>(q\\<bullet>r)}\"\n    using Group_ZF_3_3_L4 EquivClass_1_L10\n    Group_ZF_3_2_L15 Group_ZF_3_4_L13A by simp\n  also have \"R``{s\\<circ>(q\\<bullet>r)} = R``{(s\\<circ>q)\\<bullet>(s\\<circ>r)}\"\n  proof -\n    from T1 D1 have \"equiv(AH,R)\" \"s\\<circ>(q\\<bullet>r) \\<cong> (s\\<circ>q)\\<bullet>(s\\<circ>r)\"\n      using Ring_ZF_1_1_L2 by auto\n    with A1 show ?thesis using equiv_class_eq by simp\n  qed\n  also from A1 T1 D1 A3 have \n    \"R``{(s\\<circ>q)\\<bullet>(s\\<circ>r)} = A`\\<langle>M`\\<langle> a,b\\<rangle>,M`\\<langle> a,c\\<rangle>\\<rangle>\"\n    using Group_ZF_3_3_L4 Group_ZF_3_4_T1 EquivClass_1_L10\n    Group_ZF_3_3_L3 Group_ZF_3_4_L13A EquivClass_1_L10 Group_ZF_3_4_T1\n    by simp\n  finally show \"M`\\<langle>a,A`\\<langle> b,c\\<rangle>\\<rangle> = A`\\<langle>M`\\<langle> a,b\\<rangle>,M`\\<langle> a,c\\<rangle>\\<rangle>\" by simp \n  from A1 A3 T1 D1 groupAssum isAbelian show \n    \"M`\\<langle>A`\\<langle> b,c\\<rangle>,a\\<rangle> = A`\\<langle>M`\\<langle> b,a\\<rangle>,M`\\<langle> c,a\\<rangle>\\<rangle>\"\n    using Group_ZF_3_3_L4 EquivClass_1_L10 Group_ZF_3_4_L13A \n      Group_ZF_3_2_L15 Ring_ZF_1_1_L2 Group_ZF_3_4_T1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Ring_ZF_1.thy",
        "id": 1835
    },
    "1653": {
        "type": "lemma",
        "text": "text\\<open>The projection of the first group operation on almost homomorphisms\n  is distributive with respect to the second group operation.\\<close>\n",
        "assumes": "assumes A1: \"R = QuotientGroupRel(AH,Op1,FR)\"\n  and A2: \"A = ProjFun2(AH,R,Op1)\" \"M = ProjFun2(AH,R,Op2)\"\n  ",
        "using": [
            "Ring_ZF_1_1_L3",
            "IsDistributive_def"
        ],
        "statement": "lemma (in group1) Ring_ZF_1_1_L4: \n  assumes A1: \"R = QuotientGroupRel(AH,Op1,FR)\"\n  and A2: \"A = ProjFun2(AH,R,Op1)\" \"M = ProjFun2(AH,R,Op2)\"\n  shows \"IsDistributive(AH//R,A,M)\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<forall>a\\<in>(AH//R).\\<forall>b\\<in>(AH//R).\\<forall>c\\<in>(AH//R).\n  M`\\<langle>a,A`\\<langle> b,c\\<rangle>\\<rangle> = A`\\<langle>M`\\<langle> a,b\\<rangle>, M`\\<langle> a,c\\<rangle>\\<rangle> \\<and> \n  M`\\<langle>A`\\<langle> b,c\\<rangle>, a\\<rangle> = A`\\<langle>M`\\<langle> b,a\\<rangle>,M`\\<langle> c,a\\<rangle>\\<rangle>\"\n    using Ring_ZF_1_1_L3 by simp\n  then show ?thesis using IsDistributive_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Ring_ZF_1.thy",
        "id": 1836
    },
    "1654": {
        "type": "theorem",
        "text": "text\\<open>The classes of almost homomorphisms form a ring.\\<close>\n",
        "assumes": "assumes \"R = QuotientGroupRel(AH,Op1,FR)\"\n  and \"A = ProjFun2(AH,R,Op1)\" \"M = ProjFun2(AH,R,Op2)\"\n  ",
        "using": [
            "assms",
            "QuotientGroupOp_def",
            "Group_ZF_3_3_T1",
            "Group_ZF_3_4_T2",
            "Ring_ZF_1_1_L4",
            "IsAring_def"
        ],
        "statement": "theorem (in group1) Ring_ZF_1_1_T1: \n  assumes \"R = QuotientGroupRel(AH,Op1,FR)\"\n  and \"A = ProjFun2(AH,R,Op1)\" \"M = ProjFun2(AH,R,Op2)\"\n  shows \"IsAring(AH//R,A,M)\"\n  ",
        "proof": "using assms QuotientGroupOp_def Group_ZF_3_3_T1 Group_ZF_3_4_T2 \n    Ring_ZF_1_1_L4 IsAring_def by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Ring_ZF_1.thy",
        "id": 1837
    },
    "1655": {
        "type": "lemma",
        "text": "text\\<open>Some small lemmas dividing the definition of ideal into small parts\\<close>\nlemma (in ring0) ideal_dest_subset:\n  assumes \"I \\<triangleleft>R\" \n  shows \"I \\<subseteq> R\" using assms unfolding Ideal_def using add_group.group0_3_L2  by auto\n",
        "assumes": "assumes \"I \\<triangleleft>R\" \"x\\<in>I\" \"y\\<in>I\"\n  ",
        "using": [
            "assms",
            "add_group.group0_3_L6",
            "Ideal_def"
        ],
        "statement": "lemma (in ring0) ideal_dest_sum:\n  assumes \"I \\<triangleleft>R\" \"x\\<in>I\" \"y\\<in>I\"\n  shows \"x\\<ra>y \\<in>I\" ",
        "proof": "using assms add_group.group0_3_L6 \n    unfolding Ideal_def by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1839
    },
    "1656": {
        "type": "definition",
        "text": "text\\<open>From any set, we may construct the minimal ideal containing that set\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) generatedIdeal (\"\\<langle>_\\<rangle>\\<^sub>I\")\n  where \"X\\<subseteq>R \\<Longrightarrow> \\<langle>X\\<rangle>\\<^sub>I \\<equiv> \\<Inter>{I\\<in>\\<I>. X \\<subseteq> I}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1840
    },
    "1657": {
        "type": "lemma",
        "text": "text\\<open>To be able to show properties of an ideal generated by a set, we\nhave the following induction result\\<close>\n",
        "assumes": "assumes \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. \\<forall>q\\<in>\\<langle>X\\<rangle>\\<^sub>I. P(q) \\<longrightarrow> P(y\\<cdot>q\\<cdot>z)\" \n    \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. P(y) \\<and> P(z) \\<longrightarrow> P(y\\<ra>z)\" \n    \"X \\<subseteq> R\" \n    \"\\<forall>x\\<in>X. P(x)\"\n    \"X\\<noteq>0\"\n  ",
        "using": [
            "assms(3,4)",
            "generated_ideal_contains_set",
            "generated_ideal_is_ideal",
            "ideal_dest_subset",
            "assms(3)",
            "sub",
            "Ring_ZF_1_L2(2)",
            "Ring_ZF_1_L3(5)[of",
            "\"y\\<cdot>z\"]",
            "Ring_ZF_1_L4(3)[of",
            "y]",
            "Ring_ZF_1_L3(6)",
            "_",
            "generated_ideal_is_ideal[OF",
            "assms(3)]",
            "ideal_dest_mult",
            "assms(3-5)",
            "generated_ideal_contains_set[OF",
            ".",
            "{",
            "fix",
            "x",
            "assume",
            "\"x:?J\"",
            "then",
            "have",
            "x:\"x:\\<langle>X\\<rangle>\\<^sub>I\"",
            "\"x\\<in>R\"",
            "\"P(x)\"",
            "Ring_ZF_1_L2(2).",
            "\"\\<one>:R\"",
            "\"(\\<rm>\\<one>):R\"",
            "Ring_ZF_1_L3(1)",
            "assms(1)",
            "Ring_ZF_1_L3(6)[of",
            "x]",
            "Ring_ZF_1_L7(1)[of",
            "\\<one>",
            "`\\<one>:R`",
            "`x:R`",
            "Ring_ZF_1_L3(5)[OF",
            "Ring_ZF_1_L3(1)]",
            "ideal_dest_minus",
            "assms(2)",
            "ideal_dest_subset[OF",
            "assms(3)]]",
            "as",
            "ideal_dest_sum",
            "generated_ideal_small"
        ],
        "statement": "lemma (in ring0) induction_generated_ideal:\n  assumes \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. \\<forall>q\\<in>\\<langle>X\\<rangle>\\<^sub>I. P(q) \\<longrightarrow> P(y\\<cdot>q\\<cdot>z)\" \n    \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. P(y) \\<and> P(z) \\<longrightarrow> P(y\\<ra>z)\" \n    \"X \\<subseteq> R\" \n    \"\\<forall>x\\<in>X. P(x)\"\n    \"X\\<noteq>0\"\n  shows \"\\<forall>y\\<in>\\<langle>X\\<rangle>\\<^sub>I. P(y)\"\n",
        "proof": "proof-\n  let ?J=\"{m\\<in>\\<langle>X\\<rangle>\\<^sub>I. P(m)}\"\n  have XJ:\"X \\<subseteq> ?J\" using assms(3,4) generated_ideal_contains_set by auto\n  have sub:\"?J \\<subseteq> R\" using generated_ideal_is_ideal ideal_dest_subset assms(3) by auto moreover\n  {\n    fix y z assume \"y\\<in>R\" \"z\\<in>?J\"\n    then have yz:\"z\\<in>\\<langle>X\\<rangle>\\<^sub>I\" \"y\\<in>R\" \"P(z)\" \"z:R\" using sub by auto\n    from assms(1) yz have \"P(y\\<cdot>z)\" using\n      Ring_ZF_1_L2(2) Ring_ZF_1_L3(5)[of \"y\\<cdot>z\"] Ring_ZF_1_L4(3)[of y]\n      by force moreover\n    from assms(1) yz have \"P(z\\<cdot>y)\" using\n      Ring_ZF_1_L2(2) Ring_ZF_1_L3(6) Ring_ZF_1_L4(3)[of _ y]\n      by force moreover \n    from yz(1,2) have \"y\\<cdot>z\\<in>\\<langle>X\\<rangle>\\<^sub>I\" \"z\\<cdot>y\\<in>\\<langle>X\\<rangle>\\<^sub>I\" using \n      generated_ideal_is_ideal[OF assms(3)] ideal_dest_mult by auto\n    ultimately have \"y\\<cdot>z\\<in>?J\" \"z\\<cdot>y\\<in>?J\" by auto\n  }\n  then have \"\\<forall>x\\<in>?J. \\<forall>y\\<in>R. y \\<cdot> x \\<in> ?J \\<and> x \\<cdot> y \\<in> ?J\" by auto\n  moreover\n  have \"IsAsubgroup(?J,A)\"\n  proof(rule add_group.group0_3_T3)\n    show \"?J\\<noteq>0\" using assms(3-5) generated_ideal_contains_set[OF assms(3)] by force\n    show \"?J\\<subseteq>R\" using sub .\n    {\n      fix x assume \"x:?J\"\n      then have x:\"x:\\<langle>X\\<rangle>\\<^sub>I\" \"x\\<in>R\" \"P(x)\" using sub by auto moreover\n      have \"\\<one>:R\" using Ring_ZF_1_L2(2).\n      then have \"\\<one>:R\" \"(\\<rm>\\<one>):R\" using Ring_ZF_1_L3(1) by auto\n      ultimately have \"P((\\<rm>\\<one>)\\<cdot>x\\<cdot>\\<one>)\" using assms(1) by auto\n      then have \"P((\\<rm>x)\\<cdot>\\<one>)\" using Ring_ZF_1_L3(6)[of x]\n        Ring_ZF_1_L7(1)[of \\<one> x] `\\<one>:R` `x:R` by auto\n      then have \"P(\\<rm>x)\" using Ring_ZF_1_L3(5)[OF Ring_ZF_1_L3(1)]\n        `x:R` by auto moreover\n      from x(1) have \"(\\<rm>x)\\<in>\\<langle>X\\<rangle>\\<^sub>I\" using generated_ideal_is_ideal[OF assms(3)]\n        ideal_dest_minus by auto\n      ultimately have \"(\\<rm>x)\\<in>?J\" by auto\n    }\n    then show \"\\<forall>x\\<in>?J. (\\<rm> x) \\<in> ?J\" by auto\n    {\n      fix x y assume as:\"x\\<in>?J\" \"y\\<in>?J\"\n      from as have \"P(x\\<ra>y)\" using assms(2)\n        ideal_dest_subset[OF generated_ideal_is_ideal[OF assms(3)]] by auto\n      moreover\n      have \"x\\<ra>y\\<in>\\<langle>X\\<rangle>\\<^sub>I\" using as generated_ideal_is_ideal[OF assms(3)]\n        ideal_dest_sum by auto\n      ultimately have \"x\\<ra>y \\<in> ?J\" by auto\n    }\n    then show \"?J {is closed under} A\" unfolding IsOpClosed_def by auto\n  qed\n  ultimately have \"?J\\<triangleleft>R\" unfolding Ideal_def by auto\n  with XJ have \"\\<langle>X\\<rangle>\\<^sub>I \\<subseteq> ?J\" using generated_ideal_small by auto\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1841
    },
    "1658": {
        "type": "theorem",
        "text": "text\\<open>An ideal is very particular with the elements it may contain. If it contains\nany invertible element, it is in fact the whole ring and not a proper subset\\<close>\n",
        "assumes": "assumes \"I\\<triangleleft>R\" \"\\<one>\\<in>I\"\n  ",
        "using": [
            "ideal_dest_subset",
            "ideal_dest_mult(2)",
            "Ring_ZF_1_L3(5)"
        ],
        "statement": "theorem (in ring0) ideal_with_one:\n  assumes \"I\\<triangleleft>R\" \"\\<one>\\<in>I\"\n  shows \"I = R\"\n",
        "proof": "proof-\n  from assms(1) have \"I \\<subseteq> R\" using ideal_dest_subset by auto\n  moreover\n  {\n    fix t assume t:\"t:R\"\n    with assms have \"t\\<cdot>\\<one> \\<in>I\" using ideal_dest_mult(2) by auto\n    with t have \"t:I\" using Ring_ZF_1_L3(5) by auto\n  }\n  then have \"R\\<subseteq> I\" by auto\n  ultimately show \"I=R\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1842
    },
    "1659": {
        "type": "definition",
        "text": "text\\<open>The previous result drives us to define what a maximal ideal would be:\n  an ideal such that any bigger ideal is the whole ring\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) maximalIdeal (\"_\\<triangleleft>\\<^sub>mR\") where\n  \"I\\<triangleleft>\\<^sub>mR \\<equiv> I\\<triangleleft>R \\<and> I \\<noteq>R \\<and> (\\<forall>J\\<in>\\<I>. I\\<subseteq>J \\<and> J\\<noteq>R \\<longrightarrow> I=J)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1843
    },
    "1660": {
        "type": "definition",
        "text": "text\\<open>Before delving into maximal ideals, lets define some operation on ideals\n  that are useful when formulating some proofs.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) productIdeal (infix \"\\<cdot>\\<^sub>I\" 90) where\n  \"I\\<triangleleft>R \\<Longrightarrow> J\\<triangleleft>R  \\<Longrightarrow> I\\<cdot>\\<^sub>IJ \\<equiv> \\<langle>M``(I\\<times>J)\\<rangle>\\<^sub>I\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1844
    },
    "1661": {
        "type": "lemma",
        "text": "text\\<open>Every element in the arbitrary sum of ideals\n  is generated by only a finite subset of those ideals\\<close>\n",
        "assumes": "assumes \"\\<J> \\<subseteq> \\<I>\" \"s\\<in>(\\<oplus>\\<^sub>I\\<J>)\"\n  ",
        "using": [
            "subset_Finite[OF",
            "_",
            "nat_into_Finite[of",
            "1]]",
            "assms(2)",
            "eqpoll_imp_Finite_iff[of",
            "\"{J}\"",
            "\"1\"]",
            "nat_into_Finite",
            "J(2)",
            "assms(1)",
            "sumArbitraryIdeals_def",
            "generated_ideal_contains_set[of",
            "J]",
            "FinPow_def",
            "generated_ideal_is_ideal[of",
            "\"\\<Union>\\<T>\"]",
            "sumArbitraryIdeals_def[of",
            "\\<T>]",
            "Finite_Un",
            "\"\\<Union>(Ty\\<union>Tz)\"]",
            "generated_ideal_small[OF",
            "generated_ideal_is_ideal]",
            "sub",
            "\"Ty\"]",
            "\"Tz\"]",
            "generated_ideal_is_ideal[OF",
            "sub]",
            "ideal_dest_sum",
            "\"Ty\\<union>Tz\"]",
            "Q",
            "induction_generated_ideal[of",
            "\"\\<Union>\\<J>\"",
            "?P]",
            "notE"
        ],
        "statement": "lemma (in ring0) sum_ideals_finite_sum:\n  assumes \"\\<J> \\<subseteq> \\<I>\" \"s\\<in>(\\<oplus>\\<^sub>I\\<J>)\"\n  shows \"\\<exists>\\<T>\\<in>FinPow(\\<J>). s\\<in>(\\<oplus>\\<^sub>I\\<T>)\"\n",
        "proof": "proof-\n  {\n    assume \"\\<Union>\\<J>=0\"\n    then have \"\\<J>\\<subseteq>{0}\" by auto\n    then have \"Finite(\\<J>)\" using subset_Finite[OF _ nat_into_Finite[of 1]]\n      by auto\n    then have \"\\<J>\\<in>FinPow(\\<J>)\" unfolding FinPow_def by auto\n    then have ?thesis using assms(2) by auto\n  }\n  moreover\n  {\n    assume notE:\"\\<Union>\\<J>\\<noteq>0\" \n    let ?P= \"\\<lambda>t. \\<exists>\\<T>\\<in>FinPow(\\<J>). t\\<in>(\\<oplus>\\<^sub>I\\<T>)\"\n    {\n      fix t assume \"t\\<in>\\<Union>\\<J>\"\n      then obtain J where J:\"t\\<in>J\" \"J\\<in>\\<J>\" by auto\n      then have \"{J}\\<in>FinPow(\\<J>)\" unfolding FinPow_def\n        using eqpoll_imp_Finite_iff[of \"{J}\" \"1\"] nat_into_Finite\n        by auto moreover\n      have \"(\\<oplus>\\<^sub>I{J}) = \\<langle>J\\<rangle>\\<^sub>I\" using J(2) assms(1)\n        sumArbitraryIdeals_def by auto\n      with J(1) have \"t\\<in>(\\<oplus>\\<^sub>I{J})\"\n        using generated_ideal_contains_set[of J]\n        J(2) assms(1) by auto\n      ultimately have \"?P(t)\" by auto\n    }\n    then have \"\\<forall>t\\<in>\\<Union>\\<J>. ?P(t)\" by auto moreover\n    {  \n      fix y z q assume q:\"?P(q)\" \"y:R\" \"z:R\" \"q:\\<langle>\\<Union>\\<J>\\<rangle>\\<^sub>I\"\n      then obtain \\<T> where T:\"\\<T>\\<in>FinPow(\\<J>)\" \"q:\\<oplus>\\<^sub>I\\<T>\" by auto\n      from T(1) have \"\\<Union>\\<T> \\<subseteq> R\" \"\\<T>\\<subseteq>\\<I>\" using assms(1) unfolding FinPow_def by auto\n      then have \"(\\<oplus>\\<^sub>I\\<T>)\\<triangleleft>R\" using generated_ideal_is_ideal[of \"\\<Union>\\<T>\"]\n        sumArbitraryIdeals_def[of \\<T>] by auto\n      with T(2) q(2,3) have \"y \\<cdot> q \\<cdot> z \\<in> \\<oplus>\\<^sub>I\\<T>\"\n        unfolding Ideal_def by auto\n      with T(1) have \"?P(y \\<cdot> q \\<cdot> z)\" by auto\n    }\n    then have \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. \\<forall>q\\<in>\\<langle>\\<Union>\\<J>\\<rangle>\\<^sub>I. ?P(q) \\<longrightarrow> ?P(y \\<cdot> q \\<cdot> z)\" by auto moreover\n    {\n      fix y z assume \"?P(y)\" \"?P(z)\"\n      then obtain Ty Tz where T:\"Ty\\<in>FinPow(\\<J>)\" \"y \\<in> \\<oplus>\\<^sub>ITy\"\n        \"Tz\\<in>FinPow(\\<J>)\" \"z \\<in> \\<oplus>\\<^sub>ITz\" by auto\n      from T(1,3) have A:\"Ty\\<union>Tz:FinPow(\\<J>)\" unfolding FinPow_def\n        using Finite_Un by auto\n      then have \"\\<Union>Ty \\<subseteq> \\<Union>(Ty\\<union>Tz)\" \"\\<Union>Tz \\<subseteq> \\<Union>(Ty\\<union>Tz)\" and sub:\"\\<Union>(Ty\\<union>Tz) \\<subseteq>R\"\n        unfolding FinPow_def using assms(1) by auto\n      with A have \"\\<Union>Ty \\<subseteq> \\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\" \"\\<Union>Tz \\<subseteq> \\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\" using\n        generated_ideal_contains_set[of \"\\<Union>(Ty\\<union>Tz)\"] by auto\n      then have \"\\<langle>\\<Union>Ty\\<rangle>\\<^sub>I\\<subseteq> \\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\" \"\\<langle>\\<Union>Tz\\<rangle>\\<^sub>I \\<subseteq> \\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\"\n        using generated_ideal_small[OF _ generated_ideal_is_ideal]\n        sub by auto\n      moreover from T(1,3) have Q:\"Ty \\<subseteq>\\<I>\" \"Tz\\<subseteq> \\<I>\" using assms(1)\n        unfolding FinPow_def by auto\n      moreover note T(2,4)\n      ultimately have \"y\\<in>\\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\" \"z\\<in>\\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\"\n        using sumArbitraryIdeals_def[of \"Ty\"]\n        sumArbitraryIdeals_def[of \"Tz\"] by auto\n      then have \"y\\<ra>z\\<in>\\<langle>\\<Union>(Ty\\<union>Tz)\\<rangle>\\<^sub>I\" using\n        generated_ideal_is_ideal[OF sub] ideal_dest_sum\n        by auto\n      then have \"y\\<ra>z\\<in>(\\<oplus>\\<^sub>I(Ty\\<union>Tz))\" using sumArbitraryIdeals_def[of \"Ty\\<union>Tz\"]\n        Q by force\n      with A have \"?P(y\\<ra>z)\" by auto\n    }\n    then have \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. ?P(y) \\<and> ?P(z) \\<longrightarrow> ?P(y \\<ra> z)\" by auto\n    moreover\n    have sub:\"\\<Union>\\<J> \\<subseteq> R\" using assms(1) by auto\n    ultimately have \"\\<forall>t\\<in>\\<langle>\\<Union>\\<J>\\<rangle>\\<^sub>I. ?P(t)\"\n      using induction_generated_ideal[of \"\\<Union>\\<J>\" ?P] notE by blast\n    with assms(2) have ?thesis unfolding\n      sumArbitraryIdeals_def[OF assms(1)] by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1845
    },
    "1662": {
        "type": "lemma",
        "text": "text\\<open>We will show now that the sum of ideals is no more that the sum of the ideal elements\\<close>\nlemma (in ring0) sum_elements:\n  assumes \"I \\<triangleleft>R\" \"J \\<triangleleft>R\" \"x \\<in> I\" \"y \\<in> J\"\n  shows \"x\\<ra>y \\<in> I+\\<^sub>IJ\"\nproof-\n  from assms(1,2) have \"I\\<union>J \\<subseteq> R\" using ideal_dest_subset by auto moreover\n  have \"x\\<in> I\\<union>J\" \"y\\<in> I\\<union>J\" using assms(3,4) by auto\n  ultimately have \"x \\<in> \\<langle>I\\<union>J\\<rangle>\\<^sub>I\" \"y \\<in> \\<langle>I\\<union>J\\<rangle>\\<^sub>I\" using generated_ideal_contains_set\n    by auto\n  moreover have \"\\<langle>I\\<union>J\\<rangle>\\<^sub>I \\<triangleleft>R\" using generated_ideal_is_ideal[of \"I\\<union>J\"] assms(1,2)\n    using ideal_dest_subset[of I] ideal_dest_subset[of J]\n    by auto\n  ultimately have \"x\\<ra>y\\<in>\\<langle>I\\<union>J\\<rangle>\\<^sub>I\" using ideal_dest_sum by auto\n  then show ?thesis using sumIdeal_def assms(1,2) by auto\nqed\n",
        "assumes": "assumes \"I \\<triangleleft>R\" \"J \\<triangleleft>R\"\n  ",
        "using": [
            "add_group.groupAssum",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "ideal_dest_subset",
            "func1_1_L6(2)",
            "func_imagedef[OF",
            "a,",
            "of",
            "\"I\\<times>J\"]",
            "ring_oper_distr",
            "xy(1)",
            "y",
            "ij",
            "add_group.group_op_closed",
            "assms",
            "y(2,3)",
            "ideal_dest_mult",
            "Aimage.",
            "{",
            "fix",
            "x",
            "assume",
            "\"x\\<in>A",
            "``",
            "(I",
            "\\<times>",
            "J)\"",
            "then",
            "obtain",
            "z",
            "where",
            "\"x=A`z\"",
            "\"z\\<in>I\\<times>J\"",
            "Ring_ZF_1_L9(2)",
            "x(1,2)",
            "assms(1)",
            "ideal_dest_minus",
            "x(1)",
            "assms(2)",
            "x(2)",
            "ideal_dest_zero",
            "AsubR",
            "x(4-6)",
            "Ring_ZF_1_L10(1)[of",
            "yi",
            "yj]",
            "x(1-5)",
            "Ring_ZF_2_L5(4)[of",
            "xi",
            "xj",
            "x(1,4)",
            "ideal_dest_sum",
            "x(2,5)"
        ],
        "statement": "lemma (in ring0) sum_elements_is_ideal:\n  assumes \"I \\<triangleleft>R\" \"J \\<triangleleft>R\"\n  shows \"(A``(I\\<times>J)) \\<triangleleft>R\"\n",
        "proof": "proof-\n  have a:\"A:R\\<times>R \\<rightarrow> R\" using add_group.groupAssum IsAgroup_def \n      IsAmonoid_def IsAssociative_def by simp\n  from assms have ij:\"I\\<times>J \\<subseteq> R\\<times>R\" using ideal_dest_subset by auto\n  from a have Aimage:\"A``(I\\<times>J) \\<subseteq> R\" using func1_1_L6(2) by auto\n  moreover\n  {\n    fix x y assume xy:\"x\\<in>R\" \"y\\<in>A``(I\\<times>J)\"\n    from ij xy(2) obtain z where \"y=A`z\" \"z\\<in>I\\<times>J\" using func_imagedef[OF a, of \"I\\<times>J\"]\n      by auto\n    then obtain yi yj where y:\"y=yi\\<ra>yj\" \"yi\\<in>I\" \"yj\\<in>J\"\n      by auto\n    from y(1) have \"x\\<cdot>y = x\\<cdot>(yi\\<ra>yj)\" \"y\\<cdot>x = (yi\\<ra>yj)\\<cdot>x\" by auto\n    then have \"x\\<cdot>y = (x\\<cdot>yi)\\<ra>(x\\<cdot>yj)\" \"y\\<cdot>x = (yi\\<cdot>x)\\<ra>(yj\\<cdot>x)\"\n      using ring_oper_distr xy(1) y ij add_group.group_op_closed by auto\n    moreover\n    have \"x\\<cdot>yi \\<in> I\" \"yi\\<cdot>x \\<in> I\" \"x\\<cdot>yj \\<in> J\" \"yj\\<cdot>x \\<in> J\"\n      using assms xy(1) y(2,3) ideal_dest_mult by auto\n    ultimately have \"x\\<cdot>y\\<in>A``(I\\<times>J)\" \"y\\<cdot>x\\<in>A``(I\\<times>J)\"\n      using func_imagedef[OF a, of \"I\\<times>J\"] ij by auto\n  }\n  then have \"\\<forall>x\\<in>A``(I\\<times>J). \\<forall>y\\<in>R. y \\<cdot> x \\<in> A``(I\\<times>J) \\<and> x \\<cdot> y \\<in> A``(I\\<times>J)\" by auto\n  moreover\n  have \"IsAsubgroup(A``(I\\<times>J),A)\"\n  proof(rule add_group.group0_3_T3)\n    show AsubR:\"A `` (I \\<times> J) \\<subseteq> R\" using Aimage.\n    {\n      fix x assume \"x\\<in>A `` (I \\<times> J)\"\n      then obtain z where \"x=A`z\" \"z\\<in>I\\<times>J\" using func_imagedef[OF a, of \"I\\<times>J\"]\n        ij by auto\n      then obtain xi xj where x:\"xi\\<in>I\" \"xj\\<in>J\" \"x=xi\\<ra>xj\" by auto\n      from x(3) have \"(\\<rm>x) = \\<rm>(xi\\<ra>xj)\" by auto\n      then have \"(\\<rm>x) = (\\<rm>xi)\\<rs>xj\" using Ring_ZF_1_L9(2)\n        assms x(1,2) ideal_dest_subset by auto\n      moreover\n      have \"(\\<rm>xi)\\<in>I\" using assms(1) ideal_dest_minus x(1) by auto\n      moreover\n      have \"(\\<rm>xj)\\<in>J\" using assms(2) ideal_dest_minus x(2) by auto\n      ultimately have \"(\\<rm>x) \\<in> A``(I\\<times>J)\" using func_imagedef[OF a, of \"I\\<times>J\"]\n        ij by auto\n    }\n    then show \"\\<forall>x\\<in>A `` (I \\<times> J). (\\<rm> x) \\<in> A `` (I \\<times> J)\" by auto\n    have \"\\<zero>\\<in>I\" \"\\<zero>\\<in>J\" using ideal_dest_zero assms by auto\n    then have \"\\<zero>\\<ra>\\<zero> \\<in> A `` (I \\<times> J)\" using func_imagedef[OF a, of \"I\\<times>J\"] ij by auto\n    then show \"A `` (I \\<times> J) \\<noteq> 0\" by auto\n    {\n      fix x y assume xy:\"x\\<in> A `` (I \\<times> J)\" \"y\\<in> A `` (I \\<times> J)\"\n      then obtain z g where \"x=A`z\" \"z\\<in>I\\<times>J\" \"y=A`g\" \"g\\<in>I\\<times>J\" using func_imagedef[OF a, of \"I\\<times>J\"]\n        ij by auto\n      then obtain xi xj yi yj where x:\"xi\\<in>I\" \"xj\\<in>J\" \"x=xi\\<ra>xj\"\n        \"yi\\<in>I\" \"yj\\<in>J\" \"y=yi\\<ra>yj\" by auto\n      have \"x\\<ra>y = (x\\<ra>yi)\\<ra>yj\" using xy(1) AsubR\n        x(4-6) ij Ring_ZF_1_L10(1)[of x yi yj] by force\n      then have \"x\\<ra>y = (xi\\<ra>yi)\\<ra>(xj\\<ra>yj)\"\n        using x(1-5) ij Ring_ZF_2_L5(4)[of xi xj yi yj] by auto\n      moreover have \"xi\\<ra>yi \\<in> I\" using x(1,4) assms(1)\n        ideal_dest_sum by auto\n      moreover have \"xj\\<ra>yj \\<in> J\" using x(2,5) assms(2)\n        ideal_dest_sum by auto\n      ultimately have \"x\\<ra>y \\<in> A``(I\\<times>J)\" using func_imagedef[OF a, of \"I\\<times>J\"]\n        ij by auto\n    }\n    then show \"A `` (I \\<times> J) {is closed under} A\" unfolding IsOpClosed_def\n      by auto\n  qed\n  ultimately show \"(A `` (I \\<times> J))\\<triangleleft>R\" unfolding Ideal_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1846
    },
    "1663": {
        "type": "theorem",
        "text": "text\\<open>Any maximal ideal is prime\\<close>\n",
        "assumes": "assumes \"Q\\<triangleleft>\\<^sub>mR\"\n  ",
        "using": [
            "add_group.groupAssum",
            "IsAgroup_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "assms",
            "maximalIdeal_def",
            "ideal_dest_subset",
            "ij(1)",
            "generated_ideal_contains_set[of",
            "\"Q\\<union>{x}\"]",
            "ideal_dest_subset[of",
            "Q]",
            "xR",
            "generated_ideal_is_ideal[of",
            "\"\\<langle>Q\\<union>{x}\\<rangle>\\<^sub>I\"]",
            "\"Q\\<union>I\"]",
            "sumIdeal_def[of",
            "Q",
            "I]",
            "x",
            "generated_ideal_small[of",
            "\"Q\\<union>{x}\"",
            "\"Q+\\<^sub>II\"]",
            "Ring_ZF_1_L2(2)",
            "sum_ideals_is_sum_elements",
            "MI",
            "func_imagedef[OF",
            "a,",
            "of",
            "\"Q\\<times>I\"]",
            "Ring_ZF_1_L3(6)",
            "ij(2)",
            "y",
            "mi1(1,2)",
            "ij(1,2)",
            "ring_oper_distr(2)[of",
            "xm",
            "xi]",
            "mi1(1)",
            "elems(1)",
            "ideal_dest_mult(1)",
            "ringAssum",
            "IsAring_def",
            "func_imagedef[of",
            "M",
            "\"R\\<times>R\"",
            "R",
            "\"I\\<times>J\"]",
            "mi1(2)",
            "\"M``(I\\<times>J)\"]",
            "func1_1_L6(2)[OF",
            "MR]",
            "productIdeal_def",
            "ideal_dest_sum",
            "primeIdeal_def"
        ],
        "statement": "theorem (in ring0) maximal_is_prime:\n  assumes \"Q\\<triangleleft>\\<^sub>mR\"\n  shows \"Q\\<triangleleft>\\<^sub>pR\"\n",
        "proof": "proof-\n  have a:\"A:R\\<times>R \\<rightarrow> R\" using add_group.groupAssum IsAgroup_def \n      IsAmonoid_def IsAssociative_def by simp\n  have MI:\"Q \\<in> \\<I>\" using assms unfolding maximalIdeal_def\n    using ideal_dest_subset by auto\n  {\n    fix I J assume ij:\"I\\<in>\\<I>\" \"J\\<in>\\<I>\" \"I \\<cdot>\\<^sub>I J \\<subseteq> Q\"\n    {\n      assume K:\"\\<not>(I\\<subseteq>Q)\" \"\\<not>(J\\<subseteq>Q)\"\n      from this(1) obtain x where x:\"x\\<in>I-Q\" by auto\n      then have xR:\"x\\<in>R\" using ij(1) ideal_dest_subset by auto\n      let ?K = \"\\<langle>Q\\<union>{x}\\<rangle>\\<^sub>I\"\n      have MK:\"Q \\<subseteq> ?K\" \"x\\<in>?K\" using generated_ideal_contains_set[of \"Q\\<union>{x}\"]\n        assms unfolding maximalIdeal_def using ideal_dest_subset[of Q]\n        xR by auto\n      with x have \"Q \\<subseteq> ?K\" \"?K\\<noteq>Q\" by auto\n      with assms have \"?K\\<in>\\<I> \\<Longrightarrow> ?K=R\" unfolding maximalIdeal_def by auto\n      then have KR:\"?K=R\" using generated_ideal_is_ideal[of \"Q\\<union>{x}\"] xR\n        assms unfolding maximalIdeal_def using ideal_dest_subset[of Q]\n        ideal_dest_subset[of \"\\<langle>Q\\<union>{x}\\<rangle>\\<^sub>I\"] by auto\n      let ?P=\"Q+\\<^sub>II\"\n      have \"Q\\<union>I \\<subseteq> Q+\\<^sub>II\" using generated_ideal_contains_set[of \"Q\\<union>I\"]\n        sumIdeal_def[of Q I] assms ij(1)\n        maximalIdeal_def using ideal_dest_subset by auto\n      then have \"Q\\<union>{x} \\<subseteq> Q+\\<^sub>II\" using x by auto\n      then have \"?K \\<subseteq> Q+\\<^sub>II\" \"Q+\\<^sub>II \\<subseteq>R\" using generated_ideal_small[of \"Q\\<union>{x}\" \"Q+\\<^sub>II\"]\n        generated_ideal_is_ideal[of \"Q\\<union>I\"] sumIdeal_def[of Q I]\n        ij(1) assms unfolding maximalIdeal_def using\n        ideal_dest_subset by auto\n      with KR have \"Q+\\<^sub>II = R\" by auto\n      then have \"\\<one>\\<in>Q+\\<^sub>II \" using Ring_ZF_1_L2(2) by auto\n      then have \"\\<one>\\<in>A``(Q\\<times>I)\"\n        using sum_ideals_is_sum_elements MI ij(1) by auto\n      moreover have \"Q\\<times>I \\<subseteq> R\\<times>R\" using MI ij(1) by auto\n      ultimately obtain xm xi where mi1:\"xm\\<in>Q\" \"xi\\<in>I\" \"\\<one>=xm\\<ra>xi\"\n        using func_imagedef[OF a, of \"Q\\<times>I\"] by auto\n      {\n        fix y assume y:\"y\\<in>J\"\n        then have \"\\<one>\\<cdot>y = y\" using Ring_ZF_1_L3(6) ij(2) by auto\n        with mi1(3) have \"(xm\\<ra>xi)\\<cdot>y = y\" by auto\n        moreover have elems:\"y:R\" \"xm:R\" \"xi:R\" using y mi1(1,2)\n          MI ij(1,2) by auto\n        ultimately have \"(xm\\<cdot>y)\\<ra>(xi\\<cdot>y) = y\" using\n          ring_oper_distr(2)[of y xm xi] by auto\n        moreover have \"xm\\<cdot>y:Q\" using mi1(1) elems(1)\n          MI ideal_dest_mult(1) by auto\n        moreover\n        have sub:\"I\\<times>J \\<subseteq> R\\<times>R\" using ij(1,2) by auto\n        have MR:\"M:R\\<times>R\\<rightarrow>R\" using ringAssum unfolding IsAring_def\n          IsAmonoid_def IsAssociative_def by auto\n        from sub MR have \"xi\\<cdot>y:M``(I\\<times>J)\"\n          using func_imagedef[of M \"R\\<times>R\" R \"I\\<times>J\"] y mi1(2) by auto\n        then have \"xi\\<cdot>y:I\\<cdot>\\<^sub>IJ\" using generated_ideal_contains_set[of \"M``(I\\<times>J)\"]\n          func1_1_L6(2)[OF MR] productIdeal_def ij(1,2) by auto\n        with ij(3) have \"xi\\<cdot>y:Q\" by auto\n        ultimately have \"y\\<in>Q\" using MI ideal_dest_sum by force\n      }\n      then have \"J \\<subseteq> Q\" by auto\n      with K have False by auto\n    }\n    then have \"(I\\<subseteq>Q)\\<or>(J\\<subseteq>Q)\" by auto\n  }\n  then have \"\\<forall>I\\<in>\\<I>. \\<forall>J\\<in>\\<I>. I \\<cdot>\\<^sub>I J \\<subseteq> Q \\<longrightarrow> (I \\<subseteq> Q \\<or> J \\<subseteq> Q)\" by auto\n  then show ?thesis using assms unfolding maximalIdeal_def primeIdeal_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1847
    },
    "1664": {
        "type": "lemma",
        "text": "text\\<open>Prime rings appear when the zero ideal is prime\\<close>\nlemma (in ring0) prime_ring_zero_prime_ideal:\n  assumes \"[R,A,M]{is a prime ring}\" \"R\\<noteq>{\\<zero>}\"\n  shows \"{\\<zero>}\\<triangleleft>\\<^sub>pR\"\nproof-\n  have MR:\"M:R\\<times>R\\<rightarrow>R\" using ringAssum unfolding IsAring_def\n    IsAmonoid_def IsAssociative_def by auto  \n  {\n    fix I J assume ij:\"I\\<in>\\<I>\" \"J\\<in>\\<I>\" \"I \\<cdot>\\<^sub>I J \\<subseteq> {\\<zero>}\"\n    from ij(1,2) have ij_rr:\"I\\<times>J \\<subseteq> R\\<times>R\" by auto\n    {\n      assume \"\\<not>(I\\<subseteq>{\\<zero>})\" \"\\<not>(J\\<subseteq>{\\<zero>})\"\n      then obtain xi xj where x:\"xi\\<noteq>\\<zero>\" \"xj\\<noteq>\\<zero>\" \"xi\\<in>I\" \"xj:J\" by auto\n      {\n        fix u assume \"u\\<in>R\"\n        with x(3) have \"xi\\<cdot>u\\<in>I\" using ij(1) ideal_dest_mult(1)\n          by auto\n        with x(4) have \"xi\\<cdot>u\\<cdot>xj:M``(I\\<times>J)\" using func_imagedef[OF MR]\n        ij_rr by auto\n        then have \"xi\\<cdot>u\\<cdot>xj:I \\<cdot>\\<^sub>I J\" using generated_ideal_contains_set[of \"M `` (I \\<times> J)\"]\n          func1_1_L6(2)[OF MR, of \"I\\<times>J\"] productIdeal_def ij(1,2)\n          by auto\n        with ij(3) have \"xi\\<cdot>u\\<cdot>xj = \\<zero>\" by auto\n      }\n      then have \"\\<forall>u\\<in>R. xi\\<cdot>u\\<cdot>xj = \\<zero>\" by auto moreover\n      have \"xi\\<in>R\" \"xj\\<in>R\" using ij(1,2) x(3,4) by auto\n      moreover note assms(1) ultimately have False\n        using x(1,2) unfolding primeRing_def[OF ringAssum] by auto\n    }\n    then have \"I\\<subseteq>{\\<zero>} \\<or> J\\<subseteq>{\\<zero>}\" by auto\n  }\n  then have \"\\<forall>I\\<in>\\<I>. \\<forall>J\\<in>\\<I>. I \\<cdot>\\<^sub>I J \\<subseteq> {\\<zero>} \\<longrightarrow> (I \\<subseteq> {\\<zero>} \\<or> J \\<subseteq> {\\<zero>})\" by auto\n  moreover\n  note zero_ideal assms(2) ultimately\n  show ?thesis unfolding primeIdeal_def by auto\nqed\n",
        "assumes": "assumes \"{\\<zero>}\\<triangleleft>\\<^sub>pR\"\n  ",
        "using": [
            "ringAssum",
            "IsAring_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "generated_ideal_is_ideal",
            "ideal_dest_subset",
            "as(1,2)",
            "as(2)",
            "as(3)",
            "Ring_ZF_1_L11(2)",
            "yzq(1-2)",
            "q",
            "`u:R`",
            "as(1)",
            "Ring_ZF_1_L4(3)",
            "yzq(1)",
            "yzq(2)",
            "Ring_ZF_1_L6(1)",
            "ring_oper_distr(1)",
            "st(1,2)",
            "Ring_ZF_1_L3(3)",
            "Ring_ZF_1_L2(1)",
            "Ring_ZF_1_L2(2)",
            "Ring_ZF_1_L3(5)",
            "q(3)",
            "ideal_dest_mult(2)",
            "q(1-2)",
            "q3",
            "q4",
            "yy(2)",
            "Ring_ZF_1_L6(2)",
            "q(1)",
            "ring_oper_distr(2)",
            "q(1,2)",
            "`q3:?Y`",
            "func_imagedef[OF",
            "MR",
            "XY]",
            "generated_ideal_small",
            "zero_ideal",
            "productIdeal_def",
            "assms",
            "primeIdeal_def",
            "generated_ideal_contains_set"
        ],
        "statement": "lemma (in ring0) zero_prime_ideal_prime_ring:\n  assumes \"{\\<zero>}\\<triangleleft>\\<^sub>pR\"\n  shows \"[R,A,M]{is a prime ring}\"\n",
        "proof": "proof-\n  have MR:\"M:R\\<times>R\\<rightarrow>R\" using ringAssum unfolding IsAring_def\n    IsAmonoid_def IsAssociative_def by auto  \n  {\n    fix x y z assume as:\"x\\<in>R\" \"y\\<in>R\" \"\\<forall>z\\<in>R. x\\<cdot>z\\<cdot>y = \\<zero>\"\n    let ?X=\"\\<langle>{x}\\<rangle>\\<^sub>I\"\n    let ?Y=\"\\<langle>{y}\\<rangle>\\<^sub>I\"\n    have \"?X\\<subseteq>R\" \"?Y\\<subseteq>R\" using generated_ideal_is_ideal\n      ideal_dest_subset as(1,2) by auto\n    then have XY:\"?X\\<times>?Y \\<subseteq> R\\<times>R\" by auto\n    let ?P=\"\\<lambda>q. (\\<forall>z\\<in>?Y. q\\<cdot>z = \\<zero>)\"\n    let ?Q=\"\\<lambda>q. (\\<forall>z\\<in>R. x\\<cdot>z\\<cdot>q =\\<zero>)\"\n    have Y:\"\\<forall>y\\<in>?Y. ?Q(y)\"\n    proof(rule induction_generated_ideal)\n      show \"{y}\\<subseteq>R\" \"{y}\\<noteq>0\" using as(2) by auto\n      show \"\\<forall>xa\\<in>{y}. \\<forall>z\\<in>R. x \\<cdot> z \\<cdot> xa = \\<zero>\" using as(3) by auto\n      {\n        fix s t q assume yzq:\"s:R\" \"t:R\" \"q:\\<langle>{y}\\<rangle>\\<^sub>I\" \"\\<forall>k\\<in>R. x \\<cdot> k \\<cdot> q = \\<zero>\"\n        from yzq(3) have q:\"q\\<in>R\" using generated_ideal_is_ideal\n          ideal_dest_subset as(2) by auto\n        {\n          fix u assume \"u:R\"\n          have \"x \\<cdot> u \\<cdot> (s \\<cdot> q \\<cdot> t) = (x \\<cdot> (u\\<cdot>s)\\<cdot>q)\\<cdot>t\"\n            using Ring_ZF_1_L11(2) yzq(1-2) q `u:R` as(1) Ring_ZF_1_L4(3)\n            by auto\n          moreover have \"u\\<cdot>s:R\" using `u:R` yzq(1) Ring_ZF_1_L4(3) by auto\n          moreover note yzq(4) ultimately\n          have \"x \\<cdot> u \\<cdot> (s \\<cdot> q \\<cdot> t) = \\<zero>\\<cdot>t\" by auto\n          then have \"x \\<cdot> u \\<cdot> (s \\<cdot> q \\<cdot> t) = \\<zero>\" using yzq(2) Ring_ZF_1_L6(1) by auto\n        }\n        then have \"\\<forall>za\\<in>R. x \\<cdot> za \\<cdot> (s \\<cdot> q \\<cdot> t) = \\<zero>\" by auto\n      }\n      then show \"\\<forall>t\\<in>R. \\<forall>z\\<in>R. \\<forall>q\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. (\\<forall>z\\<in>R. x \\<cdot> z \\<cdot> q = \\<zero>) \\<longrightarrow> (\\<forall>za\\<in>R. x \\<cdot> za \\<cdot> (t \\<cdot> q \\<cdot> z) = \\<zero>)\" by auto\n      {\n        fix s t assume st:\"s:R\" \"t:R\" \"\\<forall>k\\<in>R. x \\<cdot> k \\<cdot> s = \\<zero>\"  \"\\<forall>k\\<in>R. x \\<cdot> k \\<cdot> t = \\<zero>\"\n        {\n          fix u assume \"u:R\"\n          have \"x \\<cdot> u \\<cdot> (s \\<ra> t) = (x \\<cdot> u \\<cdot> s) \\<ra>(x \\<cdot> u \\<cdot> t)\"\n            using ring_oper_distr(1) `u:R` as(1) st(1,2) Ring_ZF_1_L4(3) by auto\n          with st(3,4) `u:R` have \"x \\<cdot> u \\<cdot> (s \\<ra> t) = \\<zero> \\<ra> \\<zero>\" by auto\n          then have \"x \\<cdot> u \\<cdot> (s \\<ra> t) = \\<zero>\" using Ring_ZF_1_L3(3) Ring_ZF_1_L2(1) by auto\n        }\n        then have \"\\<forall>za\\<in>R. x \\<cdot> za \\<cdot> (s \\<ra> t) = \\<zero>\" by auto\n      }\n      then show \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. (\\<forall>z\\<in>R. x \\<cdot> z \\<cdot> y = \\<zero>) \\<and> (\\<forall>za\\<in>R. x \\<cdot> za \\<cdot> z = \\<zero>) \\<longrightarrow>\n                 (\\<forall>za\\<in>R. x \\<cdot> za \\<cdot> (y \\<ra> z) = \\<zero>)\" by auto\n    qed\n    {\n      fix yy assume \"yy:?Y\"\n      with Y have \"\\<forall>z\\<in>R. x \\<cdot> z \\<cdot> yy = \\<zero>\" by auto\n      then have \"x\\<cdot>yy = \\<zero>\" using Ring_ZF_1_L2(2) Ring_ZF_1_L3(5)\n        as(1) by auto\n    }\n    then have z:\"\\<forall>y\\<in>?Y. x\\<cdot>y = \\<zero>\" by auto\n    have yy:\"?Y\\<triangleleft>R\" \"?Y \\<subseteq> R\" using generated_ideal_is_ideal as(2)\n            ideal_dest_subset by auto      \n    have xy:\"\\<forall>y\\<in>?X. ?P(y)\"\n    proof(rule induction_generated_ideal)\n      show \"{x}\\<subseteq>R\" \"{x}\\<noteq>0\" using as(1) by auto\n      from z show \"\\<forall>x\\<in>{x}. \\<forall>z\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. x \\<cdot> z = \\<zero>\" by auto\n      {\n        fix q1 q2 q3 assume q:\"q1:R\" \"q2:R\" \"q3:\\<langle>{x}\\<rangle>\\<^sub>I\"\n          \"\\<forall>k\\<in>?Y. q3 \\<cdot> k = \\<zero>\"\n        have q3:\"q3\\<in>R\" using q(3) generated_ideal_is_ideal as(1)\n          ideal_dest_subset by auto\n        {\n          fix q4 assume q4:\"q4\\<in>?Y\"\n          from yy q4 q(2) have \"q2 \\<cdot> q4 :?Y\" using ideal_dest_mult(2) by auto\n          moreover have \"q1 \\<cdot> q3 \\<cdot> q2 \\<cdot> q4 = q1 \\<cdot> (q3 \\<cdot> (q2 \\<cdot> q4))\"\n            using q(1-2) q3 q4 yy(2) Ring_ZF_1_L4(3) Ring_ZF_1_L11(2) by auto\n          moreover note q(4) ultimately\n          have \"q1 \\<cdot> q3 \\<cdot> q2 \\<cdot> q4 = q1 \\<cdot> \\<zero>\" by auto\n          then have \"q1 \\<cdot> q3 \\<cdot> q2 \\<cdot> q4 = \\<zero>\" using Ring_ZF_1_L6(2) q(1) by auto\n        }\n        then have \"\\<forall>za\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. q1 \\<cdot> q3 \\<cdot> q2 \\<cdot> za = \\<zero>\" by auto\n      }\n      then show \"\\<forall>ya\\<in>R. \\<forall>z\\<in>R. \\<forall>q\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. (\\<forall>z\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. q \\<cdot> z = \\<zero>) \\<longrightarrow>\n                    (\\<forall>za\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. ya \\<cdot> q \\<cdot> z \\<cdot> za = \\<zero>)\" by auto\n      {\n        fix q1 q2 assume q:\"q1:R\" \"q2:R\" \"\\<forall>z\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. q1 \\<cdot> z = \\<zero>\" \"\\<forall>za\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. q2 \\<cdot> za = \\<zero>\"\n        {\n          fix q3 assume \"q3\\<in>?Y\"\n          have \"(q1 \\<ra> q2) \\<cdot> q3 = (q1\\<cdot>q3) \\<ra> (q2\\<cdot>q3)\" using ring_oper_distr(2)\n            q(1,2) `q3:?Y` yy(2) by auto\n          with q(3,4) have \"(q1 \\<ra> q2) \\<cdot> q3 = \\<zero> \\<ra> \\<zero>\" using `q3:?Y` by auto\n          then have \"(q1 \\<ra> q2) \\<cdot> q3 = \\<zero>\" using Ring_ZF_1_L3(3) Ring_ZF_1_L2(1) by auto\n        }\n        then have \"\\<forall>q\\<in>?Y. (q1 \\<ra> q2) \\<cdot> q = \\<zero>\" by auto\n      }\n      then show \"\\<forall>ya\\<in>R.\n       \\<forall>z\\<in>R. (\\<forall>z\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. ya \\<cdot> z = \\<zero>) \\<and> (\\<forall>za\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. z \\<cdot> za = \\<zero>) \\<longrightarrow>\n              (\\<forall>za\\<in>\\<langle>{y}\\<rangle>\\<^sub>I. (ya \\<ra> z) \\<cdot> za = \\<zero>)\" by auto\n    qed\n    {\n      fix q assume \"q\\<in>M``(?X\\<times>?Y)\"\n      then obtain qx qy where q:\"qx:?X\" \"qy:?Y\" \"q=qx\\<cdot>qy\"\n        using func_imagedef[OF MR XY] by auto\n      with xy have \"q=\\<zero>\" by auto\n    }\n    then have \"M``(?X\\<times>?Y) \\<subseteq> {\\<zero>}\" by auto\n    then have \"?X\\<cdot>\\<^sub>I?Y \\<subseteq> {\\<zero>}\" using generated_ideal_small\n      zero_ideal productIdeal_def generated_ideal_is_ideal\n      as(1,2) by auto\n    then have \"?X \\<subseteq> {\\<zero>} \\<or> ?Y \\<subseteq> {\\<zero>}\" using assms unfolding primeIdeal_def\n      using generated_ideal_is_ideal as(1,2) ideal_dest_subset by auto\n    then have \"x=\\<zero> \\<or> y =\\<zero>\" using generated_ideal_contains_set\n      as(1,2) by auto\n  }\n  then have \" \\<forall>x\\<in>R. \\<forall>y\\<in>R. (\\<forall>z\\<in>R. x \\<cdot> z \\<cdot> y = \\<zero>) \\<longrightarrow> x = \\<zero> \\<or> y = \\<zero>\" by auto\n  then show ?thesis unfolding primeRing_def[OF ringAssum] by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1848
    },
    "1665": {
        "type": "theorem",
        "text": "text\\<open>We can actually use this definition of a prime ring,\nas a condition to check for prime ideals.\\<close>\n",
        "assumes": "assumes \"P\\<triangleleft>\\<^sub>pR\"\n  ",
        "using": [
            "generated_ideal_is_ideal[THEN",
            "ideal_dest_subset]",
            "as(1)",
            "Ring_ZF_1_L4(3)",
            "assms",
            "primeIdeal_def",
            "ideal_dest_mult(2)",
            "Ring_ZF_1_L11(2)",
            "ass(1,2,5)",
            "as(2)",
            "q",
            "ideal_dest_sum",
            "ring_oper_distr(2)",
            "ass(1-3)",
            "induction_generated_ideal[of",
            "\"{x}\"",
            "\"\\<lambda>t.",
            "\\<forall>u\\<in>R.",
            "t\\<cdot>u\\<cdot>y",
            "\\<in>",
            "P\"]",
            "generated_ideal_is_ideal",
            "ideal_dest_subset",
            "as(1,2)",
            "ass(2)",
            "ideal_dest_mult(1)",
            "ass(1,2,6)",
            "qt",
            "ring_oper_distr(1)",
            "`t\\<in>R`",
            "ass(4,2,1)",
            "Ring_ZF_1_L11",
            "ass(1,2,4)",
            "Ring_ZF_1_L4(1)",
            "\"{y}\"",
            "\"\\<lambda>q.",
            "\\<forall>t\\<in>?X.",
            "t\\<cdot>u\\<cdot>q",
            "func_imagedef[of",
            "M",
            "\"R\\<times>R\"",
            "R",
            "\"?X\\<times>?Y\"]",
            "subprd",
            "ringAssum",
            "IsAring_def",
            "IsAmonoid_def",
            "IsAssociative_def",
            "Ring_ZF_1_L2(2)",
            "Ring_ZF_1_L3(5)",
            "t(3)",
            "generated_ideal_small",
            "productIdeal_def[",
            "OF",
            "generated_ideal_is_ideal]",
            "generated_ideal_contains_set"
        ],
        "statement": "theorem (in ring0) equivalent_prime_ideal:\n  assumes \"P\\<triangleleft>\\<^sub>pR\"\n  shows \"\\<forall>x\\<in>R. \\<forall>y\\<in>R. (\\<forall>z\\<in>R. x\\<cdot>z\\<cdot>y\\<in>P) \\<longrightarrow> x\\<in>P \\<or> y\\<in>P\"\n",
        "proof": "proof(safe)\n  fix x y assume as:\"x\\<in>R\" \"y\\<in>R\" \"\\<forall>z\\<in>R. x\\<cdot>z\\<cdot>y\\<in>P\" \"y\\<notin>P\"\n  let ?X=\"\\<langle>{x}\\<rangle>\\<^sub>I\"\n  let ?Y=\"\\<langle>{y}\\<rangle>\\<^sub>I\"\n  from as(3) have \"\\<forall>x\\<in>{x}. \\<forall>u\\<in>R. x \\<cdot> u \\<cdot> y \\<in> P\" by auto moreover\n  have \"\\<forall>ya\\<in>R.\n     \\<forall>z\\<in>R. \\<forall>q\\<in>?X. (\\<forall>u\\<in>R. q \\<cdot> u \\<cdot> y \\<in> P) \\<longrightarrow> (\\<forall>u\\<in>R. ya \\<cdot> q \\<cdot> z \\<cdot> u \\<cdot> y \\<in> P)\"\n  proof(safe)\n    fix ya z q u assume ass:\"ya\\<in>R\" \"z\\<in>R\" \"q\\<in>?X\" \"\\<forall>u\\<in>R. q \\<cdot> u \\<cdot> y \\<in> P\" \"u \\<in> R\"\n    from ass(3) have q:\"q\\<in>R\" using generated_ideal_is_ideal[THEN ideal_dest_subset]\n      as(1) by auto\n    from ass(2,5) have \"z\\<cdot>u\\<in>R\" using Ring_ZF_1_L4(3) by auto\n    with ass(4) have \"q\\<cdot>(z\\<cdot>u)\\<cdot>y:P\" by auto\n    with ass(1) have \"ya\\<cdot>(q\\<cdot>(z\\<cdot>u)\\<cdot>y)\\<in>P\" using assms\n      unfolding primeIdeal_def using ideal_dest_mult(2) by auto\n    then show \"ya\\<cdot>q\\<cdot>z\\<cdot>u\\<cdot>y\\<in>P\" using Ring_ZF_1_L4(3)\n      Ring_ZF_1_L11(2) ass(1,2,5) as(2) q by auto\n  qed\n  moreover\n  have \"\\<forall>ya\\<in>R.\n     \\<forall>z\\<in>R. (\\<forall>u\\<in>R. ya \\<cdot> u \\<cdot> y \\<in> P) \\<and> (\\<forall>u\\<in>R. z \\<cdot> u \\<cdot> y \\<in> P) \\<longrightarrow>\n            (\\<forall>u\\<in>R. (ya \\<ra> z) \\<cdot> u \\<cdot> y \\<in> P)\"\n  proof(safe)\n    fix ya z u assume ass:\"ya\\<in>R\" \"z\\<in>R\" \"u\\<in>R\"\n      \"\\<forall>u\\<in>R. ya \\<cdot> u \\<cdot> y \\<in> P\" \"\\<forall>u\\<in>R. z \\<cdot> u \\<cdot> y \\<in> P\"\n    from ass(3-5) have \"ya \\<cdot> u \\<cdot> y \\<in> P\" \"z \\<cdot> u \\<cdot> y \\<in> P\" by auto\n    then have \"(ya \\<cdot> u \\<cdot> y)\\<ra>(z \\<cdot> u \\<cdot> y) \\<in> P\" using\n      ideal_dest_sum assms unfolding primeIdeal_def by auto\n    then have \"((ya\\<cdot>u)\\<ra>(z\\<cdot>u))\\<cdot>y\\<in>P\" using ring_oper_distr(2)\n      as(2) Ring_ZF_1_L4(3) ass(1-3) by auto\n    then show \"((ya\\<ra>z)\\<cdot>u)\\<cdot>y\\<in>P\" using ring_oper_distr(2)\n      ass(1-3) by auto\n  qed\n  ultimately have R:\"\\<forall>ya\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. ya \\<cdot> u \\<cdot> y \\<in> P\"\n    using induction_generated_ideal[of \"{x}\" \"\\<lambda>t. \\<forall>u\\<in>R. t\\<cdot>u\\<cdot>y \\<in> P\"]\n    as(1) by auto\n  then have \"\\<forall>xa\\<in>{y}. \\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> xa \\<in> P\" by auto moreover\n  have \"\\<forall>ya\\<in>R.\n     \\<forall>z\\<in>R. \\<forall>q\\<in>\\<langle>{y}\\<rangle>\\<^sub>I.\n               (\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> q \\<in> P) \\<longrightarrow>\n               (\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> (ya \\<cdot> q \\<cdot> z) \\<in> P)\"\n  proof(safe)\n    fix ya z q t u assume ass:\"ya\\<in>R\" \"z\\<in>R\" \"q\\<in>?Y\" \"\\<forall>t\\<in>?X. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> q \\<in> P\"\n      \"t\\<in>?X\" \"u\\<in>R\"\n    from ass(3,5) have qt:\"q:R\" \"t\\<in>R\" using generated_ideal_is_ideal\n      ideal_dest_subset as(1,2) by auto\n    from ass(1,6) have \"u\\<cdot>ya:R\" using Ring_ZF_1_L4(3) by auto\n    with ass(4,5) have \"t\\<cdot>(u\\<cdot>ya)\\<cdot>q \\<in>P\" by auto\n    then have \"(t\\<cdot>(u\\<cdot>ya)\\<cdot>q)\\<cdot>z\\<in>P\" using ass(2) assms\n      ideal_dest_mult(1) unfolding primeIdeal_def by auto\n    then show \"t \\<cdot> u \\<cdot> (ya \\<cdot> q \\<cdot> z) \\<in>P\" using\n      Ring_ZF_1_L4(3) Ring_ZF_1_L11(2) ass(1,2,6) qt by auto\n  qed moreover\n  have \"\\<forall>y\\<in>R. \\<forall>z\\<in>R. (\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> y \\<in> P) \\<and>\n               (\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> z \\<in> P) \\<longrightarrow>\n               (\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> (y \\<ra> z) \\<in> P)\"\n  proof(safe)\n    fix ya z t u assume ass:\"ya\\<in>R\" \"z\\<in>R\" \"t\\<in>?X\" \"u\\<in>R\"\n      \"\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> ya \\<in> P\" \"\\<forall>t\\<in>\\<langle>{x}\\<rangle>\\<^sub>I. \\<forall>u\\<in>R. t \\<cdot> u \\<cdot> z \\<in> P\"\n    from ass(3) have \"t\\<in>R\" using ideal_dest_subset generated_ideal_is_ideal\n      as(1) by auto\n    from ass(3-6) have \"t \\<cdot> u \\<cdot> ya \\<in> P\" \"t \\<cdot> u \\<cdot> z \\<in> P\" by auto\n    then have \"(t \\<cdot> u \\<cdot> ya)\\<ra>(t \\<cdot> u \\<cdot> z) \\<in>P\" using assms\n      unfolding primeIdeal_def using ideal_dest_sum by auto\n    then have \"t\\<cdot>((u\\<cdot>ya)\\<ra>(u\\<cdot>z)) \\<in>P\" using ring_oper_distr(1)\n      `t\\<in>R` Ring_ZF_1_L4(3) ass(4,2,1) Ring_ZF_1_L11 by auto\n    then have \"t\\<cdot>(u\\<cdot>(ya\\<ra>z)) \\<in>P\" using ring_oper_distr(1)\n      ass(1,2,4) by auto\n    then show \"t\\<cdot>u\\<cdot>(ya\\<ra>z) \\<in>P\" using Ring_ZF_1_L11(2)\n      Ring_ZF_1_L4(1) ass(1,2,4) `t\\<in>R` by auto\n  qed\n  ultimately have R:\"\\<forall>q\\<in>?Y. \\<forall>t\\<in>?X. \\<forall>u\\<in>R. t\\<cdot>u\\<cdot>q \\<in> P\"\n    using induction_generated_ideal[of \"{y}\" \"\\<lambda>q. \\<forall>t\\<in>?X. \\<forall>u\\<in>R. t\\<cdot>u\\<cdot>q \\<in> P\"]\n    as(2) by auto\n  have \"?X\\<subseteq>R\" \"?Y\\<subseteq>R\" using ideal_dest_subset\n    generated_ideal_is_ideal as(1,2) by auto\n  then have subprd:\"?X\\<times>?Y \\<subseteq> R\\<times>R\" by auto\n  {\n    fix t assume \"t\\<in>M``(?X\\<times>?Y)\"\n    then obtain tx ty where t:\"tx\\<in>?X\" \"ty\\<in>?Y\" \"t= tx\\<cdot>ty\"\n      using func_imagedef[of M \"R\\<times>R\" R \"?X\\<times>?Y\"]\n        subprd ringAssum unfolding IsAring_def\n        IsAmonoid_def IsAssociative_def by auto\n    from this(1,2) have \"tx\\<cdot>\\<one>\\<cdot>ty \\<in>P\" using R Ring_ZF_1_L2(2)\n      by auto moreover\n    from t(1) have \"tx\\<in>R\" using generated_ideal_is_ideal[THEN\n          ideal_dest_subset] as(1) by auto\n    ultimately have \"t\\<in>P\" using Ring_ZF_1_L3(5) t(3) by auto\n  }\n  then have \"M``(?X\\<times>?Y) \\<subseteq> P\" by auto\n  then have \"?X\\<cdot>\\<^sub>I?Y \\<subseteq> P\" using generated_ideal_small\n    assms unfolding primeIdeal_def using productIdeal_def[\n        OF generated_ideal_is_ideal generated_ideal_is_ideal]\n    as(1,2) by auto moreover\n  have \"?X:\\<I>\" \"?Y:\\<I>\"\n    using generated_ideal_is_ideal generated_ideal_is_ideal[THEN ideal_dest_subset]\n    as(1,2) by auto\n  ultimately have \"?X \\<subseteq> P \\<or> ?Y \\<subseteq> P\" using assms\n    unfolding primeIdeal_def by auto\n  with as(4) generated_ideal_contains_set as(2)\n  have \"?X \\<subseteq> P\" by auto\n  then show \"x\\<in>P\" using generated_ideal_contains_set as(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1849
    },
    "1666": {
        "type": "lemma",
        "text": "text\\<open>Any ideal is a normal subgroup\\<close>\n",
        "assumes": "assumes \"I\\<triangleleft>R\"\n  ",
        "using": [
            "Group_ZF_2_4_L6(1)",
            "ringAssum",
            "IsAring_def",
            "assms",
            "Ideal_def"
        ],
        "statement": "lemma (in ring0) ideal_normal_add_subgroup:\n  assumes \"I\\<triangleleft>R\"\n  shows \"IsAnormalSubgroup(R,A,I)\"\n  ",
        "proof": "using Group_ZF_2_4_L6(1) using ringAssum\n  unfolding IsAring_def using assms unfolding Ideal_def by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1850
    },
    "1667": {
        "type": "definition",
        "text": "text\\<open>The multiplicative monoid is congruent with the quotient relation\nand gives rise to a monoid in the quotient\\<close>\nlemma (in ring0) quotientBy_mul_monoid:\n  assumes \"I\\<triangleleft>R\"\n  shows \"Congruent2(QuotientGroupRel(R, A, I),M)\" and\n \"IsAmonoid(QuotientBy(I),ProjFun2(R, QuotientGroupRel(R,A,I), M))\"\nproof-\n  {\n    fix x y s t assume \"\\<langle>x,y\\<rangle>\\<in>QuotientGroupRel(R,A,I)\" \"\\<langle>s,t\\<rangle>\\<in>QuotientGroupRel(R,A,I)\"\n    then have xyst:\"x\\<in>R\" \"y\\<in>R\" \"s\\<in>R\" \"t\\<in>R\" \"x\\<rs>y \\<in>I\" \"s\\<rs>t \\<in>I\"\n      unfolding QuotientGroupRel_def by auto\n    have \"(x\\<cdot>s)\\<rs>(y\\<cdot>t) = (x\\<cdot>s)\\<ra>\\<zero>\\<rs>(y\\<cdot>t)\"\n      using Ring_ZF_1_L3(3) Ring_ZF_1_L4(3)[OF xyst(1,3)] by auto\n    then have \"(x\\<cdot>s)\\<rs>(y\\<cdot>t) = ((x\\<cdot>s)\\<ra>((\\<rm>(y\\<cdot>s))\\<ra>(y\\<cdot>s)))\\<rs>(y\\<cdot>t)\"\n      using Ring_ZF_1_L3(7)[of \"y\\<cdot>s\"] Ring_ZF_1_L4(3)[OF xyst(2,3)] \n        Ring_ZF_1_L4(4)[of \"\\<rm>(y\\<cdot>s)\" \"y\\<cdot>s\"] Ring_ZF_1_L3(1)[of \"y\\<cdot>s\"]\n      by auto\n    then have \"(x\\<cdot>s)\\<rs>(y\\<cdot>t) = ((x\\<cdot>s)\\<rs>(y\\<cdot>s))\\<ra>((y\\<cdot>s)\\<rs>(y\\<cdot>t))\"\n      using Ring_ZF_1_L3(1) Ring_ZF_1_L4(1,2) \n          Ring_ZF_1_L10(1)[of \"x\\<cdot>s\" \"\\<rm>(y\\<cdot>s)\" \"y\\<cdot>s\"] \n          Ring_ZF_1_L10(1)[of \"(x\\<cdot>s)\\<rs>(y\\<cdot>s)\" \"y\\<cdot>s\" \"\\<rm>(y\\<cdot>t)\"]\n          Ring_ZF_1_L4(3)[OF xyst(1,3)] Ring_ZF_1_L4(3)[OF xyst(2,3)]\n          Ring_ZF_1_L4(3)[OF xyst(2,4)] by auto\n    then have \"(x\\<cdot>s)\\<rs>(y\\<cdot>t) = ((x\\<rs>y)\\<cdot>s)\\<ra>(y\\<cdot>(s\\<rs>t))\"\n      using Ring_ZF_1_L8 xyst(1-4) by auto\n    moreover\n    have \"(x\\<rs>y)\\<cdot>s \\<in>I\" using xyst(3,5) assms\n      ideal_dest_mult(1) by auto\n    moreover\n    have \"y\\<cdot>(s\\<rs>t) \\<in>I\" using xyst(2,6) assms\n      ideal_dest_mult(2) by auto\n    ultimately have \"(x\\<cdot>s)\\<rs>(y\\<cdot>t) \\<in>I\" using assms\n      ideal_dest_sum by auto\n    then have \"\\<langle>M ` \\<langle>x, s\\<rangle>, M ` \\<langle>y, t\\<rangle>\\<rangle> \\<in> QuotientGroupRel(R, A, I)\"\n      unfolding QuotientGroupRel_def using Ring_ZF_1_L4(3)\n      xyst(1-4) by auto\n  }\n  then show \"Congruent2(QuotientGroupRel(R, A, I),M)\"\n    unfolding Congruent2_def by auto moreover\n  have \"equiv(R,QuotientGroupRel(R,A,I))\" using add_group.Group_ZF_2_4_L3\n    assms unfolding Ideal_def by auto\n  moreover note mult_monoid.Group_ZF_2_2_T1\n  ultimately show \"IsAmonoid(QuotientBy(I),ProjFun2(R, QuotientGroupRel(R,A,I), M))\" unfolding QuotientBy_def[OF assms] by auto\nqed\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) ideal_radd (\"_{\\<ra>_}_\") where\n  \"x{\\<ra>I}y \\<equiv> QuotientGroupOp(R, A, I)`\\<langle>x,y\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1851
    },
    "1668": {
        "type": "definition",
        "text": "text\\<open>An import property satisfied by many important rings is\nbeing Noetherian: every ideal is finitely generated.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) isFinGen (\"_{is finitely generated}\") where\n\"I\\<triangleleft>R \\<Longrightarrow> I{is finitely generated} \\<equiv> \\<exists>S\\<in>FinPow(R). I = \\<langle>S\\<rangle>\\<^sub>I\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1852
    },
    "1669": {
        "type": "theorem",
        "text": "text\\<open>For noetherian rings the arbitrary sum can be reduced\nto the sum of a finite subset of the initial set of ideals\\<close>\n",
        "assumes": "assumes \"\\<forall>I\\<in>\\<I>. (I{is finitely generated})\" \"\\<J> \\<subseteq> \\<I>\"\n  ",
        "using": [
            "generated_ideal_is_ideal[of",
            "\"\\<Union>\\<J>\"]",
            "assms(2)",
            "sumArbitraryIdeals_def[OF",
            "assms(2)]",
            "ideal_dest_subset",
            "eqpoll_iff",
            "finite_choice",
            "lamE",
            "generated_ideal_contains_set",
            "S(1)",
            "FinPow_def",
            "sum_ideals_finite_sum[OF",
            "x(1)",
            "Finite1_L6A[of",
            "f",
            "S",
            "_",
            "S]",
            "Finite_Fin_iff",
            "fins",
            "Fin_into_Finite",
            "Finite_Union",
            "func_imagedef[OF",
            "f_Fun]",
            "f(2)",
            "sub",
            "generated_ideal_is_ideal[OF",
            "sub]",
            "generated_ideal_small",
            "J(1)",
            "sumArbitraryIdeals_def",
            "C",
            "generated_ideal_small[",
            "OF",
            "sub]]",
            "C]",
            "generated_ideal_contains_set[of",
            "generated_ideal_small[OF",
            "generated_ideal_is_ideal]"
        ],
        "statement": "theorem (in ring0) sum_ideals_noetherian:\n  assumes \"\\<forall>I\\<in>\\<I>. (I{is finitely generated})\" \"\\<J> \\<subseteq> \\<I>\"\n  shows \"\\<exists>\\<T>\\<in>FinPow(\\<J>). (\\<oplus>\\<^sub>I\\<J>) = (\\<oplus>\\<^sub>I\\<T>)\"\n",
        "proof": "proof-\n  have JR:\"(\\<oplus>\\<^sub>I\\<J>)\\<triangleleft>R\" using generated_ideal_is_ideal[of \"\\<Union>\\<J>\"]\n    assms(2) unfolding sumArbitraryIdeals_def[OF assms(2)]\n    by auto\n  with assms(1) have \"(\\<oplus>\\<^sub>I\\<J>) {is finitely generated}\"\n    using ideal_dest_subset by auto\n  then obtain S where S:\"S\\<in>FinPow(R)\" \"(\\<oplus>\\<^sub>I\\<J>) = \\<langle>S\\<rangle>\\<^sub>I\"\n    unfolding isFinGen_def[OF JR] by auto\n  from this(1) have fins:\"Finite(S)\" unfolding FinPow_def\n    by auto\n  then obtain n where n:\"n\\<in>nat\" \"S\\<approx>n\" unfolding Finite_def by auto\n  then have \"S\\<lesssim>n\" using eqpoll_iff by auto moreover\n  let ?N = \"\\<lambda>s\\<in>S. {J\\<in>FinPow(\\<J>). s\\<in>(\\<oplus>\\<^sub>IJ)}\"\n  from n(1) have \"{the axiom of} n {choice holds}\" using finite_choice\n    by auto\n  ultimately have \"(\\<forall>t\\<in>S. ?N ` t \\<noteq> 0) \\<longrightarrow>\n           (\\<exists>f. f \\<in> (\\<Prod>t\\<in>S. ?N ` t) \\<and> (\\<forall>t\\<in>S. f ` t \\<in> ?N ` t))\"\n    unfolding AxiomCardinalChoiceGen_def by blast moreover\n  {\n    fix t assume t:\"t\\<in>S\"\n    then have \"?N`t = {J\\<in>FinPow(\\<J>). t\\<in>(\\<oplus>\\<^sub>IJ)}\" using lamE by auto\n    moreover from t have \"t\\<in>\\<langle>S\\<rangle>\\<^sub>I\" using generated_ideal_contains_set\n      S(1) unfolding FinPow_def by auto\n    with S(2) have \"t\\<in>(\\<oplus>\\<^sub>I\\<J>)\" by auto\n    ultimately have \"?N`t\\<noteq>0\" using sum_ideals_finite_sum[OF assms(2)]\n      by auto\n  }\n  ultimately obtain f where f:\"f:(\\<Prod>t\\<in>S. ?N ` t)\" \"\\<forall>t\\<in>S. f ` t \\<in> ?N ` t\"\n    by auto\n  {\n    fix y assume \"y\\<in>f``S\"\n    with image_iff obtain x where x:\"x\\<in>S\" \"\\<langle>x,y\\<rangle>\\<in>f\" by auto\n    with f(1) have \"y\\<in>?N`x\" unfolding Pi_def by auto\n    then have \"y:{J\\<in>FinPow(\\<J>). x\\<in>(\\<oplus>\\<^sub>IJ)}\" using x(1) lamE by auto\n    then have \"Finite(y)\" using lamE unfolding FinPow_def by auto\n  }\n  moreover \n  from f(1) have f_Fun:\"f:S\\<rightarrow> (\\<Union>{?N`t. t:S})\" unfolding Pi_def\n    Sigma_def by blast\n  then have \"Finite(f``S)\" using Finite1_L6A[of f S _ S]\n    Finite_Fin_iff fins Fin_into_Finite by auto\n  ultimately have A:\"Finite(\\<Union>(f``S))\" using Finite_Union by auto\n  {\n    fix t assume \"t\\<in>\\<Union>(f``S)\"\n    then obtain q where q:\"t\\<in>q\" \"q\\<in>f``S\" by auto\n    then obtain s where s:\"t\\<in>f`s\" \"s\\<in>S\" using\n      func_imagedef[OF f_Fun] by auto\n    from s(2) have J:\"f`s\\<in>FinPow(\\<J>)\" \"s\\<in>(\\<oplus>\\<^sub>I(f`s))\"\n      using f(2) lamE by auto\n    with s(1) have \"t:\\<J>\" unfolding FinPow_def by auto\n  }\n  with A have B:\"(\\<Union>(f``S)):FinPow(\\<J>)\" unfolding FinPow_def by auto\n  then have P:\"(\\<Union>(f``S)) \\<subseteq> \\<J>\" unfolding FinPow_def by auto\n  then have C:\"(\\<Union>(f``S)) \\<subseteq> \\<I>\" using assms(2) by auto\n  then have \"(\\<Union>(f``S)) \\<subseteq> Pow(R)\" by auto\n  then have sub:\"\\<Union>(\\<Union>(f``S)) \\<subseteq> R\" by auto\n  {\n    fix t assume t:\"t\\<in>S\"\n    then have J:\"f`t\\<in>FinPow(\\<J>)\" \"t\\<in>(\\<oplus>\\<^sub>I(f`t))\"\n      using f(2) lamE by auto\n    from t have \"\\<Union>(f`t) \\<subseteq> \\<Union>(\\<Union>(f``S))\" using func_imagedef[OF f_Fun]\n      by auto\n    then have \"\\<Union>(f`t) \\<subseteq> \\<langle>\\<Union>(\\<Union>(f``S))\\<rangle>\\<^sub>I\" using generated_ideal_contains_set\n      sub by blast\n    then have \"\\<langle>\\<Union>(f`t)\\<rangle>\\<^sub>I \\<subseteq> \\<langle>\\<Union>(\\<Union>(f``S))\\<rangle>\\<^sub>I\" using\n      generated_ideal_is_ideal[OF sub] generated_ideal_small\n      by auto\n    moreover have \"f`t \\<subseteq> \\<I>\" using J(1) assms(2) unfolding FinPow_def by auto\n    moreover note J(2) \n    ultimately have \"t\\<in>\\<langle>\\<Union>(\\<Union>(f``S))\\<rangle>\\<^sub>I\" using sumArbitraryIdeals_def\n      by auto\n    then have \"t\\<in>(\\<oplus>\\<^sub>I(\\<Union>(f``S)))\" using sumArbitraryIdeals_def\n      C by auto\n  }\n  then have \"S \\<subseteq> \\<oplus>\\<^sub>I(\\<Union>(f``S))\" by auto\n  then have \"\\<langle>S\\<rangle>\\<^sub>I \\<subseteq> \\<oplus>\\<^sub>I(\\<Union>(f``S))\" using generated_ideal_small[\n        OF _ generated_ideal_is_ideal[OF sub]]\n    sumArbitraryIdeals_def[OF C] by auto\n  with S(2) have \"(\\<oplus>\\<^sub>I\\<J>)\\<subseteq> \\<oplus>\\<^sub>I(\\<Union>(f `` S))\" by auto\n  moreover\n  from P have \"\\<Union>(\\<Union>(f``S)) \\<subseteq> \\<Union>\\<J>\" by auto\n  then have \"\\<Union>(\\<Union>(f``S)) \\<subseteq>\\<langle>\\<Union>\\<J>\\<rangle>\\<^sub>I\" using \n      generated_ideal_contains_set[of \"\\<Union>\\<J>\"]\n    assms(2) by blast\n  then have \"\\<langle>\\<Union>(\\<Union>(f``S))\\<rangle>\\<^sub>I \\<subseteq> \\<langle>\\<Union>\\<J>\\<rangle>\\<^sub>I\" using generated_ideal_small[OF _\n    generated_ideal_is_ideal] assms(2) by blast\n  then have \"(\\<oplus>\\<^sub>I(\\<Union>(f `` S))) \\<subseteq>(\\<oplus>\\<^sub>I\\<J>)\" unfolding \n    sumArbitraryIdeals_def[OF assms(2)]\n    sumArbitraryIdeals_def[OF C].\n  ultimately have \"(\\<oplus>\\<^sub>I\\<J>) = \\<oplus>\\<^sub>I(\\<Union>(f `` S))\" by auto\n  with B show ?thesis by auto\nqed\nend\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1853
    },
    "1670": {
        "type": "definition",
        "text": "text \\<open>This section studies the ideals of quotient rings,\nand defines ring homomorphisms.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  ringHomomor (\"_{is a ring homomorphism}{_,_,_}\\<rightarrow>{_,_,_}\" 85)\n  where \"IsAring(R,A,M) \\<Longrightarrow> IsAring(S,U,V) \\<Longrightarrow> ringHomomor(f,R,A,M,S,U,V) \\<equiv> \n    Homomor(f,R,A,S,U) \n    \\<and> (\\<forall>x\\<in>R. \\<forall>y\\<in>R. f`(M`\\<langle>x,y\\<rangle>) = V`\\<langle>f`x,f`y\\<rangle>) \n    \\<and> f`(TheNeutralElement(R,M)) = TheNeutralElement(S,V)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1854
    },
    "1671": {
        "type": "lemma",
        "text": "text\\<open>Even more, if the target ring of the homomorphism is commutative\nor the homomorphism is surjective; we show that if the ideal es prime,\nthen its preimage is also. Note that this is not true in general.\\<close>\n",
        "assumes": "assumes \"J\\<triangleleft>\\<^sub>pR\\<^sub>t\" \"V{is commutative on}S\"\n  ",
        "using": [
            "preimage_ideal",
            "assms",
            "target_ring.primeIdeal_def",
            "fun",
            "func1_1_L15",
            "origin_ring.Ring_ZF_1_L2(2).",
            "ultimately",
            "have",
            "\"\\<one>\\<^sub>R\\<in>{x\\<in>R.",
            "f`x",
            "\\<in>J}\"",
            "homomorphism",
            "ringHomomor_def[OF",
            "origin_ring.ringAssum",
            "target_ring.ringAssum]",
            "target_ring.ideal_with_one",
            "assms(2)",
            "IsCommutative_def",
            "apply_type[OF",
            "as(1)]",
            "target_ring.Ring_ZF_1_L11(2)",
            "as(2)]",
            "homomor_dest_mult[OF",
            "as(1,2)]",
            "origin_ring.Ring_ZF_1_L2(2)",
            "origin_ring.Ring_ZF_1_L3(5)[OF",
            "assms(1)",
            "target_ring.ideal_dest_mult(2)",
            "as(1)"
        ],
        "statement": "lemma (in ring_homo) preimage_prime_ideal_comm:\n  assumes \"J\\<triangleleft>\\<^sub>pR\\<^sub>t\" \"V{is commutative on}S\"\n  shows \"(f-``J)\\<triangleleft>\\<^sub>pR\\<^sub>o\" \n",
        "proof": "proof(rule origin_ring.equivalent_prime_ideal_2)\n  show \"(f-``J)\\<triangleleft>R\\<^sub>o\" using preimage_ideal assms unfolding target_ring.primeIdeal_def by auto\n  {\n    assume \"R = f-`` J\"\n    then have \"R = {x\\<in>R. f`x \\<in>J}\"\n      using fun func1_1_L15 by auto\n    moreover have \"\\<one>\\<^sub>R\\<in>R\" using origin_ring.Ring_ZF_1_L2(2).\n    ultimately have \"\\<one>\\<^sub>R\\<in>{x\\<in>R. f`x \\<in>J}\" by auto\n    then have \"f`(\\<one>\\<^sub>R) \\<in>J\" by auto\n    moreover have \"f`\\<one>\\<^sub>R = \\<one>\\<^sub>S\" using homomorphism\n      unfolding ringHomomor_def[OF origin_ring.ringAssum\n          target_ring.ringAssum] by auto\n    ultimately have \"\\<one>\\<^sub>S \\<in> J\" by auto\n    then have False using target_ring.ideal_with_one\n      assms unfolding target_ring.primeIdeal_def by auto\n  }\n  then show \"f -`` J \\<noteq> R\" by auto\n  show \"\\<forall>x\\<in>R. \\<forall>y\\<in>R. (\\<forall>z\\<in>R. x \\<cdot>\\<^sub>R z \\<cdot>\\<^sub>R y \\<in> f -`` J) \\<longrightarrow>\n                 x \\<in> f -`` J \\<or> y \\<in> f -`` J\"\n  proof(safe)\n    fix x y assume as:\"x\\<in>R\" \"y\\<in>R\" \"\\<forall>z\\<in>R. x \\<cdot>\\<^sub>R z \\<cdot>\\<^sub>R y \\<in> f -`` J\" \"y \\<notin> f -`` J\"\n    {\n      fix s assume s:\"s\\<in>S\"\n      then have \"(f`x)\\<cdot>\\<^sub>Ss\\<cdot>\\<^sub>S(f`y) = s\\<cdot>\\<^sub>S((f`x)\\<cdot>\\<^sub>S(f`y))\"\n        using assms(2) unfolding IsCommutative_def\n        using apply_type[OF fun as(1)] \n          target_ring.Ring_ZF_1_L11(2) apply_type[OF fun as(2)]\n        by auto\n      then have \"(f`x)\\<cdot>\\<^sub>Ss\\<cdot>\\<^sub>S(f`y) = s\\<cdot>\\<^sub>S(f`(x\\<cdot>\\<^sub>Ry))\"\n        using homomor_dest_mult[OF as(1,2)]\n        by auto moreover\n      from as(3) have \"x\\<cdot>\\<^sub>Ry : f-``J\" using origin_ring.Ring_ZF_1_L2(2)\n        origin_ring.Ring_ZF_1_L3(5)[OF as(1)] by force\n      then have \"f`(x\\<cdot>\\<^sub>Ry) : J\" using func1_1_L15 fun by auto\n      with s have \"s\\<cdot>\\<^sub>S(f`(x\\<cdot>\\<^sub>Ry)) :J\" using assms(1)\n        unfolding target_ring.primeIdeal_def using target_ring.ideal_dest_mult(2)\n        by auto\n      ultimately have \"(f`x)\\<cdot>\\<^sub>Ss\\<cdot>\\<^sub>S(f`y):J\" by auto\n    }\n    then have \"\\<forall>z\\<in>S. (f`x) \\<cdot>\\<^sub>S z \\<cdot>\\<^sub>S (f`y) \\<in> J\" by auto\n    with target_ring.equivalent_prime_ideal[OF assms(1)]\n    apply_type[OF fun] as(1,2) have \"f`x:J\\<or>f`y:J\" by auto\n    with as(4,2) have \"f`x:J\" using func1_1_L15 fun by auto\n    then show \"x:f-``J\" using as(1) func1_1_L15 fun by auto\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1855
    },
    "1672": {
        "type": "theorem",
        "text": "text\\<open>The quotient map is a homomorphism of rings\\<close>\n",
        "assumes": "",
        "using": [
            "as",
            "Ring_ZF_1_L4(3)",
            "lamE",
            "lam_funtype",
            "EquivClass_1_L10[OF",
            "equiv_rel[OF",
            "idealAssum]",
            "quotientBy_mul_monoid(1)[OF",
            "idealAssum]]",
            "Ring_ZF_1_L2(2)",
            "Group_ZF_2_2_L1[OF",
            "_",
            "ringAssum",
            "IsAring_def",
            "QuotientBy_def[OF"
        ],
        "statement": "theorem (in ring2) quotient_fun_homomor:\n  shows \"f\\<^sub>I{is a ring homomorphism}{R,A,M}\\<rightarrow>{R\\<^sub>I,A\\<^sub>I,M\\<^sub>I}\"\n  unfolding ringHomomor_def[OF ringAssum quotient_ring.ringAssum]\n",
        "proof": "proof(safe)\n  from add_group.quotient_map[OF ideal_normal_add_subgroup[OF idealAssum]]\n    show \"Homomor(f\\<^sub>I,R,A,R\\<^sub>I,A\\<^sub>I)\"\n    unfolding qfun_def quot_def qadd_def QuotientBy_def[OF idealAssum] by auto\n  {\n    fix x y assume as:\"x\\<in>R\" \"y\\<in>R\"\n    have \"f\\<^sub>I ` (x\\<cdot>y) = QuotientGroupRel(R,A,I)``{x\\<cdot>y}\" \n      unfolding qfun_def using as Ring_ZF_1_L4(3)\n      lamE lam_funtype by auto\n    then have \"f\\<^sub>I ` (x\\<cdot>y) = ((QuotientGroupRel(R,A,I)``{x}){\\<cdot>I}(QuotientGroupRel(R,A,I)``{y}))\"\n      using EquivClass_1_L10[OF equiv_rel[OF idealAssum]\n          quotientBy_mul_monoid(1)[OF idealAssum]] as by auto\n    then have \"f\\<^sub>I ` (x\\<cdot>y) = ((f\\<^sub>I `x){\\<cdot>I}(f\\<^sub>I `y))\" unfolding qfun_def\n      using as lamE lam_funtype by auto\n    then show \"f\\<^sub>I ` (M ` \\<langle>x, y\\<rangle>) =M\\<^sub>I `  \\<langle>f\\<^sub>I ` x, f\\<^sub>I ` y\\<rangle>\" by auto\n  }\n  have \"f\\<^sub>I `\\<one> = QuotientGroupRel(R,A,I)``{\\<one>}\"\n    unfolding qfun_def using lam_funtype lamE Ring_ZF_1_L2(2)\n    by auto\n  then have \"f\\<^sub>I `\\<one> = TheNeutralElement(QuotientBy(I),ProjFun2(R, QuotientGroupRel(R,A,I), M))\"\n    using Group_ZF_2_2_L1[OF _ equiv_rel[OF idealAssum]\n          quotientBy_mul_monoid(1)[OF idealAssum]]\n          ringAssum unfolding IsAring_def QuotientBy_def[OF idealAssum]\n    by auto\n  then show \"f\\<^sub>I ` TheNeutralElement(R, M) = TheNeutralElement(R\\<^sub>I, M\\<^sub>I)\"\n    unfolding quot_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1856
    },
    "1673": {
        "type": "lemma",
        "text": "text\\<open>The quotient map is surjective\\<close>\n",
        "assumes": "",
        "using": [
            "lam_funtype",
            "quot_def",
            "QuotientBy_def[OF",
            "idealAssum]",
            "quotient_def",
            "qrel_def",
            "surj_def"
        ],
        "statement": "lemma (in ring2) quot_fun:\n  shows \"f\\<^sub>I\\<in>surj(R,R\\<^sub>I)\" unfolding qfun_def ",
        "proof": "using lam_funtype unfolding quot_def QuotientBy_def[OF idealAssum]\n    quotient_def qrel_def surj_def by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1857
    },
    "1674": {
        "type": "lemma",
        "text": "text\\<open>The preimage of an ideal is an ideal, so it applies to the\nquotient map; but the preimage ideal contains the quotient ideal.\\<close>\n",
        "assumes": "assumes \"J\\<triangleleft>R\\<^sub>I\"\n  ",
        "using": [
            "lamI[of",
            "x",
            "R]",
            "ideal_dest_subset[OF",
            "idealAssum]",
            "apply_equality[of",
            "\"r\\<^sub>I``{x}\"",
            "\"f\\<^sub>I\"]",
            "qfun_def",
            "add_group.Group_ZF_2_4_L5E[OF",
            "ideal_normal_add_subgroup[OF",
            "idealAssum],",
            "of",
            "\"r\\<^sub>I\"",
            "\"\\<zero>\\<^sub>I\"]",
            "qrel_def",
            "ideal_rzero_def",
            "Group_ZF_2_4_L5B[OF",
            "_",
            "idealAssum]]",
            "ringAssum",
            "IsAring_def",
            "quotient_ring.ideal_dest_zero",
            "assms",
            "quot_fun",
            "func1_1_L15"
        ],
        "statement": "lemma (in ring2) ideal_quot_preimage:\n  assumes \"J\\<triangleleft>R\\<^sub>I\"\n  shows \"(f\\<^sub>I-``J) \\<triangleleft>R\" \"I \\<subseteq> f\\<^sub>I-``J\"\n",
        "proof": "proof-\n  from quot_homomorphism.preimage_ideal[OF assms]\n  show \"(f\\<^sub>I-``J) \\<triangleleft>R\" by auto\n  {\n    fix x assume x:\"x\\<in>I\"\n    with quot_fun have \"f\\<^sub>I`x = r\\<^sub>I``{x}\"\n      using lamI[of x R] ideal_dest_subset[OF idealAssum]\n      apply_equality[of x \"r\\<^sub>I``{x}\" \"f\\<^sub>I\"] unfolding qfun_def\n      by auto\n    then have \"f\\<^sub>I`x = \\<zero>\\<^sub>I\" using add_group.Group_ZF_2_4_L5E[OF\n          ideal_normal_add_subgroup[OF idealAssum], of x\n          \"r\\<^sub>I\" \"\\<zero>\\<^sub>I\"] x ideal_dest_subset[OF idealAssum]\n      unfolding qrel_def ideal_rzero_def using\n        Group_ZF_2_4_L5B[OF _ ideal_normal_add_subgroup[OF idealAssum]]\n      using ringAssum unfolding IsAring_def by auto\n    then have \"f\\<^sub>I`x \\<in> J\" using quotient_ring.ideal_dest_zero\n      assms by auto\n    then have \"x\\<in>f\\<^sub>I-``J\" using x ideal_dest_subset[OF idealAssum]\n      quot_fun func1_1_L15 by auto\n  }\n  then show \"I \\<subseteq> f\\<^sub>I-``J\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1858
    },
    "1675": {
        "type": "theorem",
        "text": "text\\<open>The ideals of the quotient ring are in bijection\nwith the ideals of the original ring that contain the ideal\nby which we made the quotient.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(R,S)\"\n  defines \"idealFun \\<equiv> \\<lambda>J\\<in>target_ring.ideals. f-``J\"\n  ",
        "using": [
            "lam_funtype",
            "preimage_ideal[of",
            "K]",
            "func1_1_L3[OF",
            "surj_is_fun[OF",
            "assms(1)],",
            "of",
            "func1_1_L1B",
            "beta",
            "surj_image_vimage",
            "assms(1)",
            "as",
            "func1_1_L9[OF",
            "surj_is_fun]",
            "func1_1_L15[OF",
            "func_imagedef[of",
            "f",
            "R",
            "S",
            "y,",
            "OF",
            "y(2)",
            "apply_type[of",
            "\"\\<lambda>u.",
            "S\",",
            "target_ring.Ring_ZF_1_L3(7)",
            "homomor_dest_subs",
            "t(2)",
            "`s:R`",
            "origin_ring.Ring_ZF_1_L4(2)",
            "origin_ring.ideal_dest_sum",
            "y(1)",
            "origin_ring.Ring_ZF_2_L1A(5)",
            "`s\\<in>R`",
            "func1_1_L6(2)[of",
            "S]",
            "surj_def",
            "image_ideal_surj"
        ],
        "statement": "theorem (in ring_homo) ideal_quot_bijection:\n  assumes \"f\\<in>surj(R,S)\"\n  defines \"idealFun \\<equiv> \\<lambda>J\\<in>target_ring.ideals. f-``J\"\n  shows \"idealFun \\<in> bij(target_ring.ideals,{K\\<in>\\<I>. ker \\<subseteq> K})\"\n  unfolding bij_def inj_def surj_def\n",
        "proof": "proof(safe)\n  have \"idealFun \\<in> target_ring.ideals \\<rightarrow> {f-``J. J\\<in>target_ring.ideals}\"\n    unfolding idealFun_def\n    using lam_funtype by auto moreover\n  {\n    fix t assume \"t\\<in>{f-``J. J\\<in>target_ring.ideals}\"\n    then obtain K where \"K\\<in>target_ring.ideals\" \"f-``K = t\" by auto\n    then have \"ker \\<subseteq> t\" \"t\\<triangleleft>R\" \"t \\<subseteq> R\" using preimage_ideal[of K]\n      using func1_1_L3[OF surj_is_fun[OF assms(1)], of K]\n      by auto\n    then have \"t\\<in>{K\\<in>\\<I>. ker \\<subseteq> K}\" by auto\n  }\n  then have \"{f-``J. J\\<in>target_ring.ideals} \\<subseteq> {K\\<in>\\<I>. ker \\<subseteq> K}\" by blast\n  ultimately show \"idealFun \\<in> target_ring.ideals \\<rightarrow> {K\\<in>\\<I>. ker \\<subseteq> K}\"\n    using func1_1_L1B by auto\n  then show \"idealFun \\<in> target_ring.ideals \\<rightarrow> {K\\<in>\\<I>. ker \\<subseteq> K}\".\n  {\n    fix w x assume as:\"w\\<triangleleft>R\\<^sub>t\" \"x\\<triangleleft>R\\<^sub>t\" \"w\\<subseteq>S\" \"x\\<subseteq>S\" \"idealFun ` w = idealFun ` x\"\n    then have \"f-``w = f-``x\" unfolding idealFun_def\n      using beta by auto\n    then have \"f``(f-``w) = f``(f-``x)\" by auto\n    then show \"w = x\" using surj_image_vimage assms(1) as\n      by auto\n  }\n  {\n    fix y assume y:\"y\\<triangleleft>R\" \"y\\<subseteq>R\" \"ker \\<subseteq> y\"\n    from y(2) have \"y \\<subseteq> f-``(f``y)\" using func1_1_L9[OF surj_is_fun] \n        assms(1) by auto\n    moreover\n    {\n      fix t assume \"t\\<in>f-``(f``y)\"\n      then have t:\"f`t\\<in>f``y\" \"t\\<in>R\" using func1_1_L15[OF surj_is_fun] \n            assms(1) by auto\n      from t(1) y(2) obtain s where s:\"s\\<in>y\" \"f`t = f`s\" \n        using func_imagedef[of f R S y, OF surj_is_fun] assms(1) \n        by auto\n      from s(1) have \"s\\<in>R\" using y(2) by auto\n      with t(2) have E:\"f`t : S\" \"f`s: S\" using apply_type[of f R \"\\<lambda>u. S\", OF surj_is_fun]\n        assms(1) by auto\n      from E(1) s(2) have \"(f`t)\\<rs>\\<^sub>S(f`s) = \\<zero>\\<^sub>S\"\n        using target_ring.Ring_ZF_1_L3(7) by auto\n      then have \"f`(t\\<rs>\\<^sub>Rs) = \\<zero>\\<^sub>S\" using homomor_dest_subs\n        t(2) `s:R` by auto\n      moreover from \\<open>s\\<in>R\\<close> have \"t\\<rs>\\<^sub>Rs \\<in>R\" \n        using origin_ring.Ring_ZF_1_L4(2) t(2) by auto\n      ultimately have \"t\\<rs>\\<^sub>Rs \\<in> f-``{\\<zero>\\<^sub>S}\"\n        using func1_1_L15[OF surj_is_fun] assms(1) by auto\n      with y(3) have \"t\\<rs>\\<^sub>Rs \\<in> y\" by auto\n      with s(1) have \"s\\<ra>\\<^sub>R(t\\<rs>\\<^sub>Rs) \\<in> y\" using \n        origin_ring.ideal_dest_sum y(1) by auto\n      then have \"t\\<in>y\" using origin_ring.Ring_ZF_2_L1A(5)\n        using `s\\<in>R` t(2) by auto\n    }\n    ultimately have \"f-``(f``y) = y\" by blast moreover\n    have \"f``y \\<subseteq> S\" using func1_1_L6(2)[of f R S] assms(1)\n      unfolding surj_def by auto moreover\n    have \"(f``y)\\<triangleleft>R\\<^sub>t\" using image_ideal_surj\n      assms(1) y(1) by auto\n    ultimately show \"\\<exists>x\\<in>target_ring.ideals. idealFun ` x = y\"\n      unfolding idealFun_def\n      by auto\n  }\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1860
    },
    "1676": {
        "type": "corollary",
        "text": "text\\<open>Since the map is surjective, this bijection\nrestricts to prime ideals on both sides.\\<close>\n",
        "assumes": "assumes \"K\\<triangleleft>R\\<^sub>t\" \"f:surj(R,S)\"\n  ",
        "using": [
            "preimage_prime_ideal_surj",
            "assms(2)",
            "beta[of",
            "K",
            "target_ring.ideals]",
            "target_ring.ideal_dest_subset[of",
            "K]",
            "as",
            "target_ring.primeIdeal_def",
            "func1_1_L4",
            "surj_def",
            "origin_ring.ideal_dest_subset",
            "origin_ring.product_in_intersection(2)",
            "preimage_ideal",
            "target_ring.zero_ideal",
            "jp",
            "prime_ideal_quot",
            "jp(1,2)",
            "origin_ring.ideal_dest_subset[OF",
            "[OF",
            "preimage_ideal(1)",
            "preimage_ideal(1)]]",
            "preimage_ideal(1)[OF",
            "target_ring.zero_ideal]]",
            "origin_ring.generated_ideal_contains_set[of",
            "\"(f",
            "-``",
            "J)",
            "\\<cdot>\\<^sub>I",
            "(f",
            "P)",
            "\\<union>",
            "ker\"]",
            "origin_ring.primeIdeal_def",
            "surj_image_vimage",
            "assms",
            "target_ring.ideal_dest_subset"
        ],
        "statement": "corollary (in ring_homo) prime_ideal_quot_3:\n  assumes \"K\\<triangleleft>R\\<^sub>t\" \"f:surj(R,S)\"\n  shows \"K\\<triangleleft>\\<^sub>pR\\<^sub>t \\<longleftrightarrow> ((f-``K)\\<triangleleft>\\<^sub>pR\\<^sub>o)\"\n",
        "proof": "proof\n  {\n    assume as:\"K\\<triangleleft>\\<^sub>pR\\<^sub>t\"\n    then have \"(f-``K)\\<triangleleft>\\<^sub>pR\\<^sub>o\" using preimage_prime_ideal_surj\n      assms(2) by auto\n    then show \"(f-``K)\\<triangleleft>\\<^sub>pR\\<^sub>o\"\n      using beta[of K target_ring.ideals]\n      using target_ring.ideal_dest_subset[of K] as\n      unfolding target_ring.primeIdeal_def by auto\n  } moreover\n  {\n    assume as:\"(f-``K)\\<triangleleft>\\<^sub>pR\\<^sub>o\"\n    from assms(1) have \"K\\<triangleleft>R\\<^sub>t\". moreover\n    {\n      assume \"K=S\"\n      then have \"f-``K = f-``S\" by auto\n      then have \"f-``K = R\" using func1_1_L4\n        assms(2) unfolding surj_def by auto\n      with as have False unfolding origin_ring.primeIdeal_def by auto\n    }\n    then have \"K\\<noteq>S\" by auto moreover\n    {\n      fix J P assume jp:\"J\\<in>target_ring.ideals\"\n        \"P\\<in>target_ring.ideals\"\n        \"target_ring.productIdeal(J, P) \\<subseteq> K\"\n      have sub:\"((f -`` J) \\<cdot>\\<^sub>I (f -`` P)) \\<union> ker \\<subseteq> R\"\n        using origin_ring.ideal_dest_subset\n        origin_ring.product_in_intersection(2) \n        preimage_ideal target_ring.zero_ideal\n        jp by auto\n      from jp(3) have \"f -``target_ring.productIdeal(J, P) \\<subseteq> f -``K\"\n        by auto\n      with jp(1,2) have A:\"((f -`` J) \\<cdot>\\<^sub>I (f -`` P)) +\\<^sub>I (ker) \\<subseteq> f -``K\" \n        using prime_ideal_quot assms(2)\n        by auto moreover\n      have j:\"J\\<triangleleft>R\\<^sub>t\" and p:\"P\\<triangleleft>R\\<^sub>t\" using jp(1,2) by auto\n      then have \"(f -`` J) \\<cdot>\\<^sub>I (f -`` P) \\<union> ker \\<subseteq> R\"\n        using origin_ring.ideal_dest_subset[OF origin_ring.product_in_intersection(2)\n            [OF preimage_ideal(1) preimage_ideal(1)]]\n            origin_ring.ideal_dest_subset[OF preimage_ideal(1)[OF target_ring.zero_ideal]]\n        by auto\n      with A have \"((f -`` J) \\<cdot>\\<^sub>I (f -`` P)) \\<subseteq> f -``K\" \n        unfolding origin_ring.sumIdeal_def[OF origin_ring.product_in_intersection(2)\n            [OF preimage_ideal(1)[OF j] preimage_ideal(1)[OF p]]   \n            preimage_ideal(1)[OF target_ring.zero_ideal]] using\n            origin_ring.generated_ideal_contains_set[of \"(f -`` J) \\<cdot>\\<^sub>I (f -`` P) \\<union> ker\"]\n            by auto\n      moreover have \"f -`` J \\<in>\\<I>\" \"f -`` P \\<in>\\<I>\"\n        using preimage_ideal\n        origin_ring.ideal_dest_subset jp(1,2) by auto\n      ultimately have \"f -`` J \\<subseteq> f -`` K \\<or> f -`` P \\<subseteq> f -`` K\"\n        using as unfolding origin_ring.primeIdeal_def by auto\n      then have \"f``(f -`` J) \\<subseteq> f``(f -`` K) \\<or> f``(f -`` P) \\<subseteq> f``(f -`` K)\"\n        by blast\n      then have \"J \\<subseteq> K \\<or> P \\<subseteq> K\" using assms(2)\n        surj_image_vimage jp(1,2) assms target_ring.ideal_dest_subset\n        by auto\n    }\n    ultimately show \"K\\<triangleleft>\\<^sub>pR\\<^sub>t\"\n      unfolding target_ring.primeIdeal_def by auto\n  }\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1861
    },
    "1677": {
        "type": "definition",
        "text": "text\\<open>The set where the topology is defined is in the spectrum\nof a ring; i.e. the set of all prime ideals.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) Spec where\n\"Spec \\<equiv> {I\\<in>\\<I>. I\\<triangleleft>\\<^sub>pR}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1862
    },
    "1678": {
        "type": "definition",
        "text": "text\\<open>The basic set that defines the topoogy is given\nby the D operator\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) openBasic (\"D\") where\n\"S\\<subseteq>R \\<Longrightarrow> D(S) \\<equiv> {I\\<in>Spec. \\<not>(S\\<subseteq>I)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1863
    },
    "1679": {
        "type": "lemma",
        "text": "text\\<open>The D operator preserves subsets\\<close>\n",
        "assumes": "assumes \"S \\<subseteq> T\" \"T\\<subseteq>R\"\n  ",
        "using": [
            "openBasic_def",
            "S",
            "assms(2)"
        ],
        "statement": "lemma (in ring0) D_operator_preserve_subset:\n  assumes \"S \\<subseteq> T\" \"T\\<subseteq>R\"\n  shows \"D(S) \\<subseteq> D(T)\"\n",
        "proof": "proof\n  from assms have S:\"S\\<subseteq>R\" by auto\n  fix x assume \"x\\<in>D(S)\"\n  then have x:\"x\\<in>Spec\" \"\\<not>(S\\<subseteq>x)\" using openBasic_def S by auto\n  with assms(1) have \"x\\<in>Spec\" \"\\<not>(T\\<subseteq>x)\" by auto\n  then show \"x:D(T)\" using openBasic_def assms(2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1864
    },
    "1680": {
        "type": "lemma",
        "text": "text\\<open>The intersection of to D-sets is the D-set on the \nproduct of ideals\\<close>\n",
        "assumes": "assumes \"I\\<triangleleft>R\" \"J\\<triangleleft>R\"\n  ",
        "using": [
            "product_in_intersection(2)",
            "ideal_dest_subset",
            "assms",
            "openBasic_def",
            "Spec_def",
            "ideal_dest_subset[of",
            "I]",
            "J]",
            "openBasic_def[of",
            "\"I\"]",
            "ideal_dest_subset[OF",
            "assms(1)]",
            "openBasic_def[OF",
            "S]",
            "product_in_intersection"
        ],
        "statement": "lemma (in ring0) intersection_open_basic:\n  assumes \"I\\<triangleleft>R\" \"J\\<triangleleft>R\"\n  shows \"D(I)\\<inter>D(J) = D(I\\<cdot>\\<^sub>IJ)\"\n",
        "proof": "proof\n  have S:\"I\\<cdot>\\<^sub>IJ \\<subseteq> R\" using product_in_intersection(2) ideal_dest_subset assms by auto\n  {\n    fix K assume K:\"K\\<in>D(I)\\<inter>D(J)\"\n    then have \"K\\<triangleleft>\\<^sub>pR\" \"\\<not>(I\\<subseteq>K)\" \"\\<not>(J\\<subseteq>K)\"\n      using assms ideal_dest_subset openBasic_def \n      unfolding Spec_def by auto\n    then have \"\\<not>(I\\<subseteq>K)\" \"\\<not>(J\\<subseteq>K)\" \"\\<forall>I\\<in>\\<I>. \\<forall>J\\<in>\\<I>. I\\<cdot>\\<^sub>IJ\\<subseteq>K \\<longrightarrow> I \\<subseteq> K \\<or> J \\<subseteq> K\"\n      unfolding primeIdeal_def by auto\n    then have \"\\<not>(I\\<cdot>\\<^sub>IJ\\<subseteq>K)\" using assms\n      using ideal_dest_subset[of I] ideal_dest_subset[of J] by auto\n    moreover note K\n    ultimately have \"K\\<in>D(I\\<cdot>\\<^sub>IJ)\" using openBasic_def[of \"I\"]\n      ideal_dest_subset[OF assms(1)]\n      unfolding Spec_def openBasic_def[OF S] by auto\n  }\n  then show \"D(I)\\<inter>D(J) \\<subseteq> D(I\\<cdot>\\<^sub>IJ)\" by auto\n  {\n    fix K assume Kass:\"K\\<in>D(I\\<cdot>\\<^sub>IJ)\"\n    then have K:\"K\\<triangleleft>\\<^sub>pR\" \"\\<not>(I\\<cdot>\\<^sub>IJ\\<subseteq>K)\" using openBasic_def[OF S] unfolding Spec_def by auto\n    {\n      assume \"I \\<subseteq> K \\<or> J \\<subseteq>K\"\n      then have \"I\\<inter>J \\<subseteq> K\" by auto\n      then have \"I\\<cdot>\\<^sub>IJ\\<subseteq>K\" using product_in_intersection assms by auto\n      with K(2) have False by auto\n    }\n    then have \"\\<not>(I\\<subseteq>K)\" \"\\<not>(J\\<subseteq>K)\" by auto\n    with Kass have \"K\\<in>D(I)\\<inter>D(J)\" using assms ideal_dest_subset\n      openBasic_def[of I] openBasic_def[of J]\n      unfolding openBasic_def[OF S] Spec_def by auto\n  }\n  then show \"D(I \\<cdot>\\<^sub>I J) \\<subseteq> D(I) \\<inter> D(J)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1866
    },
    "1681": {
        "type": "lemma",
        "text": "text\\<open>The union of D-sets is the D-set of the sum of the ideals\\<close>\n",
        "assumes": "assumes \"\\<J> \\<subseteq> \\<I>\"\n  ",
        "using": [
            "generated_ideal_is_ideal[of",
            "\"\\<Union>\\<J>\"]",
            "assms",
            "sumArbitraryIdeals_def[OF",
            "assms]",
            "ideal_dest_subset",
            "openBasic_def",
            "Spec_def",
            "generated_ideal_contains_set[of",
            "openBasic_def[of",
            "K]",
            "\"\\<oplus>\\<^sub>I\\<J>\"]",
            "generated_ideal_small",
            "primeIdeal_def",
            "`J\\<in>\\<J>`",
            "J]",
            "J(2)"
        ],
        "statement": "lemma (in ring0) union_open_basic:\n  assumes \"\\<J> \\<subseteq> \\<I>\"\n  shows \"\\<Union>{D(I). I\\<in>\\<J>} = D(\\<oplus>\\<^sub>I\\<J>)\"\n",
        "proof": "proof\n  have S:\"(\\<oplus>\\<^sub>I\\<J>) \\<subseteq> R\" using generated_ideal_is_ideal[of \"\\<Union>\\<J>\"] assms\n      unfolding sumArbitraryIdeals_def[OF assms]\n      using ideal_dest_subset by auto\n  {\n    fix t assume \"t\\<in>\\<Union>{D(I). I\\<in>\\<J>}\"\n    then obtain K where K:\"K\\<in>\\<J>\" \"t\\<in>D(K)\" by auto\n    then have t:\"t\\<triangleleft>\\<^sub>pR\" \"\\<not>(K\\<subseteq>t)\" using assms openBasic_def unfolding Spec_def by auto\n    {\n      assume \"(\\<oplus>\\<^sub>I\\<J>) \\<subseteq> t\"\n      then have \"\\<Union>\\<J> \\<subseteq> t\" using generated_ideal_contains_set[of \"\\<Union>\\<J>\"]\n        assms unfolding sumArbitraryIdeals_def[OF assms] by auto\n      with K(1) have \"K \\<subseteq> t\" by auto\n      with t(2) have False by auto\n    }\n    then have \"\\<not>((\\<oplus>\\<^sub>I\\<J>) \\<subseteq> t)\" by auto moreover\n    note K S ultimately have \"t\\<in>D(\\<oplus>\\<^sub>I\\<J>)\" using openBasic_def[of K] openBasic_def[of \"\\<oplus>\\<^sub>I\\<J>\"]\n      assms by auto\n  }\n  then show \"\\<Union>{D(I). I\\<in>\\<J>} \\<subseteq> D(\\<oplus>\\<^sub>I\\<J>)\" by auto\n  {\n    fix t assume as:\"t\\<in>D(\\<oplus>\\<^sub>I\\<J>)\"\n    then have t:\"t\\<in>Spec\" \"\\<not>((\\<oplus>\\<^sub>I\\<J>)\\<subseteq>t)\" unfolding openBasic_def[OF S]\n      by auto\n    {\n      assume \"\\<Union>\\<J> \\<subseteq> t\"\n      with t(1) have \"\\<langle>\\<Union>\\<J>\\<rangle>\\<^sub>I \\<subseteq> t\" using generated_ideal_small\n        unfolding Spec_def primeIdeal_def\n        by auto\n      with t(2) have False unfolding sumArbitraryIdeals_def[OF assms]\n        by auto\n    }\n    then obtain J where J:\"\\<not>(J \\<subseteq> t)\" \"J\\<in>\\<J>\" by auto\n    note J(1) moreover have \"J\\<subseteq>R\" using `J\\<in>\\<J>` assms by auto\n    moreover note t(1) ultimately have \"t\\<in>D(J)\" using openBasic_def[of J]\n      by auto\n    then have \"t:\\<Union>{D(I). I\\<in>\\<J>}\" using J(2) by auto\n  }\n  then show \"D(\\<oplus>\\<^sub>I\\<J>) \\<subseteq> \\<Union>{D(I). I\\<in>\\<J>}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1867
    },
    "1682": {
        "type": "corollary",
        "text": "text\\<open>From the previous results on intesertion and union,\nwe conclude that the D-sets we computed form a topology\\<close>\n",
        "assumes": "",
        "using": [
            "union_open_basic[of",
            "\"{K",
            "\\<in>",
            "\\<I>",
            ".",
            "D(K)",
            "M}\"]",
            "generated_ideal_is_ideal[of",
            "\"\\<Union>{K\\<in>\\<I>.",
            "D(K)\\<in>M}\"]",
            "sumArbitraryIdeals_def",
            "[of",
            "\"{K\\<in>\\<I>.",
            "ideal_dest_subset",
            "intersection_open_basic",
            "product_in_intersection(2)",
            "as"
        ],
        "statement": "corollary (in ring0) zariski_top:\n  shows \"{D(J). J\\<in>\\<I>}{is a topology}\" unfolding IsATopology_def\n",
        "proof": "proof(safe)\n  fix M assume \"M \\<subseteq> {D(J). J\\<in>\\<I>}\"\n  then have \"M = {D(J). J\\<in>{K\\<in>\\<I>. D(K)\\<in>M}}\" by auto\n  then have \"\\<Union>M = \\<Union>{D(J). J\\<in>{K\\<in>\\<I>. D(K)\\<in>M}}\" by auto\n  then have \"\\<Union>M = D(\\<oplus>\\<^sub>I{K\\<in>\\<I>. D(K)\\<in>M})\" using union_open_basic[of \"{K \\<in> \\<I> . D(K) \\<in> M}\"] by auto\n  moreover have \"(\\<oplus>\\<^sub>I{K\\<in>\\<I>. D(K)\\<in>M})\\<triangleleft>R\" using\n    generated_ideal_is_ideal[of \"\\<Union>{K\\<in>\\<I>. D(K)\\<in>M}\"]\n    sumArbitraryIdeals_def [of \"{K\\<in>\\<I>. D(K)\\<in>M}\"]\n    by force\n  then have \"(\\<oplus>\\<^sub>I{K\\<in>\\<I>. D(K)\\<in>M})\\<in>\\<I>\" using ideal_dest_subset\n    by auto\n  ultimately show \"\\<Union>M:{D(J). J\\<in>\\<I>}\" by auto\nnext\n  fix x xa assume as:\"x\\<triangleleft>R\" \"xa\\<triangleleft>R\"\n  then have \"D(x) \\<inter> D(xa) = D(x\\<cdot>\\<^sub>Ixa)\" using intersection_open_basic\n    by auto\n  moreover have \"(x\\<cdot>\\<^sub>Ixa) \\<triangleleft>R\" using product_in_intersection(2)\n    as by auto\n  then have \"(x\\<cdot>\\<^sub>Ixa):\\<I>\" using ideal_dest_subset by auto\n  ultimately show \"D(x) \\<inter> D(xa)\\<in>{D(J). J\\<in>\\<I>}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1868
    },
    "1683": {
        "type": "lemma",
        "text": "text\\<open>The whole space is the D-set of the ring as an ideal of itself\\<close>\n",
        "assumes": "",
        "using": [
            "openBasic_def",
            "t",
            "Spec_def",
            "primeIdeal_def",
            "ideal_dest_subset[of",
            "t]"
        ],
        "statement": "lemma (in ring0) openBasic_total:\n  shows \"D(R) = Spec\"\n",
        "proof": "proof\n  show \"D(R) \\<subseteq> Spec\" using openBasic_def by auto\n  {\n    fix t assume t:\"t\\<in>Spec\"\n    {\n      assume \"R \\<subseteq> t\"\n      then have False using t unfolding Spec_def primeIdeal_def\n        using ideal_dest_subset[of t] by auto\n    }\n    with t have \"t\\<in>D(R)\" using openBasic_def by auto\n  }\n  then show \"Spec \\<subseteq> D(R)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1869
    },
    "1684": {
        "type": "lemma",
        "text": "text\\<open>The empty set is the D-set of the zero ideal\\<close>\n",
        "assumes": "",
        "using": [
            "openBasic_def",
            "Ring_ZF_1_L2(1)",
            "Spec_def",
            "ideal_dest_zero",
            "primeIdeal_def"
        ],
        "statement": "lemma (in ring0) openBasic_empty:\n  shows \"D({\\<zero>}) = 0\"\n",
        "proof": "proof-\n  {\n    fix t assume t:\"t\\<in>D({\\<zero>})\"\n    then have \"t\\<triangleleft>\\<^sub>pR\" \"\\<not>({\\<zero>} \\<subseteq> t)\" using openBasic_def\n      Ring_ZF_1_L2(1) unfolding Spec_def by auto\n    then have False using ideal_dest_zero unfolding primeIdeal_def by auto\n  }\n  then show \"D({\\<zero>}) =0\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1870
    },
    "1685": {
        "type": "lemma",
        "text": "text\\<open>A closed set is a set of primes containing a given\nideal\\<close>\n",
        "assumes": "assumes \"U{is closed in}{D(J). J\\<in>\\<I>}\"\n  ",
        "using": [
            "total_spec",
            "openBasic_def",
            "rule"
        ],
        "statement": "lemma (in ring0) closeBasic:\n  assumes \"U{is closed in}{D(J). J\\<in>\\<I>}\"\n  obtains J where \"J\\<in>\\<I>\" and \"U={K\\<in>Spec. J\\<subseteq>K}\"\n",
        "proof": "proof-\n  assume rule:\"\\<And>J. J \\<in> \\<I> \\<Longrightarrow> U = {K \\<in> Spec . J \\<subseteq> K} \\<Longrightarrow> thesis\"\n  from assms have U:\"U\\<subseteq>Spec\" \"Spec-U \\<in> {D(J). J\\<in>\\<I>}\" unfolding IsClosed_def\n    using total_spec by auto\n  then obtain J where J:\"J\\<in>\\<I>\" \"Spec-U = D(J)\" by auto\n  moreover from U(1) have \"Spec-(Spec-U) = U\" by auto\n  ultimately have \"U = Spec-{K\\<in>Spec. \\<not>(J\\<subseteq>K)}\" using openBasic_def\n    by auto\n  then have \"U = {K\\<in>Spec. J\\<subseteq>K}\" by auto\n  with J show ?thesis using rule by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1871
    },
    "1686": {
        "type": "definition",
        "text": "text\\<open>We define the closed sets as V-sets\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in ring0) closeBasic (\"V\") where\n\"S \\<subseteq> R \\<Longrightarrow> V(S) = {K\\<in>Spec. S\\<subseteq>K}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1872
    },
    "1687": {
        "type": "lemma",
        "text": "text\\<open>V-sets and D-sets are complementary\\<close>\n",
        "assumes": "assumes \"J\\<in>\\<I>\"\n  ",
        "using": [
            "closeBasic_def",
            "total_spec",
            "assms",
            "openBasic_def"
        ],
        "statement": "lemma (in ring0) V_is_closed:\n  assumes \"J\\<in>\\<I>\"\n  shows \"Spec-V(J) = D(J)\" and \"V(J){is closed in}{D(J). J\\<in>\\<I>}\"\n  unfolding IsClosed_def\n",
        "proof": "proof(safe)\n  from assms have \"V(J) \\<subseteq> Spec\" using closeBasic_def by auto\n  then show \"\\<And>x. x \\<in> V(J) \\<Longrightarrow> x \\<in> \\<Union>RepFun(\\<I>, D)\" using total_spec by auto\n  show \"Spec-V(J) = D(J)\" using assms\n    closeBasic_def openBasic_def by auto\n  with assms show \"\\<Union>RepFun(\\<I>, D) - V(J) \\<in> RepFun(\\<I>, D)\"\n    using total_spec by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1873
    },
    "1688": {
        "type": "lemma",
        "text": "text\\<open>As with D-sets, by De Morgan's Laws we get the same result\nfor unions and intersections on V-sets\\<close>\n",
        "assumes": "assumes \"J\\<in>\\<I>\" \"K\\<in>\\<I>\"\n  ",
        "using": [
            "closeBasic_def",
            "assms(1)",
            "product_in_intersection(1)[of",
            "J",
            "K]",
            "assms",
            "product_in_intersection(2)[of",
            "ideal_dest_subset",
            "assms(2)"
        ],
        "statement": "lemma (in ring0) V_union:\n  assumes \"J\\<in>\\<I>\" \"K\\<in>\\<I>\"\n  shows \"V(J)\\<union>V(K) = V(J\\<cdot>\\<^sub>IK)\"\n",
        "proof": "proof-\n  {\n    fix t assume \"t\\<in>V(J)\"\n    then have \"t\\<in>Spec\" \"J\\<subseteq>t\" using closeBasic_def\n      assms(1) by auto\n    moreover have \"J\\<cdot>\\<^sub>IK \\<subseteq> J\" using product_in_intersection(1)[of J K]\n      assms by auto\n    ultimately have \"t\\<in>Spec\" \"J\\<cdot>\\<^sub>IK \\<subseteq>t\" by auto\n    then have \"t: V(J\\<cdot>\\<^sub>IK)\" using closeBasic_def\n      product_in_intersection(2)[of J K] assms ideal_dest_subset\n      by auto\n  }\n  moreover\n  {\n    fix t assume \"t\\<in>V(K)\"\n    then have \"t\\<in>Spec\" \"K\\<subseteq>t\" using closeBasic_def\n      assms(2) by auto\n    moreover have \"J\\<cdot>\\<^sub>IK \\<subseteq> K\" using product_in_intersection(1)[of J K]\n      assms by auto\n    ultimately have \"t\\<in>Spec\" \"J\\<cdot>\\<^sub>IK \\<subseteq>t\" by auto\n    then have \"t: V(J\\<cdot>\\<^sub>IK)\" using closeBasic_def\n      product_in_intersection(2)[of J K] assms ideal_dest_subset\n      by auto\n  }\n  moreover\n  {\n    fix t assume \"t\\<in> V(J\\<cdot>\\<^sub>IK)\"\n    then have t:\"t\\<in>Spec\" \"J\\<cdot>\\<^sub>IK\\<subseteq>t\" using closeBasic_def\n      assms product_in_intersection(2)[of J K]\n      ideal_dest_subset by auto\n    from this(1) have \"\\<forall>Ia\\<in>\\<I>. \\<forall>J\\<in>\\<I>. Ia \\<cdot>\\<^sub>I J \\<subseteq> t \\<longrightarrow> Ia \\<subseteq> t \\<or> J \\<subseteq> t\"\n      unfolding Spec_def primeIdeal_def by blast\n    with assms have \"J\\<cdot>\\<^sub>IK\\<subseteq>t \\<longrightarrow> J\\<subseteq>t \\<or> K\\<subseteq>t\" by auto\n    with t have \"t\\<in>Spec\"  \"J \\<subseteq> t \\<or> K \\<subseteq> t\" by auto\n    then have \"t\\<in>V(J)\\<union>V(K)\" using closeBasic_def\n      assms by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1874
    },
    "1689": {
        "type": "lemma",
        "text": "text\\<open>The closure of a set is the V-set of the intersection\nof all its points.\\<close>\n",
        "assumes": "assumes \"U \\<subseteq> Spec\" \"U\\<noteq>0\"\n  ",
        "using": [
            "assms(1)",
            "Spec_def",
            "intersection_ideals[of",
            "U]",
            "assms(2)",
            "closeBasic_def",
            "openBasic_def",
            "openBasic_def[of",
            "J]",
            "J(1)",
            "total_spec",
            "zariski.inter_neigh_cl[OF",
            "RR(2,1)",
            "R].",
            "}",
            "then",
            "show",
            "\"V(\\<Inter>U)",
            "\\<subseteq>",
            "cl(U)\"",
            "apply",
            "(rule",
            "subsetI)",
            "closeBasic_def[of",
            "\"\\<Inter>U\"]",
            "V_is_closed(2)",
            "ideal",
            "ideal_dest_subset",
            "A",
            "B"
        ],
        "statement": "lemma (in ring0) closure_zariski:\n  assumes \"U \\<subseteq> Spec\" \"U\\<noteq>0\"\n  shows \"cl(U) = V(\\<Inter>U)\"\n",
        "proof": "proof\n  have \"U \\<subseteq> \\<I>\" using assms(1) unfolding Spec_def by auto\n  then have ideal:\"(\\<Inter>U)\\<triangleleft>R\" using intersection_ideals[of U] assms(2) by auto\n  {\n    fix t assume t:\"t\\<in>V(\\<Inter>U)\"\n    {\n      fix q assume q:\"q\\<in>\\<Inter>U\"\n      with q obtain M where \"M:U\" \"q:M\" using assms(2) by blast\n      with assms have \"q\\<in>\\<Union>Spec\" by auto\n      then have \"q:R\" unfolding Spec_def by auto\n    }\n    then have sub:\"\\<Inter>U \\<subseteq> R\" by auto\n    with t have tt:\"t\\<in>Spec\" \"\\<Inter>U \\<subseteq> t\" using closeBasic_def by auto\n    {\n      fix VV assume VV:\"VV\\<in>{D(J). J\\<in>\\<I>}\" \"t\\<in>VV\"\n      then obtain J where J:\"VV= D(J)\" \"J\\<in>\\<I>\" by auto\n      from VV(2) J have jt:\"\\<not>(J \\<subseteq> t)\" using openBasic_def by auto\n      {\n        assume \"U\\<inter>D(J) = 0\"\n        then have \"\\<forall>x\\<in>U. x\\<notin>D(J)\" by auto\n        with J(2) have \"\\<forall>x\\<in>U. J\\<subseteq>x\" using openBasic_def[of J]\n          assms(1) by auto\n        then have \"J\\<subseteq> \\<Inter>U \\<or> U=0\" by auto \n        with tt(2) jt have False using assms(2) by auto\n      }\n      then have \"U\\<inter>VV \\<noteq> 0\" using J(1) by auto\n    }\n    then have R:\"\\<forall>VV\\<in>{D(J). J\\<in>\\<I>}. t\\<in>VV \\<longrightarrow> VV\\<inter>U \\<noteq> 0\" by auto\n    from tt(1) assms(1) have RR:\"t\\<in>\\<Union>{D(J). J\\<in>\\<I>}\" \"U \\<subseteq> \\<Union>{D(J). J\\<in>\\<I>}\"\n      using total_spec by auto\n    have \"t\\<in>cl(U)\" using zariski.inter_neigh_cl[OF RR(2,1) R].\n  }\n  then show \"V(\\<Inter>U) \\<subseteq> cl(U)\"\n    apply (rule subsetI) by auto\n  {\n    fix p assume p:\"p\\<in>U\"\n    then have \"\\<Inter>U \\<subseteq>p\" by auto\n    moreover\n    from p assms(1) have \"p\\<in>Spec\" \"\\<Inter>U\\<subseteq>\\<Union>Spec\" by auto\n    then have \"p\\<in>Spec\" \"\\<Inter>U\\<subseteq>R\" unfolding Spec_def by auto\n    ultimately have \"p\\<in>V(\\<Inter>U)\" using closeBasic_def[of \"\\<Inter>U\"]\n      by auto\n  }\n  then have A:\"U\\<subseteq>V(\\<Inter>U)\" by auto\n  have B:\"V(\\<Inter>U){is closed in}{D(J). J\\<in>\\<I>}\"\n    using V_is_closed(2) ideal ideal_dest_subset by auto\n  show \"cl(U) \\<subseteq> V(\\<Inter>U)\"\n    apply (rule zariski.Top_3_L13[of \"V(\\<Inter>U)\" U])\n    using A B by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1875
    },
    "1690": {
        "type": "theorem",
        "text": "text\\<open>Noetherian rings have compact Zariski topology\\<close>\n",
        "assumes": "assumes \"\\<forall>I\\<in>\\<I>. (I{is finitely generated})\"\n  ",
        "using": [
            "total_spec",
            "M(1)",
            "union_open_basic[of",
            "?J]",
            "sum_ideals_noetherian[OF",
            "assms(1),",
            "of",
            "T(1)",
            "FinPow_def",
            "T]",
            "M(2)",
            "Finite_RepFun"
        ],
        "statement": "theorem (in ring0) zariski_compact:\n  assumes \"\\<forall>I\\<in>\\<I>. (I{is finitely generated})\"\n  shows \"Spec {is compact in} {D(I). I\\<in>\\<I>}\"\n  unfolding IsCompact_def\n",
        "proof": "proof(safe)\n  show \"\\<And>x. x \\<in> Spec \\<Longrightarrow> x \\<in> \\<Union>RepFun(\\<I>, D)\" using total_spec by auto\n  fix M assume M:\"M \\<subseteq> RepFun(\\<I>, D)\" \"Spec \\<subseteq> \\<Union>M\"\n  let ?J =\"{J\\<in>\\<I>. D(J)\\<in>M}\"\n  have m:\"M = RepFun(?J,D)\" using M(1) by auto\n  then have mm:\"\\<Union>M = D(\\<oplus>\\<^sub>I?J)\" using union_open_basic[of ?J] by auto\n  obtain T where T:\"T\\<in>FinPow(?J)\" \"(\\<oplus>\\<^sub>I?J) = \\<oplus>\\<^sub>IT\" using\n    sum_ideals_noetherian[OF assms(1), of ?J] by blast\n  from T(2) have \"D(\\<oplus>\\<^sub>I?J) = D(\\<oplus>\\<^sub>IT)\" by auto\n  moreover have \"T\\<subseteq>\\<I>\" using T(1) unfolding FinPow_def by auto\n  ultimately have \"D(\\<oplus>\\<^sub>I?J) = \\<Union>RepFun(T,D)\" using union_open_basic[of T]\n    by auto\n  with mm have \"\\<Union>M = \\<Union>RepFun(T,D)\" by auto\n  then have \"Spec \\<subseteq> \\<Union>RepFun(T,D)\" using M(2) by auto moreover\n  from T(1) have \"RepFun(T,D) \\<subseteq> RepFun(?J,D)\" unfolding FinPow_def by auto\n  with m have \"RepFun(T,D) \\<subseteq> M\" by auto moreover\n  from T(1) have \"Finite(RepFun(T,D))\" unfolding FinPow_def\n    using Finite_RepFun by auto\n  ultimately show \"\\<exists>N\\<in>FinPow(M). Spec \\<subseteq> \\<Union>N\" unfolding FinPow_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_Zariski_ZF",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF_2.thy",
        "id": 1876
    },
    "1691": {
        "type": "corollary",
        "text": "text\\<open>A quotient ring has a spectrum homeomorphic\nto a closed subspace of the spectrum of the base ring.\nSpecifically, the closed subspace associated to the\nideal by which we quotient.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(R,S)\"\n  defines \"g \\<equiv> \\<lambda>u\\<in>target_ring.Spec. f -`` u\"\n  ",
        "using": [
            "origin_ring.total_spec",
            "origin_ring.closeBasic_def[OF",
            "func1_1_L3[OF",
            "fun,",
            "of",
            "\"{\\<zero>\\<^sub>S}\"]]",
            "target_ring.total_spec",
            "bij_cont_open_homeo[of",
            "g",
            "\\<tau>\\<^sub>t",
            "\"\\<tau>\\<^sub>o{restricted",
            "to}V(ker)\"]",
            "spectrum_surj_bij[OF",
            "assms(1)]",
            "spectrum_surj_open[OF",
            "spectrum_surj_cont[OF",
            "g_def"
        ],
        "statement": "corollary (in ring_homo) surj_homeomorphism:\n  assumes \"f\\<in>surj(R,S)\"\n  defines \"g \\<equiv> \\<lambda>u\\<in>target_ring.Spec. f -`` u\"\n  shows \"IsAhomeomorphism(\\<tau>\\<^sub>t, \\<tau>\\<^sub>o{restricted to}V(ker), g)\"\n",
        "proof": "proof-\n  have \"\\<Union>(\\<tau>\\<^sub>o{restricted to}V(ker)) = origin_ring.Spec \\<inter> V(ker)\" unfolding\n    top_origin_def RestrictedTo_def using origin_ring.total_spec\n    by auto\n  then have \"\\<Union>(\\<tau>\\<^sub>o{restricted to}V(ker)) = V(ker)\"\n    using origin_ring.closeBasic_def[OF func1_1_L3[OF fun,\n    of \"{\\<zero>\\<^sub>S}\"]] by auto moreover\n  have \"\\<Union>\\<tau>\\<^sub>t = target_ring.Spec\" unfolding top_target_def\n    using target_ring.total_spec by auto\n  ultimately show ?thesis using bij_cont_open_homeo[of g \\<tau>\\<^sub>t \"\\<tau>\\<^sub>o{restricted to}V(ker)\"]\n    spectrum_surj_bij[OF assms(1)] spectrum_surj_open[OF assms(1)]\n    spectrum_surj_cont[OF assms(1)]\n    unfolding g_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_Zariski_ZF",
            "IsarMathLib.Ring_ZF_3",
            "IsarMathLib.Topology_ZF_2"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF_3.thy",
        "id": 1877
    },
    "1692": {
        "type": "definition",
        "text": "text\\<open>First we define a notion similar to \\<open>Fold\\<close>, except that\n  that the initial element of the fold is given by the first element\n  of sequence. By analogy with Haskell fold we call that \\<open>Fold1\\<close>\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Fold1(f,a) \\<equiv> Fold(f,a`(0),Tail(a))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1878
    },
    "1693": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows our assumption on the associativity\n  of the semigroup operation in the notation defined in in the \n  \\<open>semigr0\\<close> context.\\<close>\n",
        "assumes": "assumes \"x \\<in> G\"  \"y \\<in> G\"  \"z \\<in> G\"\n  ",
        "using": [
            "assms",
            "assoc_assum",
            "IsAssociative_def"
        ],
        "statement": "lemma (in semigr0) semigr_assoc: assumes \"x \\<in> G\"  \"y \\<in> G\"  \"z \\<in> G\"\n  shows \"x\\<cdot>y\\<cdot>z = x\\<cdot>(y\\<cdot>z)\"\n  ",
        "proof": "using assms assoc_assum IsAssociative_def by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1879
    },
    "1694": {
        "type": "lemma",
        "text": "text\\<open>In the way we define associativity the assumption that\n  $f$ is associative on $G$ also implies that it is a binary\n  operation on $X$.\\<close>\n",
        "assumes": "",
        "using": [
            "assoc_assum",
            "IsAssociative_def"
        ],
        "statement": "lemma (in semigr0) semigr_binop: shows \"f : G\\<times>G \\<rightarrow> G\"\n  ",
        "proof": "using assoc_assum IsAssociative_def by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1880
    },
    "1695": {
        "type": "lemma",
        "text": "text\\<open>Semigroup operation is closed.\\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\" ",
        "using": [
            "assms",
            "semigr_binop",
            "apply_funtype"
        ],
        "statement": "lemma (in semigr0) semigr_closed: \n  assumes \"a\\<in>G\"  \"b\\<in>G\" shows \"a\\<cdot>b \\<in> G\"\n  ",
        "proof": "using assms semigr_binop apply_funtype by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1881
    },
    "1696": {
        "type": "lemma",
        "text": "text\\<open>Lemma \\<open>append_1elem\\<close> written in the notation used in \n  the \\<open>semigr0\\<close> context.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"a: n \\<rightarrow> X\" and \"b : 1 \\<rightarrow> X\"\n  ",
        "using": [
            "assms",
            "append_1elem"
        ],
        "statement": "lemma (in semigr0) append_1elem_nice: \n  assumes \"n \\<in> nat\" and \"a: n \\<rightarrow> X\" and \"b : 1 \\<rightarrow> X\"\n  shows \"a \\<squnion> b = a \\<hookleftarrow> b`(0)\"\n  ",
        "proof": "using assms append_1elem by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1882
    },
    "1697": {
        "type": "lemma",
        "text": "text\\<open>Lemma \\<open>concat_init_last_elem\\<close> rewritten\n  in the notation used in the \\<open>semigr0\\<close> context.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"  \"k \\<in> nat\" and \n  \"a: n \\<rightarrow> X\"  and \"b : succ(k) \\<rightarrow> X\"\n  ",
        "using": [
            "assms",
            "concat_init_last_elem"
        ],
        "statement": "lemma (in semigr0) concat_init_last: \n  assumes \"n \\<in> nat\"  \"k \\<in> nat\" and \n  \"a: n \\<rightarrow> X\"  and \"b : succ(k) \\<rightarrow> X\"\n  shows \"(a \\<squnion> Init(b)) \\<hookleftarrow> b`(k) = a \\<squnion> b\"\n  ",
        "proof": "using assms concat_init_last_elem by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1883
    },
    "1698": {
        "type": "lemma",
        "text": "text\\<open>The product of semigroup (actually, magma -- we don't\n   need associativity for this) elements is in the semigroup.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"a : succ(n) \\<rightarrow> G\"\n  ",
        "using": [
            "semigr_binop",
            "tail_props",
            "empty_in_every_succ",
            "apply_funtype",
            "Fold1_def",
            "fold_props"
        ],
        "statement": "lemma (in semigr0) prod_type: \n  assumes \"n \\<in> nat\" and \"a : succ(n) \\<rightarrow> G\"\n  shows \"(\\<Prod> a) \\<in> G\"\n",
        "proof": "proof -\n  from assms have \n    \"succ(n) \\<in> nat\"  \"f : G\\<times>G \\<rightarrow> G\"  \"Tail(a) : n \\<rightarrow> G\"\n    using semigr_binop tail_props by auto\n  moreover from assms have \"a`(0) \\<in> G\" and \"G \\<noteq> 0\"\n    using empty_in_every_succ apply_funtype\n    by auto\n  ultimately show \"(\\<Prod> a) \\<in> G\" using Fold1_def fold_props\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1884
    },
    "1699": {
        "type": "lemma",
        "text": "text\\<open>What is the product of one element list?\\<close>\n",
        "assumes": "assumes A1: \"a: 1 \\<rightarrow> G\"\n  ",
        "using": [
            "semigr_binop",
            "tail_props",
            "apply_funtype",
            "fold_empty",
            "Fold1_def"
        ],
        "statement": "lemma (in semigr0) prod_of_1elem: assumes A1: \"a: 1 \\<rightarrow> G\"\n  shows \"(\\<Prod> a) = a`(0)\"\n",
        "proof": "proof -\n  have \"f : G\\<times>G \\<rightarrow> G\" using semigr_binop by simp\n  moreover from A1 have \"Tail(a) : 0 \\<rightarrow> G\" using tail_props\n    by blast\n  moreover from A1 have \"a`(0) \\<in> G\" and \"G \\<noteq> 0\" \n    using apply_funtype by auto\n  ultimately show \"(\\<Prod> a) =  a`(0)\" using fold_empty Fold1_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1885
    },
    "1700": {
        "type": "lemma",
        "text": "text\\<open>What happens to the product of a list when we append an element \n  to the list?\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\" and\n  A2: \"a : succ(n) \\<rightarrow> G\" and A3: \"x\\<in>G\"\n  ",
        "using": [
            "tail_props",
            "empty_in_every_succ",
            "apply_funtype",
            "head_of_append",
            "tail_append_commute",
            "Fold1_def",
            "semigr_binop",
            "fold_append"
        ],
        "statement": "lemma (in semigr0) prod_append: assumes A1: \"n \\<in> nat\" and\n  A2: \"a : succ(n) \\<rightarrow> G\" and A3: \"x\\<in>G\"\n  shows \"(\\<Prod> a\\<hookleftarrow>x) = (\\<Prod> a) \\<cdot> x\"\n",
        "proof": "proof -\n  from A1 A2 have I: \"Tail(a) : n \\<rightarrow> G\"  \"a`(0) \\<in> G\"\n    using tail_props empty_in_every_succ apply_funtype\n    by auto\n  from assms have \"(\\<Prod> a\\<hookleftarrow>x) = Fold(f,a`(0),Tail(a)\\<hookleftarrow>x)\"\n    using head_of_append tail_append_commute Fold1_def\n    by simp\n  also from A1 A3 I have \"\\<dots> = (\\<Prod> a) \\<cdot> x\"\n    using semigr_binop fold_append Fold1_def \n    by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1886
    },
    "1701": {
        "type": "theorem",
        "text": "text\\<open>The main theorem of the section: taking the product of \n  a sequence is distributive with respect to concatenation of sequences.\n  The proof is by induction on the length of the second list.\\<close>\n",
        "assumes": "assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and\n  A2: \"a : succ(n) \\<rightarrow> G\"   \"b: succ(k) \\<rightarrow> G\"\n  ",
        "using": [
            "apply_funtype",
            "prod_append",
            "semigr_binop",
            "prod_of_1elem",
            "init_props",
            "prod_type",
            "semigr_assoc",
            "succ_plus"
        ],
        "statement": "theorem (in semigr0) prod_conc_distr: \n  assumes A1: \"n \\<in> nat\"  \"k \\<in> nat\" and\n  A2: \"a : succ(n) \\<rightarrow> G\"   \"b: succ(k) \\<rightarrow> G\"\n  shows \"(\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)\"\n",
        "proof": "proof -\n  from A1 have \"k \\<in> nat\" by simp\n  moreover have \"\\<forall>b \\<in> succ(0) \\<rightarrow> G. (\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)\"\n  proof -\n    { fix b assume A3: \"b : succ(0) \\<rightarrow> G\"\n      with A1 A2 have\n\t\"succ(n) \\<in> nat\"  \"a : succ(n) \\<rightarrow> G\"  \"b : 1 \\<rightarrow> G\" \n\tby auto\n      then have \"a \\<squnion> b = a \\<hookleftarrow> b`(0)\" by (rule append_1elem_nice)\n      with A1 A2 A3 have \"(\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)\"\n\tusing apply_funtype prod_append semigr_binop prod_of_1elem\n\tby simp\n    } thus ?thesis by simp\n  qed\n  moreover have \"\\<forall>j \\<in> nat. \n    (\\<forall>b \\<in> succ(j) \\<rightarrow> G. (\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)) \\<longrightarrow>\n    (\\<forall>b \\<in> succ(succ(j)) \\<rightarrow> G. (\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b))\"\n  proof -\n    { fix j assume A4: \"j \\<in> nat\" and \n      A5: \"(\\<forall>b \\<in> succ(j) \\<rightarrow> G. (\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b))\"\n      { fix b assume A6: \"b : succ(succ(j)) \\<rightarrow> G\"\n\tlet ?c = \"Init(b)\"\n\tfrom A4 A6 have  T: \"b`(succ(j)) \\<in> G\" and\n\t  I: \"?c : succ(j) \\<rightarrow> G\" and II: \"b = ?c\\<hookleftarrow>b`(succ(j))\"\n\t  using apply_funtype init_props by auto\n\tfrom A1 A2 A4 A6 have\n\t  \"succ(n) \\<in> nat\"  \"succ(j) \\<in> nat\"\n\t  \"a : succ(n) \\<rightarrow> G\"  \"b : succ(succ(j)) \\<rightarrow> G\"\n\t  by auto\n\tthen have III: \"(a \\<squnion> ?c) \\<hookleftarrow> b`(succ(j)) = a \\<squnion> b\"\n\t  by (rule concat_init_last)\n\tfrom A4 I T have \"(\\<Prod> ?c\\<hookleftarrow>b`(succ(j))) = (\\<Prod> ?c) \\<cdot> b`(succ(j))\"\n\t  by (rule prod_append)\n\twith II have \n\t  \"(\\<Prod> a) \\<cdot> (\\<Prod> b) = (\\<Prod> a) \\<cdot> ((\\<Prod> ?c) \\<cdot> b`(succ(j)))\"\n\t  by simp\n\tmoreover from A1 A2 A4 T I have\n\t  \"(\\<Prod> a) \\<in> G\"  \"(\\<Prod> ?c) \\<in> G\"  \"b`(succ(j)) \\<in> G\"\n\t  using prod_type by auto\n\tultimately have \n\t  \"(\\<Prod> a) \\<cdot> (\\<Prod> b) =  ((\\<Prod> a) \\<cdot> (\\<Prod> ?c)) \\<cdot> b`(succ(j))\"\n\t  using semigr_assoc by auto\n\twith A5 I have \"(\\<Prod> a) \\<cdot> (\\<Prod> b) = (\\<Prod> (a \\<squnion> ?c))\\<cdot>b`(succ(j))\"\n\t  by simp\n\tmoreover\n\tfrom A1 A2 A4 I have\n\t  T1: \"succ(n) \\<in> nat\"  \"succ(j) \\<in> nat\" and\n\t  \"a : succ(n) \\<rightarrow> G\"   \"?c : succ(j) \\<rightarrow> G\"\n\t  by auto\n\tthen have \"Concat(a,?c): succ(n) #+ succ(j) \\<rightarrow> G\"\n\t  by (rule concat_props)\n\twith A1 A4 T have\n\t  \"succ(n #+ j) \\<in> nat\"   \n\t  \"a \\<squnion> ?c : succ(succ(n #+j)) \\<rightarrow> G\"\n\t  \"b`(succ(j)) \\<in> G\"\n\t  using succ_plus by auto\n\tthen have \n\t  \"(\\<Prod> (a \\<squnion> ?c)\\<hookleftarrow>b`(succ(j))) = (\\<Prod> (a \\<squnion> ?c))\\<cdot>b`(succ(j))\"\n\t  by (rule prod_append)\n\twith III have \"(\\<Prod> (a \\<squnion> ?c))\\<cdot>b`(succ(j)) =  \\<Prod> (a \\<squnion> b)\"\n\t  by simp\n\tultimately have \"(\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)\"\n\t  by simp\n      } hence \"(\\<forall>b \\<in> succ(succ(j)) \\<rightarrow> G. (\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b))\"\n\tby simp\n    } thus ?thesis by blast\n  qed\n  ultimately have \"\\<forall>b \\<in> succ(k) \\<rightarrow> G. (\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)\"\n    by (rule ind_on_nat)\n  with A2 show \"(\\<Prod> a) \\<cdot> (\\<Prod> b) = \\<Prod> (a \\<squnion> b)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1887
    },
    "1702": {
        "type": "definition",
        "text": "text\\<open>Suppose $a: X \\rightarrow G$ is an indexed family of elements\n  of a semigroup $G$ and \n  $\\Lambda = \\{i_0, i_1, .. , i_{n-1}\\} \\subseteq \\mathbb{N}$ is a finite \n  set of indices. We want to define \n  $\\prod_{i\\in \\Lambda} a_i = a_{i_0}\\cdot a_{i_1} \\cdot .. \\cdot a_{i-1}$.\n  To do that we use the notion of \\<open>Enumeration\\<close> defined in the\n  \\<open>Enumeration_ZF\\<close> theory file that takes a set of indices and \n  lists them in increasing order, thus converting it to list. Then we use \n  the \\<open>Fold1\\<close> to multiply the resulting list. Recall that in \n  Isabelle/ZF the capital letter ''O'' denotes the composition of two \n  functions (or relations).\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SetFold(f,a,\\<Lambda>,r) = Fold1(f,a O Enumeration(\\<Lambda>,r))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1889
    },
    "1703": {
        "type": "lemma",
        "text": "text\\<open>We can use the \\<open>enums\\<close> locale in the \\<open>semigr0\\<close> \n  context.\\<close>\n",
        "assumes": "",
        "using": [
            "linord",
            "enums_def"
        ],
        "statement": "lemma (in semigr1) enums_valid_in_semigr1: shows \"enums(X,r)\"\n  ",
        "proof": "using linord enums_def by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1890
    },
    "1704": {
        "type": "lemma",
        "text": "text\\<open>Definition of product over a set expressed\n  in notation of the \\<open>semigr0\\<close> locale.\\<close>\n",
        "assumes": "",
        "using": [
            "SetFold_def"
        ],
        "statement": "lemma (in semigr1) setproddef: \n  shows \"\\<pr>(\\<Lambda>,a) = \\<Prod> (a O \\<sigma>(\\<Lambda>))\"\n  ",
        "proof": "using SetFold_def by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1891
    },
    "1705": {
        "type": "lemma",
        "text": "text\\<open>A composition of enumeration of a nonempty \n  finite subset of $\\mathbb{N}$\n  with a sequence of elements of $G$ is a nonempty list of elements of $G$.\n  This implies that a product over set of a finite set of indices belongs\n  to the (carrier of) semigroup.\n\\<close>\n",
        "assumes": "assumes \n  A1: \"\\<Lambda> \\<in> FinPow(X)\" and A2: \"\\<Lambda>\\<noteq>0\"\n  ",
        "using": [
            "card_non_empty_succ",
            "enums_valid_in_semigr1",
            "enums.enum_props",
            "a_is_fun",
            "FinPow_def",
            "comp_fun_subset",
            "prod_type",
            "setproddef"
        ],
        "statement": "lemma (in semigr1) setprod_type: assumes \n  A1: \"\\<Lambda> \\<in> FinPow(X)\" and A2: \"\\<Lambda>\\<noteq>0\"\n  shows \n  \"\\<exists>n \\<in> nat . |\\<Lambda>| = succ(n) \\<and> a O \\<sigma>(\\<Lambda>) : succ(n) \\<rightarrow> G\"\n  and \"\\<pr>(\\<Lambda>,a) \\<in> G\"\n",
        "proof": "proof -\n  from assms obtain n where \"n \\<in> nat\" and \"|\\<Lambda>| = succ(n)\"\n    using card_non_empty_succ by auto\n  from A1 have \"\\<sigma>(\\<Lambda>) : |\\<Lambda>| \\<rightarrow> \\<Lambda>\"\n    using enums_valid_in_semigr1 enums.enum_props \n    by simp\n  with A1 have \"a O \\<sigma>(\\<Lambda>): |\\<Lambda>| \\<rightarrow> G\"\n    using a_is_fun FinPow_def comp_fun_subset \n    by simp\n  with \\<open>n \\<in> nat\\<close> and \\<open>|\\<Lambda>| = succ(n)\\<close> show \n    \"\\<exists>n \\<in> nat . |\\<Lambda>| = succ(n) \\<and> a O \\<sigma>(\\<Lambda>) : succ(n) \\<rightarrow> G\"\n    by auto\n  from  \\<open>n \\<in> nat\\<close> \\<open>|\\<Lambda>| = succ(n)\\<close> \\<open>a O \\<sigma>(\\<Lambda>): |\\<Lambda>| \\<rightarrow> G\\<close>\n  show \"\\<pr>(\\<Lambda>,a) \\<in> G\" using prod_type setproddef \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1892
    },
    "1706": {
        "type": "lemma",
        "text": "text\\<open>The \\<open>enum_append\\<close> lemma from the \n  \\<open>Enemeration\\<close> theory specialized for natural\n  numbers.\\<close> \n",
        "assumes": "assumes \"\\<Lambda> \\<in> FinPow(X)\" and\n  \"n \\<in> X - \\<Lambda>\" and \"\\<forall>k\\<in>\\<Lambda>. \\<langle>k,n\\<rangle> \\<in> r\"\n  ",
        "using": [
            "assms",
            "FinPow_def",
            "enums_valid_in_semigr1",
            "enums.enum_append"
        ],
        "statement": "lemma (in semigr1) semigr1_enum_append: \n  assumes \"\\<Lambda> \\<in> FinPow(X)\" and\n  \"n \\<in> X - \\<Lambda>\" and \"\\<forall>k\\<in>\\<Lambda>. \\<langle>k,n\\<rangle> \\<in> r\"\n  shows \"\\<sigma>(\\<Lambda> \\<union> {n}) = \\<sigma>(\\<Lambda>)\\<hookleftarrow> n\"\n  ",
        "proof": "using assms  FinPow_def enums_valid_in_semigr1 \n    enums.enum_append by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1893
    },
    "1707": {
        "type": "lemma",
        "text": "text\\<open>What is product over a singleton?\\<close>\n",
        "assumes": "assumes A1: \"x \\<in> X\"\n  ",
        "using": [
            "enums_valid_in_semigr1",
            "enums.enum_singleton",
            "a_is_fun",
            "comp_fun",
            "setproddef",
            "prod_of_1elem",
            "comp_fun_apply"
        ],
        "statement": "lemma (in semigr1) gen_prod_singleton: \n  assumes A1: \"x \\<in> X\"\n  shows  \"\\<pr>({x},a) = a`(x)\"\n",
        "proof": "proof -\n  from A1 have \"\\<sigma>({x}): 1 \\<rightarrow> X\" and  \"\\<sigma>({x})`(0) = x\"\n    using enums_valid_in_semigr1 enums.enum_singleton\n    by auto\n  then show \"\\<pr>({x},a) = a`(x)\"\n    using a_is_fun comp_fun setproddef prod_of_1elem \n      comp_fun_apply by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1894
    },
    "1708": {
        "type": "lemma",
        "text": "text\\<open>A generalization of \\<open>prod_append\\<close> to the products\n  over sets of indices.\\<close>\n",
        "assumes": "assumes\n  A1: \"\\<Lambda> \\<in> FinPow(X)\" and A2: \"\\<Lambda> \\<noteq> 0\" and\n  A3: \"n \\<in> X -  \\<Lambda>\" and\n  A4: \"\\<forall>k\\<in>\\<Lambda>. \\<langle>k,n\\<rangle> \\<in> r\"\n  ",
        "using": [
            "setproddef",
            "semigr1_enum_append",
            "card_fin_is_nat",
            "enums_valid_in_semigr1",
            "enums.enum_fun",
            "a_is_fun",
            "list_compose_append",
            "setprod_type",
            "apply_funtype",
            "prod_append",
            "SetFold_def"
        ],
        "statement": "lemma (in semigr1) gen_prod_append: \n  assumes\n  A1: \"\\<Lambda> \\<in> FinPow(X)\" and A2: \"\\<Lambda> \\<noteq> 0\" and\n  A3: \"n \\<in> X -  \\<Lambda>\" and\n  A4: \"\\<forall>k\\<in>\\<Lambda>. \\<langle>k,n\\<rangle> \\<in> r\"\n  shows \"\\<pr>(\\<Lambda> \\<union> {n}, a) = (\\<pr>(\\<Lambda>,a)) \\<cdot> a`(n)\"\n",
        "proof": "proof -\n  have \"\\<pr>(\\<Lambda> \\<union> {n}, a) =  \\<Prod> (a O \\<sigma>(\\<Lambda> \\<union> {n}))\"\n    using setproddef by simp\n  also from A1 A3 A4 have \"\\<dots> = \\<Prod> (a O (\\<sigma>(\\<Lambda>)\\<hookleftarrow> n))\"\n    using semigr1_enum_append by simp\n  also have \"\\<dots> = \\<Prod> ((a O \\<sigma>(\\<Lambda>))\\<hookleftarrow> a`(n))\"\n  proof -\n    from A1 A3 have \n      \"|\\<Lambda>| \\<in> nat\" and \"\\<sigma>(\\<Lambda>) : |\\<Lambda>| \\<rightarrow> X\" and \"n \\<in> X\" \n      using card_fin_is_nat enums_valid_in_semigr1 enums.enum_fun\n      by auto\n    then show ?thesis using a_is_fun list_compose_append\n      by simp\n  qed\n  also from assms have \"\\<dots> = (\\<Prod> (a O \\<sigma>(\\<Lambda>)))\\<cdot>a`(n)\"\n    using a_is_fun setprod_type apply_funtype prod_append\n    by blast\n  also have \"\\<dots> = (\\<pr>(\\<Lambda>,a)) \\<cdot> a`(n)\" \n    using SetFold_def by simp\n  finally show \"\\<pr>(\\<Lambda> \\<union> {n}, a) = (\\<pr>(\\<Lambda>,a)) \\<cdot> a`(n)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1895
    },
    "1709": {
        "type": "lemma",
        "text": "text\\<open>Very similar to \\<open>gen_prod_append\\<close>: a relation\n  between a product over a set of indices and the product\n  over the set with the maximum removed.\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" and\n  A2: \"n \\<in> A\" and  A4: \"A - {n} \\<noteq> 0\" and\n  A3: \"\\<forall>k\\<in>A. \\<langle>k, n\\<rangle> \\<in> r\"\n  ",
        "using": [
            "fin_rem_point_fin",
            "FinPow_def",
            "a_is_fun",
            "gen_prod_append",
            "rem_add_eq"
        ],
        "statement": "lemma (in semigr1) gen_product_rem_point:\n  assumes A1: \"A \\<in> FinPow(X)\" and\n  A2: \"n \\<in> A\" and  A4: \"A - {n} \\<noteq> 0\" and\n  A3: \"\\<forall>k\\<in>A. \\<langle>k, n\\<rangle> \\<in> r\"\n  shows\n  \"(\\<pr>(A - {n},a)) \\<cdot> a`(n) = \\<pr>(A, a)\"\n",
        "proof": "proof -\n  let ?\\<Lambda> = \"A - {n}\"\n  from A1 A2 have \"?\\<Lambda> \\<in> FinPow(X)\" and \"n \\<in> X -  ?\\<Lambda>\"\n    using fin_rem_point_fin FinPow_def by auto\n  with A3 A4 have \"\\<pr>(?\\<Lambda> \\<union> {n}, a) = (\\<pr>(?\\<Lambda>,a)) \\<cdot> a`(n)\"\n    using a_is_fun gen_prod_append by blast\n  with A2 show ?thesis using rem_add_eq by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1896
    },
    "1710": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement with 3 elements.\\<close>\n",
        "assumes": "assumes \"f {is commutative on} G\" and \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  ",
        "using": [
            "assms",
            "semigr_assoc",
            "IsCommutative_def"
        ],
        "statement": "lemma (in semigr0) rearr3elems:\n  assumes \"f {is commutative on} G\" and \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"\n  shows \"a\\<cdot>b\\<cdot>c = a\\<cdot>c\\<cdot>b\"\n  ",
        "proof": "using assms semigr_assoc IsCommutative_def by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1897
    },
    "1711": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement of four elements.\\<close>\n",
        "assumes": "assumes A1: \"f {is commutative on} G\" and \n  A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "semigr_closed",
            "semigr_assoc",
            "IsCommutative_def"
        ],
        "statement": "lemma (in semigr0) rearr4elems: \n  assumes A1: \"f {is commutative on} G\" and \n  A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n",
        "proof": "proof -\n  from A2 have \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>b\\<cdot>c\\<cdot>d\"\n    using semigr_closed semigr_assoc by simp\n  also have \"a\\<cdot>b\\<cdot>c\\<cdot>d =  a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n  proof -\n    from A1 A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d = c\\<cdot>(a\\<cdot>b)\\<cdot>d\"\n      using IsCommutative_def semigr_closed \n      by simp\n    also from A2 have \"\\<dots> =  c\\<cdot>a\\<cdot>b\\<cdot>d\"\n      using semigr_closed semigr_assoc \n      by simp\n    also from A1 A2 have \"\\<dots> = a\\<cdot>c\\<cdot>b\\<cdot>d\"\n      using IsCommutative_def semigr_closed \n      by simp\n    also from A2 have \"\\<dots> = a\\<cdot>c\\<cdot>(b\\<cdot>d)\" \n      using semigr_closed semigr_assoc\n      by simp\n    finally show  \"a\\<cdot>b\\<cdot>c\\<cdot>d =  a\\<cdot>c\\<cdot>(b\\<cdot>d)\" by simp\n  qed\n  finally show  \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1898
    },
    "1712": {
        "type": "lemma",
        "text": "text\\<open>We start with a version of \\<open>prod_append\\<close> that will shorten a bit\n  the proof of the main theorem.\\<close>\n",
        "assumes": "assumes A1: \"k \\<in> nat\" and\n  A2: \"a \\<in> succ(succ(k)) \\<rightarrow> G\" \n  ",
        "using": [
            "apply_funtype",
            "init_props",
            "prod_append"
        ],
        "statement": "lemma (in semigr0) shorter_seq: assumes A1: \"k \\<in> nat\" and\n  A2: \"a \\<in> succ(succ(k)) \\<rightarrow> G\" \n  shows \"(\\<Prod> a) = (\\<Prod> Init(a)) \\<cdot> a`(succ(k))\"\n",
        "proof": "proof -\n  let ?x = \"Init(a)\"\n  from assms have\n    \"a`(succ(k)) \\<in> G\" and \"?x : succ(k) \\<rightarrow> G\"\n    using apply_funtype init_props by auto\n  with A1 have \"(\\<Prod> ?x\\<hookleftarrow>a`(succ(k))) = (\\<Prod> ?x) \\<cdot> a`(succ(k))\"\n    using prod_append by simp\n  with assms show ?thesis using init_props\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1899
    },
    "1713": {
        "type": "lemma",
        "text": "text\\<open>A lemma useful in the induction step of the main theorem.\\<close>\n",
        "assumes": "assumes A1: \"k \\<in> nat\" and\n  A2: \"a : succ(succ(k)) \\<rightarrow> G\" and\n  A3: \"b : succ(succ(k)) \\<rightarrow> G\" and\n  A4: \"c : succ(succ(k)) \\<rightarrow> G\" and\n  A5: \"\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j)\"\n  ",
        "using": [
            "init_props"
        ],
        "statement": "lemma (in semigr0) prod_distr_ind_step:\n  assumes A1: \"k \\<in> nat\" and\n  A2: \"a : succ(succ(k)) \\<rightarrow> G\" and\n  A3: \"b : succ(succ(k)) \\<rightarrow> G\" and\n  A4: \"c : succ(succ(k)) \\<rightarrow> G\" and\n  A5: \"\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j)\"\n  shows\n  \"Init(a) : succ(k) \\<rightarrow> G\"\n  \"Init(b) : succ(k) \\<rightarrow> G\"\n  \"Init(c) : succ(k) \\<rightarrow> G\"\n  \"\\<forall>j\\<in>succ(k). Init(c)`(j) = Init(a)`(j) \\<cdot> Init(b)`(j)\"\n",
        "proof": "proof -\n  from A1 A2 A3 A4 show \n    \"Init(a) : succ(k) \\<rightarrow> G\"\n    \"Init(b) : succ(k) \\<rightarrow> G\"\n    \"Init(c) : succ(k) \\<rightarrow> G\"\n    using init_props by auto\n  from A1 have T: \"succ(k) \\<in> nat\" by simp\n  from T A2 have \"\\<forall>j\\<in>succ(k). Init(a)`(j) = a`(j)\"\n    by (rule init_props)\n  moreover from T A3 have \"\\<forall>j\\<in>succ(k). Init(b)`(j) = b`(j)\"\n     by (rule init_props)\n   moreover from T A4 have \"\\<forall>j\\<in>succ(k). Init(c)`(j) = c`(j)\"\n     by (rule init_props)\n   moreover from A5 have \"\\<forall>j\\<in>succ(k). c`(j) = a`(j) \\<cdot> b`(j)\"\n     by simp\n   ultimately show \"\\<forall>j\\<in>succ(k). Init(c)`(j) = Init(a)`(j) \\<cdot> Init(b)`(j)\"\n     by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1900
    },
    "1714": {
        "type": "theorem",
        "text": "text\\<open>A reformulation of \\<open>prod_comm_distr\\<close> that is more\n  convenient in applications.\\<close>\n",
        "assumes": "assumes  \"f {is commutative on} G\" and \"n\\<in>nat\" and\n  \"a : succ(n)\\<rightarrow>G\"  \"b : succ(n)\\<rightarrow>G\"  \"c : succ(n)\\<rightarrow>G\" and\n  \"\\<forall>j\\<in>succ(n). c`(j) = a`(j) \\<cdot> b`(j)\"\n  ",
        "using": [
            "assms",
            "prod_comm_distr"
        ],
        "statement": "theorem (in semigr0) prod_comm_distrib:\n  assumes  \"f {is commutative on} G\" and \"n\\<in>nat\" and\n  \"a : succ(n)\\<rightarrow>G\"  \"b : succ(n)\\<rightarrow>G\"  \"c : succ(n)\\<rightarrow>G\" and\n  \"\\<forall>j\\<in>succ(n). c`(j) = a`(j) \\<cdot> b`(j)\"\n  shows \"(\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\"\n  ",
        "proof": "using assms prod_comm_distr by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1902
    },
    "1715": {
        "type": "lemma",
        "text": "text\\<open>A generalization of \\<open>prod_disjoint\\<close>.\\<close>\n",
        "assumes": "assumes\n  A1: \"f {is commutative on} G\"  and A2: \"n \\<in> nat\"\n  ",
        "using": [
            "a_is_fun",
            "func1_1_L1",
            "Partition_def",
            "apply_funtype",
            "setprod_type",
            "list_len1_singleton",
            "prod_of_1elem",
            "prod_append",
            "restrict_type2",
            "restrict",
            "prod_disjoint"
        ],
        "statement": "lemma (in semigr1) prod_list_of_lists: assumes\n  A1: \"f {is commutative on} G\"  and A2: \"n \\<in> nat\"\n  shows \"\\<forall>M \\<in> succ(n) \\<rightarrow> FinPow(X). \n  M {is partition} \\<longrightarrow> \n  (\\<Prod> {\\<langle>i,\\<pr>(M`(i),a)\\<rangle>. i \\<in> succ(n)}) = \n  (\\<pr>(\\<Union>i \\<in> succ(n). M`(i),a))\"\n",
        "proof": "proof -\n  note A2\n  moreover have \"\\<forall>M \\<in> succ(0) \\<rightarrow> FinPow(X). \n    M {is partition} \\<longrightarrow> \n    (\\<Prod> {\\<langle>i,\\<pr>(M`(i),a)\\<rangle>. i \\<in> succ(0)}) = (\\<pr>(\\<Union>i \\<in> succ(0). M`(i),a))\"\n    using a_is_fun func1_1_L1 Partition_def apply_funtype setprod_type\n      list_len1_singleton prod_of_1elem \n    by simp\n  moreover have \"\\<forall>k \\<in> nat. \n    (\\<forall>M \\<in> succ(k) \\<rightarrow> FinPow(X). \n    M {is partition} \\<longrightarrow> \n    (\\<Prod> {\\<langle>i,\\<pr>(M`(i),a)\\<rangle>. i \\<in> succ(k)}) = \n    (\\<pr>(\\<Union>i \\<in> succ(k). M`(i),a))) \\<longrightarrow>\n    (\\<forall>M \\<in> succ(succ(k)) \\<rightarrow> FinPow(X). \n    M {is partition} \\<longrightarrow> \n    (\\<Prod> {\\<langle>i,\\<pr>(M`(i),a)\\<rangle>. i \\<in> succ(succ(k))}) = \n    (\\<pr>(\\<Union>i \\<in> succ(succ(k)). M`(i),a)))\"\n  proof -\n    { fix k assume \"k \\<in> nat\"\n      assume A3: \"\\<forall>M \\<in> succ(k) \\<rightarrow> FinPow(X). \n\tM {is partition} \\<longrightarrow> \n\t(\\<Prod> {\\<langle>i,\\<pr>(M`(i),a)\\<rangle>. i \\<in> succ(k)}) = \n\t(\\<pr>(\\<Union>i \\<in> succ(k). M`(i),a))\"\n      have \"(\\<forall>N \\<in> succ(succ(k)) \\<rightarrow> FinPow(X). \n\tN {is partition} \\<longrightarrow> \n\t(\\<Prod> {\\<langle>i,\\<pr>(N`(i),a)\\<rangle>. i \\<in> succ(succ(k))}) = \n\t(\\<pr>(\\<Union>i \\<in> succ(succ(k)). N`(i),a)))\"\n      proof -\n\t{ fix N assume A4: \"N : succ(succ(k)) \\<rightarrow> FinPow(X)\"\n\t  assume A5: \"N {is partition}\"\n\t  with A4 have I: \"\\<forall>i \\<in> succ(succ(k)). N`(i) \\<noteq> 0\"\n\t    using func1_1_L1 Partition_def by simp\n\t  let ?b = \"{\\<langle>i,\\<pr>(N`(i),a)\\<rangle>. i \\<in> succ(succ(k))}\"\n\t  let ?c = \"{\\<langle>i,\\<pr>(N`(i),a)\\<rangle>. i \\<in> succ(k)}\"\n\t  have II: \"\\<forall>i \\<in> succ(succ(k)). \\<pr>(N`(i),a) \\<in> G\"\n\t  proof \n\t    fix i assume \"i \\<in> succ(succ(k))\"\n\t    with A4 I have \"N`(i) \\<in> FinPow(X)\" and \"N`(i) \\<noteq> 0\"\n\t      using apply_funtype by auto\n\t    then show \"\\<pr>(N`(i),a) \\<in> G\" using setprod_type\n\t      by simp\n\t  qed\n\t  hence \"\\<forall>i \\<in> succ(k).  \\<pr>(N`(i),a) \\<in> G\" by auto\n\t  then have \"?c : succ(k) \\<rightarrow> G\" by (rule ZF_fun_from_total)\n\t  have \"?b = {\\<langle>i,\\<pr>(N`(i),a)\\<rangle>. i \\<in> succ(succ(k))}\"\n\t    by simp\n\t  with II have \"?b = Append(?c,\\<pr>(N`(succ(k)),a))\"\n\t    by (rule set_list_append)\n\t  with  II  \\<open>k \\<in> nat\\<close> \\<open>?c : succ(k) \\<rightarrow> G\\<close> \n\t  have \"(\\<Prod> ?b) = (\\<Prod> ?c)\\<cdot>(\\<pr>(N`(succ(k)),a))\"\n\t    using prod_append by simp\n\t  also have \n\t    \"\\<dots> =  (\\<pr>(\\<Union>i \\<in> succ(k). N`(i),a))\\<cdot>(\\<pr>(N`(succ(k)),a))\"\n\t  proof -\n\t    let ?M = \"restrict(N,succ(k))\"\n\t    have \"succ(k) \\<subseteq> succ(succ(k))\" by auto\n\t    with \\<open>N : succ(succ(k)) \\<rightarrow> FinPow(X)\\<close>\n\t    have \"?M : succ(k) \\<rightarrow> FinPow(X)\" and\n\t      III: \"\\<forall>i \\<in> succ(k). ?M`(i) = N`(i)\"\n\t      using restrict_type2 restrict apply_funtype \n\t      by auto\n\t    with A5 \\<open>?M : succ(k) \\<rightarrow> FinPow(X)\\<close>have \"?M {is partition}\"\n\t      using func1_1_L1 Partition_def by simp\n\t    with A3 \\<open>?M : succ(k) \\<rightarrow> FinPow(X)\\<close> have\n\t      \"(\\<Prod> {\\<langle>i,\\<pr>(?M`(i),a)\\<rangle>. i \\<in> succ(k)}) = \n\t      (\\<pr>(\\<Union>i \\<in> succ(k). ?M`(i),a))\"\n\t      by blast\n\t    with III show ?thesis by simp\n\t  qed\n\t  also have \"\\<dots> = (\\<pr>(\\<Union>i \\<in> succ(succ(k)). N`(i),a))\"\n\t  proof -\n\t    let ?A = \"\\<Union>i \\<in> succ(k). N`(i)\"\n\t    let ?B = \"N`(succ(k))\"\n\t    from A4 \\<open>k \\<in> nat\\<close> have \"succ(k) \\<in> nat\" and\n\t      \"\\<forall>i \\<in> succ(k). N`(i) \\<in> FinPow(X)\"\n\t      using apply_funtype by auto\n\t    then have \"?A \\<in> FinPow(X)\" by (rule union_fin_list_fin)\n\t    moreover from I have \"?A \\<noteq> 0\" by auto\n\t    moreover from A4 I have \n\t      \"N`(succ(k)) \\<in> FinPow(X)\" and \"N`(succ(k)) \\<noteq> 0\"\n\t      using apply_funtype by auto\n\t    moreover from \\<open>succ(k) \\<in> nat\\<close> A4 A5 have \"?A \\<inter> ?B = 0\"\n\t      by (rule list_partition)\n\t    moreover note A1\n\t    ultimately have \"\\<pr>(?A\\<union>?B,a) = (\\<pr>(?A,a))\\<cdot>(\\<pr>(?B,a))\"\n\t      using prod_disjoint by simp\n\t    moreover have \"?A \\<union> ?B = (\\<Union>i \\<in> succ(succ(k)). N`(i))\"\n\t      by auto\n\t    ultimately show ?thesis by simp\n\t  qed\n\t  finally have \"(\\<Prod> {\\<langle>i,\\<pr>(N`(i),a)\\<rangle>. i \\<in> succ(succ(k))}) = \n\t    (\\<pr>(\\<Union>i \\<in> succ(succ(k)). N`(i),a))\"\n\t    by simp\n\t  } thus ?thesis by auto\n\tqed\n\t} thus ?thesis by simp\n  qed\n  ultimately show ?thesis by (rule ind_on_nat)\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1905
    },
    "1716": {
        "type": "theorem",
        "text": "text\\<open>A more convenient reformulation of \\<open>prod_list_of_lists\\<close>.\n\\<close>\n",
        "assumes": "assumes A1: \"f {is commutative on} G\"  and \n  A2: \"n \\<in> nat\"  \"n \\<noteq> 0\" and\n  A3: \"M : n \\<rightarrow> FinPow(X)\"   \"M {is partition}\"\n  ",
        "using": [
            "Nat_ZF_1_L3",
            "prod_list_of_lists"
        ],
        "statement": "theorem (in semigr1) prod_list_of_sets: \n  assumes A1: \"f {is commutative on} G\"  and \n  A2: \"n \\<in> nat\"  \"n \\<noteq> 0\" and\n  A3: \"M : n \\<rightarrow> FinPow(X)\"   \"M {is partition}\"\n  shows\n  \"(\\<Prod> {\\<langle>i,\\<pr>(M`(i),a)\\<rangle>. i \\<in> n}) = (\\<pr>(\\<Union>i \\<in> n. M`(i),a))\"\n",
        "proof": "proof -\n  from A2 obtain k where \"k \\<in> nat\" and \"n = succ(k)\"\n    using Nat_ZF_1_L3 by auto\n  with A1 A3 show ?thesis using prod_list_of_lists\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1906
    },
    "1717": {
        "type": "theorem",
        "text": "text\\<open>The definition of the product \n  \\<open>\\<pr>(A,a) \\<equiv> SetFold(f,a,A,r)\\<close> of a some (finite) set of \n  semigroup elements requires that $r$ is a linear order on the set \n  of indices $A$. This is necessary so that we know in which order\n  we are multiplying the elements. The product over $A$ is defined \n  so that we have $\\prod_A a = \\prod a \\circ \\sigma(A)$ where\n  $\\sigma : |A| \\rightarrow A$ is the enumeration of $A$ (the only\n  order isomorphism between the number of elements in $A$ and $A$), see\n  lemma \\<open>setproddef\\<close>.\n  However, if the operation is commutative, the order is irrelevant. \n  The next theorem formalizes that fact stating that we can replace\n  the enumeration $\\sigma (A)$ by any bijection between $|A|$ and $A$.\n  In a way this is a generalization of \\<open>setproddef\\<close>. \n  The proof is based on application of \\<open>prod_list_of_sets\\<close>\n  to the finite collection of singletons that comprise $A$.\\<close>\n",
        "assumes": "assumes A1: \"f {is commutative on} G\" and\n  A2: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and\n  A3: \"b \\<in> bij(|A|,A)\"\n  ",
        "using": [
            "bij_def",
            "inj_def",
            "apply_funtype",
            "FinPow_def",
            "gen_prod_singleton",
            "comp_fun_apply",
            "inj_partition",
            "a_is_fun",
            "comp_fun",
            "fun_is_set_of_pairs",
            "card_fin_is_nat",
            "card_non_empty_non_zero",
            "singleton_in_finpow",
            "ZF_fun_from_total",
            "surj_singleton_image"
        ],
        "statement": "theorem (in semigr1) prod_order_irr: \n  assumes A1: \"f {is commutative on} G\" and\n  A2: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and\n  A3: \"b \\<in> bij(|A|,A)\"\n  shows \"(\\<Prod> (a O b)) = \\<pr>(A,a)\"\n",
        "proof": "proof -\n  let ?n = \"|A|\"\n  let ?M = \"{\\<langle>k, {b`(k)}\\<rangle>. k \\<in> ?n}\"\n  have \"(\\<Prod> (a O b)) = (\\<Prod> {\\<langle>i,\\<pr>(?M`(i),a)\\<rangle>. i \\<in> ?n})\"\n  proof -\n    have \"\\<forall>i \\<in> ?n. \\<pr>(?M`(i),a) = (a O b)`(i)\"\n    proof\n      fix i assume \"i \\<in> ?n\"\n      with A2 A3 \\<open>i \\<in> ?n\\<close> have \"b`(i) \\<in> X\" \n\tusing bij_def inj_def apply_funtype FinPow_def\n\tby auto\n      then have \"\\<pr>({b`(i)},a) = a`(b`(i))\" \n\tusing gen_prod_singleton by simp\n      with A3 \\<open>i \\<in> ?n\\<close> have \"\\<pr>({b`(i)},a) = (a O b)`(i)\"\n\tusing bij_def inj_def comp_fun_apply by auto\n      with \\<open>i \\<in> ?n\\<close> A3 show \"\\<pr>(?M`(i),a) = (a O b)`(i)\"\n\tusing bij_def inj_partition by auto\n    qed\n    hence \"{\\<langle>i,\\<pr>(?M`(i),a)\\<rangle>. i \\<in> ?n} = {\\<langle>i,(a O b)`(i)\\<rangle>. i \\<in> ?n}\"\n      by simp\n    moreover have \"{\\<langle>i,(a O b)`(i)\\<rangle>. i \\<in> ?n} = a O b\"\n    proof -\n      from A3 have \"b : ?n \\<rightarrow> A\" using bij_def inj_def by simp\n      moreover from A2 have \"A \\<subseteq> X\" using FinPow_def by simp\n      ultimately have \"b : ?n \\<rightarrow> X\" by (rule func1_1_L1B)\n      then have \"a O b: ?n \\<rightarrow> G\" using a_is_fun comp_fun\n\tby simp\n      then show \"{\\<langle>i,(a O b)`(i)\\<rangle>. i \\<in> ?n} = a O b\"\n\tusing fun_is_set_of_pairs by simp\n    qed\n    ultimately show ?thesis by simp\n  qed\n  also have \"\\<dots> = (\\<pr>(\\<Union>i \\<in> ?n. ?M`(i),a))\"\n  proof -\n    note A1\n    moreover from A2 have \"?n \\<in> nat\" and \"?n \\<noteq> 0\"\n      using card_fin_is_nat card_non_empty_non_zero by auto\n    moreover have \"?M : ?n \\<rightarrow> FinPow(X)\" and \"?M {is partition}\"\n    proof -\n      from A2 A3 have \"\\<forall>k \\<in> ?n. {b`(k)} \\<in>  FinPow(X)\"\n\tusing bij_def inj_def apply_funtype FinPow_def\n\t  singleton_in_finpow by auto\n      then show \"?M : ?n \\<rightarrow> FinPow(X)\" using ZF_fun_from_total\n\tby simp\n      from A3 show \"?M {is partition}\" using bij_def inj_partition\n\tby auto\n    qed\n    ultimately show\n      \"(\\<Prod> {\\<langle>i,\\<pr>(?M`(i),a)\\<rangle>. i \\<in> ?n}) = (\\<pr>(\\<Union>i \\<in> ?n. ?M`(i),a))\"\n      by (rule prod_list_of_sets)\n  qed\n  also from A3 have \"(\\<pr>(\\<Union>i \\<in> ?n. ?M`(i),a)) = \\<pr>(A,a)\"\n    using bij_def inj_partition surj_singleton_image\n    by auto\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1907
    },
    "1718": {
        "type": "definition",
        "text": "text\\<open>Definition of right uniformity\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in topgroup) rightUniformity\n where \"rightUniformity \\<equiv> {V\\<in>Pow(G\\<times>G).\\<exists>U\\<in> \\<N>\\<^sub>0. {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>U}\\<subseteq> V}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1910
    },
    "1719": {
        "type": "lemma",
        "text": "text\\<open>Right and left uniformities are indeed uniformities. \\<close>\n",
        "assumes": "",
        "using": [
            "zero_in_tgroup",
            "group0_valid_in_tgroup",
            "group0.group_inv_of_one",
            "group0.group0_2_L2",
            "U(1)",
            "Top_2_L1",
            "Top_2_L2",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L5",
            "AU(3)",
            "BU(3)",
            "as(2)",
            "BU(1)",
            "rightUniformity_def",
            "group0.group0_2_L6",
            "ginv_image_add",
            "simple_equation1_add",
            "V(2)",
            "neg_neigh_neigh",
            "V(1)",
            "exists_procls_zerohood",
            "interval_add(2)",
            "func_imagedef",
            "topgroup_f_binop",
            "cancel_middle_add(2)",
            "W(1)",
            "simple_equation0_add",
            "as",
            "cancel_middle_add(1)",
            "x(1,3,6)"
        ],
        "statement": "lemma (in topgroup) side_uniformities:\n    shows \"leftUniformity {is a uniformity on} G\" and \"rightUniformity {is a uniformity on} G\"\n",
        "proof": "proof-\n  {\n    assume \"0 \\<in> leftUniformity\"\n    then obtain U where U:\"U\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>U}\\<subseteq>0\" unfolding leftUniformity_def \n      by auto\n    have \"\\<langle>\\<zero>,\\<zero>\\<rangle>:G\\<times>G\" using zero_in_tgroup by auto\n    moreover have \"(\\<rm>\\<zero>)\\<ra>\\<zero> = \\<zero>\" \n      using group0_valid_in_tgroup group0.group_inv_of_one group0.group0_2_L2 zero_in_tgroup \n      by auto\n    moreover have \"\\<zero>\\<in>int(U)\" using U(1) by auto\n    then have \"\\<zero>\\<in>U\" using Top_2_L1 by auto\n    ultimately have \"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>U}\" by auto\n    with U(2) have \"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>0\" by blast\n    hence False by auto\n  }\n  hence \"0\\<notin>leftUniformity\" by auto \n  moreover  have \"leftUniformity \\<subseteq> Pow(G\\<times>G)\" unfolding leftUniformity_def by auto \n  moreover\n  {\n    have \"G\\<times>G\\<in>Pow(G\\<times>G)\" by auto moreover\n    have \"{\\<langle>s,t\\<rangle>:G\\<times>G. (\\<rm>s)\\<ra>t:G} \\<subseteq> G\\<times>G\" by auto moreover\n    note zneigh_not_empty\n    ultimately have \"G\\<times>G\\<in>leftUniformity\" unfolding leftUniformity_def by auto\n  } \n  moreover\n  {\n    fix A B assume as:\"A\\<in>leftUniformity\" \"B\\<in>leftUniformity\"\n    from as(1) obtain AU where AU:\"AU\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>AU}\\<subseteq> A\" \"A\\<in>Pow(G\\<times>G)\" \n      unfolding leftUniformity_def by auto\n    from as(2) obtain BU where BU:\"BU\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>BU}\\<subseteq> B\" \"B\\<in>Pow(G\\<times>G)\" \n      unfolding leftUniformity_def by auto\n    from AU(1) BU(1) have \"\\<zero>\\<in>int(AU)\\<inter>int(BU)\" by auto\n    moreover from AU BU have op:\"int(AU)\\<inter>int(BU)\\<in>T\" using Top_2_L2 topSpaceAssum IsATopology_def \n      by auto  \n    moreover \n    have \"int(AU)\\<inter>int(BU) \\<subseteq> AU\\<inter>BU\" using Top_2_L1 by auto\n    with op have \"int(AU)\\<inter>int(BU)\\<subseteq>int(AU\\<inter>BU)\" using Top_2_L5 by auto \n    moreover note AU(1) BU(1)\n    ultimately have \"AU\\<inter>BU: \\<N>\\<^sub>0\" unfolding zerohoods_def by auto\n    moreover have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>AU\\<inter>BU}\\<subseteq>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>AU}\" by auto\n    with AU(2) BU(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>AU\\<inter>BU}\\<subseteq>A\\<inter>B\" by auto\n    ultimately have \"A\\<inter>B \\<in> {V\\<in>Pow(G\\<times>G).\\<exists>U\\<in> \\<N>\\<^sub>0. {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>U} \\<subseteq> V}\"\n      using AU(3) BU(3) by blast\n    then have \"A\\<inter>B\\<in>leftUniformity\" unfolding leftUniformity_def by simp \n  }\n  hence \"\\<forall>A\\<in>leftUniformity. \\<forall>B\\<in>leftUniformity. A \\<inter> B \\<in> leftUniformity\" by auto\n  moreover\n  {\n    fix B C assume as:\"B\\<in>leftUniformity\" \"C\\<in>Pow(G \\<times> G)\" \"B \\<subseteq> C\"\n    from as(1) obtain BU where BU:\"BU\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> BU}\\<subseteq>B\" \n      unfolding leftUniformity_def by blast\n    from as(3) BU(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> BU}\\<subseteq>C\" by auto\n    with as(2) BU(1) have \"C \\<in> {V\\<in>Pow(G\\<times>G).\\<exists>U\\<in> \\<N>\\<^sub>0. {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>U} \\<subseteq> V}\"\n      by auto \n    then have \"C \\<in> leftUniformity\"  unfolding leftUniformity_def by auto\n  }\n  then have \"\\<forall>B\\<in>leftUniformity. \\<forall>C\\<in>Pow(G\\<times>G). B\\<subseteq>C \\<longrightarrow> C\\<in>leftUniformity\" by auto\n  ultimately have leftFilter:\"leftUniformity {is a filter on} (G\\<times>G)\" unfolding IsFilter_def \n    by auto\n  {\n    assume \"0\\<in>rightUniformity\"\n    then obtain U where U:\"U\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>U}\\<subseteq>0\" unfolding rightUniformity_def \n      by auto\n    have \"\\<langle>\\<zero>,\\<zero>\\<rangle>:G\\<times>G\" using zero_in_tgroup by auto\n    moreover have \"\\<zero>\\<ra>(\\<rm>\\<zero>) = \\<zero>\" \n      using group0_valid_in_tgroup group0.group_inv_of_one group0.group0_2_L2 zero_in_tgroup \n      by auto\n    moreover \n    have \"\\<zero>\\<in>int(U)\" using U(1) by auto\n    then have \"\\<zero>\\<in>U\" using Top_2_L1 by auto\n    ultimately have \"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>U}\" by auto\n    with U(2) have \"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>0\" by blast\n    hence False by auto\n  }\n  then have \"0\\<notin>rightUniformity\" by auto \n  moreover  have \"rightUniformity \\<subseteq> Pow(G\\<times>G)\" unfolding rightUniformity_def by auto \n  moreover\n  {\n    have \"G\\<times>G\\<in>Pow(G\\<times>G)\" by auto \n    moreover have \"{\\<langle>s,t\\<rangle>:G\\<times>G. (\\<rm>s)\\<ra>t:G} \\<subseteq> G\\<times>G\" by auto \n    moreover note zneigh_not_empty\n    ultimately have \"G\\<times>G \\<in> rightUniformity\" unfolding rightUniformity_def by auto\n  } \n  moreover\n  {\n    fix A B assume as:\"A\\<in>rightUniformity\" \"B\\<in>rightUniformity\"\n    from as(1) obtain AU where AU:\"AU\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>AU}\\<subseteq> A\" \"A\\<in>Pow(G\\<times>G)\" \n      unfolding rightUniformity_def by auto\n    from as(2) obtain BU where BU:\"BU\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>BU}\\<subseteq> B\" \"B\\<in>Pow(G\\<times>G)\" \n      unfolding rightUniformity_def by auto\n    from AU(1) BU(1) have \"\\<zero>\\<in>int(AU)\\<inter>int(BU)\" by auto\n    moreover from AU BU have op:\"int(AU)\\<inter>int(BU)\\<in>T\" \n      using Top_2_L2 topSpaceAssum IsATopology_def by auto \n    moreover \n    have \"int(AU)\\<inter>int(BU) \\<subseteq> AU\\<inter>BU\" using Top_2_L1 by auto\n    with op have \"int(AU)\\<inter>int(BU)\\<subseteq>int(AU\\<inter>BU)\" using Top_2_L5 by auto \n    moreover note AU(1) BU(1)\n    ultimately have \"AU\\<inter>BU: \\<N>\\<^sub>0\" unfolding zerohoods_def by auto\n    moreover have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>AU\\<inter>BU}\\<subseteq>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>AU}\" by auto\n    with AU(2) BU(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>AU\\<inter>BU}\\<subseteq>A\\<inter>B\" by auto\n    ultimately have \"A\\<inter>B \\<in> {V\\<in>Pow(G\\<times>G).\\<exists>U\\<in> \\<N>\\<^sub>0. {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in>U}\\<subseteq> V}\"\n      using AU(3) BU(3) by blast \n    then have \"A\\<inter>B \\<in> rightUniformity\" unfolding rightUniformity_def by simp\n  }\n  hence \"\\<forall>A\\<in>rightUniformity. \\<forall>B\\<in>rightUniformity. A\\<inter>B \\<in> rightUniformity\" by auto\n  moreover\n  {\n    fix B C assume as:\"B\\<in>rightUniformity\" \"C\\<in>Pow(G \\<times> G)\" \"B \\<subseteq> C\"\n    from as(1) obtain BU where BU:\"BU\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> BU}\\<subseteq>B\" \n      unfolding rightUniformity_def by blast\n    from as(3) BU(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> BU}\\<subseteq>C\" by auto\n    then have \"C \\<in> rightUniformity\" using as(2) BU(1) unfolding rightUniformity_def by auto\n  }\n  then have \"\\<forall>B\\<in>rightUniformity. \\<forall>C\\<in>Pow(G\\<times>G). B\\<subseteq>C \\<longrightarrow> C\\<in>rightUniformity\" by auto\n  ultimately have rightFilter:\"rightUniformity {is a filter on} (G\\<times>G)\" unfolding IsFilter_def \n    by auto\n  {\n    fix U assume as:\"U\\<in>leftUniformity\"\n    from as obtain V where V:\"V\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> V} \\<subseteq> U\" \n      unfolding leftUniformity_def by auto\n    then have \"V\\<subseteq>G\" by auto\n    {\n      fix x assume as2:\"x\\<in>id(G)\"\n      from as obtain V where V:\"V\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> V} \\<subseteq> U\" \n        unfolding leftUniformity_def by auto\n      from V(1) have \"\\<zero>\\<in>int(V)\" by auto\n      then have V0:\"\\<zero>\\<in>V\" using Top_2_L1 by auto\n      from as2 obtain t where t:\"x=\\<langle>t,t\\<rangle>\" \"t:G\" by auto\n      from t(2) have \"(\\<rm>t)\\<ra>t =\\<zero>\" using group0_valid_in_tgroup group0.group0_2_L6\n        by auto\n      with V0 t V(2) have \"x\\<in>U\" by auto\n    }\n    then have \"id(G)\\<subseteq>U\" by auto \n    moreover\n    {\n      {\n        fix x assume ass:\"x\\<in>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> \\<sm>V}\"\n        then obtain s t where as:\"s\\<in>G\" \"t\\<in>G\" \"(\\<rm>s)\\<ra>t \\<in> \\<sm>V\" \"x=\\<langle>s,t\\<rangle>\" by force\n        from as(3) \\<open>V\\<subseteq>G\\<close> have \"(\\<rm>s)\\<ra>t\\<in>{\\<rm>q. q\\<in>V}\" using ginv_image_add by simp \n        then obtain q where q: \"q\\<in>V\" \"(\\<rm>s)\\<ra>t = \\<rm>q\" by auto\n        with \\<open>V\\<subseteq>G\\<close> have \"q\\<in>G\" by auto\n        with \\<open>s\\<in>G\\<close> \\<open>t\\<in>G\\<close> \\<open>(\\<rm>s)\\<ra>t = \\<rm>q\\<close> have \"q=(\\<rm>t)\\<ra>s\" \n          using simple_equation1_add by blast  \n        with q(1) have \"(\\<rm>t)\\<ra>s \\<in> V\" by auto\n        with as(1,2) have \"\\<langle>t,s\\<rangle> \\<in> U\" using V(2) by auto\n        then have \"\\<langle>s,t\\<rangle> \\<in> converse(U)\" by auto\n        with as(4) have \"x \\<in> converse(U)\" by auto\n      }\n      then have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> \\<sm>V} \\<subseteq> converse(U)\" by auto\n      moreover have \"(\\<sm>V):\\<N>\\<^sub>0\" using neg_neigh_neigh V(1) by auto\n      moreover note as \n      ultimately have \"converse(U) \\<in> leftUniformity\" unfolding leftUniformity_def by auto\n    }\n    moreover\n    {\n      from V(1) obtain W where W:\"W:\\<N>\\<^sub>0\" \"W \\<sad> W \\<subseteq>V\" using exists_procls_zerohood by blast\n      {\n        fix x assume as:\"x \\<in> {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> W} O {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> W}\"\n        then obtain x\\<^sub>1 x\\<^sub>2 x\\<^sub>3 where \n          x:\"x\\<^sub>1\\<in>G\" \"x\\<^sub>2\\<in>G\" \"x\\<^sub>3\\<in>G\" \"(\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2 \\<in> W\" \"(\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3 \\<in> W\" \"x=\\<langle>x\\<^sub>1,x\\<^sub>3\\<rangle>\"\n          unfolding comp_def by auto\n        from W(1) have \"W\\<sad>W = f``(W\\<times>W)\" using interval_add(2) by auto \n        moreover from W(1) have WW:\"W\\<times>W\\<subseteq>G\\<times>G\" by auto\n        moreover \n        from x(4,5) have \"\\<langle>(\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2,(\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3\\<rangle>:W\\<times>W\" by auto\n        with WW have \"f`(\\<langle>(\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2,(\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3\\<rangle>):f``(W\\<times>W)\"\n          using func_imagedef topgroup_f_binop by auto\n        ultimately have \"((\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2)\\<ra>((\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3) :W\\<sad>W\" by auto\n        moreover from x(1,2,3) have \"((\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2)\\<ra>((\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3) = (\\<rm>x\\<^sub>1)\\<ra> x\\<^sub>3\"\n          using cancel_middle_add(2) by simp     \n        ultimately have \"(\\<rm>x\\<^sub>1)\\<ra> x\\<^sub>3\\<in>W\\<sad>W\" by auto\n        with W(2) have \"(\\<rm>x\\<^sub>1)\\<ra> x\\<^sub>3\\<in>V\" by auto\n        with x(1,3,6) have \"x:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> V}\" by auto\n      }\n      then have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> W} O {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> W} \\<subseteq> U\"\n        using V(2) by auto moreover\n      have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> W}\\<in>leftUniformity\" \n        unfolding leftUniformity_def using W(1) by auto\n      ultimately have \"\\<exists>Z\\<in>leftUniformity. Z O Z\\<subseteq>U\" by auto\n    }\n    ultimately have \"id(G)\\<subseteq>U \\<and> (\\<exists>Z\\<in>leftUniformity. Z O Z\\<subseteq>U) \\<and> converse(U)\\<in>leftUniformity\" \n      by blast\n  }\n  then have \n    \"\\<forall>U\\<in>leftUniformity. id(G)\\<subseteq>U \\<and> (\\<exists>Z\\<in>leftUniformity. Z O Z\\<subseteq>U) \\<and> converse(U)\\<in>leftUniformity\" \n    by auto\n  with leftFilter show \"leftUniformity {is a uniformity on} G\" unfolding IsUniformity_def by auto\n  {\n    fix U assume as:\"U\\<in>rightUniformity\"\n    from as obtain V where V:\"V\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> V} \\<subseteq> U\" \n      unfolding rightUniformity_def by auto\n    {\n      fix x assume as2:\"x\\<in>id(G)\"\n      from as obtain V where V:\"V\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> V} \\<subseteq> U\" \n        unfolding rightUniformity_def by auto\n      from V(1) have \"\\<zero>\\<in>int(V)\" by auto\n      then have V0:\"\\<zero>\\<in>V\" using Top_2_L1 by auto\n      from as2 obtain t where t:\"x=\\<langle>t,t\\<rangle>\" \"t:G\" by auto\n      from t(2) have \"t\\<ra>(\\<rm>t) =\\<zero>\" using group0_valid_in_tgroup group0.group0_2_L6 \n        by auto \n      with V0 t V(2) have \"x\\<in>U\" by auto\n    }\n    then have \"id(G)\\<subseteq>U\" by auto \n    moreover\n    {\n      {\n        fix x assume ass:\"x\\<in>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> \\<sm>V}\"\n        then obtain s t where as:\"s\\<in>G\" \"t\\<in>G\" \"s\\<ra>(\\<rm>t) \\<in> \\<sm>V\" \"x=\\<langle>s,t\\<rangle>\" \n          by force\n        from as(3) V(1) have \"s\\<ra>(\\<rm>t) \\<in> {\\<rm>q. q\\<in>V}\"\n          using ginv_image_add by simp \n        then obtain q where q:\"q\\<in>V\" \"s\\<ra>(\\<rm>t) = \\<rm>q\" by auto \n        with \\<open>V\\<in>\\<N>\\<^sub>0\\<close> have \"q\\<in>G\" by auto  \n        with as(1,2) q(1,2) have \"t\\<ra>(\\<rm>s) \\<in> V\" using simple_equation0_add \n          by blast \n        with as(1,2,4) V(2) have \"x \\<in> converse(U)\" by auto \n      }\n      then have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G.  s\\<ra>(\\<rm>t) \\<in> \\<sm>V} \\<subseteq> converse(U)\" by auto\n      moreover from V(1) have \"(\\<sm>V) \\<in> \\<N>\\<^sub>0\" using neg_neigh_neigh by auto\n      ultimately have \"converse(U) \\<in> rightUniformity\" using as rightUniformity_def \n        by auto\n    }\n    moreover\n    {\n      from V(1) obtain W where W:\"W:\\<N>\\<^sub>0\" \"W \\<sad> W \\<subseteq>V\" using exists_procls_zerohood by blast\n      {\n        fix x assume as:\"x:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G.  s\\<ra>(\\<rm>t) \\<in> W} O {\\<langle>s,t\\<rangle>\\<in>G\\<times>G.  s\\<ra>(\\<rm>t) \\<in> W}\"\n        then obtain x\\<^sub>1 x\\<^sub>2 x\\<^sub>3 where \n          x:\"x\\<^sub>1:G\" \"x\\<^sub>2\\<in>G\" \"x\\<^sub>3\\<in>G\" \"x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2) \\<in> W\" \"x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3) \\<in> W\" \"x=\\<langle>x\\<^sub>1,x\\<^sub>3\\<rangle>\"\n          unfolding comp_def by auto\n        from W(1) have \"W\\<sad>W = f``(W\\<times>W)\" using interval_add(2) by auto\n        moreover from W(1) have WW:\"W\\<times>W\\<subseteq>G\\<times>G\" by auto\n        moreover \n        from x(4,5) have \"\\<langle>x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2),x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3)\\<rangle> \\<in> W\\<times>W\" by auto\n        with WW have \"f`(\\<langle>x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2),x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3)\\<rangle>) \\<in> f``(W\\<times>W)\"\n          using func_imagedef topgroup_f_binop  by auto\n        ultimately have \"(x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2))\\<ra>(x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3)) \\<in> W\\<sad>W\" by auto\n        moreover from x(1,2,3) have \"(x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2))\\<ra>(x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3)) = x\\<^sub>1\\<ra> (\\<rm>x\\<^sub>3)\"\n          using cancel_middle_add(1) by simp \n        ultimately have \"x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>3) \\<in> W\\<sad>W\" by auto\n        with W(2) have \"x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>3) \\<in> V\" by auto\n        then have \"x \\<in> {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> V}\" using x(1,3,6) by auto\n      }\n      with V(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> W} O {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> W} \\<subseteq> U\"\n        by auto \n      moreover from W(1) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t) \\<in> W} \\<in> rightUniformity\" \n        unfolding rightUniformity_def  by auto\n      ultimately have \"\\<exists>Z\\<in>rightUniformity. Z O Z\\<subseteq>U\" by auto\n    }\n    ultimately have \"id(G)\\<subseteq>U \\<and> (\\<exists>Z\\<in>rightUniformity. Z O Z\\<subseteq>U) \\<and> converse(U)\\<in>rightUniformity\" \n      by blast\n  }\n  then have \n    \"\\<forall>U\\<in>rightUniformity. id(G)\\<subseteq>U \\<and> (\\<exists>Z\\<in>rightUniformity. Z O Z\\<subseteq>U) \\<and> converse(U)\\<in>rightUniformity\" \n    by auto\n  with rightFilter show \"rightUniformity {is a uniformity on} G\" unfolding IsUniformity_def \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1911
    },
    "1720": {
        "type": "lemma",
        "text": "text\\<open> The topologies generated by the right and left uniformities are the original group topology. \\<close>\n",
        "assumes": "",
        "using": [
            "neigh_from_uniformity",
            "side_uniformities(1)",
            "IsNeighSystem_def",
            "side_uniformities(2)",
            "neg_in_tgroup",
            "ZF_fun_from_tot_val",
            "open_trans_neigh",
            "op",
            "x",
            "image_iff",
            "cancel_left_add",
            "lrtrans_image(1)",
            "open_trans_neigh_2",
            "vimage_iff",
            "cancel_right_add",
            "lrtrans_image(2)",
            "IsUniformity_def",
            "apply_equality",
            "put_on_the_other_side(2)",
            "Top_2_L1",
            "elem_in_int_ltrans(1)",
            "Top_2_L2",
            "open_neigh_open",
            "group_op_closed_add",
            "put_on_the_other_side",
            "elem_in_int_rtrans(1)",
            "uniftop_def_alt"
        ],
        "statement": "lemma (in topgroup) top_generated_side_uniformities:\n  shows \"UniformTopology(leftUniformity,G) = T\" and \"UniformTopology(rightUniformity,G) = T\"\n",
        "proof": "proof-\n  let ?M = \"{\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle>. t\\<in>G}\"\n  have fun:\"?M:G\\<rightarrow>Pow(Pow(G))\" using neigh_from_uniformity side_uniformities(1) IsNeighSystem_def\n    by auto \n  let ?N = \"{\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle>. t\\<in>G}\"\n  have funN:\"?N:G\\<rightarrow>Pow(Pow(G))\" using neigh_from_uniformity side_uniformities(2) IsNeighSystem_def\n    by auto \n  {\n    fix U assume op:\"U\\<in>T\"\n    hence \"U\\<subseteq>G\" by auto \n    {\n      fix x assume x:\"x\\<in>U\"\n      with op have xg:\"x\\<in>G\" and \"(\\<rm>x) \\<in> G\" using neg_in_tgroup by auto\n      then have \"\\<langle>x, {V``{x}. V \\<in> leftUniformity}\\<rangle> \\<in> {\\<langle>t, {V``{t}. V \\<in> leftUniformity}\\<rangle>. t\\<in>G}\" \n        by auto\n      with fun have app:\"?M`(x) = {V``{x}. V \\<in> leftUniformity}\" using ZF_fun_from_tot_val \n        by auto \n      have \"(\\<rm>x)\\<ltr>U : \\<N>\\<^sub>0\" using open_trans_neigh op x by auto\n      then have V:\"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U)} \\<in> leftUniformity\"\n        unfolding leftUniformity_def by auto\n      with xg have \n        N:\"\\<forall>t\\<in>G. t:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U)}``{x} \\<longleftrightarrow> (\\<rm>x)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U)\"\n        using image_iff by auto \n      {\n        fix t assume t:\"t\\<in>G\" \n        {\n          assume as:\"(\\<rm>x)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U)\"\n          then have \"(\\<rm>x)\\<ra>t\\<in>LeftTranslation(G,f,\\<rm>x)``U\" by auto\n          then obtain q where q:\"q\\<in>U\" \"\\<langle>q,(\\<rm>x)\\<ra>t\\<rangle>\\<in>LeftTranslation(G,f,\\<rm>x)\"\n            using image_iff by auto \n          with op have \"q\\<in>G\" by auto\n          from q(2) have \"(\\<rm>x)\\<ra>q = (\\<rm>x)\\<ra>t\" unfolding LeftTranslation_def \n            by auto\n          with \\<open>(\\<rm>x) \\<in> G\\<close> \\<open>q\\<in>G\\<close> \\<open>t\\<in>G\\<close> have \"q = t\" using neg_in_tgroup cancel_left_add \n            by blast \n          with q(1) have \"t\\<in>U\" by auto\n        } \n        moreover\n        {\n          assume t:\"t\\<in>U\"\n          with \\<open>U\\<subseteq>G\\<close> \\<open>(\\<rm>x)\\<in>G\\<close> have \"(\\<rm>x)\\<ra>t \\<in> ((\\<rm>x)\\<ltr>U)\"\n            using lrtrans_image(1) by auto \n        } \n        ultimately have \"(\\<rm>x)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U) \\<longleftrightarrow> t:U\" by blast\n      } \n      with N have \"\\<forall>t\\<in>G. t:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in> ((\\<rm>x)\\<ltr>U)}``{x} \\<longleftrightarrow> t\\<in>U\" \n        by blast\n      with op have \"\\<forall>t. t:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U)}``{x} \\<longleftrightarrow> t:U\" \n        by auto\n      hence \"U = {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t\\<in>((\\<rm>x)\\<ltr>U)}``{x}\" by auto\n      with V have \"\\<exists>V\\<in>leftUniformity. U=V``{x}\" by blast \n      with app have \"U \\<in> {\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G}`(x)\" by auto\n      moreover from \\<open>x\\<in>G\\<close> funN have app:\"?N`(x) = {V``{x}. V \\<in> rightUniformity}\" \n        using ZF_fun_from_tot_val by simp \n      moreover \n      from x op have openTrans:\"U\\<rtr>(\\<rm>x): \\<N>\\<^sub>0\" using open_trans_neigh_2 by auto\n      then have V:\"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t)\\<in>(U\\<rtr>(\\<rm>x))} \\<in> rightUniformity\"\n        unfolding rightUniformity_def by auto\n      with xg have \n        N:\"\\<forall>t\\<in>G. t:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t)\\<in>(U\\<rtr>(\\<rm>x))}-``{x} \\<longleftrightarrow> t\\<ra>(\\<rm>x)\\<in>(U\\<rtr>(\\<rm>x))\"\n        using vimage_iff by auto\n      moreover \n      {\n        fix t assume t:\"t\\<in>G\" \n        {\n          assume as:\"t\\<ra>(\\<rm>x)\\<in>(U\\<rtr>(\\<rm>x))\"\n          hence \"t\\<ra>(\\<rm>x)\\<in>RightTranslation(G,f,\\<rm>x)``U\" by auto\n          then obtain q where q:\"q\\<in>U\" \"\\<langle>q,t\\<ra>(\\<rm>x)\\<rangle>\\<in>RightTranslation(G,f,\\<rm>x)\"\n            using image_iff by auto\n          with op have \"q\\<in>G\" by auto\n          from q(2) have \"q\\<ra>(\\<rm>x) = t\\<ra>(\\<rm>x)\" unfolding RightTranslation_def by auto\n          with \\<open>q\\<in>G\\<close> \\<open>(\\<rm>x) \\<in> G\\<close> \\<open>t\\<in>G\\<close> have \"q = t\" using cancel_right_add by simp \n          with q(1) have \"t\\<in>U\" by auto\n        } \n        moreover\n        {\n          assume \"t\\<in>U\"\n          with \\<open>(\\<rm>x)\\<in>G\\<close> \\<open>U\\<subseteq>G\\<close> have \"t\\<ra>(\\<rm>x)\\<in>(U\\<rtr>(\\<rm>x))\" using lrtrans_image(2)\n            by auto \n        } ultimately have \"t\\<ra>(\\<rm>x)\\<in>(U\\<rtr>(\\<rm>x)) \\<longleftrightarrow> t:U\" by blast\n      } with N have \"\\<forall>t\\<in>G. t:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t)\\<in>(U\\<rtr>(\\<rm>x))}-``{x} \\<longleftrightarrow> t:U\" \n        by blast\n      with op have \"\\<forall>t. t:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t)\\<in>(U\\<rtr>(\\<rm>x))}-``{x} \\<longleftrightarrow> t:U\" \n        by auto\n      hence \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t)\\<in>(U\\<rtr>(\\<rm>x))}-``{x} = U\" by auto\n      then have \"U = converse({\\<langle>s,t\\<rangle>\\<in>G\\<times>G. s\\<ra>(\\<rm>t)\\<in>(U\\<rtr>(\\<rm>x))})``{x}\" \n        unfolding vimage_def by simp\n      with V app have \"U \\<in> {\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle> . t \\<in> G}`(x)\"\n        using side_uniformities(2) IsUniformity_def by auto \n      ultimately have \n        \"U \\<in> {\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G}`(x)\" and \n        \"U \\<in> {\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle> . t \\<in> G}`(x)\" \n        by auto\n    }\n    hence \n      \"\\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G} ` x\" and \n      \"\\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle> . t \\<in> G} ` x\"\n      by auto\n  }\n  hence \n    \"T\\<subseteq>{U \\<in> Pow(G) . \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G} ` x}\" and \n    \"T\\<subseteq>{U \\<in> Pow(G) . \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle> . t \\<in> G} ` x}\" \n    by auto\n  moreover\n  {\n    fix U assume as:\"U \\<in> Pow(G)\" \"\\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G}`(x)\"\n    {\n      fix x assume x:\"x\\<in>U\"\n      with as(1) have xg:\"x\\<in>G\" by auto\n      from x as(2) have \"U\\<in>{\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G}`(x)\" by auto\n      with xg fun have \"U\\<in>{V `` {x} . V \\<in> leftUniformity}\" using apply_equality by auto \n      then obtain V where V:\"U=V``{x}\" \"V\\<in>leftUniformity\" by auto\n      from V(2) obtain W where W:\"W\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>:G\\<times>G. (\\<rm>s)\\<ra>t:W}\\<subseteq>V\" \n        unfolding leftUniformity_def by auto\n      from W(2) have A:\"{\\<langle>s,t\\<rangle>:G\\<times>G. (\\<rm>s)\\<ra>t:W}``{x}\\<subseteq>V``{x}\" by auto\n      from xg have \"\\<forall>q\\<in>G. q\\<in>({\\<langle>s,t\\<rangle>:G\\<times>G. (\\<rm>s)\\<ra>t:W}``{x}) \\<longleftrightarrow> (\\<rm>x)\\<ra>q:W\"\n        using image_iff by auto \n      hence B:\"{\\<langle>s,t\\<rangle>:G\\<times>G. (\\<rm>s)\\<ra>t:W}``{x} = {t\\<in>G. (\\<rm>x)\\<ra>t:W}\" by auto\n      from W(1) have WG:\"W\\<subseteq>G\" by auto\n      {\n        fix t assume t:\"t \\<in> x\\<ltr>W\"\n        then have \"t \\<in> LeftTranslation(G,f,x)``W\" by auto\n        then obtain s where s:\"s\\<in>W\" \"\\<langle>s,t\\<rangle>\\<in>LeftTranslation(G,f,x)\" using image_iff by auto\n        with \\<open>W\\<subseteq>G\\<close> have \"s\\<in>G\" by auto \n        from s(2) have \"t=x\\<ra>s\" \"t\\<in>G\" unfolding LeftTranslation_def by auto\n        with \\<open>x\\<in>G\\<close> \\<open>s\\<in>G\\<close> have \"(\\<rm>x)\\<ra>t = s\" using put_on_the_other_side(2) by simp \n        with s(1) have \"(\\<rm>x)\\<ra>t\\<in>W\" by auto\n        with \\<open>t\\<in>G\\<close> have \"t \\<in> {s\\<in>G. (\\<rm>x)\\<ra>s:W}\" by auto\n      }\n      then have \"x\\<ltr>W \\<subseteq> {t\\<in>G. (\\<rm>x)\\<ra>t\\<in>W}\" by auto\n      with B have \"x \\<ltr> W \\<subseteq> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . (\\<rm> s) \\<ra> t \\<in> W} `` {x}\" by auto\n      with A have \"x \\<ltr> W \\<subseteq> V`` {x}\" by blast\n      with V(1) have \"x \\<ltr> W \\<subseteq> U\" by auto\n      then have \"int(x \\<ltr> W) \\<subseteq> U\" using Top_2_L1 by blast\n      moreover from xg W(1) have \"x\\<in>int(x \\<ltr> W)\" using elem_in_int_ltrans(1) by auto\n      moreover have \"int(x \\<ltr> W)\\<in>T\" using Top_2_L2 by auto\n      ultimately have \"\\<exists>Y\\<in>T. x\\<in>Y \\<and> Y\\<subseteq>U\" by auto\n    }\n    then have \"U\\<in>T\" using open_neigh_open by auto\n  } hence  \"{U \\<in> Pow(G) . \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> leftUniformity}\\<rangle> . t \\<in> G} ` x} \\<subseteq> T\" \n    by auto\n  moreover\n  {\n    fix U assume as:\"U \\<in> Pow(G)\" \"\\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle> . t \\<in> G} ` x\"\n    {\n      fix x assume x:\"x\\<in>U\"\n      with as(1) have xg:\"x\\<in>G\" by auto\n      from x as(2) have \"U\\<in>{\\<langle>t, {V `` {t} . V \\<in> rightUniformity}\\<rangle> . t \\<in> G} ` x\" by auto\n      with xg funN have \"U\\<in>{V `` {x} . V \\<in> rightUniformity}\" using apply_equality \n        by auto \n      then obtain V where V:\"U=V``{x}\" \"V \\<in> rightUniformity\" by auto\n      then have \"converse(V) \\<in> rightUniformity\" using side_uniformities(2) IsUniformity_def \n        by auto\n      then obtain W where W:\"W\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>:G\\<times>G. s\\<ra>(\\<rm>t):W}\\<subseteq>converse(V)\" \n        unfolding rightUniformity_def by auto\n      from W(2) have A:\"{\\<langle>s,t\\<rangle>:G\\<times>G. s\\<ra>(\\<rm>t):W}-``{x}\\<subseteq>V``{x}\" by auto\n      from xg have \"\\<forall>q\\<in>G. q\\<in>({\\<langle>s,t\\<rangle>:G\\<times>G. s\\<ra>(\\<rm>t):W}-``{x}) \\<longleftrightarrow> q\\<ra>(\\<rm>x):W\"\n        using image_iff by auto \n      hence B:\"{\\<langle>s,t\\<rangle>:G\\<times>G. s\\<ra>(\\<rm>t):W}-``{x} = {t\\<in>G. t\\<ra>(\\<rm>x):W}\" by auto\n      from W(1) have WG:\"W\\<subseteq>G\" by auto\n      {\n        fix t assume \"t \\<in> W\\<rtr>x\"\n        with \\<open>x\\<in>G\\<close> \\<open>W\\<subseteq>G\\<close> obtain s where \"s\\<in>W\" and \"t=s\\<ra>x\" using lrtrans_image(2) \n          by auto\n        with \\<open>W\\<subseteq>G\\<close> have \"s\\<in>G\" by auto \n        with \\<open>x\\<in>G\\<close> \\<open>t=s\\<ra>x\\<close> have \"t\\<in>G\" using group_op_closed_add by simp \n        from \\<open>x\\<in>G\\<close> \\<open>s\\<in>G\\<close> \\<open>t=s\\<ra>x\\<close> have \"t\\<ra>(\\<rm>x) = s\" using put_on_the_other_side \n          by simp\n        with \\<open>s\\<in>W\\<close> \\<open>t\\<in>G\\<close> have \"t \\<in> {s\\<in>G. s\\<ra>(\\<rm>x) \\<in> W}\" by auto\n      }\n      then have \"W\\<rtr>x \\<subseteq> {t:G. t\\<ra>(\\<rm>x):W}\" by auto\n      with B have \"W \\<rtr> x \\<subseteq> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . s \\<ra> (\\<rm> t) \\<in> W}-``{x}\" by auto\n      with A have \"W \\<rtr> x \\<subseteq> V`` {x}\" by blast\n      with V(1) have \"W \\<rtr> x \\<subseteq> U\" by auto\n      then have \"int(W \\<rtr> x) \\<subseteq> U\" using Top_2_L1 by blast\n      moreover \n      from xg W(1) have \"x\\<in>int(W \\<rtr> x)\" using elem_in_int_rtrans(1) by auto\n      moreover have \"int(W \\<rtr> x)\\<in>T\" using Top_2_L2 by auto\n      ultimately have \"\\<exists>Y\\<in>T. x\\<in>Y \\<and> Y\\<subseteq>U\" by auto\n    }\n    then have \"U\\<in>T\" using open_neigh_open by auto\n  }\n  ultimately have \n  \"{U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V``{t} . V \\<in> leftUniformity}\\<rangle>. t \\<in> G}`(x)} = T\" \n  \"{U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V``{t} . V \\<in> rightUniformity}\\<rangle>. t \\<in> G}`(x)} = T\" \n    by auto\n  then show \"UniformTopology(leftUniformity,G) = T\" and \"UniformTopology(rightUniformity,G) = T\"\n    using uniftop_def_alt by auto \nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1912
    },
    "1721": {
        "type": "lemma",
        "text": "text\\<open> The side uniformities are called this way because of how they affect left and right translations.\n In the next lemma we show that left translations are uniformly continuous with respect to the left uniformity. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\"\n  ",
        "using": [
            "group0_5_L1",
            "side_uniformities(1)",
            "prodFunctionApp",
            "group0_5_L1(2)",
            "group0_5_L2(2)",
            "cancel_middle_add(3)",
            "assms",
            "st(2,3)",
            "group_op_closed",
            "prodFunction",
            "func1_1_L5A",
            "vimage_iff",
            "func1_1_L6A",
            "IsUniformlyCont_def"
        ],
        "statement": "lemma (in topgroup) left_mult_uniformity: assumes \"x\\<in>G\"\n  shows \n    \"LeftTranslation(G,f,x) {is uniformly continuous between} leftUniformity {and} leftUniformity\" \n",
        "proof": "proof -\n  let ?P = \"ProdFunction(LeftTranslation(G, f, x), LeftTranslation(G, f, x))\"\n  from assms have L: \"LeftTranslation(G,f,x):G\\<rightarrow>G\" and \"leftUniformity {is a uniformity on} G\" \n    using group0_5_L1 side_uniformities(1) by auto\n  moreover have \"\\<forall>V \\<in> leftUniformity. ?P-``(V) \\<in> leftUniformity\"\n  proof -\n    { fix V assume \"V \\<in> leftUniformity\"\n      then obtain U where \"U \\<in> \\<N>\\<^sub>0\" and \"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . (\\<rm> s) \\<ra> t \\<in> U} \\<subseteq> V\"\n        unfolding leftUniformity_def by auto\n      with \\<open>V \\<in> leftUniformity\\<close> have \n        as:\"V \\<subseteq> G \\<times> G\" \"U \\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . (\\<rm> s) \\<ra> t \\<in> U} \\<subseteq> V\"\n        unfolding leftUniformity_def by auto\n      { fix z assume z:\"z \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . (\\<rm> s) \\<ra> t \\<in> U}\"\n        then obtain s t where st:\"z=\\<langle>s,t\\<rangle>\" \"s\\<in>G\" \"t\\<in>G\" by auto\n        from st(1) z have st2: \"(\\<rm> s) \\<ra> t \\<in> U\" by auto\n        from assms st have \n          \"?P`(z) = \\<langle>LeftTranslation(G, f, x)`(s), LeftTranslation(G, f, x)`(t)\\<rangle>\"\n          using prodFunctionApp group0_5_L1(2) by blast\n        with assms st(2,3) have \"?P`(z) = \\<langle>x\\<ra>s,x\\<ra>t\\<rangle>\" using group0_5_L2(2)\n          by auto\n        moreover\n        from \\<open>x\\<in>G\\<close> \\<open>s\\<in>G\\<close> \\<open>t\\<in>G\\<close> have \"(\\<rm> (x\\<ra>s)) \\<ra> (x\\<ra>t) = (\\<rm>s)\\<ra>t\"\n          using cancel_middle_add(3) by simp\n        with st2 have \"(\\<rm> (x\\<ra>s)) \\<ra> (x\\<ra>t) \\<in> U\" by auto\n        ultimately have \"?P`(z) \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . (\\<rm> s) \\<ra> t \\<in> U}\"\n          using assms st(2,3) group_op_closed by auto\n        with as(3) have \"?P`(z) \\<in> V\" by force\n        with L z have \"z \\<in> ?P-``(V)\" using prodFunction func1_1_L5A vimage_iff\n          by blast\n      }\n      with as(2) have \"\\<exists>U\\<in>\\<N>\\<^sub>0. {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . (\\<rm> s) \\<ra> t \\<in> U} \\<subseteq> ?P-``(V)\" \n        by blast\n      with \\<open>LeftTranslation(G,f,x):G\\<rightarrow>G\\<close> \\<open>V \\<subseteq> G \\<times> G\\<close> have \"?P-``(V) \\<in> leftUniformity\"\n        unfolding leftUniformity_def using prodFunction func1_1_L6A by blast\n    } thus ?thesis by simp\n  qed\n  ultimately show ?thesis using IsUniformlyCont_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1913
    },
    "1722": {
        "type": "lemma",
        "text": "text\\<open> Right translations are uniformly continuous with respect to the right uniformity. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\"\n  ",
        "using": [
            "group0_5_L1",
            "side_uniformities(2)",
            "prodFunctionApp",
            "group0_5_L1(1)",
            "group0_5_L2(1)",
            "cancel_middle_add(4)",
            "assms",
            "st(2,3)",
            "group_op_closed",
            "prodFunction",
            "func1_1_L5A",
            "vimage_iff",
            "func1_1_L6A",
            "IsUniformlyCont_def"
        ],
        "statement": "lemma (in topgroup) right_mult_uniformity: assumes \"x\\<in>G\"\n  shows \n    \"RightTranslation(G,f,x) {is uniformly continuous between} rightUniformity {and} rightUniformity\" \n",
        "proof": "proof -\n  let ?P = \"ProdFunction(RightTranslation(G, f, x), RightTranslation(G, f, x))\"\n  from assms have R: \"RightTranslation(G,f,x):G\\<rightarrow>G\" and \"rightUniformity {is a uniformity on} G\" \n    using group0_5_L1 side_uniformities(2) by auto\n  moreover have \"\\<forall>V \\<in> rightUniformity. ?P-``(V) \\<in> rightUniformity\"\n  proof -\n    { fix V assume \"V \\<in> rightUniformity\"\n      then obtain U where \"U \\<in> \\<N>\\<^sub>0\" and \"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . s \\<ra> (\\<rm> t) \\<in> U} \\<subseteq> V\"\n        unfolding rightUniformity_def by auto\n      with \\<open>V \\<in> rightUniformity\\<close> have \n        as:\"V \\<subseteq> G \\<times> G\" \"U \\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . s \\<ra> (\\<rm> t) \\<in> U} \\<subseteq> V\"\n        unfolding rightUniformity_def by auto\n      { fix z assume z:\"z \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . s \\<ra> (\\<rm> t) \\<in> U}\"\n        then obtain s t where st:\"z=\\<langle>s,t\\<rangle>\" \"s\\<in>G\" \"t\\<in>G\" by auto\n        from st(1) z have st2: \"s \\<ra> (\\<rm>t) \\<in> U\" by auto\n        from assms st have \"?P`(z) = \\<langle>RightTranslation(G, f, x)`(s), RightTranslation(G, f, x)`(t)\\<rangle>\"\n          using prodFunctionApp group0_5_L1(1) by blast\n        with assms st(2,3) have \"?P`(z) = \\<langle>s\\<ra>x,t\\<ra>x\\<rangle>\" using group0_5_L2(1)\n          by auto\n        moreover\n        from \\<open>x\\<in>G\\<close> \\<open>s\\<in>G\\<close> \\<open>t\\<in>G\\<close> have \"(s\\<ra>x) \\<ra> (\\<rm>(t\\<ra>x)) =s\\<ra> (\\<rm>t)\"\n          using cancel_middle_add(4) by simp\n        with st2 have \"(s\\<ra>x) \\<ra> (\\<rm>(t\\<ra>x)) \\<in> U\" by auto\n        ultimately have \"?P`(z) \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . s \\<ra> (\\<rm> t) \\<in> U}\"\n          using assms st(2,3) group_op_closed by auto\n        with as(3) have \"?P`(z) \\<in> V\" by force\n        with R z have \"z \\<in> ?P-``(V)\" using prodFunction func1_1_L5A vimage_iff\n          by blast\n      }\n      with as(2) have \"\\<exists>U\\<in>\\<N>\\<^sub>0. {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . s \\<ra> (\\<rm> t) \\<in> U} \\<subseteq> ?P-``(V)\" \n        by blast\n      with \\<open>RightTranslation(G,f,x):G\\<rightarrow>G\\<close> \\<open>V \\<subseteq> G \\<times> G\\<close> have \"?P-``(V) \\<in> rightUniformity\"\n        unfolding rightUniformity_def using prodFunction func1_1_L6A by blast\n    } thus ?thesis by simp\n  qed\n  ultimately show ?thesis using IsUniformlyCont_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1914
    },
    "1723": {
        "type": "lemma",
        "text": "text\\<open>The Roelcke uniformity is indeed a uniformity on the group. \\<close>\n",
        "assumes": "",
        "using": [
            "Top_2_L1",
            "elem_in_int_rtrans(1)",
            "lrtrans_in_group_add(2)",
            "interval_add(4)",
            "group0_2_L2",
            "ginv_image_add(1)",
            "elements_in_set_sum",
            "elements_in_rtrans",
            "cancel_middle_add(5)",
            "ginv_image_el_add",
            "lrtrans_image(2)",
            "converse_iff",
            "neg_neigh_neigh",
            "exists_procls_zerohood",
            "lrtrans_in_group_add",
            "group_oper_assoc",
            "group_op_closed",
            "zero_in_tgroup",
            "trans_neutral_image",
            "interval_add_zero",
            "Top_2_L2",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L5",
            "elements_in_set_sum_inv",
            "AU(3)",
            "BU(3)",
            "roelckeUniformity_def",
            "as(2)",
            "BU(1)",
            "IsUniformity_def"
        ],
        "statement": "lemma (in topgroup) roelcke_uniformity:\n  shows \"roelckeUniformity {is a uniformity on} G\"\n",
        "proof": "proof -\n  let ?\\<Phi> = \"roelckeUniformity\"\n  have \"\\<forall>U \\<in> ?\\<Phi>. id(G)\\<subseteq>U \\<and> (\\<exists>V\\<in>?\\<Phi>. V O V \\<subseteq> U) \\<and> converse(U) \\<in> ?\\<Phi>\"\n  proof\n    fix U assume U:\"U \\<in> roelckeUniformity\"\n    then obtain V where V:\"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(V\\<rtr>s)\\<sad>V} \\<subseteq> U\" \"V\\<in> \\<N>\\<^sub>0\" \"U:Pow(G\\<times>G)\" \n      unfolding roelckeUniformity_def by auto\n    from V(2) have VG:\"V\\<subseteq>G\" by auto\n    have \"id(G) \\<subseteq> U\"\n    proof -\n      from V(2) have \"\\<zero>\\<in>int(V)\" by auto\n      then have V0:\"\\<zero>\\<in>V\" using Top_2_L1 by auto\n      { fix x assume x:\"x\\<in>G\"\n        with \\<open>V\\<in>\\<N>\\<^sub>0\\<close> have \"x \\<in> V\\<rtr>x\" using elem_in_int_rtrans(1) Top_2_L1 by blast \n        with \\<open>V\\<subseteq>G\\<close> \\<open>x\\<in>G\\<close> \\<open>\\<zero>\\<in>V\\<close> have \"x\\<ra>\\<zero> : (V\\<rtr>x)\\<sad>V\"\n          using lrtrans_in_group_add(2) interval_add(4) by auto\n        with \\<open>x\\<in>G\\<close>  have \"x: (V\\<rtr>x)\\<sad>V\" using group0_2_L2 by auto\n        with \\<open>x\\<in>G\\<close> have \"\\<langle>x,x\\<rangle>:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(V\\<rtr>s)\\<sad>V}\" by auto\n        with V(1) have \"\\<langle>x,x\\<rangle>\\<in>U\" by auto\n      } thus \"id(G) \\<subseteq> U\" by auto\n    qed\n    moreover have \"converse(U) \\<in> ?\\<Phi>\"\n    proof -\n      { fix l assume \"l \\<in> {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>((\\<sm>V)\\<rtr>s)\\<sad>(\\<sm>V)}\"\n        then obtain s t where st:\"s\\<in>G\" \"t\\<in>G\" \"t \\<in>((\\<sm>V)\\<rtr>s)\\<sad>(\\<sm>V)\" \"l=\\<langle>s,t\\<rangle>\" \n          by force\n        from \\<open>V\\<subseteq>G\\<close> have smG:\"(\\<sm>V) \\<subseteq> G\" using ginv_image_add(1) by simp\n        with \\<open>s\\<in>G\\<close> have VxG:\"(\\<sm>V)\\<rtr>s \\<subseteq> G\" using lrtrans_in_group_add(2) by simp\n        from \\<open>V\\<subseteq>G\\<close> \\<open>t\\<in>G\\<close> have VsG:\"V\\<rtr>t \\<subseteq> G\" using lrtrans_in_group_add(2) by simp\n        from st(3) VxG smG obtain x y where xy:\"t = x\\<ra>y\" \"x \\<in> (\\<sm>V)\\<rtr>s\" \"y\\<in>(\\<sm>V)\" \n          using elements_in_set_sum by blast\n        from xy(2) smG st(1) obtain z where z:\"x = z\\<ra>s\" \"z\\<in>(\\<sm>V)\" using elements_in_rtrans \n          by blast\n        with \\<open>y\\<in>(\\<sm>V)\\<close> \\<open>(\\<sm>V)\\<subseteq>G\\<close> \\<open>s\\<in>G\\<close> \\<open>t = x\\<ra>y\\<close>\n        have ts:\"(\\<rm>z)\\<ra>t\\<ra>(\\<rm>y) = s\" using cancel_middle_add(5) by blast\n        {\n          fix u assume \"u\\<in>(\\<sm>V)\"\n          with \\<open>V\\<subseteq>G\\<close> have \"(\\<rm>u) \\<in> V\" using ginv_image_el_add by simp\n        } hence R:\"\\<forall>u\\<in>(\\<sm>V).(\\<rm>u) \\<in> V\" by simp\n        with z(2) xy(3) have zy:\"(\\<rm>z)\\<in>V\" \"(\\<rm>y)\\<in>V\" by auto\n        from zy(1) VG st(2) have \"(\\<rm>z)\\<ra>t : V\\<rtr>t\" using lrtrans_image(2) by auto\n        with zy(2) VG VsG have \"(\\<rm>z)\\<ra>t\\<ra>(\\<rm>y) : (V\\<rtr>t)\\<sad>V\" \n          using interval_add(4) by auto\n        with ts have \"s:(V\\<rtr>t)\\<sad>V\" by auto\n        with st(1,2) have \"\\<langle>s,t\\<rangle> \\<in> converse({\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(V\\<rtr>s)\\<sad>V})\" \n          using converse_iff by auto\n        with V(1) have \"\\<langle>s,t\\<rangle> \\<in>  converse(U)\" by auto\n        with st(4) have \"l \\<in> converse(U)\" by auto\n      } then have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>((\\<sm>V)\\<rtr>s)\\<sad>(\\<sm>V)} \\<subseteq> converse(U)\" by auto\n      moreover from V(2) have \"(\\<sm>V): \\<N>\\<^sub>0\" using neg_neigh_neigh by auto\n      ultimately have \"\\<exists>V\\<in> \\<N>\\<^sub>0. {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(V\\<rtr>s)\\<sad>V} \\<subseteq> converse(U)\" by auto \n      moreover\n      from V(3) have \"converse(U) \\<subseteq> G\\<times>G\" unfolding converse_def by auto\n      ultimately show \"converse(U) \\<in> roelckeUniformity\" unfolding roelckeUniformity_def by auto\n    qed\n    moreover have \"\\<exists>Z\\<in>?\\<Phi>. Z O Z \\<subseteq> U\"\n    proof -\n      from V(2) obtain W where W:\"W\\<in>\\<N>\\<^sub>0\" \"W\\<sad>W \\<subseteq> V\" using exists_procls_zerohood by blast\n      then have WG:\"W\\<subseteq>G\" by auto\n      moreover\n      { fix k assume as:\"k:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W} O {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W}\"\n        then obtain x\\<^sub>1 x\\<^sub>2 x\\<^sub>3 where \n          x:\"x\\<^sub>1\\<in>G\" \"x\\<^sub>2\\<in>G\" \"x\\<^sub>3\\<in>G\" \"x\\<^sub>2 \\<in> (W\\<rtr>x\\<^sub>1)\\<sad>W\" \"x\\<^sub>3 \\<in> (W\\<rtr>x\\<^sub>2)\\<sad>W\" \"k=\\<langle>x\\<^sub>1,x\\<^sub>3\\<rangle>\"\n          unfolding comp_def by auto\n        from \\<open>x\\<^sub>1\\<in>G\\<close> have VsG:\"W\\<rtr>x\\<^sub>1 \\<subseteq> G\" and Vx1G:\"V\\<rtr>x\\<^sub>1 \\<subseteq> G\" \n          using lrtrans_in_group_add(2) by auto\n        from x(4) VsG WG obtain x y where xy:\"x\\<^sub>2 = x\\<ra>y\" \"x \\<in> W\\<rtr>x\\<^sub>1\" \"y\\<in>W\" \n          using elements_in_set_sum by blast\n        from xy(2) WG x(1) obtain z where z:\"x = z\\<ra>x\\<^sub>1\" \"z\\<in>W\" using elements_in_rtrans \n          by blast\n        from z(2) xy(3) WG have yzG:\"y\\<in>G\" \"z\\<in>G\" by auto\n        from x(2) have VsG:\"W\\<rtr>x\\<^sub>2 \\<subseteq> G\" using lrtrans_in_group_add by simp\n        from x(5) VsG WG obtain x' y' where xy2:\"x\\<^sub>3 = x'\\<ra>y'\" \"x'\\<in> W\\<rtr>x\\<^sub>2\" \"y'\\<in>W\" \n          using elements_in_set_sum by blast\n        from xy2(2) WG x(2) obtain z' where z2:\"x' = z'\\<ra>x\\<^sub>2\" \"z'\\<in>W\" using elements_in_rtrans \n          by blast\n        from z2(2) xy2(3) WG have yzG2:\"y'\\<in>G\" \"z'\\<in>G\" by auto\n        from xy(1) z(1) xy2(1) z2(1) have \"x\\<^sub>3 = (z'\\<ra>(z\\<ra>x\\<^sub>1\\<ra>y))\\<ra>y'\" by auto\n        with yzG yzG2 x(1) have x3:\"x\\<^sub>3 = ((z'\\<ra>z)\\<ra>x\\<^sub>1)\\<ra>(y\\<ra>y')\" \n          using group_oper_assoc group_op_closed by simp\n        from xy(3) z(2) xy2(3) z2(2) WG have \"z'\\<ra>z \\<in>  W\\<sad>W\" \"y\\<ra>y' \\<in> W\\<sad>W\" \n          using interval_add(4) by auto\n        with W(2) have yzV:\"z'\\<ra>z \\<in> V\" \"y\\<ra>y' \\<in> V\" by auto\n        from yzV(1) VG x(1) have \"(z'\\<ra>z)\\<ra>x\\<^sub>1 \\<in> V\\<rtr>x\\<^sub>1\" using lrtrans_image(2) by auto\n        with yzV(2) Vx1G VG have \"((z'\\<ra>z)\\<ra>x\\<^sub>1)\\<ra>(y\\<ra>y') \\<in> (V\\<rtr>x\\<^sub>1)\\<sad>V\" \n          using interval_add(4) by auto\n        with x3 have \"x\\<^sub>3 \\<in> (V\\<rtr>x\\<^sub>1)\\<sad>V\" by auto\n        with x(1,3,6) have \"k:{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(V\\<rtr>s)\\<sad>V}\" by auto\n      }\n      with V(1) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W} O {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W}\\<subseteq>U\" \n        by auto \n      moreover from W(1) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W}\\<in>roelckeUniformity\" \n        unfolding roelckeUniformity_def by auto\n      ultimately show \"\\<exists>Z\\<in>roelckeUniformity. Z O Z \\<subseteq> U\" by auto\n    qed\n    ultimately show \"id(G)\\<subseteq>U \\<and> (\\<exists>V\\<in>?\\<Phi>. V O V \\<subseteq> U) \\<and> converse(U) \\<in> ?\\<Phi>\" by simp\n  qed\n  moreover\n  have \"roelckeUniformity {is a filter on} (G \\<times> G)\" \n  proof -\n    {\n      assume \"0 \\<in> roelckeUniformity\"\n      then obtain W where U:\"W\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W}\\<subseteq>0\" \n        unfolding roelckeUniformity_def by auto\n      have \"\\<langle>\\<zero>,\\<zero>\\<rangle>:G\\<times>G\" using zero_in_tgroup by auto\n      moreover have \"\\<zero> = \\<zero>\\<ra>\\<zero>\\<ra>\\<zero>\" using group0_2_L2 zero_in_tgroup by auto\n      moreover \n      from U(1) have \"\\<zero>\\<in>int(W)\" by auto\n      then have \"\\<zero>\\<in>W\" using Top_2_L1 by auto\n      with \\<open>W\\<in>\\<N>\\<^sub>0\\<close> have \"\\<zero>\\<ra>\\<zero>\\<ra>\\<zero> \\<in> (W\\<rtr>\\<zero>)\\<sad>W\" \n        using  group0_2_L2 group_op_closed trans_neutral_image interval_add_zero\n        by auto\n      ultimately have \"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(W\\<rtr>s)\\<sad>W}\" by auto \n      with U(2) have False by blast\n    }\n    moreover \n    {\n      fix x xa assume as:\"x \\<in> roelckeUniformity\" \"xa\\<in>x\"\n      have \"roelckeUniformity \\<subseteq> Pow(G\\<times>G)\" unfolding roelckeUniformity_def by auto\n      with as have \"xa \\<in> G\\<times>G\" by auto\n    }\n    moreover \n    {\n      have \"G\\<times>G\\<in>Pow(G\\<times>G)\" by auto \n      moreover\n      have \"{\\<langle>s,t\\<rangle>:G\\<times>G.  t \\<in>(G\\<rtr>s)\\<sad>G} \\<subseteq> G\\<times>G\" by auto \n      moreover note zneigh_not_empty\n      ultimately have \"G\\<times>G\\<in>roelckeUniformity\" unfolding roelckeUniformity_def by auto\n    }\n    moreover \n    {\n      fix A B assume as:\"A\\<in>roelckeUniformity\" \"B\\<in>roelckeUniformity\"\n      from as(1) obtain AU where \n        AU:\"AU\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(AU\\<rtr>s)\\<sad>AU}\\<subseteq> A\" \"A\\<in>Pow(G\\<times>G)\"\n        unfolding roelckeUniformity_def by auto\n      from as(2) obtain BU where \n        BU:\"BU\\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(BU\\<rtr>s)\\<sad>BU}\\<subseteq> B\" \"B\\<in>Pow(G\\<times>G)\" \n        unfolding roelckeUniformity_def by auto\n      from AU(1) BU(1) have \"\\<zero> \\<in> int(AU)\\<inter>int(BU)\" by auto\n      moreover have op:\"int(AU)\\<inter>int(BU)\\<in>T\" using Top_2_L2 topSpaceAssum unfolding IsATopology_def \n        by auto\n      moreover \n      have \"int(AU)\\<inter>int(BU) \\<subseteq> AU\\<inter>BU\" using Top_2_L1 by auto\n      with op have \"int(AU)\\<inter>int(BU)\\<subseteq>int(AU\\<inter>BU)\" using Top_2_L5\n        by auto \n      moreover note AU(1) BU(1)\n      ultimately have interNeigh:\"AU\\<inter>BU \\<in> \\<N>\\<^sub>0\" unfolding zerohoods_def by auto \n      moreover\n      {\n        fix z assume \"z \\<in> {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>((AU\\<inter>BU)\\<rtr>s)\\<sad>(AU\\<inter>BU)}\"\n        then obtain s t where \n          z:\"z=\\<langle>s,t\\<rangle>\" \"s\\<in>G\" \"t\\<in>G\" \"t \\<in> ((AU\\<inter>BU)\\<rtr>s)\\<sad>(AU\\<inter>BU)\" \n          by force\n        from \\<open>AU\\<inter>BU \\<in> \\<N>\\<^sub>0\\<close> \\<open>s\\<in>G\\<close> have \"AU\\<inter>BU \\<subseteq> G\" and \"(AU\\<inter>BU)\\<rtr>s \\<subseteq>G\" \n          using lrtrans_in_group_add(2) by auto\n        with z(4) obtain  x y where t:\"t=x\\<ra>y\" \"x\\<in>(AU\\<inter>BU)\\<rtr>s\" \"y\\<in>AU\\<inter>BU\"\n          using elements_in_set_sum by blast\n        from t(2) z(2) interNeigh obtain q where x:\"x=q\\<ra>s\" \"q \\<in> AU\\<inter>BU\" using lrtrans_image(2)\n          by auto\n        with AU(1) BU(1) z(2) have \"x \\<in> AU\\<rtr>s\" \"x \\<in> BU\\<rtr>s\" using lrtrans_image(2) by auto\n        with \\<open>y \\<in> AU\\<inter>BU\\<close> \\<open>AU\\<in> \\<N>\\<^sub>0\\<close> \\<open>BU\\<in> \\<N>\\<^sub>0\\<close> \\<open>s \\<in> G\\<close> \\<open>t=x\\<ra>y\\<close> have\n          \"t \\<in> (AU\\<rtr>s)\\<sad>AU\" and \"t \\<in> (BU\\<rtr>s)\\<sad>BU\"\n          using lrtrans_in_group_add(2) elements_in_set_sum_inv by auto \n        with z(1,2,3) have \n          \"z \\<in> {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(AU\\<rtr>s)\\<sad>AU}\" and \"z \\<in>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(BU\\<rtr>s)\\<sad>BU}\" \n          by auto\n      }\n      then have \n        \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>((AU\\<inter>BU)\\<rtr>s)\\<sad>(AU\\<inter>BU)} \\<subseteq> \n        {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(AU\\<rtr>s)\\<sad>AU}\\<inter>{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(BU\\<rtr>s)\\<sad>BU}\" \n        by auto\n      with AU(2) BU(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>((AU\\<inter>BU)\\<rtr>s)\\<sad>(AU\\<inter>BU)}\\<subseteq>A\\<inter>B\" by blast\n      ultimately have \"A\\<inter>B \\<in> roelckeUniformity\" using AU(3) BU(3) unfolding roelckeUniformity_def \n        by blast\n    }\n    moreover \n    {\n      fix B C assume as:\"B\\<in>roelckeUniformity\" \"C\\<subseteq>(G \\<times> G)\" \"B \\<subseteq> C\"\n      from as(1) obtain BU where BU:\"BU\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(BU\\<rtr>s)\\<sad>BU}\\<subseteq>B\" \n        unfolding roelckeUniformity_def by blast\n      from as(3) BU(2) have \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t \\<in>(BU\\<rtr>s)\\<sad>BU}\\<subseteq>C\" by auto\n      then have \"C \\<in> roelckeUniformity\" using as(2) BU(1) unfolding roelckeUniformity_def \n        by auto\n    }\n    ultimately show ?thesis unfolding IsFilter_def by auto\n  qed\n  ultimately show ?thesis using IsUniformity_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1915
    },
    "1724": {
        "type": "lemma",
        "text": "text\\<open> The topology given by the roelcke uniformity is the original topology \\<close>\n",
        "assumes": "",
        "using": [
            "IsNeighSystem_def",
            "neigh_from_uniformity",
            "roelcke_uniformity",
            "ZF_fun_from_tot_val",
            "lrtrans_in_group_add",
            "interval_add(1)",
            "image_mono",
            "Top_2_L1",
            "Top_2_L2",
            "lrtrans_in_group_add(2)",
            "interval_add(2)",
            "rtrans_interior",
            "interval_add(3)",
            "ltrans_interior",
            "union_open",
            "elem_in_int_rtrans(2)",
            "open_neigh_open",
            "open_trans_neigh",
            "op",
            "x",
            "exists_procls_zerohood",
            "lrtrans_neigh",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L5",
            "elements_in_set_sum",
            "elements_in_rtrans",
            "neg_in_tgroup",
            "lrtrans_image",
            "lrtrans_in_group",
            "lrtrans_image(2)",
            "cancel_middle(4)",
            "group_oper_assoc",
            "elements_in_set_sum_inv",
            "elements_in_ltrans_inv",
            "trans_subset",
            "IsUniformity_def",
            "IsFilter_def",
            "apply_equality",
            "uniftop_def_alt"
        ],
        "statement": "lemma (in topgroup) top_generated_roelcke_uniformity:\n  shows \"UniformTopology(roelckeUniformity,G) = T\"\n",
        "proof": "proof -\n  let ?M = \"{\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G}\"\n  have fun:\"?M:G\\<rightarrow>Pow(Pow(G))\" using IsNeighSystem_def neigh_from_uniformity roelcke_uniformity\n    by auto\n  {\n    fix U assume as:\"U \\<in> {U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> ?M`x}\"\n    {\n      fix x assume x:\"x\\<in>U\"\n      with as have xg:\"x\\<in>G\" by auto\n      from x as have \"U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G}`(x)\" by auto\n      with fun \\<open>x\\<in>G\\<close> have \"U \\<in> {V `` {x} . V \\<in> roelckeUniformity}\" using ZF_fun_from_tot_val \n        by simp\n      then obtain V where V:\"U=V``{x}\" \"V \\<in> roelckeUniformity\" by auto\n      from V(2) obtain W where W:\"W\\<in>\\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle>\\<in>G\\<times>G. t\\<in> (W\\<rtr>s)\\<sad>W}\\<subseteq>V\" \n        unfolding roelckeUniformity_def by auto\n      from W(1) have WG:\"W\\<subseteq>G\" by auto\n      from W(2) have A:\"{\\<langle>s,t\\<rangle>:G\\<times>G. t:(W\\<rtr>s)\\<sad>W}``{x} \\<subseteq> V``{x}\" by auto\n      have \"{\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t \\<in> (W\\<rtr>s)\\<sad>W}``{x} = (W\\<rtr>x)\\<sad>W\"\n      proof -\n        let ?A = \"{\\<langle>s,t\\<rangle>:G\\<times>G. t \\<in> (W\\<rtr>s)\\<sad>W}\"\n        from \\<open>W\\<subseteq>G\\<close>  \\<open>x\\<in>G\\<close> have I:\"(W\\<rtr>x)\\<sad>W \\<subseteq> G\" \n            using  lrtrans_in_group_add interval_add(1) by auto\n        have \"?A``{x} = {t\\<in>G.\\<langle>x,t\\<rangle> \\<in> ?A}\" by blast \n        moreover have \"{t\\<in>G. \\<langle>x,t\\<rangle> \\<in> ?A} \\<subseteq> (W\\<rtr>x)\\<sad>W\" by auto\n        moreover from \\<open>W\\<subseteq>G\\<close>  \\<open>x\\<in>G\\<close> I have \"(W\\<rtr>x)\\<sad>W \\<subseteq> {t\\<in>G. \\<langle>x,t\\<rangle> \\<in> ?A}\" by auto\n        ultimately show ?thesis by auto\n      qed\n      with A V(1) have WU:\"(W\\<rtr>x)\\<sad>W \\<subseteq> U\" by auto\n      have \"int(W)\\<rtr>x \\<subseteq> W\\<rtr>x\" using image_mono Top_2_L1 by simp\n      then have \"(int(W)\\<rtr>x)\\<times>(int(W)) \\<subseteq> (W\\<rtr>x)\\<times>W\" using Top_2_L1 by auto\n      then have \"f``((int(W)\\<rtr>x)\\<times>(int(W))) \\<subseteq> f``((W\\<rtr>x)\\<times>W)\" using image_mono by auto\n      moreover \n      from xg WG have \n        \"\\<langle>int(W)\\<rtr>x,int(W)\\<rangle> \\<in> Pow(G)\\<times>Pow(G)\" and \"\\<langle>(W\\<rtr>x),W\\<rangle> \\<in> Pow(G)\\<times>Pow(G)\" \n        using Top_2_L2 lrtrans_in_group_add(2) by auto\n      then have \n        \"(int(W)\\<rtr>x)\\<sad>(int(W)) = f``((int(W)\\<rtr>x)\\<times>(int(W)))\" and \n        \"(W\\<rtr>x)\\<sad>W = f``((W\\<rtr>x)\\<times>W)\"\n        using interval_add(2) by auto\n      ultimately have \"(int(W)\\<rtr>x)\\<sad>(int(W)) \\<subseteq> (W\\<rtr>x)\\<sad>W\" by auto\n      with xg WG have \"int(W\\<rtr>x)\\<sad>(int(W)) \\<subseteq> (W\\<rtr>x)\\<sad>W\" using rtrans_interior \n        by auto \n      moreover\n      {\n        have \"int(W\\<rtr>x)\\<sad>(int(W)) = (\\<Union>t\\<in>int(W\\<rtr>x). t\\<ltr>(int(W)))\" \n          using interval_add(3) Top_2_L2 by auto \n        moreover have \"\\<forall>t\\<in>int(W\\<rtr>x). t\\<ltr>(int(W)) = int(t\\<ltr>W)\"\n        proof -\n          { fix t assume \"t \\<in> int(W\\<rtr>x)\"\n            from \\<open>x\\<in>G\\<close> have \"(W\\<rtr>x) \\<subseteq> G\" using lrtrans_in_group_add(2) by simp\n            with \\<open>t \\<in> int(W\\<rtr>x)\\<close> have \"t\\<in>G\" using Top_2_L2 by auto\n            with \\<open>W\\<subseteq>G\\<close> have \"t \\<ltr> int(W) = int(t\\<ltr>W)\" using ltrans_interior by simp\n          } thus ?thesis by simp\n        qed\n        ultimately have \"int(W\\<rtr>x)\\<sad>(int(W)) = (\\<Union>t\\<in>int(W\\<rtr>x). int(t\\<ltr>W))\" \n          by auto\n        with topSpaceAssum have \"int(W\\<rtr>x)\\<sad>(int(W)) \\<in> T\" using Top_2_L2 union_open\n          by auto\n      } \n      moreover from \\<open>x\\<in>G\\<close> \\<open>W\\<in>\\<N>\\<^sub>0\\<close> have \"x \\<in> int(W\\<rtr>x)\\<sad>(int(W))\" \n        using elem_in_int_rtrans(2) by simp\n      moreover note WU\n      ultimately have \"\\<exists>Y\\<in>T. x\\<in>Y \\<and> Y\\<subseteq>U\" by auto\n    }\n    then have \"U\\<in>T\" using open_neigh_open by auto\n  } \n  then have \"{U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G}`(x)} \\<subseteq> T\" \n    by auto \n  moreover\n  {\n    fix U assume op:\"U\\<in>T\"\n    {\n      fix x assume x:\"x\\<in>U\"\n      with op have xg:\"x\\<in>G\" by auto\n      have \"(\\<rm>x)\\<ltr>U \\<in> \\<N>\\<^sub>0\" using open_trans_neigh op x by auto\n      then obtain W where W:\"W\\<in>\\<N>\\<^sub>0\" \"W \\<sad> W \\<subseteq>(\\<rm>x)\\<ltr>U\" using exists_procls_zerohood \n        by blast\n      let ?V = \"x\\<ltr>(W\\<rtr>(\\<rm>x)) \\<inter> W\"\n      from \\<open>W \\<in> \\<N>\\<^sub>0\\<close> \\<open>x\\<in>G\\<close> have  xWx:\"x\\<ltr>(W\\<rtr>(\\<rm>x)) :\\<N>\\<^sub>0\" using lrtrans_neigh\n        by simp\n      from W(1) have WG:\"W\\<subseteq>G\" by auto\n      from xWx W(1) have \"\\<zero>\\<in>int(x\\<ltr>(W\\<rtr>(\\<rm>x)))\\<inter>int(W)\" by auto\n      have int:\"int(x\\<ltr>(W\\<rtr>(\\<rm>x)))\\<inter>int(W)\\<in>T\" \n        using Top_2_L2 topSpaceAssum  unfolding IsATopology_def by auto\n      have \"int(x\\<ltr>(W\\<rtr>(\\<rm>x)))\\<inter>int(W) \\<subseteq> (x\\<ltr>(W\\<rtr>(\\<rm>x)))\\<inter>W\" using Top_2_L1 \n        by auto\n      with int have \"int(x\\<ltr>(W\\<rtr>(\\<rm>x)))\\<inter>int(W)\\<subseteq>int((x\\<ltr>(W\\<rtr>(\\<rm>x)))\\<inter>W)\" \n        using Top_2_L5 by auto \n      moreover note xWx W(1)\n      ultimately have V_NEIG:\"?V \\<in> \\<N>\\<^sub>0\" unfolding zerohoods_def by auto  \n      {\n        fix z assume z:\"z \\<in> (?V\\<rtr>x)\\<sad>?V\"\n        from W(1) have VG:\"?V \\<subseteq> G\" by auto\n        with \\<open>x\\<in>G\\<close> have VxG:\"?V\\<rtr>x \\<subseteq> G\" using lrtrans_in_group_add(2) by simp\n        from z VG VxG W(1) obtain a\\<^sub>1 b\\<^sub>1 where ab:\"z=a\\<^sub>1\\<ra>b\\<^sub>1\" \"a\\<^sub>1 \\<in> ?V\\<rtr>x\" \"b\\<^sub>1 \\<in> ?V\" \n          using elements_in_set_sum by blast\n        from ab(2) xg VG obtain c\\<^sub>1 where c:\"a\\<^sub>1=c\\<^sub>1\\<ra>x\" \"c\\<^sub>1 \\<in> ?V\" using elements_in_rtrans \n          by blast\n        from ab(3) c(2) have bc:\"b\\<^sub>1\\<in>W\" \"c\\<^sub>1 \\<in> x\\<ltr>(W\\<rtr>(\\<rm>x))\" by auto\n        from \\<open>x\\<in>G\\<close> have \"x\\<ltr>(W\\<rtr>(\\<rm>x)) = {x\\<ra>y. y\\<in>(W\\<rtr>(\\<rm>x))}\"\n          using neg_in_tgroup lrtrans_in_group_add lrtrans_image by auto\n        with \\<open>c\\<^sub>1 \\<in> x\\<ltr>(W\\<rtr>(\\<rm>x))\\<close> obtain d where d:\"c\\<^sub>1=x\\<ra>d\" \"d \\<in> W\\<rtr>(\\<rm>x)\" \n          by auto\n        from \\<open>x\\<in>G\\<close> \\<open>W\\<in>\\<N>\\<^sub>0\\<close> \\<open>d \\<in> W\\<rtr>(\\<rm>x)\\<close> obtain e where e:\"d=e\\<ra>(\\<rm>x)\" \"e\\<in>W\"\n          using neg_in_tgroup lrtrans_in_group lrtrans_image(2) by auto \n        from e(2) WG have eG:\"e\\<in>G\" by auto\n        from \\<open>e\\<in>W\\<close> \\<open>W\\<subseteq>G\\<close> \\<open>b\\<^sub>1\\<in>W\\<close> have \"e\\<in>G\" \"b\\<^sub>1\\<in>G\" by auto \n        from \\<open>z = a\\<^sub>1\\<ra>b\\<^sub>1\\<close> \\<open>a\\<^sub>1 = c\\<^sub>1\\<ra>x\\<close>  \\<open>c\\<^sub>1 = x\\<ra>d\\<close> \\<open>d = e\\<ra>(\\<rm>x)\\<close>\n        have \"z = x \\<ra> (e\\<ra>(\\<rm>x)) \\<ra> x \\<ra> b\\<^sub>1\" by simp\n        with \\<open>x\\<in>G\\<close> \\<open>e\\<in>G\\<close> have \"z=(x\\<ra>e)\\<ra>b\\<^sub>1\" using cancel_middle(4) by simp\n        with \\<open>x\\<in>G\\<close> \\<open>e\\<in>G\\<close> \\<open>b\\<^sub>1\\<in>G\\<close> have \"z = x\\<ra>(e\\<ra>b\\<^sub>1)\" using group_oper_assoc by simp\n        moreover from e(2) ab(3) WG have \"e\\<ra>b\\<^sub>1 \\<in> W\\<sad>W\" using elements_in_set_sum_inv \n          by auto\n        moreover note xg WG\n        ultimately have \"z\\<in>x\\<ltr>(W\\<sad>W)\" using elements_in_ltrans_inv interval_add(1) \n          by auto \n        moreover \n        from \\<open>W\\<subseteq>G\\<close> \\<open>U\\<in>T\\<close> have \"W \\<sad> W \\<subseteq> G\" and \"U\\<subseteq>G\" using interval_add(1) by auto\n        with \\<open>W \\<sad> W \\<subseteq>(\\<rm>x)\\<ltr>U\\<close> \\<open>x\\<in>G\\<close> have  \"x\\<ltr>(W\\<sad>W) \\<subseteq> U\" using trans_subset \n          by simp\n        ultimately have \"z\\<in>U\" by auto\n      }\n      then have sub:\"(?V\\<rtr>x)\\<sad>?V \\<subseteq> U\" by auto \n      moreover from V_NEIG have unif:\"{\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t : (?V\\<rtr>s)\\<sad>?V} \\<in> roelckeUniformity\" \n        unfolding roelckeUniformity_def by auto \n      moreover from xg have \n        \"\\<forall>q. q\\<in>{\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t : (?V\\<rtr>s)\\<sad>?V}``{x} \\<longleftrightarrow> q\\<in>((?V\\<rtr>x)\\<sad>?V)\\<inter>G\" \n        by auto\n      then have \"{\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t \\<in> (?V\\<rtr>s)\\<sad>?V}``{x} = ((?V\\<rtr>x)\\<sad>?V)\\<inter>G\" \n        by auto\n      ultimately have basic:\"{\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t : (?V\\<rtr>s)\\<sad>?V}``{x} \\<subseteq> U\" using op \n        by auto\n      have add:\"({x}\\<times>U)``{x} =U\" by auto\n      from basic add have \"({\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t \\<in> (?V\\<rtr>s)\\<sad>?V}\\<union>({x}\\<times>U))``{x} = U\" \n        by auto\n      moreover have R:\"\\<forall>B\\<in>roelckeUniformity.(\\<forall> C\\<in>Pow(G \\<times> G).  B \\<subseteq> C \\<longrightarrow> C \\<in> roelckeUniformity)\" \n        using roelcke_uniformity unfolding IsUniformity_def IsFilter_def by auto\n      moreover from op xg have GG:\"({\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t \\<in> (?V\\<rtr>s)\\<sad>?V}\\<union>({x}\\<times>U)):Pow(G\\<times>G)\" by auto\n      moreover have \n        \"{\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t\\<in>(?V\\<rtr>s)\\<sad>?V} \\<subseteq> ({\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t\\<in>(?V\\<rtr>s)\\<sad>?V}\\<union>({x}\\<times>U))\" \n        by auto\n      moreover from R unif GG have \n        \"({\\<langle>s,t\\<rangle> \\<in> G\\<times>G. t \\<in> (?V\\<rtr>s)\\<sad>?V}\\<union>({x}\\<times>U)) \\<in> roelckeUniformity\" by auto\n      ultimately have \"\\<exists>V\\<in>roelckeUniformity. V``{x} = U\" by auto\n      then have \"U \\<in> {V `` {x} . V \\<in> roelckeUniformity}\" by auto\n      with xg fun have \"U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G} ` x\" \n        using apply_equality by auto\n    } hence \"\\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G} ` x\" by auto\n    with op have \"U:{U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G}`(x)}\" \n      by auto\n  } then have \"T \\<subseteq> {U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G}`(x)}\" \n    by auto\n  ultimately have \n    \"{U \\<in> Pow(G). \\<forall>x\\<in>U. U \\<in> {\\<langle>t, {V `` {t} . V \\<in> roelckeUniformity}\\<rangle> . t \\<in> G}`(x)} = T\" by auto\n  then show ?thesis using uniftop_def_alt by simp\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1916
    },
    "1725": {
        "type": "theorem",
        "text": "text\\<open>The inverse map is uniformly continuous in the Roelcke uniformity\\<close>\n",
        "assumes": "",
        "using": [
            "groupAssum",
            "group0_2_T2",
            "roelcke_uniformity",
            "exists_sym_zerohood",
            "interval_add(4)",
            "lrtrans_in_group_add(2)",
            "elements_in_rtrans",
            "lrtrans_image(2)",
            "st(2)",
            "group_op_closed_add",
            "group_oper_assoc",
            "group_inv_of_two",
            "group_op_closed",
            "ginv_image_add(2)",
            "inverse_in_group",
            "prodFunctionApp",
            "st(2,3)",
            "prodFunction",
            "func1_1_L5A",
            "vimage_iff",
            "func1_1_L6A",
            "IsUniformlyCont_def"
        ],
        "statement": "theorem (in topgroup) inv_uniform_roelcke:\n  shows \n    \"GroupInv(G,f) {is uniformly continuous between} roelckeUniformity {and} roelckeUniformity\" \n",
        "proof": "proof -\n  let ?P = \"ProdFunction(GroupInv(G,f), GroupInv(G,f))\"\n  have L: \"GroupInv(G,f):G\\<rightarrow>G\" and R:\"roelckeUniformity {is a uniformity on} G\" \n    using groupAssum group0_2_T2 roelcke_uniformity by auto\n  have \"\\<forall>V \\<in> roelckeUniformity. ?P-``(V) \\<in> roelckeUniformity\"\n  proof\n    fix V assume v:\"V\\<in> roelckeUniformity\"\n    then obtain U where \"U \\<in> \\<N>\\<^sub>0\" and \"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> U \\<rtr> s \\<sad> U} \\<subseteq> V\"\n      unfolding roelckeUniformity_def by auto\n    with \\<open>V \\<in> roelckeUniformity\\<close> have \n      as:\"V \\<subseteq> G \\<times> G\" \"U \\<in> \\<N>\\<^sub>0\" \"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> U \\<rtr> s \\<sad> U} \\<subseteq> V\"\n      unfolding roelckeUniformity_def by auto\n    from as(2) obtain W where w:\"W \\<in> \\<N>\\<^sub>0\" \"W \\<subseteq> U\" \"(\\<sm>W) = W\" using exists_sym_zerohood by blast\n    from w(1) have wg:\"W\\<subseteq>G\" by auto\n    {\n      fix z assume z:\"z \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> W \\<rtr> s \\<sad> W}\"\n      then obtain s t where st:\"z=\\<langle>s,t\\<rangle>\" \"s\\<in>G\" \"t\\<in>G\" by auto\n      from st(1) z have st2: \"t \\<in> W \\<rtr> s \\<sad> W\" by auto\n      with \\<open>W \\<in> \\<N>\\<^sub>0\\<close> st(2) obtain u v where uv:\"t=u\\<ra>v\" \"u\\<in>W\\<rtr>s\" \"v\\<in>W\" \n        using interval_add(4) lrtrans_in_group_add(2)  by auto\n      from \\<open>W\\<subseteq>G\\<close> \\<open>s\\<in>G\\<close> \\<open>u\\<in>W\\<rtr>s\\<close> obtain q where q:\"q\\<in>W\" \"u=q\\<ra>s\" using elements_in_rtrans \n        by blast\n      from w(2) as(2) q st(2) have \"u\\<in>U\\<rtr>s\" using lrtrans_image(2) by auto\n      with w(2) uv(1,3) as(2) st(2) have \"t\\<in>U \\<rtr> s \\<sad> U\" using interval_add(4)\n        lrtrans_in_group_add(2) by auto\n      with st have \"z \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> U \\<rtr> s \\<sad> U}\" by auto\n    }\n    then have \n      sub:\"{\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> W \\<rtr> s \\<sad> W} \\<subseteq> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> U \\<rtr> s \\<sad> U}\" \n      by auto\n    { \n      fix z assume z:\"z \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> W \\<rtr> s \\<sad> W}\"\n      then obtain s t where st:\"z=\\<langle>s,t\\<rangle>\" \"s\\<in>G\" \"t\\<in>G\" by auto\n      from st(1) z have st2: \"t \\<in> W \\<rtr> s \\<sad> W\" by auto\n      with \\<open>W \\<in> \\<N>\\<^sub>0\\<close> obtain u v where uv:\"t=u\\<ra>v\" \"u\\<in>W\\<rtr>s\" \"v\\<in>W\" \n        using interval_add(4) lrtrans_in_group_add(2) st(2) by auto\n      from \\<open>W\\<subseteq>G\\<close> \\<open>s\\<in>G\\<close> \\<open>u\\<in>W\\<rtr>s\\<close> obtain q where q:\"q\\<in>W\" \"u=q\\<ra>s\" using elements_in_rtrans \n        by blast            \n      from \\<open>W\\<subseteq>G\\<close> \\<open>q\\<in>W\\<close> \\<open>v\\<in>W\\<close> have \"q\\<in>G\" \"v\\<in>G\" by auto\n      with \\<open>q\\<in>G\\<close> \\<open>v\\<in>G\\<close> \\<open>u=q\\<ra>s\\<close> st(2) uv(1) q(2) have \"t=q\\<ra>(s\\<ra>v)\"\n        using group_op_closed_add group_oper_assoc by auto\n      with st(2) \\<open>q\\<in>G\\<close> \\<open>v\\<in>G\\<close> have minust:\"(\\<rm>t) = (\\<rm>v)\\<ra>(\\<rm>s)\\<ra>(\\<rm>q)\" \n        using group_inv_of_two group_op_closed group_inv_of_two by auto\n      from q(1) wg have \"(\\<rm>q)\\<in>\\<sm>W\" using ginv_image_add(2) by auto\n      with w(3) have minusq:\"(\\<rm>q)\\<in>W\" by auto\n      from uv(3) wg have \"(\\<rm>v)\\<in>\\<sm>W\" using ginv_image_add(2) by auto\n      with w(3) have minusv:\"(\\<rm>v)\\<in>W\" by auto\n      with st(2) wg have \"(\\<rm>v)\\<ra>(\\<rm>s) \\<in> W\\<rtr>(\\<rm>s)\"\n        using lrtrans_image(2) inverse_in_group by auto\n      with minust minusq st(2) wg have \"(\\<rm>t)\\<in>(W\\<rtr>(\\<rm>s))\\<sad>W\" \n        using interval_add(4) inverse_in_group lrtrans_in_group_add(2) by auto\n      moreover\n      from st groupAssum have \"?P`(z) = \\<langle>GroupInv(G,f)`(s), GroupInv(G,f)`(t)\\<rangle>\"\n        using prodFunctionApp group0_2_T2 by blast\n      with st(2,3) have \"?P`(z) = \\<langle>\\<rm>s,\\<rm>t\\<rangle>\" by auto\n      ultimately have \"?P`(z) \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> W \\<rtr> s \\<sad> W}\"\n        using st(2,3) inverse_in_group by auto\n      with sub have \"?P`(z) \\<in> {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> U \\<rtr> s \\<sad> U}\" by force\n      with as(3) have \"?P`(z) \\<in> V\" by force\n      with z L have \"z \\<in> ?P-``(V)\" using prodFunction func1_1_L5A vimage_iff\n        by blast\n    }\n    with w(1) have \"\\<exists>U\\<in>\\<N>\\<^sub>0. {\\<langle>s,t\\<rangle> \\<in> G \\<times> G . t \\<in> U \\<rtr> s \\<sad> U} \\<subseteq> ?P-``(V)\" \n      by blast\n    with L show \"?P-``(V) \\<in> roelckeUniformity\"\n      unfolding roelckeUniformity_def using prodFunction func1_1_L6A by blast\n  qed\n  with L R show ?thesis using IsUniformlyCont_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1917
    },
    "1726": {
        "type": "definition",
        "text": "text\\<open>This way we arrive at the following definition of a predicate that\n  states that pair of sets is a topological group.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAtopologicalGroup(T,f) \\<equiv> (T {is a topology}) \\<and> IsAgroup(\\<Union>T,f) \\<and>\n  IsContinuous(ProductTopology(T,T),T,f) \\<and> \n  IsContinuous(T,T,GroupInv(\\<Union>T,f))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1918
    },
    "1727": {
        "type": "lemma",
        "text": "text\\<open>If a pair of sets $(T,f)$ forms a topological group, then\n all theorems proven in the \\<open>topgroup\\<close> context are valid as applied to \n $(T,f)$.\\<close>\n",
        "assumes": "assumes \"IsAtopologicalGroup(T,f)\"\n  ",
        "using": [
            "assms",
            "IsAtopologicalGroup_def",
            "topgroup_def",
            "topgroup_axioms.intro",
            "topology0_def"
        ],
        "statement": "lemma topGroupLocale: assumes \"IsAtopologicalGroup(T,f)\"\n  shows \"topgroup(T,f)\"\n  ",
        "proof": "using assms IsAtopologicalGroup_def topgroup_def \n    topgroup_axioms.intro topology0_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1920
    },
    "1728": {
        "type": "lemma",
        "text": "text\\<open>We can use the \\<open>group0\\<close> locale in the context of \\<open>topgroup\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "Ggroup",
            "group0_def"
        ],
        "statement": "lemma (in topgroup) group0_valid_in_tgroup: shows \"group0(G,f)\"\n  ",
        "proof": "using Ggroup group0_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1921
    },
    "1729": {
        "type": "lemma",
        "text": "text\\<open>We can use \\<open>semigr0\\<close> locale in the context of \\<open>topgroup\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "Ggroup",
            "IsAgroup_def",
            "IsAmonoid_def",
            "semigr0_def"
        ],
        "statement": "lemma (in topgroup) semigr0_valid_in_tgroup: shows \"semigr0(G,f)\"\n  ",
        "proof": "using Ggroup IsAgroup_def IsAmonoid_def semigr0_def by simp \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1922
    },
    "1730": {
        "type": "lemma",
        "text": "text\\<open>We can use the \\<open>prod_top_spaces0\\<close> locale in the context of \\<open>topgroup\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "prod_top_spaces0_def"
        ],
        "statement": "lemma (in topgroup) prod_top_spaces0_valid: shows \"prod_top_spaces0(T,T,T)\"\n  ",
        "proof": "using topSpaceAssum prod_top_spaces0_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1923
    },
    "1731": {
        "type": "lemma",
        "text": "text\\<open>Negative of a group element is in group.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "assms",
            "inverse_in_group"
        ],
        "statement": "lemma (in topgroup) neg_in_tgroup: assumes \"g\\<in>G\" shows \"(\\<rm>g) \\<in> G\"\n  ",
        "proof": "using assms inverse_in_group by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1924
    },
    "1732": {
        "type": "lemma",
        "text": "text\\<open>Zero is in the group.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L2"
        ],
        "statement": "lemma (in topgroup) zero_in_tgroup: shows \"\\<zero>\\<in>G\"\n  ",
        "proof": "using group0_2_L2 by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1926
    },
    "1733": {
        "type": "lemma",
        "text": "text\\<open> Another lemma about canceling with two group elements written in additive notation \\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\" \n  ",
        "using": [
            "assms",
            "inv_cancel_two"
        ],
        "statement": "lemma (in topgroup) inv_cancel_two_add: \n  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\" \n  shows \n    \"x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>2 = x\\<^sub>1\"\n    \"x\\<^sub>1\\<ra>x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>2) = x\\<^sub>1\"\n    \"(\\<rm>x\\<^sub>1)\\<ra>(x\\<^sub>1\\<ra>x\\<^sub>2) = x\\<^sub>2\"\n    \"x\\<^sub>1\\<ra>((\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2) = x\\<^sub>2\"\n  ",
        "proof": "using assms inv_cancel_two by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1927
    },
    "1734": {
        "type": "lemma",
        "text": "text\\<open>Useful identities proven in the \\<open>Group_ZF\\<close> theory, rewritten here in additive notation.\n  Note since the group operation notation is left associative we don't really need the first set\n  of parentheses in some cases.\\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\"\n  ",
        "using": [
            "group0_2_L14A(1)",
            "group0_2_L14A(2)",
            "cancel_middle(1)",
            "cancel_middle(2)",
            "cancel_middle(3)"
        ],
        "statement": "lemma (in topgroup) cancel_middle_add: assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\"\n  shows \n    \"(x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2))\\<ra>(x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3)) = x\\<^sub>1\\<ra> (\\<rm>x\\<^sub>3)\"\n    \"((\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2)\\<ra>((\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3) = (\\<rm>x\\<^sub>1)\\<ra> x\\<^sub>3\" \n    \"(\\<rm> (x\\<^sub>1\\<ra>x\\<^sub>2)) \\<ra> (x\\<^sub>1\\<ra>x\\<^sub>3) = (\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3\"\n    \"(x\\<^sub>1\\<ra>x\\<^sub>2) \\<ra> (\\<rm>(x\\<^sub>3\\<ra>x\\<^sub>2)) =x\\<^sub>1\\<ra> (\\<rm>x\\<^sub>3)\"\n    \"(\\<rm>x\\<^sub>1) \\<ra> (x\\<^sub>1\\<ra>x\\<^sub>2\\<ra>x\\<^sub>3) \\<ra> (\\<rm>x\\<^sub>3) = x\\<^sub>2\"\n",
        "proof": "proof - \n  from assms have \"x\\<^sub>1\\<ra> (\\<rm>x\\<^sub>3) = (x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2))\\<ra>(x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3))\"\n    using group0_2_L14A(1) by blast\n  thus \"(x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2))\\<ra>(x\\<^sub>2\\<ra>(\\<rm>x\\<^sub>3)) = x\\<^sub>1\\<ra> (\\<rm>x\\<^sub>3)\" by simp\n  from assms have \"(\\<rm>x\\<^sub>1)\\<ra> x\\<^sub>3 = ((\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2)\\<ra>((\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3)\"\n    using group0_2_L14A(2) by blast\n  thus \"((\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2)\\<ra>((\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3) = (\\<rm>x\\<^sub>1)\\<ra> x\\<^sub>3\" by simp\n  from assms show \"(\\<rm> (x\\<^sub>1\\<ra>x\\<^sub>2)) \\<ra> (x\\<^sub>1\\<ra>x\\<^sub>3) = (\\<rm>x\\<^sub>2)\\<ra>x\\<^sub>3\"\n    using cancel_middle(1) by simp\n  from assms show \"(x\\<^sub>1\\<ra>x\\<^sub>2) \\<ra> (\\<rm>(x\\<^sub>3\\<ra>x\\<^sub>2)) =x\\<^sub>1\\<ra> (\\<rm>x\\<^sub>3)\"\n    using cancel_middle(2) by simp\n  from assms show \"(\\<rm>x\\<^sub>1) \\<ra> (x\\<^sub>1\\<ra>x\\<^sub>2\\<ra>x\\<^sub>3) \\<ra> (\\<rm>x\\<^sub>3) = x\\<^sub>2\"\n    using cancel_middle(3) by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1928
    },
    "1735": {
        "type": "lemma",
        "text": "text\\<open> We can cancel an element on the right from both sides of an equation. \\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"x\\<^sub>1\\<ra>x\\<^sub>2 = x\\<^sub>3\\<ra>x\\<^sub>2\" \n  ",
        "using": [
            "assms",
            "cancel_right"
        ],
        "statement": "lemma (in topgroup) cancel_right_add: \n  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"x\\<^sub>1\\<ra>x\\<^sub>2 = x\\<^sub>3\\<ra>x\\<^sub>2\" \n  shows \"x\\<^sub>1 = x\\<^sub>3\"\n  ",
        "proof": "using assms cancel_right by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1929
    },
    "1736": {
        "type": "lemma",
        "text": "text\\<open> We can cancel an element on the left from both sides of an equation. \\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"x\\<^sub>1\\<ra>x\\<^sub>2 = x\\<^sub>1\\<ra>x\\<^sub>3\" \n  ",
        "using": [
            "assms",
            "cancel_left"
        ],
        "statement": "lemma (in topgroup) cancel_left_add: \n  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"x\\<^sub>1\\<ra>x\\<^sub>2 = x\\<^sub>1\\<ra>x\\<^sub>3\" \n  shows \"x\\<^sub>2 = x\\<^sub>3\"\n  ",
        "proof": "using assms cancel_left by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1930
    },
    "1737": {
        "type": "lemma",
        "text": "text\\<open>We can put an element on the other side of an equation.\\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\" \"x\\<^sub>3 = x\\<^sub>1\\<ra>x\\<^sub>2\"\n  ",
        "using": [
            "assms",
            "group0_2_L18"
        ],
        "statement": "lemma (in topgroup) put_on_the_other_side: \n  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\" \"x\\<^sub>3 = x\\<^sub>1\\<ra>x\\<^sub>2\"\n  shows \"x\\<^sub>3\\<ra>(\\<rm>x\\<^sub>2) = x\\<^sub>1\" and \"(\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>3 = x\\<^sub>2\" \n  ",
        "proof": "using assms group0_2_L18 by auto \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1931
    },
    "1738": {
        "type": "lemma",
        "text": "text\\<open>A simple equation from lemma \\<open>simple_equation0\\<close> in \\<open>Group_ZF\\<close> in additive notation \\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2) = (\\<rm>x\\<^sub>3)\"\n  ",
        "using": [
            "assms",
            "simple_equation0"
        ],
        "statement": "lemma (in topgroup) simple_equation0_add: \n  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"x\\<^sub>1\\<ra>(\\<rm>x\\<^sub>2) = (\\<rm>x\\<^sub>3)\"\n  shows \"x\\<^sub>3 = x\\<^sub>2 \\<ra> (\\<rm>x\\<^sub>1)\"\n  ",
        "proof": "using assms simple_equation0 by blast\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1932
    },
    "1739": {
        "type": "lemma",
        "text": "text\\<open>A simple equation from lemma \\<open>simple_equation1\\<close> in \\<open>Group_ZF\\<close> in additive notation \\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"(\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2 = (\\<rm>x\\<^sub>3)\"\n  ",
        "using": [
            "assms",
            "simple_equation1"
        ],
        "statement": "lemma (in topgroup) simple_equation1_add: \n  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"  \"x\\<^sub>3 \\<in> G\" \"(\\<rm>x\\<^sub>1)\\<ra>x\\<^sub>2 = (\\<rm>x\\<^sub>3)\"\n  shows \"x\\<^sub>3 = (\\<rm>x\\<^sub>2) \\<ra> x\\<^sub>1\"\n  ",
        "proof": "using assms simple_equation1 by blast\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1933
    },
    "1740": {
        "type": "lemma",
        "text": "text\\<open>The set comprehension form of negative of a set. The proof uses the \\<open>ginv_image\\<close> lemma from \n  \\<open>Group_ZF\\<close> theory which states the same thing in multiplicative notation. \\<close>\n",
        "assumes": "assumes \"V\\<subseteq>G\" \n  ",
        "using": [
            "assms",
            "ginv_image"
        ],
        "statement": "lemma (in topgroup) ginv_image_add: assumes \"V\\<subseteq>G\" \n  shows \"(\\<sm>V)\\<subseteq>G\" and \"(\\<sm>V) = {\\<rm>x. x \\<in> V}\" \n  ",
        "proof": "using assms ginv_image by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1934
    },
    "1741": {
        "type": "lemma",
        "text": "text\\<open> The additive notation version of \\<open>ginv_image_el\\<close> lemma from \\<open>Group_ZF\\<close> theory \\<close>\n",
        "assumes": "assumes \"V\\<subseteq>G\" \"x \\<in> (\\<sm>V)\"\n  ",
        "using": [
            "assms",
            "ginv_image_el"
        ],
        "statement": "lemma (in topgroup) ginv_image_el_add: assumes \"V\\<subseteq>G\" \"x \\<in> (\\<sm>V)\"\n  shows \"(\\<rm>x) \\<in> V\"\n  ",
        "proof": "using assms ginv_image_el by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1935
    },
    "1742": {
        "type": "lemma",
        "text": "text\\<open>Of course the product topology is a topology (on $G\\times G$).\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "Top_1_4_T1"
        ],
        "statement": "lemma (in topgroup) prod_top_on_G:\n  shows \"\\<tau> {is a topology}\" and \"\\<Union>\\<tau> = G\\<times>G\"\n  ",
        "proof": "using topSpaceAssum Top_1_4_T1 by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1936
    },
    "1743": {
        "type": "lemma",
        "text": "text\\<open>A subgroup of a topological group is a topological group \n  with relative topology\n  and restricted operation. Relative topology is the same\n  as \\<open>T {restricted to} H\\<close>\n  which is defined to be $\\{V \\cap H: V\\in T\\}$ in \\<open>ZF1\\<close> theory.\\<close>\n",
        "assumes": "assumes A1: \"IsAsubgroup(H,f)\"\n  ",
        "using": [
            "union_restrict",
            "group0_3_L2",
            "Top_1_L4",
            "IsAsubgroup_def",
            "topSpaceAssum",
            "prod_top_on_G",
            "topgroup_f_binop",
            "two_top_spaces0_def",
            "fcon",
            "two_top_spaces0.restr_restr_image_cont",
            "prod_top_restr_comm",
            "image_subgr_op",
            "Ggroup",
            "group0_2_T2",
            "inv_cont",
            "restr_inv_onto",
            "group0_3_T1"
        ],
        "statement": "lemma (in topgroup) top_subgroup: assumes A1: \"IsAsubgroup(H,f)\"\n  shows \"IsAtopologicalGroup(T {restricted to} H,restrict(f,H\\<times>H))\"\n",
        "proof": "proof -\n  let ?\\<tau>\\<^sub>0 = \"T {restricted to} H\"\n  let ?f\\<^sub>H = \"restrict(f,H\\<times>H)\"\n  have \"\\<Union>?\\<tau>\\<^sub>0 = G \\<inter> H\" using union_restrict by simp\n  also from A1 have \"\\<dots> = H\" \n    using group0_3_L2 by blast\n  finally have \"\\<Union>?\\<tau>\\<^sub>0 = H\" by simp\n  have \"?\\<tau>\\<^sub>0 {is a topology}\" using Top_1_L4 by simp\n  moreover from A1 \\<open>\\<Union>?\\<tau>\\<^sub>0 = H\\<close> have \"IsAgroup(\\<Union>?\\<tau>\\<^sub>0,?f\\<^sub>H)\"\n    using IsAsubgroup_def by simp\n  moreover have \"IsContinuous(ProductTopology(?\\<tau>\\<^sub>0,?\\<tau>\\<^sub>0),?\\<tau>\\<^sub>0,?f\\<^sub>H)\"\n  proof -\n    have \"two_top_spaces0(\\<tau>, T,f)\"\n      using topSpaceAssum prod_top_on_G topgroup_f_binop prod_top_on_G\n\ttwo_top_spaces0_def by simp\n    moreover \n    from A1 have \"H \\<subseteq> G\" using group0_3_L2 by simp\n    then have \"H\\<times>H \\<subseteq> \\<Union>\\<tau>\" using prod_top_on_G by auto\n    moreover have \"IsContinuous(\\<tau>,T,f)\" using fcon by simp\n    ultimately have \n      \"IsContinuous(\\<tau> {restricted to} H\\<times>H, T {restricted to} ?f\\<^sub>H``(H\\<times>H),?f\\<^sub>H)\" using two_top_spaces0.restr_restr_image_cont\n      by simp\n    moreover have\n      \"ProductTopology(?\\<tau>\\<^sub>0,?\\<tau>\\<^sub>0) = \\<tau> {restricted to} H\\<times>H\" using topSpaceAssum prod_top_restr_comm\n      by simp\n    moreover from A1 have \"?f\\<^sub>H``(H\\<times>H) = H\" using image_subgr_op\n      by simp\n    ultimately show ?thesis by simp\n  qed \n  moreover have \"IsContinuous(?\\<tau>\\<^sub>0,?\\<tau>\\<^sub>0,GroupInv(\\<Union>?\\<tau>\\<^sub>0,?f\\<^sub>H))\"\n  proof -\n    let ?g = \"restrict(GroupInv(G,f),H)\"\n    have \"GroupInv(G,f) : G \\<rightarrow> G\"\n      using Ggroup group0_2_T2 by simp\n    then have \"two_top_spaces0(T,T,GroupInv(G,f))\"\n      using topSpaceAssum two_top_spaces0_def by simp\n    moreover from A1 have \"H \\<subseteq> \\<Union>T\" using group0_3_L2 by simp\n    ultimately have \n      \"IsContinuous(?\\<tau>\\<^sub>0,T {restricted to} ?g``(H),?g)\"\n      using inv_cont two_top_spaces0.restr_restr_image_cont\n      by simp\n    moreover from A1 have \"?g``(H) = H\" using restr_inv_onto by simp  \n    moreover\n    from A1 have \"GroupInv(H,?f\\<^sub>H) = ?g\" using group0_3_T1 by simp\n    with \\<open>\\<Union>?\\<tau>\\<^sub>0 = H\\<close> have \"?g = GroupInv(\\<Union>?\\<tau>\\<^sub>0,?f\\<^sub>H)\" by simp\n    ultimately show ?thesis by simp\n  qed\n  ultimately show ?thesis unfolding IsAtopologicalGroup_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1938
    },
    "1744": {
        "type": "lemma",
        "text": "text\\<open>Different ways of looking at adding sets.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" ",
        "using": [
            "topgroup_f_binop",
            "lift_subsets_explained",
            "image_ltrans_union"
        ],
        "statement": "lemma (in topgroup) interval_add: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" shows\n  \"A\\<sad>B \\<subseteq> G\" \n  \"A\\<sad>B = f``(A\\<times>B)\"  \n  \"A\\<sad>B = (\\<Union>x\\<in>A. x\\<ltr>B)\"\n  \"A\\<sad>B = {x\\<ra>y. \\<langle>x,y\\<rangle> \\<in> A\\<times>B}\" \n",
        "proof": "proof -\n  from assms show \"A\\<sad>B \\<subseteq> G\" and \"A\\<sad>B = f``(A\\<times>B)\" and \"A\\<sad>B = {x\\<ra>y. \\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n    using topgroup_f_binop lift_subsets_explained by auto\n  from assms show \"A\\<sad>B = (\\<Union>x\\<in>A. x\\<ltr>B)\" using image_ltrans_union by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1939
    },
    "1745": {
        "type": "lemma",
        "text": "text\\<open> If the neutral element is in a set, then it is in the sum of the sets. \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"\\<zero>\\<in>A\"\n  ",
        "using": [
            "interval_add(4)",
            "group0_2_L2"
        ],
        "statement": "lemma (in topgroup) interval_add_zero: assumes \"A\\<subseteq>G\" \"\\<zero>\\<in>A\"\n  shows \"\\<zero> \\<in> A\\<sad>A\"\n",
        "proof": "proof -\n  from assms have \"\\<zero>\\<ra>\\<zero> \\<in> A\\<sad>A\" using interval_add(4) by auto\n  then show \"\\<zero> \\<in> A\\<sad>A\" using group0_2_L2 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1940
    },
    "1746": {
        "type": "lemma",
        "text": "text\\<open>Some lemmas from \\<open>Group_ZF_1\\<close> about images of set by translations \n  written in additive notation\\<close>\n",
        "assumes": "assumes \"V\\<subseteq>G\" \"x\\<in>G\"\n  ",
        "using": [
            "assms",
            "ltrans_image",
            "rtrans_image"
        ],
        "statement": "lemma (in topgroup) lrtrans_image: assumes \"V\\<subseteq>G\" \"x\\<in>G\"\n  shows \n    \"x\\<ltr>V = {x\\<ra>v. v\\<in>V}\" \n    \"V\\<rtr>x = {v\\<ra>x. v\\<in>V}\"\n  ",
        "proof": "using assms ltrans_image rtrans_image by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1941
    },
    "1747": {
        "type": "lemma",
        "text": "text\\<open> Right and left translations of a set are subsets of the group. \n  This is of course typically applied to the subsets of the group, but formally we don't\n  need to assume that. \\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \n  ",
        "using": [
            "assms",
            "lrtrans_in_group"
        ],
        "statement": "lemma (in topgroup) lrtrans_in_group_add: assumes \"x\\<in>G\" \n  shows  \"x\\<ltr>V \\<subseteq> G\" and \"V\\<rtr>x \\<subseteq>G\"\n  ",
        "proof": "using assms lrtrans_in_group by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1942
    },
    "1748": {
        "type": "corollary",
        "text": "text\\<open> A corollary from \\<open>interval_add\\<close> \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\"\n  \"t \\<in> A\\<sad>B\" ",
        "using": [
            "assms",
            "interval_add(4)"
        ],
        "statement": "corollary (in topgroup) elements_in_set_sum: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\"\n  \"t \\<in> A\\<sad>B\" shows \"\\<exists>s\\<in>A. \\<exists>q\\<in>B. t=s\\<ra>q\"\n  ",
        "proof": "using assms interval_add(4) by auto \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1943
    },
    "1749": {
        "type": "corollary",
        "text": "text\\<open> A corollary from \\<open> lrtrans_image\\<close> \\<close> \n",
        "assumes": "assumes \"B\\<subseteq>G\" \"g\\<in>G\" \"t \\<in> g\\<ltr>B\" \n  ",
        "using": [
            "assms",
            "lrtrans_image(1)"
        ],
        "statement": "corollary (in topgroup) elements_in_ltrans: \n  assumes \"B\\<subseteq>G\" \"g\\<in>G\" \"t \\<in> g\\<ltr>B\" \n  shows \"\\<exists>q\\<in>B. t=g\\<ra>q\"\n  ",
        "proof": "using assms lrtrans_image(1) by simp \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1944
    },
    "1750": {
        "type": "corollary",
        "text": "text\\<open> Another corollary of \\<open>lrtrans_image\\<close> \\<close>\n",
        "assumes": "assumes \"B\\<subseteq>G\" \"g\\<in>G\"  \"t \\<in> B\\<rtr>g\" ",
        "using": [
            "assms",
            "lrtrans_image(2)"
        ],
        "statement": "corollary (in topgroup) elements_in_rtrans: \n  assumes \"B\\<subseteq>G\" \"g\\<in>G\"  \"t \\<in> B\\<rtr>g\" shows \"\\<exists>q\\<in>B. t=q\\<ra>g\"\n  ",
        "proof": "using assms lrtrans_image(2) by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1945
    },
    "1751": {
        "type": "corollary",
        "text": "text\\<open>Another corollary from \\<open>interval_add\\<close> \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"t=s\\<ra>q\" \"s\\<in>A\" \"q\\<in>B\"\n  ",
        "using": [
            "assms",
            "interval_add"
        ],
        "statement": "corollary (in topgroup) elements_in_set_sum_inv: \n  assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"t=s\\<ra>q\" \"s\\<in>A\" \"q\\<in>B\"\n  shows \"t \\<in> A\\<sad>B\"\n  ",
        "proof": "using assms interval_add by auto \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1946
    },
    "1752": {
        "type": "corollary",
        "text": "text\\<open>Another corollary of \\<open>lrtrans_image\\<close> \\<close>\n",
        "assumes": "assumes \"B\\<subseteq>G\" \"g\\<in>G\" \"q\\<in>B\" \"t=g\\<ra>q\"\n  ",
        "using": [
            "assms",
            "lrtrans_image(1)"
        ],
        "statement": "corollary (in topgroup) elements_in_ltrans_inv: assumes \"B\\<subseteq>G\" \"g\\<in>G\" \"q\\<in>B\" \"t=g\\<ra>q\"\n  shows \"t \\<in> g\\<ltr>B\"\n  ",
        "proof": "using assms lrtrans_image(1) by auto \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1947
    },
    "1753": {
        "type": "lemma",
        "text": "text\\<open>Another corollary of \\<open>rtrans_image_add\\<close> \\<close>\n",
        "assumes": "assumes \"B\\<subseteq>G\" \"g\\<in>G\" \"q\\<in>B\" \"t=q\\<ra>g\"\n  ",
        "using": [
            "assms",
            "lrtrans_image(2)"
        ],
        "statement": "lemma (in topgroup) elements_in_rtrans_inv:\n  assumes \"B\\<subseteq>G\" \"g\\<in>G\" \"q\\<in>B\" \"t=q\\<ra>g\"\n  shows \"t \\<in> B\\<rtr>g\"\n  ",
        "proof": "using assms lrtrans_image(2) by auto \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1948
    },
    "1754": {
        "type": "lemma",
        "text": "text\\<open>Right and left translations are continuous.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "assms",
            "trans_eq_section",
            "topgroup_f_binop",
            "fcon",
            "prod_top_spaces0_valid",
            "prod_top_spaces0.fix_1st_var_cont",
            "prod_top_spaces0.fix_2nd_var_cont"
        ],
        "statement": "lemma (in topgroup) trans_cont: assumes \"g\\<in>G\" shows\n  \"IsContinuous(T,T,RightTranslation(G,f,g))\" and\n  \"IsContinuous(T,T,LeftTranslation(G,f,g))\"\n",
        "proof": "using assms trans_eq_section topgroup_f_binop fcon prod_top_spaces0_valid \n  prod_top_spaces0.fix_1st_var_cont prod_top_spaces0.fix_2nd_var_cont\n  by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1949
    },
    "1755": {
        "type": "lemma",
        "text": "text\\<open>Left and right translations of an open set are open.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" and \"V\\<in>T\"\n  ",
        "using": [
            "assms",
            "neg_in_tgroup",
            "trans_cont",
            "IsContinuous_def",
            "trans_image_vimage"
        ],
        "statement": "lemma (in topgroup) open_tr_open: assumes \"g\\<in>G\" and \"V\\<in>T\"\n  shows \"g\\<ltr>V \\<in> T\" and  \"V\\<rtr>g \\<in> T\"\n  ",
        "proof": "using assms neg_in_tgroup trans_cont IsContinuous_def trans_image_vimage by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1950
    },
    "1756": {
        "type": "lemma",
        "text": "text\\<open>Right and left translations are homeomorphisms.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" ",
        "using": [
            "assms",
            "trans_bij",
            "trans_cont",
            "open_tr_open",
            "bij_cont_open_homeo"
        ],
        "statement": "lemma (in topgroup) tr_homeo: assumes \"g\\<in>G\" shows\n  \"IsAhomeomorphism(T,T,RightTranslation(G,f,g))\" and\n  \"IsAhomeomorphism(T,T,LeftTranslation(G,f,g))\"\n  ",
        "proof": "using assms trans_bij trans_cont open_tr_open bij_cont_open_homeo \n  by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1951
    },
    "1757": {
        "type": "lemma",
        "text": "text\\<open>Left translations preserve interior.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" and A2: \"A\\<subseteq>G\" \n  ",
        "using": [
            "tr_homeo",
            "int_top_invariant"
        ],
        "statement": "lemma (in topgroup) ltrans_interior: assumes A1: \"g\\<in>G\" and A2: \"A\\<subseteq>G\" \n  shows \"g \\<ltr> int(A) = int(g\\<ltr>A)\"\n",
        "proof": "proof -\n  from assms have \"A \\<subseteq> \\<Union>T\" and \"IsAhomeomorphism(T,T,LeftTranslation(G,f,g))\" using tr_homeo \n    by auto\n  then show ?thesis using int_top_invariant by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1952
    },
    "1758": {
        "type": "lemma",
        "text": "text\\<open>Right translations preserve interior.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" and A2: \"A\\<subseteq>G\" \n  ",
        "using": [
            "tr_homeo",
            "int_top_invariant"
        ],
        "statement": "lemma (in topgroup) rtrans_interior: assumes A1: \"g\\<in>G\" and A2: \"A\\<subseteq>G\" \n  shows \"int(A) \\<rtr> g = int(A\\<rtr>g)\"\n",
        "proof": "proof -\n  from assms have \"A \\<subseteq> \\<Union>T\" and \"IsAhomeomorphism(T,T,RightTranslation(G,f,g))\" using tr_homeo \n    by auto\n  then show ?thesis using int_top_invariant by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1953
    },
    "1759": {
        "type": "lemma",
        "text": "text\\<open>Translating by an inverse and then by an element cancels out.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" and \"A\\<subseteq>G\"\n  ",
        "using": [
            "assms",
            "neg_in_tgroup",
            "trans_comp_image",
            "group0_2_L6",
            "trans_neutral",
            "image_id_same"
        ],
        "statement": "lemma (in topgroup) trans_inverse_elem: assumes \"g\\<in>G\" and \"A\\<subseteq>G\"\n  shows \"g\\<ltr>((\\<rm>g)\\<ltr>A) = A\"\n  ",
        "proof": "using assms neg_in_tgroup trans_comp_image group0_2_L6 trans_neutral image_id_same \n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1954
    },
    "1760": {
        "type": "lemma",
        "text": "text\\<open>Inverse of an open set is open.\\<close>\n",
        "assumes": "assumes \"V\\<in>T\" ",
        "using": [
            "assms",
            "inv_image_vimage",
            "inv_cont",
            "IsContinuous_def"
        ],
        "statement": "lemma (in topgroup) open_inv_open: assumes \"V\\<in>T\" shows \"(\\<sm>V) \\<in> T\"\n  ",
        "proof": "using assms inv_image_vimage inv_cont IsContinuous_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1955
    },
    "1761": {
        "type": "lemma",
        "text": "text\\<open>Inverse is a homeomorphism.\\<close>\n",
        "assumes": "",
        "using": [
            "group_inv_bij",
            "inv_cont",
            "open_inv_open",
            "bij_cont_open_homeo"
        ],
        "statement": "lemma (in topgroup) inv_homeo: shows \"IsAhomeomorphism(T,T,GroupInv(G,f))\"\n  ",
        "proof": "using group_inv_bij inv_cont open_inv_open bij_cont_open_homeo by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1956
    },
    "1762": {
        "type": "lemma",
        "text": "text\\<open>Taking negative preserves interior.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> G\" \n  ",
        "using": [
            "assms",
            "inv_homeo",
            "int_top_invariant"
        ],
        "statement": "lemma (in topgroup) int_inv_inv_int: assumes \"A \\<subseteq> G\" \n  shows \"int(\\<sm>A) = \\<sm>(int(A))\"\n  ",
        "proof": "using assms inv_homeo int_top_invariant by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1957
    },
    "1763": {
        "type": "lemma",
        "text": "text\\<open>The whole space is a neighborhood of zero.\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L3",
            "zero_in_tgroup"
        ],
        "statement": "lemma (in topgroup) zneigh_not_empty: shows \"G \\<in> \\<N>\\<^sub>0\"\n  ",
        "proof": "using topSpaceAssum IsATopology_def Top_2_L3 zero_in_tgroup\n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1958
    },
    "1764": {
        "type": "lemma",
        "text": "text\\<open>Any element that belongs to a subset of the group belongs to that subset with the \n  interior of a neighborhood of zero added. \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"g\\<in>A\" \"H \\<in> \\<N>\\<^sub>0\"\n  ",
        "using": [
            "Top_2_L2",
            "elements_in_set_sum_inv",
            "group0_2_L2"
        ],
        "statement": "lemma (in topgroup) elem_in_int_sad: assumes \"A\\<subseteq>G\" \"g\\<in>A\" \"H \\<in> \\<N>\\<^sub>0\"\n  shows \"g \\<in> A\\<sad>int(H)\"\n",
        "proof": "proof -\n  from assms(3) have \"\\<zero> \\<in> int(H)\" and \"int(H) \\<subseteq> G\" using Top_2_L2 by auto\n  with assms(1,2) have \"g\\<ra>\\<zero> \\<in> A\\<sad>int(H)\" using elements_in_set_sum_inv\n    by simp\n  with assms(1,2) show ?thesis using group0_2_L2 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1959
    },
    "1765": {
        "type": "lemma",
        "text": "text\\<open>Any element belongs to the interior of any neighboorhood of zero\n  left translated by that element.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\" and \"H \\<in> \\<N>\\<^sub>0\"\n  ",
        "using": [
            "Top_2_L2",
            "neut_trans_elem",
            "ltrans_interior",
            "lrtrans_in_group_add(1)",
            "Top_2_L1",
            "elem_in_int_sad"
        ],
        "statement": "lemma (in topgroup) elem_in_int_ltrans:\n  assumes \"g\\<in>G\" and \"H \\<in> \\<N>\\<^sub>0\"\n  shows \"g \\<in> int(g\\<ltr>H)\" and \"g \\<in> int(g\\<ltr>H) \\<sad> int(H)\"\n",
        "proof": "proof -\n  from assms(2) have \"\\<zero> \\<in> int(H)\" and \"int(H) \\<subseteq> G\" using Top_2_L2 by auto\n  with assms(1) have \"g \\<in> g \\<ltr> int(H)\" using neut_trans_elem by simp\n  with assms show \"g \\<in> int(g\\<ltr>H)\" using ltrans_interior by simp\n  from assms(1) have \"int(g\\<ltr>H) \\<subseteq> G\" using lrtrans_in_group_add(1) Top_2_L1\n    by blast\n  with \\<open>g \\<in> int(g\\<ltr>H)\\<close> assms(2) show \"g \\<in> int(g\\<ltr>H) \\<sad> int(H)\" \n    using elem_in_int_sad by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1960
    },
    "1766": {
        "type": "lemma",
        "text": "text\\<open>Any element belongs to the interior of any neighboorhood of zero\n  right translated by that element.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" and A2: \"H \\<in> \\<N>\\<^sub>0\"\n  ",
        "using": [
            "Top_2_L2",
            "neut_trans_elem",
            "rtrans_interior",
            "lrtrans_in_group_add(2)",
            "Top_2_L1",
            "elem_in_int_sad"
        ],
        "statement": "lemma (in topgroup) elem_in_int_rtrans:\n  assumes A1: \"g\\<in>G\" and A2: \"H \\<in> \\<N>\\<^sub>0\"\n  shows \"g \\<in> int(H\\<rtr>g)\" and \"g \\<in> int(H\\<rtr>g) \\<sad> int(H)\"\n",
        "proof": "proof -\n  from A2 have \"\\<zero> \\<in> int(H)\" and \"int(H) \\<subseteq> G\" using Top_2_L2 by auto\n  with A1 have \"g \\<in> int(H) \\<rtr> g\" using neut_trans_elem by simp\n  with assms show \"g \\<in> int(H\\<rtr>g)\" using rtrans_interior by simp\n  from assms(1) have \"int(H\\<rtr>g) \\<subseteq> G\" using lrtrans_in_group_add(2) Top_2_L1\n    by blast\n  with \\<open>g \\<in> int(H\\<rtr>g)\\<close> assms(2) show \"g \\<in> int(H\\<rtr>g) \\<sad> int(H)\" \n    using elem_in_int_sad by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1961
    },
    "1767": {
        "type": "lemma",
        "text": "text\\<open>Negative of a neighborhood of zero is a neighborhood of zero.\\<close>\n",
        "assumes": "assumes \"H \\<in> \\<N>\\<^sub>0\"\n  ",
        "using": [
            "Top_2_L1",
            "neut_inv_neut",
            "int_inv_inv_int",
            "Ggroup",
            "group0_2_T2",
            "func1_1_L6"
        ],
        "statement": "lemma (in topgroup) neg_neigh_neigh: assumes \"H \\<in> \\<N>\\<^sub>0\"\n  shows \"(\\<sm>H) \\<in> \\<N>\\<^sub>0\"\n",
        "proof": "proof -\n  from assms have \"int(H) \\<subseteq> G\" and \"\\<zero> \\<in> int(H)\" using Top_2_L1 by auto\n  with assms have \"\\<zero> \\<in> int(\\<sm>H)\" using neut_inv_neut int_inv_inv_int by simp\n  moreover\n  have \"GroupInv(G,f):G\\<rightarrow>G\" using Ggroup group0_2_T2 by simp\n  then have \"(\\<sm>H) \\<subseteq> G\" using func1_1_L6 by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1962
    },
    "1768": {
        "type": "lemma",
        "text": "text\\<open>Left translating an open set by a negative of a point that belongs to it\n  makes it a neighboorhood of zero.\\<close>\n",
        "assumes": "assumes A1: \"U\\<in>T\" and \"g\\<in>U\"\n  ",
        "using": [
            "neg_in_tgroup",
            "open_tr_open",
            "elem_trans_neut",
            "Top_2_L3"
        ],
        "statement": "lemma (in topgroup) open_trans_neigh: assumes A1: \"U\\<in>T\" and \"g\\<in>U\"\n  shows \"(\\<rm>g)\\<ltr>U \\<in> \\<N>\\<^sub>0\"\n",
        "proof": "proof -\n  let ?H = \"(\\<rm>g)\\<ltr>U\"\n  from assms have \"g\\<in>G\" by auto\n  then have \"(\\<rm>g) \\<in> G\" using neg_in_tgroup by simp\n  with A1 have \"?H\\<in>T\" using open_tr_open by simp\n  hence \"?H \\<subseteq> G\" by auto\n  moreover have \"\\<zero> \\<in> int(?H)\"\n  proof -\n    from assms have \"U\\<subseteq>G\" and \"g\\<in>U\" by auto\n    with \\<open>?H\\<in>T\\<close> show \"\\<zero> \\<in> int(?H)\" using elem_trans_neut Top_2_L3 by auto\n  qed\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1963
    },
    "1769": {
        "type": "lemma",
        "text": "text\\<open>Right translating an open set by a negative of a point that belongs to it\n  makes it a neighboorhood of zero.\\<close>\n",
        "assumes": "assumes A1: \"U\\<in>T\" and \"g\\<in>U\"\n  ",
        "using": [
            "neg_in_tgroup",
            "open_tr_open",
            "elem_trans_neut",
            "Top_2_L3"
        ],
        "statement": "lemma (in topgroup) open_trans_neigh_2: assumes A1: \"U\\<in>T\" and \"g\\<in>U\"\n  shows \"U\\<rtr>(\\<rm>g) \\<in> \\<N>\\<^sub>0\"\n",
        "proof": "proof -\n  let ?H = \"U\\<rtr>(\\<rm>g)\"\n  from assms have \"g\\<in>G\" by auto\n  then have \"(\\<rm>g) \\<in> G\" using neg_in_tgroup by simp\n  with A1 have \"?H\\<in>T\" using open_tr_open by simp\n  hence \"?H \\<subseteq> G\" by auto\n  moreover have \"\\<zero> \\<in> int(?H)\"\n  proof -\n    from assms have \"U\\<subseteq>G\" and \"g\\<in>U\" by auto\n    with \\<open>?H\\<in>T\\<close> show \"\\<zero> \\<in> int(?H)\" using elem_trans_neut Top_2_L3  by auto\n  qed\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1964
    },
    "1770": {
        "type": "lemma",
        "text": "text\\<open>Right and left translating an neighboorhood of zero by a point and its negative \n  makes it back a neighboorhood of zero.\\<close>\n",
        "assumes": "assumes \"W\\<in>\\<N>\\<^sub>0\" and \"x\\<in>G\"\n  ",
        "using": [
            "lrtrans_in_group_add(1)",
            "neg_in_tgroup",
            "lrtrans_in_group_add(2)",
            "Top_2_L1",
            "lrtrans_image(1)",
            "elem_in_int_rtrans(1)",
            "group0_2_L6",
            "ltrans_interior",
            "lrtrans_image(2)",
            "elem_in_int_ltrans(1)",
            "rtrans_interior"
        ],
        "statement": "lemma (in topgroup) lrtrans_neigh: assumes \"W\\<in>\\<N>\\<^sub>0\" and \"x\\<in>G\"\n  shows \"x\\<ltr>(W\\<rtr>(\\<rm>x)) \\<in> \\<N>\\<^sub>0\" and \"(x\\<ltr>W)\\<rtr>(\\<rm>x) \\<in> \\<N>\\<^sub>0\"\n",
        "proof": "proof -\n  from assms(2) have \"x\\<ltr>(W\\<rtr>(\\<rm>x)) \\<subseteq> G\" using lrtrans_in_group_add(1) by simp\n  moreover have \"\\<zero> \\<in> int(x\\<ltr>(W\\<rtr>(\\<rm>x)))\"\n  proof -\n    from assms(2) have \"int(W\\<rtr>(\\<rm>x)) \\<subseteq> G\" \n      using neg_in_tgroup lrtrans_in_group_add(2) Top_2_L1 by blast\n    with assms(2) have \"(x\\<ltr>int((W\\<rtr>(\\<rm>x)))) = {x\\<ra>y. y\\<in>int(W\\<rtr>(\\<rm>x))}\"\n      using lrtrans_image(1) by simp\n    moreover from assms have \"(\\<rm>x) \\<in> int(W\\<rtr>(\\<rm>x))\" \n      using neg_in_tgroup elem_in_int_rtrans(1) by simp\n    ultimately have \"x\\<ra>(\\<rm>x) \\<in> x\\<ltr>int(W\\<rtr>(\\<rm>x))\" by auto\n    with assms show ?thesis using group0_2_L6 neg_in_tgroup lrtrans_in_group_add(2) ltrans_interior \n      by simp\n  qed\n  ultimately show \"x\\<ltr>(W\\<rtr>(\\<rm>x)) \\<in> \\<N>\\<^sub>0\" by simp\n  from assms(2) have \"(x\\<ltr>W)\\<rtr>(\\<rm>x) \\<subseteq> G\" using lrtrans_in_group_add(2) neg_in_tgroup \n    by simp\n  moreover have \"\\<zero> \\<in> int((x\\<ltr>W)\\<rtr>(\\<rm>x))\"\n  proof -\n    from assms(2) have \"int((x\\<ltr>W)) \\<subseteq> G\" using lrtrans_in_group_add(1) Top_2_L1 by blast\n    with assms(2) have \"int(x\\<ltr>W) \\<rtr> (\\<rm>x) = {y\\<ra>(\\<rm>x).y\\<in>int(x\\<ltr>W)}\"\n      using neg_in_tgroup  lrtrans_image(2) by simp\n    moreover from assms have \"x \\<in> int(x\\<ltr>W)\" using elem_in_int_ltrans(1) by simp\n    ultimately have \"x\\<ra>(\\<rm>x) \\<in> int(x\\<ltr>W) \\<rtr> (\\<rm>x)\" by auto\n    with assms(2) have \"\\<zero> \\<in> int(x\\<ltr>W) \\<rtr> (\\<rm>x)\" using group0_2_L6 by simp\n    with assms show ?thesis using group0_2_L6 neg_in_tgroup lrtrans_in_group_add(1) rtrans_interior\n      by auto\n  qed\n  ultimately show \"(x\\<ltr>W)\\<rtr>(\\<rm>x) \\<in> \\<N>\\<^sub>0\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1965
    },
    "1771": {
        "type": "lemma",
        "text": "text\\<open>If $A$ is a subset of $B$ translated by $-x$ then its translation by $x$ is a subset of $B$.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> ((\\<rm>x)\\<ltr>B)\"\"x\\<in>G\" \"B\\<subseteq>G\"\n  ",
        "using": [
            "neg_in_tgroup",
            "trans_comp_image",
            "group0_2_L6",
            "trans_neutral",
            "image_id_same"
        ],
        "statement": "lemma (in topgroup) trans_subset:\n  assumes \"A \\<subseteq> ((\\<rm>x)\\<ltr>B)\"\"x\\<in>G\" \"B\\<subseteq>G\"\n  shows \"x\\<ltr>A \\<subseteq> B\"\n",
        "proof": "proof-\n  from assms(1) have \"x\\<ltr>A \\<subseteq> (x\\<ltr> ((\\<rm>x)\\<ltr>B))\" by auto\n  with assms(2,3) show \"x\\<ltr>A \\<subseteq> B\"\n    using neg_in_tgroup trans_comp_image group0_2_L6 trans_neutral image_id_same by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1966
    },
    "1772": {
        "type": "theorem",
        "text": "text\\<open> Every neighborhood of zero has a symmetric subset that is a neighborhood of zero.\\<close>\n",
        "assumes": "assumes \"U\\<in>\\<N>\\<^sub>0\"\n  ",
        "using": [
            "assms",
            "zerohoods_def",
            "group0_2_T2",
            "Ggroup",
            "group_inv_bij(2)",
            "inv_image_vimage",
            "invim_inter_inter_invim",
            "invg",
            "inj_vimage_image",
            "invb",
            "bij_def",
            "neg_neigh_neigh",
            "int_inter_int"
        ],
        "statement": "theorem (in topgroup) exists_sym_zerohood:\n  assumes \"U\\<in>\\<N>\\<^sub>0\"\n  shows \"\\<exists>V\\<in>\\<N>\\<^sub>0. (V\\<subseteq>U \\<and> (\\<sm>V)=V)\"\n",
        "proof": "proof\n  let ?V = \"U\\<inter>(\\<sm>U)\"\n  have \"U\\<subseteq>G\" using assms unfolding zerohoods_def by auto\n  then have \"?V\\<subseteq>G\" by auto\n  have invg:\" GroupInv(G, f) \\<in> G \\<rightarrow> G\" using group0_2_T2 Ggroup by auto\n  have invb:\"GroupInv(G, f) \\<in>bij(G,G)\" using group_inv_bij(2) by auto\n  have \"(\\<sm>?V)=GroupInv(G,f)-``?V\" unfolding setninv_def using inv_image_vimage \n    by auto\n  also have \"\\<dots>=(GroupInv(G,f)-``U)\\<inter>(GroupInv(G,f)-``(\\<sm>U))\" using invim_inter_inter_invim invg \n    by auto\n  also have \"\\<dots>=(\\<sm>U)\\<inter>(GroupInv(G,f)-``(GroupInv(G,f)``U))\" \n    unfolding setninv_def using inv_image_vimage by auto\n  also from \\<open>U\\<subseteq>G\\<close> have \"\\<dots>=(\\<sm>U)\\<inter>U\" using inj_vimage_image invb unfolding bij_def\n    by auto\n  finally have \"(\\<sm>?V)=?V\" by auto\n  then show \"?V \\<subseteq> U \\<and> (\\<sm> ?V) = ?V\" by auto\n  from assms have \"(\\<sm>U)\\<in>\\<N>\\<^sub>0\" using neg_neigh_neigh by auto\n  with assms have \"\\<zero> \\<in> int(U)\\<inter>int(\\<sm>U)\" unfolding zerohoods_def by auto\n  moreover have \"int(U)\\<inter>int(\\<sm>U) = int(?V)\" using int_inter_int by simp\n  ultimately have \"\\<zero> \\<in> int(?V)\" by (rule set_mem_eq)\n  with \\<open>?V\\<subseteq>G\\<close> show \"?V\\<in>\\<N>\\<^sub>0\" using zerohoods_def by auto\nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1967
    },
    "1773": {
        "type": "theorem",
        "text": "text\\<open> We can say even more than in \\<open>exists_sym_zerohood\\<close>:\n  every neighborhood of zero $U$ has a symmetric subset that is a neighborhood of zero and its \n  set double is contained in $U$.\\<close>\n",
        "assumes": "assumes \"U\\<in>\\<N>\\<^sub>0\"\n  ",
        "using": [
            "Top_2_L2",
            "fcon",
            "IsContinuous_def",
            "group0_2_L2",
            "assms",
            "zerohoods_def",
            "func1_1_L8",
            "vimage_def",
            "group0_2_T3",
            "fne",
            "zero_in_tgroup",
            "GroupInv_def",
            "prod_top_point_neighb",
            "topSpaceAssum",
            "prodtop_def",
            "wop",
            "vop",
            "G_def",
            "group_oper_fun",
            "cartsub",
            "func1_1_L15",
            "assoc",
            "lift_subsets_explained(4)",
            "sub",
            "Top_2_L1",
            "IsATopology_def",
            "Top_2_L3",
            "exists_sym_zerohood",
            "interval_add(2)",
            "interval_add(3)",
            "trans_neutral(2)",
            "image_id_same"
        ],
        "statement": "theorem (in topgroup) exists_procls_zerohood:\n  assumes \"U\\<in>\\<N>\\<^sub>0\"\n  shows \"\\<exists>V\\<in>\\<N>\\<^sub>0. (V\\<subseteq>U\\<and> (V\\<sad>V)\\<subseteq>U \\<and> (\\<sm>V)=V)\"\n",
        "proof": "proof-\n  have \"int(U)\\<in>T\" using Top_2_L2 by auto\n  then have \"f-``(int(U))\\<in>\\<tau>\" using fcon IsContinuous_def by auto\n  moreover have fne:\"f ` \\<langle>\\<zero>, \\<zero>\\<rangle> = \\<zero>\" using group0_2_L2 by auto\n  moreover\n  have \"\\<zero>\\<in>int(U)\" using assms unfolding zerohoods_def by auto\n  then have \"f -`` {\\<zero>}\\<subseteq>f-``(int(U))\" using func1_1_L8 vimage_def by auto\n  then have \"GroupInv(G,f)\\<subseteq>f-``(int(U))\" using group0_2_T3 by auto\n  then have \"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>f-``(int(U))\" using fne zero_in_tgroup unfolding GroupInv_def\n    by auto\n  ultimately obtain W V where \n    wop:\"W\\<in>T\" and vop:\"V\\<in>T\" and cartsub:\"W\\<times>V\\<subseteq>f-``(int(U))\" and zerhood:\"\\<langle>\\<zero>,\\<zero>\\<rangle>\\<in>W\\<times>V\" \n    using prod_top_point_neighb topSpaceAssum\n    unfolding prodtop_def by force\n  then have \"\\<zero>\\<in>W\" and \"\\<zero>\\<in>V\" by auto\n  then have \"\\<zero>\\<in>W\\<inter>V\" by auto\n  have sub:\"W\\<inter>V\\<subseteq>G\" using wop vop G_def by auto\n  have assoc:\"f\\<in>G\\<times>G\\<rightarrow>G\" using group_oper_fun by auto\n  {\n    fix t s assume \"t\\<in>W\\<inter>V\" and \"s\\<in>W\\<inter>V\"\n    then have \"t\\<in>W\" and \"s\\<in>V\" by auto\n    then have \"\\<langle>t,s\\<rangle>\\<in>W\\<times>V\" by auto\n    then have \"\\<langle>t,s\\<rangle>\\<in>f-``(int(U))\" using cartsub by auto\n    then have \"f`\\<langle>t,s\\<rangle>\\<in>int(U)\" using func1_1_L15 assoc by auto\n  } hence \"{f`\\<langle>t,s\\<rangle>. \\<langle>t,s\\<rangle>\\<in>(W\\<inter>V)\\<times>(W\\<inter>V)}\\<subseteq>int(U)\" by auto\n  then have \"(W\\<inter>V)\\<sad>(W\\<inter>V)\\<subseteq>int(U)\" \n    unfolding setadd_def using lift_subsets_explained(4) assoc sub\n    by auto\n  then have \"(W\\<inter>V)\\<sad>(W\\<inter>V)\\<subseteq>U\" using Top_2_L1 by auto\n  from topSpaceAssum have \"W\\<inter>V\\<in>T\" using vop wop unfolding IsATopology_def by auto\n  then have \"int(W\\<inter>V)=W\\<inter>V\" using Top_2_L3 by auto\n  with sub \\<open>\\<zero>\\<in>W\\<inter>V\\<close> have \"W\\<inter>V\\<in>\\<N>\\<^sub>0\" unfolding zerohoods_def by auto\n  then obtain Q where \"Q\\<in>\\<N>\\<^sub>0\" and \"Q\\<subseteq>W\\<inter>V\" and \"(\\<sm>Q)=Q\" using exists_sym_zerohood by blast\n  then have \"Q\\<times>Q\\<subseteq>(W\\<inter>V)\\<times>(W\\<inter>V)\" by auto \n  moreover from \\<open>Q\\<subseteq>W\\<inter>V\\<close> have \"W\\<inter>V\\<subseteq>G\" and \"Q\\<subseteq>G\" using vop wop unfolding G_def by auto\n  ultimately have \"Q\\<sad>Q\\<subseteq>(W\\<inter>V)\\<sad>(W\\<inter>V)\" using interval_add(2) func1_1_L8 by auto\n  with \\<open>(W\\<inter>V)\\<sad>(W\\<inter>V)\\<subseteq>U\\<close> have \"Q\\<sad>Q\\<subseteq>U\" by auto\n  from \\<open>Q\\<in>\\<N>\\<^sub>0\\<close> have \"\\<zero>\\<in>Q\" unfolding zerohoods_def using Top_2_L1 by auto\n  with \\<open>Q\\<sad>Q\\<subseteq>U\\<close> \\<open>Q\\<subseteq>G\\<close> have \"\\<zero>\\<ltr>Q\\<subseteq>U\" using interval_add(3) by auto\n  with \\<open>Q\\<subseteq>G\\<close> have \"Q\\<subseteq>U\" unfolding ltrans_def gzero_def using trans_neutral(2) image_id_same \n    by auto\n  with \\<open>Q\\<in>\\<N>\\<^sub>0\\<close> \\<open>Q\\<sad>Q\\<subseteq>U\\<close> \\<open>(\\<sm>Q)=Q\\<close> show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1968
    },
    "1774": {
        "type": "lemma",
        "text": "text\\<open>Closure of a set is contained in the sum of the set and any\n  neighboorhood of zero.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>G\" and A2: \"H \\<in> \\<N>\\<^sub>0\"\n  ",
        "using": [
            "Top_3_L11",
            "Top_2_L2",
            "neg_neigh_neigh",
            "ltrans_interior",
            "int_inv_inv_int",
            "elem_in_int_ltrans(1)",
            "cl_inter_neigh",
            "ltrans_inv_in",
            "Top_2_L1",
            "func1_1_L8",
            "interval_add(3)"
        ],
        "statement": "lemma (in topgroup) cl_contains_zneigh:\n  assumes A1: \"A\\<subseteq>G\" and A2: \"H \\<in> \\<N>\\<^sub>0\"\n  shows \"cl(A) \\<subseteq> A\\<sad>H\"\n",
        "proof": "proof\n  fix x assume \"x \\<in> cl(A)\"\n  from A1 have \"cl(A) \\<subseteq> G\" using Top_3_L11 by simp\n  with \\<open>x \\<in> cl(A)\\<close> have \"x\\<in>G\" by auto\n  have \"int(H) \\<subseteq> G\" using Top_2_L2 by auto\n  let ?V = \"int(x \\<ltr> (\\<sm>H))\"\n  have \"?V = x \\<ltr> (\\<sm>int(H))\"\n  proof -\n    from A2 \\<open>x\\<in>G\\<close> have \"?V = x \\<ltr> int(\\<sm>H)\" \n      using neg_neigh_neigh ltrans_interior by simp\n    with A2 show ?thesis  using int_inv_inv_int by simp\n  qed\n  have \"A\\<inter>?V \\<noteq> 0\"\n  proof -\n    from A2 \\<open>x\\<in>G\\<close> \\<open>x \\<in> cl(A)\\<close> have \"?V\\<in>T\" and \"x \\<in> cl(A) \\<inter> ?V\" \n      using neg_neigh_neigh elem_in_int_ltrans(1) Top_2_L2 by auto\n    with A1 show \"A\\<inter>?V \\<noteq> 0\" using cl_inter_neigh by simp\n  qed\n  then obtain y where \"y\\<in>A\" and \"y\\<in>?V\" by auto\n  with \\<open>?V = x \\<ltr> (\\<sm>int(H))\\<close> \\<open>int(H) \\<subseteq> G\\<close> \\<open>x\\<in>G\\<close> have \"x \\<in> y\\<ltr>int(H)\"\n    using ltrans_inv_in by simp\n  with \\<open>y\\<in>A\\<close> have \"x \\<in> (\\<Union>y\\<in>A. y\\<ltr>H)\" using Top_2_L1 func1_1_L8 by auto\n  with assms show \"x \\<in> A\\<sad>H\" using interval_add(3) by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1969
    },
    "1775": {
        "type": "theorem",
        "text": "text\\<open>The next theorem provides a characterization of closure in topological\n  groups in terms of neighborhoods of zero.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" ",
        "using": [
            "zneigh_not_empty",
            "cl_contains_zneigh",
            "interval_add",
            "open_trans_neigh",
            "neg_neigh_neigh",
            "interval_add(3)",
            "ltrans_inv_in",
            "neg_in_tgroup",
            "trans_comp_image",
            "group0_2_L6",
            "trans_neutral",
            "image_id_same",
            "inter_neigh_cl"
        ],
        "statement": "theorem (in topgroup) cl_topgroup:\n  assumes \"A\\<subseteq>G\" shows \"cl(A) = (\\<Inter>H\\<in>\\<N>\\<^sub>0. A\\<sad>H)\"\n",
        "proof": "proof\n  from assms show \"cl(A) \\<subseteq> (\\<Inter>H\\<in>\\<N>\\<^sub>0. A\\<sad>H)\" \n    using zneigh_not_empty cl_contains_zneigh by auto\nnext\n  { fix x assume \"x \\<in> (\\<Inter>H\\<in>\\<N>\\<^sub>0. A\\<sad>H)\"\n    then have \"x \\<in> A\\<sad>G\" using zneigh_not_empty by auto\n    with assms have \"x\\<in>G\" using interval_add by blast\n    have \"\\<forall>U\\<in>T. x\\<in>U \\<longrightarrow> U\\<inter>A \\<noteq> 0\"\n    proof -\n      { fix U assume \"U\\<in>T\" and \"x\\<in>U\"\n        let ?H = \"\\<sm>((\\<rm>x)\\<ltr>U)\"\n        from \\<open>U\\<in>T\\<close> and \\<open>x\\<in>U\\<close> have \"(\\<rm>x)\\<ltr>U \\<subseteq> G\" and \"?H \\<in> \\<N>\\<^sub>0\" \n          using open_trans_neigh neg_neigh_neigh by auto\n        with \\<open>x \\<in> (\\<Inter>H\\<in>\\<N>\\<^sub>0. A\\<sad>H)\\<close> have \"x \\<in> A\\<sad>?H\" by auto\n        with assms \\<open>?H \\<in> \\<N>\\<^sub>0\\<close> obtain y where \"y\\<in>A\" and \"x \\<in> y\\<ltr>?H\"\n          using interval_add(3) by auto\n        have \"y\\<in>U\"\n        proof -\n          from assms \\<open>y\\<in>A\\<close> have \"y\\<in>G\" by auto\n          with \\<open>(\\<rm>x)\\<ltr>U \\<subseteq> G\\<close> and \\<open>x \\<in> y\\<ltr>?H\\<close> have \"y \\<in> x\\<ltr>((\\<rm>x)\\<ltr>U)\"\n            using ltrans_inv_in by simp\n          with \\<open>U\\<in>T\\<close> \\<open>x\\<in>G\\<close> show \"y\\<in>U\" \n            using neg_in_tgroup trans_comp_image group0_2_L6 trans_neutral image_id_same\n              by auto\n        qed\n        with \\<open>y\\<in>A\\<close> have \"U\\<inter>A \\<noteq> 0\" by auto\n      } thus ?thesis by simp\n    qed\n    with assms \\<open>x\\<in>G\\<close> have \"x \\<in> cl(A)\" using inter_neigh_cl by simp\n  } thus \"(\\<Inter>H\\<in>\\<N>\\<^sub>0. A\\<sad>H) \\<subseteq> cl(A)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1970
    },
    "1776": {
        "type": "lemma",
        "text": "text\\<open>Let's recall first that the sum of elements of a group is an element of the group.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"x: succ(n)\\<rightarrow>G\"\n  ",
        "using": [
            "semigr0_valid_in_tgroup"
        ],
        "statement": "lemma (in topgroup) sum_list_in_group:\n  assumes \"n \\<in> nat\" and \"x: succ(n)\\<rightarrow>G\"\n  shows \"(\\<Sum>x) \\<in> G\"\n",
        "proof": "proof -\n  from assms have \"semigr0(G,f)\" and \"n \\<in> nat\" \"x: succ(n)\\<rightarrow>G\"\n    using semigr0_valid_in_tgroup by auto\n  then have \"Fold1(f,x) \\<in> G\" by (rule semigr0.prod_type)\n  thus \"(\\<Sum>x) \\<in> G\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1971
    },
    "1777": {
        "type": "lemma",
        "text": "text\\<open>In this context \\<open>x\\<ra>y\\<close> is the same as the value of the group operation\n  on the elements $x$ and $y$. Normally we shouldn't need to state this a s separate lemma.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma (in topgroup) grop_def1: shows \"f`\\<langle>x,y\\<rangle> = x\\<ra>y\" by simp \n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1972
    },
    "1778": {
        "type": "lemma",
        "text": "text\\<open>Another theorem from \\<open>Semigroup_ZF\\<close> theory that is useful to have in the\n  additive notation.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"x: succ(succ(n))\\<rightarrow>G\"\n  ",
        "using": [
            "semigr0_valid_in_tgroup"
        ],
        "statement": "lemma (in topgroup) shorter_set_add:\n  assumes \"n \\<in> nat\" and \"x: succ(succ(n))\\<rightarrow>G\"\n  shows \"(\\<Sum>x) = (\\<Sum>Init(x)) \\<ra> (x`(succ(n)))\"\n",
        "proof": "proof -\n  from assms have \"semigr0(G,f)\" and \"n \\<in> nat\" \"x: succ(succ(n))\\<rightarrow>G\"\n    using semigr0_valid_in_tgroup by auto\n  then have \"Fold1(f,x) = f`\\<langle>Fold1(f,Init(x)),x`(succ(n))\\<rangle>\"\n    by (rule semigr0.shorter_seq)\n  thus ?thesis by simp   \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1973
    },
    "1779": {
        "type": "theorem",
        "text": "text\\<open>We prove the equivalence between $T_0$ and $T_1$ first.\\<close>\n",
        "assumes": "assumes \"{\\<zero>}{is closed in}T\"\n  ",
        "using": [
            "cl_point",
            "Top_3_L11(1)",
            "G_def",
            "group0.group0_2_L18(2)",
            "group0_valid_in_tgroup",
            "xG",
            "nG",
            "yG",
            "grinv_def",
            "grop_def",
            "zneigh_not_empty",
            "zero_in_tgroup",
            "image_id_same",
            "group0.trans_neutral(2)",
            "gzero_def",
            "ltrans_def",
            "assms",
            "Top_3_L8",
            "group0.group0_2_L9(2)",
            "neg_in_tgroup",
            "group0.group_inv_of_inv",
            "cl_contains_set",
            "IsClosed_def",
            "isT1_def"
        ],
        "statement": "theorem (in topgroup) neu_closed_imp_T1:\n  assumes \"{\\<zero>}{is closed in}T\"\n  shows \"T{is T\\<^sub>1}\"\n",
        "proof": "proof-\n  {\n    fix x z assume xG:\"x\\<in>G\" and zG:\"z\\<in>G\" and dis:\"x\\<noteq>z\"\n    then have clx:\"cl({x})=(\\<Inter>H\\<in>\\<N>\\<^sub>0. x\\<ltr>H)\" using cl_point by auto\n    {\n      fix y\n      assume \"y\\<in>cl({x})\"\n      with clx have \"y\\<in>(\\<Inter>H\\<in>\\<N>\\<^sub>0. x\\<ltr>H)\" by auto\n      then have t:\"\\<forall>H\\<in>\\<N>\\<^sub>0. y\\<in>x\\<ltr>H\" by auto\n      from \\<open>y\\<in>cl({x})\\<close> xG have yG:\"y\\<in>G\" using Top_3_L11(1) G_def by auto\n      {\n        fix H\n        assume HNeig:\"H\\<in>\\<N>\\<^sub>0\"\n        with t have \"y\\<in>x\\<ltr>H\" by auto\n        then obtain n where \"y=x\\<ra>n\" and \"n\\<in>H\" unfolding ltrans_def grop_def LeftTranslation_def by auto\n        with HNeig have nG:\"n\\<in>G\" unfolding zerohoods_def by auto\n        from \\<open>y=x\\<ra>n\\<close> and \\<open>n\\<in>H\\<close> have \"(\\<rm>x)\\<ra>y\\<in>H\" using group0.group0_2_L18(2) group0_valid_in_tgroup xG nG yG unfolding grinv_def grop_def\n          by auto\n      }\n      then have el:\"(\\<rm>x)\\<ra>y\\<in>(\\<Inter>\\<N>\\<^sub>0)\" using zneigh_not_empty by auto\n      have \"cl({\\<zero>})=(\\<Inter>H\\<in>\\<N>\\<^sub>0. \\<zero>\\<ltr>H)\" using cl_point zero_in_tgroup by auto\n      moreover\n      {\n        fix H  assume \"H\\<in>\\<N>\\<^sub>0\"\n        then have \"H\\<subseteq>G\" unfolding zerohoods_def by auto\n        then have \"\\<zero>\\<ltr>H=H\" using image_id_same  group0.trans_neutral(2) group0_valid_in_tgroup unfolding gzero_def ltrans_def\n          by auto\n        with \\<open>H\\<in>\\<N>\\<^sub>0\\<close> have \"\\<zero>\\<ltr>H\\<in>\\<N>\\<^sub>0\" \"H\\<in>{\\<zero>\\<ltr>H. H\\<in>\\<N>\\<^sub>0}\" by auto\n      }\n      then have \"{\\<zero>\\<ltr>H. H\\<in>\\<N>\\<^sub>0}=\\<N>\\<^sub>0\" by blast\n      ultimately have \"cl({\\<zero>})=(\\<Inter>\\<N>\\<^sub>0)\" by auto\n      with el have \"(\\<rm>x)\\<ra>y\\<in>cl({\\<zero>})\" by auto\n      then have \"(\\<rm>x)\\<ra>y\\<in>{\\<zero>}\" using assms Top_3_L8 G_def zero_in_tgroup by auto\n      then have \"(\\<rm>x)\\<ra>y=\\<zero>\" by auto\n      then have \"y=\\<rm>(\\<rm>x)\" using group0.group0_2_L9(2) group0_valid_in_tgroup neg_in_tgroup xG yG unfolding grop_def grinv_def by auto\n      then have \"y=x\" using group0.group_inv_of_inv group0_valid_in_tgroup xG unfolding grinv_def by auto\n    }\n    then have \"cl({x})\\<subseteq>{x}\" by auto\n    then have \"cl({x})={x}\" using xG cl_contains_set G_def by blast\n    then have \"{x}{is closed in}T\" using Top_3_L8 xG G_def by auto\n    then have \"(\\<Union>T)-{x}\\<in>T\" using IsClosed_def by auto moreover\n    from dis zG G_def have \"z\\<in>((\\<Union>T)-{x}) \\<and> x\\<notin>((\\<Union>T)-{x})\" by auto\n    ultimately have \"\\<exists>V\\<in>T. z\\<in>V\\<and>x\\<notin>V\" by(safe,auto)\n  }\n  then show \"T{is T\\<^sub>1}\" using isT1_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.Topology_ZF_properties_2"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_1.thy",
        "id": 1975
    },
    "1780": {
        "type": "lemma",
        "text": "text\\<open>Here follow some auxiliary lemmas.\\<close>\n",
        "assumes": "assumes \"x\\<in>G\" \"A\\<subseteq>G\"\n  ",
        "using": [
            "group0.group0_5_L1(2)[OF",
            "group0_valid_in_tgroup",
            "assms(1)]",
            "image_def",
            "range_def",
            "domain_def",
            "converse_def",
            "Pi_def",
            "Top_3_L11(2)[of",
            "\"\\<Union>T-(x\\<ltr>A)\"]",
            "surj_image_eq",
            "group0.trans_bij(2)[OF",
            "bij_def",
            "inj_image_dif[of",
            "\"LeftTranslation(G,",
            "f,",
            "x)\"\"G\"\"G\",",
            "OF",
            "_",
            "assms(2)]",
            "ltrans_def",
            "G_def",
            "ltrans_interior[OF",
            "assms(1),of",
            "\"\\<Union>T-A\"]",
            "assms(2)",
            "Top_2_L2",
            "x)\"\"G\"\"G\"\"cl(A)\"]",
            "Top_3_L11(1)"
        ],
        "statement": "lemma (in topgroup) trans_closure:\n  assumes \"x\\<in>G\" \"A\\<subseteq>G\"\n  shows \"cl(x\\<ltr>A)=x\\<ltr>cl(A)\"\n",
        "proof": "proof-\n  have \"\\<Union>T-(\\<Union>T-(x\\<ltr>A))=(x\\<ltr>A)\" unfolding ltrans_def using group0.group0_5_L1(2)[OF group0_valid_in_tgroup assms(1)]\n    unfolding image_def range_def domain_def converse_def Pi_def by auto\n  then have \"cl(x\\<ltr>A)=\\<Union>T-int(\\<Union>T-(x\\<ltr>A))\" using Top_3_L11(2)[of \"\\<Union>T-(x\\<ltr>A)\"] by auto moreover\n  have \"x\\<ltr>G=G\" using surj_image_eq group0.trans_bij(2)[OF group0_valid_in_tgroup assms(1)] bij_def by auto\n  then have \"\\<Union>T-(x\\<ltr>A)=x\\<ltr>(\\<Union>T-A)\" using inj_image_dif[of \"LeftTranslation(G, f, x)\"\"G\"\"G\", OF _ assms(2)]\n    unfolding ltrans_def G_def using group0.trans_bij(2)[OF group0_valid_in_tgroup assms(1)] bij_def by auto\n  then have \"int(\\<Union>T-(x\\<ltr>A))=int(x\\<ltr>(\\<Union>T-A))\" by auto\n  then have \"int(\\<Union>T-(x\\<ltr>A))=x\\<ltr>int(\\<Union>T-A)\" using ltrans_interior[OF assms(1),of \"\\<Union>T-A\"] unfolding G_def by force\n  have \"\\<Union>T-int(\\<Union>T-A)=cl(\\<Union>T-(\\<Union>T-A))\" using Top_3_L11(2)[of \"\\<Union>T-A\"] by force\n  have \"\\<Union>T-(\\<Union>T-A)=A\" using assms(2) G_def by auto\n  with \\<open>\\<Union>T-int(\\<Union>T-A)=cl(\\<Union>T-(\\<Union>T-A))\\<close> have \"\\<Union>T-int(\\<Union>T-A)=cl(A)\" by auto\n  have \"\\<Union>T-(\\<Union>T-int(\\<Union>T-A))=int(\\<Union>T-A)\" using Top_2_L2 by auto\n  with \\<open>\\<Union>T-int(\\<Union>T-A)=cl(A)\\<close> have \"int(\\<Union>T-A)=\\<Union>T-cl(A)\" by auto\n  with \\<open>int(\\<Union>T-(x\\<ltr>A))=x\\<ltr>int(\\<Union>T-A)\\<close> have \"int(\\<Union>T-(x\\<ltr>A))=x\\<ltr>(\\<Union>T-cl(A))\" by auto\n  with \\<open>x\\<ltr>G=G\\<close> have \"int(\\<Union>T-(x\\<ltr>A))=\\<Union>T-(x\\<ltr>cl(A))\" using inj_image_dif[of \"LeftTranslation(G, f, x)\"\"G\"\"G\"\"cl(A)\"]\n    unfolding ltrans_def using group0.trans_bij(2)[OF group0_valid_in_tgroup assms(1)] Top_3_L11(1) assms(2) unfolding bij_def G_def\n    by auto\n  then have \"\\<Union>T-int(\\<Union>T-(x\\<ltr>A))=\\<Union>T-(\\<Union>T-(x\\<ltr>cl(A)))\" by auto\n  then have \"\\<Union>T-int(\\<Union>T-(x\\<ltr>A))=x\\<ltr>cl(A)\" unfolding ltrans_def using group0.group0_5_L1(2)[OF group0_valid_in_tgroup assms(1)]\n    unfolding image_def range_def domain_def converse_def Pi_def by auto\n  with \\<open>cl(x\\<ltr>A)=\\<Union>T-int(\\<Union>T-(x\\<ltr>A))\\<close> show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.Topology_ZF_properties_2"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_1.thy",
        "id": 1976
    },
    "1781": {
        "type": "lemma",
        "text": "text\\<open>In a topological group, all local properties depend only on the neighbourhoods\nof the neutral element; when considering topological properties. The next result\nof regularity, will use this idea, since translations preserve closed sets.\\<close>\n",
        "assumes": "assumes \"\\<forall>U\\<in>T\\<inter>\\<N>\\<^sub>0. \\<exists>N\\<in>\\<N>\\<^sub>0. N\\<subseteq>U\\<and> P(N,T)\" \"\\<forall>N\\<in>Pow(G). \\<forall>x\\<in>G. P(N,T) \\<longrightarrow> P(x\\<ltr>N,T)\"\n  ",
        "using": [
            "open_tr_open(1)",
            "open_trans_neigh",
            "neg_in_tgroup",
            "G_def",
            "trans_subset",
            "elem_in_int_ltrans"
        ],
        "statement": "lemma (in topgroup) local_iff_neutral:\n  assumes \"\\<forall>U\\<in>T\\<inter>\\<N>\\<^sub>0. \\<exists>N\\<in>\\<N>\\<^sub>0. N\\<subseteq>U\\<and> P(N,T)\" \"\\<forall>N\\<in>Pow(G). \\<forall>x\\<in>G. P(N,T) \\<longrightarrow> P(x\\<ltr>N,T)\"\n  shows \"T{is locally}P\"\n",
        "proof": "proof-\n  {\n    fix x U assume \"x\\<in>\\<Union>T\"\"U\\<in>T\"\"x\\<in>U\"\n    then have \"(\\<rm>x)\\<ltr>U\\<in>T\\<inter>\\<N>\\<^sub>0\" using open_tr_open(1) open_trans_neigh neg_in_tgroup unfolding G_def\n      by auto\n    with assms(1) obtain N where \"N\\<subseteq>((\\<rm>x)\\<ltr>U)\"\"P(N,T)\"\"N\\<in>\\<N>\\<^sub>0\" by auto\n    note \\<open>x\\<in>\\<Union>T\\<close>\\<open>N\\<subseteq>((\\<rm>x)\\<ltr>U)\\<close> moreover\n    from \\<open>U\\<in>T\\<close> have \"U\\<subseteq>\\<Union>T\" by auto moreover\n    from \\<open>N\\<in>\\<N>\\<^sub>0\\<close> have \"N\\<subseteq>G\" unfolding zerohoods_def by auto\n    ultimately have \"(x\\<ltr>N)\\<subseteq>U\" using trans_subset unfolding G_def by auto moreover\n    from \\<open>N\\<subseteq>G\\<close>\\<open>x\\<in>\\<Union>T\\<close> assms(2) \\<open>P(N,T)\\<close> have \"P((x\\<ltr>N),T)\" unfolding G_def by auto moreover\n    from \\<open>N\\<in>\\<N>\\<^sub>0\\<close>\\<open>x\\<in>\\<Union>T\\<close> have \"x\\<in>int(x\\<ltr>N)\" using elem_in_int_ltrans unfolding G_def by auto\n    ultimately have \"\\<exists>N\\<in>Pow(U). x\\<in>int(N)\\<and>P(N,T)\" by auto\n  }\n  then show ?thesis unfolding IsLocally_def[OF topSpaceAssum] by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.Topology_ZF_properties_2"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_1.thy",
        "id": 1977
    },
    "1782": {
        "type": "theorem",
        "text": "text\\<open>As it is written in the previous section, every topological group is regular.\\<close>\n",
        "assumes": "",
        "using": [
            "exist_basehoods_closed",
            "cl_contains_set",
            "zerohoods_def",
            "G_def",
            "interior_mono",
            "Top_3_L11(1)",
            "cl_is_closed",
            "trans_closed",
            "local_iff_neutral",
            "IsLocallyClosed_def",
            "regular_locally_closed"
        ],
        "statement": "theorem (in topgroup) topgroup_reg:\n  shows \"T{is regular}\"\n",
        "proof": "proof-\n  {\n    fix U assume \"U\\<in>T\\<inter>\\<N>\\<^sub>0\"\n    then obtain V where \"cl(V)\\<subseteq>U\"\"V\\<in>\\<N>\\<^sub>0\" using exist_basehoods_closed by blast\n    then have \"V\\<subseteq>cl(V)\" using cl_contains_set unfolding zerohoods_def G_def by auto\n    then have \"int(V)\\<subseteq>int(cl(V))\" using interior_mono by auto\n    with \\<open>V\\<in>\\<N>\\<^sub>0\\<close> have \"cl(V)\\<in>\\<N>\\<^sub>0\" unfolding zerohoods_def G_def using Top_3_L11(1) by auto\n    from \\<open>V\\<in>\\<N>\\<^sub>0\\<close> have \"cl(V){is closed in}T\" using cl_is_closed unfolding zerohoods_def G_def by auto\n    with \\<open>cl(V)\\<in>\\<N>\\<^sub>0\\<close>\\<open>cl(V)\\<subseteq>U\\<close> have \"\\<exists>N\\<in>\\<N>\\<^sub>0. N\\<subseteq>U\\<and>N{is closed in}T\" by auto\n  }\n  then have \"\\<forall>U\\<in>T\\<inter>\\<N>\\<^sub>0. \\<exists>N\\<in>\\<N>\\<^sub>0. N\\<subseteq>U\\<and>N{is closed in}T\" by auto moreover\n  have \"\\<forall>N\\<in>Pow(G).( \\<forall>x\\<in>G. (N{is closed in}T\\<longrightarrow>(x\\<ltr>N){is closed in}T))\" using trans_closed by auto\n  ultimately have \"T{is locally-closed}\" using local_iff_neutral unfolding IsLocallyClosed_def by auto\n  then show \"T{is regular}\" using regular_locally_closed by auto\nqed\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.Topology_ZF_properties_2"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_1.thy",
        "id": 1978
    },
    "1783": {
        "type": "corollary",
        "text": "text\\<open>The promised corollary follows:\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>2}\"\n  ",
        "using": [
            "T2_is_T1",
            "topgroup_reg",
            "isT3_def",
            "assms"
        ],
        "statement": "corollary (in topgroup) T2_imp_T3:\n  assumes \"T{is T\\<^sub>2}\"\n  shows \"T{is T\\<^sub>3}\" ",
        "proof": "using T2_is_T1 topgroup_reg isT3_def assms by auto\n",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.Topology_ZF_properties_2"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_1.thy",
        "id": 1979
    },
    "1784": {
        "type": "theorem",
        "text": "text\\<open>A quotient of a topological group is just a quotient group with an appropiate\n topology that makes product and inverse continuous.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,f,H)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,f,H)\"\n  defines \"F \\<equiv> QuotientGroupOp(G,f,H)\"\n  ",
        "using": [
            "group0.Group_ZF_2_4_L3",
            "assms(1)",
            "r_def",
            "IsAnormalSubgroup_def",
            "group0_valid_in_tgroup",
            "product_equiv_rel_fun",
            "G_def",
            "Group_ZF_2_4_L5A[OF",
            "Ggroup",
            "assms(1)]",
            "r_def.",
            "with",
            "eqT",
            "have",
            "\"IsContinuous(ProductTopology(T,T),ProductTopology(T{quotient",
            "product_quo_fun",
            "Top_1_4_T1(1)[OF",
            "topSpaceAssum",
            "topSpaceAssum].",
            "Hfun:\"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>.",
            "\\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\\<in>surj(\\<Union>ProductTopology(T,T),\\<Union>(({quotient",
            "topology",
            "in}(((\\<Union>T)//r)\\<times>((\\<Union>T)//r)){",
            "prod_equiv_rel_surj",
            "total_quo_equi[OF",
            "eqT]",
            "topology0.total_quo_func[OF",
            "tprod",
            "prod_equiv_rel_surj]",
            "F_def",
            "QuotientGroupOp_def",
            "EquivClass_1_T1[OF",
            "eqG",
            "C]",
            "comp_fun[OF",
            "fun",
            "C]]",
            "Top_1_4_T1(3)[OF",
            "topSpaceAssum]",
            "equiv_quo_is_top[OF",
            "fcon",
            "prodtop_def",
            "quotient_func_cont[OF",
            "quotient_proj_surj]",
            "EquivQuo_def[OF",
            "comp_cont",
            "apply_type[OF",
            "topgroup_f_binop]",
            "apply_equality[OF",
            "_",
            "quotient_proj_fun]",
            "comp_fun_apply[OF",
            "topgroup_f_binop",
            "A]",
            "A_def(1)",
            "product_equiv_rel_fun]",
            "group0.Group_ZF_2_2_L2[OF",
            "C",
            "A_def(2,3)]",
            "Pr1",
            "fun_extension[OF",
            "cc",
            "quotient_proj_fun]]",
            "cont",
            "quotient_map_topgroup_open",
            "prod_quotient",
            "two_top_spaces0.cont_quotient_top[OF",
            "two",
            "Hfun",
            "Ffun]"
        ],
        "statement": "theorem (in topgroup) quotient_top_group_F_cont:\n  assumes \"IsAnormalSubgroup(G,f,H)\"\n  defines \"r \\<equiv> QuotientGroupRel(G,f,H)\"\n  defines \"F \\<equiv> QuotientGroupOp(G,f,H)\"\n  shows \"IsContinuous(ProductTopology(T{quotient by}r,T{quotient by}r),T{quotient by}r,F)\"\n",
        "proof": "proof-\n  have eqT:\"equiv(\\<Union>T,r)\" and eqG:\"equiv(G,r)\" using group0.Group_ZF_2_4_L3 assms(1) unfolding r_def IsAnormalSubgroup_def\n    using group0_valid_in_tgroup by auto\n  have fun:\"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}:G\\<times>G\\<rightarrow>(G//r)\\<times>(G//r)\" using product_equiv_rel_fun unfolding G_def by auto \n  have C:\"Congruent2(r,f)\" using Group_ZF_2_4_L5A[OF Ggroup assms(1)] unfolding r_def.\n  with eqT have \"IsContinuous(ProductTopology(T,T),ProductTopology(T{quotient by}r,T{quotient by}r),{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T})\"\n    using product_quo_fun by auto\n  have tprod:\"topology0(ProductTopology(T,T))\" unfolding topology0_def using Top_1_4_T1(1)[OF topSpaceAssum topSpaceAssum].\n  have Hfun:\"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\\<in>surj(\\<Union>ProductTopology(T,T),\\<Union>(({quotient topology in}(((\\<Union>T)//r)\\<times>((\\<Union>T)//r)){by}{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}{from}(ProductTopology(T,T)))))\" using prod_equiv_rel_surj\n    total_quo_equi[OF eqT] topology0.total_quo_func[OF tprod prod_equiv_rel_surj] unfolding F_def QuotientGroupOp_def r_def\n    by auto\n  have Ffun:\"F:\\<Union>(({quotient topology in}(((\\<Union>T)//r)\\<times>((\\<Union>T)//r)){by}{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}{from}(ProductTopology(T,T))))\\<rightarrow>\\<Union>(T{quotient by}r)\"\n    using EquivClass_1_T1[OF eqG C] using total_quo_equi[OF eqT] topology0.total_quo_func[OF tprod prod_equiv_rel_surj] unfolding F_def QuotientGroupOp_def r_def\n    by auto\n  have cc:\"(F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}):G\\<times>G\\<rightarrow>G//r\" using comp_fun[OF fun EquivClass_1_T1[OF eqG C]]\n    unfolding F_def QuotientGroupOp_def r_def by auto\n  then have \"(F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}):\\<Union>(ProductTopology(T,T))\\<rightarrow>\\<Union>(T{quotient by}r)\" using Top_1_4_T1(3)[OF topSpaceAssum topSpaceAssum]\n    total_quo_equi[OF eqT] by auto\n  then have two:\"two_top_spaces0(ProductTopology(T,T),T{quotient by}r,(F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}))\" unfolding two_top_spaces0_def\n    using Top_1_4_T1(1)[OF topSpaceAssum topSpaceAssum] equiv_quo_is_top[OF eqT] by auto\n  have \"IsContinuous(ProductTopology(T,T),T,f)\" using fcon prodtop_def by auto moreover\n  have \"IsContinuous(T,T{quotient by}r,{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T})\" using quotient_func_cont[OF quotient_proj_surj]\n    unfolding EquivQuo_def[OF eqT] by auto\n  ultimately have cont:\"IsContinuous(ProductTopology(T,T),T{quotient by}r,{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T} O f)\"\n    using comp_cont by auto\n  {\n    fix A assume A:\"A\\<in>G\\<times>G\"\n    then obtain g1 g2 where A_def:\"A=\\<langle>g1,g2\\<rangle>\" \"g1\\<in>G\"\"g2\\<in>G\" by auto\n    then have \"f`A=g1\\<ra>g2\" and p:\"g1\\<ra>g2\\<in>\\<Union>T\" unfolding grop_def using \n      apply_type[OF topgroup_f_binop] by auto\n    then have \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(f`A)={\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(g1\\<ra>g2)\" by auto\n    with p have \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(f`A)=r``{g1\\<ra>g2}\" using apply_equality[OF _ quotient_proj_fun]\n      by auto\n    then have Pr1:\"({\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T} O f)`A=r``{g1\\<ra>g2}\" using comp_fun_apply[OF topgroup_f_binop A] by auto\n    from A_def(2,3) have \"\\<langle>g1,g2\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T\" by auto\n    then have \"\\<langle>\\<langle>g1,g2\\<rangle>,\\<langle>r``{g1},r``{g2}\\<rangle>\\<rangle>\\<in>{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\" by auto\n    then have \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}`A=\\<langle>r``{g1},r``{g2}\\<rangle>\" using A_def(1) apply_equality[OF _ product_equiv_rel_fun]\n      by auto\n    then have \"F`({\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}`A)=F`\\<langle>r``{g1},r``{g2}\\<rangle>\" by auto\n    then have \"F`({\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}`A)=r``({g1\\<ra>g2})\" using group0.Group_ZF_2_2_L2[OF group0_valid_in_tgroup eqG C\n      _ A_def(2,3)] unfolding F_def QuotientGroupOp_def r_def by auto moreover\n    note fun ultimately have \"(F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T})`A=r``({g1\\<ra>g2})\" using comp_fun_apply[OF _ A] by auto\n    then have \"(F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T})`A=({\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T} O f)`A\" using Pr1 by auto\n  }\n  then have \"(F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T})=({\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T} O f)\" using fun_extension[OF cc comp_fun[OF topgroup_f_binop quotient_proj_fun]]\n    unfolding F_def QuotientGroupOp_def r_def by auto\n  then have A:\"IsContinuous(ProductTopology(T,T),T{quotient by}r,F O {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T})\" using cont by auto\n  have \"IsAsubgroup(H,f)\" using assms(1) unfolding IsAnormalSubgroup_def by auto\n  then have \"\\<forall>A\\<in>T. {\\<langle>b, r `` {b}\\<rangle> . b \\<in> \\<Union>T} `` A \\<in> ({quotient by}r)\" using quotient_map_topgroup_open unfolding r_def by auto\n  with eqT have \"ProductTopology({quotient by}r,{quotient by}r)=({quotient topology in}(((\\<Union>T)//r)\\<times>((\\<Union>T)//r)){by}{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}{from}(ProductTopology(T,T)))\" using prod_quotient\n    by auto\n  with A show \"IsContinuous(ProductTopology(T{quotient by}r,T{quotient by}r),T{quotient by}r,F)\"\n    using two_top_spaces0.cont_quotient_top[OF two Hfun Ffun] topology0.total_quo_func[OF tprod prod_equiv_rel_surj] unfolding F_def QuotientGroupOp_def r_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_8",
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_2.thy",
        "id": 1980
    },
    "1785": {
        "type": "theorem",
        "text": "text\\<open>The closure of a subgroup is a subgroup.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,f)\"\n  ",
        "using": [
            "topSpaceAssum",
            "Top_1_4_T1(1,3)",
            "topgroup_f_binop",
            "two_top_spaces0.TopZF_2_1_L1",
            "two",
            "two_top_spaces0.Top_ZF_2_1_L2",
            "group0.group0_3_L2",
            "group0_valid_in_tgroup",
            "assms",
            "prod_top_on_G(2)",
            "Top_3_L11(1)",
            "cl_product",
            "group0.group_oper_fun",
            "group0_def",
            "restrict_image",
            "func1_1_L6(2)",
            "top_closure_mono",
            "func_imagedef",
            "clHsub1",
            "Ggroup",
            "group0_2_T2",
            "IsAsubgroup_def",
            "group0.group0_3_T1",
            "sub1",
            "clHG",
            "group0.group0_3_L5",
            "cl_contains_set",
            "group0.group0_3_T3"
        ],
        "statement": "theorem (in topgroup) closure_subgroup:\n  assumes \"IsAsubgroup(H,f)\"\n  shows \"IsAsubgroup(cl(H),f)\"\n",
        "proof": "proof-\n  have two:\"two_top_spaces0(ProductTopology(T,T),T,f)\" unfolding two_top_spaces0_def using\n    topSpaceAssum Top_1_4_T1(1,3) topgroup_f_binop by auto\n  from fcon have cont:\"IsContinuous(ProductTopology(T,T),T,f)\" by auto\n  then have closed:\"\\<forall>D. D{is closed in}T \\<longrightarrow> f-``D{is closed in}\\<tau>\" using two_top_spaces0.TopZF_2_1_L1\n    two by auto\n  then have closure:\"\\<forall>A\\<in>Pow(\\<Union>\\<tau>). f``(Closure(A,\\<tau>))\\<subseteq>cl(f``A)\" using two_top_spaces0.Top_ZF_2_1_L2\n    two by force\n  have sub1:\"H\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup assms by force\n  then have sub:\"(H)\\<times>(H)\\<subseteq>\\<Union>\\<tau>\" using prod_top_on_G(2) by auto\n  from sub1 have clHG:\"cl(H)\\<subseteq>G\" using Top_3_L11(1) by auto\n  then have clHsub1:\"cl(H)\\<times>cl(H)\\<subseteq>G\\<times>G\" by auto\n  have \"Closure(H\\<times>H,ProductTopology(T,T))=cl(H)\\<times>cl(H)\" using cl_product\n    topSpaceAssum group0.group0_3_L2 group0_valid_in_tgroup assms by auto\n  then have \"f``(Closure(H\\<times>H,ProductTopology(T,T)))=f``(cl(H)\\<times>cl(H))\" by auto\n  with closure sub have clcl:\"f``(cl(H)\\<times>cl(H))\\<subseteq>cl(f``(H\\<times>H))\" by force\n  from assms have fun:\"restrict(f,H\\<times>H):H\\<times>H\\<rightarrow>H\" unfolding IsAsubgroup_def using\n    group0.group_oper_fun unfolding group0_def by auto\n  then have \"restrict(f,H\\<times>H)``(H\\<times>H)=f``(H\\<times>H)\" using restrict_image by auto\n  moreover from fun have \"restrict(f,H\\<times>H)``(H\\<times>H)\\<subseteq>H\" using func1_1_L6(2) by blast\n  ultimately have \"f``(H\\<times>H)\\<subseteq>H\" by auto\n  with sub1 have \"f``(H\\<times>H)\\<subseteq>H\"\"f``(H\\<times>H)\\<subseteq>G\"\"H\\<subseteq>G\" by auto\n  then have \"cl(f``(H\\<times>H))\\<subseteq>cl(H)\" using top_closure_mono by auto\n  with clcl have img:\"f``(cl(H)\\<times>cl(H))\\<subseteq>cl(H)\" by auto\n  {\n    fix x y assume \"x\\<in>cl(H)\"\"y\\<in>cl(H)\"\n    then have \"\\<langle>x,y\\<rangle>\\<in>cl(H)\\<times>cl(H)\" by auto moreover\n    have \"f``(cl(H)\\<times>cl(H))={f`t. t\\<in>cl(H)\\<times>cl(H)}\" using func_imagedef topgroup_f_binop \n      clHsub1 by auto ultimately\n    have \"f`\\<langle>x,y\\<rangle>\\<in>f``(cl(H)\\<times>cl(H))\" by auto\n    with img have \"f`\\<langle>x,y\\<rangle>\\<in>cl(H)\" by auto\n  }\n  then have A1:\"cl(H){is closed under} f\" unfolding IsOpClosed_def by auto\n  have two:\"two_top_spaces0(T,T,GroupInv(G,f))\" unfolding two_top_spaces0_def using\n    topSpaceAssum Ggroup group0_2_T2 by auto\n  from inv_cont have cont:\"IsContinuous(T,T,GroupInv(G,f))\" by auto\n  then have closed:\"\\<forall>D. D{is closed in}T \\<longrightarrow> GroupInv(G,f)-``D{is closed in}T\" using two_top_spaces0.TopZF_2_1_L1\n    two by auto\n  then have closure:\"\\<forall>A\\<in>Pow(\\<Union>T). GroupInv(G,f)``(cl(A))\\<subseteq>cl(GroupInv(G,f)``A)\" using two_top_spaces0.Top_ZF_2_1_L2\n    two by force\n  with sub1 have Inv:\"GroupInv(G,f)``(cl(H))\\<subseteq>cl(GroupInv(G,f)``H)\" by auto moreover\n  have \"GroupInv(H,restrict(f,H\\<times>H)):H\\<rightarrow>H\" using assms unfolding IsAsubgroup_def using group0_2_T2 by auto then\n  have \"GroupInv(H,restrict(f,H\\<times>H))``H\\<subseteq>H\" using func1_1_L6(2) by auto\n  then have \"restrict(GroupInv(G,f),H)``H\\<subseteq>H\" using group0.group0_3_T1 assms group0_valid_in_tgroup by auto\n  then have sss:\"GroupInv(G,f)``H\\<subseteq>H\" using restrict_image by auto\n  then have \"H\\<subseteq>G\" \"GroupInv(G,f)``H\\<subseteq>G\" using sub1 by auto\n  with sub1 sss have \"cl(GroupInv(G,f)``H)\\<subseteq>cl(H)\" using top_closure_mono by auto ultimately\n  have img:\"GroupInv(G,f)``(cl(H))\\<subseteq>cl(H)\" by auto\n  {\n    fix x assume \"x\\<in>cl(H)\" moreover\n    have \"GroupInv(G,f)``(cl(H))={GroupInv(G,f)`t. t\\<in>cl(H)}\" using func_imagedef Ggroup group0_2_T2\n      clHG by force ultimately\n    have \"GroupInv(G,f)`x\\<in>GroupInv(G,f)``(cl(H))\" by auto\n    with img have \"GroupInv(G,f)`x\\<in>cl(H)\" by auto\n  }\n  then have A2:\"\\<forall>x\\<in>cl(H). GroupInv(G,f)`x\\<in>cl(H)\" by auto\n  from assms have \"H\\<noteq>0\" using group0.group0_3_L5 group0_valid_in_tgroup by auto moreover\n  have \"H\\<subseteq>cl(H)\" using cl_contains_set sub1 by auto ultimately\n  have \"cl(H)\\<noteq>0\" by auto\n  with clHG A2 A1 show ?thesis using group0.group0_3_T3 group0_valid_in_tgroup by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_10",
            "IsarMathLib.TopologicalGroup_ZF_2",
            "IsarMathLib.TopologicalGroup_ZF_1",
            "IsarMathLib.Group_ZF_4"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_3.thy",
        "id": 1981
    },
    "1786": {
        "type": "theorem",
        "text": "text\\<open>The closure of a normal subgroup is normal.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,f,H)\"\n  ",
        "using": [
            "closure_subgroup",
            "assms",
            "IsAnormalSubgroup_def",
            "group0.group0_3_L2",
            "group0_valid_in_tgroup",
            "Top_3_L11(1)",
            "trans_closure",
            "sub1",
            "neg_in_tgroup",
            "trans_closure2",
            "grinv_def",
            "grop_def",
            "top_closure_mono",
            "sub2",
            "group0.group_op_closed[OF",
            "\\<open>g\\<in>G\\<close>]",
            "group0.group_oper_assoc[OF",
            "\\<open>g\\<in>G\\<close>",
            "\\<open>d\\<in>G\\<close>\\<open>(\\<rm>g)\\<in>G\\<close>]",
            "grsub_def",
            "group0.group0_5_L2(2)[OF",
            "group0_valid_in_tgroup]",
            "\\<open>g\\<in>G\\<close>\\<open>d\\<in>G\\<close>",
            "func_imagedef[OF",
            "group0.group0_5_L1(2)[",
            "OF",
            "sub2]",
            "group0.group0_5_L2(1)[OF",
            "\\<open>(\\<rm>g)\\<in>G\\<close>\\<open>g\\<ra>d\\<in>G\\<close>",
            "group0.group0_5_L1(1)[",
            "\\<open>(\\<rm>g)\\<in>G\\<close>]",
            "ss]",
            "A",
            "group0.cont_conj_is_normal[OF",
            "group0_valid_in_tgroup,",
            "of",
            "\"cl(H)\"]"
        ],
        "statement": "theorem (in topgroup) normal_subg:\n  assumes \"IsAnormalSubgroup(G,f,H)\"\n  shows \"IsAnormalSubgroup(G,f,cl(H))\"\n",
        "proof": "proof-\n  have A:\"IsAsubgroup(cl(H),f)\" using closure_subgroup assms unfolding IsAnormalSubgroup_def by auto\n  have sub1:\"H\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup assms unfolding IsAnormalSubgroup_def by auto\n  then have sub2:\"cl(H)\\<subseteq>G\" using Top_3_L11(1) by auto\n  {\n    fix g assume g:\"g\\<in>G\"\n    then have cl1:\"cl(g\\<ltr>H)=g\\<ltr>cl(H)\" using trans_closure sub1 by auto\n    have ss:\"g\\<ltr>cl(H)\\<subseteq>G\" unfolding ltrans_def LeftTranslation_def by auto\n    have \"g\\<ltr>H\\<subseteq>G\" unfolding ltrans_def LeftTranslation_def by auto\n    moreover from g have \"(\\<rm>g)\\<in>G\" using neg_in_tgroup by auto\n    ultimately have cl2:\"cl((g\\<ltr>H)\\<rtr>(\\<rm>g))=cl(g\\<ltr>H)\\<rtr>(\\<rm>g)\" using trans_closure2\n      by auto\n    with cl1 have clcon:\"cl((g\\<ltr>H)\\<rtr>(\\<rm>g))=(g\\<ltr>(cl(H)))\\<rtr>(\\<rm>g)\" by auto\n    {\n      fix r assume \"r\\<in>(g\\<ltr>H)\\<rtr>(\\<rm>g)\"\n      then obtain q where q:\"q\\<in>g\\<ltr>H\" \"r=q\\<ra>(\\<rm>g)\" unfolding rtrans_def RightTranslation_def\n        by force\n      from q(1) obtain h where \"h\\<in>H\" \"q=g\\<ra>h\" unfolding ltrans_def LeftTranslation_def by auto\n      with q(2) have \"r=(g\\<ra>h)\\<ra>(\\<rm>g)\" by auto\n      with \\<open>h\\<in>H\\<close> \\<open>g\\<in>G\\<close> \\<open>(\\<rm>g)\\<in>G\\<close> have \"r\\<in>H\" using assms unfolding IsAnormalSubgroup_def\n        grinv_def grop_def by auto\n    }\n    then have \"(g\\<ltr>H)\\<rtr>(\\<rm>g)\\<subseteq>H\" by auto\n    moreover then have \"(g\\<ltr>H)\\<rtr>(\\<rm>g)\\<subseteq>G\"\"H\\<subseteq>G\" using sub1 by auto ultimately\n    have \"cl((g\\<ltr>H)\\<rtr>(\\<rm>g))\\<subseteq>cl(H)\" using top_closure_mono by auto\n    with clcon have \"(g\\<ltr>(cl(H)))\\<rtr>(\\<rm>g)\\<subseteq>cl(H)\" by auto moreover\n    {\n      fix b assume \"b\\<in>{g\\<ra>(d\\<rs>g). d\\<in>cl(H)}\"\n      then obtain d where d:\"d\\<in>cl(H)\" \"b=g\\<ra>(d\\<rs>g)\" by auto moreover\n      then have \"d\\<in>G\" using sub2 by auto \n      then have \"g\\<ra>d\\<in>G\" using group0.group_op_closed[OF group0_valid_in_tgroup \\<open>g\\<in>G\\<close>] by auto\n      from d(2) have b:\"b=(g\\<ra>d)\\<rs>g\" using group0.group_oper_assoc[OF group0_valid_in_tgroup \\<open>g\\<in>G\\<close> \\<open>d\\<in>G\\<close>\\<open>(\\<rm>g)\\<in>G\\<close>] \n        unfolding grsub_def grop_def grinv_def by blast\n      have \"(g\\<ra>d)=LeftTranslation(G,f,g)`d\" using group0.group0_5_L2(2)[OF group0_valid_in_tgroup]\n        \\<open>g\\<in>G\\<close>\\<open>d\\<in>G\\<close> by auto\n      with \\<open>d\\<in>cl(H)\\<close> have \"g\\<ra>d\\<in>g\\<ltr>cl(H)\" unfolding ltrans_def using func_imagedef[OF group0.group0_5_L1(2)[\n        OF group0_valid_in_tgroup \\<open>g\\<in>G\\<close>] sub2] by auto\n      moreover from b have \"b=RightTranslation(G,f,\\<rm>g)`(g\\<ra>d)\" using group0.group0_5_L2(1)[OF group0_valid_in_tgroup]\n        \\<open>(\\<rm>g)\\<in>G\\<close>\\<open>g\\<ra>d\\<in>G\\<close> by auto\n      ultimately have \"b\\<in>(g\\<ltr>cl(H))\\<rtr>(\\<rm>g)\" unfolding rtrans_def using func_imagedef[OF group0.group0_5_L1(1)[\n        OF group0_valid_in_tgroup \\<open>(\\<rm>g)\\<in>G\\<close>] ss] by force\n    }\n    ultimately have \"{g\\<ra>(d\\<rs>g). d\\<in>cl(H)}\\<subseteq>cl(H)\" by force\n  }\n  then show ?thesis using A group0.cont_conj_is_normal[OF group0_valid_in_tgroup, of \"cl(H)\"]\n    unfolding grsub_def grinv_def grop_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_10",
            "IsarMathLib.TopologicalGroup_ZF_2",
            "IsarMathLib.TopologicalGroup_ZF_1",
            "IsarMathLib.Group_ZF_4"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_3.thy",
        "id": 1982
    },
    "1787": {
        "type": "theorem",
        "text": "text\\<open>Every open subgroup is also closed.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,f)\" \"H\\<in>T\"\n  ",
        "using": [
            "group0.group0_3_L2",
            "group0_valid_in_tgroup",
            "group0.group0_3_L5",
            "open_tr_open(1)",
            "group0.neut_trans_elem",
            "sub",
            "tG",
            "group0.group0_2_L18(1)",
            "grop_def",
            "grinv_def",
            "assms(1)",
            "group0.group0_3_T3A",
            "group0.group0_3_L6",
            "tnH",
            "open_neigh_open"
        ],
        "statement": "theorem (in topgroup) open_subgroup_closed:\n  assumes \"IsAsubgroup(H,f)\" \"H\\<in>T\"\n  shows \"H{is closed in}T\"\n",
        "proof": "proof-\n  from assms(1) have sub:\"H\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup by force\n  {\n    fix t assume \"t\\<in>G-H\"\n    then have tnH:\"t\\<notin>H\" and tG:\"t\\<in>G\" by auto\n    from assms(1) have sub:\"H\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup by force\n    from assms(1) have nSubG:\"\\<zero>\\<in>H\" using group0.group0_3_L5 group0_valid_in_tgroup by auto\n    from assms(2) tG have P:\"t\\<ltr>H\\<in>T\" using open_tr_open(1) by auto\n    from nSubG sub tG have tp:\"t\\<in>t\\<ltr>H\" using group0_valid_in_tgroup group0.neut_trans_elem\n      by auto\n    {\n      fix x assume \"x\\<in>(t\\<ltr>H)\\<inter>H\"\n      then obtain u where \"x=t\\<ra>u\" \"u\\<in>H\" \"x\\<in>H\" unfolding ltrans_def LeftTranslation_def by auto\n      then have \"u\\<in>G\"\"x\\<in>G\"\"t\\<in>G\" using sub tG by auto\n      with \\<open>x=t\\<ra>u\\<close> have \"x\\<ra>(\\<rm>u)=t\" using group0.group0_2_L18(1) group0_valid_in_tgroup\n        unfolding grop_def grinv_def by auto\n      from \\<open>u\\<in>H\\<close> have \"(\\<rm>u)\\<in>H\" unfolding grinv_def using assms(1) group0.group0_3_T3A group0_valid_in_tgroup\n        by auto\n      with \\<open>x\\<in>H\\<close> have \"x\\<ra>(\\<rm>u)\\<in>H\" unfolding grop_def using assms(1) group0.group0_3_L6 group0_valid_in_tgroup\n        by auto\n      with \\<open>x\\<ra>(\\<rm>u)=t\\<close> have \"False\" using tnH by auto\n    }\n    then have \"(t\\<ltr>H)\\<inter>H=0\" by auto moreover\n    have \"t\\<ltr>H\\<subseteq>G\" unfolding ltrans_def LeftTranslation_def by auto ultimately\n    have \"(t\\<ltr>H)\\<subseteq>G-H\" by auto\n    with tp P have \"\\<exists>V\\<in>T. t\\<in>V \\<and> V\\<subseteq>G-H\" unfolding Bex_def by auto\n  }\n  then have \"\\<forall>t\\<in>G-H. \\<exists>V\\<in>T. t\\<in>V \\<and> V\\<subseteq>G-H\" by auto\n  then have \"G-H\\<in>T\" using open_neigh_open by auto\n  then show ?thesis unfolding IsClosed_def using sub by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_10",
            "IsarMathLib.TopologicalGroup_ZF_2",
            "IsarMathLib.TopologicalGroup_ZF_1",
            "IsarMathLib.Group_ZF_4"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_3.thy",
        "id": 1983
    },
    "1788": {
        "type": "theorem",
        "text": "text\\<open>Any subgroup with non-empty interior is open.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,f)\" \"int(H)\\<noteq>0\"\n  ",
        "using": [
            "group0.group0_3_L2",
            "group0_valid_in_tgroup",
            "Top_2_L1",
            "assms(1)",
            "group0.group0_3_T3A",
            "group0.group0_3_L6",
            "intsub",
            "open_tr_open(1)",
            "\\<open>h\\<rs>u\\<in>H\\<close>",
            "Top_2_L2",
            "sub",
            "group0.group0_5_L1(2)",
            "\\<open>(h\\<rs>u)\\<in>G\\<close>",
            "func_imagedef",
            "group0.group0_5_L2(2)",
            "group0.inv_cancel_two(1)",
            "\\<open>u\\<in>G\\<close>\\<open>h\\<in>G\\<close>",
            "open_neigh_open"
        ],
        "statement": "theorem (in topgroup) clopen_or_emptyInt:\n  assumes \"IsAsubgroup(H,f)\" \"int(H)\\<noteq>0\"\n  shows \"H\\<in>T\"\n",
        "proof": "proof-\n  from assms(1) have sub:\"H\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup by force\n  {\n    fix h assume \"h\\<in>H\"\n    have intsub:\"int(H)\\<subseteq>H\" using Top_2_L1 by auto\n    from assms(2) obtain u where \"u\\<in>int(H)\" by auto\n    with intsub have \"u\\<in>H\" by auto\n    then have \"(\\<rm>u)\\<in>H\" unfolding grinv_def using assms(1) group0.group0_3_T3A group0_valid_in_tgroup\n      by auto\n    with \\<open>h\\<in>H\\<close> have \"h\\<rs>u\\<in>H\" unfolding grop_def using assms(1) group0.group0_3_L6 group0_valid_in_tgroup\n      by auto\n    {\n      fix t assume \"t\\<in>(h\\<rs>u)\\<ltr>(int(H))\"\n      then obtain r where \"r\\<in>int(H)\"\"t=(h\\<rs>u)\\<ra>r\" unfolding grsub_def grinv_def grop_def\n        ltrans_def LeftTranslation_def by auto\n      then have \"r\\<in>H\" using intsub by auto\n      with \\<open>h\\<rs>u\\<in>H\\<close> have \"(h\\<rs>u)\\<ra>r\\<in>H\" unfolding grop_def using assms(1) group0.group0_3_L6 group0_valid_in_tgroup\n        by auto\n      with \\<open>t=(h\\<rs>u)\\<ra>r\\<close> have \"t\\<in>H\" by auto\n    }\n    then have ss:\"(h\\<rs>u)\\<ltr>(int(H))\\<subseteq>H\" by auto\n    have P:\"(h\\<rs>u)\\<ltr>(int(H))\\<in>T\" using open_tr_open(1) \\<open>h\\<rs>u\\<in>H\\<close> Top_2_L2 sub by blast\n    from \\<open>h\\<rs>u\\<in>H\\<close>\\<open>u\\<in>H\\<close>\\<open>h\\<in>H\\<close> sub have \"(h\\<rs>u)\\<in>G\" \"u\\<in>G\"\"h\\<in>G\" by auto\n    have \"int(H)\\<subseteq>G\" using sub intsub by auto moreover\n    have \"LeftTranslation(G,f,(h\\<rs>u))\\<in>G\\<rightarrow>G\" using group0.group0_5_L1(2) group0_valid_in_tgroup \\<open>(h\\<rs>u)\\<in>G\\<close>\n      by auto ultimately\n    have \"LeftTranslation(G,f,(h\\<rs>u))``(int(H))={LeftTranslation(G,f,(h\\<rs>u))`r. r\\<in>int(H)}\" \n      using func_imagedef by auto moreover\n    from \\<open>(h\\<rs>u)\\<in>G\\<close> \\<open>u\\<in>G\\<close> have \"LeftTranslation(G,f,(h\\<rs>u))`u=(h\\<rs>u)\\<ra>u\" using group0.group0_5_L2(2) group0_valid_in_tgroup\n      by auto\n    with \\<open>u\\<in>int(H)\\<close> have \"(h\\<rs>u)\\<ra>u\\<in>{LeftTranslation(G,f,(h\\<rs>u))`r. r\\<in>int(H)}\" by force ultimately\n    have \"(h\\<rs>u)\\<ra>u\\<in>(h\\<rs>u)\\<ltr>(int(H))\" unfolding ltrans_def by auto moreover\n    have \"(h\\<rs>u)\\<ra>u=h\" using group0.inv_cancel_two(1) group0_valid_in_tgroup\n      \\<open>u\\<in>G\\<close>\\<open>h\\<in>G\\<close> by auto ultimately\n    have \"h\\<in>(h\\<rs>u)\\<ltr>(int(H))\" by auto\n    with P ss have \"\\<exists>V\\<in>T. h\\<in>V\\<and> V\\<subseteq>H\" unfolding Bex_def by auto\n  }\n  then show ?thesis using open_neigh_open by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_10",
            "IsarMathLib.TopologicalGroup_ZF_2",
            "IsarMathLib.TopologicalGroup_ZF_1",
            "IsarMathLib.Group_ZF_4"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_3.thy",
        "id": 1984
    },
    "1789": {
        "type": "theorem",
        "text": "text\\<open>Every locally-compact subgroup of a $T_0$ group is closed.\\<close>\n",
        "assumes": "assumes \"IsAsubgroup(H,f)\" \"(T{restricted to}H){is locally-compact}\" \"T{is T\\<^sub>0}\"\n  ",
        "using": [
            "closure_subgroup",
            "group0.group0_3_L2",
            "group0_valid_in_tgroup",
            "T1_imp_T2",
            "neu_closed_imp_T1",
            "T0_imp_neu_closed",
            "T2_here",
            "sub",
            "RestrictedTo_def",
            "topology0.locally_compact_exist_compact_neig[of",
            "\"T{restricted",
            "to}H\"]",
            "Top_1_L4",
            "topology0_def",
            "group0.group0_3_L5",
            "assms(1)",
            "gzero_def",
            "compact_subspace_imp_compact",
            "in_t2_compact_is_cl",
            "topology0.Top_2_L2",
            "topology0.Top_2_L1[of",
            "tot",
            "K(2)",
            "IsCompact_def",
            "Top_2_L6",
            "U(1)",
            "ksub",
            "exists_procls_zerohood[of",
            "\"U\\<union>K\"]",
            "group0.group0_3_T3A",
            "subcl",
            "elem_in_int_ltrans",
            "Top_2_L2",
            "cl_inter_neigh",
            "ltrans_interior",
            "Top_2_L1[of",
            "\"V\"]",
            "zerohoods_def",
            "group0.group0_2_L18(2)",
            "grop_def",
            "grinv_def",
            "AS",
            "group0.group_inv_of_inv",
            "y(1)",
            "cl_contains_set",
            "clsub",
            "group0.group0_3_L6",
            "topSpaceAssum",
            "IsATopology_def",
            "cl_inter_neigh[of",
            "\"H\"\"int(V)\\<inter>W\"\"h\\<ra>y\"]",
            "Top_2_L1",
            "hycl",
            "inter_neigh_cl[of",
            "\"K\"\"h\\<ra>y\"]",
            "G_def",
            "Kcl",
            "Top_3_L8",
            "\\<open>K\\<subseteq>G\\<close>",
            "\\<open>(\\<rm>y)\\<in>H\\<close>",
            "\\<open>y\\<in>G\\<close>\\<open>h\\<in>G\\<close>",
            "group0.group_oper_assoc",
            "grsub_def",
            "group0.group0_2_L6",
            "\\<open>y\\<in>G\\<close>",
            "group0.group0_2_L2",
            "\\<open>h\\<in>G\\<close>"
        ],
        "statement": "theorem (in topgroup) loc_compact_T0_closed:\n  assumes \"IsAsubgroup(H,f)\" \"(T{restricted to}H){is locally-compact}\" \"T{is T\\<^sub>0}\"\n  shows \"H{is closed in}T\"\n",
        "proof": "proof-\n  from assms(1) have clsub:\"IsAsubgroup(cl(H),f)\" using closure_subgroup by auto\n  then have subcl:\"cl(H)\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup by force\n  from assms(1) have sub:\"H\\<subseteq>G\" using group0.group0_3_L2 group0_valid_in_tgroup by force\n  from assms(3) have \"T{is T\\<^sub>2}\" using T1_imp_T2 neu_closed_imp_T1 T0_imp_neu_closed by auto\n  then have \"(T{restricted to}H){is T\\<^sub>2}\" using T2_here sub by auto\n  have tot:\"\\<Union>(T{restricted to}H)=H\" using sub unfolding RestrictedTo_def by auto\n  with assms(2) have \"\\<forall>x\\<in>H. \\<exists>A\\<in>Pow(H). A {is compact in} (T{restricted to}H) \\<and> x \\<in> Interior(A, (T{restricted to}H))\" using \n    topology0.locally_compact_exist_compact_neig[of \"T{restricted to}H\"] Top_1_L4 unfolding topology0_def\n    by auto\n  then obtain K where K:\"K\\<subseteq>H\" \"K{is compact in} (T{restricted to}H)\"\"\\<zero>\\<in>Interior(K,(T{restricted to}H))\"\n    using group0.group0_3_L5 group0_valid_in_tgroup assms(1) unfolding gzero_def by force\n  from K(1,2) have \"K{is compact in} T\" using compact_subspace_imp_compact by auto\n  with \\<open>T{is T\\<^sub>2}\\<close> have Kcl:\"K{is closed in}T\" using in_t2_compact_is_cl by auto\n  have \"Interior(K,(T{restricted to}H))\\<in>(T{restricted to}H)\" using topology0.Top_2_L2 unfolding topology0_def\n    using Top_1_L4 by auto\n  then obtain U where U:\"U\\<in>T\"\"Interior(K,(T{restricted to}H))=H\\<inter>U\" unfolding RestrictedTo_def by auto\n  then have \"H\\<inter>U\\<subseteq>K\" using topology0.Top_2_L1[of \"T{restricted to}H\"] unfolding topology0_def using Top_1_L4 by force\n  moreover have U2:\"U\\<subseteq>U\\<union>K\" by auto\n  have ksub:\"K\\<subseteq>H\" using tot K(2) unfolding IsCompact_def by auto\n  ultimately have int:\"H\\<inter>(U\\<union>K)=K\" by auto\n  from U(2) K(3) have \"\\<zero>\\<in>U\" by auto\n  with U(1) U2 have \"\\<zero>\\<in>int(U \\<union> K)\" using Top_2_L6 by auto\n  then have \"U\\<union>K\\<in>\\<N>\\<^sub>0\" unfolding zerohoods_def using U(1) ksub sub by auto\n  then obtain V where V:\"V\\<subseteq>U\\<union>K\" \"V\\<in>\\<N>\\<^sub>0\" \"V\\<sad>V\\<subseteq>U\\<union>K\"\"(\\<sm> V) = V\" using exists_procls_zerohood[of \"U\\<union>K\"]\n    by auto\n  {\n    fix h assume AS:\"h\\<in>cl(H)\"\n    with clsub have \"(\\<rm>h)\\<in>cl(H)\" using group0.group0_3_T3A group0_valid_in_tgroup by auto moreover\n    then have \"(\\<rm>h)\\<in>G\" using subcl by auto\n    with V(2) have \"(\\<rm>h)\\<in>int((\\<rm>h)\\<ltr>V)\" using elem_in_int_ltrans by auto ultimately\n    have \"(\\<rm>h)\\<in>(cl(H))\\<inter>(int((\\<rm>h)\\<ltr>V))\" by auto moreover\n    have \"int((\\<rm>h)\\<ltr>V)\\<in>T\" using Top_2_L2 by auto moreover\n    note sub ultimately\n    have \"H\\<inter>(int((\\<rm>h)\\<ltr>V))\\<noteq>0\" using cl_inter_neigh by auto moreover\n    from \\<open>(\\<rm>h)\\<in>G\\<close> V(2) have \"int((\\<rm>h)\\<ltr>V)=(\\<rm>h)\\<ltr>int(V)\" unfolding zerohoods_def \n      using ltrans_interior by force\n    ultimately have \"H\\<inter>((\\<rm>h)\\<ltr>int(V))\\<noteq>0\" by auto\n    then obtain y where y:\"y\\<in>H\" \"y\\<in>(\\<rm>h)\\<ltr>int(V)\" by blast\n    then obtain v where v:\"v\\<in>int(V)\" \"y=(\\<rm>h)\\<ra>v\" unfolding ltrans_def LeftTranslation_def by auto\n    with \\<open>(\\<rm>h)\\<in>G\\<close> V(2) y(1) sub have \"v\\<in>G\"\"(\\<rm>h)\\<in>G\"\"y\\<in>G\" using Top_2_L1[of \"V\"] unfolding zerohoods_def by auto\n    with v(2) have \"(\\<rm>(\\<rm>h))\\<ra>y=v\" using group0.group0_2_L18(2) group0_valid_in_tgroup\n      unfolding grop_def grinv_def by auto moreover\n    have \"h\\<in>G\" using AS subcl by auto\n    then have \"(\\<rm>(\\<rm>h))=h\" using group0.group_inv_of_inv group0_valid_in_tgroup by auto ultimately\n    have \"h\\<ra>y=v\" by auto\n    with v(1) have hyV:\"h\\<ra>y\\<in>int(V)\" by auto\n    have \"y\\<in>cl(H)\" using y(1) cl_contains_set sub by auto\n    with AS have hycl:\"h\\<ra> y\\<in>cl(H)\" using clsub group0.group0_3_L6 group0_valid_in_tgroup by auto\n    {\n      fix W assume W:\"W\\<in>T\"\"h\\<ra>y\\<in>W\"\n      with hyV have \"h\\<ra>y\\<in>int(V)\\<inter>W\" by auto moreover\n      from W(1) have \"int(V)\\<inter>W\\<in>T\" using Top_2_L2 topSpaceAssum unfolding IsATopology_def by auto moreover\n      note hycl sub\n      ultimately have \"(int(V)\\<inter>W)\\<inter>H\\<noteq>0\" using cl_inter_neigh[of \"H\"\"int(V)\\<inter>W\"\"h\\<ra>y\"] by auto\n      then have \"V\\<inter>W\\<inter>H\\<noteq>0\" using Top_2_L1 by auto\n      with V(1) have \"(U\\<union>K)\\<inter>W\\<inter>H\\<noteq>0\" by auto\n      then have \"(H\\<inter>(U\\<union>K))\\<inter>W\\<noteq>0\" by auto\n      with int have \"K\\<inter>W\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>W\\<in>T. h\\<ra>y\\<in>W \\<longrightarrow> K\\<inter>W\\<noteq>0\" by auto moreover\n    have \"K\\<subseteq>G\" \"h\\<ra>y\\<in>G\" using ksub sub hycl subcl by auto ultimately\n    have \"h\\<ra>y\\<in>cl(K)\" using inter_neigh_cl[of \"K\"\"h\\<ra>y\"] unfolding G_def by force\n    then have \"h\\<ra>y\\<in>K\" using Kcl Top_3_L8 \\<open>K\\<subseteq>G\\<close> by auto\n    with ksub have \"h\\<ra>y\\<in>H\" by auto\n    moreover from y(1) have \"(\\<rm>y)\\<in>H\" using group0.group0_3_T3A assms(1) group0_valid_in_tgroup\n      by auto\n    ultimately have \"(h\\<ra>y)\\<rs>y\\<in>H\" unfolding grsub_def using group0.group0_3_L6 group0_valid_in_tgroup\n      assms(1) by auto\n    moreover \n    have \"(\\<rm>y)\\<in>G\" using \\<open>(\\<rm>y)\\<in>H\\<close> sub by auto\n    then have \"h\\<ra>(y\\<rs>y)=(h\\<ra>y)\\<rs>y\" using \\<open>y\\<in>G\\<close>\\<open>h\\<in>G\\<close> group0.group_oper_assoc\n      group0_valid_in_tgroup unfolding grsub_def by auto\n    then have \"h\\<ra>\\<zero>=(h\\<ra>y)\\<rs>y\" using group0.group0_2_L6 group0_valid_in_tgroup \\<open>y\\<in>G\\<close>\n      unfolding grsub_def grinv_def grop_def gzero_def by auto\n    then have \"h=(h\\<ra>y)\\<rs>y\" using group0.group0_2_L2 group0_valid_in_tgroup\n      \\<open>h\\<in>G\\<close> unfolding gzero_def by auto\n    ultimately have \"h\\<in>H\" by auto\n  }\n  then have \"cl(H)\\<subseteq>H\" by auto\n  then have \"H=cl(H)\" using cl_contains_set sub by auto\n  then show ?thesis using Top_3_L8 sub by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_10",
            "IsarMathLib.TopologicalGroup_ZF_2",
            "IsarMathLib.TopologicalGroup_ZF_1",
            "IsarMathLib.Group_ZF_4"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF_3.thy",
        "id": 1985
    },
    "1790": {
        "type": "definition",
        "text": "text\\<open>Topology is a collection of sets that is closed under arbitrary unions and intersections \n  of two sets.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsATopology (\"_ {is a topology}\" [90] 91) where\n  \"T {is a topology} \\<equiv> ( \\<forall>M \\<in> Pow(T). \\<Union>M \\<in> T ) \\<and> \n  ( \\<forall>U\\<in>T. \\<forall> V\\<in>T. U\\<inter>V \\<in> T)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1986
    },
    "1791": {
        "type": "definition",
        "text": "text\\<open>We define interior of a set $A$ as the union of all open sets \n  contained in $A$. We use \\<open>Interior(A,T)\\<close> to denote the \n  interior of A.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Interior(A,T) \\<equiv> \\<Union> {U\\<in>T. U \\<subseteq> A}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1987
    },
    "1792": {
        "type": "definition",
        "text": "text\\<open>A set is closed if it is contained in the carrier of topology\n  and its complement is open.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsClosed (infixl \"{is closed in}\" 90) where\n  \"D {is closed in} T \\<equiv> (D \\<subseteq> \\<Union>T \\<and> \\<Union>T - D \\<in> T)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1988
    },
    "1793": {
        "type": "definition",
        "text": "text\\<open>To prove various properties of closure we will often use \n  the collection of  closed sets that contain a given set $A$. \n  Such collection does not have a separate\n  name in informal math. We will call it \\<open>ClosedCovers(A,T)\\<close>. \n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ClosedCovers(A,T) \\<equiv> {D \\<in> Pow(\\<Union>T). D {is closed in} T \\<and> A\\<subseteq>D}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1989
    },
    "1794": {
        "type": "definition",
        "text": "text\\<open>The closure of a set $A$ is defined as the intersection of the collection\n  of closed sets that contain $A$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Closure(A,T) \\<equiv> \\<Inter> ClosedCovers(A,T)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1990
    },
    "1795": {
        "type": "definition",
        "text": "text\\<open>We also define boundary  of a set as the intersection of \n  its closure with the closure of the complement (with respect to the \n  carrier).\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Boundary(A,T) \\<equiv> Closure(A,T) \\<inter> Closure(\\<Union>T - A,T)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1991
    },
    "1796": {
        "type": "definition",
        "text": "text\\<open>A set $K$ is compact if for every collection of open \n  sets that covers $K$ we can choose a finite one that still covers the set. \n  Recall that \\<open>FinPow(M)\\<close> is the collection of finite subsets of $M$ \n  (finite powerset of $M$), defined in IsarMathLib's \\<open>Finite_ZF\\<close>\n  theory.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsCompact (infixl \"{is compact in}\" 90) where\n  \"K {is compact in} T \\<equiv> (K \\<subseteq> \\<Union>T \\<and> \n  (\\<forall> M\\<in>Pow(T). K \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists> N \\<in> FinPow(M). K \\<subseteq> \\<Union>N)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1992
    },
    "1797": {
        "type": "lemma",
        "text": "text\\<open>A basic example of a topology: the powerset of any set is a topology.\\<close>\n",
        "assumes": "",
        "using": [
            "IsATopology_def"
        ],
        "statement": "lemma Pow_is_top: shows \"Pow(X) {is a topology}\"\n",
        "proof": "proof -\n  have \"\\<forall>A\\<in>Pow(Pow(X)). \\<Union>A \\<in> Pow(X)\" by fast\n  moreover have \"\\<forall>U\\<in>Pow(X). \\<forall>V\\<in>Pow(X). U\\<inter>V \\<in> Pow(X)\" by fast\n  ultimately show \"Pow(X) {is a topology}\" using IsATopology_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1993
    },
    "1798": {
        "type": "lemma",
        "text": "text\\<open>Empty set is open.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\" ",
        "using": [
            "IsATopology_def"
        ],
        "statement": "lemma empty_open: \n  assumes \"T {is a topology}\" shows \"0 \\<in> T\"\n",
        "proof": "proof -\n  have \"0 \\<in> Pow(T)\" by simp\n  with assms have \"\\<Union>0 \\<in> T\" using IsATopology_def by blast\n  thus \"0 \\<in> T\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1994
    },
    "1799": {
        "type": "lemma",
        "text": "text\\<open>Singletons are compact. Interestingly we do not have\n  to assume that $T$ is a topology for this.\n  Note singletons do not have to be closed, we need the\n  the space to be $T_1$ for that (see \\<open>Topology_ZF_1)\\<close>. \\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\" ",
        "using": [
            "assms",
            "singleton_in_finpow",
            "IsCompact_def"
        ],
        "statement": "lemma singl_compact: \n  assumes \"x\\<in>\\<Union>T\" shows \"{x} {is compact in} T\"\n  ",
        "proof": "using assms singleton_in_finpow unfolding IsCompact_def\n  by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1995
    },
    "1800": {
        "type": "lemma",
        "text": "text\\<open>Intersection of a finite nonempty collection of open sets is open.\\<close>\n",
        "assumes": "assumes \"N\\<noteq>0\" \"N \\<in> FinPow(T)\"\n  ",
        "using": [
            "topSpaceAssum",
            "assms",
            "IsATopology_def",
            "inter_two_inter_fin"
        ],
        "statement": "lemma (in topology0) fin_inter_open_open: assumes \"N\\<noteq>0\" \"N \\<in> FinPow(T)\"\n  shows \"\\<Inter>N \\<in> T\"\n  ",
        "proof": "using topSpaceAssum assms IsATopology_def inter_two_inter_fin \n  by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1996
    },
    "1801": {
        "type": "lemma",
        "text": "text\\<open>Having a topology $T$ and a set $X$ we can \n  define the induced topology \n  as the one consisting of the intersections of $X$ with sets from $T$.\n  The notion of a collection restricted to a set is defined in ZF1.thy.\\<close>\n",
        "assumes": "",
        "using": [
            "IsATopology_def",
            "RestrictedTo_def"
        ],
        "statement": "lemma (in topology0) Top_1_L4: \n  shows \"(T {restricted to} X) {is a topology}\"\n",
        "proof": "proof -\n  let ?S = \"T {restricted to} X\"\n  have \"\\<forall>A\\<in>Pow(?S). \\<Union>A \\<in> ?S\"\n  proof\n    fix A assume A1: \"A\\<in>Pow(?S)\"\n    have \"\\<forall>V\\<in>A. \\<Union> {U \\<in> T. V = U\\<inter>X} \\<in> T\"\n    proof -\n      { fix V\n\tlet ?M = \"{U \\<in> T. V = U\\<inter>X}\"\n\thave \"?M \\<in> Pow(T)\" by auto\n\twith topSpaceAssum have \"\\<Union>?M \\<in> T\" using IsATopology_def by simp\n      } thus ?thesis by simp\n    qed\n    hence \"{\\<Union>{U\\<in>T. V = U\\<inter>X}.V\\<in> A} \\<subseteq> T\" by auto\n    with topSpaceAssum have \"(\\<Union>V\\<in>A. \\<Union>{U\\<in>T. V = U\\<inter>X}) \\<in> T\"\n      using IsATopology_def by auto\n    then have \"(\\<Union>V\\<in>A. \\<Union>{U\\<in>T. V = U\\<inter>X})\\<inter> X \\<in> ?S\"\n      using RestrictedTo_def by auto\n    moreover\n    from A1 have \"\\<forall>V\\<in>A. \\<exists>U\\<in>T. V = U\\<inter>X\"\n      using RestrictedTo_def by auto\n    hence \"(\\<Union>V\\<in>A. \\<Union>{U\\<in>T. V = U\\<inter>X})\\<inter>X = \\<Union>A\" by blast\n    ultimately show \"\\<Union>A \\<in> ?S\" by simp\n  qed\n  moreover have  \"\\<forall>U\\<in>?S. \\<forall>V\\<in>?S. U\\<inter>V \\<in> ?S\"\n  proof -\n    { fix U V assume \"U\\<in>?S\"  \"V\\<in>?S\"\n      then obtain U\\<^sub>1 V\\<^sub>1 where \n\t\"U\\<^sub>1 \\<in> T \\<and> U = U\\<^sub>1\\<inter>X\" and \"V\\<^sub>1 \\<in> T \\<and> V = V\\<^sub>1\\<inter>X\"\n\tusing RestrictedTo_def by auto\n      with topSpaceAssum have \"U\\<^sub>1\\<inter>V\\<^sub>1 \\<in> T\" and \"U\\<inter>V = (U\\<^sub>1\\<inter>V\\<^sub>1)\\<inter>X\"\n\tusing IsATopology_def by auto\n      then have \" U\\<inter>V \\<in> ?S\" using RestrictedTo_def by auto\n    } thus \"\\<forall>U\\<in>?S. \\<forall> V\\<in>?S. U\\<inter>V \\<in> ?S\"\n      by simp\n  qed\n  ultimately show \"?S {is a topology}\" using IsATopology_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1997
    },
    "1802": {
        "type": "lemma",
        "text": "text\\<open>Interior of a set $A$ is contained in $A$.\\<close>\n",
        "assumes": "",
        "using": [
            "Interior_def"
        ],
        "statement": "lemma (in topology0) Top_2_L1: shows \"int(A) \\<subseteq> A\"\n  ",
        "proof": "using Interior_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1998
    },
    "1803": {
        "type": "lemma",
        "text": "text\\<open>A set is open iff it is equal to its interior.\\<close>\n",
        "assumes": "",
        "using": [
            "Interior_def",
            "Top_2_L2"
        ],
        "statement": "lemma (in topology0) Top_2_L3: shows \"U\\<in>T \\<longleftrightarrow> int(U) = U\"\n",
        "proof": "proof\n  assume \"U\\<in>T\" then show \"int(U) = U\"\n    using Interior_def by auto\nnext assume A1: \"int(U) = U\"\n  have \"int(U) \\<in> T\" using Top_2_L2 by simp\n  with A1 show \"U\\<in>T\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2000
    },
    "1804": {
        "type": "lemma",
        "text": "text\\<open>Interior of the interior is the interior.\\<close>\n",
        "assumes": "",
        "using": [
            "Top_2_L2",
            "Top_2_L3"
        ],
        "statement": "lemma (in topology0) Top_2_L4: shows \"int(int(A)) = int(A)\"\n",
        "proof": "proof -\n  let ?U = \"int(A)\"\n  from topSpaceAssum have \"?U\\<in>T\" using Top_2_L2 by simp\n  then show \"int(int(A)) = int(A)\" using Top_2_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2001
    },
    "1805": {
        "type": "lemma",
        "text": "text\\<open>Interior of a bigger set is bigger.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>B\" ",
        "using": [
            "Interior_def"
        ],
        "statement": "lemma (in topology0) interior_mono: \n  assumes A1: \"A\\<subseteq>B\" shows \"int(A) \\<subseteq> int(B)\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall> U\\<in>T. (U\\<subseteq>A \\<longrightarrow> U\\<subseteq>B)\" by auto\n  then show \"int(A) \\<subseteq> int(B)\" using Interior_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2002
    },
    "1806": {
        "type": "lemma",
        "text": "text\\<open>An open subset of any set is a subset of the interior of that set.\\<close>\n",
        "assumes": "assumes \"U\\<subseteq>A\" and \"U\\<in>T\"\n  ",
        "using": [
            "assms",
            "Interior_def"
        ],
        "statement": "lemma (in topology0) Top_2_L5: assumes \"U\\<subseteq>A\" and \"U\\<in>T\"\n  shows \"U \\<subseteq> int(A)\"\n  ",
        "proof": "using assms Interior_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2003
    },
    "1807": {
        "type": "lemma",
        "text": "text\\<open>If a point of a set has an open neighboorhood contained in the set,\n  then the point belongs to the interior of the set.\\<close>\n",
        "assumes": "assumes \"\\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>A)\"\n  ",
        "using": [
            "assms",
            "Interior_def"
        ],
        "statement": "lemma (in topology0) Top_2_L6:  assumes \"\\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>A)\"\n  shows \"x \\<in> int(A)\"\n  ",
        "proof": "using assms Interior_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2004
    },
    "1808": {
        "type": "lemma",
        "text": "text\\<open>A set is open iff its every point has a an open neighbourhood \n  contained in the set. We will formulate this statement as two lemmas\n  (implication one way and the other way).\n  The lemma below shows that if a set is open then every point has a \n  an open neighbourhood contained in the set.\\<close>\n",
        "assumes": "assumes A1: \"V\\<in>T\" \n  ",
        "using": [],
        "statement": "lemma (in topology0) open_open_neigh: \n  assumes A1: \"V\\<in>T\" \n  shows \"\\<forall>x\\<in>V. \\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>V)\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall>x\\<in>V. V\\<in>T \\<and> x \\<in> V \\<and> V \\<subseteq> V\" by simp\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2005
    },
    "1809": {
        "type": "lemma",
        "text": "text\\<open>If every point of a set has a an open neighbourhood \n  contained in the set then the set is open.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>V. \\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>V)\" \n  ",
        "using": [
            "Top_2_L1",
            "Top_2_L6",
            "Top_2_L3"
        ],
        "statement": "lemma (in topology0) open_neigh_open: \n  assumes A1: \"\\<forall>x\\<in>V. \\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>V)\" \n  shows \"V\\<in>T\"\n",
        "proof": "proof -\n  from A1 have \"V = int(V)\" using Top_2_L1 Top_2_L6 \n    by blast\n  then show \"V\\<in>T\" using Top_2_L3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2006
    },
    "1810": {
        "type": "lemma",
        "text": "text\\<open>The intersection of interiors is a equal to the interior of intersections.\\<close>\n",
        "assumes": "",
        "using": [
            "Top_2_L1",
            "Top_2_L2",
            "IsATopology_def",
            "topSpaceAssum",
            "Top_2_L5",
            "interior_mono"
        ],
        "statement": "lemma (in topology0) int_inter_int: shows \"int(A) \\<inter> int(B) = int(A\\<inter>B)\"\n",
        "proof": "proof\n  have \"int(A) \\<inter> int(B) \\<subseteq> A\\<inter>B\" using Top_2_L1 by auto  \n  moreover have \"int(A) \\<inter> int(B) \\<in> T\" using Top_2_L2 IsATopology_def topSpaceAssum \n    by auto\n  ultimately show \"int(A) \\<inter> int(B) \\<subseteq> int(A\\<inter>B)\" using Top_2_L5 by simp\n  have \"A\\<inter>B \\<subseteq> A\" and \"A\\<inter>B \\<subseteq> B\" by auto \n  then have \"int(A\\<inter>B) \\<subseteq> int(A)\" and \"int(A\\<inter>B) \\<subseteq> int(B)\" using interior_mono by auto\n  thus \"int(A\\<inter>B) \\<subseteq> int(A) \\<inter> int(B)\" by auto\nqed \n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2007
    },
    "1811": {
        "type": "lemma",
        "text": "text\\<open>The carrier of the space is closed.\\<close>\n",
        "assumes": "",
        "using": [
            "IsATopology_def",
            "IsClosed_def"
        ],
        "statement": "lemma (in topology0) Top_3_L1: shows \"(\\<Union>T) {is closed in} T\"\n",
        "proof": "proof -\n  have \"\\<Union>T - \\<Union>T = 0\" by auto\n  with topSpaceAssum have \"\\<Union>T - \\<Union>T \\<in> T\" using IsATopology_def by auto\n  then show ?thesis using IsClosed_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2008
    },
    "1812": {
        "type": "lemma",
        "text": "text\\<open>Empty set is closed.\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "IsATopology_def",
            "IsClosed_def"
        ],
        "statement": "lemma (in topology0) Top_3_L2: shows \"0 {is closed in} T\"\n  ",
        "proof": "using topSpaceAssum  IsATopology_def IsClosed_def by simp\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2009
    },
    "1813": {
        "type": "lemma",
        "text": "text\\<open>The collection of closed covers of a subset of the carrier of topology\n  is never empty. This is good to know, as we want to intersect this collection\n  to get the closure.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\" ",
        "using": [
            "ClosedCovers_def",
            "Top_3_L1"
        ],
        "statement": "lemma (in topology0) Top_3_L3: \n  assumes A1: \"A \\<subseteq> \\<Union>T\" shows \"ClosedCovers(A,T) \\<noteq> 0\"\n",
        "proof": "proof -\n  from A1 have \"\\<Union>T \\<in> ClosedCovers(A,T)\" using ClosedCovers_def Top_3_L1\n    by auto\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2010
    },
    "1814": {
        "type": "lemma",
        "text": "text\\<open>Intersection of a nonempty family of closed sets is closed.\\<close>\n",
        "assumes": "assumes A1: \"K\\<noteq>0\" and\n  A2: \"\\<forall>D\\<in>K. D {is closed in} T\"\n  ",
        "using": [
            "IsClosed_def",
            "IsATopology_def"
        ],
        "statement": "lemma (in topology0) Top_3_L4: assumes A1: \"K\\<noteq>0\" and\n  A2: \"\\<forall>D\\<in>K. D {is closed in} T\"\n  shows \"(\\<Inter>K) {is closed in} T\"\n",
        "proof": "proof -\n  from A2 have I: \"\\<forall>D\\<in>K. (D \\<subseteq> \\<Union>T \\<and> (\\<Union>T - D)\\<in> T)\"\n    using IsClosed_def by simp\n  then have \"{\\<Union>T - D. D\\<in> K} \\<subseteq> T\" by auto\n  with topSpaceAssum have \"(\\<Union> {\\<Union>T - D. D\\<in> K}) \\<in> T\" \n    using IsATopology_def by auto\n  moreover from A1 have \"\\<Union> {\\<Union>T - D. D\\<in> K} = \\<Union>T - \\<Inter>K\" by fast\n  moreover from A1 I have \"\\<Inter>K \\<subseteq> \\<Union>T\" by blast\n  ultimately show \"(\\<Inter>K) {is closed in} T\" using  IsClosed_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2011
    },
    "1815": {
        "type": "lemma",
        "text": "text\\<open>The union and intersection of two closed sets are closed.\\<close>\n",
        "assumes": "assumes A1: \"D\\<^sub>1 {is closed in} T\"   \"D\\<^sub>2 {is closed in} T\"\n  ",
        "using": [
            "Top_3_L4",
            "IsClosed_def",
            "IsATopology_def"
        ],
        "statement": "lemma (in topology0) Top_3_L5:\n  assumes A1: \"D\\<^sub>1 {is closed in} T\"   \"D\\<^sub>2 {is closed in} T\"\n  shows \n  \"(D\\<^sub>1\\<inter>D\\<^sub>2) {is closed in} T\"\n  \"(D\\<^sub>1\\<union>D\\<^sub>2) {is closed in} T\"\n",
        "proof": "proof -\n  have \"{D\\<^sub>1,D\\<^sub>2} \\<noteq> 0\" by simp\n  with A1 have \"(\\<Inter> {D\\<^sub>1,D\\<^sub>2}) {is closed in} T\" using Top_3_L4\n    by fast\n  thus \"(D\\<^sub>1\\<inter>D\\<^sub>2) {is closed in} T\" by simp\n  from topSpaceAssum A1 have \"(\\<Union>T - D\\<^sub>1) \\<inter> (\\<Union>T - D\\<^sub>2) \\<in> T\"\n    using IsClosed_def IsATopology_def by simp\n  moreover have \"(\\<Union>T - D\\<^sub>1) \\<inter> (\\<Union>T - D\\<^sub>2) = \\<Union>T - (D\\<^sub>1 \\<union> D\\<^sub>2)\" \n    by auto\n  moreover from A1 have \"D\\<^sub>1 \\<union> D\\<^sub>2 \\<subseteq> \\<Union>T\" using IsClosed_def\n    by auto\n  ultimately show \"(D\\<^sub>1\\<union>D\\<^sub>2) {is closed in} T\" using IsClosed_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2012
    },
    "1816": {
        "type": "lemma",
        "text": "text\\<open>Finite union of closed sets is closed. To understand the proof \n  recall that $D\\in$\\<open>Pow(\\<Union>T)\\<close> means\n  that $D$ is a subset of the carrier of the topology.\\<close> \n",
        "assumes": "assumes \n  A1: \"N \\<in> FinPow({D\\<in>Pow(\\<Union>T). D {is closed in} T})\"\n  ",
        "using": [
            "Top_3_L2",
            "Top_3_L5"
        ],
        "statement": "lemma (in topology0) fin_union_cl_is_cl: \n  assumes \n  A1: \"N \\<in> FinPow({D\\<in>Pow(\\<Union>T). D {is closed in} T})\"\n  shows \"(\\<Union>N) {is closed in} T\"\n",
        "proof": "proof -\n  let ?C = \"{D\\<in>Pow(\\<Union>T). D {is closed in} T}\"\n  have \"0\\<in>?C\" using Top_3_L2 by simp\n  moreover have \"\\<forall>A\\<in>?C. \\<forall>B\\<in>?C. A\\<union>B \\<in> ?C\"\n    using Top_3_L5 by auto\n  moreover note A1\n  ultimately have \"\\<Union>N \\<in> ?C\" by (rule union_two_union_fin)\n  thus \"(\\<Union>N) {is closed in} T\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2013
    },
    "1817": {
        "type": "lemma",
        "text": "text\\<open>Closure of a bigger sets is bigger.\\<close>\n",
        "assumes": "assumes A1: \"B \\<subseteq> \\<Union>T\"  and A2:\"A\\<subseteq>B\"\n  ",
        "using": [
            "ClosedCovers_def",
            "Top_3_L3",
            "Closure_def"
        ],
        "statement": "lemma (in topology0) top_closure_mono: \n  assumes A1: \"B \\<subseteq> \\<Union>T\"  and A2:\"A\\<subseteq>B\"\n  shows \"cl(A) \\<subseteq> cl(B)\"\n",
        "proof": "proof -\n  from A2 have \"ClosedCovers(B,T)\\<subseteq> ClosedCovers(A,T)\" \n    using ClosedCovers_def by auto\n  with A1 show ?thesis using Top_3_L3 Closure_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2015
    },
    "1818": {
        "type": "lemma",
        "text": "text\\<open>Boundary of a set is closed.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\" ",
        "using": [
            "cl_is_closed",
            "Top_3_L5",
            "Boundary_def"
        ],
        "statement": "lemma (in topology0) boundary_closed: \n  assumes A1: \"A \\<subseteq> \\<Union>T\" shows \"\\<partial>A {is closed in} T\"\n",
        "proof": "proof -\n  from A1 have \"\\<Union>T - A \\<subseteq> \\<Union>T\" by fast\n  with A1 show \"\\<partial>A {is closed in} T\"\n    using cl_is_closed Top_3_L5 Boundary_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2016
    },
    "1819": {
        "type": "lemma",
        "text": "text\\<open>A set is closed iff it is equal to its closure.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\"\n  ",
        "using": [
            "Closure_def",
            "ClosedCovers_def",
            "cl_is_closed",
            "IsClosed_def"
        ],
        "statement": "lemma (in topology0) Top_3_L8: assumes A1: \"A \\<subseteq> \\<Union>T\"\n  shows \"A {is closed in} T \\<longleftrightarrow> cl(A) = A\"\n",
        "proof": "proof\n  assume \"A {is closed in} T\"\n  with A1 show \"cl(A) = A\"\n    using Closure_def ClosedCovers_def by auto\nnext assume \"cl(A) = A\"\n  then have \"\\<Union>T - A = \\<Union>T - cl(A)\" by simp\n  with A1 show \"A {is closed in} T\" using cl_is_closed IsClosed_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2017
    },
    "1820": {
        "type": "lemma",
        "text": "text\\<open>Complement of an open set is closed.\\<close>\n",
        "assumes": "assumes A1: \"A\\<in>T\" \n  ",
        "using": [
            "IsATopology_def",
            "IsClosed_def"
        ],
        "statement": "lemma (in topology0) Top_3_L9: assumes A1: \"A\\<in>T\" \n  shows \"(\\<Union>T - A) {is closed in} T\"\n",
        "proof": "proof -\n  from topSpaceAssum A1 have \"\\<Union>T - (\\<Union>T - A) = A\" and \"\\<Union>T - A \\<subseteq> \\<Union>T\"\n    using IsATopology_def by auto\n  with A1 show \"(\\<Union>T - A) {is closed in} T\" using IsClosed_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2018
    },
    "1821": {
        "type": "lemma",
        "text": "text\\<open>A set is contained in its closure.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<Union>T\" ",
        "using": [
            "assms",
            "Top_3_L1",
            "ClosedCovers_def",
            "Top_3_L3",
            "Closure_def"
        ],
        "statement": "lemma (in topology0) cl_contains_set: assumes \"A \\<subseteq> \\<Union>T\" shows \"A \\<subseteq> cl(A)\"\n  ",
        "proof": "using assms Top_3_L1 ClosedCovers_def Top_3_L3 Closure_def by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2019
    },
    "1822": {
        "type": "lemma",
        "text": "text\\<open>Boundary of a set is the closure of the set \n  minus the interior of the set.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\"\n  ",
        "using": [
            "Boundary_def",
            "Top_3_L11"
        ],
        "statement": "lemma (in topology0) Top_3_L12: assumes A1: \"A \\<subseteq> \\<Union>T\"\n  shows \"\\<partial>A = cl(A) - int(A)\"\n",
        "proof": "proof -\n  from A1 have \"\\<partial>A = cl(A) \\<inter> (\\<Union>T - int(A))\" \n    using Boundary_def Top_3_L11 by simp\n  moreover from A1 have \n    \"cl(A) \\<inter> (\\<Union>T - int(A)) = cl(A) - int(A)\" \n    using Top_3_L11 by blast\n  ultimately show \"\\<partial>A = cl(A) - int(A)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2021
    },
    "1823": {
        "type": "lemma",
        "text": "text\\<open>If a set $A$ is contained in a closed set $B$, then the closure of $A$ \n  is contained in $B$.\\<close>\n",
        "assumes": "assumes A1: \"B {is closed in} T\"   \"A\\<subseteq>B\"\n  ",
        "using": [
            "IsClosed_def",
            "ClosedCovers_def",
            "Closure_def"
        ],
        "statement": "lemma (in topology0) Top_3_L13: \n  assumes A1: \"B {is closed in} T\"   \"A\\<subseteq>B\"\n  shows \"cl(A) \\<subseteq> B\"\n",
        "proof": "proof -\n  from A1 have \"B \\<subseteq> \\<Union>T\" using IsClosed_def by simp \n  with A1 show \"cl(A) \\<subseteq> B\" using ClosedCovers_def Closure_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2022
    },
    "1824": {
        "type": "lemma",
        "text": "text\\<open>If a set is disjoint with an open set, then we can close it\n  and it will still be disjoint.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\"  \"V\\<in>T\" and  A2: \"A\\<inter>V = 0\"\n  ",
        "using": [
            "Top_3_L9",
            "Top_3_L13",
            "cl_is_closed",
            "IsClosed_def"
        ],
        "statement": "lemma (in topology0) disj_open_cl_disj:\n  assumes A1: \"A \\<subseteq> \\<Union>T\"  \"V\\<in>T\" and  A2: \"A\\<inter>V = 0\"\n  shows \"cl(A) \\<inter> V = 0\"\n",
        "proof": "proof -\n  from assms have \"A \\<subseteq> \\<Union>T - V\" by auto\n  moreover from A1 have \"(\\<Union>T - V) {is closed in} T\" using Top_3_L9 by simp\n  ultimately have \"cl(A) - (\\<Union>T - V) = 0\" \n    using Top_3_L13 by blast\n  moreover from A1 have \"cl(A) \\<subseteq> \\<Union>T\" using cl_is_closed IsClosed_def by simp\n  then have \"cl(A) -(\\<Union>T - V) = cl(A) \\<inter> V\" by auto\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2023
    },
    "1825": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of \\<open>disj_open_cl_disj\\<close>:\n  If a point belongs to the closure of a set, then we can find a point\n  from the set in any open neighboorhood of the point.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<Union>T\" and \"U\\<in>T\" and \"x \\<in> cl(A) \\<inter> U\"\n  ",
        "using": [
            "assms",
            "disj_open_cl_disj"
        ],
        "statement": "lemma (in topology0) cl_inter_neigh:\n  assumes \"A \\<subseteq> \\<Union>T\" and \"U\\<in>T\" and \"x \\<in> cl(A) \\<inter> U\"\n  shows \"A\\<inter>U \\<noteq> 0\" ",
        "proof": "using assms disj_open_cl_disj by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2024
    },
    "1826": {
        "type": "lemma",
        "text": "text\\<open>A reverse of  \\<open>cl_inter_neigh\\<close>: if every open neiboorhood of a point\n  has a nonempty intersection with a set, then that point belongs to the closure\n  of the set.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\" and A2: \"x\\<in>\\<Union>T\" and A3: \"\\<forall>U\\<in>T. x\\<in>U \\<longrightarrow> U\\<inter>A \\<noteq> 0\"\n  ",
        "using": [
            "Top_3_L3",
            "Closure_def",
            "ClosedCovers_def"
        ],
        "statement": "lemma (in topology0) inter_neigh_cl:\n  assumes A1: \"A \\<subseteq> \\<Union>T\" and A2: \"x\\<in>\\<Union>T\" and A3: \"\\<forall>U\\<in>T. x\\<in>U \\<longrightarrow> U\\<inter>A \\<noteq> 0\"\n  shows \"x \\<in> cl(A)\"\n",
        "proof": "proof -\n  { assume \"x \\<notin> cl(A)\"\n    with A1 obtain D where \"D {is closed in} T\" and \"A\\<subseteq>D\" and \"x\\<notin>D\"\n      using Top_3_L3 Closure_def ClosedCovers_def by auto\n    let ?U = \"(\\<Union>T) - D\"\n    from A2 \\<open>D {is closed in} T\\<close> \\<open>x\\<notin>D\\<close> \\<open>A\\<subseteq>D\\<close> have \"?U\\<in>T\" \"x\\<in>?U\" and \"?U\\<inter>A = 0\"\n      unfolding IsClosed_def by auto\n    with A3 have False by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2025
    },
    "1827": {
        "type": "definition",
        "text": "text\\<open>A topology on $X$ is $T_0$ if for every pair of distinct points of $X$\n  there is an open set that contains only one of them.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  isT0 (\"_ {is T\\<^sub>0}\" [90] 91) where\n  \"T {is T\\<^sub>0} \\<equiv> \\<forall> x y. ((x \\<in> \\<Union>T \\<and> y \\<in> \\<Union>T \\<and>  x\\<noteq>y) \\<longrightarrow> \n  (\\<exists>U\\<in>T. (x\\<in>U \\<and> y\\<notin>U) \\<or> (y\\<in>U \\<and> x\\<notin>U)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2026
    },
    "1828": {
        "type": "definition",
        "text": "text\\<open>A topology is $T_2$ (Hausdorff) if for every pair of points there exist a \n  pair of disjoint open sets each containing one of the points. \n  This is an important class of topological spaces. In particular, metric \n  spaces are Hausdorff.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  isT2 (\"_ {is T\\<^sub>2}\" [90] 91) where\n  \"T {is T\\<^sub>2} \\<equiv> \\<forall> x y. ((x \\<in> \\<Union>T \\<and> y \\<in> \\<Union>T \\<and>  x\\<noteq>y) \\<longrightarrow>\n  (\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2029
    },
    "1829": {
        "type": "definition",
        "text": "text\\<open>A topology is regular if every closed set can be separated from a point in its complement\n  by (disjoint) opens sets.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsRegular (\"_ {is regular}\" 90)\n  where \"T {is regular} \\<equiv> \\<forall>D. D {is closed in} T \\<longrightarrow> (\\<forall>x\\<in>\\<Union>T-D.\\<exists>U\\<in>T.\\<exists>V\\<in>T. D\\<subseteq>U\\<and>x\\<in>V\\<and>U\\<inter>V=0)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2030
    },
    "1830": {
        "type": "lemma",
        "text": "text\\<open>Some sources (e.g. Metamath) use a different definition of regularity: \n  any open neighborhood has a closed subneighborhood. The next lemma shows the equivalence\n  of this with our definition.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \n  ",
        "using": [
            "topology0.Top_3_L9",
            "IsRegular_def",
            "topology0.Top_3_L11(1)",
            "topology0.disj_open_cl_disj",
            "topology0.cl_contains_set",
            "topology0.cl_is_closed(2)"
        ],
        "statement": "lemma is_regular_def_alt: assumes \"T {is a topology}\" \n  shows \"T {is regular} \\<longleftrightarrow> (\\<forall>W\\<in>T. \\<forall>x\\<in>W. \\<exists>V\\<in>T. x\\<in>V \\<and> Closure(V,T)\\<subseteq>W)\"\n",
        "proof": "proof \n  let ?X = \"\\<Union>T\"\n  from assms(1) have cntx: \"topology0(T)\"\n    unfolding topology0_def by simp\n  assume \"T {is regular}\"\n  { fix W x assume \"W\\<in>T\" \"x\\<in>W\"\n    have \"\\<exists>V\\<in>T. x\\<in>V \\<and> Closure(V,T)\\<subseteq>W\"\n    proof -\n      let ?D = \"?X-W\"\n      from cntx \\<open>W\\<in>T\\<close> \\<open>T {is regular}\\<close> \\<open>x\\<in>W\\<close>\n      have \"\\<exists>U\\<in>T.\\<exists>V\\<in>T. ?D\\<subseteq>U\\<and>x\\<in>V\\<and>U\\<inter>V=0\"\n        using topology0.Top_3_L9 unfolding IsRegular_def by auto\n      then obtain U V where \"U\\<in>T\" \"V\\<in>T\" \"?D\\<subseteq>U\" \"x\\<in>V\" \"V\\<inter>U=0\"\n        by blast\n      from cntx \\<open>V\\<in>T\\<close> have \"Closure(V,T) \\<subseteq> ?X\"\n        using topology0.Top_3_L11(1) by blast      \n      from cntx \\<open>V\\<in>T\\<close> \\<open>U\\<in>T\\<close> \\<open>V\\<inter>U=0\\<close> \\<open>?D\\<subseteq>U\\<close>\n      have \"Closure(V,T) \\<inter> ?D = 0\"\n        using topology0.disj_open_cl_disj by blast\n      with \\<open>Closure(V,T) \\<subseteq> ?X\\<close> \\<open>V\\<in>T\\<close> \\<open>x\\<in>V\\<close> show ?thesis\n        by blast\n    qed\n  } thus \"\\<forall>W\\<in>T. \\<forall>x\\<in>W. \\<exists>V\\<in>T. x\\<in>V \\<and> Closure(V,T)\\<subseteq>W\"\n    by simp\nnext\n  let ?X = \"\\<Union>T\"\n  from assms(1) have cntx: \"topology0(T)\"\n    unfolding topology0_def by simp\n  assume regAlt: \"\\<forall>W\\<in>T. \\<forall>x\\<in>W. \\<exists>V\\<in>T. x\\<in>V \\<and> Closure(V,T)\\<subseteq>W\"\n  { fix A assume \"A {is closed in} T\"\n    have \"\\<forall>x\\<in>?X-A.\\<exists>U\\<in>T.\\<exists>V\\<in>T. A\\<subseteq>U \\<and> x\\<in>V \\<and> U\\<inter>V=0\"\n    proof -\n      { let ?W = \"?X-A\"\n        from \\<open>A {is closed in} T\\<close> have \"A\\<subseteq>?X\" and \"?W\\<in>T\"\n          unfolding IsClosed_def by auto\n        fix x assume \"x\\<in>?W\"\n        with regAlt \\<open>?W\\<in>T\\<close> have \"\\<exists>V\\<in>T. x\\<in>V \\<and> Closure(V,T)\\<subseteq>?W\"\n          by simp\n        then obtain V where \"V\\<in>T\" \"x\\<in>V\" \"Closure(V,T)\\<subseteq>?W\"\n          by auto\n        let ?U = \"?X-Closure(V,T)\"        \n        from cntx \\<open>V\\<in>T\\<close> have \"V\\<subseteq>?X\" and \"V\\<subseteq>Closure(V,T)\" \n          using topology0.cl_contains_set by auto\n        with cntx \\<open>A\\<subseteq>?X\\<close> \\<open>Closure(V,T)\\<subseteq>?W\\<close>\n        have \"?U\\<in>T\" \"A\\<subseteq>?U\" \"?U\\<inter>V = 0\"\n          using topology0.cl_is_closed(2) by auto\n        with \\<open>V\\<in>T\\<close> \\<open>x\\<in>V\\<close> have \"\\<exists>U\\<in>T.\\<exists>V\\<in>T. A\\<subseteq>U \\<and> x\\<in>V \\<and> U\\<inter>V=0\"\n          by blast\n      } thus ?thesis by blast\n    qed\n  } then show \"T {is regular}\" unfolding IsRegular_def \n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2031
    },
    "1831": {
        "type": "lemma",
        "text": "text\\<open>If a topology is $T_1$ then it is $T_0$. \n  We don't really assume here that $T$ is a topology on $X$. \n  Instead, we prove the relation between isT0 condition and isT1.\\<close>\n",
        "assumes": "assumes A1: \"T {is T\\<^sub>1}\" ",
        "using": [
            "isT1_def",
            "isT0_def"
        ],
        "statement": "lemma T1_is_T0: assumes A1: \"T {is T\\<^sub>1}\" shows \"T {is T\\<^sub>0}\"\n",
        "proof": "proof -\n  from A1 have \"\\<forall> x y. x \\<in> \\<Union>T \\<and> y \\<in> \\<Union>T \\<and> x\\<noteq>y \\<longrightarrow> \n    (\\<exists>U\\<in>T. x\\<in>U \\<and> y\\<notin>U)\"\n    using isT1_def by simp\n  then have \"\\<forall> x y. x \\<in> \\<Union>T \\<and> y \\<in> \\<Union>T \\<and> x\\<noteq>y \\<longrightarrow> \n    (\\<exists>U\\<in>T. x\\<in>U \\<and> y\\<notin>U \\<or> y\\<in>U \\<and> x\\<notin>U)\"\n    by auto\n  then show \"T {is T\\<^sub>0}\" using isT0_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2032
    },
    "1832": {
        "type": "lemma",
        "text": "text\\<open>In a $T_0$ space two points that can not be separated \n  by an open set are equal. Proof by contradiction.\\<close>\n",
        "assumes": "assumes A1: \"T {is T\\<^sub>0}\" and A2: \"x \\<in> \\<Union>T\"  \"y \\<in> \\<Union>T\"\n  and A3: \"\\<forall>U\\<in>T. (x\\<in>U \\<longleftrightarrow> y\\<in>U)\" \n  ",
        "using": [
            "isT0_def"
        ],
        "statement": "lemma Top_1_1_L1: assumes A1: \"T {is T\\<^sub>0}\" and A2: \"x \\<in> \\<Union>T\"  \"y \\<in> \\<Union>T\"\n  and A3: \"\\<forall>U\\<in>T. (x\\<in>U \\<longleftrightarrow> y\\<in>U)\" \n  shows \"x=y\"\n",
        "proof": "proof -\n  { assume \"x\\<noteq>y\"\n    with A1 A2 have \"\\<exists>U\\<in>T. x\\<in>U \\<and> y\\<notin>U \\<or> y\\<in>U \\<and> x\\<notin>U\"\n      using isT0_def by simp\n    with A3 have False by auto\n  } then show \"x=y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2034
    },
    "1833": {
        "type": "definition",
        "text": "text\\<open>A base of topology is a collection of open sets such that every \n  open set is a union of the sets from the base.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsAbaseFor (infixl \"{is a base for}\" 65) where \n  \"B {is a base for} T \\<equiv> B\\<subseteq>T \\<and> T = {\\<Union>A. A\\<in>Pow(B)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2035
    },
    "1834": {
        "type": "definition",
        "text": "text\\<open>A subbase is a collection \n  of open sets such that finite intersection of those sets form a base.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsAsubBaseFor (infixl \"{is a subbase for}\" 65) where\n  \"B {is a subbase for} T \\<equiv> \n  B \\<subseteq> T \\<and> {\\<Inter>A. A \\<in> FinPow(B)} {is a base for} T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2036
    },
    "1835": {
        "type": "definition",
        "text": "text\\<open>Below we formulate a condition that we will prove to be necessary and \n  sufficient for a collection $B$ of open sets to form a base. \n  It says that for any two sets $U,V$ from the collection $B$ we can\n  find a point $x\\in U\\cap V$ with a neighboorhod \n  from $B$ contained in $U\\cap V$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  SatisfiesBaseCondition (\"_ {satisfies the base condition}\" [50] 50)\n  where\n  \"B {satisfies the base condition} \\<equiv> \n  \\<forall>U V. ((U\\<in>B \\<and> V\\<in>B) \\<longrightarrow> (\\<forall>x \\<in> U\\<inter>V. \\<exists>W\\<in>B. x\\<in>W \\<and> W \\<subseteq> U\\<inter>V))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2037
    },
    "1836": {
        "type": "lemma",
        "text": "text\\<open>A collection that is closed with respect to intersection\n  satisfies the base condition.\\<close>\n",
        "assumes": "assumes \"\\<forall>U\\<in>B.(\\<forall>V\\<in>B. U\\<inter>V \\<in> B)\"\n  ",
        "using": [
            "SatisfiesBaseCondition_def"
        ],
        "statement": "lemma inter_closed_base: assumes \"\\<forall>U\\<in>B.(\\<forall>V\\<in>B. U\\<inter>V \\<in> B)\"\n  shows  \"B {satisfies the base condition}\" \n",
        "proof": "proof -\n    { fix U V x assume \"U\\<in>B\" and \"V\\<in>B\" and \"x \\<in> U\\<inter>V\"\n      with assms have \"\\<exists>W\\<in>B. x\\<in>W \\<and> W \\<subseteq> U\\<inter>V\" by blast\n    } then show ?thesis using SatisfiesBaseCondition_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2038
    },
    "1837": {
        "type": "lemma",
        "text": "text\\<open>Each open set is a union of some sets from the base.\\<close>\n",
        "assumes": "assumes \"B {is a base for} T\"  and \"U\\<in>T\" \n  ",
        "using": [
            "assms",
            "IsAbaseFor_def"
        ],
        "statement": "lemma Top_1_2_L1: assumes \"B {is a base for} T\"  and \"U\\<in>T\" \n  shows \"\\<exists>A\\<in>Pow(B). U = \\<Union>A\"\n  ",
        "proof": "using assms IsAbaseFor_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2039
    },
    "1838": {
        "type": "lemma",
        "text": "text\\<open>Elements of base are open.\\<close>\n",
        "assumes": "assumes \"B {is a base for} T\" and \"U \\<in> B\"\n  ",
        "using": [
            "assms",
            "IsAbaseFor_def"
        ],
        "statement": "lemma base_sets_open: \n  assumes \"B {is a base for} T\" and \"U \\<in> B\"\n  shows \"U \\<in> T\"\n  ",
        "proof": "using assms IsAbaseFor_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2040
    },
    "1839": {
        "type": "lemma",
        "text": "text\\<open>Every point from an open set has a neighboorhood from the base\n  that is contained in the set.\\<close>\n",
        "assumes": "assumes A1: \"B {is a base for} T\" and A2: \"U\\<in>T\" and A3: \"x\\<in>U\"\n  ",
        "using": [
            "Top_1_2_L1"
        ],
        "statement": "lemma point_open_base_neigh: \n  assumes A1: \"B {is a base for} T\" and A2: \"U\\<in>T\" and A3: \"x\\<in>U\"\n  shows \"\\<exists>V\\<in>B. V\\<subseteq>U \\<and> x\\<in>V\"\n",
        "proof": "proof -\n  from A1 A2 obtain A where \"A \\<in> Pow(B)\" and \"U = \\<Union>A\"\n    using Top_1_2_L1 by blast\n  with A3 obtain V where \"V\\<in>A\" and \"x\\<in>V\" by auto\n  with \\<open>A \\<in> Pow(B)\\<close> \\<open>U = \\<Union>A\\<close> show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2042
    },
    "1840": {
        "type": "lemma",
        "text": "text\\<open>A criterion for a collection to be a base for a topology\n  that is a slight reformulation of the definition. The only thing\n  different that in the definition is that we assume only that\n  every open set is a union of some sets from the base. The definition\n  requires also the opposite inclusion that every union of the \n  sets from the base is open, but that we can prove if we assume that\n  $T$ is a topology.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"\n  and A2: \"B \\<subseteq> T\" and A3: \"\\<forall>V \\<in> T. \\<exists>A \\<in> Pow(B). V = \\<Union>A\"\n  ",
        "using": [],
        "statement": "lemma is_a_base_criterion: assumes A1: \"T {is a topology}\"\n  and A2: \"B \\<subseteq> T\" and A3: \"\\<forall>V \\<in> T. \\<exists>A \\<in> Pow(B). V = \\<Union>A\"\n  shows \"B {is a base for} T\"\n",
        "proof": "proof -\n  from A3 have \"T \\<subseteq> {\\<Union>A. A\\<in>Pow(B)}\" by auto\n  moreover have \"{\\<Union>A. A\\<in>Pow(B)} \\<subseteq> T\"\n  proof\n    fix U assume \"U \\<in> {\\<Union>A. A\\<in>Pow(B)}\"\n    then obtain A where \"A \\<in> Pow(B)\" and \"U = \\<Union>A\"\n      by auto\n    with \\<open>B \\<subseteq> T\\<close> have \"A \\<in> Pow(T)\" by auto\n    with A1 \\<open>U = \\<Union>A\\<close> show \"U \\<in> T\"\n      unfolding IsATopology_def by simp\n  qed\n  ultimately have \"T = {\\<Union>A. A\\<in>Pow(B)}\" by auto\n  with A2 show \"B {is a base for} T\" \n    unfolding IsAbaseFor_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2043
    },
    "1841": {
        "type": "lemma",
        "text": "text\\<open>A necessary condition for a collection of sets to be a base for some \n  topology : every point in the intersection\n  of two sets in the base has a neighboorhood from the base contained\n  in the intersection.\\<close>\n",
        "assumes": "assumes A1:\"\\<exists>T. T {is a topology} \\<and> B {is a base for} T\"\n  and A2: \"V\\<in>B\"  \"W\\<in>B\"\n  ",
        "using": [
            "IsAbaseFor_def",
            "IsATopology_def",
            "Top_1_2_L1"
        ],
        "statement": "lemma Top_1_2_L2: \n  assumes A1:\"\\<exists>T. T {is a topology} \\<and> B {is a base for} T\"\n  and A2: \"V\\<in>B\"  \"W\\<in>B\"\n  shows \"\\<forall> x \\<in> V\\<inter>W. \\<exists>U\\<in>B. x\\<in>U \\<and> U \\<subseteq> V \\<inter> W\"\n",
        "proof": "proof -\n  from A1 obtain T where \n    D1: \"T {is a topology}\"   \"B {is a base for} T\"\n    by auto\n  then have \"B \\<subseteq> T\" using IsAbaseFor_def by auto\n  with A2 have \"V\\<in>T\" and \"W\\<in>T\" using IsAbaseFor_def by auto\n  with D1 have \"\\<exists>A\\<in>Pow(B). V\\<inter>W = \\<Union>A\" using IsATopology_def Top_1_2_L1\n    by auto\n  then obtain A where \"A \\<subseteq> B\" and \"V \\<inter> W = \\<Union>A\" by auto\n  then show \"\\<forall> x \\<in> V\\<inter>W. \\<exists>U\\<in>B. (x\\<in>U \\<and> U \\<subseteq> V \\<inter> W)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2044
    },
    "1842": {
        "type": "lemma",
        "text": "text\\<open>We will construct a topology as the collection of unions of (would-be)\n  base. First we prove that if the collection of sets satisfies the \n  condition we want to show to be sufficient, the the intersection belongs\n  to what we will define as topology (am I clear here?). Having this fact \n  ready simplifies the proof of the next lemma. There is not much topology\n  here, just some set theory.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in> V\\<inter>W . \\<exists>U\\<in>B. x\\<in>U \\<and> U \\<subseteq> V\\<inter>W\"\n  ",
        "using": [],
        "statement": "lemma Top_1_2_L3:\n  assumes A1: \"\\<forall>x\\<in> V\\<inter>W . \\<exists>U\\<in>B. x\\<in>U \\<and> U \\<subseteq> V\\<inter>W\"\n  shows \"V\\<inter>W \\<in> {\\<Union>A. A\\<in>Pow(B)}\"\n",
        "proof": "proof\n  let ?A = \"\\<Union>x\\<in>V\\<inter>W. {U\\<in>B. x\\<in>U \\<and> U \\<subseteq> V\\<inter>W}\"\n  show \"?A\\<in>Pow(B)\" by auto\n  from A1 show \"V\\<inter>W = \\<Union>?A\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2045
    },
    "1843": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is needed when proving that the would-be topology is\n  closed with respect to taking intersections. We show here that intersection\n  of two sets from this (would-be) topology can be written as union of sets \n  from the topology.\\<close>\n",
        "assumes": "assumes A1:  \"U\\<^sub>1 \\<in> {\\<Union>A. A\\<in>Pow(B)}\"   \"U\\<^sub>2 \\<in> {\\<Union>A. A\\<in>Pow(B)}\"\n  and A2: \"B {satisfies the base condition}\"\n  ",
        "using": [
            "Top_1_2_L3",
            "SatisfiesBaseCondition_def"
        ],
        "statement": "lemma Top_1_2_L4:\n  assumes A1:  \"U\\<^sub>1 \\<in> {\\<Union>A. A\\<in>Pow(B)}\"   \"U\\<^sub>2 \\<in> {\\<Union>A. A\\<in>Pow(B)}\"\n  and A2: \"B {satisfies the base condition}\"\n  shows \"\\<exists>C. C \\<subseteq> {\\<Union>A. A\\<in>Pow(B)} \\<and> U\\<^sub>1\\<inter>U\\<^sub>2 = \\<Union>C\"\n",
        "proof": "proof -\n  from A1 A2 obtain A\\<^sub>1 A\\<^sub>2 where \n    D1: \"A\\<^sub>1\\<in> Pow(B)\"  \"U\\<^sub>1 = \\<Union>A\\<^sub>1\"  \"A\\<^sub>2 \\<in> Pow(B)\"  \"U\\<^sub>2 = \\<Union>A\\<^sub>2\" \n    by auto\n  let ?C = \"\\<Union>U\\<in>A\\<^sub>1.{U\\<inter>V. V\\<in>A\\<^sub>2}\"\n  from D1 have \"(\\<forall>U\\<in>A\\<^sub>1. U\\<in>B) \\<and> (\\<forall>V\\<in>A\\<^sub>2. V\\<in>B)\" by auto\n  with A2 have \"?C \\<subseteq> {\\<Union>A . A \\<in> Pow(B)}\"\n    using Top_1_2_L3 SatisfiesBaseCondition_def by auto\n  moreover from D1 have \"U\\<^sub>1 \\<inter> U\\<^sub>2 = \\<Union>?C\" by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2046
    },
    "1844": {
        "type": "theorem",
        "text": "text\\<open>If $B$ satisfies the base condition, then the collection of unions\n  of sets from $B$ is a topology and $B$ is a base for this topology.\\<close>\n",
        "assumes": "assumes A1: \"B {satisfies the base condition}\"\n  and A2: \"T = {\\<Union>A. A\\<in>Pow(B)}\"\n  ",
        "using": [
            "ZF1_1_L10",
            "Top_1_2_L4",
            "IsATopology_def",
            "IsAbaseFor_def"
        ],
        "statement": "theorem Top_1_2_T1:\n  assumes A1: \"B {satisfies the base condition}\"\n  and A2: \"T = {\\<Union>A. A\\<in>Pow(B)}\"\n  shows \"T {is a topology}\" and \"B {is a base for} T\"\n",
        "proof": "proof -\n  show \"T {is a topology}\"\n  proof -\n    have I: \"\\<forall>C\\<in>Pow(T). \\<Union>C \\<in> T\"\n    proof -\n      { fix C assume A3: \"C \\<in> Pow(T)\"\n        let ?Q = \"\\<Union> {\\<Union>{A\\<in>Pow(B). U = \\<Union>A}. U\\<in>C}\"\n        from A2 A3 have \"\\<forall>U\\<in>C. \\<exists>A\\<in>Pow(B). U = \\<Union>A\" by auto\n        then have \"\\<Union>?Q = \\<Union>C\" using ZF1_1_L10 by simp\n        moreover from A2 have \"\\<Union>?Q \\<in> T\" by auto\n        ultimately have \"\\<Union>C \\<in> T\" by simp\n      } thus \"\\<forall>C\\<in>Pow(T). \\<Union>C \\<in> T\" by auto\n    qed\n    moreover have \"\\<forall>U\\<in>T. \\<forall> V\\<in>T. U\\<inter>V \\<in> T\"\n    proof -\n      { fix U V assume  \"U \\<in> T\"  \"V \\<in> T\"\n        with A1 A2 have \"\\<exists>C.(C \\<subseteq> T \\<and> U\\<inter>V = \\<Union>C)\"\n        using Top_1_2_L4 by simp\n        then obtain C where \"C \\<subseteq> T\" and  \"U\\<inter>V = \\<Union>C\"\n          by auto\n          with I have \"U\\<inter>V \\<in> T\" by simp\n      } then show \"\\<forall>U\\<in>T. \\<forall> V\\<in>T. U\\<inter>V \\<in> T\" by simp\n    qed\n    ultimately show \"T {is a topology}\" using IsATopology_def\n      by simp\n  qed\n  from A2 have \"B\\<subseteq>T\" by auto\n  with A2 show \"B {is a base for} T\" using IsAbaseFor_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2047
    },
    "1845": {
        "type": "lemma",
        "text": "text\\<open>The carrier of the base and topology are the same.\\<close>\n",
        "assumes": "assumes \"B {is a base for} T\"\n  ",
        "using": [
            "assms",
            "IsAbaseFor_def"
        ],
        "statement": "lemma Top_1_2_L5: assumes \"B {is a base for} T\"\n  shows \"\\<Union>T = \\<Union>B\"\n  ",
        "proof": "using assms IsAbaseFor_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2048
    },
    "1846": {
        "type": "lemma",
        "text": "text\\<open>If $B$ is a base for $T$, then $T$ is the smallest topology containing $B$.\n\\<close>\n",
        "assumes": "assumes A1: \"B {is a base for} T\" and  A2: \"S {is a topology}\" and A3: \"B\\<subseteq>S\"\n  ",
        "using": [
            "IsAbaseFor_def",
            "IsATopology_def"
        ],
        "statement": "lemma base_smallest_top: \n  assumes A1: \"B {is a base for} T\" and  A2: \"S {is a topology}\" and A3: \"B\\<subseteq>S\"\n  shows \"T\\<subseteq>S\"\n",
        "proof": "proof\n  fix U assume \"U\\<in>T\"\n  with A1 obtain B\\<^sub>U where \"B\\<^sub>U \\<subseteq> B\" and \"U = \\<Union>B\\<^sub>U\" using IsAbaseFor_def by auto\n  with A3 have \"B\\<^sub>U \\<subseteq> S\" by auto \n  with A2 \\<open>U = \\<Union>B\\<^sub>U\\<close> show \"U\\<in>S\" using IsATopology_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2049
    },
    "1847": {
        "type": "lemma",
        "text": "text\\<open>If $B$ is a base for $T$ and $B$ is a topology, then $B=T$.\\<close>\n",
        "assumes": "assumes \"B {is a topology}\" and \"B {is a base for} T\"\n  ",
        "using": [
            "assms",
            "base_sets_open",
            "base_smallest_top"
        ],
        "statement": "lemma base_topology: assumes \"B {is a topology}\" and \"B {is a base for} T\"\n  shows \"B=T\" ",
        "proof": "using assms base_sets_open base_smallest_top by blast \n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2050
    },
    "1848": {
        "type": "definition",
        "text": "text\\<open>Given two topological spaces we can define a topology on the product of \n  the carriers such that the cartesian products of the sets of the topologies \n  are a base for the product topology. Recall that for two collections $S,T$ \n  of sets the product collection is defined (in \\<open>ZF1.thy\\<close>) as the collections of cartesian \n  products $A\\times B$, where $A\\in S, B\\in T$. The $T\\times_tS$ notation is defined as\n  an alternative to the verbose  \\<open>ProductTopology(T,S)\\<close>). \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition ProductTopology (infixl \"\\<times>\\<^sub>t\" 65) where\n  \"T \\<times>\\<^sub>t S  \\<equiv> {\\<Union>W. W \\<in> Pow(ProductCollection(T,S))}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2051
    },
    "1849": {
        "type": "lemma",
        "text": "text\\<open>The product collection satisfies the base condition.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"   \"S {is a topology}\"\n  and A2: \"A \\<in> ProductCollection(T,S)\"  \"B \\<in> ProductCollection(T,S)\"\n  ",
        "using": [
            "ProductCollection_def",
            "IsATopology_def"
        ],
        "statement": "lemma Top_1_4_L1: \n  assumes A1: \"T {is a topology}\"   \"S {is a topology}\"\n  and A2: \"A \\<in> ProductCollection(T,S)\"  \"B \\<in> ProductCollection(T,S)\"\n  shows \"\\<forall>x\\<in>(A\\<inter>B). \\<exists>W\\<in>ProductCollection(T,S). (x\\<in>W \\<and> W \\<subseteq> A \\<inter> B)\"\n",
        "proof": "proof\n  fix x assume A3: \"x \\<in> A\\<inter>B\"\n  from A2 obtain U\\<^sub>1 V\\<^sub>1 U\\<^sub>2 V\\<^sub>2 where \n    D1: \"U\\<^sub>1\\<in>T\"  \"V\\<^sub>1\\<in>S\"   \"A=U\\<^sub>1\\<times>V\\<^sub>1\"  \"U\\<^sub>2\\<in>T\"  \"V\\<^sub>2\\<in>S\"   \"B=U\\<^sub>2\\<times>V\\<^sub>2\"\n    using ProductCollection_def by auto\n  let ?W = \"(U\\<^sub>1\\<inter>U\\<^sub>2) \\<times> (V\\<^sub>1\\<inter>V\\<^sub>2)\"\n  from A1 D1 have \"U\\<^sub>1\\<inter>U\\<^sub>2 \\<in> T\" and \"V\\<^sub>1\\<inter>V\\<^sub>2 \\<in> S\"\n    using IsATopology_def by auto\n  then have \"?W \\<in> ProductCollection(T,S)\" using ProductCollection_def \n    by auto\n  moreover from A3 D1 have \"x\\<in>?W\" and \"?W \\<subseteq> A\\<inter>B\" by auto\n  ultimately have \"\\<exists>W. (W \\<in> ProductCollection(T,S) \\<and> x\\<in>W \\<and> W \\<subseteq> A\\<inter>B)\"\n    by auto\n  thus \"\\<exists>W\\<in>ProductCollection(T,S). (x\\<in>W \\<and> W \\<subseteq> A \\<inter> B)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2052
    },
    "1850": {
        "type": "theorem",
        "text": "text\\<open>The product topology is indeed a topology on the product.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\"\n  ",
        "using": [
            "Top_1_4_L1",
            "ProductCollection_def",
            "SatisfiesBaseCondition_def",
            "ProductTopology_def",
            "Top_1_2_T1",
            "Top_1_2_L5",
            "ZF1_1_L6"
        ],
        "statement": "theorem Top_1_4_T1: assumes A1: \"T {is a topology}\"  \"S {is a topology}\"\n  shows \n  \"(T\\<times>\\<^sub>tS) {is a topology}\"\n  \"ProductCollection(T,S) {is a base for} (T\\<times>\\<^sub>tS)\"\n  \"\\<Union>(T\\<times>\\<^sub>tS) = \\<Union>T \\<times> \\<Union>S\"\n",
        "proof": "proof -\n  from A1 show \n    \"(T\\<times>\\<^sub>tS) {is a topology}\"\n    \"ProductCollection(T,S) {is a base for} (T\\<times>\\<^sub>tS)\"\n    using Top_1_4_L1 ProductCollection_def \n      SatisfiesBaseCondition_def ProductTopology_def Top_1_2_T1 \n    by auto\n  then show \"\\<Union>(T\\<times>\\<^sub>tS) = \\<Union>T \\<times> \\<Union>S\"\n    using Top_1_2_L5 ZF1_1_L6 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2053
    },
    "1851": {
        "type": "lemma",
        "text": "text\\<open>Each point of a set open in the product topology has a neighborhood\n  which is a cartesian product of open sets.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and \n  A2: \"U \\<in> ProductTopology(T,S)\" and A3: \"x \\<in> U\"\n  ",
        "using": [
            "Top_1_4_T1",
            "point_open_base_neigh",
            "ProductCollection_def"
        ],
        "statement": "lemma prod_top_point_neighb: \n  assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and \n  A2: \"U \\<in> ProductTopology(T,S)\" and A3: \"x \\<in> U\"\n  shows \"\\<exists>V W. V\\<in>T \\<and> W\\<in>S \\<and> V\\<times>W \\<subseteq> U \\<and> x \\<in> V\\<times>W\"\n",
        "proof": "proof -\n  from A1 have \n    \"ProductCollection(T,S) {is a base for} ProductTopology(T,S)\"\n    using Top_1_4_T1 by simp\n  with A2 A3 obtain Z where \n    \"Z \\<in> ProductCollection(T,S)\" and \"Z \\<subseteq> U \\<and> x\\<in>Z\"\n    using point_open_base_neigh by blast\n  then obtain V W where \"V \\<in> T\" and \"W\\<in>S\" and\" V\\<times>W \\<subseteq> U \\<and> x \\<in> V\\<times>W\"\n    using ProductCollection_def by auto\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2054
    },
    "1852": {
        "type": "lemma",
        "text": "text\\<open>Products of open sets are open in the product topology.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"U\\<in>T\" \"V\\<in>S\"\n  ",
        "using": [
            "Top_1_4_T1",
            "base_sets_open"
        ],
        "statement": "lemma prod_open_open_prod: \n  assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"U\\<in>T\" \"V\\<in>S\"\n  shows \"U\\<times>V \\<in> ProductTopology(T,S)\"\n",
        "proof": "proof -\n  from A1 have \n    \"ProductCollection(T,S) {is a base for} ProductTopology(T,S)\"\n    using Top_1_4_T1 by simp\n  moreover from A2 have \"U\\<times>V \\<in> ProductCollection(T,S)\"\n    unfolding ProductCollection_def by auto\n  ultimately show \"U\\<times>V \\<in> ProductTopology(T,S)\"\n    using base_sets_open by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2055
    },
    "1853": {
        "type": "lemma",
        "text": "text\\<open>Sets that are open in the product topology are contained in the product\n  of the carrier.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"V \\<in> ProductTopology(T,S)\"\n  ",
        "using": [
            "Top_1_4_T1"
        ],
        "statement": "lemma prod_open_type: assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"V \\<in> ProductTopology(T,S)\"\n  shows \"V \\<subseteq> \\<Union>T \\<times> \\<Union>S\"\n",
        "proof": "proof -\n  from A2 have \"V \\<subseteq> \\<Union> ProductTopology(T,S)\" by auto\n  with A1 show ?thesis using Top_1_4_T1 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2056
    },
    "1854": {
        "type": "lemma",
        "text": "text\\<open>A reverse of \\<open>prod_top_point_neighb\\<close>: if each point of set has an neighborhood in the set\n  that is a cartesian product of open sets, then the set is open.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\"  \"S {is a topology}\"\n  and \"\\<forall>p\\<in>V. \\<exists>U\\<in>T.\\<exists>W\\<in>S. p\\<in>U\\<times>W \\<and> U\\<times>W \\<subseteq> V\"\n",
        "using": [
            "Top_1_4_T1(1)",
            "topology0_def",
            "prod_open_open_prod",
            "topology0.open_neigh_open"
        ],
        "statement": "lemma point_neighb_prod_top: \n  assumes \"T {is a topology}\"  \"S {is a topology}\"\n  and \"\\<forall>p\\<in>V. \\<exists>U\\<in>T.\\<exists>W\\<in>S. p\\<in>U\\<times>W \\<and> U\\<times>W \\<subseteq> V\"\nshows \"V \\<in> ProductTopology(T,S)\"\n",
        "proof": "proof -\n  from assms(1,2) have I: \"topology0(ProductTopology(T,S))\" \n    using Top_1_4_T1(1) topology0_def by simp\n  moreover \n  { fix p assume \"p\\<in>V\"\n    with assms(3) obtain U W where \"U\\<in>T\" \"W\\<in>S\" \"p\\<in>U\\<times>W\" \"U\\<times>W \\<subseteq> V\"\n      by auto\n    with assms(1,2) have \"\\<exists>N\\<in>ProductTopology(T,S). p\\<in>N \\<and> N\\<subseteq>V\"\n      using prod_open_open_prod by auto\n  } hence \"\\<forall>p\\<in>V. \\<exists>N\\<in>ProductTopology(T,S). p\\<in>N \\<and> N\\<subseteq>V\" by blast\n  ultimately show ?thesis using topology0.open_neigh_open by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2057
    },
    "1855": {
        "type": "lemma",
        "text": "text\\<open>Suppose we have subsets $A\\subseteq X, B\\subseteq Y$, where\n  $X,Y$ are topological spaces with topologies $T,S$. We can the consider\n  relative topologies on $T_A, S_B$ on sets $A,B$ and the collection\n  of cartesian products of sets open in $T_A, S_B$, (namely \n  $\\{U\\times V: U\\in T_A, V\\in S_B\\}$. The next lemma states that\n  this collection is a base of the product topology on $X\\times Y$\n  restricted to the product $A\\times B$.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\"\n  ",
        "using": [
            "Top_1_4_T1",
            "topology0_def",
            "topology0.Top_1_L4",
            "ProductCollection_def",
            "RestrictedTo_def",
            "prod_open_open_prod",
            "IsAbaseFor_def"
        ],
        "statement": "lemma prod_restr_base_restr:\n  assumes A1: \"T {is a topology}\"  \"S {is a topology}\"\n  shows \n  \"ProductCollection(T {restricted to} A, S {restricted to} B)\n  {is a base for} (ProductTopology(T,S) {restricted to} A\\<times>B)\"\n",
        "proof": "proof -\n  let ?\\<B> = \"ProductCollection(T {restricted to} A, S {restricted to} B)\"\n  let ?\\<tau> = \"ProductTopology(T,S)\"\n  from A1 have \"(?\\<tau> {restricted to} A\\<times>B) {is a topology}\"\n    using Top_1_4_T1 topology0_def topology0.Top_1_L4\n    by simp\n  moreover have \"?\\<B> \\<subseteq> (?\\<tau> {restricted to} A\\<times>B)\"\n  proof\n    fix U assume \"U \\<in> ?\\<B>\"\n    then obtain U\\<^sub>A U\\<^sub>B where \"U = U\\<^sub>A \\<times> U\\<^sub>B\" and\n      \"U\\<^sub>A \\<in> (T {restricted to} A)\" and \"U\\<^sub>B \\<in> (S {restricted to} B)\"\n      using ProductCollection_def by auto\n    then obtain W\\<^sub>A W\\<^sub>B where \n      \"W\\<^sub>A \\<in> T\"  \"U\\<^sub>A = W\\<^sub>A \\<inter> A\" and \"W\\<^sub>B \\<in> S\"  \"U\\<^sub>B = W\\<^sub>B \\<inter> B\"\n      using RestrictedTo_def by auto\n    with \\<open>U = U\\<^sub>A \\<times> U\\<^sub>B\\<close> have \"U = W\\<^sub>A\\<times>W\\<^sub>B \\<inter> (A\\<times>B)\" by auto\n    moreover from A1 \\<open>W\\<^sub>A \\<in> T\\<close> and \\<open>W\\<^sub>B \\<in> S\\<close> have \"W\\<^sub>A\\<times>W\\<^sub>B \\<in> ?\\<tau>\"\n      using prod_open_open_prod by simp\n    ultimately show \"U \\<in> ?\\<tau> {restricted to} A\\<times>B\"\n      using RestrictedTo_def by auto\n  qed\n  moreover have \"\\<forall>U \\<in> ?\\<tau> {restricted to} A\\<times>B.\n    \\<exists>C \\<in> Pow(?\\<B>). U = \\<Union>C\"\n  proof\n    fix U assume \"U \\<in> ?\\<tau> {restricted to} A\\<times>B\"\n    then obtain W where \"W \\<in> ?\\<tau>\" and \"U = W \\<inter> (A\\<times>B)\"\n      using RestrictedTo_def by auto\n    from A1 \\<open>W \\<in> ?\\<tau>\\<close> obtain A\\<^sub>W  where \n      \"A\\<^sub>W \\<in> Pow(ProductCollection(T,S))\" and \"W = \\<Union>A\\<^sub>W\"\n       using Top_1_4_T1 IsAbaseFor_def by auto\n    let ?C = \"{V \\<inter> A\\<times>B. V \\<in> A\\<^sub>W}\" \n    have \"?C \\<in> Pow(?\\<B>)\" and \"U = \\<Union>?C\"\n    proof -\n      { fix R assume \"R \\<in> ?C\"\n\tthen obtain V where \"V \\<in> A\\<^sub>W\" and \"R = V \\<inter> A\\<times>B\"\n\t  by auto\n\twith \\<open>A\\<^sub>W \\<in> Pow(ProductCollection(T,S))\\<close> obtain V\\<^sub>T V\\<^sub>S where \n\t  \"V\\<^sub>T \\<in> T\" and \"V\\<^sub>S \\<in> S\" and \"V = V\\<^sub>T \\<times> V\\<^sub>S\"\n\t  using ProductCollection_def by auto\n\twith \\<open>R = V \\<inter> A\\<times>B\\<close> have \"R \\<in> ?\\<B>\"\n\t  using ProductCollection_def RestrictedTo_def\n\t  by auto\n      } then show \"?C \\<in> Pow(?\\<B>)\" by auto\n      from \\<open>U = W \\<inter> (A\\<times>B)\\<close> and \\<open>W = \\<Union>A\\<^sub>W\\<close>\n      show \"U = \\<Union>?C\" by auto\n    qed\n    thus \"\\<exists>C \\<in> Pow(?\\<B>). U = \\<Union>C\" by blast\n  qed\n  ultimately show ?thesis by (rule is_a_base_criterion)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2058
    },
    "1856": {
        "type": "lemma",
        "text": "text\\<open>We can commute taking restriction (relative topology) and\n  product topology. The reason the two topologies are the same is\n  that they have the same base.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\"\n  ",
        "using": [
            "topology0_def",
            "topology0.Top_1_L4",
            "Top_1_4_T1",
            "prod_restr_base_restr"
        ],
        "statement": "lemma prod_top_restr_comm: \n  assumes A1: \"T {is a topology}\"  \"S {is a topology}\"\n  shows\n  \"ProductTopology(T {restricted to} A,S {restricted to} B) =\n  ProductTopology(T,S) {restricted to} (A\\<times>B)\"\n",
        "proof": "proof -\n  let ?\\<B> = \"ProductCollection(T {restricted to} A, S {restricted to} B)\"\n  from A1 have\n    \"?\\<B> {is a base for} ProductTopology(T {restricted to} A,S {restricted to} B)\"\n    using topology0_def topology0.Top_1_L4 Top_1_4_T1 by simp\n  moreover from A1 have \n    \"?\\<B> {is a base for} ProductTopology(T,S) {restricted to} (A\\<times>B)\"\n    using prod_restr_base_restr by simp\n  ultimately show ?thesis by (rule same_base_same_top)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2059
    },
    "1857": {
        "type": "lemma",
        "text": "text\\<open>Projection of a section of an open set is open.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"V \\<in> ProductTopology(T,S)\" and A3: \"x \\<in> \\<Union>T\"\n  ",
        "using": [
            "topology0_def",
            "prod_open_type",
            "section_proj"
        ],
        "statement": "lemma prod_sec_open1: assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"V \\<in> ProductTopology(T,S)\" and A3: \"x \\<in> \\<Union>T\"\n  shows \"{y \\<in> \\<Union>S. \\<langle>x,y\\<rangle> \\<in> V} \\<in> S\"\n",
        "proof": "proof -\n  let ?A = \"{y \\<in> \\<Union>S. \\<langle>x,y\\<rangle> \\<in> V}\"\n  from A1 have \"topology0(S)\" using topology0_def by simp\n  moreover have \"\\<forall>y\\<in>?A.\\<exists>W\\<in>S. (y\\<in>W \\<and> W\\<subseteq>?A)\"\n    proof\n      fix y assume \"y \\<in> ?A\"\n      then have \"\\<langle>x,y\\<rangle> \\<in> V\" by simp\n      with A1 A2 have \"\\<langle>x,y\\<rangle> \\<in> \\<Union>T \\<times> \\<Union>S\" using prod_open_type by blast\n      hence \"x \\<in> \\<Union>T\" and \"y \\<in> \\<Union>S\" by auto\n      from A1 A2 \\<open>\\<langle>x,y\\<rangle> \\<in> V\\<close> have \"\\<exists>U W. U\\<in>T \\<and> W\\<in>S \\<and> U\\<times>W \\<subseteq> V \\<and> \\<langle>x,y\\<rangle> \\<in> U\\<times>W\"\n        by (rule prod_top_point_neighb)\n      then obtain U W where  \"U\\<in>T\" \"W\\<in>S\" \"U\\<times>W \\<subseteq> V\" \"\\<langle>x,y\\<rangle> \\<in> U\\<times>W\"\n        by auto\n      with A1 A2 show \"\\<exists>W\\<in>S. (y\\<in>W \\<and> W\\<subseteq>?A)\" using prod_open_type section_proj\n        by auto\n    qed\n  ultimately show ?thesis by (rule topology0.open_neigh_open)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2060
    },
    "1858": {
        "type": "lemma",
        "text": "text\\<open>Projection of a section of an open set is open. This is dual of \n\\<open>prod_sec_open1\\<close> with a very similar proof.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"V \\<in> ProductTopology(T,S)\" and A3: \"y \\<in> \\<Union>S\"\n  ",
        "using": [
            "topology0_def",
            "prod_open_type",
            "section_proj"
        ],
        "statement": "lemma prod_sec_open2: assumes A1: \"T {is a topology}\"  \"S {is a topology}\" and\n  A2: \"V \\<in> ProductTopology(T,S)\" and A3: \"y \\<in> \\<Union>S\"\n  shows \"{x \\<in> \\<Union>T. \\<langle>x,y\\<rangle> \\<in> V} \\<in> T\"\n",
        "proof": "proof -\n  let ?A = \"{x \\<in> \\<Union>T. \\<langle>x,y\\<rangle> \\<in> V}\"\n  from A1 have \"topology0(T)\" using topology0_def by simp\n  moreover have \"\\<forall>x\\<in>?A.\\<exists>W\\<in>T. (x\\<in>W \\<and> W\\<subseteq>?A)\"\n    proof\n      fix x assume \"x \\<in> ?A\"\n      then have \"\\<langle>x,y\\<rangle> \\<in> V\" by simp\n      with A1 A2 have \"\\<langle>x,y\\<rangle> \\<in> \\<Union>T \\<times> \\<Union>S\" using prod_open_type by blast\n      hence \"x \\<in> \\<Union>T\" and \"y \\<in> \\<Union>S\" by auto\n      from A1 A2 \\<open>\\<langle>x,y\\<rangle> \\<in> V\\<close> have \"\\<exists>U W. U\\<in>T \\<and> W\\<in>S \\<and> U\\<times>W \\<subseteq> V \\<and> \\<langle>x,y\\<rangle> \\<in> U\\<times>W\"\n        by (rule prod_top_point_neighb)\n      then obtain U W where  \"U\\<in>T\" \"W\\<in>S\" \"U\\<times>W \\<subseteq> V\" \"\\<langle>x,y\\<rangle> \\<in> U\\<times>W\"\n        by auto\n      with A1 A2 show \"\\<exists>W\\<in>T. (x\\<in>W \\<and> W\\<subseteq>?A)\" using prod_open_type section_proj\n        by auto\n    qed\n  ultimately show ?thesis by (rule topology0.open_neigh_open)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2061
    },
    "1859": {
        "type": "theorem",
        "text": "text\\<open>A space is Hausdorff if and only if the diagonal $\\Delta = \\{\\langle x,x\\rangle : x\\in X\\}$\n  is closed in the product topology on $X\\times X$. \\<close>\n",
        "assumes": "assumes \"T {is a topology}\"\n  ",
        "using": [
            "Top_1_4_T1(1)",
            "topology0_def",
            "Top_1_4_T1(3)",
            "point_neighb_prod_top",
            "IsClosed_def",
            "prod_top_point_neighb"
        ],
        "statement": "theorem t2_iff_diag_closed: assumes \"T {is a topology}\"\n  shows \"T {is T\\<^sub>2} \\<longleftrightarrow> {\\<langle>x,x\\<rangle>. x\\<in>\\<Union>T} {is closed in} ProductTopology(T,T)\"\n",
        "proof": "proof\n  let ?X = \"\\<Union>T\"\n  from assms(1) have I: \"topology0(ProductTopology(T,T))\" \n    using Top_1_4_T1(1) topology0_def by simp\n  assume \"T {is T\\<^sub>2}\" show \"{\\<langle>x,x\\<rangle>. x\\<in>?X} {is closed in} ProductTopology(T,T)\"\n  proof -\n    let ?D\\<^sub>c = \"?X\\<times>?X - {\\<langle>x,x\\<rangle>. x\\<in>?X}\"\n    have \"\\<forall>p\\<in>?D\\<^sub>c.\\<exists>U\\<in>T.\\<exists>V\\<in>T. p\\<in>U\\<times>V \\<and> U\\<times>V \\<subseteq> ?D\\<^sub>c\"\n    proof -\n      { fix p assume \"p\\<in>?D\\<^sub>c\"\n        then obtain x y where \"p=\\<langle>x,y\\<rangle>\" \"x\\<in>?X\" \"y\\<in>?X\" \"x\\<noteq>y\" by auto\n        with \\<open>T {is T\\<^sub>2}\\<close> obtain U V where \"U\\<in>T\" \"V\\<in>T\" \"x\\<in>U\" \"y\\<in>V\" \"U\\<inter>V = 0\"\n          unfolding isT2_def by blast\n        with assms \\<open>p=\\<langle>x,y\\<rangle>\\<close> have \"\\<exists>U\\<in>T.\\<exists>V\\<in>T. p\\<in>U\\<times>V \\<and> U\\<times>V \\<subseteq> ?D\\<^sub>c\" by auto\n      } hence \"\\<forall>p. p\\<in>?D\\<^sub>c \\<longrightarrow> (\\<exists>U\\<in>T.\\<exists>V\\<in>T. p\\<in>U\\<times>V \\<and> U\\<times>V \\<subseteq> ?D\\<^sub>c)\" by simp\n      then show ?thesis by (rule exists_in_set)\n    qed\n    with assms show ?thesis using Top_1_4_T1(3) point_neighb_prod_top \n      unfolding IsClosed_def by auto\n  qed\nnext\n  let ?X = \"\\<Union>T\"\n  assume A: \"{\\<langle>x,x\\<rangle>. x\\<in>?X} {is closed in} ProductTopology(T,T)\" show \"T {is T\\<^sub>2}\"\n  proof -\n    { let ?D\\<^sub>c = \"?X\\<times>?X - {\\<langle>x,x\\<rangle>. x\\<in>?X}\"\n      fix x y assume \"x\\<in>?X\" \"y\\<in>?X\" \"x\\<noteq>y\" \n      with assms A have \"?D\\<^sub>c \\<in> ProductTopology(T,T)\" and \"\\<langle>x,y\\<rangle> \\<in> ?D\\<^sub>c\"\n        using Top_1_4_T1(3) unfolding IsClosed_def by auto\n      with assms obtain U V where \"U\\<in>T\" \"V\\<in>T\" \"U\\<times>V \\<subseteq> ?D\\<^sub>c\" \"\\<langle>x,y\\<rangle> \\<in> U\\<times>V\"\n        using prod_top_point_neighb by blast\n      moreover from \\<open>U\\<times>V \\<subseteq> ?D\\<^sub>c\\<close> have \"U\\<inter>V = 0\" by auto\n      ultimately have \"\\<exists>U\\<in>T.\\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n    } then show \"T {is T\\<^sub>2}\" unfolding isT2_def by simp\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2062
    },
    "1860": {
        "type": "lemma",
        "text": "text\\<open>The closure of a product, is the product of the closures.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\" \"S{is a topology}\" \"A\\<subseteq>\\<Union>T\" \"B\\<subseteq>\\<Union>S\"\n  ",
        "using": [
            "assms(3,4)",
            "Top_1_4_T1(3)",
            "assms(1,2)",
            "Top_1_4_T1(1)",
            "topology0.cl_inter_neigh",
            "sub",
            "top",
            "topology0_def",
            "topology0.Top_3_L11(1)",
            "Pair_fst_snd_eq",
            "assms(2)",
            "IsATopology_def",
            "Top_1_4_T1(2)",
            "base_sets_open",
            "xSigma",
            "assms(1)",
            "topology0.inter_neigh_cl",
            "xT",
            "xS",
            "assms(1,3)",
            "assms(2,4)",
            "point_open_base_neigh",
            "xtot"
        ],
        "statement": "lemma cl_product:\n  assumes \"T{is a topology}\" \"S{is a topology}\" \"A\\<subseteq>\\<Union>T\" \"B\\<subseteq>\\<Union>S\"\n  shows \"Closure(A\\<times>B,ProductTopology(T,S))=Closure(A,T)\\<times>Closure(B,S)\"\n",
        "proof": "proof\n  have \"A\\<times>B\\<subseteq>\\<Union>T\\<times>\\<Union>S\" using assms(3,4) by auto\n  then have sub:\"A\\<times>B\\<subseteq>\\<Union>ProductTopology(T,S)\" using Top_1_4_T1(3) assms(1,2) by auto\n  have top:\"ProductTopology(T,S){is a topology}\" using Top_1_4_T1(1) assms(1,2) by auto\n  {\n    fix x assume asx:\"x\\<in>Closure(A\\<times>B,ProductTopology(T,S))\"\n    then have reg:\"\\<forall>U\\<in>ProductTopology(T,S). x\\<in>U \\<longrightarrow> U\\<inter>(A\\<times>B)\\<noteq>0\" using topology0.cl_inter_neigh\n      sub top unfolding topology0_def by blast\n    from asx have \"x\\<in>\\<Union>ProductTopology(T,S)\" using topology0.Top_3_L11(1) top unfolding topology0_def\n      using sub by blast\n    then have xSigma:\"x\\<in>\\<Union>T\\<times>\\<Union>S\" using Top_1_4_T1(3) assms(1,2) by auto\n    then have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\" using Pair_fst_snd_eq by auto\n    then have xT:\"fst(x)\\<in>\\<Union>T\" and xS:\"snd(x)\\<in>\\<Union>S\" by auto\n    {\n      fix U V assume as:\"U\\<in>T\"  \"fst(x)\\<in>U\"\n      have \"\\<Union>S\\<in>S\" using assms(2) unfolding IsATopology_def by auto\n      with as have \"U\\<times>(\\<Union>S)\\<in>ProductCollection(T,S)\" unfolding ProductCollection_def\n        by auto\n      then have P:\"U\\<times>(\\<Union>S)\\<in>ProductTopology(T,S)\" using Top_1_4_T1(2) assms(1,2) base_sets_open by blast\n      with xS as(2) have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>U\\<times>(\\<Union>S)\" by auto\n      then have \"x\\<in>U\\<times>(\\<Union>S)\" using Pair_fst_snd_eq xSigma by auto\n      with P reg have \"U\\<times>(\\<Union>S)\\<inter>A\\<times>B\\<noteq>0\" by auto\n      then have noEm:\"U\\<inter>A\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>U\\<in>T. fst(x)\\<in>U \\<longrightarrow> U\\<inter>A\\<noteq>0\" by auto moreover\n    {\n      fix U V assume as:\"U\\<in>S\"  \"snd(x)\\<in>U\"\n      have \"\\<Union>T\\<in>T\" using assms(1) unfolding IsATopology_def by auto\n      with as have \"(\\<Union>T)\\<times>U\\<in>ProductCollection(T,S)\" unfolding ProductCollection_def\n        by auto\n      then have P:\"(\\<Union>T)\\<times>U\\<in>ProductTopology(T,S)\" using Top_1_4_T1(2) assms(1,2) base_sets_open by blast\n      with xT as(2) have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>(\\<Union>T)\\<times>U\" by auto\n      then have \"x\\<in>(\\<Union>T)\\<times>U\" using Pair_fst_snd_eq xSigma by auto\n      with P reg have \"(\\<Union>T)\\<times>U\\<inter>A\\<times>B\\<noteq>0\" by auto\n      then have noEm:\"U\\<inter>B\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>U\\<in>S. snd(x)\\<in>U \\<longrightarrow> U\\<inter>B\\<noteq>0\" by auto\n    ultimately have \"fst(x)\\<in>Closure(A,T)\" \"snd(x)\\<in>Closure(B,S)\" using \n      topology0.inter_neigh_cl assms(3,4) unfolding topology0_def\n      using assms(1,2) xT xS by auto\n    then have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>Closure(A,T)\\<times>Closure(B,S)\" by auto\n    with xSigma have \"x\\<in>Closure(A,T)\\<times>Closure(B,S)\" by auto\n  }\n  then show \"Closure(A\\<times>B,ProductTopology(T,S))\\<subseteq>Closure(A,T)\\<times>Closure(B,S)\" by auto\n  {\n    fix x assume x:\"x\\<in>Closure(A,T)\\<times>Closure(B,S)\"\n    then have xcl:\"fst(x)\\<in>Closure(A,T)\" \"snd(x)\\<in>Closure(B,S)\" by auto\n    from xcl(1) have regT:\"\\<forall>U\\<in>T. fst(x)\\<in>U \\<longrightarrow> U\\<inter>A\\<noteq>0\" using topology0.cl_inter_neigh\n      unfolding topology0_def using assms(1,3) by blast\n    from xcl(2) have regS:\"\\<forall>U\\<in>S. snd(x)\\<in>U \\<longrightarrow> U\\<inter>B\\<noteq>0\" using topology0.cl_inter_neigh\n      unfolding topology0_def using assms(2,4) by blast\n    from x assms(3,4) have \"x\\<in>\\<Union>T\\<times>\\<Union>S\" using topology0.Top_3_L11(1) unfolding topology0_def\n      using assms(1,2) by blast\n    then have xtot:\"x\\<in>\\<Union>ProductTopology(T,S)\" using Top_1_4_T1(3) assms(1,2) by auto\n    {\n      fix PO assume as:\"PO\\<in>ProductTopology(T,S)\" \"x\\<in>PO\"\n      then obtain POB where base:\"POB\\<in>ProductCollection(T,S)\" \"x\\<in>POB\"\"POB\\<subseteq>PO\" using point_open_base_neigh\n        Top_1_4_T1(2) assms(1,2) base_sets_open by blast\n      then obtain VT VS where V:\"VT\\<in>T\" \"VS\\<in>S\" \"x\\<in>VT\\<times>VS\" \"POB=VT\\<times>VS\" unfolding ProductCollection_def\n        by auto\n      from V(3) have x:\"fst(x)\\<in>VT\" \"snd(x)\\<in>VS\" by auto\n      from V(1) regT x(1) have \"VT\\<inter>A\\<noteq>0\" by auto moreover\n      from V(2) regS x(2) have \"VS\\<inter>B\\<noteq>0\" by auto ultimately\n      have \"VT\\<times>VS\\<inter>A\\<times>B\\<noteq>0\" by auto\n      with V(4) base(3) have \"PO\\<inter>A\\<times>B\\<noteq>0\" by blast\n    }\n    then have \"\\<forall>P\\<in>ProductTopology(T,S). x\\<in>P \\<longrightarrow> P\\<inter>A\\<times>B\\<noteq>0\" by auto\n    then have \"x\\<in>Closure(A\\<times>B,ProductTopology(T,S))\" using topology0.inter_neigh_cl\n      unfolding topology0_def using top sub xtot by auto\n  }\n  then show \"Closure(A,T)\\<times>Closure(B,S)\\<subseteq>Closure(A\\<times>B,ProductTopology(T,S))\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2063
    },
    "1861": {
        "type": "theorem",
        "text": "text\\<open>The product of $T_0$ spaces is $T_0$.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is T\\<^sub>0}\"\"S{is T\\<^sub>0}\"\n  ",
        "using": [
            "Top_1_4_T1(3)",
            "assms(1,2)",
            "Pair_fst_snd_eq",
            "tot(1,2)",
            "assms(2)",
            "IsATopology_def",
            "prod_open_open_prod",
            "assms(1)"
        ],
        "statement": "theorem T0_product:\n  assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is T\\<^sub>0}\"\"S{is T\\<^sub>0}\"\n  shows \"ProductTopology(T,S){is T\\<^sub>0}\"\n",
        "proof": "proof-\n  {\n    fix x y assume \"x\\<in>\\<Union>ProductTopology(T,S)\"\"y\\<in>\\<Union>ProductTopology(T,S)\"\"x\\<noteq>y\"\n    then have tot:\"x\\<in>\\<Union>T\\<times>\\<Union>S\"\"y\\<in>\\<Union>T\\<times>\\<Union>S\"\"x\\<noteq>y\" using Top_1_4_T1(3) assms(1,2) by auto\n    then have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\"\"\\<langle>fst(y),snd(y)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\" and disj:\"fst(x)\\<noteq>fst(y)\\<or>snd(x)\\<noteq>snd(y)\" \n      using Pair_fst_snd_eq by auto\n    then have T:\"fst(x)\\<in>\\<Union>T\"\"fst(y)\\<in>\\<Union>T\" and S:\"snd(y)\\<in>\\<Union>S\"\"snd(x)\\<in>\\<Union>S\" and p:\"fst(x)\\<noteq>fst(y)\\<or>snd(x)\\<noteq>snd(y)\"\n      by auto\n    {\n      assume \"fst(x)\\<noteq>fst(y)\"\n      with T assms(3) have \"(\\<exists>U\\<in>T. (fst(x)\\<in>U\\<and>fst(y)\\<notin>U)\\<or>(fst(y)\\<in>U\\<and>fst(x)\\<notin>U))\" unfolding\n        isT0_def by auto\n      then obtain U where \"U\\<in>T\" \"(fst(x)\\<in>U\\<and>fst(y)\\<notin>U)\\<or>(fst(y)\\<in>U\\<and>fst(x)\\<notin>U)\" by auto\n      with S have \"(\\<langle>fst(x),snd(x)\\<rangle>\\<in>U\\<times>(\\<Union>S) \\<and> \\<langle>fst(y),snd(y)\\<rangle>\\<notin>U\\<times>(\\<Union>S))\\<or>(\\<langle>fst(y),snd(y)\\<rangle>\\<in>U\\<times>(\\<Union>S) \\<and> \\<langle>fst(x),snd(x)\\<rangle>\\<notin>U\\<times>(\\<Union>S))\"\n        by auto\n      then have \"(x\\<in>U\\<times>(\\<Union>S) \\<and> y\\<notin>U\\<times>(\\<Union>S))\\<or>(y\\<in>U\\<times>(\\<Union>S) \\<and> x\\<notin>U\\<times>(\\<Union>S))\" using Pair_fst_snd_eq tot(1,2) by auto\n      moreover have \"(\\<Union>S)\\<in>S\" using assms(2) unfolding IsATopology_def by auto\n      with \\<open>U\\<in>T\\<close> have \"U\\<times>(\\<Union>S)\\<in>ProductTopology(T,S)\" using prod_open_open_prod assms(1,2) by auto\n      ultimately\n      have \"\\<exists>V\\<in>ProductTopology(T,S). (x\\<in>V \\<and> y\\<notin>V)\\<or>(y\\<in>V \\<and> x\\<notin>V)\" proof qed\n    } moreover\n    {\n      assume \"snd(x)\\<noteq>snd(y)\"\n      with S assms(4) have \"(\\<exists>U\\<in>S. (snd(x)\\<in>U\\<and>snd(y)\\<notin>U)\\<or>(snd(y)\\<in>U\\<and>snd(x)\\<notin>U))\" unfolding\n        isT0_def by auto\n      then obtain U where \"U\\<in>S\" \"(snd(x)\\<in>U\\<and>snd(y)\\<notin>U)\\<or>(snd(y)\\<in>U\\<and>snd(x)\\<notin>U)\" by auto\n      with T have \"(\\<langle>fst(x),snd(x)\\<rangle>\\<in>(\\<Union>T)\\<times>U \\<and> \\<langle>fst(y),snd(y)\\<rangle>\\<notin>(\\<Union>T)\\<times>U)\\<or>(\\<langle>fst(y),snd(y)\\<rangle>\\<in>(\\<Union>T)\\<times>U \\<and> \\<langle>fst(x),snd(x)\\<rangle>\\<notin>(\\<Union>T)\\<times>U)\"\n        by auto\n      then have \"(x\\<in>(\\<Union>T)\\<times>U \\<and> y\\<notin>(\\<Union>T)\\<times>U)\\<or>(y\\<in>(\\<Union>T)\\<times>U \\<and> x\\<notin>(\\<Union>T)\\<times>U)\" using Pair_fst_snd_eq tot(1,2) by auto\n      moreover have \"(\\<Union>T)\\<in>T\" using assms(1) unfolding IsATopology_def by auto\n      with \\<open>U\\<in>S\\<close> have \"(\\<Union>T)\\<times>U\\<in>ProductTopology(T,S)\" using prod_open_open_prod assms(1,2) by auto\n      ultimately\n      have \"\\<exists>V\\<in>ProductTopology(T,S). (x\\<in>V \\<and> y\\<notin>V)\\<or>(y\\<in>V \\<and> x\\<notin>V)\" proof qed\n    }moreover\n    note disj\n    ultimately have \"\\<exists>V\\<in>ProductTopology(T,S). (x\\<in>V \\<and> y\\<notin>V)\\<or>(y\\<in>V \\<and> x\\<notin>V)\" by auto\n  }\n  then show ?thesis unfolding isT0_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2065
    },
    "1862": {
        "type": "theorem",
        "text": "text\\<open>The product of $T_1$ spaces is $T_1$.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is T\\<^sub>1}\"\"S{is T\\<^sub>1}\"\n  ",
        "using": [
            "Top_1_4_T1(3)",
            "assms(1,2)",
            "Pair_fst_snd_eq",
            "tot(1,2)",
            "assms(2)",
            "IsATopology_def",
            "prod_open_open_prod",
            "assms(1)"
        ],
        "statement": "theorem T1_product:\n  assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is T\\<^sub>1}\"\"S{is T\\<^sub>1}\"\n  shows \"ProductTopology(T,S){is T\\<^sub>1}\"\n",
        "proof": "proof-\n  {\n    fix x y assume \"x\\<in>\\<Union>ProductTopology(T,S)\"\"y\\<in>\\<Union>ProductTopology(T,S)\"\"x\\<noteq>y\"\n    then have tot:\"x\\<in>\\<Union>T\\<times>\\<Union>S\"\"y\\<in>\\<Union>T\\<times>\\<Union>S\"\"x\\<noteq>y\" using Top_1_4_T1(3) assms(1,2) by auto\n    then have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\"\"\\<langle>fst(y),snd(y)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\" and disj:\"fst(x)\\<noteq>fst(y)\\<or>snd(x)\\<noteq>snd(y)\" \n      using Pair_fst_snd_eq by auto\n    then have T:\"fst(x)\\<in>\\<Union>T\"\"fst(y)\\<in>\\<Union>T\" and S:\"snd(y)\\<in>\\<Union>S\"\"snd(x)\\<in>\\<Union>S\" and p:\"fst(x)\\<noteq>fst(y)\\<or>snd(x)\\<noteq>snd(y)\"\n      by auto\n    {\n      assume \"fst(x)\\<noteq>fst(y)\"\n      with T assms(3) have \"(\\<exists>U\\<in>T. (fst(x)\\<in>U\\<and>fst(y)\\<notin>U))\" unfolding\n        isT1_def by auto\n      then obtain U where \"U\\<in>T\" \"(fst(x)\\<in>U\\<and>fst(y)\\<notin>U)\" by auto\n      with S have \"(\\<langle>fst(x),snd(x)\\<rangle>\\<in>U\\<times>(\\<Union>S) \\<and> \\<langle>fst(y),snd(y)\\<rangle>\\<notin>U\\<times>(\\<Union>S))\" by auto\n      then have \"(x\\<in>U\\<times>(\\<Union>S) \\<and> y\\<notin>U\\<times>(\\<Union>S))\" using Pair_fst_snd_eq tot(1,2) by auto\n      moreover have \"(\\<Union>S)\\<in>S\" using assms(2) unfolding IsATopology_def by auto\n      with \\<open>U\\<in>T\\<close> have \"U\\<times>(\\<Union>S)\\<in>ProductTopology(T,S)\" using prod_open_open_prod assms(1,2) by auto\n      ultimately\n      have \"\\<exists>V\\<in>ProductTopology(T,S). (x\\<in>V \\<and> y\\<notin>V)\" proof qed\n    } moreover\n    {\n      assume \"snd(x)\\<noteq>snd(y)\"\n      with S assms(4) have \"(\\<exists>U\\<in>S. (snd(x)\\<in>U\\<and>snd(y)\\<notin>U))\" unfolding\n        isT1_def by auto\n      then obtain U where \"U\\<in>S\" \"(snd(x)\\<in>U\\<and>snd(y)\\<notin>U)\" by auto\n      with T have \"(\\<langle>fst(x),snd(x)\\<rangle>\\<in>(\\<Union>T)\\<times>U \\<and> \\<langle>fst(y),snd(y)\\<rangle>\\<notin>(\\<Union>T)\\<times>U)\" by auto\n      then have \"(x\\<in>(\\<Union>T)\\<times>U \\<and> y\\<notin>(\\<Union>T)\\<times>U)\" using Pair_fst_snd_eq tot(1,2) by auto\n      moreover have \"(\\<Union>T)\\<in>T\" using assms(1) unfolding IsATopology_def by auto\n      with \\<open>U\\<in>S\\<close> have \"(\\<Union>T)\\<times>U\\<in>ProductTopology(T,S)\" using prod_open_open_prod assms(1,2) by auto\n      ultimately\n      have \"\\<exists>V\\<in>ProductTopology(T,S). (x\\<in>V \\<and> y\\<notin>V)\" proof qed\n    }moreover\n    note disj\n    ultimately have \"\\<exists>V\\<in>ProductTopology(T,S). (x\\<in>V \\<and> y\\<notin>V)\" by auto\n  }\n  then show ?thesis unfolding isT1_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2066
    },
    "1863": {
        "type": "theorem",
        "text": "text\\<open>The product of $T_2$ spaces is $T_2$.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is T\\<^sub>2}\"\"S{is T\\<^sub>2}\"\n  ",
        "using": [
            "Top_1_4_T1(3)",
            "assms(1,2)",
            "Pair_fst_snd_eq",
            "tot(1,2)",
            "assms(2)",
            "IsATopology_def",
            "prod_open_open_prod",
            "exI[where",
            "x=\"V\\<times>(\\<Union>S)\"",
            "and",
            "P=\"\\<lambda>t.",
            "t\\<in>ProductTopology(T,S)",
            "\\<and>",
            "(x\\<in>U\\<times>(\\<Union>S)",
            "y\\<in>t",
            "(U\\<times>(\\<Union>S))\\<inter>t=0)\"]",
            "x=\"U\\<times>(\\<Union>S)\"",
            "(\\<exists>UU\\<in>ProductTopology(T,S).",
            "(x\\<in>t",
            "y\\<in>UU",
            "(t)\\<inter>UU=0))\"]",
            "assms(1)",
            "x=\"(\\<Union>T)\\<times>V\"",
            "(x\\<in>(\\<Union>T)\\<times>U",
            "((\\<Union>T)\\<times>U)\\<inter>t=0)\"]",
            "x=\"(\\<Union>T)\\<times>U\""
        ],
        "statement": "theorem T2_product:\n  assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is T\\<^sub>2}\"\"S{is T\\<^sub>2}\"\n  shows \"ProductTopology(T,S){is T\\<^sub>2}\"\n",
        "proof": "proof-\n  {\n    fix x y assume \"x\\<in>\\<Union>ProductTopology(T,S)\"\"y\\<in>\\<Union>ProductTopology(T,S)\"\"x\\<noteq>y\"\n    then have tot:\"x\\<in>\\<Union>T\\<times>\\<Union>S\"\"y\\<in>\\<Union>T\\<times>\\<Union>S\"\"x\\<noteq>y\" using Top_1_4_T1(3) assms(1,2) by auto\n    then have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\"\"\\<langle>fst(y),snd(y)\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>S\" and disj:\"fst(x)\\<noteq>fst(y)\\<or>snd(x)\\<noteq>snd(y)\" \n      using Pair_fst_snd_eq by auto\n    then have T:\"fst(x)\\<in>\\<Union>T\"\"fst(y)\\<in>\\<Union>T\" and S:\"snd(y)\\<in>\\<Union>S\"\"snd(x)\\<in>\\<Union>S\" and p:\"fst(x)\\<noteq>fst(y)\\<or>snd(x)\\<noteq>snd(y)\"\n      by auto\n    {\n      assume \"fst(x)\\<noteq>fst(y)\"\n      with T assms(3) have \"(\\<exists>U\\<in>T. \\<exists>V\\<in>T. (fst(x)\\<in>U\\<and>fst(y)\\<in>V) \\<and> U\\<inter>V=0)\" unfolding\n        isT2_def by auto\n      then obtain U V where \"U\\<in>T\" \"V\\<in>T\" \"fst(x)\\<in>U\" \"fst(y)\\<in>V\" \"U\\<inter>V=0\" by auto\n      with S have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>U\\<times>(\\<Union>S)\" \"\\<langle>fst(y),snd(y)\\<rangle>\\<in>V\\<times>(\\<Union>S)\" and disjoint:\"(U\\<times>\\<Union>S)\\<inter>(V\\<times>\\<Union>S)=0\" by auto\n      then have \"x\\<in>U\\<times>(\\<Union>S)\"\"y\\<in>V\\<times>(\\<Union>S)\" using Pair_fst_snd_eq tot(1,2) by auto\n      moreover have \"(\\<Union>S)\\<in>S\" using assms(2) unfolding IsATopology_def by auto\n      with \\<open>U\\<in>T\\<close>\\<open>V\\<in>T\\<close> have P:\"U\\<times>(\\<Union>S)\\<in>ProductTopology(T,S)\" \"V\\<times>(\\<Union>S)\\<in>ProductTopology(T,S)\" \n        using prod_open_open_prod assms(1,2) by auto\n      note disjoint ultimately \n      have \"x\\<in>U\\<times>(\\<Union>S) \\<and> y\\<in>V\\<times>(\\<Union>S) \\<and> (U\\<times>(\\<Union>S))\\<inter>(V\\<times>(\\<Union>S))=0\" by auto\n      with P(2) have \"\\<exists>UU\\<in>ProductTopology(T,S). (x\\<in>U\\<times>(\\<Union>S) \\<and> y\\<in>UU \\<and> (U\\<times>(\\<Union>S))\\<inter>UU=0)\"\n        using exI[where x=\"V\\<times>(\\<Union>S)\" and P=\"\\<lambda>t. t\\<in>ProductTopology(T,S) \\<and> (x\\<in>U\\<times>(\\<Union>S) \\<and> y\\<in>t \\<and> (U\\<times>(\\<Union>S))\\<inter>t=0)\"] by auto\n      with P(1) have \"\\<exists>VV\\<in>ProductTopology(T,S). \\<exists>UU\\<in>ProductTopology(T,S). (x\\<in>VV \\<and> y\\<in>UU \\<and> VV\\<inter>UU=0)\" \n        using exI[where x=\"U\\<times>(\\<Union>S)\" and P=\"\\<lambda>t. t\\<in>ProductTopology(T,S) \\<and> (\\<exists>UU\\<in>ProductTopology(T,S). (x\\<in>t \\<and> y\\<in>UU \\<and> (t)\\<inter>UU=0))\"] by auto\n    } moreover\n    {\n      assume \"snd(x)\\<noteq>snd(y)\"\n      with S assms(4) have \"(\\<exists>U\\<in>S. \\<exists>V\\<in>S. (snd(x)\\<in>U\\<and>snd(y)\\<in>V) \\<and> U\\<inter>V=0)\" unfolding\n        isT2_def by auto\n      then obtain U V where \"U\\<in>S\" \"V\\<in>S\" \"snd(x)\\<in>U\" \"snd(y)\\<in>V\" \"U\\<inter>V=0\" by auto\n      with T have \"\\<langle>fst(x),snd(x)\\<rangle>\\<in>(\\<Union>T)\\<times>U\" \"\\<langle>fst(y),snd(y)\\<rangle>\\<in>(\\<Union>T)\\<times>V\" and disjoint:\"((\\<Union>T)\\<times>U)\\<inter>((\\<Union>T)\\<times>V)=0\" by auto\n      then have \"x\\<in>(\\<Union>T)\\<times>U\"\"y\\<in>(\\<Union>T)\\<times>V\" using Pair_fst_snd_eq tot(1,2) by auto\n      moreover have \"(\\<Union>T)\\<in>T\" using assms(1) unfolding IsATopology_def by auto\n      with \\<open>U\\<in>S\\<close>\\<open>V\\<in>S\\<close> have P:\"(\\<Union>T)\\<times>U\\<in>ProductTopology(T,S)\" \"(\\<Union>T)\\<times>V\\<in>ProductTopology(T,S)\" \n        using prod_open_open_prod assms(1,2) by auto\n      note disjoint ultimately \n      have \"x\\<in>(\\<Union>T)\\<times>U \\<and> y\\<in>(\\<Union>T)\\<times>V \\<and> ((\\<Union>T)\\<times>U)\\<inter>((\\<Union>T)\\<times>V)=0\" by auto\n      with P(2) have \"\\<exists>UU\\<in>ProductTopology(T,S). (x\\<in>(\\<Union>T)\\<times>U \\<and> y\\<in>UU \\<and> ((\\<Union>T)\\<times>U)\\<inter>UU=0)\"\n        using exI[where x=\"(\\<Union>T)\\<times>V\" and P=\"\\<lambda>t. t\\<in>ProductTopology(T,S) \\<and> (x\\<in>(\\<Union>T)\\<times>U \\<and> y\\<in>t \\<and> ((\\<Union>T)\\<times>U)\\<inter>t=0)\"] by auto\n      with P(1) have \"\\<exists>VV\\<in>ProductTopology(T,S). \\<exists>UU\\<in>ProductTopology(T,S). (x\\<in>VV \\<and> y\\<in>UU \\<and> VV\\<inter>UU=0)\" \n        using exI[where x=\"(\\<Union>T)\\<times>U\" and P=\"\\<lambda>t. t\\<in>ProductTopology(T,S) \\<and> (\\<exists>UU\\<in>ProductTopology(T,S). (x\\<in>t \\<and> y\\<in>UU \\<and> (t)\\<inter>UU=0))\"] by auto\n    } moreover\n    note disj\n    ultimately have \"\\<exists>VV\\<in>ProductTopology(T, S). \\<exists>UU\\<in>ProductTopology(T, S). x \\<in> VV \\<and> y \\<in> UU \\<and> VV \\<inter> UU = 0\" by auto\n  }\n  then show ?thesis unfolding isT2_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2067
    },
    "1864": {
        "type": "theorem",
        "text": "text\\<open>The product of regular spaces is regular.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\" \"S{is a topology}\" \"T{is regular}\" \"S{is regular}\"\n  ",
        "using": [
            "prod_top_point_neighb",
            "assms(1,2)",
            "assms(1,3)",
            "topology0.regular_imp_exist_clos_neig",
            "topology0_def",
            "assms(2,4)",
            "x",
            "cl_product",
            "prod_open_open_prod",
            "VV(3)",
            "WW(3)",
            "topology0.exist_clos_neig_imp_regular",
            "Top_1_4_T1(1)"
        ],
        "statement": "theorem regular_product:\n  assumes \"T{is a topology}\" \"S{is a topology}\" \"T{is regular}\" \"S{is regular}\"\n  shows \"ProductTopology(T,S){is regular}\"\n",
        "proof": "proof-\n  {\n    fix x U assume \"x\\<in>\\<Union>ProductTopology(T,S)\" \"U\\<in>ProductTopology(T,S)\" \"x\\<in>U\"\n    then obtain V W where VW:\"V\\<in>T\"\"W\\<in>S\" \"V\\<times>W\\<subseteq>U\" and x:\"x\\<in>V\\<times>W\" using prod_top_point_neighb \n      assms(1,2) by blast\n    then have p:\"fst(x)\\<in>V\"\"snd(x)\\<in>W\" by auto\n    from p(1) \\<open>V\\<in>T\\<close> obtain VV where VV:\"fst(x)\\<in>VV\" \"Closure(VV,T)\\<subseteq>V\" \"VV\\<in>T\" using \n      assms(1,3) topology0.regular_imp_exist_clos_neig unfolding topology0_def\n      by force moreover\n    from p(2) \\<open>W\\<in>S\\<close> obtain WW where WW:\"snd(x)\\<in>WW\" \"Closure(WW,S)\\<subseteq>W\" \"WW\\<in>S\" using \n      assms(2,4) topology0.regular_imp_exist_clos_neig unfolding topology0_def\n      by force ultimately\n    have  \"x\\<in>VV\\<times>WW\" using x by auto\n    moreover from  \\<open>Closure(VV,T)\\<subseteq>V\\<close> \\<open>Closure(WW,S)\\<subseteq>W\\<close> have \"Closure(VV,T)\\<times>Closure(WW,S) \\<subseteq> V\\<times>W\"\n      by auto \n    moreover from VV(3) WW(3) have \"VV\\<subseteq>\\<Union>T\"\"WW\\<subseteq>\\<Union>S\" by auto\n    ultimately have \"x\\<in>VV\\<times>WW\" \"Closure(VV\\<times>WW,ProductTopology(T,S)) \\<subseteq> V\\<times>W\" using cl_product assms(1,2)\n      by auto\n    moreover have \"VV\\<times>WW\\<in>ProductTopology(T,S)\" using prod_open_open_prod assms(1,2)\n      VV(3) WW(3) by auto\n    ultimately have \"\\<exists>Z\\<in>ProductTopology(T,S). x\\<in>Z \\<and> Closure(Z,ProductTopology(T,S))\\<subseteq>V\\<times>W\" by auto\n    with VW(3) have \"\\<exists>Z\\<in>ProductTopology(T,S). x\\<in>Z \\<and> Closure(Z,ProductTopology(T,S))\\<subseteq>U\" by auto\n  }\n  then have \"\\<forall>x\\<in>\\<Union>ProductTopology(T,S). \\<forall>U\\<in>ProductTopology(T,S).x\\<in>U \\<longrightarrow> (\\<exists>Z\\<in>ProductTopology(T,S). x\\<in>Z \\<and> Closure(Z,ProductTopology(T,S))\\<subseteq>U)\"\n    by auto\n  then show ?thesis using topology0.exist_clos_neig_imp_regular unfolding topology0_def\n    using assms(1,2) Top_1_4_T1(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2068
    },
    "1865": {
        "type": "theorem",
        "text": "text\\<open>The product of connected spaces is connected.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is connected}\"\"S{is connected}\"\n  ",
        "using": [
            "prod_sec_open2",
            "assms(1,2)",
            "Top_1_4_T1(3)",
            "Pair_fst_snd_eq",
            "prod_sec_open1"
        ],
        "statement": "theorem compact_product:\n  assumes \"T{is a topology}\"\"S{is a topology}\"\"T{is connected}\"\"S{is connected}\"\n  shows \"ProductTopology(T,S){is connected}\"\n",
        "proof": "proof-\n  {\n    fix U assume U:\"U\\<in>ProductTopology(T,S)\" \"U{is closed in}ProductTopology(T,S)\"\n    then have P:\"U\\<in>ProductTopology(T,S)\" \"\\<Union>ProductTopology(T,S)-U\\<in>ProductTopology(T,S)\"\n      unfolding IsClosed_def by auto\n    {\n      fix s assume s:\"s\\<in>\\<Union>S\" \n      with P(1) have p:\"{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}\\<in>T\" using prod_sec_open2 assms(1,2) by auto\n      from s P(2) have oop:\"{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\\<in>T\" using prod_sec_open2\n        assms(1,2) by blast\n      then have \"\\<Union>T-(\\<Union>T-{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)})={y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n      with oop have cl:\"(\\<Union>T-{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}) {is closed in}T\" unfolding IsClosed_def by auto\n      {\n        fix t assume \"t\\<in>\\<Union>T-{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\"\n        then have tt:\"t\\<in>\\<Union>T\" \"t\\<notin>{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<notin>(\\<Union>ProductTopology(T,S)-U)\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<in>U \\<or> \\<langle>t,s\\<rangle>\\<notin>\\<Union>ProductTopology(T,S)\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<in>U \\<or> \\<langle>t,s\\<rangle>\\<notin>\\<Union>T\\<times>\\<Union>S\" using Top_1_4_T1(3) assms(1,2) by auto\n        with tt(1) s have \"\\<langle>t,s\\<rangle>\\<in>U\" by auto\n        with tt(1) have \"t\\<in>{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}\" by auto\n      } moreover\n      {\n        fix t assume \"t\\<in>{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}\"\n        then have tt:\"t\\<in>\\<Union>T\" \"\\<langle>t,s\\<rangle>\\<in>U\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<notin>\\<Union>ProductTopology(T,S)-U\" by auto\n        then have \"t\\<notin>{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n        with tt(1) have \"t\\<in>\\<Union>T-{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n      }\n      ultimately have \"{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}=\\<Union>T-{y\\<in>\\<Union>T. \\<langle>y,s\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by blast\n      with cl have \"{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}{is closed in}T\" by auto\n      with p assms(3) have \"{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}=0 \\<or> {x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}=\\<Union>T\" unfolding IsConnected_def\n        by auto moreover\n      {\n        assume \"{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}=0\"\n        then have \"\\<forall>x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<notin>U\" by auto\n      }\n      moreover\n      {\n        assume AA:\"{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}=\\<Union>T\"\n        {\n          fix x assume \"x\\<in>\\<Union>T\"\n          with AA have \"x\\<in>{x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U}\" by auto\n          then have \"\\<langle>x,s\\<rangle>\\<in>U\" by auto\n        }\n        then have \"\\<forall>x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U\" by auto\n      }\n      ultimately have \"(\\<forall>x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<notin>U) \\<or> (\\<forall>x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U)\" by blast\n    }\n    then have reg:\"\\<forall>s\\<in>\\<Union>S. (\\<forall>x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<notin>U) \\<or> (\\<forall>x\\<in>\\<Union>T. \\<langle>x,s\\<rangle>\\<in>U)\" by auto\n    {\n      fix q assume qU:\"q\\<in>\\<Union>T\\<times>{snd(qq). qq\\<in>U}\"\n      then obtain t u where t:\"t\\<in>\\<Union>T\" \"u\\<in>U\" \"q=\\<langle>t,snd(u)\\<rangle>\" by auto\n      with U(1) have \"u\\<in>\\<Union>ProductTopology(T,S)\" by auto\n      then have \"u\\<in>\\<Union>T\\<times>\\<Union>S\" using Top_1_4_T1(3) assms(1,2) by auto moreover\n      then have uu:\"u=\\<langle>fst(u),snd(u)\\<rangle>\" using Pair_fst_snd_eq by auto ultimately\n      have fu:\"fst(u)\\<in>\\<Union>T\"\"snd(u)\\<in>\\<Union>S\" by (safe,auto)\n      with reg have \"(\\<forall>tt\\<in>\\<Union>T. \\<langle>tt,snd(u)\\<rangle>\\<notin>U)\\<or>(\\<forall>tt\\<in>\\<Union>T. \\<langle>tt,snd(u)\\<rangle>\\<in>U)\" by auto\n      with \\<open>u\\<in>U\\<close> uu fu(1) have \"\\<forall>tt\\<in>\\<Union>T. \\<langle>tt,snd(u)\\<rangle>\\<in>U\" by force\n      with t(1,3) have \"q\\<in>U\" by auto\n    }\n    then have U1:\"\\<Union>T\\<times>{snd(qq). qq\\<in>U}\\<subseteq>U\" by auto\n    {\n      fix t assume t:\"t\\<in>\\<Union>T\" \n      with P(1) have p:\"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}\\<in>S\" using prod_sec_open1 assms(1,2) by auto\n      from t P(2) have oop:\"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\\<in>S\" using prod_sec_open1\n        assms(1,2) by blast\n      then have \"\\<Union>S-(\\<Union>S-{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)})={y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n      with oop have cl:\"(\\<Union>S-{y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}) {is closed in}S\" unfolding IsClosed_def by auto\n      {\n        fix s assume \"s\\<in>\\<Union>S-{y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\"\n        then have tt:\"s\\<in>\\<Union>S\" \"s\\<notin>{y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<notin>(\\<Union>ProductTopology(T,S)-U)\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<in>U \\<or> \\<langle>t,s\\<rangle>\\<notin>\\<Union>ProductTopology(T,S)\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<in>U \\<or> \\<langle>t,s\\<rangle>\\<notin>\\<Union>T\\<times>\\<Union>S\" using Top_1_4_T1(3) assms(1,2) by auto\n        with tt(1) t have \"\\<langle>t,s\\<rangle>\\<in>U\" by auto\n        with tt(1) have \"s\\<in>{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}\" by auto\n      } moreover\n      {\n        fix s assume \"s\\<in>{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}\"\n        then have tt:\"s\\<in>\\<Union>S\" \"\\<langle>t,s\\<rangle>\\<in>U\" by auto\n        then have \"\\<langle>t,s\\<rangle>\\<notin>\\<Union>ProductTopology(T,S)-U\" by auto\n        then have \"s\\<notin>{y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n        with tt(1) have \"s\\<in>\\<Union>S-{y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by auto\n      }\n      ultimately have \"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}=\\<Union>S-{y\\<in>\\<Union>S. \\<langle>t,y\\<rangle>\\<in>(\\<Union>ProductTopology(T,S)-U)}\" by blast\n      with cl have \"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}{is closed in}S\" by auto\n      with p assms(4) have \"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}=0 \\<or> {x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}=\\<Union>S\" unfolding IsConnected_def\n        by auto moreover\n      {\n        assume \"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}=0\"\n        then have \"\\<forall>x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<notin>U\" by auto\n      }\n      moreover\n      {\n        assume AA:\"{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}=\\<Union>S\"\n        {\n          fix x assume \"x\\<in>\\<Union>S\"\n          with AA have \"x\\<in>{x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U}\" by auto\n          then have \"\\<langle>t,x\\<rangle>\\<in>U\" by auto\n        }\n        then have \"\\<forall>x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U\" by auto\n      }\n      ultimately have \"(\\<forall>x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<notin>U) \\<or> (\\<forall>x\\<in>\\<Union>S. \\<langle>t,x\\<rangle>\\<in>U)\" by blast\n    }\n    then have reg:\"\\<forall>s\\<in>\\<Union>T. (\\<forall>x\\<in>\\<Union>S. \\<langle>s,x\\<rangle>\\<notin>U) \\<or> (\\<forall>x\\<in>\\<Union>S. \\<langle>s,x\\<rangle>\\<in>U)\" by auto\n    {\n      fix q assume qU:\"q\\<in>{fst(qq). qq\\<in>U}\\<times>\\<Union>S\"\n      then obtain qq s where t:\"q=\\<langle>fst(qq),s\\<rangle>\" \"qq\\<in>U\" \"s\\<in>\\<Union>S\" by auto\n      with U(1) have \"qq\\<in>\\<Union>ProductTopology(T,S)\" by auto\n      then have \"qq\\<in>\\<Union>T\\<times>\\<Union>S\" using Top_1_4_T1(3) assms(1,2) by auto moreover\n      then have qq:\"qq=\\<langle>fst(qq),snd(qq)\\<rangle>\" using Pair_fst_snd_eq by auto ultimately\n      have fq:\"fst(qq)\\<in>\\<Union>T\"\"snd(qq)\\<in>\\<Union>S\" by (safe,auto)\n      from fq(1) reg have \"(\\<forall>tt\\<in>\\<Union>S. \\<langle>fst(qq),tt\\<rangle>\\<notin>U)\\<or>(\\<forall>tt\\<in>\\<Union>S. \\<langle>fst(qq),tt\\<rangle>\\<in>U)\" by auto moreover\n      with \\<open>qq\\<in>U\\<close> qq fq(2) have \"\\<forall>tt\\<in>\\<Union>S. \\<langle>fst(qq),tt\\<rangle>\\<in>U\" by force\n      with t(1,3) have \"q\\<in>U\" by auto\n    }\n    then have U2:\"{fst(qq). qq\\<in>U}\\<times>\\<Union>S\\<subseteq>U\" by blast\n    {\n      assume \"U\\<noteq>0\"\n      then obtain u where u:\"u\\<in>U\" by auto\n      {\n        fix aa assume \"aa\\<in>\\<Union>T\\<times>\\<Union>S\"\n        then obtain t s where \"t\\<in>\\<Union>T\"\"s\\<in>\\<Union>S\"\"aa=\\<langle>t,s\\<rangle>\" by auto\n        with u have \"\\<langle>t,snd(u)\\<rangle>\\<in>\\<Union>T\\<times>{snd(qq). qq\\<in>U}\" by auto\n        with U1 have \"\\<langle>t,snd(u)\\<rangle>\\<in>U\" by auto\n        moreover have \"t=fst(\\<langle>t,snd(u)\\<rangle>)\" by auto moreover note \\<open>s\\<in>\\<Union>S\\<close> ultimately\n        have \"\\<langle>t,s\\<rangle>\\<in>{fst(qq). qq\\<in>U}\\<times>\\<Union>S\" by blast\n        with U2 have \"\\<langle>t,s\\<rangle>\\<in>U\" by auto\n        with \\<open>aa=\\<langle>t,s\\<rangle>\\<close> have \"aa\\<in>U\" by auto\n      }\n      then have \"\\<Union>T\\<times>\\<Union>S\\<subseteq>U\" by auto moreover\n      with U(1) have \"U\\<subseteq>\\<Union>ProductTopology(T,S)\" by auto ultimately\n      have \"\\<Union>T\\<times>\\<Union>S=U\" using Top_1_4_T1(3) assms(1,2) by auto\n    }\n    then have \"(U=0)\\<or>(U=\\<Union>T\\<times>\\<Union>S)\" by auto\n  }\n  then show ?thesis unfolding IsConnected_def using Top_1_4_T1(3) assms(1,2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2070
    },
    "1866": {
        "type": "definition",
        "text": "text\\<open>Some order-dense properties:\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsDenseSub (\"_ {is dense in}_{with respect to}_\") where\n  \"A {is dense in}X{with respect to}r \\<equiv> \n  \\<forall>x\\<in>X. \\<forall>y\\<in>X. \\<langle>x,y\\<rangle>\\<in>r \\<and> x\\<noteq>y  \\<longrightarrow> (\\<exists>z\\<in>A-{x,y}. \\<langle>x,z\\<rangle>\\<in>r\\<and>\\<langle>z,y\\<rangle>\\<in>r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2072
    },
    "1867": {
        "type": "theorem",
        "text": "text\\<open>In densely ordered sets, intervals are infinite.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"IntervalX(X, r, b, c)\\<noteq>0\"\"b\\<in>X\"\"c\\<in>X\" \"X{is dense with respect to}r\"\n  ",
        "using": [
            "Finite_ZF_1_T2(2)[OF",
            "assms(1)",
            "Finite_Fin[OF",
            "fin",
            "sub]",
            "assms(2)]",
            "Order_ZF_2_L1",
            "IsLinOrder_def",
            "antisym_def",
            "z1(3)",
            "Finite_ZF_1_T2(4)[OF"
        ],
        "statement": "theorem dense_order_inf_intervals:\n  assumes \"IsLinOrder(X,r)\" \"IntervalX(X, r, b, c)\\<noteq>0\"\"b\\<in>X\"\"c\\<in>X\" \"X{is dense with respect to}r\"\n  shows \"\\<not>Finite(IntervalX(X, r, b, c))\"\n",
        "proof": "proof\n  assume fin:\"Finite(IntervalX(X, r, b, c))\"\n  have sub:\"IntervalX(X, r, b, c)\\<subseteq>X\" unfolding IntervalX_def by auto\n  have p:\"Minimum(r,IntervalX(X, r, b, c))\\<in>IntervalX(X, r, b, c)\" using Finite_ZF_1_T2(2)[OF assms(1) Finite_Fin[OF fin sub] assms(2)]\n    by auto\n  then have \"\\<langle>b,Minimum(r,IntervalX(X, r, b, c))\\<rangle>\\<in>r\"\"b\\<noteq>Minimum(r,IntervalX(X, r, b, c))\"\n    unfolding IntervalX_def using Order_ZF_2_L1 by auto\n  with assms(3,5) sub p obtain z1 where z1:\"z1\\<in>X\"\"z1\\<noteq>b\"\"z1\\<noteq>Minimum(r,IntervalX(X, r, b, c))\"\"\\<langle>b,z1\\<rangle>\\<in>r\"\"\\<langle>z1,Minimum(r,IntervalX(X, r, b, c))\\<rangle>\\<in>r\"\n    unfolding IsDense_def by blast\n  from p have B:\"\\<langle>Minimum(r,IntervalX(X, r, b, c)),c\\<rangle>\\<in>r\" unfolding IntervalX_def using Order_ZF_2_L1 by auto moreover\n  have \"trans(r)\" using assms(1) unfolding IsLinOrder_def by auto moreover\n  note z1(5) ultimately have z1a:\"\\<langle>z1,c\\<rangle>\\<in>r\" unfolding trans_def by fast\n  {\n    assume \"z1=c\"\n    with B have \"\\<langle>Minimum(r,IntervalX(X, r, b, c)),z1\\<rangle>\\<in>r\" by auto\n    with z1(5) have \"z1=Minimum(r,IntervalX(X, r, b, c))\" using assms(1) unfolding IsLinOrder_def antisym_def by auto\n    then have \"False\" using z1(3) by auto\n  }\n  then have \"z1\\<noteq>c\" by auto\n  with z1(1,2,4) z1a have \"z1\\<in>IntervalX(X, r, b, c)\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n  then have \"\\<langle>Minimum(r,IntervalX(X, r, b, c)),z1\\<rangle>\\<in>r\" using Finite_ZF_1_T2(4)[OF assms(1) Finite_Fin[OF fin sub] assms(2)] by auto\n  with z1(5) have \"z1=Minimum(r,IntervalX(X, r, b, c))\" using assms(1) unfolding IsLinOrder_def antisym_def by auto\n  with z1(3) show \"False\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2073
    },
    "1868": {
        "type": "theorem",
        "text": "text\\<open>Left rays are infinite.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"LeftRayX(X,r,c)\\<noteq>0\"\"c\\<in>X\"  \"X{is dense with respect to}r\"\n  ",
        "using": [
            "assms(4)",
            "IsDense_def",
            "Order_ZF_2_L1",
            "dense_order_inf_intervals[OF",
            "assms(1)",
            "_",
            "assms(3,4)]",
            "\\<open>b\\<in>X\\<close>",
            "subset_Finite"
        ],
        "statement": "theorem dense_order_inf_lrays:\n  assumes \"IsLinOrder(X,r)\" \"LeftRayX(X,r,c)\\<noteq>0\"\"c\\<in>X\"  \"X{is dense with respect to}r\"\n  shows \"\\<not>Finite(LeftRayX(X,r,c))\"\n",
        "proof": "proof-\n  from assms(2) obtain b where \"b\\<in>X\"\"\\<langle>b,c\\<rangle>\\<in>r\"\"b\\<noteq>c\" unfolding LeftRayX_def by auto\n  with assms(3) obtain z where \"z\\<in>X-{b,c}\"\"\\<langle>b,z\\<rangle>\\<in>r\"\"\\<langle>z,c\\<rangle>\\<in>r\" using assms(4) unfolding IsDense_def by auto\n  then have \"IntervalX(X, r, b, c)\\<noteq>0\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n  then have nFIN:\"\\<not>Finite(IntervalX(X, r, b, c))\" using dense_order_inf_intervals[OF assms(1) _ _ assms(3,4)]\n    \\<open>b\\<in>X\\<close> by auto\n  {\n    fix d assume \"d\\<in>IntervalX(X, r, b, c)\"\n    then have \"\\<langle>b,d\\<rangle>\\<in>r\"\"\\<langle>d,c\\<rangle>\\<in>r\"\"d\\<in>X\"\"d\\<noteq>b\"\"d\\<noteq>c\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n    then have \"d\\<in>LeftRayX(X,r,c)\" unfolding LeftRayX_def by auto\n  }\n  then have \"IntervalX(X, r, b, c)\\<subseteq>LeftRayX(X,r,c)\" by auto\n  with nFIN show ?thesis using subset_Finite by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2074
    },
    "1869": {
        "type": "theorem",
        "text": "text\\<open>Right rays are infinite.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"RightRayX(X,r,b)\\<noteq>0\"\"b\\<in>X\"  \"X{is dense with respect to}r\"\n  ",
        "using": [
            "assms(4)",
            "IsDense_def",
            "Order_ZF_2_L1",
            "dense_order_inf_intervals[OF",
            "assms(1)",
            "_",
            "assms(3)",
            "assms(4)]",
            "\\<open>c\\<in>X\\<close>",
            "subset_Finite"
        ],
        "statement": "theorem dense_order_inf_rrays:\n  assumes \"IsLinOrder(X,r)\" \"RightRayX(X,r,b)\\<noteq>0\"\"b\\<in>X\"  \"X{is dense with respect to}r\"\n  shows \"\\<not>Finite(RightRayX(X,r,b))\"\n",
        "proof": "proof-\n  from assms(2) obtain c where \"c\\<in>X\"\"\\<langle>b,c\\<rangle>\\<in>r\"\"b\\<noteq>c\" unfolding RightRayX_def by auto\n  with assms(3) obtain z where \"z\\<in>X-{b,c}\"\"\\<langle>b,z\\<rangle>\\<in>r\"\"\\<langle>z,c\\<rangle>\\<in>r\" using assms(4) unfolding IsDense_def by auto\n  then have \"IntervalX(X, r, b, c)\\<noteq>0\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n  then have nFIN:\"\\<not>Finite(IntervalX(X, r, b, c))\" using dense_order_inf_intervals[OF assms(1) _ assms(3) _ assms(4)]\n    \\<open>c\\<in>X\\<close> by auto\n  {\n    fix d assume \"d\\<in>IntervalX(X, r, b, c)\"\n    then have \"\\<langle>b,d\\<rangle>\\<in>r\"\"\\<langle>d,c\\<rangle>\\<in>r\"\"d\\<in>X\"\"d\\<noteq>b\"\"d\\<noteq>c\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n    then have \"d\\<in>RightRayX(X,r,b)\" unfolding RightRayX_def by auto\n  }\n  then have \"IntervalX(X, r, b, c)\\<subseteq>RightRayX(X,r,b)\" by auto\n  with nFIN show ?thesis using subset_Finite by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2075
    },
    "1870": {
        "type": "theorem",
        "text": "text\\<open>If an order topology is connected, then the order is complete.\nIt is equivalent to assume that $r\\subseteq X\\times X$ or prove that\n$r\\cap X\\times X$ is complete.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\" \"r\\<subseteq>X\\<times>X\"\n     \"(OrdTopology X r){is connected}\"\n  ",
        "using": [
            "image_iff",
            "A(1)",
            "assms(1)",
            "IsLinOrder_def",
            "IsTotal_def",
            "\\<open>x\\<in>X\\<close>\\<open>\\<langle>x,z\\<rangle>\\<notin>r\\<close>",
            "total_is_refl",
            "refl_def",
            "trans_def",
            "base_sets_open[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "assms(1)]]",
            "\\<open>z\\<in>X\\<close>",
            "topology0.open_neigh_open[OF",
            "topology0_ordtopology[OF",
            "\\<open>x\\<in>X\\<close>",
            "\\<open>\\<langle>b,x\\<rangle>\\<notin>r\\<close>",
            "antisym_def",
            "\\<open>y\\<in>X-{b}\\<close>",
            "\\<open>b\\<in>A\\<close>\\<open>A\\<subseteq>X\\<close>",
            "union_ordtopology[OF",
            "assms(1,2)]",
            "sub",
            "IsConnected_def",
            "noE",
            "\\<open>A\\<subseteq>X\\<close>"
        ],
        "statement": "theorem conn_imp_complete:\n  assumes \"IsLinOrder(X,r)\" \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\" \"r\\<subseteq>X\\<times>X\"\n     \"(OrdTopology X r){is connected}\"\n  shows \"r{is complete}\"\n",
        "proof": "proof-\n  {\n    assume \"\\<not>(r{is complete})\"\n    then obtain A where A:\"A\\<noteq>0\"\"IsBoundedAbove(A,r)\"\"\\<not>(HasAminimum(r, \\<Inter>b\\<in>A. r `` {b}))\" unfolding\n      IsComplete_def by auto\n    from A(3) have r1:\"\\<forall>m\\<in>\\<Inter>b\\<in>A. r `` {b}. \\<exists>x\\<in>\\<Inter>b\\<in>A. r `` {b}. \\<langle>m,x\\<rangle>\\<notin>r\" unfolding HasAminimum_def\n      by force\n    from A(1,2) obtain b where r2:\"\\<forall>x\\<in>A. \\<langle>x, b\\<rangle> \\<in> r\" unfolding IsBoundedAbove_def by auto\n    with assms(3) A(1) have \"A\\<subseteq>X\"\"b\\<in>X\" by auto\n    with assms(3) have r3:\"\\<forall>c\\<in>A. r `` {c}\\<subseteq>X\" using image_iff by auto\n    from r2 have \"\\<forall>x\\<in>A. b\\<in>r``{x}\" using image_iff by auto\n    then have noE:\"b\\<in>(\\<Inter>b\\<in>A. r `` {b})\" using A(1) by auto\n    {\n      fix x assume \"x\\<in>(\\<Inter>b\\<in>A. r `` {b})\"\n      then have \"\\<forall>c\\<in>A. x\\<in>r``{c}\" by auto\n      with A(1) obtain c where \"c\\<in>A\" \"x\\<in>r``{c}\" by auto\n      with r3 have \"x\\<in>X\" by auto\n    }\n    then have sub:\"(\\<Inter>b\\<in>A. r `` {b})\\<subseteq>X\" by auto\n    {\n      fix x assume x:\"x\\<in>(\\<Inter>b\\<in>A. r `` {b})\"\n      with r1 have \"\\<exists>z\\<in>\\<Inter>b\\<in>A. r `` {b}. \\<langle>x,z\\<rangle>\\<notin>r\" by auto\n      then obtain z where z:\"z\\<in>(\\<Inter>b\\<in>A. r `` {b})\"\"\\<langle>x,z\\<rangle>\\<notin>r\" by auto\n      from x z(1) sub have \"x\\<in>X\"\"z\\<in>X\" by auto\n      with z(2) have \"\\<langle>z,x\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def IsTotal_def by auto\n      then have xx:\"x\\<in>RightRayX(X,r,z)\" unfolding RightRayX_def using \\<open>x\\<in>X\\<close>\\<open>\\<langle>x,z\\<rangle>\\<notin>r\\<close>\n        assms(1) unfolding IsLinOrder_def using total_is_refl unfolding refl_def by auto\n      {\n        fix m assume \"m\\<in>RightRayX(X,r,z)\"\n        then have m:\"m\\<in>X-{z}\"\"\\<langle>z,m\\<rangle>\\<in>r\" unfolding RightRayX_def by auto\n        {\n          fix c assume \"c\\<in>A\"\n          with z(1) have \"\\<langle>c,z\\<rangle>\\<in>r\" using image_iff by auto\n          with m(2) have \"\\<langle>c,m\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def trans_def by fast\n          then have \"m\\<in>r``{c}\" using image_iff by auto\n        }\n        with A(1) have \"m\\<in>(\\<Inter>b\\<in>A. r `` {b})\" by auto\n      }\n      then have sub1:\"RightRayX(X,r,z)\\<subseteq>(\\<Inter>b\\<in>A. r `` {b})\" by auto\n      have \"RightRayX(X,r,z)\\<in>(OrdTopology X r)\" using \n        base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] \\<open>z\\<in>X\\<close> by auto\n      with sub1 xx have \"\\<exists>U\\<in>(OrdTopology X r). x\\<in>U \\<and> U\\<subseteq>(\\<Inter>b\\<in>A. r `` {b})\" by auto\n    }\n    then have \"(\\<Inter>b\\<in>A. r `` {b})\\<in>(OrdTopology X r)\" using topology0.open_neigh_open[OF topology0_ordtopology[OF assms(1)]]\n      by auto moreover\n    {\n      fix x assume \"x\\<in>X-(\\<Inter>b\\<in>A. r `` {b})\"\n      then have \"x\\<in>X\"\"x\\<notin>(\\<Inter>b\\<in>A. r `` {b})\" by auto\n      with A(1) obtain b where \"x\\<notin>r``{b}\"\"b\\<in>A\" by auto\n      then have \"\\<langle>b,x\\<rangle>\\<notin>r\" using image_iff by auto\n      with \\<open>A\\<subseteq>X\\<close> \\<open>b\\<in>A\\<close>\\<open>x\\<in>X\\<close> have \"\\<langle>x,b\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def\n        IsTotal_def by auto\n      then have xx:\"x\\<in>LeftRayX(X,r,b)\" unfolding LeftRayX_def using \\<open>x\\<in>X\\<close> \\<open>\\<langle>b,x\\<rangle>\\<notin>r\\<close>\n        assms(1) unfolding IsLinOrder_def using total_is_refl unfolding refl_def by auto\n      {\n        fix y assume \"y\\<in>LeftRayX(X,r,b)\\<inter>(\\<Inter>b\\<in>A. r `` {b})\"\n        then have \"y\\<in>X-{b}\"\"\\<langle>y,b\\<rangle>\\<in>r\"\"\\<forall>c\\<in>A. y\\<in>r``{c}\" unfolding LeftRayX_def by auto\n        then have \"y\\<in>X\"\"\\<langle>y,b\\<rangle>\\<in>r\"\"\\<forall>c\\<in>A. \\<langle>c,y\\<rangle>\\<in>r\" using image_iff by auto\n        with \\<open>b\\<in>A\\<close> have \"y=b\" using assms(1) unfolding IsLinOrder_def antisym_def by auto\n        then have \"False\" using \\<open>y\\<in>X-{b}\\<close> by auto\n      }\n      then have sub1:\"LeftRayX(X,r,b)\\<subseteq>X-(\\<Inter>b\\<in>A. r `` {b})\" unfolding LeftRayX_def by auto\n      have \"LeftRayX(X,r,b)\\<in>(OrdTopology X r)\" using \n        base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] \\<open>b\\<in>A\\<close>\\<open>A\\<subseteq>X\\<close> by blast\n      with sub1 xx have \"\\<exists>U\\<in>(OrdTopology X r). x\\<in>U\\<and>U\\<subseteq>X-(\\<Inter>b\\<in>A. r `` {b})\" by auto\n    }\n    then have \"X - (\\<Inter>b\\<in>A. r `` {b})\\<in>(OrdTopology X r)\" using topology0.open_neigh_open[OF topology0_ordtopology[OF assms(1)]]\n      by auto\n    then have \"\\<Union>(OrdTopology X r)-(\\<Inter>b\\<in>A. r `` {b})\\<in>(OrdTopology X r)\" using union_ordtopology[OF assms(1,2)] by auto\n    then have \"(\\<Inter>b\\<in>A. r `` {b}){is closed in}(OrdTopology X r)\" unfolding IsClosed_def using union_ordtopology[OF assms(1,2)]\n      sub by auto\n    moreover note assms(4) ultimately\n    have \"(\\<Inter>b\\<in>A. r `` {b})=0\\<or>(\\<Inter>b\\<in>A. r `` {b})=X\" using union_ordtopology[OF assms(1,2)] unfolding IsConnected_def\n      by auto\n    then have e1:\"(\\<Inter>b\\<in>A. r `` {b})=X\" using noE by auto\n    then have \"\\<forall>x\\<in>X. \\<forall>b\\<in>A. x\\<in>r``{b}\" by auto\n    then have r4:\"\\<forall>x\\<in>X. \\<forall>b\\<in>A. \\<langle>b,x\\<rangle>\\<in>r\" using image_iff by auto\n    {\n      fix a1 a2 assume aA:\"a1\\<in>A\"\"a2\\<in>A\"\"a1\\<noteq>a2\"\n      with \\<open>A\\<subseteq>X\\<close> have aX:\"a1\\<in>X\"\"a2\\<in>X\" by auto\n      with r4 aA(1,2) have \"\\<langle>a1,a2\\<rangle>\\<in>r\"\"\\<langle>a2,a1\\<rangle>\\<in>r\" by auto\n      then have \"a1=a2\" using assms(1) unfolding IsLinOrder_def antisym_def by auto\n      with aA(3) have \"False\" by auto\n    }\n    moreover\n    from A(1) obtain t where \"t\\<in>A\" by auto\n    ultimately have \"A={t}\" by auto\n    with r4 have \"\\<forall>x\\<in>X. \\<langle>t,x\\<rangle>\\<in>r\"\"t\\<in>X\" using \\<open>A\\<subseteq>X\\<close> by auto\n    then have \"HasAminimum(r,X)\" unfolding HasAminimum_def by auto\n    with e1 have \"HasAminimum(r,\\<Inter>b\\<in>A. r `` {b})\" by auto\n    with A(3) have \"False\" by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2077
    },
    "1871": {
        "type": "theorem",
        "text": "text\\<open>If an order topology is connected, then the order is dense.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n     \"(OrdTopology X r){is connected}\"\n  ",
        "using": [
            "base_sets_open[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "assms(1)]]",
            "assms(1)",
            "\\<open>x\\<in>X\\<close>",
            "\\<open>x2\\<in>X\\<close>",
            "IsLinOrder_def",
            "IsTotal_def",
            "total_is_refl",
            "refl_def",
            "trans_def",
            "antisym_def",
            "P(2)",
            "union_ordtopology[",
            "OF",
            "assms(1,2)]",
            "IsClosed_def",
            "LeftRayX_def",
            "assms(3)",
            "IsConnected_def",
            "x(2)"
        ],
        "statement": "theorem conn_imp_dense:\n  assumes \"IsLinOrder(X,r)\" \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n     \"(OrdTopology X r){is connected}\"\n  shows \"X {is dense with respect to}r\"\n",
        "proof": "proof-\n  {\n    assume \"\\<not>(X {is dense with respect to}r)\"\n    then have \"\\<exists>x1\\<in>X. \\<exists>x2\\<in>X. \\<langle>x1,x2\\<rangle>\\<in>r\\<and>x1\\<noteq>x2\\<and>(\\<forall>z\\<in>X-{x1,x2}. \\<langle>x1,z\\<rangle>\\<notin>r\\<or>\\<langle>z,x2\\<rangle>\\<notin>r)\"\n      unfolding IsDense_def by auto\n    then obtain x1 x2 where x:\"x1\\<in>X\"\"x2\\<in>X\"\"\\<langle>x1,x2\\<rangle>\\<in>r\"\"x1\\<noteq>x2\"\"(\\<forall>z\\<in>X-{x1,x2}. \\<langle>x1,z\\<rangle>\\<notin>r\\<or>\\<langle>z,x2\\<rangle>\\<notin>r)\" by auto\n    from x(1,2) have P:\"LeftRayX(X,r,x2)\\<in>(OrdTopology X r)\"\"RightRayX(X,r,x1)\\<in>(OrdTopology X r)\"\n      using  base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n    {\n      fix x assume \"x\\<in>X-LeftRayX(X,r,x2)\"\n      then have \"x\\<in>X\" \"x\\<notin>LeftRayX(X,r,x2)\" by auto\n      then have \"\\<langle>x,x2\\<rangle>\\<notin>r\\<or>x=x2\" unfolding LeftRayX_def by auto\n      then have \"\\<langle>x2,x\\<rangle>\\<in>r\\<or>x=x2\" using assms(1) \\<open>x\\<in>X\\<close> \\<open>x2\\<in>X\\<close> unfolding IsLinOrder_def\n        IsTotal_def by auto\n      then have s:\"\\<langle>x2,x\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def using total_is_refl \\<open>x2\\<in>X\\<close>\n        unfolding refl_def by auto\n      with x(3) have \"\\<langle>x1,x\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def trans_def by fast\n      then have \"x=x1\\<or>x\\<in>RightRayX(X,r,x1)\" unfolding RightRayX_def using \\<open>x\\<in>X\\<close> by auto\n      with s have \"\\<langle>x2,x1\\<rangle>\\<in>r\\<or>x\\<in>RightRayX(X,r,x1)\" by auto\n      with x(3) have \"x1=x2 \\<or> x\\<in>RightRayX(X,r,x1)\" using assms(1) unfolding IsLinOrder_def\n        antisym_def by auto\n      with x(4) have \"x\\<in>RightRayX(X,r,x1)\" by auto\n    }\n    then have \"X-LeftRayX(X,r,x2)\\<subseteq>RightRayX(X,r,x1)\" by auto moreover\n    {\n      fix x assume \"x\\<in>RightRayX(X,r,x1)\"\n      then have xr:\"x\\<in>X-{x1}\"\"\\<langle>x1,x\\<rangle>\\<in>r\" unfolding RightRayX_def by auto\n      {\n        assume \"x\\<in>LeftRayX(X,r,x2)\"\n        then have xl:\"x\\<in>X-{x2}\"\"\\<langle>x,x2\\<rangle>\\<in>r\" unfolding LeftRayX_def by auto\n        from xl xr x(5) have \"False\" by auto\n      }\n      with xr(1) have \"x\\<in>X-LeftRayX(X,r,x2)\" by auto\n    }\n    ultimately have \"RightRayX(X,r,x1)=X-LeftRayX(X,r,x2)\" by auto\n    then have \"LeftRayX(X,r,x2){is closed in}(OrdTopology X r)\" using P(2) union_ordtopology[\n      OF assms(1,2)] unfolding IsClosed_def LeftRayX_def by auto\n    with P(1) have \"LeftRayX(X,r,x2)=0\\<or>LeftRayX(X,r,x2)=X\" using union_ordtopology[\n      OF assms(1,2)] assms(3) unfolding IsConnected_def by auto\n    with x(1,3,4) have \"LeftRayX(X,r,x2)=X\" unfolding LeftRayX_def by auto\n    then have \"x2\\<in>LeftRayX(X,r,x2)\" using x(2) by auto\n    then have \"False\" unfolding LeftRayX_def by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2078
    },
    "1872": {
        "type": "lemma",
        "text": "text\\<open>First a lemma. In a complete ordered set, every non-empty set bounded from below has\na maximum lower bound.\\<close>\n",
        "assumes": "assumes \"r{is complete}\" \"IsBoundedBelow(A,r)\" \"A\\<noteq>0\" \"r\\<subseteq>X\\<times>X\"\n  ",
        "using": [
            "vimage_iff",
            "rr(1)",
            "assms(3)"
        ],
        "statement": "lemma complete_order_bounded_below:\n  assumes \"r{is complete}\" \"IsBoundedBelow(A,r)\" \"A\\<noteq>0\" \"r\\<subseteq>X\\<times>X\"\n  shows \"HasAmaximum(r,\\<Inter>c\\<in>A. r-``{c})\"\n",
        "proof": "proof-\n  let ?M=\"\\<Inter>c\\<in>A. r-``{c}\"\n  from assms(3) obtain t where A:\"t\\<in>A\" by auto\n  {\n    fix m assume \"m\\<in>?M\"\n    with A have \"m\\<in>r-``{t}\" by auto\n    then have \"\\<langle>m,t\\<rangle>\\<in>r\" by auto\n  }\n  then have \"(\\<forall>x\\<in>\\<Inter>c\\<in>A. r -`` {c}. \\<langle>x, t\\<rangle> \\<in> r)\" by auto\n  then have \"IsBoundedAbove(?M,r)\" unfolding IsBoundedAbove_def by auto\n  moreover\n  from assms(2,3) obtain l where \" \\<forall>x\\<in>A. \\<langle>l, x\\<rangle> \\<in> r\" unfolding IsBoundedBelow_def by auto\n  then have \"\\<forall>x\\<in>A. l \\<in> r-``{x}\" using vimage_iff by auto\n  with assms(3) have \"l\\<in>?M\" by auto\n  then have \"?M\\<noteq>0\" by auto moreover note assms(1)\n  ultimately have \"HasAminimum(r,\\<Inter>c\\<in>?M. r `` {c})\" unfolding IsComplete_def by auto\n  then obtain rr where rr:\"rr\\<in>(\\<Inter>c\\<in>?M. r `` {c})\" \"\\<forall>s\\<in>(\\<Inter>c\\<in>?M. r `` {c}). \\<langle>rr,s\\<rangle>\\<in>r\" unfolding HasAminimum_def\n    by auto\n  {\n    fix aa assume A:\"aa\\<in>A\"\n    {\n      fix c assume M:\"c\\<in>?M\"\n      with A have \"\\<langle>c,aa\\<rangle>\\<in>r\" by auto\n      then have \"aa\\<in>r``{c}\" by auto\n    }\n    then have \"aa\\<in>(\\<Inter>c\\<in>?M. r `` {c})\" using rr(1) by auto\n  }\n  then have \"A\\<subseteq>(\\<Inter>c\\<in>?M. r `` {c})\" by auto\n  with rr(2) have \"\\<forall>s\\<in>A. \\<langle>rr,s\\<rangle>\\<in>r\" by auto\n  then have \"rr\\<in>?M\" using assms(3) by auto\n  moreover\n  {\n    fix m assume \"m\\<in>?M\"\n    then have \"rr\\<in>r``{m}\" using rr(1) by auto\n    then have \"\\<langle>m,rr\\<rangle>\\<in>r\" by auto\n  }\n  then have \"\\<forall>m\\<in>?M. \\<langle>m,rr\\<rangle>\\<in>r\" by auto\n  ultimately show ?thesis unfolding HasAmaximum_def by auto\nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2079
    },
    "1873": {
        "type": "lemma",
        "text": "text\\<open>If an order topology has a subset $A$ which is topologically\ndense, then that subset is weakly order-dense in $X$.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"Closure(A,OrdTopology X r)=X\" \"A\\<subseteq>X\" \"\\<exists>x y. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"\n  ",
        "using": [
            "base_sets_open[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "assms(1)]]",
            "assms(2)",
            "topology0.cl_inter_neigh[OF",
            "topology0_ordtopology[OF",
            "assms(1)]",
            "_",
            "P",
            ",",
            "of",
            "\"A\"]",
            "assms(3)",
            "union_ordtopology[OF",
            "assms(1,4)]",
            "int"
        ],
        "statement": "lemma dense_top_imp_Wdense_ord:\n  assumes \"IsLinOrder(X,r)\" \"Closure(A,OrdTopology X r)=X\" \"A\\<subseteq>X\" \"\\<exists>x y. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"\n  shows \"A{is weakly dense in}X{with respect to}r\"\n",
        "proof": "proof-\n  {\n    fix r1 r2 assume \"r1\\<in>X\"\"r2\\<in>X\"\"r1\\<noteq>r2\" \"\\<langle>r1,r2\\<rangle>\\<in>r\"\n    then have \"IntervalX(X,r,r1,r2)\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union>\n      {RightRayX(X, r, b) . b \\<in> X}\" by auto\n    then have P:\"IntervalX(X,r,r1,r2)\\<in>(OrdTopology X r)\" using base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]]\n      by auto\n    have \"IntervalX(X,r,r1,r2)\\<subseteq>X\" unfolding IntervalX_def by auto\n    then have int:\"Closure(A,OrdTopology X r)\\<inter>IntervalX(X,r,r1,r2)=IntervalX(X,r,r1,r2)\" using assms(2) by auto\n    {\n      assume \"IntervalX(X,r,r1,r2)\\<noteq>0\"\n      then have \"A\\<inter>(IntervalX(X,r,r1,r2))\\<noteq>0\" using topology0.cl_inter_neigh[OF topology0_ordtopology[OF assms(1)] _ P , of \"A\"]\n        using assms(3) union_ordtopology[OF assms(1,4)] int by auto\n    }\n    then have \"(\\<exists>z\\<in>A-{r1,r2}. \\<langle>r1,z\\<rangle>\\<in>r\\<and>\\<langle>z,r2\\<rangle>\\<in>r)\\<or>IntervalX(X,r,r1,r2)=0\" unfolding IntervalX_def\n      Interval_def by auto\n  }\n  then show ?thesis unfolding IsWeaklyDenseSub_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2080
    },
    "1874": {
        "type": "lemma",
        "text": "text\\<open>Another way to see this: Consider a weakly order-dense set $A$:\n\\begin{itemize}\n\\item If $X$ has a maximum and a minimum and $\\{min,max\\}$ is open: $A$ is topologically dense in $X\\setminus\\{min,max\\}$, where $min$ is the minimum in $X$ and $max$ is the maximum in $X$.\n\\item If $X$ has a maximum, $\\{max\\}$ is open and $X$ has no minimum\n  or $\\{min\\}$ isn't open: $A$ is topologically dense in $X\\setminus\\{max\\}$, where $max$ is the maximum in $X$.\n\\item If $X$ has a minimum, $\\{min\\}$ is open and $X$ has no maximum\n  or $\\{max\\}$ isn't open $A$ is topologically dense in $X\\setminus\\{min\\}$, where $min$ is the minimum in $X$.\n\\item If $X$ has no minimum or maximum, or $\\{min,max\\}$ has no proper open sets: $A$ is topologically dense in $X$.\n\\end{itemize}\n\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"A{is weakly dense in}X{with respect to}r\" \"A\\<subseteq>X\" \"\\<exists>x y. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"\n    \"HasAminimum(r,X)\\<longrightarrow>{Minimum(r,X)}\\<in>(OrdTopology X r)\\<longrightarrow>Minimum(r,X)\\<in>A\"\n    \"HasAmaximum(r,X)\\<longrightarrow>{Maximum(r,X)}\\<in>(OrdTopology X r)\\<longrightarrow>Maximum(r,X)\\<in>A\"\n  ",
        "using": [
            "point_open_base_neigh[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "assms(1)]]",
            "assms(1)",
            "IsLinOrder_def",
            "trans_def",
            "antisym_def",
            "V(2)",
            "b(3)",
            "ass(2)",
            "union_ordtopology[OF",
            "assms(1,4)]",
            "ass(1)",
            "\\<open>x\\<in>X\\<close>",
            "y(2)",
            "x(1)",
            "y(2,3)",
            "assms(2)",
            "IsWeaklyDenseSub_def",
            "y(1)",
            "b(1)",
            "b(2)",
            "RightRayX_def",
            "assms(3)",
            "R",
            "IsTotal_def",
            "B",
            "V(3)",
            "Order_ZF_1_L1",
            "T",
            "Order_ZF_4_L3",
            "base_sets_open[OF",
            "V(1)",
            "assms(6)",
            "LeftRayX_def",
            "Order_ZF_4_L4",
            "assms(5)"
        ],
        "statement": "lemma Wdense_ord_imp_dense_top:\n  assumes \"IsLinOrder(X,r)\" \"A{is weakly dense in}X{with respect to}r\" \"A\\<subseteq>X\" \"\\<exists>x y. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"\n    \"HasAminimum(r,X)\\<longrightarrow>{Minimum(r,X)}\\<in>(OrdTopology X r)\\<longrightarrow>Minimum(r,X)\\<in>A\"\n    \"HasAmaximum(r,X)\\<longrightarrow>{Maximum(r,X)}\\<in>(OrdTopology X r)\\<longrightarrow>Maximum(r,X)\\<in>A\"\n  shows \"Closure(A,OrdTopology X r)=X\"\n",
        "proof": "proof-\n  {\n    fix x assume \"x\\<in>X\"\n  {\n    fix U assume ass:\"x\\<in>U\"\"U\\<in>(OrdTopology X r)\"\n    then have \"\\<exists>V\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X} . V\\<subseteq>U\\<and>x\\<in>V\"\n      using point_open_base_neigh[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n    then obtain V where V:\"V\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X}\" \"V\\<subseteq>U\" \"x\\<in>V\"\n      by blast\n    note V(1) moreover\n    {\n      assume \"V\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X}\"\n      then obtain b c where b:\"b\\<in>X\"\"c\\<in>X\"\"V=IntervalX(X, r, b, c)\" by auto\n      with V(3) have x:\"\\<langle>b,x\\<rangle>\\<in>r\" \"\\<langle>x,c\\<rangle>\\<in>r\" \"x\\<noteq>b\" \"x\\<noteq>c\" unfolding IntervalX_def Interval_def by auto\n      then have \"\\<langle>b,c\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def trans_def by fast\n      moreover from x(1-3) have \"b\\<noteq>c\" using assms(1) unfolding IsLinOrder_def antisym_def by fast\n      moreover note assms(2) b V(3)\n      ultimately have \"\\<exists>z\\<in>A-{b,c}. \\<langle>b,z\\<rangle>\\<in>r\\<and>\\<langle>z,c\\<rangle>\\<in>r\" unfolding IsWeaklyDenseSub_def by auto\n      then obtain z where \"z\\<in>A\"\"z\\<noteq>b\"\"z\\<noteq>c\"\"\\<langle>b,z\\<rangle>\\<in>r\"\"\\<langle>z,c\\<rangle>\\<in>r\" by auto\n      with assms(3) have \"z\\<in>A\"\"z\\<in>IntervalX(X, r, b, c)\" unfolding IntervalX_def Interval_def by auto\n      then have \"A\\<inter>U\\<noteq>0\" using V(2) b(3) by auto\n    }\n    moreover\n    {\n      assume \"V\\<in>{RightRayX(X, r, b) . b \\<in> X}\"\n      then obtain b where b:\"b\\<in>X\"\"V=RightRayX(X, r, b)\" by auto\n      with V(3) have x:\"\\<langle>b,x\\<rangle>\\<in>r\" \"b\\<noteq>x\" unfolding RightRayX_def by auto moreover\n      note b(1) moreover\n      have \"U\\<subseteq>\\<Union>(OrdTopology X r)\" using ass(2) by auto\n      then have \"U\\<subseteq>X\" using union_ordtopology[OF assms(1,4)] by auto\n      then have \"x\\<in>X\" using ass(1) by auto moreover\n      note assms(2) ultimately\n      have disj:\"(\\<exists>z\\<in>A-{b,x}. \\<langle>b,z\\<rangle>\\<in>r\\<and>\\<langle>z,x\\<rangle>\\<in>r)\\<or> IntervalX(X, r, b, x) = 0\" unfolding IsWeaklyDenseSub_def by auto\n      {\n        assume B:\"IntervalX(X, r, b, x) = 0\"\n        {\n          assume \"\\<exists>y\\<in>X. \\<langle>x,y\\<rangle>\\<in>r \\<and> x\\<noteq>y\"\n          then obtain y where y:\"y\\<in>X\"\"\\<langle>x,y\\<rangle>\\<in>r\" \"x\\<noteq>y\" by auto\n          with x have \"x\\<in>IntervalX(X,r,b,y)\" unfolding IntervalX_def Interval_def\n            using \\<open>x\\<in>X\\<close> by auto moreover\n          have \"\\<langle>b,y\\<rangle>\\<in>r\" using y(2) x(1) assms(1) unfolding IsLinOrder_def trans_def by fast\n          moreover have \"b\\<noteq>y\" using y(2,3) x(1) assms(1) unfolding IsLinOrder_def antisym_def by fast\n          ultimately\n          have \"(\\<exists>z\\<in>A-{b,y}. \\<langle>b,z\\<rangle>\\<in>r\\<and>\\<langle>z,y\\<rangle>\\<in>r)\" using assms(2) unfolding IsWeaklyDenseSub_def\n            using y(1) b(1) by auto\n          then obtain z where \"z\\<in>A\"\"\\<langle>b,z\\<rangle>\\<in>r\"\"b\\<noteq>z\" by auto\n          then have \"z\\<in>A\\<inter>V\" using b(2) unfolding RightRayX_def using assms(3) by auto\n          then have \"z\\<in>A\\<inter>U\" using V(2) by auto\n          then have \"A\\<inter>U\\<noteq>0\" by auto\n        }\n        moreover\n        {\n          assume R:\"\\<forall>y\\<in>X. \\<langle>x,y\\<rangle>\\<in>r\\<longrightarrow>x=y\"\n          {\n            fix y assume \"y\\<in>RightRayX(X,r,b)\"\n            then have y:\"\\<langle>b,y\\<rangle>\\<in>r\" \"y\\<in>X-{b}\" unfolding RightRayX_def by auto\n            {\n              assume A:\"y\\<noteq>x\"\n              then have \"\\<langle>x,y\\<rangle>\\<notin>r\" using R y(2) by auto\n              then have \"\\<langle>y,x\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def IsTotal_def\n                using \\<open>x\\<in>X\\<close> y(2) by auto\n              with A y have \"y\\<in>IntervalX(X,r,b,x)\" unfolding IntervalX_def Interval_def\n                by auto\n              then have \"False\" using B by auto\n            }\n            then have \"y=x\" by auto\n          }\n          then have \"RightRayX(X,r,b)={x}\" using V(3) b(2) by blast\n          moreover\n          {\n            fix t assume T:\"t\\<in>X\"\n            {\n              assume \"t=x\"\n              then have \"\\<langle>t,x\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def\n                using Order_ZF_1_L1 T by auto\n            }\n            moreover\n            {\n              assume \"t\\<noteq>x\"\n              then have \"\\<langle>x,t\\<rangle>\\<notin>r\" using R T by auto\n              then have \"\\<langle>t,x\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def IsTotal_def\n                using T \\<open>x\\<in>X\\<close> by auto\n            }\n            ultimately have \"\\<langle>t,x\\<rangle>\\<in>r\" by auto\n          }\n          with \\<open>x\\<in>X\\<close> have HM:\"HasAmaximum(r,X)\" unfolding HasAmaximum_def by auto\n          then have \"Maximum(r,X)\\<in>X\"\"\\<forall>t\\<in>X. \\<langle>t,Maximum(r,X)\\<rangle>\\<in>r\" using Order_ZF_4_L3 assms(1) unfolding IsLinOrder_def\n            by auto\n          with R \\<open>x\\<in>X\\<close> have xm:\"x=Maximum(r,X)\" by auto\n          moreover note b(2)\n          ultimately have \"V={Maximum(r,X)}\" by auto\n          then have \"{Maximum(r,X)}\\<in>(OrdTopology X r)\" using base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]]\n            V(1) by auto\n          with HM have \"Maximum(r,X)\\<in>A\" using assms(6) by auto\n          with xm have \"x\\<in>A\" by auto\n          with V(2,3) have \"A\\<inter>U\\<noteq>0\" by auto\n        }\n        ultimately have \"A\\<inter>U\\<noteq>0\" by auto\n      }\n      moreover\n      {\n        assume \"IntervalX(X, r, b, x) \\<noteq> 0\"\n        with disj have \"\\<exists>z\\<in>A-{b,x}. \\<langle>b,z\\<rangle>\\<in>r\\<and>\\<langle>z,x\\<rangle>\\<in>r\" by auto\n        then obtain z where \"z\\<in>A\"\"z\\<noteq>b\"\"\\<langle>b,z\\<rangle>\\<in>r\" by auto\n        then have \"z\\<in>A\"\"z\\<in>RightRayX(X,r,b)\" unfolding RightRayX_def using assms(3) by auto\n        then have \"z\\<in>A\\<inter>U\" using V(2) b(2) by auto\n        then have \"A\\<inter>U\\<noteq>0\" by auto\n      }\n      ultimately have \"A\\<inter>U\\<noteq>0\" by auto\n    }\n    moreover\n    {\n      assume \"V\\<in>{LeftRayX(X, r, b) . b \\<in> X}\"\n      then obtain b where b:\"b\\<in>X\"\"V=LeftRayX(X, r, b)\" by auto\n      with V(3) have x:\"\\<langle>x,b\\<rangle>\\<in>r\" \"b\\<noteq>x\" unfolding LeftRayX_def by auto moreover\n      note b(1) moreover\n      have \"U\\<subseteq>\\<Union>(OrdTopology X r)\" using ass(2) by auto\n      then have \"U\\<subseteq>X\" using union_ordtopology[OF assms(1,4)] by auto\n      then have \"x\\<in>X\" using ass(1) by auto moreover\n      note assms(2) ultimately\n      have disj:\"(\\<exists>z\\<in>A-{b,x}. \\<langle>x,z\\<rangle>\\<in>r\\<and>\\<langle>z,b\\<rangle>\\<in>r)\\<or> IntervalX(X, r, x, b) = 0\" unfolding IsWeaklyDenseSub_def by auto\n      {\n        assume B:\"IntervalX(X, r, x, b) = 0\"\n        {\n          assume \"\\<exists>y\\<in>X. \\<langle>y,x\\<rangle>\\<in>r \\<and> x\\<noteq>y\"\n          then obtain y where y:\"y\\<in>X\"\"\\<langle>y,x\\<rangle>\\<in>r\" \"x\\<noteq>y\" by auto\n          with x have \"x\\<in>IntervalX(X,r,y,b)\" unfolding IntervalX_def Interval_def\n            using \\<open>x\\<in>X\\<close> by auto moreover\n          have \"\\<langle>y,b\\<rangle>\\<in>r\" using y(2) x(1) assms(1) unfolding IsLinOrder_def trans_def by fast\n          moreover have \"b\\<noteq>y\" using y(2,3) x(1) assms(1) unfolding IsLinOrder_def antisym_def by fast\n          ultimately\n          have \"(\\<exists>z\\<in>A-{b,y}. \\<langle>y,z\\<rangle>\\<in>r\\<and>\\<langle>z,b\\<rangle>\\<in>r)\" using assms(2) unfolding IsWeaklyDenseSub_def\n            using y(1) b(1) by auto\n          then obtain z where \"z\\<in>A\"\"\\<langle>z,b\\<rangle>\\<in>r\"\"b\\<noteq>z\" by auto\n          then have \"z\\<in>A\\<inter>V\" using b(2) unfolding LeftRayX_def using assms(3) by auto\n          then have \"z\\<in>A\\<inter>U\" using V(2) by auto\n          then have \"A\\<inter>U\\<noteq>0\" by auto\n        }\n        moreover\n        {\n          assume R:\"\\<forall>y\\<in>X. \\<langle>y,x\\<rangle>\\<in>r\\<longrightarrow>x=y\"\n          {\n            fix y assume \"y\\<in>LeftRayX(X,r,b)\"\n            then have y:\"\\<langle>y,b\\<rangle>\\<in>r\" \"y\\<in>X-{b}\" unfolding LeftRayX_def by auto\n            {\n              assume A:\"y\\<noteq>x\"\n              then have \"\\<langle>y,x\\<rangle>\\<notin>r\" using R y(2) by auto\n              then have \"\\<langle>x,y\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def IsTotal_def\n                using \\<open>x\\<in>X\\<close> y(2) by auto\n              with A y have \"y\\<in>IntervalX(X,r,x,b)\" unfolding IntervalX_def Interval_def\n                by auto\n              then have \"False\" using B by auto\n            }\n            then have \"y=x\" by auto\n          }\n          then have \"LeftRayX(X,r,b)={x}\" using V(3) b(2) by blast\n          moreover\n          {\n            fix t assume T:\"t\\<in>X\"\n            {\n              assume \"t=x\"\n              then have \"\\<langle>x,t\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def\n                using Order_ZF_1_L1 T by auto\n            }\n            moreover\n            {\n              assume \"t\\<noteq>x\"\n              then have \"\\<langle>t,x\\<rangle>\\<notin>r\" using R T by auto\n              then have \"\\<langle>x,t\\<rangle>\\<in>r\" using assms(1) unfolding IsLinOrder_def IsTotal_def\n                using T \\<open>x\\<in>X\\<close> by auto\n            }\n            ultimately have \"\\<langle>x,t\\<rangle>\\<in>r\" by auto\n          }\n          with \\<open>x\\<in>X\\<close> have HM:\"HasAminimum(r,X)\" unfolding HasAminimum_def by auto\n          then have \"Minimum(r,X)\\<in>X\"\"\\<forall>t\\<in>X. \\<langle>Minimum(r,X),t\\<rangle>\\<in>r\" using Order_ZF_4_L4 assms(1) unfolding IsLinOrder_def\n            by auto\n          with R \\<open>x\\<in>X\\<close> have xm:\"x=Minimum(r,X)\" by auto\n          moreover note b(2)\n          ultimately have \"V={Minimum(r,X)}\" by auto\n          then have \"{Minimum(r,X)}\\<in>(OrdTopology X r)\" using base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]]\n            V(1) by auto\n          with HM have \"Minimum(r,X)\\<in>A\" using assms(5) by auto\n          with xm have \"x\\<in>A\" by auto\n          with V(2,3) have \"A\\<inter>U\\<noteq>0\" by auto\n        }\n        ultimately have \"A\\<inter>U\\<noteq>0\" by auto\n      }\n      moreover\n      {\n        assume \"IntervalX(X, r, x, b) \\<noteq> 0\"\n        with disj have \"\\<exists>z\\<in>A-{b,x}. \\<langle>x,z\\<rangle>\\<in>r\\<and>\\<langle>z,b\\<rangle>\\<in>r\" by auto\n        then obtain z where \"z\\<in>A\"\"z\\<noteq>b\"\"\\<langle>z,b\\<rangle>\\<in>r\" by auto\n        then have \"z\\<in>A\"\"z\\<in>LeftRayX(X,r,b)\" unfolding LeftRayX_def using assms(3) by auto\n        then have \"z\\<in>A\\<inter>U\" using V(2) b(2) by auto\n        then have \"A\\<inter>U\\<noteq>0\" by auto\n      }\n      ultimately have \"A\\<inter>U\\<noteq>0\" by auto\n    }\n    ultimately have \"A\\<inter>U\\<noteq>0\" by auto\n  }\n  then have \"\\<forall>U\\<in>(OrdTopology X r). x\\<in>U \\<longrightarrow> U\\<inter>A\\<noteq>0\" by auto\n  moreover note \\<open>x\\<in>X\\<close> moreover\n  note assms(3) topology0.inter_neigh_cl[OF topology0_ordtopology[OF assms(1)]]\n  union_ordtopology[OF assms(1,4)] ultimately have \"x\\<in>Closure(A,OrdTopology X r)\"\n    by auto\n  }\n  then have \"X\\<subseteq>Closure(A,OrdTopology X r)\" by auto\n  with topology0.Top_3_L11(1)[OF topology0_ordtopology[OF assms(1)]]\n    assms(3) union_ordtopology[OF assms(1,4)] show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2081
    },
    "1875": {
        "type": "theorem",
        "text": "text\\<open>The conclusion is that an order topology is $\\kappa$-separable\niff there is a set $A$ with cardinality strictly less than $\\kappa$\nwhich is weakly-dense in $X$.\\<close>\n",
        "assumes": "assumes \"(OrdTopology X r){is separable of cardinal}Q\" \"\\<exists>x y. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"\n    \"IsLinOrder(X,r)\"\n  ",
        "using": [
            "union_ordtopology[OF",
            "assms(3,2)]"
        ],
        "statement": "theorem separable_imp_wdense:\n  assumes \"(OrdTopology X r){is separable of cardinal}Q\" \"\\<exists>x y. x \\<noteq> y \\<and> x \\<in> X \\<and> y \\<in> X\"\n    \"IsLinOrder(X,r)\"\n  shows \"\\<exists>A\\<in>Pow(X). A\\<prec>Q \\<and> (A{is weakly dense in}X{with respect to}r)\"\n",
        "proof": "proof-\n  from assms obtain U where \"U\\<in>Pow(\\<Union>(OrdTopology X r))\" \"Closure(U,OrdTopology X r)=\\<Union>(OrdTopology X r)\" \"U\\<prec>Q\"\n    unfolding IsSeparableOfCard_def by auto\n  then have \"U\\<in>Pow(X)\" \"Closure(U,OrdTopology X r)=X\" \"U\\<prec>Q\" using union_ordtopology[OF assms(3,2)]\n    by auto\n  with dense_top_imp_Wdense_ord[OF assms(3) _ _ assms(2)] show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2082
    },
    "1876": {
        "type": "lemma",
        "text": "text\\<open>First we prove a lemma that in a $T_2$ space two points \n  can be separated by the closure of an open set.\\<close>\n",
        "assumes": "assumes \"T {is T\\<^sub>2}\"  and \"x \\<in> \\<Union>T\"  \"y \\<in> \\<Union>T\"   \"x\\<noteq>y\"\n  ",
        "using": [
            "isT2_def",
            "disj_open_cl_disj"
        ],
        "statement": "lemma (in topology0) T2_cl_open_sep:\n  assumes \"T {is T\\<^sub>2}\"  and \"x \\<in> \\<Union>T\"  \"y \\<in> \\<Union>T\"   \"x\\<noteq>y\"\n  shows \"\\<exists>U\\<in>T. (x\\<in>U \\<and> y \\<notin> cl(U))\"\n",
        "proof": "proof -\n  from assms have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\"\n    using isT2_def by simp\n  then obtain U V where \"U\\<in>T\"  \"V\\<in>T\"  \"x\\<in>U\"  \"y\\<in>V\"  \"U\\<inter>V=0\"\n    by auto\n  then have \"U\\<in>T \\<and> x\\<in>U \\<and> y\\<in> V \\<and> cl(U) \\<inter> V = 0\"\n    using  disj_open_cl_disj by auto\n  thus \"\\<exists>U\\<in>T. (x\\<in>U \\<and> y \\<notin> cl(U))\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_1b.thy",
        "id": 2083
    },
    "1877": {
        "type": "theorem",
        "text": "text\\<open>AC-free proof that in a Hausdorff space compact sets \n  are closed. To understand the notation recall that in Isabelle/ZF\n  \\<open>Pow(A)\\<close> is the powerset (the set of subsets) of $A$ \n  and \\<open>FinPow(A)\\<close> denotes the set of finite subsets of $A$ \n  in IsarMathLib.\\<close>\n",
        "assumes": "assumes A1: \"T {is T\\<^sub>2}\" and A2: \"K {is compact in} T\"\n  ",
        "using": [
            "FinPow_def",
            "IsCompact_def",
            "T2_cl_open_sep",
            "cl_is_closed",
            "IsClosed_def",
            "fin_union_cl_is_cl",
            "cl_contains_set",
            "open_neigh_open"
        ],
        "statement": "theorem (in topology0) in_t2_compact_is_cl:\n  assumes A1: \"T {is T\\<^sub>2}\" and A2: \"K {is compact in} T\"\n  shows \"K {is closed in} T\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  have \"\\<forall>y \\<in> ?X - K. \\<exists>U\\<in>T. y\\<in>U \\<and> U \\<subseteq> ?X - K\"\n  proof -\n    { fix y assume \"y \\<in> ?X\"  \"y\\<notin>K\"\n      have \"\\<exists>U\\<in>T. y\\<in>U \\<and> U \\<subseteq> ?X - K\"\n      proof -\n\tlet ?B = \"\\<Union>x\\<in>K. {V\\<in>T. x\\<in>V \\<and> y \\<notin> cl(V)}\"\n\thave I: \"?B \\<in> Pow(T)\"  \"FinPow(?B) \\<subseteq> Pow(?B)\" \n\t  using FinPow_def by auto\n\tfrom \\<open>K {is compact in} T\\<close> \\<open>y \\<in> ?X\\<close>  \\<open>y\\<notin>K\\<close> have \n\t  \"\\<forall>x\\<in>K. x \\<in> ?X \\<and> y \\<in> ?X \\<and> x\\<noteq>y\"\n\t  using IsCompact_def by auto\n\twith \\<open>T {is T\\<^sub>2}\\<close> have \"\\<forall>x\\<in>K. {V\\<in>T. x\\<in>V \\<and> y \\<notin> cl(V)} \\<noteq> 0\"\n\t  using T2_cl_open_sep by auto\n\thence \"K \\<subseteq> \\<Union>?B\" by blast\n\twith \\<open>K {is compact in} T\\<close> I have \n\t  \"\\<exists>N \\<in> FinPow(?B). K \\<subseteq> \\<Union>N\" \n\t  using IsCompact_def by auto\n\tthen obtain N where \"N \\<in> FinPow(?B)\"  \"K \\<subseteq> \\<Union>N\" \n\t  by auto\n\twith I have \"N \\<subseteq> ?B\" by auto\n\thence \"\\<forall>V\\<in>N. V\\<in>?B\" by auto\n\tlet ?M = \"{cl(V). V\\<in>N}\"\n\tlet ?C = \"{D \\<in> Pow(?X). D {is closed in} T}\"\n\tfrom \\<open>N \\<in> FinPow(?B)\\<close> have \"\\<forall>V\\<in>?B. cl(V) \\<in> ?C\"  \"N \\<in> FinPow(?B)\"\n\t  using cl_is_closed IsClosed_def by auto\n\tthen have \"?M \\<in> FinPow(?C)\" by (rule fin_image_fin)\n\tthen have \"?X - \\<Union>?M \\<in> T\" using fin_union_cl_is_cl IsClosed_def \n\t  by simp\n\tmoreover from \\<open>y \\<in> ?X\\<close>  \\<open>y\\<notin>K\\<close>  \\<open>\\<forall>V\\<in>N. V\\<in>?B\\<close> have \n\t  \"y \\<in> ?X - \\<Union>?M\" by simp\n\tmoreover have \"?X - \\<Union>?M \\<subseteq> ?X - K\"\n\tproof -\n\t  from \\<open>\\<forall>V\\<in>N. V\\<in>?B\\<close> have \"\\<Union>N \\<subseteq> \\<Union>?M\" using cl_contains_set by auto\n\t  with \\<open>K \\<subseteq> \\<Union>N\\<close> show \"?X - \\<Union>?M \\<subseteq> ?X - K\" by auto\n\tqed\n\tultimately have \"\\<exists>U. U\\<in>T \\<and> y \\<in> U \\<and> U \\<subseteq> ?X - K\"\n\t  by auto\n\tthus \"\\<exists>U\\<in>T. y\\<in>U \\<and> U \\<subseteq> ?X - K\" by auto\n      qed\n    } thus \"\\<forall>y \\<in> ?X - K. \\<exists>U\\<in>T. y\\<in>U \\<and> U \\<subseteq> ?X - K\"\n      by auto\n  qed\n  with A2 show \"K {is closed in} T\" \n    using open_neigh_open IsCompact_def IsClosed_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_1b.thy",
        "id": 2084
    },
    "1878": {
        "type": "definition",
        "text": "text\\<open>The space of continuous functions mapping $X=\\bigcup \\tau_1$ to $Y=\\bigcup \\tau_2$ \n  will be denoted \\<open>Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\\<close>. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2) \\<equiv> {f\\<in>(\\<Union>\\<tau>\\<^sub>1)\\<rightarrow>(\\<Union>\\<tau>\\<^sub>2). IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2085
    },
    "1879": {
        "type": "lemma",
        "text": "text\\<open>A trivial example of a continuous function - identity is continuous.\\<close>\n",
        "assumes": "",
        "using": [
            "vimage_id_same"
        ],
        "statement": "lemma id_cont: shows \"IsContinuous(\\<tau>,\\<tau>,id(\\<Union>\\<tau>))\"\n",
        "proof": "proof -\n  { fix U assume \"U\\<in>\\<tau>\"\n    then have \"id(\\<Union>\\<tau>)-``(U) = U\" using vimage_id_same by auto\n    with \\<open>U\\<in>\\<tau>\\<close> have \"id(\\<Union>\\<tau>)-``(U) \\<in> \\<tau>\" by simp\n  } then show \"IsContinuous(\\<tau>,\\<tau>,id(\\<Union>\\<tau>))\" unfolding IsContinuous_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2086
    },
    "1880": {
        "type": "lemma",
        "text": "text\\<open>Identity is in the space of continuous functions from $\\bigcup \\tau$ to itself.\\<close>\n",
        "assumes": "",
        "using": [
            "id_type",
            "id_cont"
        ],
        "statement": "lemma id_cont_sp: shows \"{\\<langle>x,x\\<rangle>. x\\<in>\\<Union>\\<tau>} \\<in> Cont(\\<tau>,\\<tau>)\"\n",
        "proof": "proof -\n  have \"id(\\<Union>\\<tau>) : \\<Union>\\<tau> \\<rightarrow> \\<Union>\\<tau>\" and \"IsContinuous(\\<tau>,\\<tau>,id(\\<Union>\\<tau>))\"\n    using id_type id_cont by auto\n  moreover have \"id(\\<Union>\\<tau>) = {\\<langle>x,x\\<rangle>. x\\<in>\\<Union>\\<tau>}\" by blast\n  ultimately show ?thesis unfolding Cont_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2087
    },
    "1881": {
        "type": "lemma",
        "text": "text\\<open>If $c\\in Y =  \\bigcup S$, then the constant function defined on $X=\\bigcup T $ \n  that is equal to $c$ is in the the space of continuous functions from $X$ to $Y$.  \\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \"c\\<in>\\<Union>S\"\n  ",
        "using": [
            "assms",
            "ZF_fun_from_total",
            "const_fun_def_alt",
            "const_cont",
            "Cont_def"
        ],
        "statement": "lemma const_cont_sp: assumes \"T {is a topology}\" \"c\\<in>\\<Union>S\"\n  shows \"{\\<langle>x,c\\<rangle>. x\\<in>\\<Union>T} \\<in> Cont(T,S)\"\n  ",
        "proof": "using assms ZF_fun_from_total const_fun_def_alt const_cont\n  unfolding Cont_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2089
    },
    "1882": {
        "type": "lemma",
        "text": "text\\<open>First we show that theorems proven in locale \\<open>topology0\\<close> \n  are valid when applied to topologies $\\tau_1$ and $\\tau_2$.\\<close>\n",
        "assumes": "",
        "using": [
            "tau1_is_top",
            "tau2_is_top",
            "topology0_def"
        ],
        "statement": "lemma (in two_top_spaces0) topol_cntxs_valid:\n  shows \"topology0(\\<tau>\\<^sub>1)\" and \"topology0(\\<tau>\\<^sub>2)\"\n  ",
        "proof": "using tau1_is_top tau2_is_top topology0_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2090
    },
    "1883": {
        "type": "lemma",
        "text": "text\\<open>For continuous functions the inverse image of a closed set is closed.\\<close>\n",
        "assumes": "assumes A1: \"f {is continuous}\" and A2: \"D {is closed in} \\<tau>\\<^sub>2\"\n  ",
        "using": [
            "func1_1_L3",
            "Pi_iff",
            "function_vimage_Diff",
            "func1_1_L4",
            "IsClosed_def",
            "IsContinuous_def",
            "topol_cntxs_valid",
            "topology0.Top_3_L9"
        ],
        "statement": "lemma (in two_top_spaces0) TopZF_2_1_L1: \n  assumes A1: \"f {is continuous}\" and A2: \"D {is closed in} \\<tau>\\<^sub>2\"\n  shows \"f-``(D) {is closed in} \\<tau>\\<^sub>1\"\n",
        "proof": "proof -\n  from fmapAssum have  \"f-``(D) \\<subseteq> X\\<^sub>1\" using func1_1_L3 by simp\n  moreover from fmapAssum have \"f-``(X\\<^sub>2 - D) =  X\\<^sub>1 - f-``(D)\" \n    using Pi_iff function_vimage_Diff func1_1_L4 by auto\n  ultimately have \"X\\<^sub>1 - f-``(X\\<^sub>2 - D) = f-``(D)\" by auto\n  moreover from A1 A2 have \"(X\\<^sub>1 - f-``(X\\<^sub>2 - D)) {is closed in} \\<tau>\\<^sub>1\"\n    using IsClosed_def IsContinuous_def topol_cntxs_valid topology0.Top_3_L9\n    by simp\n  ultimately show \"f-``(D) {is closed in} \\<tau>\\<^sub>1\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2091
    },
    "1884": {
        "type": "lemma",
        "text": "text\\<open>If the inverse image of every closed set is closed, then the\n  image of a closure is contained in the closure of the image.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>D. ((D {is closed in} \\<tau>\\<^sub>2) \\<longrightarrow> f-``(D) {is closed in} \\<tau>\\<^sub>1)\"\n  and A2: \"A \\<subseteq> X\\<^sub>1\"\n  ",
        "using": [
            "func1_1_L6",
            "topol_cntxs_valid",
            "topology0.cl_contains_set",
            "func1_1_L9",
            "func1_1_L8",
            "IsClosed_def",
            "topology0.cl_is_closed",
            "topology0.Top_3_L13",
            "fun_is_function",
            "function_image_vimage"
        ],
        "statement": "lemma (in two_top_spaces0) Top_ZF_2_1_L2:\n  assumes A1: \"\\<forall>D. ((D {is closed in} \\<tau>\\<^sub>2) \\<longrightarrow> f-``(D) {is closed in} \\<tau>\\<^sub>1)\"\n  and A2: \"A \\<subseteq> X\\<^sub>1\"\n  shows \"f``(cl\\<^sub>1(A)) \\<subseteq> cl\\<^sub>2(f``(A))\"\n",
        "proof": "proof -\n  from fmapAssum have \"f``(A) \\<subseteq> cl\\<^sub>2(f``(A))\"\n    using func1_1_L6 topol_cntxs_valid topology0.cl_contains_set \n    by simp\n  with fmapAssum have \"f-``(f``(A)) \\<subseteq> f-``(cl\\<^sub>2(f``(A)))\"\n    by auto\n  moreover from fmapAssum A2 have \"A \\<subseteq> f-``(f``(A))\"\n    using func1_1_L9 by simp\n  ultimately have \"A \\<subseteq> f-``(cl\\<^sub>2(f``(A)))\" by auto\n  with fmapAssum A1 have \"f``(cl\\<^sub>1(A)) \\<subseteq> f``(f-``(cl\\<^sub>2(f``(A))))\"\n    using func1_1_L6 func1_1_L8 IsClosed_def \n      topol_cntxs_valid topology0.cl_is_closed topology0.Top_3_L13\n    by simp\n  moreover from fmapAssum have \"f``(f-``(cl\\<^sub>2(f``(A)))) \\<subseteq> cl\\<^sub>2(f``(A))\"\n    using fun_is_function function_image_vimage by simp\n  ultimately show \"f``(cl\\<^sub>1(A)) \\<subseteq> cl\\<^sub>2(f``(A))\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2092
    },
    "1885": {
        "type": "lemma",
        "text": "text\\<open>If $f\\left( \\overline{A}\\right)\\subseteq \\overline{f(A)}$ \n  (the image of the closure is contained in the closure of the image), then\n  $\\overline{f^{-1}(B)}\\subseteq f^{-1}\\left( \\overline{B} \\right)$ \n  (the inverse image of the closure contains the closure of the \n  inverse image).\\<close>\n",
        "assumes": "assumes A1: \"\\<forall> A. ( A \\<subseteq> X\\<^sub>1 \\<longrightarrow> f``(cl\\<^sub>1(A)) \\<subseteq> cl\\<^sub>2(f``(A)))\"\n  ",
        "using": [
            "func1_1_L3",
            "fun_is_function",
            "function_image_vimage",
            "func1_1_L6",
            "topol_cntxs_valid",
            "topology0.top_closure_mono",
            "fmapAssum",
            "func1_1_L9",
            "IsClosed_def",
            "topology0.cl_is_closed"
        ],
        "statement": "lemma (in two_top_spaces0) Top_ZF_2_1_L3:\n  assumes A1: \"\\<forall> A. ( A \\<subseteq> X\\<^sub>1 \\<longrightarrow> f``(cl\\<^sub>1(A)) \\<subseteq> cl\\<^sub>2(f``(A)))\"\n  shows \"\\<forall>B. ( B \\<subseteq> X\\<^sub>2 \\<longrightarrow> cl\\<^sub>1(f-``(B)) \\<subseteq> f-``(cl\\<^sub>2(B)) )\"\n",
        "proof": "proof -\n  { fix B assume \"B \\<subseteq> X\\<^sub>2\"\n    from fmapAssum A1 have \"f``(cl\\<^sub>1(f-``(B))) \\<subseteq> cl\\<^sub>2(f``(f-``(B)))\"\n      using func1_1_L3 by simp\n    moreover from fmapAssum \\<open>B \\<subseteq> X\\<^sub>2\\<close> have \"cl\\<^sub>2(f``(f-``(B))) \\<subseteq> cl\\<^sub>2(B)\"\n      using fun_is_function function_image_vimage func1_1_L6\n\ttopol_cntxs_valid topology0.top_closure_mono\n      by simp\n    ultimately have \"f-``(f``(cl\\<^sub>1(f-``(B)))) \\<subseteq> f-``(cl\\<^sub>2(B))\"\n      using fmapAssum fun_is_function by auto\n    moreover from fmapAssum \\<open>B \\<subseteq> X\\<^sub>2\\<close> have \n      \"cl\\<^sub>1(f-``(B)) \\<subseteq> f-``(f``(cl\\<^sub>1(f-``(B))))\"\n      using func1_1_L3 func1_1_L9 IsClosed_def \n\ttopol_cntxs_valid topology0.cl_is_closed by simp\n    ultimately have \"cl\\<^sub>1(f-``(B)) \\<subseteq> f-``(cl\\<^sub>2(B))\" by auto\n  } then show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2093
    },
    "1886": {
        "type": "lemma",
        "text": "text\\<open>If $\\overline{f^{-1}(B)}\\subseteq f^{-1}\\left( \\overline{B} \\right)$ \n  (the inverse image of a closure contains the closure of the \n  inverse image), then the function is continuous. This lemma closes a series of \n  implications in lemmas  \\<open> Top_ZF_2_1_L1\\<close>, \n  \\<open> Top_ZF_2_1_L2\\<close> and \\<open> Top_ZF_2_1_L3\\<close> showing equivalence \n  of four definitions of continuity.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>B. ( B \\<subseteq> X\\<^sub>2 \\<longrightarrow> cl\\<^sub>1(f-``(B)) \\<subseteq> f-``(cl\\<^sub>2(B)) )\"\n  ",
        "using": [
            "topol_cntxs_valid",
            "topology0.Top_3_L9",
            "topology0.Top_3_L8",
            "func1_1_L3",
            "topology0.cl_contains_set",
            "fmapAssum",
            "fun_is_function",
            "function_vimage_Diff",
            "func1_1_L4",
            "IsClosed_def",
            "double_complement",
            "IsContinuous_def"
        ],
        "statement": "lemma (in two_top_spaces0) Top_ZF_2_1_L4:\n  assumes A1: \"\\<forall>B. ( B \\<subseteq> X\\<^sub>2 \\<longrightarrow> cl\\<^sub>1(f-``(B)) \\<subseteq> f-``(cl\\<^sub>2(B)) )\"\n  shows \"f {is continuous}\"\n",
        "proof": "proof -\n  { fix U assume \"U \\<in> \\<tau>\\<^sub>2\"\n    then have \"(X\\<^sub>2 - U) {is closed in} \\<tau>\\<^sub>2\"\n      using topol_cntxs_valid topology0.Top_3_L9 by simp\n    moreover have \"X\\<^sub>2 - U \\<subseteq> \\<Union>\\<tau>\\<^sub>2\" by auto\n    ultimately have \"cl\\<^sub>2(X\\<^sub>2 - U) = X\\<^sub>2 - U\" \n      using topol_cntxs_valid topology0.Top_3_L8 by simp\n    moreover from A1 have \"cl\\<^sub>1(f-``(X\\<^sub>2 - U)) \\<subseteq> f-``(cl\\<^sub>2(X\\<^sub>2 - U))\" \n      by auto\n    ultimately have \"cl\\<^sub>1(f-``(X\\<^sub>2 - U)) \\<subseteq> f-``(X\\<^sub>2 - U)\" by simp\n    moreover from fmapAssum have \"f-``(X\\<^sub>2 - U) \\<subseteq> cl\\<^sub>1(f-``(X\\<^sub>2 - U))\"\n      using func1_1_L3 topol_cntxs_valid topology0.cl_contains_set\n      by simp\n    ultimately have \"f-``(X\\<^sub>2 - U) {is closed in} \\<tau>\\<^sub>1\"\n      using fmapAssum func1_1_L3 topol_cntxs_valid topology0.Top_3_L8\n      by auto\n    with fmapAssum have \"f-``(U) \\<in> \\<tau>\\<^sub>1\" \n      using fun_is_function function_vimage_Diff func1_1_L4\n\tfunc1_1_L3 IsClosed_def double_complement by simp\n  } then have \"\\<forall>U\\<in>\\<tau>\\<^sub>2. f-``(U) \\<in> \\<tau>\\<^sub>1\" by simp\n  then show ?thesis using IsContinuous_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2094
    },
    "1887": {
        "type": "corollary",
        "text": "text\\<open>For continuous functions the closure of the inverse image is contained in the\n  inverse image of the closure. This is a shortcut through a series of implications\n  provided by \\<open>TopZF_2_1_L1\\<close>, \\<open>Top_ZF_2_1_L2\\<close> and \\<open>Top_ZF_2_1_L3\\<close>. \\<close>\n",
        "assumes": "assumes \"f {is continuous}\" and \"B \\<subseteq> X\\<^sub>2\"\n  ",
        "using": [
            "assms",
            "TopZF_2_1_L1",
            "Top_ZF_2_1_L2",
            "Top_ZF_2_1_L3"
        ],
        "statement": "corollary (in two_top_spaces0) im_cl_in_cl_im: \n  assumes \"f {is continuous}\" and \"B \\<subseteq> X\\<^sub>2\"\n  shows \"cl\\<^sub>1(f-``(B)) \\<subseteq> f-``(cl\\<^sub>2(B))\"\n  ",
        "proof": "using assms TopZF_2_1_L1 Top_ZF_2_1_L2 Top_ZF_2_1_L3 by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2095
    },
    "1888": {
        "type": "lemma",
        "text": "text\\<open>Another condition for continuity: it is sufficient to check if the \n  inverse image of every set in a base is open.\\<close>\n",
        "assumes": "assumes A1: \"B {is a base for} \\<tau>\\<^sub>2\" and A2: \"\\<forall>U\\<in>B. f-``(U) \\<in> \\<tau>\\<^sub>1\" \n  ",
        "using": [
            "IsAbaseFor_def",
            "IsATopology_def",
            "IsContinuous_def"
        ],
        "statement": "lemma (in two_top_spaces0) Top_ZF_2_1_L5:\n  assumes A1: \"B {is a base for} \\<tau>\\<^sub>2\" and A2: \"\\<forall>U\\<in>B. f-``(U) \\<in> \\<tau>\\<^sub>1\" \n  shows \"f {is continuous}\"\n",
        "proof": "proof -\n  { fix V assume A3: \"V \\<in> \\<tau>\\<^sub>2\"\n    with A1 obtain A where \"A \\<subseteq> B\"  \"V = \\<Union>A\"\n      using IsAbaseFor_def by auto\n    with A2 have \"{f-``(U). U\\<in>A} \\<subseteq> \\<tau>\\<^sub>1\" by auto\n    with tau1_is_top have \"\\<Union> {f-``(U). U\\<in>A} \\<in> \\<tau>\\<^sub>1\"\n      using IsATopology_def by simp\n    moreover from \\<open>A \\<subseteq> B\\<close> \\<open>V = \\<Union>A\\<close> have \"f-``(V) = \\<Union>{f-``(U). U\\<in>A}\" \n      by auto\n    ultimately have \"f-``(V) \\<in>  \\<tau>\\<^sub>1\" by simp\n  } then show \"f {is continuous}\" using IsContinuous_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2096
    },
    "1889": {
        "type": "lemma",
        "text": "text\\<open>We can strenghten the previous lemma: it is sufficient to check if the \n  inverse image of every set in a subbase is open. The proof is rather awkward,\n  as usual when we deal with general intersections. We have to keep track of \n  the case when the collection is empty.\\<close>\n",
        "assumes": "assumes A1: \"B {is a subbase for} \\<tau>\\<^sub>2\" and A2: \"\\<forall>U\\<in>B. f-``(U) \\<in> \\<tau>\\<^sub>1\" \n  ",
        "using": [
            "IsAsubBaseFor_def",
            "empty_open",
            "topol_cntxs_valid",
            "topology0.fin_inter_open_open",
            "FinPow_def",
            "IsATopology_def",
            "func1_1_L12",
            "Top_ZF_2_1_L5"
        ],
        "statement": "lemma (in two_top_spaces0) Top_ZF_2_1_L6:\n  assumes A1: \"B {is a subbase for} \\<tau>\\<^sub>2\" and A2: \"\\<forall>U\\<in>B. f-``(U) \\<in> \\<tau>\\<^sub>1\" \n  shows \"f {is continuous}\"\n",
        "proof": "proof -\n  let ?C = \"{\\<Inter>A. A \\<in> FinPow(B)}\"\n  from A1 have \"?C {is a base for} \\<tau>\\<^sub>2\"\n    using IsAsubBaseFor_def by simp\n  moreover have \"\\<forall>U\\<in>?C. f-``(U) \\<in> \\<tau>\\<^sub>1\"\n  proof\n    fix U assume \"U\\<in>?C\"\n    { assume \"f-``(U) = 0\"\n      with tau1_is_top have \"f-``(U) \\<in> \\<tau>\\<^sub>1\"\n\tusing empty_open by simp }\n    moreover\n    { assume \"f-``(U) \\<noteq> 0\"\n      then have \"U\\<noteq>0\" by (rule func1_1_L13)\n      moreover from \\<open>U\\<in>?C\\<close> obtain A where \n\t\"A \\<in> FinPow(B)\" and \"U = \\<Inter>A\" \n\tby auto\n      ultimately have \"\\<Inter>A\\<noteq>0\" by simp\n      then have \"A\\<noteq>0\" by (rule inter_nempty_nempty)\n      then have \"{f-``(W). W\\<in>A} \\<noteq> 0\" by simp\n      moreover from A2 \\<open>A \\<in> FinPow(B)\\<close> have \"{f-``(W). W\\<in>A} \\<in> FinPow(\\<tau>\\<^sub>1)\"\n\tby (rule fin_image_fin)\n      ultimately have \"\\<Inter>{f-``(W). W\\<in>A} \\<in> \\<tau>\\<^sub>1\"\n\tusing topol_cntxs_valid topology0.fin_inter_open_open by simp\n      moreover\n      from \\<open>A \\<in> FinPow(B)\\<close> have \"A \\<subseteq> B\" using FinPow_def by simp\n      with tau2_is_top A1 have \"A \\<subseteq> Pow(X\\<^sub>2)\"\n\tusing IsAsubBaseFor_def IsATopology_def by auto\n      with fmapAssum \\<open>A\\<noteq>0\\<close> \\<open>U = \\<Inter>A\\<close> have \"f-``(U) = \\<Inter>{f-``(W). W\\<in>A}\"\n\tusing func1_1_L12 by simp\n      ultimately have \"f-``(U) \\<in> \\<tau>\\<^sub>1\" by simp }\n    ultimately show \"f-``(U) \\<in> \\<tau>\\<^sub>1\" by blast\n  qed\n  ultimately show \"f {is continuous}\"\n    using Top_ZF_2_1_L5 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2097
    },
    "1890": {
        "type": "lemma",
        "text": "text\\<open>A dual of \\<open> Top_ZF_2_1_L5\\<close>: a function that maps base sets to open sets\n  is open.\\<close>\n",
        "assumes": "assumes A1: \"\\<B> {is a base for} \\<tau>\\<^sub>1\" and A2: \"\\<forall>B\\<in>\\<B>. f``(B) \\<in> \\<tau>\\<^sub>2\" and A3: \"U\\<in>\\<tau>\\<^sub>1\" \n  ",
        "using": [
            "Top_1_2_L1",
            "Top_1_2_L5",
            "fmapAssum",
            "image_of_Union",
            "tau2_is_top",
            "IsATopology_def"
        ],
        "statement": "lemma (in two_top_spaces0) base_image_open: \n  assumes A1: \"\\<B> {is a base for} \\<tau>\\<^sub>1\" and A2: \"\\<forall>B\\<in>\\<B>. f``(B) \\<in> \\<tau>\\<^sub>2\" and A3: \"U\\<in>\\<tau>\\<^sub>1\" \n  shows \"f``(U) \\<in> \\<tau>\\<^sub>2\"\n",
        "proof": "proof -\n  from A1 A3 obtain \\<E> where \"\\<E> \\<in> Pow(\\<B>)\" and \"U = \\<Union>\\<E>\" using Top_1_2_L1 by blast\n  with A1 have \"f``(U) = \\<Union>{f``(E). E \\<in> \\<E>}\" using Top_1_2_L5  fmapAssum image_of_Union\n    by auto\n  moreover \n  from A2 \\<open>\\<E> \\<in> Pow(\\<B>)\\<close> have \"{f``(E). E \\<in> \\<E>} \\<in> Pow(\\<tau>\\<^sub>2)\" by auto\n  then have \"\\<Union>{f``(E). E \\<in> \\<E>} \\<in> \\<tau>\\<^sub>2\" using tau2_is_top IsATopology_def by simp\n  ultimately show ?thesis using tau2_is_top IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2098
    },
    "1891": {
        "type": "lemma",
        "text": "text\\<open>A composition of two continuous functions is continuous.\\<close>\n",
        "assumes": "assumes \"IsContinuous(T,S,f)\" and \"IsContinuous(S,R,g)\"\n  ",
        "using": [
            "assms",
            "IsContinuous_def",
            "vimage_comp"
        ],
        "statement": "lemma comp_cont: assumes \"IsContinuous(T,S,f)\" and \"IsContinuous(S,R,g)\"\n  shows \"IsContinuous(T,R,g O f)\"\n  ",
        "proof": "using assms IsContinuous_def vimage_comp by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2099
    },
    "1892": {
        "type": "lemma",
        "text": "text\\<open>A composition of three continuous functions is continuous.\\<close>\n",
        "assumes": "assumes \"IsContinuous(T,S,f)\" and \"IsContinuous(S,R,g)\" and \"IsContinuous(R,P,h)\"\n  ",
        "using": [
            "assms",
            "IsContinuous_def",
            "vimage_comp"
        ],
        "statement": "lemma comp_cont3: \n  assumes \"IsContinuous(T,S,f)\" and \"IsContinuous(S,R,g)\" and \"IsContinuous(R,P,h)\"\n  shows \"IsContinuous(T,P,h O g O f)\"\n  ",
        "proof": "using assms IsContinuous_def vimage_comp by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2100
    },
    "1893": {
        "type": "lemma",
        "text": "text\\<open>The graph of a continuous function into a Hausdorff topological space is closed\n  in the product topology. Recall that in ZF a function is the same as its graph.\\<close>\n",
        "assumes": "assumes \"f {is continuous}\" \"\\<tau>\\<^sub>2 {is T\\<^sub>2}\"\n  ",
        "using": [
            "fun_is_set_of_pairs",
            "func1_1_L15",
            "fun_is_fun",
            "function_image_vimage",
            "vimage_prod_dis_graph",
            "point_neighb_prod_top",
            "fun_subset_prod",
            "Top_1_4_T1(3)",
            "IsClosed_def"
        ],
        "statement": "lemma (in two_top_spaces0) into_T2_graph_closed:\n  assumes \"f {is continuous}\" \"\\<tau>\\<^sub>2 {is T\\<^sub>2}\"\n  shows \"f {is closed in} ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\"\n",
        "proof": "proof -\n  from fmapAssum have \"f = {\\<langle>x,f`(x)\\<rangle>. x\\<in>X\\<^sub>1}\" using fun_is_set_of_pairs\n    by simp\n  let ?f\\<^sub>c = \"X\\<^sub>1\\<times>X\\<^sub>2 - f\"\n  have \"?f\\<^sub>c \\<in> ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\"\n  proof -\n    { fix p assume \"p\\<in>?f\\<^sub>c\"\n      then have \"p \\<in> X\\<^sub>1\\<times>X\\<^sub>2\" and \"p \\<notin> f\" by auto\n      from \\<open>p\\<in>X\\<^sub>1\\<times>X\\<^sub>2\\<close> obtain x y where \"x\\<in>X\\<^sub>1\" \"y\\<in>X\\<^sub>2\" \"p = \\<langle>x,y\\<rangle>\"\n        by auto\n      have \"y\\<noteq>f`(x)\"\n      proof -\n        { assume \"y=f`(x)\"\n          with \\<open>x\\<in>X\\<^sub>1\\<close> \\<open>p = \\<langle>x,y\\<rangle>\\<close> have \"p \\<in> {\\<langle>x,f`(x)\\<rangle>. x\\<in>X\\<^sub>1}\" by auto\n          with \\<open>f = {\\<langle>x,f`(x)\\<rangle>. x\\<in>X\\<^sub>1}\\<close> \\<open>p \\<notin> f\\<close> have False by auto\n        } thus \"y\\<noteq>f`(x)\" by auto\n      qed\n      from fmapAssum \\<open>x\\<in>X\\<^sub>1\\<close> have \"f`(x) \\<in> X\\<^sub>2\" by (rule apply_funtype)\n      with \\<open>y\\<in>X\\<^sub>2\\<close>  have \"y\\<in>\\<Union>\\<tau>\\<^sub>2\" \"f`(x) \\<in> \\<Union>\\<tau>\\<^sub>2\" by auto\n      with assms(2) \\<open>y\\<noteq>f`(x)\\<close> obtain U V \n        where \"U\\<in>\\<tau>\\<^sub>2\" \"V\\<in>\\<tau>\\<^sub>2\" \"y\\<in>U\" \"f`(x)\\<in>V\" \"U\\<inter>V = 0\"\n        unfolding isT2_def by blast\n      let ?W = \"f-``(V)\"\n      have \"?W\\<in>\\<tau>\\<^sub>1\" \"?W\\<subseteq>X\\<^sub>1\" \"U\\<subseteq>X\\<^sub>2\" \"x\\<in>?W\" \"p\\<in>?W\\<times>U\" \"f``(?W) \\<subseteq> V\"\n      proof -\n        from assms(1) have \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" by simp\n        with \\<open>V\\<in>\\<tau>\\<^sub>2\\<close> \\<open>U\\<in>\\<tau>\\<^sub>2\\<close> show \"?W\\<in>\\<tau>\\<^sub>1\" \"?W\\<subseteq>X\\<^sub>1\" \"U\\<subseteq>X\\<^sub>2\" \n          unfolding IsContinuous_def by auto\n        from fmapAssum \\<open>x\\<in>X\\<^sub>1\\<close> \\<open>f`(x)\\<in>V\\<close> show \"x\\<in>?W\" using func1_1_L15 \n          by auto\n        with \\<open>y\\<in>U\\<close> \\<open>y\\<in>U\\<close> \\<open>p = \\<langle>x,y\\<rangle>\\<close> show  \"p\\<in>?W\\<times>U\" by simp\n        from fmapAssum show \"f``(?W) \\<subseteq> V\" \n          using fun_is_fun function_image_vimage by simp \n      qed\n      from fmapAssum \\<open>U\\<inter>V = 0\\<close> \\<open>?W\\<subseteq>X\\<^sub>1\\<close> \\<open>U\\<subseteq>X\\<^sub>2\\<close> have \"?W\\<times>U \\<subseteq> ?f\\<^sub>c\"\n        using vimage_prod_dis_graph by blast \n      with \\<open>?W\\<in>\\<tau>\\<^sub>1\\<close> \\<open>U\\<in>\\<tau>\\<^sub>2\\<close> \\<open>p\\<in>?W\\<times>U\\<close> have \"\\<exists>W\\<in>\\<tau>\\<^sub>1.\\<exists>U\\<in>\\<tau>\\<^sub>2. p\\<in>W\\<times>U \\<and> W\\<times>U \\<subseteq> ?f\\<^sub>c\" \n        by blast\n    } \n    with tau1_is_top tau2_is_top show \"?f\\<^sub>c \\<in> ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\"\n      using point_neighb_prod_top by simp    \n  qed\n  with fmapAssum tau1_is_top tau2_is_top show ?thesis\n    using fun_subset_prod Top_1_4_T1(3) unfolding IsClosed_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2101
    },
    "1894": {
        "type": "definition",
        "text": "text\\<open>Homeomorphism is a bijection that preserves open sets.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \"IsAhomeomorphism(T,S,f) \\<equiv>\n         f \\<in> bij(\\<Union>T,\\<Union>S) \\<and> IsContinuous(T,S,f) \\<and> IsContinuous(S,T,converse(f))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2102
    },
    "1895": {
        "type": "lemma",
        "text": "text\\<open>Inverse (converse) of a homeomorphism is a homeomorphism.\\<close>\n",
        "assumes": "assumes \"IsAhomeomorphism(T,S,f)\"\n  ",
        "using": [
            "assms",
            "IsAhomeomorphism_def",
            "bij_converse_bij",
            "bij_converse_converse"
        ],
        "statement": "lemma homeo_inv: assumes \"IsAhomeomorphism(T,S,f)\"\n  shows \"IsAhomeomorphism(S,T,converse(f))\"\n  ",
        "proof": "using assms IsAhomeomorphism_def bij_converse_bij bij_converse_converse\n    by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2103
    },
    "1896": {
        "type": "lemma",
        "text": "text\\<open>Homeomorphisms are open maps.\\<close>\n",
        "assumes": "assumes \"IsAhomeomorphism(T,S,f)\" and \"U\\<in>T\"\n  ",
        "using": [
            "assms",
            "image_converse",
            "IsAhomeomorphism_def",
            "IsContinuous_def"
        ],
        "statement": "lemma homeo_open: assumes \"IsAhomeomorphism(T,S,f)\" and \"U\\<in>T\"\n  shows \"f``(U) \\<in> S\"\n  ",
        "proof": "using assms image_converse IsAhomeomorphism_def IsContinuous_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2104
    },
    "1897": {
        "type": "lemma",
        "text": "text\\<open>A continuous bijection that is an open map is a homeomorphism.\\<close>\n",
        "assumes": "assumes \"f \\<in> bij(\\<Union>T,\\<Union>S)\" and \"IsContinuous(T,S,f)\" and \"\\<forall>U\\<in>T. f``(U) \\<in> S\" \n  ",
        "using": [
            "assms",
            "image_converse",
            "IsAhomeomorphism_def",
            "IsContinuous_def"
        ],
        "statement": "lemma bij_cont_open_homeo: \n  assumes \"f \\<in> bij(\\<Union>T,\\<Union>S)\" and \"IsContinuous(T,S,f)\" and \"\\<forall>U\\<in>T. f``(U) \\<in> S\" \n  shows \"IsAhomeomorphism(T,S,f)\"\n  ",
        "proof": "using assms image_converse IsAhomeomorphism_def IsContinuous_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2105
    },
    "1898": {
        "type": "lemma",
        "text": "text\\<open>A bijection that maps base to base is a homeomorphism.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(X\\<^sub>1,X\\<^sub>2)\" and A2: \"\\<B> {is a base for} \\<tau>\\<^sub>1\" and \n  A3: \"{f``(B). B\\<in>\\<B>} {is a base for} \\<tau>\\<^sub>2\"\n  ",
        "using": [
            "Top_1_2_L5",
            "bij_def",
            "inj_vimage_image",
            "base_sets_open",
            "base_image_open",
            "bij_cont_open_homeo"
        ],
        "statement": "lemma (in two_top_spaces0) bij_base_homeo: \n  assumes A1: \"f \\<in> bij(X\\<^sub>1,X\\<^sub>2)\" and A2: \"\\<B> {is a base for} \\<tau>\\<^sub>1\" and \n  A3: \"{f``(B). B\\<in>\\<B>} {is a base for} \\<tau>\\<^sub>2\"\n  shows \"IsAhomeomorphism(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\"\n",
        "proof": "proof -\n  note A1\n  moreover have \"f {is continuous}\"\n  proof -\n    { fix C assume \"C \\<in> {f``(B). B\\<in>\\<B>}\"\n      then obtain B where \"B\\<in>\\<B>\" and I: \"C = f``(B)\" by auto\n      with A2 have \"B \\<subseteq> X\\<^sub>1\" using Top_1_2_L5 by auto\n      with A1 A2 \\<open>B\\<in>\\<B>\\<close> I have \"f-``(C) \\<in> \\<tau>\\<^sub>1\" \n         using bij_def inj_vimage_image base_sets_open by auto\n    } hence \"\\<forall>C \\<in> {f``(B). B\\<in>\\<B>}. f-``(C) \\<in> \\<tau>\\<^sub>1\" by auto\n    with A3 show ?thesis by (rule Top_ZF_2_1_L5)\n  qed\n  moreover \n  from A3 have \"\\<forall>B\\<in>\\<B>. f``(B) \\<in> \\<tau>\\<^sub>2\" using base_sets_open by auto\n  with A2 have \"\\<forall>U\\<in>\\<tau>\\<^sub>1. f``(U) \\<in> \\<tau>\\<^sub>2\" using base_image_open by simp\n  ultimately show ?thesis using bij_cont_open_homeo by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2107
    },
    "1899": {
        "type": "theorem",
        "text": "text\\<open>Interior is a topological invariant.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>\\<Union>T\" and A2: \"IsAhomeomorphism(T,S,f)\"\n  ",
        "using": [
            "homeo_open",
            "IsAhomeomorphism_def",
            "bij_def",
            "inj_vimage_image",
            "IsContinuous_def",
            "surj_image_vimage",
            "inj_def",
            "image_of_Union"
        ],
        "statement": "theorem int_top_invariant: assumes A1: \"A\\<subseteq>\\<Union>T\" and A2: \"IsAhomeomorphism(T,S,f)\"\n  shows \"f``(Interior(A,T)) = Interior(f``(A),S)\"\n",
        "proof": "proof -\n  let ?\\<A> = \"{U\\<in>T. U\\<subseteq>A}\"\n  have I: \"{f``(U). U\\<in>?\\<A>} = {V\\<in>S. V \\<subseteq> f``(A)}\"\n  proof\n    from A2 show \"{f``(U). U\\<in>?\\<A>} \\<subseteq> {V\\<in>S. V \\<subseteq> f``(A)}\"\n      using homeo_open by auto\n    { fix V assume \"V \\<in> {V\\<in>S. V \\<subseteq> f``(A)}\"\n      hence \"V\\<in>S\" and II: \"V \\<subseteq> f``(A)\" by auto\n      let ?U = \"f-``(V)\"\n      from II have \"?U \\<subseteq> f-``(f``(A))\" by auto\n      moreover from assms have \"f-``(f``(A)) = A\"\n        using IsAhomeomorphism_def bij_def inj_vimage_image by auto\n      moreover from A2 \\<open>V\\<in>S\\<close> have \"?U\\<in>T\" \n        using IsAhomeomorphism_def IsContinuous_def by simp\n      moreover \n      from \\<open>V\\<in>S\\<close> have \"V \\<subseteq> \\<Union>S\" by auto\n      with A2 have \"V = f``(?U)\" \n        using IsAhomeomorphism_def bij_def surj_image_vimage by auto\n      ultimately have \"V \\<in> {f``(U). U\\<in>?\\<A>}\" by auto\n    } thus \"{V\\<in>S. V \\<subseteq> f``(A)} \\<subseteq> {f``(U). U\\<in>?\\<A>}\" by auto\n  qed\n  have \"f``(Interior(A,T)) =  f``(\\<Union>?\\<A>)\" unfolding Interior_def by simp\n  also from A2 have \"\\<dots> = \\<Union>{f``(U). U\\<in>?\\<A>}\" \n    using IsAhomeomorphism_def bij_def inj_def image_of_Union by auto\n  also from I have \"\\<dots> = Interior(f``(A),S)\" unfolding Interior_def by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2108
    },
    "1900": {
        "type": "theorem",
        "text": "text\\<open>A bijection from a topological space induces a topology on the range.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\" and A2: \"f \\<in> bij(\\<Union>T,Y)\"\n  ",
        "using": [
            "bij_def",
            "inj_def",
            "inj_vimage_image",
            "IsATopology_def",
            "image_of_Union",
            "func1_1_L6",
            "surj_subsets",
            "inj_image_inter",
            "func_imagedef",
            "surj_range_image_domain",
            "bij_cont_open_homeo"
        ],
        "statement": "theorem bij_induced_top: assumes A1: \"T {is a topology}\" and A2: \"f \\<in> bij(\\<Union>T,Y)\"\n  shows \n  \"{f``(U). U\\<in>T} {is a topology}\" and\n  \"{ {f`(x).x\\<in>U}. U\\<in>T} {is a topology}\" and \n  \"(\\<Union>{f``(U). U\\<in>T}) = Y\" and \n  \"IsAhomeomorphism(T, {f``(U). U\\<in>T},f)\"\n",
        "proof": "proof -\n  from A2 have \"f \\<in> inj(\\<Union>T,Y)\" using bij_def by simp \n  then have \"f:\\<Union>T\\<rightarrow>Y\" using inj_def by simp\n  let ?S = \"{f``(U). U\\<in>T}\"\n  { fix M assume \"M \\<in> Pow(?S)\"\n    let ?M\\<^sub>T = \"{f-``(V). V\\<in>M}\"\n    have \"?M\\<^sub>T \\<subseteq> T\"\n    proof\n      fix W assume \"W\\<in>?M\\<^sub>T\"\n      then obtain V where \"V\\<in>M\" and I: \"W = f-``(V)\" by auto\n      with \\<open>M \\<in> Pow(?S)\\<close> have \"V\\<in>?S\" by auto\n      then obtain U where \"U\\<in>T\" and  \"V = f``(U)\" by auto\n      with I have \"W = f-``(f``(U))\" by simp\n      with \\<open>f \\<in> inj(\\<Union>T,Y)\\<close>  \\<open>U\\<in>T\\<close> have \"W = U\" using inj_vimage_image by blast \n      with \\<open>U\\<in>T\\<close> show \"W\\<in>T\" by simp\n    qed\n    with A1 have \"(\\<Union>?M\\<^sub>T) \\<in> T\" using IsATopology_def by simp\n    hence \"f``(\\<Union>?M\\<^sub>T) \\<in>  ?S\" by auto \n    moreover have \"f``(\\<Union>?M\\<^sub>T) = \\<Union>M\"\n    proof -\n      from \\<open>f:\\<Union>T\\<rightarrow>Y\\<close> \\<open>?M\\<^sub>T \\<subseteq> T\\<close>  have \"f``(\\<Union>?M\\<^sub>T) = \\<Union>{f``(U). U\\<in>?M\\<^sub>T}\"\n         using image_of_Union by auto \n      moreover have \"{f``(U). U\\<in>?M\\<^sub>T} = M\"\n      proof -\n        from \\<open>f:\\<Union>T\\<rightarrow>Y\\<close> have \"\\<forall>U\\<in>T. f``(U) \\<subseteq> Y\" using  func1_1_L6 by simp\n        with \\<open>M \\<in> Pow(?S)\\<close> have \"M \\<subseteq> Pow(Y)\" by auto \n        with A2 show \"{f``(U). U\\<in>?M\\<^sub>T} = M\" using bij_def surj_subsets by auto\n      qed\n      ultimately show \"f``(\\<Union>?M\\<^sub>T) = \\<Union>M\" by simp \n    qed\n    ultimately have \"\\<Union>M \\<in> ?S\" by auto\n  } then have \"\\<forall>M\\<in>Pow(?S). \\<Union>M \\<in> ?S\" by auto\n  moreover\n  { fix U V assume \"U\\<in>?S\" \"V\\<in>?S\"\n    then obtain U\\<^sub>T V\\<^sub>T where \"U\\<^sub>T \\<in> T\"   \"V\\<^sub>T \\<in> T\" and \n      I: \"U = f``(U\\<^sub>T)\"  \"V = f``(V\\<^sub>T)\"\n      by auto\n    with A1 have \"U\\<^sub>T\\<inter>V\\<^sub>T \\<in> T\" using IsATopology_def by simp\n    hence \"f``(U\\<^sub>T\\<inter>V\\<^sub>T) \\<in> ?S\" by auto\n    moreover have \"f``(U\\<^sub>T\\<inter>V\\<^sub>T) = U\\<inter>V\"\n    proof -\n      from \\<open>U\\<^sub>T \\<in> T\\<close>  \\<open>V\\<^sub>T \\<in> T\\<close> have \"U\\<^sub>T \\<subseteq> \\<Union>T\"  \"V\\<^sub>T \\<subseteq> \\<Union>T\"\n        using bij_def by auto\n      with \\<open>f \\<in> inj(\\<Union>T,Y)\\<close> I show \"f``(U\\<^sub>T\\<inter>V\\<^sub>T) = U\\<inter>V\" using inj_image_inter \n      by simp \n    qed\n    ultimately have \"U\\<inter>V \\<in> ?S\" by simp \n  } then have \"\\<forall>U\\<in>?S. \\<forall>V\\<in>?S. U\\<inter>V \\<in> ?S\" by auto \n  ultimately show \"?S {is a topology}\" using IsATopology_def by simp\n  moreover from \\<open>f:\\<Union>T\\<rightarrow>Y\\<close> have \"\\<forall>U\\<in>T. f``(U) = {f`(x).x\\<in>U}\"\n    using func_imagedef by blast\n  ultimately show \"{ {f`(x).x\\<in>U}. U\\<in>T} {is a topology}\" by simp  \n  show \"\\<Union>?S =  Y\"\n  proof \n    from \\<open>f:\\<Union>T\\<rightarrow>Y\\<close> have \"\\<forall>U\\<in>T. f``(U) \\<subseteq> Y\" using func1_1_L6 by simp\n    thus \"\\<Union>?S \\<subseteq> Y\" by auto\n    from A1 have \"f``(\\<Union>T) \\<subseteq> \\<Union>?S\" using IsATopology_def by auto \n    with A2 show \"Y \\<subseteq> \\<Union>?S\" using bij_def surj_range_image_domain \n      by auto\n  qed\n  show \"IsAhomeomorphism(T,?S,f)\"\n  proof -\n    from A2  \\<open>\\<Union>?S =  Y\\<close> have \"f \\<in> bij(\\<Union>T,\\<Union>?S)\" by simp\n    moreover have \"IsContinuous(T,?S,f)\"\n    proof -\n      { fix V assume \"V\\<in>?S\"\n        then obtain U where \"U\\<in>T\" and \"V = f``(U)\" by auto\n        hence \"U \\<subseteq> \\<Union>T\" and \"f-``(V) = f-``(f``(U))\"  by auto\n        with \\<open>f \\<in> inj(\\<Union>T,Y)\\<close>  \\<open>U\\<in>T\\<close> have \"f-``(V) \\<in> T\"  using inj_vimage_image \n          by simp \n      } then show \"IsContinuous(T,?S,f)\" unfolding IsContinuous_def by auto\n    qed\n    ultimately show\"IsAhomeomorphism(T,?S,f)\" using bij_cont_open_homeo \n      by auto \n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2109
    },
    "1901": {
        "type": "lemma",
        "text": "text\\<open>If a function is continuous, then it is continuous when we restrict\n  the topology on the range to the image of the domain.\\<close>\n",
        "assumes": "assumes A1: \"f {is continuous}\"\n  ",
        "using": [
            "RestrictedTo_def",
            "fmapAssum",
            "inv_im_inter_im",
            "IsContinuous_def"
        ],
        "statement": "lemma (in two_top_spaces0) restr_image_cont:\n  assumes A1: \"f {is continuous}\"\n  shows \"IsContinuous(\\<tau>\\<^sub>1, \\<tau>\\<^sub>2 {restricted to} f``(X\\<^sub>1),f)\"\n",
        "proof": "proof -\n  have \"\\<forall>U \\<in> \\<tau>\\<^sub>2 {restricted to} f``(X\\<^sub>1). f-``(U) \\<in> \\<tau>\\<^sub>1\"\n  proof\n    fix U assume \"U \\<in> \\<tau>\\<^sub>2 {restricted to} f``(X\\<^sub>1)\"\n    then obtain V where \"V \\<in> \\<tau>\\<^sub>2\" and \"U = V \\<inter> f``(X\\<^sub>1)\"\n      using RestrictedTo_def by auto\n    with A1 show  \"f-``(U) \\<in> \\<tau>\\<^sub>1\"\n      using fmapAssum inv_im_inter_im IsContinuous_def\n      by simp\n  qed\n  then show ?thesis using IsContinuous_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2111
    },
    "1902": {
        "type": "lemma",
        "text": "text\\<open>A combination of \\<open>restr_cont\\<close> and \\<open>restr_image_cont\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> X\\<^sub>1\" and A2: \"f {is continuous}\" and\n  A3: \"g = restrict(f,A)\" and\n  A4: \"\\<tau>\\<^sub>3 = \\<tau>\\<^sub>1 {restricted to} A\"\n  ",
        "using": [
            "union_restrict",
            "tau1_is_top",
            "tau2_is_top",
            "topology0_def",
            "topology0.Top_1_L4",
            "fmapAssum",
            "restrict_type2",
            "two_top_spaces0_def",
            "restr_cont"
        ],
        "statement": "lemma (in two_top_spaces0) restr_restr_image_cont:\n  assumes A1: \"A \\<subseteq> X\\<^sub>1\" and A2: \"f {is continuous}\" and\n  A3: \"g = restrict(f,A)\" and\n  A4: \"\\<tau>\\<^sub>3 = \\<tau>\\<^sub>1 {restricted to} A\"\n  shows \"IsContinuous(\\<tau>\\<^sub>3, \\<tau>\\<^sub>2 {restricted to} g``(A),g)\"\n",
        "proof": "proof -\n  from A1 A4 have \"\\<Union>\\<tau>\\<^sub>3 = A\"\n    using union_restrict by auto\n  have \"two_top_spaces0(\\<tau>\\<^sub>3, \\<tau>\\<^sub>2, g)\"\n  proof -\n    from A4 have\n      \"\\<tau>\\<^sub>3 {is a topology}\" and \"\\<tau>\\<^sub>2 {is a topology}\"\n      using tau1_is_top tau2_is_top\n\ttopology0_def topology0.Top_1_L4 by auto\n    moreover from A1 A3 \\<open>\\<Union>\\<tau>\\<^sub>3 = A\\<close> have \"g: \\<Union>\\<tau>\\<^sub>3 \\<rightarrow> \\<Union>\\<tau>\\<^sub>2\"\n      using fmapAssum restrict_type2 by simp\n    ultimately show ?thesis using two_top_spaces0_def\n      by simp\n  qed\n  moreover from assms have \"IsContinuous(\\<tau>\\<^sub>3, \\<tau>\\<^sub>2, g)\"\n    using restr_cont by simp\n  ultimately have \"IsContinuous(\\<tau>\\<^sub>3, \\<tau>\\<^sub>2 {restricted to} g``(\\<Union>\\<tau>\\<^sub>3),g)\"\n    by (rule two_top_spaces0.restr_image_cont)\n  moreover note \\<open>\\<Union>\\<tau>\\<^sub>3 = A\\<close>\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2112
    },
    "1903": {
        "type": "lemma",
        "text": "text\\<open>If a partial function $g:X_1\\supseteq A\\rightarrow X_2$ is continuous with\nrespect to $(\\tau_1,\\tau_2)$, then $A$ is open (in $\\tau_1$) and \nthe function is continuous in the relative topology.\\<close>\n",
        "assumes": "assumes A1: \"g:A\\<rightarrow>X\\<^sub>2\" and A2: \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g)\"\n  ",
        "using": [
            "tau2_is_top",
            "IsATopology_def",
            "IsContinuous_def",
            "func1_1_L4",
            "func1_1_L3",
            "RestrictedTo_def"
        ],
        "statement": "lemma (in two_top_spaces1) partial_fun_cont:\n  assumes A1: \"g:A\\<rightarrow>X\\<^sub>2\" and A2: \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g)\"\n  shows \"A \\<in> \\<tau>\\<^sub>1\" and \"IsContinuous(\\<tau>\\<^sub>1 {restricted to} A, \\<tau>\\<^sub>2, g)\"\n",
        "proof": "proof -\n  from A2 have \"g-``(X\\<^sub>2) \\<in> \\<tau>\\<^sub>1\" \n    using tau2_is_top IsATopology_def IsContinuous_def by simp\n  with A1 show \"A \\<in> \\<tau>\\<^sub>1\" using func1_1_L4 by simp\n  { fix V assume \"V \\<in> \\<tau>\\<^sub>2\"\n    with A2 have \"g-``(V) \\<in> \\<tau>\\<^sub>1\" using IsContinuous_def by simp\n    moreover\n    from A1 have \"g-``(V) \\<subseteq> A\" using func1_1_L3 by simp\n    hence \"g-``(V) = A \\<inter> g-``(V)\" by auto\n    ultimately have \"g-``(V) \\<in> (\\<tau>\\<^sub>1 {restricted to} A)\"\n      using RestrictedTo_def by auto\n  } then show \"IsContinuous(\\<tau>\\<^sub>1 {restricted to} A, \\<tau>\\<^sub>2, g)\"\n    using IsContinuous_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2113
    },
    "1904": {
        "type": "lemma",
        "text": "text\\<open>For partial function defined on open sets continuity in the whole\n  and relative topologies are the same.\\<close>\n",
        "assumes": "assumes A1: \"g:A\\<rightarrow>X\\<^sub>2\" and A2: \"A \\<in> \\<tau>\\<^sub>1\"\n  ",
        "using": [
            "partial_fun_cont",
            "IsContinuous_def",
            "RestrictedTo_def",
            "tau1_is_top",
            "IsATopology_def"
        ],
        "statement": "lemma (in two_top_spaces1) part_fun_on_open_cont:\n  assumes A1: \"g:A\\<rightarrow>X\\<^sub>2\" and A2: \"A \\<in> \\<tau>\\<^sub>1\"\n  shows \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g) \\<longleftrightarrow> \n         IsContinuous(\\<tau>\\<^sub>1 {restricted to} A, \\<tau>\\<^sub>2, g)\"\n",
        "proof": "proof\n  assume \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g)\"\n  with A1 show \"IsContinuous(\\<tau>\\<^sub>1 {restricted to} A, \\<tau>\\<^sub>2, g)\"\n    using partial_fun_cont by simp\n  next\n    assume I: \"IsContinuous(\\<tau>\\<^sub>1 {restricted to} A, \\<tau>\\<^sub>2, g)\"\n    { fix V assume \"V \\<in> \\<tau>\\<^sub>2\"\n      with I have \"g-``(V) \\<in> (\\<tau>\\<^sub>1 {restricted to} A)\"\n        using IsContinuous_def by simp\n      then obtain W where \"W \\<in> \\<tau>\\<^sub>1\" and \"g-``(V) = A\\<inter>W\"\n        using RestrictedTo_def by auto\n      with A2 have \"g-``(V) \\<in> \\<tau>\\<^sub>1\" using tau1_is_top IsATopology_def \n        by simp\n    } then show \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g)\" using IsContinuous_def\n      by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2114
    },
    "1905": {
        "type": "lemma",
        "text": "text\\<open>Fixing the first variable in a two-variable continuous function results in a \ncontinuous function.\\<close>\n",
        "assumes": "assumes \"f: X\\<^sub>1\\<times>X\\<^sub>2\\<rightarrow>X\\<^sub>3\" and \"IsContinuous(\\<eta>,\\<tau>\\<^sub>3,f)\"\n  and \"x\\<in>X\\<^sub>1\"\n  ",
        "using": [
            "assms",
            "fix_1st_var_vimage",
            "IsContinuous_def",
            "tau1_is_top",
            "tau2_is_top",
            "prod_sec_open1"
        ],
        "statement": "lemma (in prod_top_spaces0) fix_1st_var_cont: \n  assumes \"f: X\\<^sub>1\\<times>X\\<^sub>2\\<rightarrow>X\\<^sub>3\" and \"IsContinuous(\\<eta>,\\<tau>\\<^sub>3,f)\"\n  and \"x\\<in>X\\<^sub>1\"\n  shows \"IsContinuous(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3,Fix1stVar(f,x))\"\n  ",
        "proof": "using assms fix_1st_var_vimage IsContinuous_def tau1_is_top tau2_is_top\n    prod_sec_open1 by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2115
    },
    "1906": {
        "type": "lemma",
        "text": "text\\<open>Fixing the second variable in a two-variable continuous function results in a\ncontinuous function.\\<close>\n",
        "assumes": "assumes \"f: X\\<^sub>1\\<times>X\\<^sub>2\\<rightarrow>X\\<^sub>3\" and \"IsContinuous(\\<eta>,\\<tau>\\<^sub>3,f)\"\n  and \"y\\<in>X\\<^sub>2\"\n  ",
        "using": [
            "assms",
            "fix_2nd_var_vimage",
            "IsContinuous_def",
            "tau1_is_top",
            "tau2_is_top",
            "prod_sec_open2"
        ],
        "statement": "lemma (in prod_top_spaces0) fix_2nd_var_cont: \n  assumes \"f: X\\<^sub>1\\<times>X\\<^sub>2\\<rightarrow>X\\<^sub>3\" and \"IsContinuous(\\<eta>,\\<tau>\\<^sub>3,f)\"\n  and \"y\\<in>X\\<^sub>2\"\n  shows \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>3,Fix2ndVar(f,y))\"\n  ",
        "proof": "using assms fix_2nd_var_vimage IsContinuous_def tau1_is_top tau2_is_top\n    prod_sec_open2 by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2116
    },
    "1907": {
        "type": "lemma",
        "text": "text\\<open>Having two constinuous mappings we can construct a third one on the cartesian product\n  of the domains.\\<close>\n",
        "assumes": "assumes A1: \"\\<tau>\\<^sub>1 {is a topology}\" \"\\<tau>\\<^sub>2 {is a topology}\" and \n  A2: \"\\<eta>\\<^sub>1 {is a topology}\" \"\\<eta>\\<^sub>2 {is a topology}\" and\n  A3a: \"f\\<^sub>1:\\<Union>\\<tau>\\<^sub>1\\<rightarrow>\\<Union>\\<eta>\\<^sub>1\"  and A3b: \"f\\<^sub>2:\\<Union>\\<tau>\\<^sub>2\\<rightarrow>\\<Union>\\<eta>\\<^sub>2\" and\n  A4: \"IsContinuous(\\<tau>\\<^sub>1,\\<eta>\\<^sub>1,f\\<^sub>1)\" \"IsContinuous(\\<tau>\\<^sub>2,\\<eta>\\<^sub>2,f\\<^sub>2)\" and\n  A5: \"g = {\\<langle>p,\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2}\"\n  ",
        "using": [
            "Top_1_4_T1",
            "ZF_fun_from_total",
            "two_top_spaces0_def",
            "ProductCollection_def",
            "cart_prod_fun_vimage",
            "IsContinuous_def",
            "prod_open_open_prod",
            "two_top_spaces0.Top_ZF_2_1_L5"
        ],
        "statement": "lemma cart_prod_cont: \n  assumes A1: \"\\<tau>\\<^sub>1 {is a topology}\" \"\\<tau>\\<^sub>2 {is a topology}\" and \n  A2: \"\\<eta>\\<^sub>1 {is a topology}\" \"\\<eta>\\<^sub>2 {is a topology}\" and\n  A3a: \"f\\<^sub>1:\\<Union>\\<tau>\\<^sub>1\\<rightarrow>\\<Union>\\<eta>\\<^sub>1\"  and A3b: \"f\\<^sub>2:\\<Union>\\<tau>\\<^sub>2\\<rightarrow>\\<Union>\\<eta>\\<^sub>2\" and\n  A4: \"IsContinuous(\\<tau>\\<^sub>1,\\<eta>\\<^sub>1,f\\<^sub>1)\" \"IsContinuous(\\<tau>\\<^sub>2,\\<eta>\\<^sub>2,f\\<^sub>2)\" and\n  A5: \"g = {\\<langle>p,\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2}\"\n  shows \"IsContinuous(ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2),ProductTopology(\\<eta>\\<^sub>1,\\<eta>\\<^sub>2),g)\"\n",
        "proof": "proof -\n  let ?\\<tau> = \"ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\"\n  let ?\\<eta> = \"ProductTopology(\\<eta>\\<^sub>1,\\<eta>\\<^sub>2)\"\n  let ?X\\<^sub>1 = \"\\<Union>\\<tau>\\<^sub>1\"\n  let ?X\\<^sub>2 = \"\\<Union>\\<tau>\\<^sub>2\"\n  let ?Y\\<^sub>1 = \"\\<Union>\\<eta>\\<^sub>1\"\n  let ?Y\\<^sub>2 = \"\\<Union>\\<eta>\\<^sub>2\"\n  let ?B = \"ProductCollection(\\<eta>\\<^sub>1,\\<eta>\\<^sub>2)\"\n  from A1 A2 have \"?\\<tau> {is a topology}\" and \"?\\<eta> {is a topology}\"\n    using Top_1_4_T1 by auto\n  moreover have \"g: ?X\\<^sub>1\\<times>?X\\<^sub>2 \\<rightarrow> ?Y\\<^sub>1\\<times>?Y\\<^sub>2\"\n  proof -\n    { fix p assume \"p \\<in> ?X\\<^sub>1\\<times>?X\\<^sub>2\"\n      hence \"fst(p) \\<in> ?X\\<^sub>1\" and \"snd(p) \\<in> ?X\\<^sub>2\" by auto\n      from A3a \\<open>fst(p) \\<in> ?X\\<^sub>1\\<close> have \"f\\<^sub>1`(fst(p)) \\<in> ?Y\\<^sub>1\" \n        by (rule apply_funtype)\n      moreover from A3b \\<open>snd(p) \\<in> ?X\\<^sub>2\\<close> have \"f\\<^sub>2`(snd(p)) \\<in> ?Y\\<^sub>2\" \n        by (rule apply_funtype)\n      ultimately have \"\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle> \\<in> \\<Union>\\<eta>\\<^sub>1\\<times>\\<Union>\\<eta>\\<^sub>2\" by auto\n    } hence \"\\<forall>p \\<in> ?X\\<^sub>1\\<times>?X\\<^sub>2. \\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle> \\<in> ?Y\\<^sub>1\\<times>?Y\\<^sub>2\"\n      by simp\n    with A5 show \"g: ?X\\<^sub>1\\<times>?X\\<^sub>2 \\<rightarrow> ?Y\\<^sub>1\\<times>?Y\\<^sub>2\" using ZF_fun_from_total\n      by simp \n  qed\n  moreover from A1 A2 have \"\\<Union>?\\<tau> = ?X\\<^sub>1\\<times>?X\\<^sub>2\" and \"\\<Union>?\\<eta> = ?Y\\<^sub>1\\<times>?Y\\<^sub>2\"\n    using Top_1_4_T1 by auto \n  ultimately have \"two_top_spaces0(?\\<tau>,?\\<eta>,g)\" using two_top_spaces0_def\n    by simp\n  moreover from A2 have \"?B {is a base for} ?\\<eta>\" using Top_1_4_T1\n    by simp\n  moreover have \"\\<forall>U\\<in>?B. g-``(U) \\<in> ?\\<tau>\"\n  proof\n    fix U assume \"U\\<in>?B\"\n    then obtain V W where \"V \\<in> \\<eta>\\<^sub>1\" \"W \\<in> \\<eta>\\<^sub>2\" and \"U = V\\<times>W\"\n      using ProductCollection_def by auto\n    with A3a A3b A5 have \"g-``(U) = f\\<^sub>1-``(V) \\<times> f\\<^sub>2-``(W)\"\n      using cart_prod_fun_vimage by simp\n    moreover from A1 A4 \\<open>V \\<in> \\<eta>\\<^sub>1\\<close> \\<open>W \\<in> \\<eta>\\<^sub>2\\<close> have \"f\\<^sub>1-``(V) \\<times> f\\<^sub>2-``(W) \\<in> ?\\<tau>\"\n      using IsContinuous_def prod_open_open_prod by simp \n    ultimately show \"g-``(U) \\<in> ?\\<tau>\" by simp \n  qed\n  ultimately show ?thesis using two_top_spaces0.Top_ZF_2_1_L5\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2117
    },
    "1908": {
        "type": "theorem",
        "text": "text\\<open>A reformulation of the \\<open>cart_prod_cont\\<close> lemma above in slightly different notation.\\<close>\n",
        "assumes": "assumes \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"g:\\<Union>\\<tau>\\<^sub>3\\<rightarrow>\\<Union>\\<tau>\\<^sub>4\" \n    \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"IsContinuous(\\<tau>\\<^sub>3,\\<tau>\\<^sub>4,g)\"\n    \"\\<tau>\\<^sub>4{is a topology}\" \"\\<tau>\\<^sub>3{is a topology}\"\n  ",
        "using": [
            "cart_prod_cont"
        ],
        "statement": "theorem (in two_top_spaces0) product_cont_functions:\n  assumes \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"g:\\<Union>\\<tau>\\<^sub>3\\<rightarrow>\\<Union>\\<tau>\\<^sub>4\" \n    \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"IsContinuous(\\<tau>\\<^sub>3,\\<tau>\\<^sub>4,g)\"\n    \"\\<tau>\\<^sub>4{is a topology}\" \"\\<tau>\\<^sub>3{is a topology}\"\n  shows \"IsContinuous(ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>3),ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>4),{\\<langle>\\<langle>x,y\\<rangle>,\\<langle>f`x,g`y\\<rangle>\\<rangle>. \\<langle>x,y\\<rangle>\\<in>X\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>3})\"\n",
        "proof": "proof -\n  have \"{\\<langle>\\<langle>x,y\\<rangle>,\\<langle>f`x,g`y\\<rangle>\\<rangle>. \\<langle>x,y\\<rangle>\\<in>X\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>3} = {\\<langle>p,\\<langle>f`(fst(p)),g`(snd(p))\\<rangle>\\<rangle>. p \\<in> X\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>3}\"\n    by force\n  with tau1_is_top tau2_is_top assms show ?thesis using cart_prod_cont by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2118
    },
    "1909": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>cart_prod_cont\\<close> when the function acting on the second \n  axis is the identity.\\<close>\n",
        "assumes": "assumes A1: \"\\<tau>\\<^sub>1 {is a topology}\" and A1a: \"\\<tau>\\<^sub>2 {is a topology}\" and \n  A2: \"\\<eta>\\<^sub>1 {is a topology}\"  and\n  A3: \"f\\<^sub>1:\\<Union>\\<tau>\\<^sub>1\\<rightarrow>\\<Union>\\<eta>\\<^sub>1\" and A4: \"IsContinuous(\\<tau>\\<^sub>1,\\<eta>\\<^sub>1,f\\<^sub>1)\" and\n  A5: \"g = {\\<langle>p, \\<langle>f\\<^sub>1`(fst(p)),snd(p)\\<rangle>\\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2}\"\n  ",
        "using": [
            "id_conv",
            "id_type",
            "id_cont"
        ],
        "statement": "lemma cart_prod_cont1:\n assumes A1: \"\\<tau>\\<^sub>1 {is a topology}\" and A1a: \"\\<tau>\\<^sub>2 {is a topology}\" and \n  A2: \"\\<eta>\\<^sub>1 {is a topology}\"  and\n  A3: \"f\\<^sub>1:\\<Union>\\<tau>\\<^sub>1\\<rightarrow>\\<Union>\\<eta>\\<^sub>1\" and A4: \"IsContinuous(\\<tau>\\<^sub>1,\\<eta>\\<^sub>1,f\\<^sub>1)\" and\n  A5: \"g = {\\<langle>p, \\<langle>f\\<^sub>1`(fst(p)),snd(p)\\<rangle>\\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2}\"\n  shows \"IsContinuous(ProductTopology(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2),ProductTopology(\\<eta>\\<^sub>1,\\<tau>\\<^sub>2),g)\"\n",
        "proof": "proof -\n  let ?f\\<^sub>2 = \"id(\\<Union>\\<tau>\\<^sub>2)\"\n  have \"\\<forall>x\\<in>\\<Union>\\<tau>\\<^sub>2. ?f\\<^sub>2`(x) = x\" using id_conv by blast\n  hence I: \"\\<forall>p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2. snd(p) = ?f\\<^sub>2`(snd(p))\" by simp\n  note A1 A1a A2 A1a A3\n  moreover have \"?f\\<^sub>2:\\<Union>\\<tau>\\<^sub>2\\<rightarrow>\\<Union>\\<tau>\\<^sub>2\"  using id_type by simp\n  moreover note A4\n  moreover have \"IsContinuous(\\<tau>\\<^sub>2,\\<tau>\\<^sub>2,?f\\<^sub>2)\" using id_cont by simp\n  moreover have \"g = {\\<langle>p, \\<langle>f\\<^sub>1`(fst(p)),?f\\<^sub>2`(snd(p))\\<rangle> \\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2}\"\n  proof\n    from A5 I show  \"g \\<subseteq> {\\<langle>p, \\<langle>f\\<^sub>1`(fst(p)),?f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2}\"\n      by auto\n    from A5 I show \"{\\<langle>p, \\<langle>f\\<^sub>1`(fst(p)),?f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> \\<Union>\\<tau>\\<^sub>1\\<times>\\<Union>\\<tau>\\<^sub>2} \\<subseteq> g\"\n      by auto\n  qed\n  ultimately show ?thesis by (rule cart_prod_cont)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2119
    },
    "1910": {
        "type": "lemma",
        "text": "text\\<open>Having two continuous mappings $f,g$ we can construct a third one with values\n  in the cartesian product of the codomains of $f,g$, \n  defined by $x\\mapsto \\langle f(x),g(x) \\rangle$. This is essentially the same as \n  \\<open>cont_funcs_prod\\<close> but formulated in a way that is sometimes easier to apply.\n  Recall that $\\tau_2 \\times_t \\tau_3$ is a notation for the product topology \n  of $\\tau_1$ and $\\tau_2$.  \\<close>\n",
        "assumes": "assumes \"\\<tau>\\<^sub>1 {is a topology}\" \"\\<tau>\\<^sub>2 {is a topology}\" \"\\<tau>\\<^sub>3 {is a topology}\" and\n  \"{\\<langle>x,p(x)\\<rangle>. x\\<in>\\<Union>\\<tau>\\<^sub>1} \\<in> Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\" \"{\\<langle>x,q(x)\\<rangle>. x\\<in>\\<Union>\\<tau>\\<^sub>1} \\<in> Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>3)\"\n  ",
        "using": [
            "prod_fun_val(1)",
            "Top_1_4_T1(3)",
            "Top_1_4_T1(1)",
            "two_top_spaces0_def",
            "Top_1_4_T1(2)",
            "ZF_fun_from_tot_val1",
            "vimage_prod(3)",
            "Cont_def",
            "IsContinuous_def",
            "IsATopology_def"
        ],
        "statement": "lemma cont_funcs_prod1: \n  assumes \"\\<tau>\\<^sub>1 {is a topology}\" \"\\<tau>\\<^sub>2 {is a topology}\" \"\\<tau>\\<^sub>3 {is a topology}\" and\n  \"{\\<langle>x,p(x)\\<rangle>. x\\<in>\\<Union>\\<tau>\\<^sub>1} \\<in> Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\" \"{\\<langle>x,q(x)\\<rangle>. x\\<in>\\<Union>\\<tau>\\<^sub>1} \\<in> Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>3)\"\n  shows \"{\\<langle>x,\\<langle>p(x),q(x)\\<rangle>\\<rangle>. x\\<in>\\<Union>\\<tau>\\<^sub>1} \\<in> Cont(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2\\<times>\\<^sub>t\\<tau>\\<^sub>3)\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>\\<tau>\\<^sub>1\"\n  let ?Y = \"\\<Union>\\<tau>\\<^sub>2\"\n  let ?Z = \"\\<Union>\\<tau>\\<^sub>3\"\n  let ?f = \"{\\<langle>x,p(x)\\<rangle>. x\\<in>?X}\"\n  let ?g = \"{\\<langle>x,q(x)\\<rangle>. x\\<in>?X}\"\n  let ?h = \"{\\<langle>x,\\<langle>p(x),q(x)\\<rangle>\\<rangle>. x\\<in>?X}\"\n  from assms(4,5) have \"?f:?X\\<rightarrow>?Y\" and \"?g:?X\\<rightarrow>?Z\" unfolding Cont_def \n    by auto\n  with assms(2,3) have hFun: \"?h:?X\\<rightarrow>\\<Union>(\\<tau>\\<^sub>2\\<times>\\<^sub>t\\<tau>\\<^sub>3)\"\n    using prod_fun_val(1) using Top_1_4_T1(3) by simp\n  moreover have \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2\\<times>\\<^sub>t\\<tau>\\<^sub>3,?h)\"\n  proof -\n    let ?B = \"ProductCollection(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3)\"\n    from assms(1,2,3) hFun have \"two_top_spaces0(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2\\<times>\\<^sub>t\\<tau>\\<^sub>3,?h)\"\n      using Top_1_4_T1(1) unfolding two_top_spaces0_def by simp\n    moreover from assms(2,3) have \"?B {is a base for} (\\<tau>\\<^sub>2\\<times>\\<^sub>t\\<tau>\\<^sub>3)\"\n      using Top_1_4_T1(2) by simp\n    moreover have \"\\<forall>W\\<in>?B. ?h-``(W) \\<in> \\<tau>\\<^sub>1\"\n    proof -\n      { fix W assume \"W\\<in>?B\"\n        then obtain U V where \"U\\<in>\\<tau>\\<^sub>2\" \"V\\<in>\\<tau>\\<^sub>3\" \"W=U\\<times>V\"\n          unfolding ProductCollection_def by auto\n        have \"\\<forall>x\\<in>?X. \\<langle>p(x),q(x)\\<rangle> = \\<langle>?f`(x),?g`(x)\\<rangle>\" \n        proof -\n          { fix x assume \"x\\<in>?X\"\n            then have \"\\<langle>p(x),q(x)\\<rangle> = \\<langle>?f`(x),?g`(x)\\<rangle>\" \n              using ZF_fun_from_tot_val1 by simp\n          } thus ?thesis by auto\n        qed\n        then have \"?h = {\\<langle>x,\\<langle>?f`(x),?g`(x)\\<rangle>\\<rangle>. x\\<in>?X}\" by (rule set_comp_eq)\n        with assms(1,4,5) \\<open>?f:?X\\<rightarrow>?Y\\<close> \\<open>?g:?X\\<rightarrow>?Z\\<close> \\<open>U\\<in>\\<tau>\\<^sub>2\\<close> \\<open>V\\<in>\\<tau>\\<^sub>3\\<close> \\<open>W=U\\<times>V\\<close>\n        have \"?h-``(W) \\<in> \\<tau>\\<^sub>1\" using vimage_prod(3) \n          unfolding Cont_def IsContinuous_def IsATopology_def by auto       \n      } thus ?thesis by simp\n    qed\n    ultimately show ?thesis by (rule two_top_spaces0.Top_ZF_2_1_L5) \n  qed\n  ultimately show ?thesis unfolding Cont_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2121
    },
    "1911": {
        "type": "lemma",
        "text": "text\\<open>Two continuous functions into a Hausdorff space are equal on a closed set.\n  Note that in the lemma below $f$ is assumed to map $X_1$ to $X_2$ in the locale, we only\n  need to add a similar assumption for the second function. \\<close>\n",
        "assumes": "assumes \"g:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"f {is continuous}\" \"g {is continuous}\"  \"\\<tau>\\<^sub>2 {is T\\<^sub>2}\"\n  ",
        "using": [
            "Top_1_4_T1(1)",
            "vimage_prod(1)",
            "Top_1_4_T1(3)",
            "prod_top_spaces0.cont_funcs_prod",
            "t2_iff_diag_closed",
            "two_top_spaces0.TopZF_2_1_L1",
            "vimage_prod(4)"
        ],
        "statement": "lemma (in two_top_spaces0) two_fun_eq_closed:\n  assumes \"g:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"f {is continuous}\" \"g {is continuous}\"  \"\\<tau>\\<^sub>2 {is T\\<^sub>2}\"\n  shows \"{x\\<in>X\\<^sub>1. f`(x)=g`(x)} {is closed in} \\<tau>\\<^sub>1\"\n",
        "proof": "proof -\n  let ?D = \"{x\\<in>X\\<^sub>1. f`(x)=g`(x)}\"\n  let ?h = \"{\\<langle>x,\\<langle>f`(x),g`(x)\\<rangle>\\<rangle>. x\\<in>X\\<^sub>1}\"\n  have \"?h-``({\\<langle>y,y\\<rangle>. y\\<in>X\\<^sub>2}) {is closed in} \\<tau>\\<^sub>1\"\n    proof -\n      have \"two_top_spaces0(\\<tau>\\<^sub>1,ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>2),?h)\"\n      proof\n        from tau1_is_top tau2_is_top\n        show \"\\<tau>\\<^sub>1 {is a topology}\" and \"ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>2) {is a topology}\"\n          using Top_1_4_T1(1) by auto\n        from tau1_is_top tau2_is_top fmapAssum assms(1)\n        show \"?h : \\<Union>\\<tau>\\<^sub>1 \\<rightarrow> \\<Union>ProductTopology(\\<tau>\\<^sub>2, \\<tau>\\<^sub>2)\"\n          using vimage_prod(1) Top_1_4_T1(3) by simp\n      qed\n      moreover \n      have \"IsContinuous(\\<tau>\\<^sub>1,ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>2),?h)\"\n      proof -\n        from tau1_is_top tau2_is_top have \"prod_top_spaces0(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,\\<tau>\\<^sub>2)\"\n          unfolding prod_top_spaces0_def by simp\n        with fmapAssum assms(1,2,3) show ?thesis\n          using prod_top_spaces0.cont_funcs_prod by simp \n      qed\n      moreover \n      from tau2_is_top assms(4) \n        have \"{\\<langle>y,y\\<rangle>. y\\<in>X\\<^sub>2} {is closed in} ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>2)\"\n          using t2_iff_diag_closed by simp \n      ultimately show ?thesis using two_top_spaces0.TopZF_2_1_L1 \n        by simp\n    qed \n  with fmapAssum assms(1) show ?thesis using vimage_prod(4)\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2122
    },
    "1912": {
        "type": "lemma",
        "text": "text\\<open>Closure of an image of a singleton by a relation in $X\\times Y$ is contained in the \n  image of this singleton by the closure of the relation (in the product topology).\n  Compare the proof of Metamath's theorem with the same name.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\"  \"S {is a topology}\" \"R \\<subseteq> (\\<Union>T)\\<times>(\\<Union>S)\" \"x\\<in>\\<Union>T\"\n  ",
        "using": [
            "const_cont_sp",
            "id_cont_sp",
            "cont_funcs_prod1",
            "Top_1_4_T1(1,3)",
            "two_top_spaces0.im_cl_in_cl_im",
            "Top_1_4_T1(3)"
        ],
        "statement": "lemma imasncls: \n  assumes \"T {is a topology}\"  \"S {is a topology}\" \"R \\<subseteq> (\\<Union>T)\\<times>(\\<Union>S)\" \"x\\<in>\\<Union>T\"\n  shows \"Closure(R``{x},S) \\<subseteq> Closure(R,T\\<times>\\<^sub>tS)``{x}\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  let ?Y = \"\\<Union>S\"\n  let ?f = \"{\\<langle>y,\\<langle>x,y\\<rangle>\\<rangle>. y\\<in>?Y}\"\n  from assms(3) have \"R``{x} = ?f-``(R)\" by blast\n  hence \"Closure(R``{x},S) = Closure(?f-``(R),S)\" by simp\n  also have \"Closure(?f-``(R),S) \\<subseteq> ?f-``(Closure(R,T\\<times>\\<^sub>tS))\"\n  proof -\n    from assms(1,2,4) have \"?f \\<in> Cont(S,T\\<times>\\<^sub>tS)\"\n      using const_cont_sp id_cont_sp cont_funcs_prod1 by simp\n    with assms(1,2,3) have \n      \"two_top_spaces0(S,T\\<times>\\<^sub>tS,?f)\" \"IsContinuous(S,T\\<times>\\<^sub>tS,?f)\" \"R \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\"\n      unfolding Cont_def two_top_spaces0_def using Top_1_4_T1(1,3)\n      by auto\n    then show \"Closure(?f-``(R),S) \\<subseteq> ?f-``(Closure(R,T\\<times>\\<^sub>tS))\"\n      using two_top_spaces0.im_cl_in_cl_im by simp\n  qed\n  also \n  have \"Closure(R,T\\<times>\\<^sub>tS) \\<subseteq> ?X\\<times>?Y\"\n  proof -\n    from assms(1,2,3) have \"topology0(T\\<times>\\<^sub>tS)\" \"R \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\" \n      unfolding topology0_def using Top_1_4_T1(1,3) by auto\n    then have \"Closure(R,T\\<times>\\<^sub>tS) \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\" by (rule topology0.Top_3_L11)\n    with assms(1,2) show ?thesis using Top_1_4_T1(3) by simp\n  qed\n  with assms(4) have \"?f-``(Closure(R,T\\<times>\\<^sub>tS)) = Closure(R,T\\<times>\\<^sub>tS)``{x}\" by blast\n  finally show \"Closure(R``{x},S) \\<subseteq> Closure(R,T\\<times>\\<^sub>tS)``{x}\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2123
    },
    "1913": {
        "type": "lemma",
        "text": "text\\<open>A typical statement of the pasting lemma uses the notion of a function \nrestricted to a set being continuous without specifying the topologies with \nrespect to which this continuity holds.\nIn \\<open>two_top_spaces0\\<close> context the notation \\<open>g {is continuous}\\<close>\nmeans continuity wth respect to topologies $\\tau_1, \\tau_2$.\nThe next lemma is a special case of \\<open>partial_fun_cont\\<close> and states that if\nfor some set $A\\subseteq X_1=\\bigcup \\tau_1$\nthe function $f|_A$ is continuous (with respect to $(\\tau_1, \\tau_2)$), then \n$A$ has to be open. This clears up terminology and indicates why we need\nto pay attention to the issue of which topologies we talk about when we say\nthat the restricted (to some closed set for example) function is continuos.\n\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> X\\<^sub>1\" and A2: \"restrict(f,A) {is continuous}\"\n  ",
        "using": [
            "tau1_is_top",
            "tau2_is_top",
            "two_top_spaces1_def",
            "fmapAssum",
            "restrict_fun",
            "two_top_spaces1.partial_fun_cont"
        ],
        "statement": "lemma (in two_top_spaces0) restriction_continuous1:\n  assumes A1: \"A \\<subseteq> X\\<^sub>1\" and A2: \"restrict(f,A) {is continuous}\"\n  shows \"A \\<in> \\<tau>\\<^sub>1\"\n",
        "proof": "proof -\n  from assms have \"two_top_spaces1(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2)\" and\n    \"restrict(f,A):A\\<rightarrow>X\\<^sub>2\" and \"restrict(f,A) {is continuous}\"\n    using tau1_is_top tau2_is_top two_top_spaces1_def fmapAssum restrict_fun\n      by auto\n  then show ?thesis using two_top_spaces1.partial_fun_cont by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2124
    },
    "1914": {
        "type": "lemma",
        "text": "text\\<open>If a fuction is continuous on each set of a collection of open sets, then\n  it is continuous on the union of them. We could use continuity with respect to\n  the relative topology here, but we know that on open sets this is the same as the\n  original topology.\\<close>\n",
        "assumes": "assumes A1: \"M \\<subseteq> \\<tau>\\<^sub>1\" and A2: \"\\<forall>U\\<in>M. restrict(f,U)  {is continuous}\"\n  ",
        "using": [
            "func1_2_L1",
            "fmapAssum",
            "IsContinuous_def",
            "tau1_is_top",
            "IsATopology_def"
        ],
        "statement": "lemma (in two_top_spaces0) pasting_lemma1:\n  assumes A1: \"M \\<subseteq> \\<tau>\\<^sub>1\" and A2: \"\\<forall>U\\<in>M. restrict(f,U)  {is continuous}\"\n  shows \"restrict(f,\\<Union>M) {is continuous}\"\n",
        "proof": "proof -\n  { fix V assume \"V\\<in>\\<tau>\\<^sub>2\"\n    from A1 have \"\\<Union>M \\<subseteq> X\\<^sub>1\" by auto\n    then have \"restrict(f,\\<Union>M)-``(V) = f-``(V) \\<inter> (\\<Union>M)\"\n      using func1_2_L1 fmapAssum by simp\n    also have \"\\<dots> = \\<Union> {f-``(V) \\<inter> U. U\\<in>M}\" by auto\n    finally have \"restrict(f,\\<Union>M)-``(V) = \\<Union> {f-``(V) \\<inter> U. U\\<in>M}\" by simp\n    moreover\n    have \"{f-``(V) \\<inter> U. U\\<in>M} \\<in> Pow(\\<tau>\\<^sub>1)\"\n    proof -\n      { fix W assume \"W \\<in> {f-``(V) \\<inter> U. U\\<in>M}\"\n        then obtain U where \"U\\<in>M\" and I: \"W = f-``(V) \\<inter> U\" by auto\n        with A2 have \"restrict(f,U) {is continuous}\" by simp\n        with \\<open>V\\<in>\\<tau>\\<^sub>2\\<close> have \"restrict(f,U)-``(V) \\<in> \\<tau>\\<^sub>1\"\n          using IsContinuous_def by simp\n        moreover from \\<open>\\<Union>M \\<subseteq> X\\<^sub>1\\<close> and \\<open>U\\<in>M\\<close> \n        have \"restrict(f,U)-``(V) = f-``(V) \\<inter> U\"\n          using fmapAssum func1_2_L1 by blast\n        ultimately have \"f-``(V) \\<inter> U \\<in> \\<tau>\\<^sub>1\" by simp\n        with I have \"W \\<in> \\<tau>\\<^sub>1\" by simp\n      } then show ?thesis by auto\n    qed\n    then have  \"\\<Union>{f-``(V) \\<inter> U. U\\<in>M} \\<in> \\<tau>\\<^sub>1\"\n       using tau1_is_top IsATopology_def by auto\n    ultimately have \"restrict(f,\\<Union>M)-``(V) \\<in> \\<tau>\\<^sub>1\"\n      by simp\n  } then show ?thesis using IsContinuous_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2125
    },
    "1915": {
        "type": "lemma",
        "text": "text\\<open>If a function is continuous on two sets, then it is continuous\n  on intersection.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> X\\<^sub>1\" \"B \\<subseteq> X\\<^sub>1\" and\n  A2: \"restrict(f,A)  {is continuous}\"  \"restrict(f,B)  {is continuous}\"\n  ",
        "using": [
            "func1_2_L1",
            "fmapAssum",
            "IsContinuous_def",
            "tau1_is_top",
            "IsATopology_def"
        ],
        "statement": "lemma (in two_top_spaces0) cont_inter_cont:\n  assumes A1: \"A \\<subseteq> X\\<^sub>1\" \"B \\<subseteq> X\\<^sub>1\" and\n  A2: \"restrict(f,A)  {is continuous}\"  \"restrict(f,B)  {is continuous}\"\n  shows \"restrict(f,A\\<inter>B)  {is continuous}\"\n",
        "proof": "proof -\n  { fix V assume \"V\\<in>\\<tau>\\<^sub>2\"\n    with assms have\n      \"restrict(f,A)-``(V) = f-``(V) \\<inter> A\"  \"restrict(f,B)-``(V) = f-``(V) \\<inter> B\" and\n      \"restrict(f,A)-``(V) \\<in> \\<tau>\\<^sub>1\" and \"restrict(f,B)-``(V) \\<in> \\<tau>\\<^sub>1\"\n        using func1_2_L1 fmapAssum IsContinuous_def by auto\n    then have \"(restrict(f,A)-``(V)) \\<inter> (restrict(f,B)-``(V)) = f-``(V) \\<inter> (A\\<inter>B)\"\n      by auto\n    moreover \n    from A2 \\<open>V\\<in>\\<tau>\\<^sub>2\\<close> have \n      \"restrict(f,A)-``(V) \\<in> \\<tau>\\<^sub>1\" and \"restrict(f,B)-``(V) \\<in> \\<tau>\\<^sub>1\"\n      using IsContinuous_def by auto\n    then have \"(restrict(f,A)-``(V)) \\<inter> (restrict(f,B)-``(V)) \\<in> \\<tau>\\<^sub>1\"\n      using tau1_is_top IsATopology_def by simp\n    moreover \n    from A1 have \"(A\\<inter>B) \\<subseteq> X\\<^sub>1\" by auto\n    then have \"restrict(f,A\\<inter>B)-``(V) = f-``(V) \\<inter> (A\\<inter>B)\"\n      using func1_2_L1 fmapAssum by simp\n  ultimately have \"restrict(f,A\\<inter>B)-``(V) \\<in> \\<tau>\\<^sub>1\" by simp\n  } then show ?thesis using  IsContinuous_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2126
    },
    "1916": {
        "type": "corollary",
        "text": "text\\<open>0 is continuous.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "corollary (in two_top_spaces0) zero_continuous: shows \"0 {is continuous}\"\n",
        "proof": "proof -\n  let ?T = \"{U \\<in> \\<tau>\\<^sub>1. restrict(f,U) {is continuous}}\"\n  have \"?T {is a topology}\" by (rule pasting_theorem)\n  then have \"0\\<in>?T\" by (rule empty_open)\n  hence \"restrict(f,0) {is continuous}\" by simp\n  moreover have \"restrict(f,0) = 0\" by simp\n  ultimately show ?thesis by simp\nqed    \n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2128
    },
    "1917": {
        "type": "definition",
        "text": "text\\<open>Suppose $\\mathcal{X} = I\\rightarrow \\bigcup T$ is a space of functions from some index set $I$\nto the carrier of a topology $T$. Then take a finite collection of open sets $W:N\\rightarrow T$ \nindexed by $N\\subseteq I$. We can define a subset of $\\mathcal{X}$ that models the cartesian product of $W$.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"FinProd(\\<X>,W) \\<equiv> {x\\<in>\\<X>. \\<forall> i\\<in>domain(W). x`(i) \\<in> W`(i)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2129
    },
    "1918": {
        "type": "definition",
        "text": "text\\<open>Now we define the base of the product topology as the collection of all finite products \n(in the sense defined above) of open sets. \n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ProductTopBase(I,T) \\<equiv>  \\<Union>N\\<in>FinPow(I).{FinProd(I\\<rightarrow>\\<Union>T,W). W\\<in>N\\<rightarrow>T}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2130
    },
    "1919": {
        "type": "definition",
        "text": "text\\<open>Finally, we define the product topology on sequences. We use the ''Seq'' \nprefix although the definition is good for any index sets, not only natural numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SeqProductTopology(I,T) \\<equiv> {\\<Union>B. B \\<in> Pow(ProductTopBase(I,T))}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2131
    },
    "1920": {
        "type": "lemma",
        "text": "text\\<open>Product topology base is closed with respect to intersections.\\<close>\n",
        "assumes": "assumes A1: \"T {is a topology}\" and  \n  A2: \"U \\<in> ProductTopBase(I,T)\"  \"V \\<in> ProductTopBase(I,T)\"\n  ",
        "using": [
            "ProductTopBase_def",
            "apply_funtype",
            "IsATopology_def",
            "union_finpow",
            "func1_1_L1",
            "FinProd_def",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma prod_top_base_inter: \n  assumes A1: \"T {is a topology}\" and  \n  A2: \"U \\<in> ProductTopBase(I,T)\"  \"V \\<in> ProductTopBase(I,T)\"\n  shows \"U\\<inter>V \\<in> ProductTopBase(I,T)\"\n",
        "proof": "proof -\n  let ?\\<X> = \"I\\<rightarrow>\\<Union>T\"  \n  from A2 obtain N\\<^sub>1  W\\<^sub>1 N\\<^sub>2 W\\<^sub>2 where \n    I: \"N\\<^sub>1 \\<in> FinPow(I)\"  \"W\\<^sub>1\\<in>N\\<^sub>1\\<rightarrow>T\"  \"U = FinProd(?\\<X>,W\\<^sub>1)\" and\n    II: \"N\\<^sub>2 \\<in> FinPow(I)\"  \"W\\<^sub>2\\<in>N\\<^sub>2\\<rightarrow>T\"  \"V = FinProd(?\\<X>,W\\<^sub>2)\"\n    using ProductTopBase_def by auto\n  let ?N\\<^sub>3 = \"N\\<^sub>1 \\<union> N\\<^sub>2\"\n  let ?W\\<^sub>3 = \"{\\<langle>i,if i \\<in> N\\<^sub>1-N\\<^sub>2 then W\\<^sub>1`(i) \n        else if i \\<in> N\\<^sub>2-N\\<^sub>1 then  W\\<^sub>2`(i) \n        else (W\\<^sub>1`(i)) \\<inter> (W\\<^sub>2`(i))\\<rangle>. i \\<in> ?N\\<^sub>3}\"\n  from A1 I II have \"\\<forall>i \\<in> N\\<^sub>1 \\<inter> N\\<^sub>2.  (W\\<^sub>1`(i) \\<inter> W\\<^sub>2`(i)) \\<in> T\"\n      using apply_funtype IsATopology_def by auto\n  moreover from I II have \"\\<forall>i\\<in>N\\<^sub>1-N\\<^sub>2. W\\<^sub>1`(i) \\<in> T\" and \"\\<forall>i\\<in>N\\<^sub>2-N\\<^sub>1. W\\<^sub>2`(i) \\<in> T\" \n      using apply_funtype by auto\n  ultimately have  \"?W\\<^sub>3:?N\\<^sub>3\\<rightarrow>T\" by (rule fun_union_overlap)\n  with I II have \"FinProd(?\\<X>,?W\\<^sub>3) \\<in> ProductTopBase(I,T)\" using union_finpow ProductTopBase_def\n    by auto\n  moreover have \"U\\<inter>V = FinProd(?\\<X>,?W\\<^sub>3)\"\n  proof\n    { fix x assume \"x\\<in>U\" and \"x\\<in>V\"\n      with \\<open>U = FinProd(?\\<X>,W\\<^sub>1)\\<close>  \\<open>W\\<^sub>1\\<in>N\\<^sub>1\\<rightarrow>T\\<close> and  \\<open>V = FinProd(?\\<X>,W\\<^sub>2)\\<close>  \\<open>W\\<^sub>2\\<in>N\\<^sub>2\\<rightarrow>T\\<close>\n      have \"x\\<in>?\\<X>\" and \"\\<forall>i\\<in>N\\<^sub>1. x`(i) \\<in> W\\<^sub>1`(i)\" and \"\\<forall>i\\<in>N\\<^sub>2. x`(i) \\<in> W\\<^sub>2`(i)\"\n        using func1_1_L1 FinProd_def by auto\n      with \\<open>?W\\<^sub>3:?N\\<^sub>3\\<rightarrow>T\\<close> \\<open>x\\<in>?\\<X>\\<close> have \"x \\<in> FinProd(?\\<X>,?W\\<^sub>3)\"  \n        using ZF_fun_from_tot_val func1_1_L1 FinProd_def by auto\n    } thus \"U\\<inter>V \\<subseteq> FinProd(?\\<X>,?W\\<^sub>3)\" by auto\n    { fix x assume \"x \\<in> FinProd(?\\<X>,?W\\<^sub>3)\"\n      with \\<open>?W\\<^sub>3:?N\\<^sub>3\\<rightarrow>T\\<close> have \"x:I\\<rightarrow>\\<Union>T\" and III: \"\\<forall>i\\<in>?N\\<^sub>3. x`(i) \\<in> ?W\\<^sub>3`(i)\"\n        using FinProd_def func1_1_L1 by auto\n     { fix i assume \"i\\<in>N\\<^sub>1\" \n       with \\<open>?W\\<^sub>3:?N\\<^sub>3\\<rightarrow>T\\<close> have \"?W\\<^sub>3`(i) \\<subseteq> W\\<^sub>1`(i)\" using ZF_fun_from_tot_val by auto\n       with III \\<open>i\\<in>N\\<^sub>1\\<close> have \"x`(i) \\<in> W\\<^sub>1`(i)\" by auto\n     } with \\<open>W\\<^sub>1\\<in>N\\<^sub>1\\<rightarrow>T\\<close> \\<open>x:I\\<rightarrow>\\<Union>T\\<close> \\<open>U = FinProd(?\\<X>,W\\<^sub>1)\\<close> \n      have \"x \\<in> U\" using func1_1_L1 FinProd_def by auto\n      moreover\n      { fix i assume \"i\\<in>N\\<^sub>2\" \n        with \\<open>?W\\<^sub>3:?N\\<^sub>3\\<rightarrow>T\\<close> have \"?W\\<^sub>3`(i) \\<subseteq> W\\<^sub>2`(i)\" using ZF_fun_from_tot_val by auto\n        with III \\<open>i\\<in>N\\<^sub>2\\<close> have \"x`(i) \\<in> W\\<^sub>2`(i)\" by auto\n      } with \\<open>W\\<^sub>2\\<in>N\\<^sub>2\\<rightarrow>T\\<close> \\<open>x:I\\<rightarrow>\\<Union>T\\<close> \\<open>V = FinProd(?\\<X>,W\\<^sub>2)\\<close> have \"x\\<in>V\" \n          using func1_1_L1 FinProd_def by auto \n      ultimately have \"x \\<in> U\\<inter>V\" by simp\n    } thus \"FinProd(?\\<X>,?W\\<^sub>3) \\<subseteq> U\\<inter>V\" by auto\n  qed\n    ultimately show ?thesis by simp\nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2132
    },
    "1921": {
        "type": "theorem",
        "text": "text\\<open>In the next theorem we show the collection of sets defined above as \n\\<open>ProductTopBase(\\<X>,T)\\<close> satisfies the base condition. This is a condition, defined in \n\\<open>Topology_ZF_1\\<close> that allows to claim that this collection is a base for some topology.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \n  ",
        "using": [
            "assms",
            "prod_top_base_inter",
            "inter_closed_base"
        ],
        "statement": "theorem prod_top_base_is_base: assumes \"T {is a topology}\" \n  shows \"ProductTopBase(I,T) {satisfies the base condition}\"\n  ",
        "proof": "using assms prod_top_base_inter inter_closed_base by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2133
    },
    "1922": {
        "type": "theorem",
        "text": "text\\<open>The (sequence) product topology is indeed a topology on the space of sequences.\nIn the proof we are using the fact that $(\\emptyset\\rightarrow X) = \\{\\emptyset\\}$.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\"\n  ",
        "using": [
            "prod_top_base_is_base",
            "SeqProductTopology_def",
            "Top_1_2_T1",
            "Top_1_2_L5",
            "ProductTopBase_def",
            "FinProd_def",
            "empty_in_finpow"
        ],
        "statement": "theorem seq_prod_top_is_top:  assumes \"T {is a topology}\"\n  shows \n  \"SeqProductTopology(I,T) {is a topology}\" and \n  \"ProductTopBase(I,T) {is a base for} SeqProductTopology(I,T)\" and\n  \"\\<Union>SeqProductTopology(I,T) = (I\\<rightarrow>\\<Union>T)\"\n",
        "proof": "proof -\n  from assms show \"SeqProductTopology(I,T) {is a topology}\" and \n    I: \"ProductTopBase(I,T) {is a base for} SeqProductTopology(I,T)\"\n      using prod_top_base_is_base SeqProductTopology_def Top_1_2_T1\n        by auto\n  from I have \"\\<Union>SeqProductTopology(I,T) = \\<Union>ProductTopBase(I,T)\"\n    using Top_1_2_L5 by simp\n  also have \"\\<Union>ProductTopBase(I,T) = (I\\<rightarrow>\\<Union>T)\"\n  proof\n    show \"\\<Union>ProductTopBase(I,T) \\<subseteq> (I\\<rightarrow>\\<Union>T)\" using ProductTopBase_def FinProd_def\n      by auto\n    have \"0 \\<in> FinPow(I)\" using empty_in_finpow by simp\n    hence \"{FinProd(I\\<rightarrow>\\<Union>T,W). W\\<in>0\\<rightarrow>T} \\<subseteq> (\\<Union>N\\<in>FinPow(I).{FinProd(I\\<rightarrow>\\<Union>T,W). W\\<in>N\\<rightarrow>T})\"\n      by blast\n    then show \"(I\\<rightarrow>\\<Union>T) \\<subseteq> \\<Union>ProductTopBase(I,T)\" using ProductTopBase_def FinProd_def\n      by auto\n  qed     \n  finally show \"\\<Union>SeqProductTopology(I,T) = (I\\<rightarrow>\\<Union>T)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2134
    },
    "1923": {
        "type": "lemma",
        "text": "text\\<open>When the index set is finite, the definition of \\<open>ProductTopBase(I,T)\\<close> \ncan be simplifed.\\<close>\n",
        "assumes": "assumes A1: \"n\\<in>nat\" and A2: \"T {is a topology}\"  \n  ",
        "using": [
            "nat_finpow_nat",
            "fin_finpow_self",
            "ProductTopBase_def",
            "apply_funtype",
            "FinPow_def",
            "IsATopology_def",
            "FinProd_def",
            "func1_1_L1",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma fin_prod_def_nat: assumes A1: \"n\\<in>nat\" and A2: \"T {is a topology}\"  \n  shows \"ProductTopBase(n,T) = {FinProd(n\\<rightarrow>\\<Union>T,W). W\\<in>n\\<rightarrow>T}\"\n",
        "proof": "proof\n  from A1 have \"n \\<in> FinPow(n)\" using nat_finpow_nat fin_finpow_self by auto\n  then show \"{FinProd(n\\<rightarrow>\\<Union>T,W). W\\<in>n\\<rightarrow>T} \\<subseteq> ProductTopBase(n,T)\" using ProductTopBase_def\n    by auto\n  { fix B assume \"B \\<in> ProductTopBase(n,T)\"\n    then obtain N W where  \"N \\<in> FinPow(n)\" and \"W \\<in> N\\<rightarrow>T\" and \"B = FinProd(n\\<rightarrow>\\<Union>T,W)\"\n      using ProductTopBase_def by auto\n    let ?W\\<^sub>n = \"{\\<langle>i,if i\\<in>N then W`(i) else \\<Union>T\\<rangle>. i\\<in>n}\"\n    from A2  \\<open>N \\<in> FinPow(n)\\<close>  \\<open>W\\<in>N\\<rightarrow>T\\<close> have \"\\<forall>i\\<in>n. (if i\\<in>N then W`(i) else \\<Union>T) \\<in> T\"\n      using apply_funtype FinPow_def IsATopology_def by auto\n    then have \"?W\\<^sub>n:n\\<rightarrow>T\" by (rule ZF_fun_from_total)\n    moreover have \"B = FinProd(n\\<rightarrow>\\<Union>T,?W\\<^sub>n)\"\n    proof\n      { fix x assume \"x\\<in>B\"\n        with \\<open>B = FinProd(n\\<rightarrow>\\<Union>T,W)\\<close> have \"x \\<in> n\\<rightarrow>\\<Union>T\" using FinProd_def by simp\n        moreover have \"\\<forall>i\\<in>domain(?W\\<^sub>n). x`(i) \\<in> ?W\\<^sub>n`(i)\"\n        proof\n          fix i assume \"i \\<in> domain(?W\\<^sub>n)\"\n          with \\<open>?W\\<^sub>n:n\\<rightarrow>T\\<close> have \"i\\<in>n\" using func1_1_L1 by simp \n          with \\<open>x:n\\<rightarrow>\\<Union>T\\<close> have \"x`(i) \\<in> \\<Union>T\" using apply_funtype by blast\n          with \\<open>x\\<in>B\\<close> \\<open>B = FinProd(n\\<rightarrow>\\<Union>T,W)\\<close> \\<open>W \\<in> N\\<rightarrow>T\\<close> \\<open>?W\\<^sub>n:n\\<rightarrow>T\\<close> \\<open>i\\<in>n\\<close>\n          show \"x`(i) \\<in> ?W\\<^sub>n`(i)\" using func1_1_L1 FinProd_def ZF_fun_from_tot_val \n            by simp\n        qed\n        ultimately have \"x \\<in> FinProd(n\\<rightarrow>\\<Union>T,?W\\<^sub>n)\" using FinProd_def by simp\n      } thus \"B \\<subseteq> FinProd(n\\<rightarrow>\\<Union>T,?W\\<^sub>n)\" by auto\n      next\n      { fix x assume \"x \\<in> FinProd(n\\<rightarrow>\\<Union>T,?W\\<^sub>n)\"    \n        then have \"x \\<in> n\\<rightarrow>\\<Union>T\" and \"\\<forall>i\\<in>domain(?W\\<^sub>n). x`(i) \\<in> ?W\\<^sub>n`(i)\" \n          using  FinProd_def by auto\n        with \\<open>?W\\<^sub>n:n\\<rightarrow>T\\<close> and \\<open>N \\<in> FinPow(n)\\<close> have \"\\<forall>i\\<in>N. x`(i) \\<in> ?W\\<^sub>n`(i)\"\n          using func1_1_L1 FinPow_def by auto\n        moreover from \\<open>?W\\<^sub>n:n\\<rightarrow>T\\<close> and \\<open>N \\<in> FinPow(n)\\<close> \n        have \"\\<forall>i\\<in>N. ?W\\<^sub>n`(i) = W`(i)\"\n          using ZF_fun_from_tot_val FinPow_def by auto\n        ultimately have \"\\<forall>i\\<in>N. x`(i) \\<in> W`(i)\" by simp\n        with \\<open>W \\<in> N\\<rightarrow>T\\<close> \\<open>x \\<in> n\\<rightarrow>\\<Union>T\\<close> \\<open>B = FinProd(n\\<rightarrow>\\<Union>T,W)\\<close> have \"x\\<in>B\"\n          using func1_1_L1 FinProd_def by simp\n     } thus \"FinProd(n\\<rightarrow>\\<Union>T,?W\\<^sub>n) \\<subseteq> B\" by auto\n  qed \n    ultimately have \"B \\<in> {FinProd(n\\<rightarrow>\\<Union>T,W). W\\<in>n\\<rightarrow>T}\" by auto\n  } thus \"ProductTopBase(n,T) \\<subseteq> {FinProd(n\\<rightarrow>\\<Union>T,W). W\\<in>n\\<rightarrow>T}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2135
    },
    "1924": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma providing a formula for finite product on one topological space.\\<close>\n",
        "assumes": "assumes A1: \"W:1\\<rightarrow>\\<tau>\" \n  ",
        "using": [
            "func1_1_L1",
            "FinProd_def",
            "func_singleton_pair",
            "apply_funtype",
            "pair_func_singleton",
            "pair_val"
        ],
        "statement": "lemma single_top_prod: assumes A1: \"W:1\\<rightarrow>\\<tau>\" \n  shows \"FinProd(1\\<rightarrow>\\<Union>\\<tau>,W) = { {\\<langle>0,y\\<rangle>}. y \\<in> W`(0)}\"\n",
        "proof": "proof -\n  have \"1 = {0}\" by auto\n  from A1 have \"domain(W) = {0}\" using func1_1_L1 by auto\n  then have \"FinProd(1\\<rightarrow>\\<Union>\\<tau>,W) = {x \\<in> 1\\<rightarrow>\\<Union>\\<tau>. x`(0) \\<in> W`(0)}\"\n    using FinProd_def by simp\n  also have \"{x \\<in> 1\\<rightarrow>\\<Union>\\<tau>. x`(0) \\<in> W`(0)} = { {\\<langle>0,y\\<rangle>}. y \\<in> W`(0)}\"\n  proof\n    from \\<open>1 = {0}\\<close> show \"{x \\<in> 1\\<rightarrow>\\<Union>\\<tau>. x`(0) \\<in> W`(0)} \\<subseteq> { {\\<langle>0,y\\<rangle>}. y \\<in> W`(0)}\"\n      using func_singleton_pair by auto \n    { fix x assume \"x \\<in> { {\\<langle>0,y\\<rangle>}. y \\<in> W`(0)}\"\n      then obtain y where \"x = {\\<langle>0,y\\<rangle>}\" and II: \"y \\<in> W`(0)\" by auto\n      with A1 have \"y \\<in> \\<Union>\\<tau>\" using apply_funtype by auto\n      with \\<open>x = {\\<langle>0,y\\<rangle>}\\<close>  \\<open>1 = {0}\\<close> have \"x:1\\<rightarrow>\\<Union>\\<tau>\" using pair_func_singleton\n        by auto\n      with \\<open>x = {\\<langle>0,y\\<rangle>}\\<close> II have \"x \\<in> {x \\<in> 1\\<rightarrow>\\<Union>\\<tau>. x`(0) \\<in> W`(0)}\"\n        using pair_val by simp\n    } thus \"{ {\\<langle>0,y\\<rangle>}. y \\<in> W`(0)} \\<subseteq> {x \\<in> 1\\<rightarrow>\\<Union>\\<tau>. x`(0) \\<in> W`(0)}\" by auto\n  qed\n  finally show ?thesis by simp \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2136
    },
    "1925": {
        "type": "lemma",
        "text": "text\\<open>Intuitively, the topological space of singleton lists valued in $X$ \n  is the same as $X$. However, each element of this space is a list of length one,\n  i.e a set consisting of a pair $\\langle 0, x\\rangle$ where $x$ is an element of $X$.\n  The next lemma provides a formula for the product topology in the corner case when we have \n  only one factor and shows that the product topology of one space is essentially the same as \n  the space.\\<close>\n",
        "assumes": "assumes A1: \"\\<tau> {is a topology}\" \n  ",
        "using": [
            "list_singleton_bij",
            "bij_induced_top",
            "bij_def",
            "inj_def",
            "ZF_fun_from_tot_val",
            "func_imagedef",
            "fin_prod_def_nat",
            "apply_funtype",
            "single_top_prod",
            "pair_func_singleton",
            "pair_val",
            "seq_prod_top_is_top"
        ],
        "statement": "lemma singleton_prod_top: assumes A1: \"\\<tau> {is a topology}\" \n  shows \n    \"SeqProductTopology(1,\\<tau>) = { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\" and\n    \"IsAhomeomorphism(\\<tau>,SeqProductTopology(1,\\<tau>),{\\<langle>y,{\\<langle>0,y\\<rangle>}\\<rangle>.y \\<in> \\<Union>\\<tau>})\"\n",
        "proof": "proof -\n  have \"{0} = 1\" by auto\n  let ?b = \"{\\<langle>y,{\\<langle>0,y\\<rangle>}\\<rangle>.y \\<in> \\<Union>\\<tau>}\"\n  have \"?b \\<in> bij(\\<Union>\\<tau>,1\\<rightarrow>\\<Union>\\<tau>)\" using list_singleton_bij by blast\n  with A1 have \"{?b``(U). U\\<in>\\<tau>} {is a topology}\" and \"IsAhomeomorphism(\\<tau>, {?b``(U). U\\<in>\\<tau>},?b)\"\n    using bij_induced_top by auto\n  moreover have \"\\<forall>U\\<in>\\<tau>. ?b``(U) = { {\\<langle>0,y\\<rangle>}. y\\<in>U }\"\n  proof\n    fix U assume \"U\\<in>\\<tau>\"\n    from \\<open>?b \\<in> bij(\\<Union>\\<tau>,1\\<rightarrow>\\<Union>\\<tau>)\\<close> have \"?b:\\<Union>\\<tau>\\<rightarrow>(1\\<rightarrow>\\<Union>\\<tau>)\" using bij_def inj_def\n      by simp\n    { fix y assume \"y \\<in> \\<Union>\\<tau>\"\n      with \\<open>?b:\\<Union>\\<tau>\\<rightarrow>(1\\<rightarrow>\\<Union>\\<tau>)\\<close> have \"?b`(y) = {\\<langle>0,y\\<rangle>}\" using ZF_fun_from_tot_val\n        by simp\n    } hence \"\\<forall>y \\<in> \\<Union>\\<tau>. ?b`(y) = {\\<langle>0,y\\<rangle>}\" by auto\n    with  \\<open>U\\<in>\\<tau>\\<close> \\<open>?b:\\<Union>\\<tau>\\<rightarrow>(1\\<rightarrow>\\<Union>\\<tau>)\\<close> show \" ?b``(U) = { {\\<langle>0,y\\<rangle>}. y\\<in>U }\"\n      using func_imagedef by auto \n  qed\n  moreover have \"ProductTopBase(1,\\<tau>) = { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\"\n  proof\n    { fix V assume \"V \\<in> ProductTopBase(1,\\<tau>)\"\n      with A1 obtain W where \"W:1\\<rightarrow>\\<tau>\" and \"V = FinProd(1\\<rightarrow>\\<Union>\\<tau>,W)\"\n        using fin_prod_def_nat by auto\n      then have \"V \\<in> { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\" using apply_funtype single_top_prod\n        by auto \n    } thus \"ProductTopBase(1,\\<tau>) \\<subseteq> { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\" by auto\n  { fix V assume \"V \\<in> { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\"\n    then obtain U where \"U\\<in>\\<tau>\" and \"V = { {\\<langle>0,y\\<rangle>}. y\\<in>U }\" by auto \n    let ?W = \"{\\<langle>0,U\\<rangle>}\"\n    from \\<open>U\\<in>\\<tau>\\<close> have \"?W:{0}\\<rightarrow>\\<tau>\" using pair_func_singleton by simp   \n    with \\<open>{0} = 1\\<close> have \"?W:1\\<rightarrow>\\<tau>\" and \"?W`(0) = U\" using pair_val by auto\n    with \\<open>V = { {\\<langle>0,y\\<rangle>}. y\\<in>U }\\<close> have \"V = FinProd(1\\<rightarrow>\\<Union>\\<tau>,?W)\"\n      using single_top_prod by simp \n    with A1 \\<open>?W:1\\<rightarrow>\\<tau>\\<close> have \"V \\<in> ProductTopBase(1,\\<tau>)\" using fin_prod_def_nat\n      by auto\n   } thus \"{ { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>} \\<subseteq> ProductTopBase(1,\\<tau>)\" by auto \n  qed\n  ultimately have I: \"ProductTopBase(1,\\<tau>) {is a topology}\" and \n    II: \"IsAhomeomorphism(\\<tau>, ProductTopBase(1,\\<tau>),?b)\" by auto\n  from A1 have \"ProductTopBase(1,\\<tau>) {is a base for} SeqProductTopology(1,\\<tau>)\" \n    using seq_prod_top_is_top by simp\n  with I have \"ProductTopBase(1,\\<tau>) = SeqProductTopology(1,\\<tau>)\" by (rule base_topology)\n  with \\<open>ProductTopBase(1,\\<tau>) = { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\\<close> II show\n    \"SeqProductTopology(1,\\<tau>) = { { {\\<langle>0,y\\<rangle>}. y\\<in>U }. U\\<in>\\<tau>}\" and\n    \"IsAhomeomorphism(\\<tau>,SeqProductTopology(1,\\<tau>),{\\<langle>y,{\\<langle>0,y\\<rangle>}\\<rangle>.y \\<in> \\<Union>\\<tau>})\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2137
    },
    "1926": {
        "type": "theorem",
        "text": "text\\<open>A special corner case of \\<open>finite_top_prod_homeo\\<close>: a space $X$ \n  is homeomorphic to the space of one element lists of $X$.\\<close>\n",
        "assumes": "assumes A1: \"\\<tau> {is a topology}\" \n  ",
        "using": [
            "list_singleton_bij",
            "singleton_prod_top",
            "homeo_inv"
        ],
        "statement": "theorem singleton_prod_top1: assumes A1: \"\\<tau> {is a topology}\" \n  shows \"IsAhomeomorphism(SeqProductTopology(1,\\<tau>),\\<tau>,{\\<langle>x,x`(0)\\<rangle>. x\\<in>1\\<rightarrow>\\<Union>\\<tau>})\"\n",
        "proof": "proof -\n  have \"{\\<langle>x,x`(0)\\<rangle>. x\\<in>1\\<rightarrow>\\<Union>\\<tau>} = converse({\\<langle>y,{\\<langle>0,y\\<rangle>}\\<rangle>.y\\<in>\\<Union>\\<tau>})\" \n    using list_singleton_bij by blast\n  with A1 show ?thesis using singleton_prod_top homeo_inv by simp\nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2138
    },
    "1927": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma describing the carrier of a (cartesian) product topology of  \nthe (sequence) product topology of $n$ copies of topology $\\tau$ and another \ncopy of $\\tau$.\\<close>\n",
        "assumes": "assumes \"\\<tau> {is a topology}\" and  \"T = SeqProductTopology(n,\\<tau>)\"\n  ",
        "using": [
            "assms",
            "Top_1_4_T1",
            "seq_prod_top_is_top"
        ],
        "statement": "lemma finite_prod_top: assumes \"\\<tau> {is a topology}\" and  \"T = SeqProductTopology(n,\\<tau>)\"\n  shows \"(\\<Union>ProductTopology(T,\\<tau>)) = (n\\<rightarrow>\\<Union>\\<tau>)\\<times>\\<Union>\\<tau>\"\n  ",
        "proof": "using assms Top_1_4_T1 seq_prod_top_is_top by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2139
    },
    "1928": {
        "type": "lemma",
        "text": "text\\<open>If $U$ is a set from the base of $X^n$ and $V$ is open in $X$, then $U\\times V$\nis in the base of $X^{n+1}$. The next lemma is an analogue of this fact for the \nfunction space approach.\\<close>\n",
        "assumes": "assumes A1: \"\\<tau> {is a topology}\" and A2: \"n \\<in> nat\" and \n  A3: \"U \\<in> ProductTopBase(n,\\<tau>)\" and A4: \"V\\<in>\\<tau>\"\n  ",
        "using": [
            "fin_prod_def_nat",
            "append_props",
            "func1_1_L1",
            "FinProd_def",
            "init_props"
        ],
        "statement": "lemma finite_prod_succ_base: assumes A1: \"\\<tau> {is a topology}\" and A2: \"n \\<in> nat\" and \n  A3: \"U \\<in> ProductTopBase(n,\\<tau>)\" and A4: \"V\\<in>\\<tau>\"\n  shows \"{x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> U \\<and> x`(n) \\<in> V} \\<in> ProductTopBase(succ(n),\\<tau>)\"\n  ",
        "proof": "proof -\n    let ?B = \"{x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> U \\<and> x`(n) \\<in> V}\"\n    from A1 A2 have \"ProductTopBase(n,\\<tau>) = {FinProd(n\\<rightarrow>\\<Union>\\<tau>,W). W\\<in>n\\<rightarrow>\\<tau>}\"\n      using fin_prod_def_nat by simp\n    with A3 obtain W\\<^sub>U where \"W\\<^sub>U:n\\<rightarrow>\\<tau>\" and \"U =FinProd(n\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>U)\" by auto\n    let ?W = \"Append(W\\<^sub>U,V)\"\n    from A4 and \\<open>W\\<^sub>U:n\\<rightarrow>\\<tau>\\<close> have \"?W:succ(n)\\<rightarrow>\\<tau>\" using append_props by simp\n    moreover have \"?B = FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,?W)\"\n    proof\n      { fix x assume \"x\\<in>?B\"\n        with \\<open>?W:succ(n)\\<rightarrow>\\<tau>\\<close> have \"x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>\" and \"domain(?W) = succ(n)\" using func1_1_L1 \n          by auto\n        moreover from A2 A4 \\<open>x\\<in>?B\\<close> \\<open>U =FinProd(n\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>U)\\<close> \\<open>W\\<^sub>U:n\\<rightarrow>\\<tau>\\<close> \\<open>x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>\\<close> \n        have \"\\<forall>i\\<in>succ(n). x`(i) \\<in> ?W`(i)\" using func1_1_L1 FinProd_def init_props append_props\n          by simp \n        ultimately have \"x \\<in> FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,?W)\" using FinProd_def by simp \n      } thus \"?B \\<subseteq> FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,?W)\" by auto\n      next\n      { fix x assume \"x \\<in> FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,?W)\"\n        then have \"x:succ(n)\\<rightarrow>\\<Union>\\<tau>\" and I: \"\\<forall>i \\<in> domain(?W). x`(i) \\<in> ?W`(i)\"\n          using FinProd_def by auto\n        moreover have \"Init(x) \\<in> U\"\n        proof -\n          from A2 and \\<open>x:succ(n)\\<rightarrow>\\<Union>\\<tau>\\<close> have \"Init(x):n\\<rightarrow>\\<Union>\\<tau>\" using init_props by simp \n          moreover have \"\\<forall>i\\<in>domain(W\\<^sub>U). Init(x)`(i) \\<in> W\\<^sub>U`(i)\"\n          proof -\n            from A2 \\<open>x \\<in> FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,?W)\\<close> \\<open>?W:succ(n)\\<rightarrow>\\<tau>\\<close> have \"\\<forall>i\\<in>n. x`(i) \\<in> ?W`(i)\"\n              using FinProd_def func1_1_L1 by simp \n            moreover from A2 \\<open>x: succ(n)\\<rightarrow>\\<Union>\\<tau>\\<close> have \"\\<forall>i\\<in>n. Init(x)`(i) = x`(i)\"\n              using init_props by simp\n            moreover from A4 and \\<open>W\\<^sub>U:n\\<rightarrow>\\<tau>\\<close> have \"\\<forall>i\\<in>n. ?W`(i) =  W\\<^sub>U`(i)\"\n              using append_props by simp\n            ultimately have \"\\<forall>i\\<in>n. Init(x)`(i) \\<in> W\\<^sub>U`(i)\" by simp\n            with \\<open>W\\<^sub>U:n\\<rightarrow>\\<tau>\\<close> show ?thesis using func1_1_L1 by simp \n          qed\n          ultimately have \"Init(x) \\<in> FinProd(n\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>U)\" using FinProd_def by simp\n          with \\<open>U =FinProd(n\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>U)\\<close> show ?thesis by simp \n        qed\n        moreover have \"x`(n) \\<in> V\"       \n        proof -  \n          from \\<open>?W:succ(n)\\<rightarrow>\\<tau>\\<close> I  have \"x`(n) \\<in> ?W`(n)\" using func1_1_L1 by simp\n          moreover from A4 \\<open>W\\<^sub>U:n\\<rightarrow>\\<tau>\\<close> have \"?W`(n) = V\" using append_props by simp\n          ultimately show ?thesis by simp \n        qed\n        ultimately have \"x\\<in>?B\" by simp  \n      } thus \"FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,?W) \\<subseteq> ?B\" by auto\n    qed\n    moreover from A1 A2 have \n      \"ProductTopBase(succ(n),\\<tau>) = {FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,W). W\\<in>succ(n)\\<rightarrow>\\<tau>}\"\n      using fin_prod_def_nat by simp\n    ultimately show ?thesis by auto\n qed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2140
    },
    "1929": {
        "type": "lemma",
        "text": "text\\<open>If $U$ is open in $X^n$ and $V$ is open in $X$, then $U\\times V$ is open in $X^{n+1}$. \nThe next lemma is an analogue of this fact for the function space approach.\\<close>\n",
        "assumes": "assumes A1: \"\\<tau> {is a topology}\" and A2: \"n \\<in> nat\" and \n  A3: \"U \\<in> SeqProductTopology(n,\\<tau>)\" and A4: \"V\\<in>\\<tau>\"\n  ",
        "using": [
            "seq_prod_top_is_top",
            "Top_1_2_L1",
            "finite_prod_succ_base",
            "base_sets_open",
            "union_indexed_open"
        ],
        "statement": "lemma finite_prod_succ: assumes A1: \"\\<tau> {is a topology}\" and A2: \"n \\<in> nat\" and \n  A3: \"U \\<in> SeqProductTopology(n,\\<tau>)\" and A4: \"V\\<in>\\<tau>\"\n  shows \"{x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> U \\<and> x`(n) \\<in> V} \\<in> SeqProductTopology(succ(n),\\<tau>)\"\n  ",
        "proof": "proof -\n     from A1 have \"ProductTopBase(n,\\<tau>) {is a base for} SeqProductTopology(n,\\<tau>)\" and \n      I: \"ProductTopBase(succ(n),\\<tau>) {is a base for} SeqProductTopology(succ(n),\\<tau>)\" and \n      II: \"SeqProductTopology(succ(n),\\<tau>) {is a topology}\"\n        using seq_prod_top_is_top by auto\n    with A3 have \"\\<exists>\\<B> \\<in> Pow(ProductTopBase(n,\\<tau>)). U = \\<Union>\\<B>\" using Top_1_2_L1 by simp\n    then obtain \\<B> where \"\\<B> \\<subseteq> ProductTopBase(n,\\<tau>)\" and \"U = \\<Union>\\<B>\" by auto\n    then have \n    \"{x:succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> U \\<and> x`(n) \\<in> V} = (\\<Union>B\\<in>\\<B>.{x:succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> B \\<and> x`(n) \\<in> V})\"\n      by auto\n    moreover from A1 A2 A4 \\<open>\\<B> \\<subseteq> ProductTopBase(n,\\<tau>)\\<close> have\n      \"\\<forall>B\\<in>\\<B>. ({x:succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> B \\<and> x`(n) \\<in> V} \\<in> ProductTopBase(succ(n),\\<tau>))\"\n      using finite_prod_succ_base by auto\n    with I II have \n      \"(\\<Union>B\\<in>\\<B>.{x:succ(n)\\<rightarrow>\\<Union>\\<tau>. Init(x) \\<in> B \\<and> x`(n) \\<in> V}) \\<in> SeqProductTopology(succ(n),\\<tau>)\"\n      using base_sets_open union_indexed_open by auto\n    ultimately show ?thesis by simp\n  qed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2141
    },
    "1930": {
        "type": "theorem",
        "text": "text\\<open>In the \\<open>Topology_ZF_2\\<close> theory we define product topology of two topological spaces.\nThe next lemma explains in what sense the topology on finite lists of length $n$ of \nelements of topological space $X$ can be thought as a model of the product topology on the cartesian \nproduct of $n$ copies of that space. Namely, we show that the space of lists of length $n+1$ \nof elements of $X$  is homeomorphic to the product topology (as defined in \\<open>Topology_ZF_2\\<close>) \nof two spaces: the space of lists of length $n$ and $X$. Recall that if $\\mathcal{B}$ is a base \n(i.e. satisfies the base condition), then the collection $\\{\\bigcup B| B \\in Pow(\\mathcal{B})\\}$ \nis a topology (generated by $\\mathcal{B}$).\\<close>\n",
        "assumes": "assumes A1: \"\\<tau> {is a topology}\" and A2: \"n \\<in> nat\" and \n  A3: \"f = {\\<langle>x,\\<langle>Init(x),x`(n)\\<rangle>\\<rangle>. x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>}\" and\n  A4: \"T = SeqProductTopology(n,\\<tau>)\" and\n  A5: \"S = SeqProductTopology(succ(n),\\<tau>)\"\n",
        "using": [
            "seq_prod_top_is_top",
            "Top_1_4_T1",
            "lists_cart_prod",
            "bij_is_fun",
            "two_top_spaces0_def",
            "ProductCollection_def",
            "ZF_fun_from_tot_val",
            "func1_1_L15",
            "finite_prod_succ",
            "fin_prod_def_nat",
            "init_props",
            "base_sets_open",
            "apply_funtype",
            "prod_open_open_prod",
            "func1_1_L1",
            "IsAbaseFor_def",
            "func_imagedef",
            "FinProd_def",
            "append_props",
            "init_append",
            "two_top_spaces0.bij_base_open_homeo"
        ],
        "statement": "theorem finite_top_prod_homeo: assumes A1: \"\\<tau> {is a topology}\" and A2: \"n \\<in> nat\" and \n  A3: \"f = {\\<langle>x,\\<langle>Init(x),x`(n)\\<rangle>\\<rangle>. x \\<in> succ(n)\\<rightarrow>\\<Union>\\<tau>}\" and\n  A4: \"T = SeqProductTopology(n,\\<tau>)\" and\n  A5: \"S = SeqProductTopology(succ(n),\\<tau>)\"\nshows \"IsAhomeomorphism(S,ProductTopology(T,\\<tau>),f)\"\n",
        "proof": "proof -\n  let ?C = \"ProductCollection(T,\\<tau>)\"\n  let ?B = \"ProductTopBase(succ(n),\\<tau>)\"\n  from A1 A4 have \"T {is a topology}\" using seq_prod_top_is_top by simp\n  with A1 A5  have \"S {is a topology}\" and \" ProductTopology(T,\\<tau>) {is a topology}\" \n        using seq_prod_top_is_top  Top_1_4_T1 by auto\n  moreover \n  from assms have \"f \\<in> bij(\\<Union>S,\\<Union>ProductTopology(T,\\<tau>))\"\n    using lists_cart_prod seq_prod_top_is_top Top_1_4_T1 by simp\n  then have \"f: \\<Union>S\\<rightarrow>\\<Union>ProductTopology(T,\\<tau>)\" using bij_is_fun by simp\n  ultimately have \"two_top_spaces0(S,ProductTopology(T,\\<tau>),f)\" using two_top_spaces0_def by simp\n  moreover note \\<open>f \\<in> bij(\\<Union>S,\\<Union>ProductTopology(T,\\<tau>))\\<close>\n  moreover from A1 A5 have \"?B {is a base for} S\"\n    using seq_prod_top_is_top by simp\n  moreover from A1 \\<open>T {is a topology}\\<close> have \"?C {is a base for} ProductTopology(T,\\<tau>)\" \n    using Top_1_4_T1 by auto\n  moreover have  \"\\<forall>W\\<in>?C. f-``(W) \\<in> S\"\n  proof\n      fix W assume \"W\\<in>?C\"\n      then obtain U V where \"U\\<in>T\" \"V\\<in>\\<tau>\" and \"W = U\\<times>V\" using ProductCollection_def by auto  \n      from A1 A5 \\<open>f: \\<Union>S\\<rightarrow>\\<Union>ProductTopology(T,\\<tau>)\\<close> have \"f: (succ(n)\\<rightarrow>\\<Union>\\<tau>)\\<rightarrow>\\<Union>ProductTopology(T,\\<tau>)\"\n        using seq_prod_top_is_top by simp\n      with assms \\<open>W = U\\<times>V\\<close> \\<open>U\\<in>T\\<close> \\<open>V\\<in>\\<tau>\\<close> show \"f-``(W) \\<in> S\" \n        using ZF_fun_from_tot_val func1_1_L15 finite_prod_succ by simp \n  qed\n  moreover have \"\\<forall>V\\<in>?B. f``(V) \\<in> ProductTopology(T,\\<tau>)\"\n  proof\n    fix V assume \"V\\<in>?B\"\n    with A1 A2 obtain W\\<^sub>V where \"W\\<^sub>V \\<in> succ(n)\\<rightarrow>\\<tau>\" and \"V = FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>V)\" \n      using fin_prod_def_nat by auto\n    let ?U = \"FinProd(n\\<rightarrow>\\<Union>\\<tau>,Init(W\\<^sub>V))\"\n    let ?W = \"W\\<^sub>V`(n)\"\n    have \"?U \\<in> T\"\n    proof - \n      from A1 A2 \\<open>W\\<^sub>V \\<in> succ(n)\\<rightarrow>\\<tau>\\<close> have \"?U \\<in> ProductTopBase(n,\\<tau>)\" \n        using fin_prod_def_nat init_props by auto\n      with A1 A4 show ?thesis using seq_prod_top_is_top base_sets_open by blast\n    qed\n    from A1 \\<open>W\\<^sub>V \\<in> succ(n)\\<rightarrow>\\<tau>\\<close> \\<open>T {is a topology}\\<close> \\<open>?U \\<in> T\\<close> have \"?U\\<times>?W \\<in> ProductTopology(T,\\<tau>)\"\n      using apply_funtype prod_open_open_prod by simp\n    moreover have \"f``(V) = ?U\\<times>?W\"\n    proof -\n      from A2 \\<open>W\\<^sub>V: succ(n)\\<rightarrow>\\<tau>\\<close> have \"Init(W\\<^sub>V): n\\<rightarrow>\\<tau>\" and III: \"\\<forall>k\\<in>n. Init(W\\<^sub>V)`(k) = W\\<^sub>V`(k)\" \n        using init_props by auto\n      then have \"domain(Init(W\\<^sub>V)) = n\" using func1_1_L1 by simp\n      have \"f``(V) = {\\<langle>Init(x),x`(n)\\<rangle>. x\\<in>V}\"\n      proof -\n        have \"f``(V) = {f`(x). x\\<in>V}\"\n        proof -\n          from A1 A5 have \"?B {is a base for} S\" using seq_prod_top_is_top by simp \n          with \\<open>V\\<in>?B\\<close> have \"V \\<subseteq> \\<Union>S\" using IsAbaseFor_def by auto\n          with \\<open>f: \\<Union>S\\<rightarrow>\\<Union>ProductTopology(T,\\<tau>)\\<close> show ?thesis using func_imagedef by simp\n        qed\n        moreover have \"\\<forall>x\\<in>V. f`(x) = \\<langle>Init(x),x`(n)\\<rangle>\"\n        proof -\n          from A1 A3 A5 \\<open>V = FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>V)\\<close> have \"V \\<subseteq> \\<Union>S\" and \n            fdef: \"f = {\\<langle>x,\\<langle>Init(x),x`(n)\\<rangle>\\<rangle>. x \\<in> \\<Union>S}\" using seq_prod_top_is_top FinProd_def \n            by auto \n          from \\<open>f: \\<Union>S\\<rightarrow>\\<Union>ProductTopology(T,\\<tau>)\\<close> fdef have \"\\<forall>x \\<in> \\<Union>S. f`(x) = \\<langle>Init(x),x`(n)\\<rangle>\" \n            by (rule ZF_fun_from_tot_val0)  \n          with \\<open>V \\<subseteq> \\<Union>S\\<close> show ?thesis by auto  \n        qed\n        ultimately show ?thesis by simp \n      qed\n      also have \"{\\<langle>Init(x),x`(n)\\<rangle>. x\\<in>V} = ?U\\<times>?W\"\n      proof\n        { fix y assume \"y \\<in> {\\<langle>Init(x),x`(n)\\<rangle>. x\\<in>V}\"\n          then obtain x where I: \"y = \\<langle>Init(x),x`(n)\\<rangle>\" and \"x\\<in>V\" by auto \n          with \\<open>V = FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>V)\\<close> have \n            \"x:succ(n)\\<rightarrow>\\<Union>\\<tau>\" and II: \"\\<forall>k\\<in>domain(W\\<^sub>V). x`(k) \\<in> W\\<^sub>V`(k)\" \n            unfolding FinProd_def by auto\n          with A2 \\<open>W\\<^sub>V: succ(n)\\<rightarrow>\\<tau>\\<close> have IV: \"\\<forall>k\\<in>n. Init(x)`(k) = x`(k)\" \n            using init_props by simp \n          have \"Init(x) \\<in> ?U\"\n          proof -\n            from A2 \\<open>x:succ(n)\\<rightarrow>\\<Union>\\<tau>\\<close> have \"Init(x): n\\<rightarrow>\\<Union>\\<tau>\" using init_props by simp \n            moreover have \"\\<forall>k\\<in>domain(Init(W\\<^sub>V)). Init(x)`(k) \\<in> Init(W\\<^sub>V)`(k)\"\n            proof -\n              from A2 \\<open>W\\<^sub>V: succ(n)\\<rightarrow>\\<tau>\\<close> have \"Init(W\\<^sub>V): n\\<rightarrow>\\<tau>\" using init_props by simp\n              then have \"domain(Init(W\\<^sub>V)) = n\" using func1_1_L1 by simp\n              note III IV  \\<open>domain(Init(W\\<^sub>V)) = n\\<close>\n              moreover from II \\<open>W\\<^sub>V \\<in> succ(n)\\<rightarrow>\\<tau>\\<close> have \"\\<forall>k\\<in>n. x`(k) \\<in> W\\<^sub>V`(k)\" \n                using func1_1_L1 by simp\n              ultimately show ?thesis by simp \n            qed\n            ultimately show \"Init(x) \\<in> ?U\" using FinProd_def by simp\n          qed\n          moreover from \\<open>W\\<^sub>V: succ(n)\\<rightarrow>\\<tau>\\<close> II have \"x`(n) \\<in> ?W\" using func1_1_L1 by simp\n          ultimately have \"\\<langle>Init(x),x`(n)\\<rangle> \\<in> ?U\\<times>?W\" by simp \n          with I have \"y \\<in> ?U\\<times>?W\" by simp \n        } thus \"{\\<langle>Init(x),x`(n)\\<rangle>. x\\<in>V} \\<subseteq> ?U\\<times>?W\" by auto\n        { fix y assume \"y \\<in> ?U\\<times>?W\"\n          then have \"fst(y) \\<in> ?U\" and \"snd(y) \\<in> ?W\" by auto\n          with \\<open>domain(Init(W\\<^sub>V)) = n\\<close> have \"fst(y): n\\<rightarrow>\\<Union>\\<tau>\" and \n            V: \"\\<forall>k\\<in>n. fst(y)`(k) \\<in> Init(W\\<^sub>V)`(k)\"\n            using FinProd_def by auto\n          from \\<open>W\\<^sub>V: succ(n)\\<rightarrow>\\<tau>\\<close> have \"?W \\<in> \\<tau>\" using apply_funtype by simp\n          with \\<open>snd(y) \\<in> ?W\\<close> have \"snd(y) \\<in> \\<Union>\\<tau>\" by auto     \n          let ?x = \"Append(fst(y),snd(y))\"\n          have \"?x\\<in>V\"\n          proof -\n            from \\<open>fst(y): n\\<rightarrow>\\<Union>\\<tau>\\<close> \\<open>snd(y) \\<in> \\<Union>\\<tau>\\<close> have \"?x:succ(n)\\<rightarrow>\\<Union>\\<tau>\" using append_props by simp\n            moreover have \"\\<forall>i\\<in>domain(W\\<^sub>V). ?x`(i) \\<in> W\\<^sub>V`(i)\"             \n            proof -\n              from \\<open>fst(y): n\\<rightarrow>\\<Union>\\<tau>\\<close> \\<open>snd(y) \\<in> \\<Union>\\<tau>\\<close> \n                have \"\\<forall>k\\<in>n. ?x`(k) = fst(y)`(k)\" and \"?x`(n) = snd(y)\" \n                using append_props by auto\n              moreover from III V have \"\\<forall>k\\<in>n. fst(y)`(k) \\<in> W\\<^sub>V`(k)\" by simp \n              moreover note \\<open>snd(y) \\<in> ?W\\<close>\n              ultimately have \"\\<forall>i\\<in>succ(n). ?x`(i) \\<in> W\\<^sub>V`(i)\" by simp\n              with \\<open>W\\<^sub>V \\<in> succ(n)\\<rightarrow>\\<tau>\\<close> show ?thesis using func1_1_L1 by simp \n            qed\n            ultimately have \"?x \\<in> FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>V)\" using FinProd_def by simp\n            with \\<open>V = FinProd(succ(n)\\<rightarrow>\\<Union>\\<tau>,W\\<^sub>V)\\<close> show \"?x\\<in>V\" by simp  \n          qed\n          moreover from A2 \\<open>y \\<in> ?U\\<times>?W\\<close> \\<open>fst(y): n\\<rightarrow>\\<Union>\\<tau>\\<close> \\<open>snd(y) \\<in> \\<Union>\\<tau>\\<close> have \"y = \\<langle>Init(?x),?x`(n)\\<rangle>\"\n            using init_append append_props by auto  \n          ultimately have \"y \\<in> {\\<langle>Init(x),x`(n)\\<rangle>. x\\<in>V}\" by auto \n        } thus \"?U\\<times>?W \\<subseteq> {\\<langle>Init(x),x`(n)\\<rangle>. x\\<in>V}\" by auto\n      qed\n      finally show \"f``(V) = ?U\\<times>?W\" by simp \n    qed\n    ultimately show \"f``(V) \\<in> ProductTopology(T,\\<tau>)\" by simp \n  qed\n  ultimately show ?thesis using two_top_spaces0.bij_base_open_homeo by simp \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_3.thy",
        "id": 2142
    },
    "1931": {
        "type": "definition",
        "text": "text\\<open>We say that a relation $r$ \\<open>directs\\<close> a set $X$ if the relation is reflexive, transitive\n  on $X$ and for every two elements $x,y$ of $X$ there is some element $z$ such that both\n  $x$ and $y$ are in the relation with $z$. Note that this naming is a bit inconsistent with what\n  is defined in \\<open>Order_ZF\\<close> where we define what it means that $r$ \\<open>up-directs\\<close> $X$ \n  (the third condition in the definition below) or $r$ \\<open>down-directs\\<close> $X$. This naming inconsistency\n   will be fixed in the future (maybe).\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsDirectedSet (\"_ directs _\" 90)\n  where \"r directs X \\<equiv> refl(X,r) \\<and> trans(r) \\<and> (\\<forall>x\\<in>X. \\<forall>y\\<in>X. \\<exists>z\\<in>X. \\<langle>x,z\\<rangle>\\<in>r \\<and> \\<langle>y,z\\<rangle>\\<in>r)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2143
    },
    "1932": {
        "type": "lemma",
        "text": "text\\<open>Any linear order is a directed set; in particular $(\\mathbb{N},\\leq)$.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\"\n  ",
        "using": [
            "IsLinOrder_def",
            "total_is_refl",
            "IsTotal_def",
            "R",
            "refl_def",
            "IsDirectedSet_def",
            "function_def"
        ],
        "statement": "lemma linorder_imp_directed:\n  assumes \"IsLinOrder(X,r)\"\n  shows \"r directs X\"\n",
        "proof": "proof-\n  from assms have \"trans(r)\" using IsLinOrder_def by auto\n  moreover\n  from assms have r:\"refl(X,r)\" using IsLinOrder_def total_is_refl by auto\n  moreover\n  {\n    fix x y\n    assume R: \"x\\<in>X\" \"y\\<in>X\"\n    with assms have \"\\<langle>x,y\\<rangle>\\<in>r \\<or> \\<langle>y,x\\<rangle>\\<in>r\" using IsLinOrder_def IsTotal_def by auto\n    with r have \"(\\<langle>x,y\\<rangle>\\<in>r \\<and> \\<langle>y,y\\<rangle>\\<in>r)\\<or>(\\<langle>y,x\\<rangle>\\<in>r \\<and> \\<langle>x,x\\<rangle>\\<in>r)\" using R refl_def by auto\n    then have \"\\<exists>z\\<in>X. \\<langle>x,z\\<rangle>\\<in>r \\<and> \\<langle>y,z\\<rangle>\\<in>r\" using R by auto\n  }\n  ultimately show ?thesis using IsDirectedSet_def function_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2144
    },
    "1933": {
        "type": "definition",
        "text": "text\\<open>We are able to define the concept of net, now that we now what a directed set is.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsNet (\"_ {is a net on} _\" 90)\n  where \"N {is a net on} X \\<equiv> fst(N):domain(fst(N))\\<rightarrow>X \\<and> (snd(N) directs domain(fst(N))) \\<and> domain(fst(N))\\<noteq>0\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2146
    },
    "1934": {
        "type": "definition",
        "text": "text\\<open>Provided a topology and a net directed on its underlying set,\nwe can talk about convergence of the net in the topology.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in topology0)\n  NetConverges (\"_ \\<rightarrow>\\<^sub>N _\" 90)\n  where \"N {is a net on} \\<Union>T \\<Longrightarrow> N \\<rightarrow>\\<^sub>N x \\<equiv> \n  (x\\<in>\\<Union>T) \\<and> (\\<forall>U\\<in>Pow(\\<Union>T). (x\\<in>int(U) \\<longrightarrow> (\\<exists>t\\<in>domain(fst(N)). \\<forall>m\\<in>domain(fst(N)). \n    (\\<langle>t,m\\<rangle>\\<in>snd(N) \\<longrightarrow> fst(N)`m\\<in>U))))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2147
    },
    "1935": {
        "type": "theorem",
        "text": "text\\<open>One of the most important directed sets, is the neighborhoods of a point.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\"\n  defines \"Neigh\\<equiv>{U\\<in>Pow(\\<Union>T). x\\<in>int(U)}\"\n  defines \"r\\<equiv>{\\<langle>U,V\\<rangle>\\<in>(Neigh \\<times> Neigh). V\\<subseteq>U}\"\n  ",
        "using": [
            "r_def",
            "refl_def",
            "trans_def",
            "Neigh_def",
            "Top_2_L1",
            "Top_2_L2",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L5",
            "p",
            "IsDirectedSet_def"
        ],
        "statement": "theorem (in topology0) directedset_neighborhoods:\n  assumes \"x\\<in>\\<Union>T\"\n  defines \"Neigh\\<equiv>{U\\<in>Pow(\\<Union>T). x\\<in>int(U)}\"\n  defines \"r\\<equiv>{\\<langle>U,V\\<rangle>\\<in>(Neigh \\<times> Neigh). V\\<subseteq>U}\"\n  shows \"r directs Neigh\"\n",
        "proof": "proof-\n  {\n    fix U\n    assume \"U \\<in> Neigh\"\n    then have \"\\<langle>U,U\\<rangle> \\<in> r\" using r_def by auto\n  }\n  then have \"refl(Neigh,r)\" using refl_def by auto\n  moreover\n  {\n    fix U V W\n    assume \"\\<langle>U,V\\<rangle> \\<in> r\" \"\\<langle>V,W\\<rangle> \\<in> r\"\n    then have \"U \\<in> Neigh\" \"W \\<in> Neigh\" \"W\\<subseteq>U\" using r_def by auto\n    then have \"\\<langle>U,W\\<rangle>\\<in>r\" using r_def by auto\n  }\n  then have \"trans(r)\" using trans_def by blast\n  moreover\n  {\n    fix A B\n    assume p: \"A\\<in>Neigh\" \"B\\<in>Neigh\"\n    have \"A\\<inter>B \\<in> Neigh\"\n    proof-\n      from p have \"A\\<inter>B \\<in> Pow(\\<Union>T)\" using Neigh_def by auto\n      moreover\n      { from p have \"x\\<in>int(A)\"\"x\\<in>int(B)\" using Neigh_def by auto\n        then have \"x\\<in>int(A)\\<inter>int(B)\" by auto\n        moreover\n        { have \"int(A)\\<inter>int(B)\\<subseteq>A\\<inter>B\" using Top_2_L1  by auto\n          moreover have \"int(A)\\<inter>int(B)\\<in>T\" \n            using Top_2_L2 Top_2_L2 topSpaceAssum IsATopology_def by blast\n          ultimately have \"int(A)\\<inter>int(B)\\<subseteq>int(A\\<inter>B)\" \n          using Top_2_L5 by auto \n        }\n        ultimately have \"x \\<in> int(A\\<inter>B)\" by auto \n      }\n      ultimately show ?thesis using Neigh_def by auto\n    qed\n    moreover from \\<open>A\\<inter>B \\<in> Neigh\\<close> have \"\\<langle>A,A\\<inter>B\\<rangle>\\<in>r \\<and> \\<langle>B,A\\<inter>B\\<rangle>\\<in>r\" \n      using r_def p by auto\n    ultimately\n    have \"\\<exists>z\\<in>Neigh. \\<langle>A,z\\<rangle>\\<in>r \\<and> \\<langle>B,z\\<rangle>\\<in>r\" by auto\n  }\n  ultimately show ?thesis using IsDirectedSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2148
    },
    "1936": {
        "type": "theorem",
        "text": "text\\<open>There can be nets directed by the neighborhoods that converge to the point;\nif there is a choice function.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\"\n  defines \"Neigh\\<equiv>{U\\<in>Pow(\\<Union>T). x\\<in>int(U)}\"\n  defines \"r\\<equiv>{\\<langle>U,V\\<rangle>\\<in>(Neigh \\<times> Neigh). V\\<subseteq>U}\"\n  assumes \"f:Neigh\\<rightarrow>\\<Union>T\" \"\\<forall>U\\<in>Neigh. f`(U) \\<in> U\"\n  ",
        "using": [
            "Pi_def",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L3",
            "Neigh_def",
            "dom_def",
            "directedset_neighborhoods",
            "NetConverges_def"
        ],
        "statement": "theorem (in topology0) net_direct_neigh_converg:\n  assumes \"x\\<in>\\<Union>T\"\n  defines \"Neigh\\<equiv>{U\\<in>Pow(\\<Union>T). x\\<in>int(U)}\"\n  defines \"r\\<equiv>{\\<langle>U,V\\<rangle>\\<in>(Neigh \\<times> Neigh). V\\<subseteq>U}\"\n  assumes \"f:Neigh\\<rightarrow>\\<Union>T\" \"\\<forall>U\\<in>Neigh. f`(U) \\<in> U\"\n  shows \"\\<langle>f,r\\<rangle> \\<rightarrow>\\<^sub>N x\"\n",
        "proof": "proof -\n  from assms(4) have dom_def: \"Neigh = domain(f)\" using Pi_def by auto\n  moreover\n    have \"\\<Union>T\\<in>T\" using topSpaceAssum IsATopology_def by auto\n    then have \"int(\\<Union>T)=\\<Union>T\" using Top_2_L3 by auto\n    with assms(1) have \"\\<Union>T\\<in>Neigh\" using Neigh_def by auto\n    then have \"\\<Union>T\\<in>domain(fst(\\<langle>f,r\\<rangle>))\" using dom_def by auto\n  moreover from assms(4) dom_def have \"fst(\\<langle>f,r\\<rangle>):domain(fst(\\<langle>f,r\\<rangle>))\\<rightarrow>\\<Union>T\" \n    by auto\n  moreover from assms(1,2,3) dom_def have \"snd(\\<langle>f,r\\<rangle>) directs domain(fst(\\<langle>f,r\\<rangle>))\" \n      using directedset_neighborhoods by simp\n  ultimately have Net: \"\\<langle>f,r\\<rangle> {is a net on} \\<Union>T\" unfolding IsNet_def by auto\n  {\n    fix U\n    assume \"U \\<in> Pow(\\<Union>T)\" \"x \\<in> int(U)\"\n    then have \"U \\<in> Neigh\" using Neigh_def by auto\n    then have t: \"U \\<in> domain(f)\" using dom_def by auto\n    {\n      fix W\n      assume A: \"W\\<in>domain(f)\" \"\\<langle>U,W\\<rangle>\\<in>r\"\n      then have \"W\\<in>Neigh\" using dom_def by auto\n      with assms(5) have \"f`W\\<in>W\" by auto\n      with A(2) r_def have \"f`W\\<in>U\" by auto\n    }\n    then have \"\\<forall>W\\<in>domain(f). (\\<langle>U,W\\<rangle>\\<in>r \\<longrightarrow> f`W\\<in>U)\" by auto\n    with t have \"\\<exists>V\\<in>domain(f). \\<forall>W\\<in>domain(f). (\\<langle>V,W\\<rangle>\\<in>r \\<longrightarrow> f`W\\<in>U)\" by auto\n  }\n  then have \"\\<forall>U\\<in>Pow(\\<Union>T). (x\\<in>int(U) \\<longrightarrow> (\\<exists>V\\<in>domain(f). \\<forall>W\\<in>domain(f). (\\<langle>V,W\\<rangle>\\<in>r \\<longrightarrow> f`(W) \\<in> U)))\"\n    by auto\n  with assms(1) Net show ?thesis using NetConverges_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2149
    },
    "1937": {
        "type": "definition",
        "text": "text\\<open>The topological tools to deal with convergence are what is called filters.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsFilter (\"_ {is a filter on} _\" 90)\n  where \"\\<FF> {is a filter on} X \\<equiv> (0\\<notin>\\<FF>) \\<and> (X\\<in>\\<FF>) \\<and> \\<FF>\\<subseteq>Pow(X) \\<and> \n  (\\<forall>A\\<in>\\<FF>. \\<forall>B\\<in>\\<FF>. A\\<inter>B\\<in>\\<FF>) \\<and> (\\<forall>B\\<in>\\<FF>. \\<forall>C\\<in>Pow(X). B\\<subseteq>C \\<longrightarrow> C\\<in>\\<FF>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2150
    },
    "1938": {
        "type": "lemma",
        "text": "text\\<open>The next lemma splits the the definition of a filter into four conditions\n to make it easier to reference each one separately in proofs.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} X\"\n  ",
        "using": [
            "assms",
            "IsFilter_def"
        ],
        "statement": "lemma is_filter_def_split: assumes \"\\<FF> {is a filter on} X\"\n  shows \"0\\<notin>\\<FF>\" \"X\\<in>\\<FF>\" \"\\<FF>\\<subseteq>Pow(X)\" \n    \"\\<forall>A\\<in>\\<FF>. \\<forall>B\\<in>\\<FF>. A\\<inter>B\\<in>\\<FF>\" and \"\\<forall>B\\<in>\\<FF>. \\<forall>C\\<in>Pow(X). B\\<subseteq>C \\<longrightarrow> C\\<in>\\<FF>\"\n  ",
        "proof": "using assms unfolding IsFilter_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2151
    },
    "1939": {
        "type": "definition",
        "text": "text\\<open>Not all the sets of a filter are needed to be consider at all times; as it happens\nwith a topology we can consider bases.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsBaseFilter (\"_ {is a base filter} _\" 90)\n  where \"C {is a base filter} \\<FF> \\<equiv> C\\<subseteq>\\<FF> \\<and> \\<FF>={A\\<in>Pow(\\<Union>\\<FF>). (\\<exists>D\\<in>C. D\\<subseteq>A)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2152
    },
    "1940": {
        "type": "definition",
        "text": "text\\<open>Not every set is a base for a filter, as it happens with topologies, there\nis a condition to be satisfied.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  SatisfiesFilterBase (\"_ {satisfies the filter base condition}\" 90)\n  where \"C {satisfies the filter base condition} \\<equiv> (\\<forall>A\\<in>C. \\<forall>B\\<in>C. \\<exists>D\\<in>C. D\\<subseteq>A\\<inter>B) \\<and> C\\<noteq>0 \\<and> 0\\<notin>C\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2153
    },
    "1941": {
        "type": "lemma",
        "text": "text\\<open>Every set of a filter contains a set from the filter's base.\\<close>\n",
        "assumes": "assumes \"A\\<in>\\<FF>\" and \"C {is a base filter} \\<FF>\"\n  ",
        "using": [
            "IsBaseFilter_def"
        ],
        "statement": "lemma basic_element_filter:\n  assumes \"A\\<in>\\<FF>\" and \"C {is a base filter} \\<FF>\"\n  shows \"\\<exists>D\\<in>C. D\\<subseteq>A\"\n",
        "proof": "proof-\n  from assms(2) have t:\"\\<FF>={A\\<in>Pow(\\<Union>\\<FF>). (\\<exists>D\\<in>C. D\\<subseteq>A)}\" using IsBaseFilter_def by auto\n  with assms(1) have \"A\\<in>{A\\<in>Pow(\\<Union>\\<FF>). (\\<exists>D\\<in>C. D\\<subseteq>A)}\" by auto\n  then have \"A\\<in>Pow(\\<Union>\\<FF>)\" \"\\<exists>D\\<in>C. D\\<subseteq>A\" by auto\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2154
    },
    "1942": {
        "type": "theorem",
        "text": "text\\<open>The following two results state that the filter base condition is necessary\nand sufficient for the filter generated by a base, to be an actual filter.\nThe third result, rewrites the previous two.\\<close>\n",
        "assumes": "assumes \"C {is a base filter} \\<FF>\" and \"C {satisfies the filter base condition}\"\n  ",
        "using": [
            "basic_element_filter",
            "SatisfiesFilterBase_def",
            "IsBaseFilter_def",
            "IsFilter_def"
        ],
        "statement": "theorem basic_filter_1:\n  assumes \"C {is a base filter} \\<FF>\" and \"C {satisfies the filter base condition}\"\n  shows \"\\<FF> {is a filter on} \\<Union>\\<FF>\"\n",
        "proof": "proof-\n  {\n    fix A B\n    assume AF: \"A\\<in>\\<FF>\" and BF: \"B\\<in>\\<FF>\"\n    with assms(1) have \"\\<exists>DA\\<in>C. DA\\<subseteq>A\" using  basic_element_filter by simp\n    then obtain DA where perA: \"DA\\<in>C\" and subA: \"DA\\<subseteq>A\" by auto\n    from BF assms have \"\\<exists>DB\\<in>C. DB\\<subseteq>B\" using  basic_element_filter by simp\n    then obtain DB where perB: \"DB\\<in>C\" and subB: \"DB\\<subseteq>B\" by auto\n    from assms(2) perA perB have \"\\<exists>D\\<in>C. D\\<subseteq>DA\\<inter>DB\" \n      unfolding SatisfiesFilterBase_def by auto\n    then obtain D where \"D\\<in>C\" \"D\\<subseteq>DA\\<inter>DB\" by auto\n    with subA subB AF BF have \"A\\<inter>B\\<in>{A \\<in> Pow(\\<Union>\\<FF>) . \\<exists>D\\<in>C. D \\<subseteq> A}\" by auto\n    with assms(1) have \"A\\<inter>B\\<in>\\<FF>\" unfolding IsBaseFilter_def by auto    \n  }\n  moreover\n  {\n    fix A B\n    assume AF: \"A\\<in>\\<FF>\" and BS: \"B\\<in>Pow(\\<Union>\\<FF>)\" and sub: \"A\\<subseteq>B\"\n    from assms(1) AF have \"\\<exists>D\\<in>C. D\\<subseteq>A\" using basic_element_filter by auto\n    then obtain D where \"D\\<subseteq>A\" \"D\\<in>C\" by auto\n    with sub BS have \"B\\<in>{A\\<in>Pow(\\<Union>\\<FF>). \\<exists>D\\<in>C. D\\<subseteq>A}\" by auto\n    with assms(1) have \"B\\<in>\\<FF>\" unfolding IsBaseFilter_def by auto\n    }\n  moreover\n  from assms(2) have \"C\\<noteq>0\" using SatisfiesFilterBase_def by auto\n  then obtain D where \"D\\<in>C\" by auto\n  with assms(1) have \"D\\<subseteq>\\<Union>\\<FF>\" using IsBaseFilter_def by auto\n  with \\<open>D\\<in>C\\<close> have \"\\<Union>\\<FF>\\<in>{A\\<in>Pow(\\<Union>\\<FF>). \\<exists>D\\<in>C. D\\<subseteq>A}\" by auto\n  with assms(1) have \"\\<Union>\\<FF>\\<in>\\<FF>\" unfolding IsBaseFilter_def by auto\n  moreover\n  {\n    assume \"0\\<in>\\<FF>\" \n    with assms(1) have \"\\<exists>D\\<in>C. D\\<subseteq>0\" using basic_element_filter by simp \n    then obtain D where \"D\\<in>C\"\"D\\<subseteq>0\" by auto\n    then have \"D\\<in>C\" \"D=0\" by auto\n    with assms(2) have \"False\" using SatisfiesFilterBase_def by auto \n  }\n  then have \"0\\<notin>\\<FF>\" by auto\n  ultimately show ?thesis using IsFilter_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2155
    },
    "1943": {
        "type": "theorem",
        "text": "text\\<open>A base filter satisfies the filter base condition.\\<close>\n",
        "assumes": "assumes \"C {is a base filter} \\<FF>\" and \"\\<FF> {is a filter on} \\<Union>\\<FF>\"\n  ",
        "using": [
            "assms(1)",
            "IsBaseFilter_def",
            "assms(2)",
            "IsFilter_def",
            "basic_element_filter",
            "SatisfiesFilterBase_def"
        ],
        "statement": "theorem basic_filter_2:\n  assumes \"C {is a base filter} \\<FF>\" and \"\\<FF> {is a filter on} \\<Union>\\<FF>\"\n  shows \"C {satisfies the filter base condition}\"\n",
        "proof": "proof-\n  {\n    fix A B\n    assume AF: \"A\\<in>C\" and BF: \"B\\<in>C\"\n    then have \"A\\<in>\\<FF>\" and \"B\\<in>\\<FF>\" using assms(1) IsBaseFilter_def by auto\n    then have \"A\\<inter>B\\<in>\\<FF>\" using assms(2) IsFilter_def by auto\n    then have \"\\<exists>D\\<in>C. D\\<subseteq>A\\<inter>B\" using assms(1) basic_element_filter by blast\n  }\n  then have \"\\<forall>A\\<in>C. \\<forall>B\\<in>C. \\<exists>D\\<in>C. D\\<subseteq>A\\<inter>B\" by auto\n  moreover\n  {\n    assume \"0\\<in>C\"\n    then have \"0\\<in>\\<FF>\" using assms(1) IsBaseFilter_def by auto\n    then have \"False\" using assms(2) IsFilter_def by auto\n  } \n  then have \"0\\<notin>C\" by auto\n  moreover\n  {\n    assume \"C=0\"\n    then have \"\\<FF>=0\" using assms(1) IsBaseFilter_def by auto\n    then have \"False\" using assms(2) IsFilter_def by auto\n  }\n  then have \"C\\<noteq>0\" by auto\n  ultimately show ?thesis using SatisfiesFilterBase_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2156
    },
    "1944": {
        "type": "theorem",
        "text": "text\\<open>A base filter for a collection satisfies the filter base condition iff that collection\nis in fact a filter.\\<close>\n",
        "assumes": "assumes \"C {is a base filter} \\<FF>\"\n  ",
        "using": [
            "assms",
            "basic_filter_1",
            "basic_filter_2"
        ],
        "statement": "theorem basic_filter:\n  assumes \"C {is a base filter} \\<FF>\"\n  shows \"(C {satisfies the filter base condition}) \\<longleftrightarrow> (\\<FF> {is a filter on} \\<Union>\\<FF>)\"\n",
        "proof": "using assms basic_filter_1 basic_filter_2 by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2157
    },
    "1945": {
        "type": "theorem",
        "text": "text\\<open>A base for a filter determines a filter up to the underlying set.\\<close>\n",
        "assumes": "assumes \"C {is a base filter} \\<FF>1\"and \"C {is a base filter} \\<FF>2\"\n  ",
        "using": [
            "assms",
            "IsBaseFilter_def"
        ],
        "statement": "theorem base_unique_filter:\n  assumes \"C {is a base filter} \\<FF>1\"and \"C {is a base filter} \\<FF>2\"\n  shows \"\\<FF>1=\\<FF>2 \\<longleftrightarrow> \\<Union>\\<FF>1=\\<Union>\\<FF>2\"\n",
        "proof": "using assms unfolding IsBaseFilter_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2158
    },
    "1946": {
        "type": "corollary",
        "text": "text\\<open>A simple corollary from the previous lemma.\\<close>\n",
        "assumes": "assumes \"C\\<subseteq>Pow(X)\" and \"C {satisfies the filter base condition}\"\n  ",
        "using": [
            "base_unique_filter_set2"
        ],
        "statement": "corollary base_unique_filter_set3:\n  assumes \"C\\<subseteq>Pow(X)\" and \"C {satisfies the filter base condition}\"\n  shows \"C {is a base filter} {A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}\" and \"\\<Union>{A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A} = X\"\n",
        "proof": "proof -\n  let ?\\<FF> = \"{A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}\"\n  from assms have \"(C {is a base filter} ?\\<FF>) \\<and> \\<Union>?\\<FF>=X\"\n    using base_unique_filter_set2 by simp\n  thus \"C {is a base filter} ?\\<FF>\" and \"\\<Union>?\\<FF> = X\"\n    by auto\nqed  \n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2160
    },
    "1947": {
        "type": "definition",
        "text": "text\\<open>The convergence for filters is much easier concept to write. Given a topology\nand a filter on the same underlying set, we can define convergence as containing\nall the neighborhoods of the point.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in topology0)\n  FilterConverges (\"_ \\<rightarrow>\\<^sub>F _\" 50) where\n  \"\\<FF>{is a filter on}\\<Union>T  \\<Longrightarrow> \\<FF>\\<rightarrow>\\<^sub>Fx \\<equiv>\n  x\\<in>\\<Union>T \\<and> ({U\\<in>Pow(\\<Union>T). x\\<in>int(U)} \\<subseteq> \\<FF>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2161
    },
    "1948": {
        "type": "lemma",
        "text": "text\\<open>The neighborhoods of a point form a filter that converges to that point.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\"\n  defines \"Neigh\\<equiv>{U\\<in>Pow(\\<Union>T). x\\<in>int(U)}\"\n  ",
        "using": [
            "Neigh_def",
            "Top_2_L1",
            "Top_2_L2",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L5",
            "Top_2_L3",
            "IsFilter_def",
            "FilterConverges_def",
            "assms(1)"
        ],
        "statement": "lemma (in topology0) neigh_filter:\n  assumes \"x\\<in>\\<Union>T\"\n  defines \"Neigh\\<equiv>{U\\<in>Pow(\\<Union>T). x\\<in>int(U)}\"\n  shows \"Neigh {is a filter on}\\<Union>T\" and \"Neigh \\<rightarrow>\\<^sub>F x\"\n",
        "proof": "proof-\n  {\n    fix A B\n    assume p:\"A\\<in>Neigh\" \"B\\<in>Neigh\"\n    have \"A\\<inter>B\\<in>Neigh\"\n    proof-\n      from p have \"A\\<inter>B\\<in>Pow(\\<Union>T)\" using Neigh_def by auto\n      moreover\n      {from p have \"x\\<in>int(A)\" \"x\\<in>int(B)\" using Neigh_def by auto\n      then have \"x\\<in>int(A)\\<inter>int(B)\" by auto\n      moreover\n      { have \"int(A)\\<inter>int(B)\\<subseteq>A\\<inter>B\" using Top_2_L1 by auto\n        moreover have \"int(A)\\<inter>int(B)\\<in>T\" \n          using Top_2_L2 topSpaceAssum IsATopology_def by blast\n        ultimately have \"int(A)\\<inter>int(B)\\<subseteq>int(A\\<inter>B)\" using Top_2_L5 by auto}\n        ultimately have \"x\\<in>int(A\\<inter>B)\" by auto\n      }\n      ultimately show ?thesis using Neigh_def by auto\n    qed\n    }\n  moreover\n  {\n    fix A B\n    assume A: \"A\\<in>Neigh\" and B: \"B\\<in>Pow(\\<Union>T)\" and sub: \"A\\<subseteq>B\"\n    from sub have \"int(A)\\<in>T\" \"int(A)\\<subseteq>B\" using Top_2_L2 Top_2_L1 \n      by auto \n    then have \"int(A)\\<subseteq>int(B)\" using Top_2_L5  by auto\n    with A have \"x\\<in>int(B)\" using Neigh_def by auto\n    with B have \"B\\<in>Neigh\" using Neigh_def by auto\n    }\n  moreover\n  {\n    assume \"0\\<in>Neigh\"\n    then have \"x\\<in>Interior(0,T)\" using Neigh_def by auto\n    then have \"x\\<in>0\" using Top_2_L1 by auto\n    then have \"False\" by auto\n    }\n  then have \"0\\<notin>Neigh\" by auto\n  moreover\n  have \"\\<Union>T\\<in>T\" using topSpaceAssum IsATopology_def by auto\n  then have \"Interior(\\<Union>T,T)=\\<Union>T\" using Top_2_L3 by auto\n  with assms(1) have ab: \"\\<Union>T\\<in>Neigh\" unfolding Neigh_def by auto\n  moreover have \"Neigh\\<subseteq>Pow(\\<Union>T)\" using Neigh_def by auto\n  ultimately show \"Neigh {is a filter on} \\<Union>T\" using IsFilter_def \n    by auto\n  moreover from ab have \"\\<Union>Neigh=\\<Union>T\" unfolding Neigh_def by auto\n  ultimately show \"Neigh \\<rightarrow>\\<^sub>F x\" using FilterConverges_def assms(1) Neigh_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2162
    },
    "1949": {
        "type": "theorem",
        "text": "text\\<open>A sufficient condition for a filter to converge to a point.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} \\<Union>T\" and \"C {is a base filter} \\<FF>\"\n    and \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>C. D\\<subseteq>U)\" and \"x\\<in>\\<Union>T\"\n  ",
        "using": [
            "assms(3)",
            "IsBaseFilter_def",
            "IsFilter_def",
            "FilterConverges_def"
        ],
        "statement": "theorem (in topology0) convergence_filter_base2:\n  assumes \"\\<FF> {is a filter on} \\<Union>T\" and \"C {is a base filter} \\<FF>\"\n    and \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>C. D\\<subseteq>U)\" and \"x\\<in>\\<Union>T\"\n  shows \"\\<FF> \\<rightarrow>\\<^sub>F x\"\n",
        "proof": "proof-\n  {\n    fix U\n    assume AS: \"U\\<in>Pow(\\<Union>T)\" \"x\\<in>int(U)\"\n    then obtain D where pD:\"D\\<in>C\" and s:\"D\\<subseteq>U\" using assms(3) by blast\n    with assms(2) AS have \"D\\<in>\\<FF>\" and \"D\\<subseteq>U\" and \"U\\<in>Pow(\\<Union>T)\" \n      using IsBaseFilter_def by auto\n    with assms(1) have \"U\\<in>\\<FF>\" using IsFilter_def by auto\n  }\n  with assms(1,4) show ?thesis using FilterConverges_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2163
    },
    "1950": {
        "type": "theorem",
        "text": "text\\<open>A necessary and sufficient condition for a filter to converge to a point.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} \\<Union>T\" and \"C {is a base filter} \\<FF>\"\n  ",
        "using": [
            "convergence_filter_base1",
            "convergence_filter_base2"
        ],
        "statement": "theorem (in topology0) convergence_filter_base_eq:\n  assumes \"\\<FF> {is a filter on} \\<Union>T\" and \"C {is a base filter} \\<FF>\"\n  shows \"(\\<FF> \\<rightarrow>\\<^sub>F x) \\<longleftrightarrow> ((\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>C. D\\<subseteq>U)) \\<and> x\\<in>\\<Union>T)\"\n",
        "proof": "proof\n  assume \"\\<FF> \\<rightarrow>\\<^sub>F x\"\n  with assms show \"((\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>C. D\\<subseteq>U)) \\<and> x\\<in>\\<Union>T)\"\n    using convergence_filter_base1 by simp  \n  next \n  assume \"(\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>C. D\\<subseteq>U)) \\<and> x\\<in>\\<Union>T\"\n  with assms show \"\\<FF> \\<rightarrow>\\<^sub>F x\" using convergence_filter_base2\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2164
    },
    "1951": {
        "type": "definition",
        "text": "text\\<open>Let's build now a net from a filter, such that both converge to the same points.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  NetOfFilter (\"Net(_)\" 40) where\n  \"\\<FF> {is a filter on} \\<Union>\\<FF> \\<Longrightarrow> Net(\\<FF>) \\<equiv> \n    \\<langle>{\\<langle>A,fst(A)\\<rangle>. A\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}},{\\<langle>A,B\\<rangle>\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}\\<times>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}. snd(B)\\<subseteq>snd(A)}\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2165
    },
    "1952": {
        "type": "theorem",
        "text": "text\\<open>Net of a filter is indeed a net.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} X\"\n  ",
        "using": [
            "IsFilter_def",
            "function_def",
            "relation_def",
            "function_imp_Pi",
            "fun_weaken_type",
            "refl_def",
            "dom",
            "trans_def",
            "assms",
            "p",
            "IsDirectedSet_def",
            "IsNet_def",
            "NetOfFilter_def",
            "uu"
        ],
        "statement": "theorem net_of_filter_is_net:\n  assumes \"\\<FF> {is a filter on} X\"\n  shows \"(Net(\\<FF>)) {is a net on} X\"\n",
        "proof": "proof-\n  from assms have \"X\\<in>\\<FF>\" \"\\<FF>\\<subseteq>Pow(X)\" using IsFilter_def by auto\n  then have uu:\"\\<Union>\\<FF>=X\" by blast\n  let ?f = \"{\\<langle>A,fst(A)\\<rangle>. A\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}}\"\n  let ?r = \"{\\<langle>A,B\\<rangle>\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}\\<times>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}. snd(B)\\<subseteq>snd(A)}\"\n  have \"function(?f)\" using function_def by auto\n  moreover have \"relation(?f)\" using relation_def by auto\n  ultimately  have \"?f:domain(?f)\\<rightarrow>range(?f)\" using function_imp_Pi \n    by auto\n  have dom:\"domain(?f)={\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}\" by auto\n  have \"range(?f)\\<subseteq>\\<Union>\\<FF>\" by auto\n  with \\<open>?f:domain(?f)\\<rightarrow>range(?f)\\<close> have \"?f:domain(?f)\\<rightarrow>\\<Union>\\<FF>\" using fun_weaken_type by auto\n  moreover\n  {\n    {\n      fix t\n      assume pp:\"t\\<in>domain(?f)\"\n      then have \"snd(t)\\<subseteq>snd(t)\" by auto\n      with dom pp have \"\\<langle>t,t\\<rangle>\\<in>?r\" by auto\n    }\n    then have \"refl(domain(?f),?r)\" using refl_def by auto\n    moreover\n    {\n      fix t1 t2 t3\n      assume \"\\<langle>t1,t2\\<rangle>\\<in>?r\" \"\\<langle>t2,t3\\<rangle>\\<in>?r\"\n      then have \"snd(t3)\\<subseteq>snd(t1)\" \"t1\\<in>domain(?f)\" \"t3\\<in>domain(?f)\" using dom by auto\n      then have \"\\<langle>t1,t3\\<rangle>\\<in>?r\" by auto\n    }\n    then have \"trans(?r)\" using trans_def by auto\n    moreover\n    {\n      fix x y\n      assume as:\"x\\<in>domain(?f)\"\"y\\<in>domain(?f)\"\n      then have \"snd(x)\\<in>\\<FF>\" \"snd(y)\\<in>\\<FF>\" by auto\n      then have p:\"snd(x)\\<inter>snd(y)\\<in>\\<FF>\" using assms IsFilter_def by auto\n      {\n        assume \"snd(x)\\<inter>snd(y)=0\"\n        with p have \"0\\<in>\\<FF>\" by auto\n        then have \"False\" using assms IsFilter_def by auto\n      }\n      then have \"snd(x)\\<inter>snd(y)\\<noteq>0\" by auto\n      then obtain xy where \"xy\\<in>snd(x)\\<inter>snd(y)\" by auto\n      then have \"xy\\<in>snd(x)\\<inter>snd(y)\" \"\\<langle>xy,snd(x)\\<inter>snd(y)\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>\" using p by auto\n      then have \"\\<langle>xy,snd(x)\\<inter>snd(y)\\<rangle>\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}\" by auto\n      with dom have d:\"\\<langle>xy,snd(x)\\<inter>snd(y)\\<rangle>\\<in>domain(?f)\" by auto\n      with as have \"\\<langle>x,\\<langle>xy,snd(x)\\<inter>snd(y)\\<rangle>\\<rangle>\\<in>?r \\<and> \\<langle>y,\\<langle>xy,snd(x)\\<inter>snd(y)\\<rangle>\\<rangle>\\<in>?r\" by auto\n      with d have \"\\<exists>z\\<in>domain(?f). \\<langle>x,z\\<rangle>\\<in>?r \\<and> \\<langle>y,z\\<rangle>\\<in>?r\"  by blast\n    }\n    then have \"\\<forall>x\\<in>domain(?f). \\<forall>y\\<in>domain(?f). \\<exists>z\\<in>domain(?f). \\<langle>x,z\\<rangle>\\<in>?r \\<and> \\<langle>y,z\\<rangle>\\<in>?r\" by blast\n    ultimately have \"?r directs domain(?f)\" using IsDirectedSet_def by blast\n  }\n  moreover\n  {\n    have p:\"X\\<in>\\<FF>\" and \"0\\<notin>\\<FF>\" using assms IsFilter_def by auto\n    then have \"X\\<noteq>0\" by auto\n    then obtain q where \"q\\<in>X\" by auto\n    with p dom have \"\\<langle>q,X\\<rangle>\\<in>domain(?f)\" by auto\n    then have \"domain(?f)\\<noteq>0\" by blast\n  }\n  ultimately have \"\\<langle>?f,?r\\<rangle> {is a net on}\\<Union>\\<FF>\" using IsNet_def by auto\n  then show \"(Net(\\<FF>)) {is a net on} X\" using NetOfFilter_def assms uu by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2166
    },
    "1953": {
        "type": "theorem",
        "text": "text\\<open>If a filter converges to some point then its net converges to the same point.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} \\<Union>T\" and \"\\<FF> \\<rightarrow>\\<^sub>F x\"\n  ",
        "using": [
            "IsFilter_def",
            "NetOfFilter_def",
            "uu",
            "ZF_fun_from_total",
            "net_of_filter_is_net",
            "FilterConverges_def",
            "Top_2_L1",
            "dom_def",
            "func1_1_L1",
            "ZF_fun_from_tot_val",
            "NetConverges_def"
        ],
        "statement": "theorem (in topology0) filter_conver_net_of_filter_conver:\n  assumes \"\\<FF> {is a filter on} \\<Union>T\" and \"\\<FF> \\<rightarrow>\\<^sub>F x\"\n  shows \"(Net(\\<FF>)) \\<rightarrow>\\<^sub>N x\"\n",
        "proof": "proof-\n  from assms have \"\\<Union>T\\<in>\\<FF>\" \"\\<FF>\\<subseteq>Pow(\\<Union>T)\" using IsFilter_def by auto\n  then have uu: \"\\<Union>\\<FF>=\\<Union>T\" by blast\n  from assms(1) have func: \"fst(Net(\\<FF>))={\\<langle>A,fst(A)\\<rangle>. A\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}}\"\n    and dir: \"snd(Net(\\<FF>))={\\<langle>A,B\\<rangle>\\<in>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}\\<times>{\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}. snd(B)\\<subseteq>snd(A)}\"\n    using NetOfFilter_def uu by auto\n  then have dom_def: \"domain(fst(Net(\\<FF>)))={\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F}\" by auto\n  from func have fun: \"fst(Net(\\<FF>)): {\\<langle>x,F\\<rangle>\\<in>(\\<Union>\\<FF>)\\<times>\\<FF>. x\\<in>F} \\<rightarrow> (\\<Union>\\<FF>)\"\n    using ZF_fun_from_total by simp\n  from assms(1) have NN: \"(Net(\\<FF>)) {is a net on}\\<Union>T\" using net_of_filter_is_net \n    by auto\n  moreover from assms have \"x\\<in>\\<Union>T\" using FilterConverges_def \n    by auto\n  moreover\n  {\n    fix U\n    assume AS: \"U\\<in>Pow(\\<Union>T)\" \"x\\<in>int(U)\"\n    with assms have \"U\\<in>\\<FF>\" \"x\\<in>U\" using Top_2_L1 FilterConverges_def by auto\n    then have pp: \"\\<langle>x,U\\<rangle>\\<in>domain(fst(Net(\\<FF>)))\" using dom_def by auto\n    {\n      fix m\n      assume ASS: \"m\\<in>domain(fst(Net(\\<FF>)))\" \"\\<langle>\\<langle>x,U\\<rangle>,m\\<rangle>\\<in>snd(Net(\\<FF>))\"\n      from ASS(1) fun func have \"fst(Net(\\<FF>))`(m) = fst(m)\" \n        using func1_1_L1 ZF_fun_from_tot_val by simp \n      with dir ASS have \"fst(Net(\\<FF>))`(m) \\<in> U\" using dom_def by auto    \n    }\n    then have \"\\<forall>m\\<in>domain(fst(Net(\\<FF>))). (\\<langle>\\<langle>x,U\\<rangle>,m\\<rangle>\\<in>snd(Net(\\<FF>)) \\<longrightarrow> fst(Net(\\<FF>))`m\\<in>U)\" by auto\n    with pp have \"\\<exists>t\\<in>domain(fst(Net(\\<FF>))). \\<forall>m\\<in>domain(fst(Net(\\<FF>))). (\\<langle>t,m\\<rangle>\\<in>snd(Net(\\<FF>)) \\<longrightarrow> fst(Net(\\<FF>))`m\\<in>U)\"\n      by auto\n  }\n  then have \"\\<forall>U\\<in>Pow(\\<Union>T). \n      (x\\<in>int(U) \\<longrightarrow> (\\<exists>t\\<in>domain(fst(Net(\\<FF>))). \\<forall>m\\<in>domain(fst(Net(\\<FF>))). (\\<langle>t,m\\<rangle>\\<in>snd(Net(\\<FF>)) \\<longrightarrow> fst(Net(\\<FF>))`m\\<in>U)))\"\n      by auto\n  ultimately show ?thesis using NetConverges_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2167
    },
    "1954": {
        "type": "theorem",
        "text": "text\\<open>If a net converges to a point, then a filter also converges to a point.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on}\\<Union>T\" and \"(Net(\\<FF>)) \\<rightarrow>\\<^sub>N x\"\n  ",
        "using": [
            "IsFilter_def",
            "assms",
            "NetConverges_def",
            "net_of_filter_is_net",
            "NetOfFilter_def",
            "tFF",
            "reg",
            "t_def",
            "function_def",
            "function_apply_equality",
            "FilterConverges_def",
            "assms(1)"
        ],
        "statement": "theorem (in topology0) net_of_filter_conver_filter_conver:\n  assumes \"\\<FF> {is a filter on}\\<Union>T\" and \"(Net(\\<FF>)) \\<rightarrow>\\<^sub>N x\"\n  shows \"\\<FF> \\<rightarrow>\\<^sub>F x\"\n",
        "proof": "proof-\n  from assms have \"\\<Union>T\\<in>\\<FF>\" \"\\<FF>\\<subseteq>Pow(\\<Union>T)\" using IsFilter_def by auto\n  then have uu: \"\\<Union>\\<FF>=\\<Union>T\" by blast\n  have \"x\\<in>\\<Union>T\" using assms NetConverges_def net_of_filter_is_net by auto\n  moreover\n  {\n    fix U\n    assume \"U\\<in>Pow(\\<Union>T)\" \"x\\<in>int(U)\"\n    then obtain t where t: \"t\\<in>domain(fst(Net(\\<FF>)))\" and \n      reg: \"\\<forall>m\\<in>domain(fst(Net(\\<FF>))). \\<langle>t,m\\<rangle>\\<in>snd(Net(\\<FF>)) \\<longrightarrow> fst(Net(\\<FF>))`m\\<in>U\"\n        using assms net_of_filter_is_net NetConverges_def by blast\n    with assms(1) uu obtain t1 t2 where t_def: \"t=\\<langle>t1,t2\\<rangle>\" and \"t1\\<in>t2\" and tFF: \"t2\\<in>\\<FF>\" \n      using NetOfFilter_def by auto\n    {\n      fix s\n      assume \"s\\<in>t2\"\n      then have \"\\<langle>s,t2\\<rangle>\\<in>{\\<langle>q1,q2\\<rangle>\\<in>\\<Union>\\<FF>\\<times>\\<FF>. q1\\<in>q2}\" using tFF by auto\n      moreover\n      from assms(1) uu have \"domain(fst(Net(\\<FF>)))={\\<langle>q1,q2\\<rangle>\\<in>\\<Union>\\<FF>\\<times>\\<FF>. q1\\<in>q2}\" using NetOfFilter_def\n        by auto\n      ultimately\n      have tt: \"\\<langle>s,t2\\<rangle>\\<in>domain(fst(Net(\\<FF>)))\" by auto\n      moreover\n      from assms(1) uu t t_def tt have \"\\<langle>\\<langle>t1,t2\\<rangle>,\\<langle>s,t2\\<rangle>\\<rangle>\\<in>snd(Net(\\<FF>))\" using NetOfFilter_def\n        by auto\n      ultimately\n      have \"fst(Net(\\<FF>))`\\<langle>s,t2\\<rangle>\\<in>U\" using reg t_def by auto\n      moreover\n      from assms(1) uu have \"function(fst(Net(\\<FF>)))\" using NetOfFilter_def function_def\n        by auto\n      moreover\n      from tt assms(1) uu have \"\\<langle>\\<langle>s,t2\\<rangle>,s\\<rangle>\\<in>fst(Net(\\<FF>))\" using NetOfFilter_def by auto\n      ultimately\n      have \"s\\<in>U\" using NetOfFilter_def function_apply_equality by auto\n    }\n    then have \"t2\\<subseteq>U\" by auto\n    with tFF assms(1) \\<open>U\\<in>Pow(\\<Union>T)\\<close> have \"U\\<in>\\<FF>\" using IsFilter_def by auto\n  }\n  then have \"{U\\<in>Pow(\\<Union>T). x\\<in>int(U)} \\<subseteq> \\<FF>\" by auto\n  ultimately\n  show ?thesis using FilterConverges_def assms(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2168
    },
    "1955": {
        "type": "theorem",
        "text": "text\\<open>A filter converges to a point if and only if its net converges to the point.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on}\\<Union>T\"\n  ",
        "using": [
            "filter_conver_net_of_filter_conver",
            "net_of_filter_conver_filter_conver",
            "assms"
        ],
        "statement": "theorem (in topology0) filter_conver_iff_net_of_filter_conver:\n  assumes \"\\<FF> {is a filter on}\\<Union>T\"\n  shows \"(\\<FF> \\<rightarrow>\\<^sub>F x) \\<longleftrightarrow> ((Net(\\<FF>)) \\<rightarrow>\\<^sub>N x)\"\n  ",
        "proof": "using filter_conver_net_of_filter_conver net_of_filter_conver_filter_conver assms \n    by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2169
    },
    "1956": {
        "type": "theorem",
        "text": "text\\<open>Filter of a net is indeed a filter\\<close>\n",
        "assumes": "assumes \"N {is a net on} X\"\n  ",
        "using": [
            "apply_funtype",
            "x_def",
            "IsNet_def",
            "assms",
            "trans_def",
            "A_def",
            "B_def",
            "sd_def",
            "d_def",
            "sat",
            "basic_filter",
            "FilterOfNet_def"
        ],
        "statement": "theorem filter_of_net_is_filter:\n  assumes \"N {is a net on} X\"\n  shows \"(Filter N..X) {is a filter on} X\" and \n    \"{{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t0}}. t0\\<in>domain(fst(N))} {is a base filter} (Filter N..X)\"\n",
        "proof": "proof -\n  let ?C = \"{{fst(N)`(snd(s)). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t0}}. t0\\<in>domain(fst(N))}\"\n  have \"?C\\<subseteq>Pow(X)\"\n  proof -\n    {\n      fix t\n      assume \"t\\<in>?C\"\n      then obtain t1 where \"t1\\<in>domain(fst(N))\" and \n        t_Def: \"t={fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t1}}\" \n        by auto\n      {\n        fix x\n        assume \"x\\<in>t\" \n        with t_Def obtain ss where \"ss\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t1}\" and \n          x_def: \"x = fst(N)`(snd(ss))\" by blast \n        then have \"snd(ss) \\<in> domain(fst(N))\" by auto\n        from assms have \"fst(N):domain(fst(N))\\<rightarrow>X\" unfolding IsNet_def by simp\n          with \\<open>snd(ss) \\<in> domain(fst(N))\\<close> have \"x\\<in>X\" using apply_funtype x_def \n        by auto \n      }\n      hence \"t\\<subseteq>X\" by auto\n    }\n    thus ?thesis by blast\n  qed\n  have sat: \"?C {satisfies the filter base condition}\"\n  proof -\n    from assms obtain t1 where \"t1\\<in>domain(fst(N))\" using IsNet_def by blast\n    hence \"{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t1}}\\<in>?C\" \n      by auto\n    hence \"?C\\<noteq>0\" by auto\n    moreover\n    {\n      fix U\n      assume \"U\\<in>?C\"\n      then obtain q where q_dom: \"q\\<in>domain(fst(N))\" and \n        U_def: \"U={fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=q}}\" \n        by blast\n      with assms have \"\\<langle>q,q\\<rangle>\\<in>snd(N) \\<and> fst(\\<langle>q,q\\<rangle>)=q\" unfolding IsNet_def IsDirectedSet_def refl_def \n        by auto\n      with q_dom have \"\\<langle>q,q\\<rangle>\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=q}\" \n        by auto\n      with U_def have \"fst(N)`(snd(\\<langle>q,q\\<rangle>)) \\<in> U\" by blast\n      hence \"U\\<noteq>0\" by auto \n    }\n    then have \"0\\<notin>?C\" by auto\n    moreover\n    have \"\\<forall>A\\<in>?C. \\<forall>B\\<in>?C. (\\<exists>D\\<in>?C. D\\<subseteq>A\\<inter>B)\"\n    proof\n      fix A\n      assume pA: \"A\\<in>?C\"\n      show \"\\<forall>B\\<in>?C. \\<exists>D\\<in>?C. D\\<subseteq>A\\<inter>B\"\n      proof\n        {\n          fix B\n          assume \"B\\<in>?C\"\n          with pA obtain qA qB where per: \"qA\\<in>domain(fst(N))\" \"qB\\<in>domain(fst(N))\" and \n            A_def: \"A={fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=qA}}\" and\n            B_def: \"B={fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=qB}}\" \n              by blast\n          have dir: \"snd(N) directs domain(fst(N))\" using assms IsNet_def by auto\n          with per obtain qD where ine: \"\\<langle>qA,qD\\<rangle>\\<in>snd(N)\" \"\\<langle>qB,qD\\<rangle>\\<in>snd(N)\" and \n          perD: \"qD\\<in>domain(fst(N))\" unfolding IsDirectedSet_def\n            by blast\n          let ?D = \"{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=qD}}\"\n          from perD have \"?D\\<in>?C\" by auto\n          moreover\n          {\n            fix d\n            assume \"d\\<in>?D\"\n            then obtain sd where \"sd\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=qD}\" and \n              d_def: \"d=fst(N)`snd(sd)\" by blast\n            then have sdN: \"sd\\<in>snd(N)\" and qdd: \"fst(sd)=qD\" and \"sd\\<in>domain(fst(N))\\<times>domain(fst(N))\" \n              by auto\n            then obtain qI aa where \"sd = \\<langle>aa,qI\\<rangle>\" \"qI \\<in> domain(fst(N))\" \"aa \\<in> domain(fst(N))\" \n              by auto\n            with qdd have sd_def: \"sd=\\<langle>qD,qI\\<rangle>\" and qIdom: \"qI\\<in>domain(fst(N))\" by auto\n            with sdN have \"\\<langle>qD,qI\\<rangle>\\<in>snd(N)\" by auto\n            from dir have \"trans(snd(N))\" unfolding IsDirectedSet_def by auto\n            then have \"\\<langle>qA,qD\\<rangle>\\<in>snd(N) \\<and> \\<langle>qD,qI\\<rangle>\\<in>snd(N) \\<longrightarrow> \\<langle>qA,qI\\<rangle>\\<in>snd(N)\" and \n              \"\\<langle>qB,qD\\<rangle>\\<in>snd(N) \\<and> \\<langle>qD,qI\\<rangle>\\<in>snd(N)\\<longrightarrow>\\<langle>qB,qI\\<rangle>\\<in>snd(N)\"\n              using trans_def by auto \n            with ine \\<open>\\<langle>qD,qI\\<rangle>\\<in>snd(N)\\<close> have \"\\<langle>qA,qI\\<rangle>\\<in>snd(N)\" \"\\<langle>qB,qI\\<rangle>\\<in>snd(N)\" by auto\n            with qIdom per have \"\\<langle>qA,qI\\<rangle>\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=qA}\"\n              \"\\<langle>qB,qI\\<rangle>\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=qB}\" \n              by auto\n            then have \"fst(N)`(qI) \\<in> A\\<inter>B\" using A_def B_def by auto\n            then have \"fst(N)`(snd(sd)) \\<in> A\\<inter>B\" using sd_def by auto\n            then have \"d \\<in> A\\<inter>B\" using d_def by auto\n          }\n          then have \"?D \\<subseteq> A\\<inter>B\" by blast\n          ultimately show \"\\<exists>D\\<in>?C. D\\<subseteq>A\\<inter>B\" by blast\n        }\n      qed\n    qed\n    ultimately\n    show ?thesis unfolding SatisfiesFilterBase_def by blast\n  qed\n  have \n    Base: \"?C {is a base filter} {A\\<in>Pow(X). \\<exists>D\\<in>?C. D\\<subseteq>A}\" \"\\<Union>{A\\<in>Pow(X). \\<exists>D\\<in>?C. D\\<subseteq>A}=X\"\n  proof -\n    from \\<open>?C\\<subseteq>Pow(X)\\<close> sat show \"?C {is a base filter} {A\\<in>Pow(X). \\<exists>D\\<in>?C. D\\<subseteq>A}\" \n      by (rule base_unique_filter_set3)\n    from \\<open>?C\\<subseteq>Pow(X)\\<close> sat show \"\\<Union>{A\\<in>Pow(X). \\<exists>D\\<in>?C. D\\<subseteq>A}=X\"\n      by (rule base_unique_filter_set3)\n  qed \n  with sat show \"(Filter N..X) {is a filter on} X\" \n    using sat basic_filter FilterOfNet_def assms by auto\n  from Base(1) show \"?C {is a base filter} (Filter N..X)\" \n    using FilterOfNet_def assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2170
    },
    "1957": {
        "type": "theorem",
        "text": "text\\<open>Convergence of a net implies the convergence of the corresponding filter.\\<close>\n",
        "assumes": "assumes \"N {is a net on} \\<Union>T\" and \"N \\<rightarrow>\\<^sub>N x\"\n  ",
        "using": [
            "filter_of_net_is_filter",
            "NetConverges_def"
        ],
        "statement": "theorem (in topology0) net_conver_filter_of_net_conver:\n  assumes \"N {is a net on} \\<Union>T\" and \"N \\<rightarrow>\\<^sub>N x\"\n  shows \"(Filter N..(\\<Union>T)) \\<rightarrow>\\<^sub>F x\"\n",
        "proof": "proof -\n  let ?C = \"{{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t}}. \n      t\\<in>domain(fst(N))}\"\n  from assms(1) have  \n    \"(Filter N..(\\<Union>T)) {is a filter on} (\\<Union>T)\" and \"?C {is a base filter} Filter N..(\\<Union>T)\"\n    using filter_of_net_is_filter by auto \n  moreover have \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>?C. D\\<subseteq>U)\"\n  proof -\n    {\n      fix U\n      assume \"U\\<in>Pow(\\<Union>T)\" \"x\\<in>int(U)\"\n      with assms have \"\\<exists>t\\<in>domain(fst(N)). (\\<forall>m\\<in>domain(fst(N)). (\\<langle>t,m\\<rangle>\\<in>snd(N) \\<longrightarrow> fst(N)`m\\<in>U))\"\n        using NetConverges_def by auto\n        then obtain t where \"t\\<in>domain(fst(N))\" and \n          reg: \"\\<forall>m\\<in>domain(fst(N)). (\\<langle>t,m\\<rangle>\\<in>snd(N) \\<longrightarrow> fst(N)`m\\<in>U)\" by auto\n      {\n        fix f\n        assume \"f\\<in>{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t}}\"\n        then obtain s where \"s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t}\" and \n          f_def: \"f=fst(N)`snd(s)\" by blast\n        hence \"s\\<in>domain(fst(N))\\<times>domain(fst(N))\" and \"s\\<in>snd(N)\" and \"fst(s)=t\" \n          by auto\n        hence \"s=\\<langle>t,snd(s)\\<rangle>\" and \"snd(s)\\<in>domain(fst(N))\" by auto\n        with \\<open>s\\<in>snd(N)\\<close> reg have \"fst(N)`snd(s)\\<in>U\" by auto\n        with f_def have \"f\\<in>U\" by auto\n      }\n      hence \"{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t}} \\<subseteq> U\" \n        by blast\n      with \\<open>t\\<in>domain(fst(N))\\<close> have \"\\<exists>D\\<in>?C. D\\<subseteq>U\"\n        by auto\n    } thus \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>?C. D\\<subseteq>U)\"  by auto\n  qed\n  moreover from assms have \"x\\<in>\\<Union>T\" using NetConverges_def by auto\n  ultimately show \"(Filter N..(\\<Union>T)) \\<rightarrow>\\<^sub>F x\" by (rule convergence_filter_base2)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2171
    },
    "1958": {
        "type": "theorem",
        "text": "text\\<open>Convergence of a filter corresponding to a net implies convergence of the net.\\<close>\n",
        "assumes": "assumes \"N {is a net on} \\<Union>T\" and \"(Filter N..(\\<Union>T)) \\<rightarrow>\\<^sub>F x\"\n  ",
        "using": [
            "filter_of_net_is_filter",
            "NetConverges_def",
            "assms(1)"
        ],
        "statement": " theorem (in topology0) filter_of_net_conver_net_conver:\n  assumes \"N {is a net on} \\<Union>T\" and \"(Filter N..(\\<Union>T)) \\<rightarrow>\\<^sub>F x\"\n  shows \"N \\<rightarrow>\\<^sub>N x\"\n",
        "proof": "proof -\n  let ?C = \"{{fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=t}}. \n      t\\<in>domain(fst(N))}\"\n  from assms have I: \"(Filter N..(\\<Union>T)) {is a filter on} (\\<Union>T)\"\n    \"?C {is a base filter} (Filter N..(\\<Union>T))\" \"(Filter N..(\\<Union>T)) \\<rightarrow>\\<^sub>F x\"\n    using filter_of_net_is_filter by auto\n  then have reg: \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>?C. D\\<subseteq>U)\"\n    by (rule convergence_filter_base1)\n  from I have \"x\\<in>\\<Union>T\" by (rule convergence_filter_base1)\n  moreover\n  {\n    fix U\n    assume \"U\\<in>Pow(\\<Union>T)\" \"x\\<in>int(U)\"\n    with reg have \"\\<exists>D\\<in>?C. D\\<subseteq>U\" by auto\n    then obtain D where \"D\\<in>?C\" \"D\\<subseteq>U\"\n      by auto\n    then obtain td where \"td\\<in>domain(fst(N))\" and \n      D_def: \"D={fst(N)`snd(s). s\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=td}}\"\n      by auto\n    {\n      fix m\n      assume \"m\\<in>domain(fst(N))\" \"\\<langle>td,m\\<rangle>\\<in>snd(N)\"\n      with \\<open>td\\<in>domain(fst(N))\\<close> have \n        \"\\<langle>td,m\\<rangle>\\<in>{s\\<in>domain(fst(N))\\<times>domain(fst(N)). s\\<in>snd(N) \\<and> fst(s)=td}\"\n        by auto\n      with D_def have \"fst(N)`m\\<in>D\" by auto\n      with \\<open>D\\<subseteq>U\\<close> have \"fst(N)`m\\<in>U\" by auto\n    }\n    then have \"\\<forall>m\\<in>domain(fst(N)). \\<langle>td,m\\<rangle>\\<in>snd(N) \\<longrightarrow> fst(N)`m\\<in>U\" by auto\n    with \\<open>td\\<in>domain(fst(N))\\<close> have \n      \"\\<exists>t\\<in>domain(fst(N)). \\<forall>m\\<in>domain(fst(N)). \\<langle>t,m\\<rangle>\\<in>snd(N) \\<longrightarrow> fst(N)`m\\<in>U\"\n      by auto\n  }\n  then have \n    \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> \n      (\\<exists>t\\<in>domain(fst(N)). \\<forall>m\\<in>domain(fst(N)). \\<langle>t,m\\<rangle>\\<in>snd(N) \\<longrightarrow> fst(N)`m\\<in>U)\"\n      by auto\n  ultimately show \"?thesis\" using NetConverges_def assms(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2172
    },
    "1959": {
        "type": "lemma",
        "text": "text\\<open>We can use  \\<open>topology0\\<close> locale with filters.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} \\<Union>\\<FF>\"\n  ",
        "using": [
            "top_of_filter",
            "topology0_def",
            "assms"
        ],
        "statement": "lemma topology0_filter:\n  assumes \"\\<FF> {is a filter on} \\<Union>\\<FF>\"\n  shows \"topology0(\\<FF> \\<union> {0})\"\n  ",
        "proof": "using top_of_filter topology0_def assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2173
    },
    "1960": {
        "type": "lemma",
        "text": "text\\<open>Each point of a the union of a filter is a limit of that filter.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} \\<Union>\\<FF>\" and \"x\\<in>\\<Union>\\<FF>\"\n  ",
        "using": [
            "topology0_def",
            "top_of_filter",
            "topology0.Top_2_L2",
            "topology0.Top_2_L1",
            "assms(1)",
            "IsFilter_def",
            "topology0.FilterConverges_def"
        ],
        "statement": "lemma lim_filter_top_of_filter:\n  assumes \"\\<FF> {is a filter on} \\<Union>\\<FF>\" and \"x\\<in>\\<Union>\\<FF>\"\n  shows \"\\<FF> \\<rightarrow>\\<^sub>F x {in} (\\<FF>\\<union>{0})\"\n",
        "proof": "proof-\n  have \"\\<Union>\\<FF>=\\<Union>(\\<FF>\\<union>{0})\" by auto\n  with assms(1) have assms1: \"\\<FF> {is a filter on} \\<Union>(\\<FF>\\<union>{0})\" by auto\n  {\n    fix U\n    assume \"U\\<in>Pow(\\<Union>(\\<FF>\\<union>{0}))\" \"x\\<in>Interior(U,(\\<FF>\\<union>{0}))\"\n    with assms(1) have \"Interior(U,(\\<FF>\\<union>{0}))\\<in>\\<FF>\" using topology0_def top_of_filter\n      topology0.Top_2_L2 by blast\n    moreover\n    from assms(1) have \"Interior(U,(\\<FF>\\<union>{0}))\\<subseteq>U\" using topology0_def top_of_filter\n      topology0.Top_2_L1 by auto\n    moreover\n    from \\<open>U\\<in>Pow(\\<Union>(\\<FF>\\<union>{0}))\\<close> have \"U\\<in>Pow(\\<Union>\\<FF>)\" by auto\n    ultimately have \"U\\<in>\\<FF>\" using assms(1) IsFilter_def by auto\n  }\n  with assms assms1 show ?thesis using topology0.FilterConverges_def top_of_filter\n    topology0_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2174
    },
    "1961": {
        "type": "definition",
        "text": "text\\<open> We define a neighborhood system as a function that takes each point $x\\in X$ and assigns it \n  a collection of subsets of $X$ which is called the neighborhoods of $x$. \n  The neighborhoods of a point $x$ form a filter that satisfies an additional\n  axiom that for every neighborhood $N$ of $x$ we can find another one $U$ such that $N$ \n  is a neighborhood of every point of $U$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsNeighSystem (\"_ {is a neighborhood system on} _\" 90)\n  where \"\\<M> {is a neighborhood system on} X \\<equiv> (\\<M> : X\\<rightarrow>Pow(Pow(X))) \\<and>\n  (\\<forall>x\\<in>X. (\\<M>`(x) {is a filter on} X) \\<and> (\\<forall>N\\<in>\\<M>`(x). x\\<in>N \\<and> (\\<exists>U\\<in>\\<M>`(x).\\<forall>y\\<in>U.(N\\<in>\\<M>`(y)) ) ))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2175
    },
    "1962": {
        "type": "lemma",
        "text": "text\\<open> A neighborhood system on $X$ consists of collections of subsets of $X$. \\<close>\n",
        "assumes": "assumes \"\\<M> {is a neighborhood system on} X\" and \"x\\<in>X\" and \"N\\<in>\\<M>`(x)\"\n  ",
        "using": [
            "apply_funtype",
            "IsNeighSystem_def"
        ],
        "statement": "lemma neighborhood_subset:\n  assumes \"\\<M> {is a neighborhood system on} X\" and \"x\\<in>X\" and \"N\\<in>\\<M>`(x)\"\n  shows \"N\\<subseteq>X\" and \"x\\<in>N\"\n",
        "proof": "proof -\n  from \\<open>\\<M> {is a neighborhood system on} X\\<close> have \"\\<M> : X\\<rightarrow>Pow(Pow(X))\"\n    unfolding IsNeighSystem_def by simp\n  with \\<open>x\\<in>X\\<close> have \"\\<M>`(x) \\<in> Pow(Pow(X))\" using apply_funtype by blast\n  with \\<open>N\\<in>\\<M>`(x)\\<close> show \"N\\<subseteq>X\" by blast\n  from assms show \"x\\<in>N\" using IsNeighSystem_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2176
    },
    "1963": {
        "type": "theorem",
        "text": "text\\<open>The collection of sets defined as above is indeed a topology. \\<close>\n",
        "assumes": "assumes \"\\<M> {is a neighborhood system on} X\"\n  defines Tdef: \"T \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  ",
        "using": [
            "Tdef"
        ],
        "statement": "theorem topology_from_neighs: \n  assumes \"\\<M> {is a neighborhood system on} X\"\n  defines Tdef: \"T \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  shows \"T {is a topology}\" and \"\\<Union>T = X\"\n",
        "proof": "proof -\n  { fix \\<UU> assume \"\\<UU> \\<in> Pow(T)\"\n    have \"\\<Union>\\<UU> \\<in> T\"\n    proof -\n      from \\<open>\\<UU> \\<in> Pow(T)\\<close> Tdef have \"\\<Union>\\<UU> \\<in> Pow(X)\" by blast\n      moreover\n      { fix x assume \"x \\<in> \\<Union>\\<UU>\"\n        then obtain U where \"U\\<in>\\<UU>\" and \"x\\<in>U\" by blast\n        with assms \\<open>\\<UU> \\<in> Pow(T)\\<close> \n        have \"U \\<in> \\<M>`(x)\" and \"U \\<subseteq> \\<Union>\\<UU>\" and  \"\\<M>`(x) {is a filter on} X\"\n          unfolding IsNeighSystem_def by auto\n        with \\<open>\\<Union>\\<UU> \\<in> Pow(X)\\<close> have \"\\<Union>\\<UU> \\<in> \\<M>`(x)\" unfolding IsFilter_def\n          by simp\n      } \n      ultimately show \"\\<Union>\\<UU> \\<in> T\" using Tdef by blast\n    qed \n  }        \n  moreover\n  { fix U V assume \"U\\<in>T\" and \"V\\<in>T\"\n    have \"U\\<inter>V \\<in> T\"\n    proof -\n      from Tdef \\<open>U\\<in>T\\<close>  \\<open>U\\<in>T\\<close> have \"U\\<inter>V \\<in> Pow(X)\" by auto \n      moreover\n      { fix x assume \"x \\<in> U\\<inter>V\"\n        with assms \\<open>U\\<in>T\\<close> \\<open>V\\<in>T\\<close> Tdef have \"U \\<in> \\<M>`(x)\" \"V \\<in> \\<M>`(x)\" and  \"\\<M>`(x) {is a filter on} X\"\n          unfolding IsNeighSystem_def by auto \n        then have \"U\\<inter>V \\<in> \\<M>`(x)\" unfolding IsFilter_def by simp\n      }\n      ultimately show \"U\\<inter>V \\<in>T\" using Tdef by simp\n    qed\n  }\n  ultimately show \"T {is a topology}\" unfolding IsATopology_def by blast \n  from assms show \"\\<Union>T = X\" unfolding IsNeighSystem_def IsFilter_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2178
    },
    "1964": {
        "type": "lemma",
        "text": "text\\<open> Some sources (like Wikipedia) define the open sets generated by a neighborhood system\n  \"as those sets containing a neighborhood of each of their points\". The next lemma shows that\n  this definition is equivalent to the one we are using.\\<close>\n",
        "assumes": "assumes \"\\<M> {is a neighborhood system on} X\"\n  ",
        "using": [],
        "statement": "lemma topology_from_neighs1:\n  assumes \"\\<M> {is a neighborhood system on} X\"\n  shows \"{U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)} = {U\\<in>Pow(X). \\<forall>x\\<in>U. \\<exists>V \\<in> \\<M>`(x). V\\<subseteq>U}\"\n",
        "proof": "proof\n  let ?T = \"{U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  let ?S = \"{U\\<in>Pow(X). \\<forall>x\\<in>U. \\<exists>V \\<in> \\<M>`(x). V\\<subseteq>U}\"\n  show \"?S\\<subseteq>?T\"\n  proof -\n    { fix U assume \"U\\<in>?S\"\n      then have \"U\\<in>Pow(X)\" by simp\n      moreover\n      from assms \\<open>U\\<in>?S\\<close> \\<open>U\\<in>Pow(X)\\<close> have \"\\<forall>x\\<in>U. U \\<in> \\<M>`(x)\"\n        unfolding IsNeighSystem_def IsFilter_def by blast \n      ultimately have \"U\\<in>?T\" by auto\n    } thus ?thesis by auto\n  qed\n  show \"?T\\<subseteq>?S\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2179
    },
    "1965": {
        "type": "definition",
        "text": "text\\<open>For a topology $T$ we define a neighborhood system of $T$ as a function that takes an $x\\in X=\\bigcup T$ \nand assigns it the collection of supersets of open sets containing $x$. \nWe call that the \"neighborhood system of $T$\"\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  NeighSystem (\"{neighborhood system of} _\" 91)\n  where \"{neighborhood system of} T \\<equiv> { \\<langle>x,{N\\<in>Pow(\\<Union>T).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>N)}\\<rangle>. x \\<in> \\<Union>T }\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2180
    },
    "1966": {
        "type": "lemma",
        "text": "text\\<open>The way we defined the neighborhood system of $T$ means that\n  it is a function on $\\bigcup T$. \\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_total"
        ],
        "statement": "lemma neigh_fun: shows \"({neighborhood system of} T): \\<Union>T \\<rightarrow> Pow(Pow(\\<Union>T))\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  have \"\\<forall>x\\<in>?X. {N\\<in>Pow(?X).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>N)} \\<in> Pow(Pow(?X))\"\n    by blast\n  then show ?thesis unfolding NeighSystem_def using ZF_fun_from_total\n    by simp\nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2181
    },
    "1967": {
        "type": "lemma",
        "text": "text\\<open>The value of the neighborhood system of $T$ at $x\\in \\bigcup T$ \n  is the collection of supersets of open sets containing $x$.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\"\n  ",
        "using": [
            "assms",
            "ZF_fun_from_tot_val1",
            "NeighSystem_def"
        ],
        "statement": "lemma neigh_val: assumes \"x\\<in>\\<Union>T\"\n  shows \"({neighborhood system of} T)`(x) = {N\\<in>Pow(\\<Union>T).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>N)}\"\n  ",
        "proof": "using assms ZF_fun_from_tot_val1 unfolding NeighSystem_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2182
    },
    "1968": {
        "type": "lemma",
        "text": "text\\<open> Another fact we will need is that for every $x\\in X=\\bigcup T$ the neighborhoods of $x$\n  form a filter \\<close>\n",
        "assumes": "assumes \"T {is a topology}\" and \"x \\<in> \\<Union>T\" \n  defines Mdef: \"\\<M> \\<equiv> {neighborhood system of} T\"\n  ",
        "using": [
            "carr_open",
            "IsATopology_def",
            "ZF_fun_from_tot_val1",
            "NeighSystem_def"
        ],
        "statement": "lemma neighs_is_filter:\n  assumes \"T {is a topology}\" and \"x \\<in> \\<Union>T\" \n  defines Mdef: \"\\<M> \\<equiv> {neighborhood system of} T\"\n  shows \"\\<M>`(x) {is a filter on} (\\<Union>T)\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  let ?\\<FF> = \"{V\\<in>Pow(?X).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>V)}\"\n  have \"0\\<notin>?\\<FF>\" by blast \n  moreover have \"?X\\<in>?\\<FF>\"\n  proof -\n    from assms \\<open>x\\<in>?X\\<close> have \"?X \\<in> Pow(?X)\" \"?X\\<in>T\" and \"x\\<in>?X \\<and> ?X\\<subseteq>?X\" using carr_open \n      by auto\n    hence \"\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>?X)\" by auto\n    thus ?thesis by auto\n  qed\n  moreover have \"\\<forall>A\\<in>?\\<FF>. \\<forall>B\\<in>?\\<FF>. A\\<inter>B \\<in> ?\\<FF>\"\n  proof -\n    { fix A B assume \"A\\<in>?\\<FF>\" \"B\\<in>?\\<FF>\"\n      then obtain U\\<^sub>A U\\<^sub>B where \"U\\<^sub>A\\<in>T\" \"x\\<in>U\\<^sub>A\" \"U\\<^sub>A\\<subseteq>A\" \"U\\<^sub>B\\<in>T\" \"x\\<in>U\\<^sub>B\" \"U\\<^sub>B\\<subseteq>B\" \n        by auto\n      with \\<open>T {is a topology}\\<close> \\<open>A\\<in>?\\<FF>\\<close> \\<open>B\\<in>?\\<FF>\\<close> have \"A\\<inter>B \\<in> Pow(?X)\" and \n        \"U\\<^sub>A\\<inter>U\\<^sub>B \\<in> T\" \"x \\<in> U\\<^sub>A\\<inter>U\\<^sub>B\" \"U\\<^sub>A\\<inter>U\\<^sub>B \\<subseteq> A\\<inter>B\" using IsATopology_def \n        by auto\n      hence \"A\\<inter>B \\<in> ?\\<FF>\" by blast\n    } thus ?thesis by blast\n  qed\n  moreover have \"\\<forall>B\\<in>?\\<FF>. \\<forall>C\\<in>Pow(?X). B\\<subseteq>C \\<longrightarrow> C\\<in>?\\<FF>\"\n  proof -\n    { fix B C assume \"B\\<in>?\\<FF>\" \"C \\<in> Pow(?X)\" \"B\\<subseteq>C\"\n      then obtain U where \"U\\<in>T\" and \"x\\<in>U\" \"U\\<subseteq>B\" by blast\n      with \\<open>C \\<in> Pow(?X)\\<close> \\<open>B\\<subseteq>C\\<close> have \"C\\<in>?\\<FF>\" by blast\n    } thus ?thesis by auto\n  qed\n  ultimately have \"?\\<FF> {is a filter on} ?X\" unfolding IsFilter_def by blast\n  with Mdef \\<open>x\\<in>?X\\<close> show \"\\<M>`(x) {is a filter on} ?X\" using ZF_fun_from_tot_val1 NeighSystem_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2184
    },
    "1969": {
        "type": "theorem",
        "text": "text\\<open>The next theorem states that the the natural \n  neighborhood system on $X=\\bigcup T$ indeed is a neighborhood system. \\<close>\n",
        "assumes": "assumes \"T {is a topology}\"\n  ",
        "using": [
            "ZF_fun_from_total",
            "NeighSystem_def",
            "neighs_is_filter",
            "ZF_fun_from_tot_val1",
            "open_are_neighs",
            "IsFilter_def"
        ],
        "statement": "theorem neigh_from_topology:\n  assumes \"T {is a topology}\"\n  shows \"({neighborhood system of} T) {is a neighborhood system on} (\\<Union>T)\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  let ?\\<M> = \"{neighborhood system of} T\" \n  have \"?\\<M> : ?X\\<rightarrow>Pow(Pow(?X))\"\n  proof -\n    { fix x assume \"x\\<in>?X\"\n      hence \"{V\\<in>Pow(\\<Union>T).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>V)} \\<in> Pow(Pow(?X))\" by auto\n    } hence \"\\<forall>x\\<in>?X. {V\\<in>Pow(\\<Union>T).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>V)} \\<in> Pow(Pow(?X))\" by auto\n    then show ?thesis using ZF_fun_from_total NeighSystem_def by simp\n  qed\n  moreover from assms have \"\\<forall>x\\<in>?X. (?\\<M>`(x) {is a filter on} ?X)\"\n    using neighs_is_filter NeighSystem_def by auto \n  moreover have \"\\<forall>x\\<in>?X. \\<forall>N\\<in>?\\<M>`(x). x\\<in>N \\<and> (\\<exists>U\\<in>?\\<M>`(x).\\<forall>y\\<in>U.(N\\<in>?\\<M>`(y)))\"\n  proof -\n    { fix x N assume \"x\\<in>?X\" \"N \\<in> ?\\<M>`(x)\"\n      let ?\\<FF> = \"{V\\<in>Pow(?X).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>V)}\"\n      from \\<open>x\\<in>?X\\<close> have \"?\\<M>`(x) = ?\\<FF>\" using ZF_fun_from_tot_val1 NeighSystem_def \n        by simp\n      with \\<open>N \\<in> ?\\<M>`(x)\\<close> have \"N\\<in>?\\<FF>\" by simp\n      hence \"x\\<in>N\" by blast\n      from \\<open>N\\<in>?\\<FF>\\<close> obtain U where \"U\\<in>T\" \"x\\<in>U\" and \"U\\<subseteq>N\" by blast \n      with \\<open>N\\<in>?\\<FF>\\<close> \\<open>?\\<M>`(x) = ?\\<FF>\\<close> have \"U \\<in> ?\\<M>`(x)\" by auto \n      moreover from assms \\<open>U\\<in>T\\<close>  \\<open>U\\<subseteq>N\\<close> \\<open>N\\<in>?\\<FF>\\<close> have  \"\\<forall>y\\<in>U.(N \\<in> ?\\<M>`(y))\"\n        using ZF_fun_from_tot_val1 open_are_neighs neighs_is_filter \n                NeighSystem_def IsFilter_def by auto\n      ultimately have \"\\<exists>U\\<in>?\\<M>`(x).\\<forall>y\\<in>U.(N\\<in>?\\<M>`(y))\" by blast\n      with \\<open>x\\<in>N\\<close> have \"x\\<in>N \\<and> (\\<exists>U\\<in>?\\<M>`(x).\\<forall>y\\<in>U.(N\\<in>?\\<M>`(y)))\" by simp      \n    } thus ?thesis by auto \n  qed\n  ultimately show ?thesis unfolding IsNeighSystem_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2185
    },
    "1970": {
        "type": "lemma",
        "text": "text\\<open>Any neighborhood of an element of the closure of a subset intersects the subset.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \"A\\<subseteq>\\<Union>T\" \"x \\<in> Closure(A,T)\" and\n  \"N \\<in> ({neighborhood system of} T)`(x)\"\n  ",
        "using": [
            "topology0.Top_3_L11(1)",
            "neigh_val",
            "topology0.cl_inter_neigh"
        ],
        "statement": "lemma neigh_inter_nempty: \n  assumes \"T {is a topology}\" \"A\\<subseteq>\\<Union>T\" \"x \\<in> Closure(A,T)\" and\n  \"N \\<in> ({neighborhood system of} T)`(x)\"\n  shows \"N\\<inter>A \\<noteq> 0\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  from assms(1) have cntx: \"topology0(T)\" \n    unfolding topology0_def by simp\n  with assms(2,3) have \"x\\<in>?X\"\n    using topology0.Top_3_L11(1) by blast\n  with assms(4) obtain U where \"U\\<in>T\" \"x\\<in>U\" and \"U\\<subseteq>N\"\n    using neigh_val by auto\n  from assms(2,3) cntx \\<open>U\\<in>T\\<close> \\<open>x\\<in>U\\<close> have \"A\\<inter>U \\<noteq> 0\"\n    using topology0.cl_inter_neigh by simp\n  with \\<open>U\\<subseteq>N\\<close> show \"N\\<inter>A \\<noteq> 0\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2186
    },
    "1971": {
        "type": "lemma",
        "text": "text\\<open>Each abstract neighborhood of $x$ contains an open neighborhood of $x$.\\<close>\n",
        "assumes": "assumes \"\\<M> {is a neighborhood system on} X\" \"x\\<in>X\" \"N\\<in>\\<M>`(x)\"\n  defines Tdef: \"T \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  ",
        "using": [
            "apply_funtype",
            "neighborhood_subset(1)",
            "is_filter_def_split(5)",
            "neighborhood_subset(2)"
        ],
        "statement": "lemma open_nei_in_nei: \n  assumes \"\\<M> {is a neighborhood system on} X\" \"x\\<in>X\" \"N\\<in>\\<M>`(x)\"\n  defines Tdef: \"T \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  shows \"N\\<in>Pow(X)\" and \"\\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>N)\"\n",
        "proof": "proof -\n  from assms(1) have \"\\<M>:X\\<rightarrow>Pow(Pow(X))\" unfolding IsNeighSystem_def \n    by simp\n  with assms(2,3) show \"N\\<in>Pow(X)\"using apply_funtype by blast\n  let ?U = \"{y\\<in>X. N \\<in> \\<M>`(y)}\"\n  have \"?U\\<in>T\"\n  proof -\n    have \"?U \\<in> Pow(X)\" by auto\n    moreover have \"\\<forall>y\\<in>?U. ?U\\<in>\\<M>`(y)\"\n    proof -\n      { fix y assume \"y\\<in>?U\"\n        then have \"y\\<in>X\" and \"N\\<in>\\<M>`(y)\" by auto\n        with assms(1) obtain V where \"V\\<in>\\<M>`(y)\" and \"\\<forall>z\\<in>V. N \\<in> \\<M>`(z)\"\n          unfolding IsNeighSystem_def by blast\n        with assms(1) \\<open>y\\<in>X\\<close> \\<open>V\\<in>\\<M>`(y)\\<close> have \"V\\<subseteq>?U\"\n          using neighborhood_subset(1) by blast\n        with assms(1) \\<open>y\\<in>X\\<close> \\<open>V\\<in>\\<M>`(y)\\<close> \\<open>?U \\<in> Pow(X)\\<close> have \"?U\\<in>\\<M>`(y)\"\n          unfolding IsNeighSystem_def using is_filter_def_split(5) by blast\n      } thus ?thesis by simp\n    qed\n    ultimately have \"?U \\<in> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\" by simp\n    with assms(4) show \"?U\\<in>T\" by simp\n  qed\n  moreover from assms(1,2) \\<open>N\\<in>\\<M>`(x)\\<close> have \"x\\<in>?U \\<and> ?U \\<subseteq> N\"\n    using neighborhood_subset(2) by auto\n  ultimately show \"\\<exists>U\\<in>T. (x\\<in>U \\<and> U\\<subseteq>N)\" by (rule witness_exists)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2187
    },
    "1972": {
        "type": "theorem",
        "text": "text\\<open>In the the next theorem we show that if we start from \n  a neighborhood system, create a topology from it, then create it's natural neighborhood system,\n  we get back the original neighborhood system.\\<close>\n",
        "assumes": "assumes \"\\<M> {is a neighborhood system on} X\"\n  defines Tdef: \"T \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  ",
        "using": [
            "topology_from_neighs",
            "neigh_from_topology",
            "ZF_fun_from_tot_val1",
            "open_nei_in_nei"
        ],
        "statement": "theorem nei_top_nei_round_trip: \n  assumes \"\\<M> {is a neighborhood system on} X\"\n  defines Tdef: \"T \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U \\<in> \\<M>`(x)}\"\n  shows \"({neighborhood system of} T) = \\<M>\"\n",
        "proof": "proof -\n  let ?M = \"{neighborhood system of} T\"\n  from assms have \"T {is a topology}\" and \"\\<Union>T = X\" using topology_from_neighs \n    by auto\n  then have \"?M {is a neighborhood system on} X\" using neigh_from_topology \n    by blast\n  with assms(1) have \"?M:X\\<rightarrow>Pow(Pow(X))\" and \"\\<M>:X\\<rightarrow>Pow(Pow(X))\"\n    unfolding IsNeighSystem_def by auto\n  moreover\n  { fix x assume \"x\\<in>X\"\n    from \\<open>\\<Union>T = X\\<close> \\<open>x\\<in>X\\<close> have I: \"?M`(x) = {V\\<in>Pow(X).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>V)}\"\n      unfolding NeighSystem_def using ZF_fun_from_tot_val1 by simp\n    have \"?M`(x) = \\<M>`(x)\"\n    proof\n      { fix V assume \"V\\<in>?M`(x)\"\n        with I obtain U where \"U\\<in>T\" \"x\\<in>U\" \"U\\<subseteq>V\" by auto\n        from assms(2) \\<open>U\\<in>T\\<close> \\<open>x\\<in>U\\<close> have \"U \\<in> \\<M>`(x)\" by simp\n        from assms(1) \\<open>x\\<in>X\\<close> have \"\\<M>`(x) {is a filter on} X\"\n          unfolding IsNeighSystem_def by simp\n        with \\<open>U \\<in> \\<M>`(x)\\<close> \\<open>V\\<in>?M`(x)\\<close> I \\<open>U\\<subseteq>V\\<close>  have \"V \\<in> \\<M>`(x)\"\n          unfolding IsFilter_def by simp\n      } thus \"?M`(x) \\<subseteq> \\<M>`(x)\" by auto\n      { fix N assume \"N\\<in>\\<M>`(x)\"\n        with assms \\<open>x\\<in>X\\<close> \\<open>\\<Union>T = X\\<close> I have \"N\\<in>?M`(x)\" using open_nei_in_nei \n          by auto\n      } thus \"\\<M>`(x) \\<subseteq> ?M`(x)\" by auto\n    qed\n  } hence \"\\<forall>x\\<in>X. ?M`(x) = \\<M>`(x)\" by simp\n  ultimately show ?thesis by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2188
    },
    "1973": {
        "type": "definition",
        "text": "text\\<open>We define a set neighborhood system as a function that takes a subset $A$ of the carrier of the\n  topology and assigns it the collection of supersets of all open sets that contain $A$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  SetNeighSystem ( \"{set neighborhood system of} _\" 91)\n  where \"{set neighborhood system of} T \n          \\<equiv> {\\<langle>A,{N\\<in>Pow(\\<Union>T). \\<exists>U\\<in>T. (A\\<subseteq>U \\<and> U\\<subseteq>N)}\\<rangle>. A\\<in>Pow(\\<Union>T)}\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2189
    },
    "1974": {
        "type": "lemma",
        "text": "text\\<open>Given a set neighborhood system we can recover the (standard)\n  neighborhood system by taking the values of the set neighborhood system\n  at singletons ${x}$ where $x\\in X=\\bigcup T$.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\"\n  ",
        "using": [
            "assms",
            "ZF_fun_from_tot_val1",
            "NeighSystem_def",
            "SetNeighSystem_def"
        ],
        "statement": "lemma neigh_from_nei: assumes \"x\\<in>\\<Union>T\"\n  shows \"({neighborhood system of} T)`(x) = ({set neighborhood system of} T)`{x}\"\n  ",
        "proof": "using assms ZF_fun_from_tot_val1\n  unfolding NeighSystem_def SetNeighSystem_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2190
    },
    "1975": {
        "type": "lemma",
        "text": "text\\<open>The set neighborhood system of $T$ is a function mapping subsets of $\\bigcup T$\n  to collections of subsets of $\\bigcup T$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma nei_fun: \n  shows \"({set neighborhood system of} T):Pow(\\<Union>T) \\<rightarrow>Pow(Pow(\\<Union>T))\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  have \"\\<forall>A\\<in>Pow(?X). {N\\<in>Pow(?X). \\<exists>U\\<in>T. (A\\<subseteq>U \\<and> U\\<subseteq>N)} \\<in> Pow(Pow(?X))\"\n    by blast\n  then have \n    \"{\\<langle>A,{N\\<in>Pow(?X). \\<exists>U\\<in>T. (A\\<subseteq>U \\<and> U\\<subseteq>N)}\\<rangle>. A\\<in>Pow(?X)}:Pow(?X)\\<rightarrow>Pow(Pow(?X))\"\n    by (rule ZF_fun_from_total)\n  then show ?thesis unfolding SetNeighSystem_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2191
    },
    "1976": {
        "type": "lemma",
        "text": "text\\<open>A member of the value of the set neighborhood system of $T$ at $A$ is\n  a subset of $\\bigcup T$. The interesting part is that we can show it without any\n  assumption on $A$. \\<close>\n",
        "assumes": "assumes \"N \\<in> ({set neighborhood system of} T)`(A)\"\n  ",
        "using": [
            "nei_fun",
            "arg_in_domain",
            "nei_val"
        ],
        "statement": "lemma nei_val_subset: \n  assumes \"N \\<in> ({set neighborhood system of} T)`(A)\"\n  shows \"A \\<subseteq> \\<Union>T\" and \"N \\<subseteq> \\<Union>T\"\n",
        "proof": "proof -\n  let ?f = \"{set neighborhood system of} T\"\n  have \"?f:Pow(\\<Union>T) \\<rightarrow>Pow(Pow(\\<Union>T))\" using nei_fun by simp\n  with assms show \"A \\<subseteq> \\<Union>T\" using arg_in_domain by blast\n  with assms show \"N \\<subseteq> \\<Union>T\" using nei_val by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2193
    },
    "1977": {
        "type": "lemma",
        "text": "text\\<open>If $T$ is a topology, then every subset of its carrier (i.e. $\\bigcup T$) \n  is a (set) neighborhood of the empty set. \\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \"N \\<subseteq> \\<Union>T\"\n  ",
        "using": [
            "assms",
            "empty_open",
            "nei_val"
        ],
        "statement": "lemma nei_empty: assumes \"T {is a topology}\" \"N \\<subseteq> \\<Union>T\"\n  shows \"N \\<in> ({set neighborhood system of} T)`(0)\"\n  ",
        "proof": "using assms empty_open nei_val by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2194
    },
    "1978": {
        "type": "theorem",
        "text": "text\\<open>If $T$ is a topology, then the (set) neighborhoods of a nonempty subset of \n  $\\bigcup T$ form a filter on $X=\\bigcup T$.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \"D \\<subseteq> (\\<Union>T)\" \"D\\<noteq>0\"\n  ",
        "using": [
            "nei_val",
            "carr_open"
        ],
        "statement": "theorem nei_filter: assumes \"T {is a topology}\" \"D \\<subseteq> (\\<Union>T)\" \"D\\<noteq>0\"\n  shows \"({set neighborhood system of} T)`(D) {is a filter on} (\\<Union>T)\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  let ?\\<F> = \"({set neighborhood system of} T)`(D)\"\n  from assms(2) have I: \"?\\<F> = {N\\<in>Pow(?X). \\<exists>U\\<in>T. (D\\<subseteq>U \\<and> U\\<subseteq>N)}\"\n    using nei_val by simp\n  with assms(3) have \"0 \\<notin> ?\\<F>\" by auto\n  moreover from assms(1,2) I have \"?X\\<in>?\\<F>\"\n    using carr_open by auto\n  moreover from I have \"?\\<F> \\<subseteq> Pow(?X)\" by auto\n  moreover have \"\\<forall>A\\<in>?\\<F>. \\<forall>B\\<in>?\\<F>. A\\<inter>B \\<in> ?\\<F>\"\n  proof -\n    { fix A B assume \"A\\<in>?\\<F>\" \"B\\<in>?\\<F>\"\n      with I obtain U\\<^sub>A U\\<^sub>B where \n        \"U\\<^sub>A\\<in>T\" \"D\\<subseteq>U\\<^sub>A\" \"U\\<^sub>A\\<subseteq>A\" and \"U\\<^sub>B\\<in>T\" \"D\\<subseteq>U\\<^sub>B\" \"U\\<^sub>B\\<subseteq>B\"\n        by auto\n      let ?U = \"U\\<^sub>A\\<inter>U\\<^sub>B\"\n      from assms(1) \\<open>U\\<^sub>A\\<in>T\\<close> \\<open>U\\<^sub>B\\<in>T\\<close> \\<open>D\\<subseteq>U\\<^sub>A\\<close> \\<open>D\\<subseteq>U\\<^sub>B\\<close> \\<open>U\\<^sub>A\\<subseteq>A\\<close> \\<open>U\\<^sub>B\\<subseteq>B\\<close>\n      have \"?U \\<in> T\" \"D\\<subseteq>?U\" \"?U \\<subseteq> A\\<inter>B\"\n        unfolding IsATopology_def by auto\n      with I \\<open>A\\<in>?\\<F>\\<close> \\<open>B\\<in>?\\<F>\\<close> have \"A\\<inter>B \\<in> ?\\<F>\" by auto\n    } thus ?thesis by simp\n  qed\n  moreover have \"\\<forall>B\\<in>?\\<F>. \\<forall>C\\<in>Pow(?X). B\\<subseteq>C \\<longrightarrow> C\\<in>?\\<F>\"\n  proof -\n    { fix B C assume \"B\\<in>?\\<F>\" \"C\\<in>Pow(?X)\" \"B\\<subseteq>C\"\n      from I \\<open>B\\<in>?\\<F>\\<close> obtain U where \"U\\<in>T\" \"D\\<subseteq>U\" and \"U\\<subseteq>B\"\n        by auto\n      with \\<open>B\\<subseteq>C\\<close> have \"\\<exists>U\\<in>T. (D\\<subseteq>U \\<and> U\\<subseteq>C)\" by blast\n      with I \\<open>C\\<in>Pow(?X)\\<close> have \"C\\<in>?\\<F>\" by simp\n    } thus ?thesis by blast\n  qed\n  ultimately show \"?\\<F> {is a filter on} ?X\"\n    unfolding IsFilter_def by simp\nqed  \n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2195
    },
    "1979": {
        "type": "lemma",
        "text": "text\\<open>If $N$ is a (set) neighborhood of $A$ in $T$, then exist an open set $U$ such that\n  $N$ contains $U$ which contains $A$. This is similar to the Metamath's theorem\n  with the same name, except that here we do not need assume that $T$ is a topology\n  (which is a bit worrying).\\<close>\n",
        "assumes": "assumes \"N \\<in> ({set neighborhood system of} T)`(A)\"\n  ",
        "using": [
            "nei_fun",
            "arg_in_domain",
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma neii2: assumes \"N \\<in> ({set neighborhood system of} T)`(A)\"\n  shows \"\\<exists>U\\<in>T. (A\\<subseteq>U \\<and> U\\<subseteq>N)\"\n",
        "proof": "proof -\n  from assms have \"A\\<in>Pow(\\<Union>T)\" using nei_fun arg_in_domain\n    by blast\n  with assms show ?thesis\n    unfolding SetNeighSystem_def using ZF_fun_from_tot_val1\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2196
    },
    "1980": {
        "type": "lemma",
        "text": "text\\<open>An open set $U$ covering a set $A$ is a set neighborhood of $A$. \\<close>\n",
        "assumes": "assumes \"V\\<in>T\" \"A\\<subseteq>V\"\n  ",
        "using": [
            "nei_val"
        ],
        "statement": "lemma open_superset_nei: assumes \"V\\<in>T\" \"A\\<subseteq>V\"\n  shows \"V \\<in> ({set neighborhood system of} T)`(A)\"\n",
        "proof": "proof -\n  from assms have \n    \"({set neighborhood system of} T)`(A) = {N\\<in>Pow(\\<Union>T). \\<exists>U\\<in>T. (A\\<subseteq>U \\<and> U\\<subseteq>N)}\"\n    using nei_val by blast\n  with assms show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2197
    },
    "1981": {
        "type": "corollary",
        "text": "text\\<open>An open set is a set neighborhood of itself.\\<close>\n",
        "assumes": "assumes \"V\\<in>T\"\n  ",
        "using": [
            "assms",
            "open_superset_nei"
        ],
        "statement": "corollary open_is_nei: assumes \"V\\<in>T\"\n  shows \"V \\<in> ({set neighborhood system of} T)`(V)\"\n  ",
        "proof": "using assms open_superset_nei by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2198
    },
    "1982": {
        "type": "corollary",
        "text": "text\\<open>An open neighborhood of $x$ is a set neighborhood of $\\{ x\\}$. \\<close>\n",
        "assumes": "assumes \"V\\<in>T\" \"x\\<in>V\"\n  ",
        "using": [
            "assms",
            "open_superset_nei"
        ],
        "statement": "corollary open_nei_singl: assumes \"V\\<in>T\" \"x\\<in>V\"\n  shows  \"V \\<in> ({set neighborhood system of} T)`{x}\"\n  ",
        "proof": "using assms open_superset_nei by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2199
    },
    "1983": {
        "type": "lemma",
        "text": "text\\<open>The Cartesian product of two neighborhoods is a neighborhood in the \n  product topology. Similar to the Metamath's theorem with the same name. \\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \"S {is a topology}\" and\n  \"A \\<in> ({set neighborhood system of} T)`(C)\" and\n  \"B \\<in> ({set neighborhood system of} S)`(D)\"\n  ",
        "using": [
            "nei_val_subset(2)",
            "Top_1_4_T1",
            "Top_1_4_T1(1)",
            "nei_empty",
            "neii2",
            "prod_open_open_prod",
            "open_superset_nei",
            "nei_val_subset(1)",
            "Top_1_4_T1(3)",
            "nei_filter",
            "is_filter_def_split(5)"
        ],
        "statement": "lemma neitx: \n  assumes \"T {is a topology}\" \"S {is a topology}\" and\n  \"A \\<in> ({set neighborhood system of} T)`(C)\" and\n  \"B \\<in> ({set neighborhood system of} S)`(D)\"\n  shows \"A\\<times>B \\<in> ({set neighborhood system of} (T\\<times>\\<^sub>tS))`(C\\<times>D)\"\n",
        "proof": "proof -\n  have \"A\\<times>B \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\"\n  proof -\n    from assms(3,4) have \"A\\<times>B \\<subseteq> (\\<Union>T)\\<times>(\\<Union>S)\"\n      using nei_val_subset(2) by blast\n    with assms(1,2) show ?thesis using Top_1_4_T1 by simp\n  qed\n  let ?\\<F> = \"({set neighborhood system of} (T\\<times>\\<^sub>tS))`(C\\<times>D)\"\n  { assume \"C=0 \\<or> D=0\"\n    with assms(1,2) \\<open>A\\<times>B \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\\<close> have \"A\\<times>B \\<in> ?\\<F>\"\n      using Top_1_4_T1(1) nei_empty by auto\n  }\n  moreover\n  { assume \"C\\<noteq>0\" \"D\\<noteq>0\"\n    from assms(3) obtain U\\<^sub>A where \n      \"U\\<^sub>A\\<in>T\" \"C\\<subseteq>U\\<^sub>A\" \"U\\<^sub>A\\<subseteq>A\" using neii2 by blast\n    from assms(4) obtain U\\<^sub>B where \n      \"U\\<^sub>B\\<in>S\" \"D\\<subseteq>U\\<^sub>B\" \"U\\<^sub>B\\<subseteq>B\" using neii2 by blast\n    from assms(1,2) \\<open>U\\<^sub>A\\<in>T\\<close> \\<open>U\\<^sub>B\\<in>S\\<close> \\<open>C\\<subseteq>U\\<^sub>A\\<close> \\<open>D\\<subseteq>U\\<^sub>B\\<close>\n    have \"U\\<^sub>A\\<times>U\\<^sub>B \\<in> T\\<times>\\<^sub>tS\" and \"C\\<times>D \\<subseteq> U\\<^sub>A\\<times>U\\<^sub>B\"\n      using prod_open_open_prod by auto\n    then have \"U\\<^sub>A\\<times>U\\<^sub>B \\<in> ?\\<F>\" using open_superset_nei \n      by simp\n    from \\<open>U\\<^sub>A\\<subseteq>A\\<close> \\<open>U\\<^sub>B\\<subseteq>B\\<close> have \"U\\<^sub>A\\<times>U\\<^sub>B \\<subseteq> A\\<times>B\" by auto\n    have \"?\\<F> {is a filter on} (\\<Union>(T\\<times>\\<^sub>tS))\"\n    proof -\n      from assms(1,2) have \"(T\\<times>\\<^sub>tS) {is a topology}\"\n        using Top_1_4_T1(1) by simp\n      moreover have \"C\\<times>D \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\"\n      proof -\n        from assms(3,4) have \"C\\<times>D \\<subseteq> (\\<Union>T)\\<times>(\\<Union>S)\"\n          using nei_val_subset(1) by blast\n        with assms(1,2) show ?thesis using Top_1_4_T1(3) by simp\n      qed \n      moreover from \\<open>C\\<noteq>0\\<close> \\<open>D\\<noteq>0\\<close> have \"C\\<times>D \\<noteq> 0\" by auto\n      ultimately show \"?\\<F> {is a filter on} (\\<Union>(T\\<times>\\<^sub>tS))\"\n        using nei_filter by simp\n    qed\n    with \\<open>U\\<^sub>A\\<times>U\\<^sub>B \\<in> ?\\<F>\\<close> \\<open>A\\<times>B \\<subseteq> \\<Union>(T\\<times>\\<^sub>tS)\\<close> \\<open>U\\<^sub>A\\<times>U\\<^sub>B \\<subseteq> A\\<times>B\\<close> \n    have \"A\\<times>B \\<in> ?\\<F>\" using is_filter_def_split(5) by simp\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2200
    },
    "1984": {
        "type": "lemma",
        "text": "text\\<open>Any neighborhood of an element of the closure of a subset intersects the subset.\n  This is practically the same as \\<open>neigh_inter_nempty\\<close>, just formulated in terms \n  of set neighborhoods of singletons. \n  Compare with Metamath's theorem with the same name.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\" \"A\\<subseteq>\\<Union>T\" \"x \\<in> Closure(A,T)\" and\n  \"N \\<in> ({set neighborhood system of} T)`{x}\"\n  ",
        "using": [
            "topology0.Top_3_L11(1)",
            "neigh_from_nei",
            "neigh_inter_nempty"
        ],
        "statement": "lemma neindisj: assumes \"T {is a topology}\" \"A\\<subseteq>\\<Union>T\" \"x \\<in> Closure(A,T)\" and\n  \"N \\<in> ({set neighborhood system of} T)`{x}\"\n  shows \"N\\<inter>A \\<noteq> 0\"\n",
        "proof": "proof -\n  let ?X = \"\\<Union>T\"\n  from assms(1) have cntx: \"topology0(T)\" \n    unfolding topology0_def by simp\n  with assms(2,3) have \"x\\<in>?X\"\n    using topology0.Top_3_L11(1) by blast\n  with assms show ?thesis using neigh_from_nei neigh_inter_nempty\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2201
    },
    "1985": {
        "type": "lemma",
        "text": "text\\<open>First we will give a global characterization of $T_1$-spaces; which is interesting\nbecause it involves the cardinal $\\mathbb{N}$.\\<close>\n",
        "assumes": "",
        "using": [
            "isT1_def",
            "open_neigh_open",
            "IsClosed_def",
            "Pi_def",
            "function_def",
            "apply_equality",
            "eqpoll_imp_Finite_iff",
            "AS2",
            "pointCl",
            "FinPow_def",
            "fin_union_cl_is_cl",
            "CoCardinal_def",
            "lesspoll_nat_is_Finite",
            "empty_open",
            "topSpaceAssum",
            "reg",
            "Cofinite_def",
            "Finite_def",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "closed_sets_cocardinal",
            "AS2(2)",
            "union_cocardinal"
        ],
        "statement": "lemma (in topology0)  T1_cocardinal_coarser:\n  shows \"(T {is T\\<^sub>1}) \\<longleftrightarrow> (CoFinite (\\<Union>T))\\<subseteq>T\"\n",
        "proof": "proof\n  {\n    assume AS:\"T {is T\\<^sub>1}\"\n    {\n      fix x assume p:\"x\\<in>\\<Union>T\"\n      {\n        fix y assume \"y\\<in>(\\<Union>T)-{x}\"\n        with AS p obtain U where \"U\\<in>T\" \"y\\<in>U\" \"x\\<notin>U\" using isT1_def by blast\n        then have \"U\\<in>T\" \"y\\<in>U\" \"U\\<subseteq>(\\<Union>T)-{x}\" by auto\n        then have \"\\<exists>U\\<in>T. y\\<in>U \\<and> U\\<subseteq>(\\<Union>T)-{x}\" by auto\n      }\n      then have \"\\<forall>y\\<in>(\\<Union>T)-{x}. \\<exists>U\\<in>T. y\\<in>U \\<and> U\\<subseteq>(\\<Union>T)-{x}\" by auto\n      then have \"\\<Union>T-{x}\\<in>T\" using open_neigh_open by auto\n      with p have \"{x} {is closed in}T\" using IsClosed_def by auto\n    }\n    then have pointCl:\"\\<forall>x\\<in>\\<Union>T. {x} {is closed in} T\" by auto\n    {\n      fix A\n      assume AS2:\"A\\<in>FinPow(\\<Union>T)\"\n      let ?p=\"{\\<langle>x,{x}\\<rangle>. x\\<in>A}\"\n      have \"?p\\<in>A\\<rightarrow>{{x}. x\\<in>A}\" using Pi_def unfolding function_def by auto\n      then have \"?p:bij(A,{{x}. x\\<in>A})\" unfolding bij_def inj_def surj_def using apply_equality\n        by auto\n      then have \"A\\<approx>{{x}. x\\<in>A}\" unfolding eqpoll_def by auto\n      with AS2 have \"Finite({{x}. x\\<in>A})\" unfolding FinPow_def using eqpoll_imp_Finite_iff by auto\n      then have \"{{x}. x\\<in>A}\\<in>FinPow({D \\<in> Pow(\\<Union>T) . D {is closed in} T})\" using AS2 pointCl unfolding FinPow_def\n      by (safe, blast+) \n      then have \"(\\<Union>{{x}. x\\<in>A}) {is closed in} T\" using fin_union_cl_is_cl by auto\n      moreover\n      have \"\\<Union>{{x}. x\\<in>A}=A\" by auto\n      ultimately have \"A {is closed in} T\" by simp\n    }\n    then have reg:\"\\<forall>A\\<in>FinPow(\\<Union>T). A {is closed in} T\" by auto\n    {\n      fix U\n      assume AS2:\"U \\<in> CoCardinal(\\<Union>T,nat)\"\n      then have \"U\\<in>Pow(\\<Union>T)\" \"U=0 \\<or> ((\\<Union>T)-U)\\<prec>nat\" using CoCardinal_def by auto\n      then have \"U\\<in>Pow(\\<Union>T)\" \"U=0 \\<or> Finite(\\<Union>T-U)\" using lesspoll_nat_is_Finite by auto\n      then have \"U\\<in>Pow(\\<Union>T)\" \"U\\<in>T\\<or>(\\<Union>T-U) {is closed in} T\" using empty_open topSpaceAssum\n        reg unfolding FinPow_def by auto\n      then have \"U\\<in>Pow(\\<Union>T)\" \"U\\<in>T\\<or>(\\<Union>T-(\\<Union>T-U))\\<in>T\" using IsClosed_def by auto\n      moreover\n      then have \"(\\<Union>T-(\\<Union>T-U))=U\" by blast\n      ultimately have \"U\\<in>T\" by auto\n    }\n    then show \"(CoFinite (\\<Union>T))\\<subseteq>T\" using Cofinite_def by auto\n  }\n  {\n    assume \"(CoFinite (\\<Union>T))\\<subseteq>T\"\n    then have AS:\"CoCardinal(\\<Union>T,nat) \\<subseteq> T\" using Cofinite_def by auto\n    {\n      fix x y\n      assume AS2:\"x\\<in>\\<Union>T\" \"y\\<in>\\<Union>T\"\"x\\<noteq>y\"\n      have \"Finite({y})\" by auto\n      then obtain n where \"{y}\\<approx>n\" \"n\\<in>nat\" using Finite_def by auto\n      then have \"{y}\\<prec>nat\" using n_lesspoll_nat eq_lesspoll_trans by auto\n      then have \"{y} {is closed in} CoCardinal(\\<Union>T,nat)\" using closed_sets_cocardinal\n        AS2(2) by auto\n      then have \"(\\<Union>T)-{y}\\<in>CoCardinal(\\<Union>T,nat)\" using union_cocardinal IsClosed_def by auto\n      with AS have \"(\\<Union>T)-{y}\\<in>T\" by auto\n      moreover\n      with AS2(1,3) have \"x\\<in>((\\<Union>T)-{y}) \\<and> y\\<notin>((\\<Union>T)-{y})\" by auto\n      ultimately have \"\\<exists>V\\<in>T. x\\<in>V\\<and>y\\<notin>V\" by(safe,auto)\n    }\n    then show \"T {is T\\<^sub>1}\" using isT1_def by auto\n  }\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2202
    },
    "1986": {
        "type": "lemma",
        "text": "text\\<open>Secondly, let's show that the \\<open>CoCardinal X Q\\<close>\ntopologies for different sets $Q$ are all ordered\nas the partial order of sets. (The order is linear when considering only cardinals)\\<close>\n",
        "assumes": "assumes \"Q1\\<lesssim>Q2\"\n  ",
        "using": [
            "CoCardinal_def",
            "lesspoll_trans2"
        ],
        "statement": "lemma order_cocardinal_top:\n  fixes X\n  assumes \"Q1\\<lesssim>Q2\"\n  shows \"CoCardinal(X,Q1) \\<subseteq> CoCardinal(X,Q2)\"\n",
        "proof": "proof\n  fix x\n  assume \"x \\<in> CoCardinal(X,Q1)\"\n  then have \"x\\<in>Pow(X)\" \"x=0\\<or>(X-x)\\<prec>Q1\" using CoCardinal_def by auto\n  with assms have \"x\\<in>Pow(X)\" \"x=0\\<or>(X-x)\\<prec>Q2\" using lesspoll_trans2 by auto\n  then show \"x\\<in>CoCardinal(X,Q2)\" using CoCardinal_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2203
    },
    "1987": {
        "type": "lemma",
        "text": "text\\<open>In $T_2$-spaces, filters and nets have at most one limit point.\\<close>\n",
        "assumes": "assumes \"T {is T\\<^sub>2}\" \"\\<FF> {is a filter on}\\<Union>T\" \"\\<FF> \\<rightarrow>\\<^sub>F x\" \"\\<FF> \\<rightarrow>\\<^sub>F y\"\n  ",
        "using": [
            "FilterConverges_def",
            "assms(2)",
            "assms(1)",
            "isT2_def",
            "Top_2_L3",
            "assms(3,4)",
            "IsFilter_def"
        ],
        "statement": "lemma (in topology0) T2_imp_unique_limit_filter:\n  assumes \"T {is T\\<^sub>2}\" \"\\<FF> {is a filter on}\\<Union>T\" \"\\<FF> \\<rightarrow>\\<^sub>F x\" \"\\<FF> \\<rightarrow>\\<^sub>F y\"\n  shows \"x=y\"\n",
        "proof": "proof-\n  {\n    assume \"x\\<noteq>y\"\n    from assms(3,4) have \"x\\<in>\\<Union>T\" \"y\\<in>\\<Union>T\" using FilterConverges_def assms(2)\n      by auto\n    with \\<open>x\\<noteq>y\\<close> have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" using assms(1) isT2_def by auto\n    then obtain U V where \"x\\<in>U\" \"y\\<in>V\" \"U\\<inter>V=0\" \"U\\<in>T\" \"V\\<in>T\" by auto\n    then have \"U\\<in>{A\\<in>Pow(\\<Union>T). x\\<in>Interior(A,T)}\" \"V\\<in>{A\\<in>Pow(\\<Union>T). y\\<in>Interior(A,T)}\" using Top_2_L3 by auto\n    then have \"U\\<in>\\<FF>\" \"V\\<in>\\<FF>\" using FilterConverges_def assms(2) assms(3,4)\n      by auto\n    then have \"U\\<inter>V\\<in>\\<FF>\" using IsFilter_def assms(2) by auto\n    with \\<open>U\\<inter>V=0\\<close> have \"0\\<in>\\<FF>\" by auto\n    then have \"False\" using IsFilter_def assms(2) by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2204
    },
    "1988": {
        "type": "lemma",
        "text": "text\\<open>In fact, $T_2$-spaces are characterized by this property. For this proof we build\na filter containing the union of two filters.\\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>\\<Union>T. \\<forall>y\\<in>\\<Union>T. \\<forall>\\<FF>. ((\\<FF> {is a filter on}\\<Union>T) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F x) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F y)) \\<longrightarrow> x=y\"\n  ",
        "using": [
            "neigh_filter(1)",
            "IsFilter_def",
            "\\<open>B\\<in>?FF\\<close>",
            "\\<open>AA\\<in>?Ux\\<close>",
            "\\<open>B\\<inter>BB\\<in>?Uy\\<close>",
            "\\<open>B\\<inter>AA\\<in>?Ux\\<close>",
            "\\<open>BB\\<in>?Uy\\<close>",
            "\\<open>A\\<in>?FF\\<close>",
            "\\<open>x\\<in>\\<Union>T\\<close>",
            "\\<open>y\\<in>\\<Union>T\\<close>",
            "Top_2_L1",
            "Top_2_L2",
            "\\<open>\\<forall>U\\<in>T.",
            "\\<forall>V\\<in>T.",
            "x\\<in>U\\<and>y\\<in>V",
            "\\<longrightarrow>",
            "U\\<inter>V\\<noteq>0\\<close>",
            "SatisfiesFilterBase_def",
            "base_unique_filter_set2[of",
            "\"?FF\"]",
            "basic_filter",
            "sat",
            "convergence_filter_base2[OF",
            "fil",
            "bas(1)",
            "_",
            "\\<open>x\\<in>\\<Union>T\\<close>]",
            "\\<open>y\\<in>\\<Union>T\\<close>]",
            "assms",
            "\\<open>x\\<in>\\<Union>T\\<close>\\<open>y\\<in>\\<Union>T\\<close>",
            "isT2_def"
        ],
        "statement": "lemma (in topology0) unique_limit_filter_imp_T2:\n  assumes \"\\<forall>x\\<in>\\<Union>T. \\<forall>y\\<in>\\<Union>T. \\<forall>\\<FF>. ((\\<FF> {is a filter on}\\<Union>T) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F x) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F y)) \\<longrightarrow> x=y\"\n  shows \"T {is T\\<^sub>2}\"\n",
        "proof": "proof-\n  {\n    fix x y\n    assume \"x\\<in>\\<Union>T\" \"y\\<in>\\<Union>T\" \"x\\<noteq>y\"\n    {\n      assume \"\\<forall>U\\<in>T. \\<forall>V\\<in>T. (x\\<in>U \\<and> y\\<in>V) \\<longrightarrow> U\\<inter>V\\<noteq>0\"\n      let ?Ux=\"{A\\<in>Pow(\\<Union>T). x\\<in>int(A)}\"\n      let ?Uy=\"{A\\<in>Pow(\\<Union>T). y\\<in>int(A)}\"\n      let ?FF=\"?Ux \\<union> ?Uy \\<union> {A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\"\n      have sat:\"?FF {satisfies the filter base condition}\"\n      proof-\n        {\n          fix A B\n          assume \"A\\<in>?FF\" \"B\\<in>?FF\"\n          {\n            assume \"A\\<in>?Ux\" \n            {\n              assume \"B\\<in>?Ux\"\n              with \\<open>x\\<in>\\<Union>T\\<close> \\<open>A\\<in>?Ux\\<close> have \"A\\<inter>B\\<in>?Ux\" using neigh_filter(1) IsFilter_def by auto\n              then have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            moreover\n            {\n              assume \"B\\<in>?Uy\"\n              with \\<open>A\\<in>?Ux\\<close> have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            moreover\n            {\n              assume \"B\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\"\n              then obtain AA BB where \"B=AA\\<inter>BB\" \"AA\\<in>?Ux\" \"BB\\<in>?Uy\" by auto\n              with \\<open>x\\<in>\\<Union>T\\<close> \\<open>A\\<in>?Ux\\<close> have \"A\\<inter>B=(A\\<inter>AA)\\<inter>BB\" \"A\\<inter>AA\\<in>?Ux\" using neigh_filter(1) IsFilter_def by auto\n              with \\<open>BB\\<in>?Uy\\<close> have \"A\\<inter>B\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\" by auto\n              then have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            ultimately have \"A\\<inter>B\\<in>?FF\" using \\<open>B\\<in>?FF\\<close> by auto\n          }\n          moreover\n          {\n            assume \"A\\<in>?Uy\" \n            {\n              assume \"B\\<in>?Uy\"\n              with \\<open>y\\<in>\\<Union>T\\<close> \\<open>A\\<in>?Uy\\<close> have \"A\\<inter>B\\<in>?Uy\" using neigh_filter(1) IsFilter_def by auto\n              then have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            moreover\n            {\n              assume \"B\\<in>?Ux\"\n              with \\<open>A\\<in>?Uy\\<close> have \"B\\<inter>A\\<in>?FF\" by auto\n              moreover have \"A\\<inter>B=B\\<inter>A\" by auto\n              ultimately have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            moreover\n            {\n              assume \"B\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\"\n              then obtain AA BB where \"B=AA\\<inter>BB\" \"AA\\<in>?Ux\" \"BB\\<in>?Uy\" by auto\n              with \\<open>y\\<in>\\<Union>T\\<close> \\<open>A\\<in>?Uy\\<close> have \"A\\<inter>B=AA\\<inter>(A\\<inter>BB)\" \"A\\<inter>BB\\<in>?Uy\" using neigh_filter(1) IsFilter_def by auto\n              with \\<open>AA\\<in>?Ux\\<close> have \"A\\<inter>B\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\" by auto\n              then have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            ultimately have \"A\\<inter>B\\<in>?FF\" using \\<open>B\\<in>?FF\\<close> by auto\n          }\n          moreover\n          {\n            assume \"A\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\"\n            then obtain AA BB where \"A=AA\\<inter>BB\" \"AA\\<in>?Ux\" \"BB\\<in>?Uy\" by auto\n            {\n              assume \"B\\<in>?Uy\"\n              with \\<open>BB\\<in>?Uy\\<close> \\<open>y\\<in>\\<Union>T\\<close> have \"B\\<inter>BB\\<in>?Uy\" using neigh_filter(1) IsFilter_def by auto\n              moreover from \\<open>A=AA\\<inter>BB\\<close> have \"A\\<inter>B=AA\\<inter>(B\\<inter>BB)\" by auto\n              ultimately have \"A\\<inter>B\\<in>?FF\" using \\<open>AA\\<in>?Ux\\<close> \\<open>B\\<inter>BB\\<in>?Uy\\<close> by auto\n            }\n            moreover\n            {\n              assume \"B\\<in>?Ux\"\n              with \\<open>AA\\<in>?Ux\\<close> \\<open>x\\<in>\\<Union>T\\<close> have \"B\\<inter>AA\\<in>?Ux\" using neigh_filter(1) IsFilter_def by auto\n              moreover from \\<open>A=AA\\<inter>BB\\<close> have \"A\\<inter>B=(B\\<inter>AA)\\<inter>BB\" by auto\n              ultimately have \"A\\<inter>B\\<in>?FF\" using \\<open>B\\<inter>AA\\<in>?Ux\\<close> \\<open>BB\\<in>?Uy\\<close> by auto\n            }\n            moreover\n            {\n              assume \"B\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\"\n              then obtain AA2 BB2 where \"B=AA2\\<inter>BB2\" \"AA2\\<in>?Ux\" \"BB2\\<in>?Uy\" by auto\n              from \\<open>B=AA2\\<inter>BB2\\<close> \\<open>A=AA\\<inter>BB\\<close> have \"A\\<inter>B=(AA\\<inter>AA2)\\<inter>(BB\\<inter>BB2)\" by auto\n              moreover\n              from \\<open>AA\\<in>?Ux\\<close>\\<open>AA2\\<in>?Ux\\<close>\\<open>x\\<in>\\<Union>T\\<close> have \"AA\\<inter>AA2\\<in>?Ux\" using neigh_filter(1) IsFilter_def by auto\n              moreover\n              from \\<open>BB\\<in>?Uy\\<close>\\<open>BB2\\<in>?Uy\\<close>\\<open>y\\<in>\\<Union>T\\<close> have \"BB\\<inter>BB2\\<in>?Uy\" using neigh_filter(1) IsFilter_def by auto\n              ultimately have \"A\\<inter>B\\<in>?FF\" by auto\n            }\n            ultimately have \"A\\<inter>B\\<in>?FF\" using \\<open>B\\<in>?FF\\<close> by auto\n          }\n          ultimately have \"A\\<inter>B\\<in>?FF\" using \\<open>A\\<in>?FF\\<close> by auto\n          then have \"\\<exists>D\\<in>?FF. D\\<subseteq>A\\<inter>B\" unfolding Bex_def by auto\n        }\n        then have \"\\<forall>A\\<in>?FF. \\<forall>B\\<in>?FF. \\<exists>D\\<in>?FF. D\\<subseteq>A\\<inter>B\" by force\n        moreover\n        have \"\\<Union>T\\<in>?Ux\" using \\<open>x\\<in>\\<Union>T\\<close> neigh_filter(1) IsFilter_def by auto\n        then have \"?FF\\<noteq>0\" by auto\n        moreover\n        {\n          assume \"0\\<in>?FF\"\n          moreover\n          have \"0\\<notin>?Ux\" using \\<open>x\\<in>\\<Union>T\\<close> neigh_filter(1) IsFilter_def by auto\n          moreover\n          have \"0\\<notin>?Uy\" using \\<open>y\\<in>\\<Union>T\\<close> neigh_filter(1) IsFilter_def by auto\n          ultimately have \"0\\<in>{A\\<inter>B. \\<langle>A,B\\<rangle>\\<in>?Ux \\<times> ?Uy}\" by auto\n          then obtain A B where \"0=A\\<inter>B\" \"A\\<in>?Ux\"\"B\\<in>?Uy\" by auto\n          then have \"x\\<in>int(A)\"\"y\\<in>int(B)\" by auto\n          moreover\n          with \\<open>0=A\\<inter>B\\<close> have \"int(A)\\<inter>int(B)=0\" using Top_2_L1 by auto\n          moreover\n          have \"int(A)\\<in>T\"\"int(B)\\<in>T\" using Top_2_L2 by auto\n          ultimately have \"False\" using \\<open>\\<forall>U\\<in>T. \\<forall>V\\<in>T. x\\<in>U\\<and>y\\<in>V \\<longrightarrow> U\\<inter>V\\<noteq>0\\<close> by auto\n        }\n        then have \"0\\<notin>?FF\" by auto\n        ultimately show ?thesis using SatisfiesFilterBase_def by auto\n      qed\n      moreover\n      have \"?FF\\<subseteq>Pow(\\<Union>T)\" by auto\n      ultimately have bas:\"?FF {is a base filter} {A\\<in>Pow(\\<Union>T). \\<exists>D\\<in>?FF. D\\<subseteq>A}\" \"\\<Union>{A\\<in>Pow(\\<Union>T). \\<exists>D\\<in>?FF. D\\<subseteq>A}=\\<Union>T\" \n        using base_unique_filter_set2[of \"?FF\"] by auto\n      then have fil:\"{A\\<in>Pow(\\<Union>T). \\<exists>D\\<in>?FF. D\\<subseteq>A} {is a filter on} \\<Union>T\" using basic_filter sat by auto\n      have \"\\<forall>U\\<in>Pow(\\<Union>T). x\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>?FF. D\\<subseteq>U)\" by auto\n      then have \"{A\\<in>Pow(\\<Union>T). \\<exists>D\\<in>?FF. D\\<subseteq>A} \\<rightarrow>\\<^sub>F x\" using convergence_filter_base2[OF fil bas(1) _ \\<open>x\\<in>\\<Union>T\\<close>] by auto\n      moreover\n      then have \"\\<forall>U\\<in>Pow(\\<Union>T). y\\<in>int(U) \\<longrightarrow> (\\<exists>D\\<in>?FF. D\\<subseteq>U)\" by auto\n      then have \"{A\\<in>Pow(\\<Union>T). \\<exists>D\\<in>?FF. D\\<subseteq>A} \\<rightarrow>\\<^sub>F y\" using convergence_filter_base2[OF fil bas(1) _ \\<open>y\\<in>\\<Union>T\\<close>] by auto\n      ultimately have \"x=y\" using assms fil \\<open>x\\<in>\\<Union>T\\<close>\\<open>y\\<in>\\<Union>T\\<close> by blast\n      with \\<open>x\\<noteq>y\\<close> have \"False\" by auto\n    }\n    then have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by blast\n  }\n  then show ?thesis using isT2_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2205
    },
    "1989": {
        "type": "corollary",
        "text": "text\\<open>The topology\nwhich comes from a filter as in @{thm \"top_of_filter\"} is not $T_2$ generally.\n  We will see in this file later on, that the exceptions are a consequence of the spectrum.\\<close>\n",
        "assumes": "assumes \"(\\<FF>\\<union>{0}) {is T\\<^sub>2}\" \"\\<FF> {is a filter on} \\<Union>\\<FF>\" \"x\\<in>\\<Union>\\<FF>\"\n  ",
        "using": [
            "lim_filter_top_of_filter",
            "assms(2)",
            "assms(2,3)",
            "topology0.T2_imp_unique_limit_filter[OF",
            "topology0_filter[OF",
            "assms(2)]",
            "assms(1)]"
        ],
        "statement": "corollary filter_T2_imp_card1:\n  assumes \"(\\<FF>\\<union>{0}) {is T\\<^sub>2}\" \"\\<FF> {is a filter on} \\<Union>\\<FF>\" \"x\\<in>\\<Union>\\<FF>\"\n  shows \"\\<Union>\\<FF>={x}\"\n",
        "proof": "proof-\n  {\n    fix y assume \"y\\<in>\\<Union>\\<FF>\"\n    then have \"\\<FF> \\<rightarrow>\\<^sub>F y {in} (\\<FF>\\<union>{0})\" using lim_filter_top_of_filter assms(2) by auto\n    moreover\n    have \"\\<FF> \\<rightarrow>\\<^sub>F x {in} (\\<FF>\\<union>{0})\" using lim_filter_top_of_filter assms(2,3) by auto\n    moreover\n    have \"\\<Union>\\<FF>=\\<Union>(\\<FF>\\<union>{0})\" by auto\n    ultimately\n    have \"y=x\" using topology0.T2_imp_unique_limit_filter[OF topology0_filter[OF assms(2)] assms(1)] assms(2)\n      by auto\n  }\n  then have \"\\<Union>\\<FF>\\<subseteq>{x}\" by auto\n  with assms(3) show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2206
    },
    "1990": {
        "type": "definition",
        "text": "text\\<open>There are more separation axioms that just $T_0$, $T_1$ or $T_2$\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  isT3 (\"_{is T\\<^sub>3}\" 90)\n  where \"T{is T\\<^sub>3} \\<equiv> (T{is T\\<^sub>1}) \\<and> (T{is regular})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2207
    },
    "1991": {
        "type": "lemma",
        "text": "text\\<open>Regularity can be rewritten in terms of existence of certain neighboorhoods.\\<close>\n",
        "assumes": "assumes \"T{is regular}\" and \"U\\<in>T\" and \"x\\<in>U\"\n  ",
        "using": [
            "Top_3_L9",
            "Top_3_L13"
        ],
        "statement": "lemma (in topology0) regular_imp_exist_clos_neig:\n  assumes \"T{is regular}\" and \"U\\<in>T\" and \"x\\<in>U\"\n  shows \"\\<exists>V\\<in>T. x\\<in>V \\<and> cl(V)\\<subseteq>U\"\n",
        "proof": "proof-\n  from assms(2) have \"(\\<Union>T-U){is closed in}T\" using Top_3_L9 by auto moreover\n  from assms(2,3) have \"x\\<in>\\<Union>T\" by auto moreover\n  note assms(1,3) ultimately obtain A B where \"A\\<in>T\" and \"B\\<in>T\" and \"A\\<inter>B=0\" and \"(\\<Union>T-U)\\<subseteq>A\" and \"x\\<in>B\"\n    unfolding IsRegular_def by blast\n  from \\<open>A\\<inter>B=0\\<close> \\<open>B\\<in>T\\<close> have \"B\\<subseteq>\\<Union>T-A\" by auto\n  with \\<open>A\\<in>T\\<close> have \"cl(B)\\<subseteq>\\<Union>T-A\" using Top_3_L9 Top_3_L13 by auto\n  moreover from \\<open>(\\<Union>T-U)\\<subseteq>A\\<close> assms(3) have \"\\<Union>T-A\\<subseteq>U\" by auto\n  moreover note \\<open>x\\<in>B\\<close> \\<open>B\\<in>T\\<close>\n  ultimately have \"B\\<in>T \\<and> x\\<in>B \\<and> cl(B)\\<subseteq>U\" by auto\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2208
    },
    "1992": {
        "type": "theorem",
        "text": "text\\<open>A Hausdorff space separates compact spaces from points.\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>2}\" \"A{is compact in}T\" \"x\\<in>\\<Union>T\" \"x\\<notin>A\"\n  ",
        "using": [
            "assms(3)",
            "empty_open",
            "topSpaceAssum",
            "IsATopology_def",
            "assms(2,3)",
            "IsCompact_def",
            "assms(1)",
            "isT2_def",
            "assms(2)",
            "eqpoll_imp_lepoll",
            "apply_equality",
            "finite_choice",
            "AxiomCardinalChoiceGen_def",
            "fPI(2)",
            "func_imagedef",
            "QQPi",
            "fPI(1)",
            "Pi_def",
            "fun_is_surj",
            "surj_fun_inv_2",
            "nat_into_Ord",
            "lepoll_trans",
            "n_lesspoll_nat",
            "lesspoll_nat_is_Finite",
            "lesspoll_trans1",
            "fin_inter_open_open",
            "\\<open>range(f)\\<noteq>0\\<close>",
            "Union_iff",
            "apply_rangeI",
            "ffun"
        ],
        "statement": "theorem (in topology0) T2_compact_point:\n  assumes \"T{is T\\<^sub>2}\" \"A{is compact in}T\" \"x\\<in>\\<Union>T\" \"x\\<notin>A\"\n  shows \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. A\\<subseteq>U \\<and> x\\<in>V \\<and> U\\<inter>V=0\"\n",
        "proof": "proof-\n  {\n    assume \"A=0\"\n    then have \"A\\<subseteq>0\\<and>x\\<in>\\<Union>T\\<and>(0\\<inter>(\\<Union>T)=0)\" using assms(3) by auto \n    then have ?thesis using empty_open topSpaceAssum unfolding IsATopology_def by auto\n  }\n  moreover\n  {\n    assume noEmpty:\"A\\<noteq>0\"\n    let ?U=\"{\\<langle>U,V\\<rangle>\\<in>T\\<times>T. x\\<in>U\\<and>U\\<inter>V=0}\"\n    {\n      fix y assume \"y\\<in>A\"\n      with \\<open>x\\<notin>A\\<close> assms(4) have \"x\\<noteq>y\" by auto\n      moreover from \\<open>y\\<in>A\\<close> have \"x\\<in>\\<Union>T\"\"y\\<in>\\<Union>T\" using assms(2,3) unfolding IsCompact_def by auto\n      ultimately obtain U V where \"U\\<in>T\"\"V\\<in>T\"\"U\\<inter>V=0\"\"x\\<in>U\"\"y\\<in>V\" using assms(1) unfolding isT2_def by blast\n      then have \"\\<exists>\\<langle>U,V\\<rangle>\\<in>?U. y\\<in>V\" by auto\n    }\n    then have \"\\<forall>y\\<in>A. \\<exists>\\<langle>U,V\\<rangle>\\<in>?U. y\\<in>V\" by auto\n    then have \"A\\<subseteq>\\<Union>{snd(B). B\\<in>?U}\" by auto\n    moreover have \"{snd(B). B\\<in>?U}\\<in>Pow(T)\" by auto\n    ultimately have \"\\<exists>N\\<in>FinPow({snd(B). B\\<in>?U}). A\\<subseteq>\\<Union>N\" using assms(2) unfolding IsCompact_def by auto\n    then obtain N where ss:\"N\\<in>FinPow({snd(B). B\\<in>?U})\" \"A\\<subseteq>\\<Union>N\" by auto\n    with \\<open>{snd(B). B\\<in>?U}\\<in>Pow(T)\\<close> have \"A\\<subseteq>\\<Union>N\" \"N\\<in>Pow(T)\" unfolding FinPow_def by auto\n    then have NN:\"A\\<subseteq>\\<Union>N\" \"\\<Union>N\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    from ss have \"Finite(N)\"\"N\\<subseteq>{snd(B). B\\<in>?U}\" unfolding FinPow_def by auto\n    then obtain n where \"n\\<in>nat\" \"N\\<approx>n\" unfolding Finite_def by auto\n    then have \"N\\<lesssim>n\" using eqpoll_imp_lepoll by auto\n    from noEmpty \\<open>A\\<subseteq>\\<Union>N\\<close> have NnoEmpty:\"N\\<noteq>0\" by auto\n    let ?QQ=\"{\\<langle>n,{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\\<rangle>. n\\<in>N}\"\n    have QQPi:\"?QQ:N\\<rightarrow>{{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}. n\\<in>N}\" unfolding Pi_def function_def domain_def by auto\n    {\n      fix n assume \"n\\<in>N\"\n      with \\<open>N\\<subseteq>{snd(B). B\\<in>?U}\\<close> obtain B where \"n=snd(B)\" \"B\\<in>?U\" by auto\n      then have \"fst(B)\\<in>{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\" by auto\n      then have \"{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\\<noteq>0\" by auto moreover\n      from \\<open>n\\<in>N\\<close> have \"\\<langle>n,{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\\<rangle>\\<in>?QQ\" by auto\n      with QQPi have \"?QQ`n={fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\" using apply_equality by auto\n      ultimately have \"?QQ`n\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>n\\<in>N. ?QQ`n\\<noteq>0\" by auto\n    with \\<open>n\\<in>nat\\<close> \\<open>N\\<lesssim>n\\<close> have \"\\<exists>f. f\\<in>Pi(N,\\<lambda>t. ?QQ`t) \\<and> (\\<forall>t\\<in>N. f`t\\<in>?QQ`t)\" using finite_choice unfolding AxiomCardinalChoiceGen_def\n      by auto\n    then obtain f where fPI:\"f\\<in>Pi(N,\\<lambda>t. ?QQ`t)\" \"(\\<forall>t\\<in>N. f`t\\<in>?QQ`t)\" by auto\n    from fPI(1) NnoEmpty have \"range(f)\\<noteq>0\" unfolding Pi_def range_def domain_def converse_def by (safe,blast)\n    {\n      fix t assume \"t\\<in>N\"\n      then have \"f`t\\<in>?QQ`t\" using fPI(2) by auto\n      with \\<open>t\\<in>N\\<close> have \"f`t\\<in>\\<Union>(?QQ``N)\" \"?QQ`t\\<subseteq>\\<Union>(?QQ``N)\" using func_imagedef QQPi by auto\n    }\n    then have reg:\"\\<forall>t\\<in>N. f`t\\<in>\\<Union>(?QQ``N)\"  \"\\<forall>t\\<in>N. ?QQ`t\\<subseteq>\\<Union>(?QQ``N)\" by auto\n    {\n      fix tt assume \"tt\\<in>f\"\n      with fPI(1) have \"tt\\<in>Sigma(N, (`)(?QQ))\" unfolding Pi_def by auto\n      then have \"tt\\<in>(\\<Union>xa\\<in>N. \\<Union>y\\<in>?QQ`xa. {\\<langle>xa,y\\<rangle>})\" unfolding Sigma_def by auto\n      then obtain xa y where \"xa\\<in>N\" \"y\\<in>?QQ`xa\" \"tt=\\<langle>xa,y\\<rangle>\" by auto\n      with reg(2) have \"y\\<in>\\<Union>(?QQ``N)\" by blast\n      with \\<open>tt=\\<langle>xa,y\\<rangle>\\<close> \\<open>xa\\<in>N\\<close> have \"tt\\<in>(\\<Union>xa\\<in>N. \\<Union>y\\<in>\\<Union>(?QQ``N). {\\<langle>xa,y\\<rangle>})\" by auto\n      then have \"tt\\<in>N\\<times>(\\<Union>(?QQ``N))\" unfolding Sigma_def by auto\n    }\n    then have ffun:\"f:N\\<rightarrow>\\<Union>(?QQ``N)\"  using fPI(1) unfolding Pi_def by auto\n    then have \"f\\<in>surj(N,range(f))\" using fun_is_surj by auto\n    with \\<open>N\\<lesssim>n\\<close> \\<open>n\\<in>nat\\<close> have \"range(f)\\<lesssim>N\" using surj_fun_inv_2 nat_into_Ord by auto\n    with \\<open>N\\<lesssim>n\\<close> have \"range(f)\\<lesssim>n\" using lepoll_trans by blast\n    with \\<open>n\\<in>nat\\<close> have \"Finite(range(f))\" using n_lesspoll_nat lesspoll_nat_is_Finite lesspoll_trans1 by auto\n    moreover from ffun have rr:\"range(f)\\<subseteq>\\<Union>(?QQ``N)\" unfolding Pi_def by auto\n    then have \"range(f)\\<subseteq>T\" by auto\n    ultimately have \"range(f)\\<in>FinPow(T)\" unfolding FinPow_def by auto\n    then have \"\\<Inter>range(f)\\<in>T\" using fin_inter_open_open \\<open>range(f)\\<noteq>0\\<close> by auto moreover\n    {\n      fix S assume \"S\\<in>range(f)\"\n      with rr have \"S\\<in>\\<Union>(?QQ``N)\" by blast\n      then have \"\\<exists>B\\<in>(?QQ``N). S \\<in> B\" using Union_iff by auto\n      then obtain B where \"B\\<in>(?QQ``N)\" \"S\\<in>B\" by auto\n      then have \"\\<exists>rr\\<in>N. \\<langle>rr,B\\<rangle>\\<in>?QQ\" unfolding image_def by auto\n      then have \"\\<exists>rr\\<in>N. B={fst(B). B\\<in>{A\\<in>?U. snd(A)=rr}}\" by auto\n      with \\<open>S\\<in>B\\<close> obtain rr where \"\\<langle>S,rr\\<rangle>\\<in>?U\" by auto\n      then have \"x\\<in>S\" by auto\n    }\n    then have \"x\\<in>\\<Inter>range(f)\" using \\<open>range(f)\\<noteq>0\\<close> by auto moreover\n    {\n      fix y assume \"y\\<in>(\\<Union>N)\\<inter>(\\<Inter>range(f))\"\n      then have reg:\"(\\<forall>S\\<in>range(f). y\\<in>S)\\<and>(\\<exists>t\\<in>N. y\\<in>t)\" by auto\n      then obtain t where \"t\\<in>N\" \"y\\<in>t\" by auto\n      then have \"\\<langle>t, {fst(B). B\\<in>{A\\<in>?U. snd(A)=t}}\\<rangle>\\<in>?QQ\" by auto\n      then have \"f`t\\<in>range(f)\" using apply_rangeI ffun by auto\n      with reg have yft:\"y\\<in>f`t\" by auto\n      with \\<open>t\\<in>N\\<close> fPI(2) have \"f`t\\<in>?QQ`t\" by auto\n      with \\<open>t\\<in>N\\<close> have \"f`t\\<in>{fst(B). B\\<in>{A\\<in>?U. snd(A)=t}}\" using apply_equality QQPi by auto\n      then have \"\\<langle>f`t,t\\<rangle>\\<in>?U\" by auto\n      then have \"f`t\\<inter>t=0\" by auto\n      with \\<open>y\\<in>t\\<close> yft have \"False\" by auto\n    }\n    then have \"(\\<Union>N)\\<inter>(\\<Inter>range(f))=0\" by blast moreover\n    note NN\n    ultimately have ?thesis by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2209
    },
    "1993": {
        "type": "theorem",
        "text": "text\\<open>A Hausdorff space separates compact spaces from other compact spaces.\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>2}\" \"A{is compact in}T\" \"B{is compact in}T\" \"A\\<inter>B=0\"\n  ",
        "using": [
            "assms(2)",
            "IsCompact_def",
            "empty_open",
            "topSpaceAssum",
            "IsATopology_def",
            "assms(3)",
            "T2_compact_point",
            "assms(1,2,4)",
            "eqpoll_imp_lepoll",
            "apply_equality",
            "finite_choice",
            "AxiomCardinalChoiceGen_def",
            "fPI(2)",
            "func_imagedef",
            "QQPi",
            "fPI(1)",
            "Pi_def",
            "fun_is_surj",
            "surj_fun_inv_2",
            "nat_into_Ord",
            "lepoll_trans",
            "n_lesspoll_nat",
            "lesspoll_nat_is_Finite",
            "lesspoll_trans1",
            "fin_inter_open_open",
            "\\<open>range(f)\\<noteq>0\\<close>",
            "Union_iff",
            "apply_rangeI",
            "ffun"
        ],
        "statement": "theorem (in topology0) T2_compact_compact:\n  assumes \"T{is T\\<^sub>2}\" \"A{is compact in}T\" \"B{is compact in}T\" \"A\\<inter>B=0\"\n  shows \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. A\\<subseteq>U \\<and> B\\<subseteq>V \\<and> U\\<inter>V=0\"\n",
        "proof": "proof-\n {\n    assume \"B=0\"\n    then have \"A\\<subseteq>\\<Union>T\\<and>B\\<subseteq>0\\<and>((\\<Union>T)\\<inter>0=0)\" using assms(2) unfolding IsCompact_def by auto moreover\n    have \"0\\<in>T\" using empty_open topSpaceAssum by auto moreover\n    have \"\\<Union>T\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto ultimately\n    have ?thesis by auto\n  }\n  moreover\n  {\n    assume noEmpty:\"B\\<noteq>0\"\n    let ?U=\"{\\<langle>U,V\\<rangle>\\<in>T\\<times>T. A\\<subseteq>U \\<and> U\\<inter>V=0}\"\n    {\n      fix y assume \"y\\<in>B\"\n      then have \"y\\<in>\\<Union>T\" using assms(3) unfolding IsCompact_def by auto\n      with \\<open>y\\<in>B\\<close> have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. A\\<subseteq>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" using T2_compact_point assms(1,2,4) by auto\n      then have \"\\<exists>\\<langle>U,V\\<rangle>\\<in>?U. y\\<in>V\" by auto\n    }\n    then have \"\\<forall>y\\<in>B. \\<exists>\\<langle>U,V\\<rangle>\\<in>?U. y\\<in>V\" by auto\n    then have \"B\\<subseteq>\\<Union>{snd(B). B\\<in>?U}\" by auto\n    moreover have \"{snd(B). B\\<in>?U}\\<in>Pow(T)\" by auto\n    ultimately have \"\\<exists>N\\<in>FinPow({snd(B). B\\<in>?U}). B\\<subseteq>\\<Union>N\" using assms(3) unfolding IsCompact_def by auto\n    then obtain N where ss:\"N\\<in>FinPow({snd(B). B\\<in>?U})\" \"B\\<subseteq>\\<Union>N\" by auto\n    with \\<open>{snd(B). B\\<in>?U}\\<in>Pow(T)\\<close> have \"B\\<subseteq>\\<Union>N\" \"N\\<in>Pow(T)\" unfolding FinPow_def by auto\n    then have NN:\"B\\<subseteq>\\<Union>N\" \"\\<Union>N\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    from ss have \"Finite(N)\"\"N\\<subseteq>{snd(B). B\\<in>?U}\" unfolding FinPow_def by auto\n    then obtain n where \"n\\<in>nat\" \"N\\<approx>n\" unfolding Finite_def by auto\n    then have \"N\\<lesssim>n\" using eqpoll_imp_lepoll by auto\n    from noEmpty \\<open>B\\<subseteq>\\<Union>N\\<close> have NnoEmpty:\"N\\<noteq>0\" by auto\n    let ?QQ=\"{\\<langle>n,{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\\<rangle>. n\\<in>N}\"\n    have QQPi:\"?QQ:N\\<rightarrow>{{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}. n\\<in>N}\" unfolding Pi_def function_def domain_def by auto\n    {\n      fix n assume \"n\\<in>N\"\n      with \\<open>N\\<subseteq>{snd(B). B\\<in>?U}\\<close> obtain B where \"n=snd(B)\" \"B\\<in>?U\" by auto\n      then have \"fst(B)\\<in>{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\" by auto\n      then have \"{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\\<noteq>0\" by auto moreover\n      from \\<open>n\\<in>N\\<close> have \"\\<langle>n,{fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\\<rangle>\\<in>?QQ\" by auto\n      with QQPi have \"?QQ`n={fst(B). B\\<in>{A\\<in>?U. snd(A)=n}}\" using apply_equality by auto\n      ultimately have \"?QQ`n\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>n\\<in>N. ?QQ`n\\<noteq>0\" by auto\n    with \\<open>n\\<in>nat\\<close> \\<open>N\\<lesssim>n\\<close> have \"\\<exists>f. f\\<in>Pi(N,\\<lambda>t. ?QQ`t) \\<and> (\\<forall>t\\<in>N. f`t\\<in>?QQ`t)\" using finite_choice unfolding AxiomCardinalChoiceGen_def\n      by auto\n    then obtain f where fPI:\"f\\<in>Pi(N,\\<lambda>t. ?QQ`t)\" \"(\\<forall>t\\<in>N. f`t\\<in>?QQ`t)\" by auto\n    from fPI(1) NnoEmpty have \"range(f)\\<noteq>0\" unfolding Pi_def range_def domain_def converse_def by (safe,blast)\n    {\n      fix t assume \"t\\<in>N\"\n      then have \"f`t\\<in>?QQ`t\" using fPI(2) by auto\n      with \\<open>t\\<in>N\\<close> have \"f`t\\<in>\\<Union>(?QQ``N)\" \"?QQ`t\\<subseteq>\\<Union>(?QQ``N)\" using func_imagedef QQPi by auto\n    }\n    then have reg:\"\\<forall>t\\<in>N. f`t\\<in>\\<Union>(?QQ``N)\"  \"\\<forall>t\\<in>N. ?QQ`t\\<subseteq>\\<Union>(?QQ``N)\" by auto\n    {\n      fix tt assume \"tt\\<in>f\"\n      with fPI(1) have \"tt\\<in>Sigma(N, (`)(?QQ))\" unfolding Pi_def by auto\n      then have \"tt\\<in>(\\<Union>xa\\<in>N. \\<Union>y\\<in>?QQ`xa. {\\<langle>xa,y\\<rangle>})\" unfolding Sigma_def by auto\n      then obtain xa y where \"xa\\<in>N\" \"y\\<in>?QQ`xa\" \"tt=\\<langle>xa,y\\<rangle>\" by auto\n      with reg(2) have \"y\\<in>\\<Union>(?QQ``N)\" by blast\n      with \\<open>tt=\\<langle>xa,y\\<rangle>\\<close> \\<open>xa\\<in>N\\<close> have \"tt\\<in>(\\<Union>xa\\<in>N. \\<Union>y\\<in>\\<Union>(?QQ``N). {\\<langle>xa,y\\<rangle>})\" by auto\n      then have \"tt\\<in>N\\<times>(\\<Union>(?QQ``N))\" unfolding Sigma_def by auto\n    }\n    then have ffun:\"f:N\\<rightarrow>\\<Union>(?QQ``N)\"  using fPI(1) unfolding Pi_def by auto\n    then have \"f\\<in>surj(N,range(f))\" using fun_is_surj by auto\n    with \\<open>N\\<lesssim>n\\<close> \\<open>n\\<in>nat\\<close> have \"range(f)\\<lesssim>N\" using surj_fun_inv_2 nat_into_Ord by auto\n    with \\<open>N\\<lesssim>n\\<close> have \"range(f)\\<lesssim>n\" using lepoll_trans by blast\n    with \\<open>n\\<in>nat\\<close> have \"Finite(range(f))\" using n_lesspoll_nat lesspoll_nat_is_Finite lesspoll_trans1 by auto\n    moreover from ffun have rr:\"range(f)\\<subseteq>\\<Union>(?QQ``N)\" unfolding Pi_def by auto\n    then have \"range(f)\\<subseteq>T\" by auto\n    ultimately have \"range(f)\\<in>FinPow(T)\" unfolding FinPow_def by auto\n    then have \"\\<Inter>range(f)\\<in>T\" using fin_inter_open_open \\<open>range(f)\\<noteq>0\\<close> by auto moreover\n    {\n      fix S assume \"S\\<in>range(f)\"\n      with rr have \"S\\<in>\\<Union>(?QQ``N)\" by blast\n      then have \"\\<exists>B\\<in>(?QQ``N). S \\<in> B\" using Union_iff by auto\n      then obtain B where \"B\\<in>(?QQ``N)\" \"S\\<in>B\" by auto\n      then have \"\\<exists>rr\\<in>N. \\<langle>rr,B\\<rangle>\\<in>?QQ\" unfolding image_def by auto\n      then have \"\\<exists>rr\\<in>N. B={fst(B). B\\<in>{A\\<in>?U. snd(A)=rr}}\" by auto\n      with \\<open>S\\<in>B\\<close> obtain rr where \"\\<langle>S,rr\\<rangle>\\<in>?U\" by auto\n      then have \"A\\<subseteq>S\" by auto\n    }\n    then have \"A\\<subseteq>\\<Inter>range(f)\" using \\<open>range(f)\\<noteq>0\\<close> by auto moreover\n    {\n      fix y assume \"y\\<in>(\\<Union>N)\\<inter>(\\<Inter>range(f))\"\n      then have reg:\"(\\<forall>S\\<in>range(f). y\\<in>S)\\<and>(\\<exists>t\\<in>N. y\\<in>t)\" by auto\n      then obtain t where \"t\\<in>N\" \"y\\<in>t\" by auto\n      then have \"\\<langle>t, {fst(B). B\\<in>{A\\<in>?U. snd(A)=t}}\\<rangle>\\<in>?QQ\" by auto\n      then have \"f`t\\<in>range(f)\" using apply_rangeI ffun by auto\n      with reg have yft:\"y\\<in>f`t\" by auto\n      with \\<open>t\\<in>N\\<close> fPI(2) have \"f`t\\<in>?QQ`t\" by auto\n      with \\<open>t\\<in>N\\<close> have \"f`t\\<in>{fst(B). B\\<in>{A\\<in>?U. snd(A)=t}}\" using apply_equality QQPi by auto\n      then have \"\\<langle>f`t,t\\<rangle>\\<in>?U\" by auto\n      then have \"f`t\\<inter>t=0\" by auto\n      with \\<open>y\\<in>t\\<close> yft have \"False\" by auto\n    }\n    then have \"(\\<Inter>range(f))\\<inter>(\\<Union>N)=0\" by blast moreover\n    note NN\n    ultimately have ?thesis by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2210
    },
    "1994": {
        "type": "corollary",
        "text": "text\\<open>A compact Hausdorff space is normal.\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>2}\" \"(\\<Union>T){is compact in}T\"\n  ",
        "using": [
            "Compact_is_card_nat",
            "compact_closed[OF",
            "car_nat]",
            "T2_compact_compact",
            "assms(1)"
        ],
        "statement": "corollary (in topology0) T2_compact_is_normal:\n  assumes \"T{is T\\<^sub>2}\" \"(\\<Union>T){is compact in}T\"\n  shows \"T{is normal}\" unfolding IsNormal_def\n",
        "proof": "proof-\n  from assms(2) have car_nat:\"(\\<Union>T){is compact of cardinal}nat{in}T\" using Compact_is_card_nat by auto\n  {\n    fix A B assume \"A{is closed in}T\" \"B{is closed in}T\"\"A\\<inter>B=0\"\n    then have com:\"((\\<Union>T)\\<inter>A){is compact of cardinal}nat{in}T\" \"((\\<Union>T)\\<inter>B){is compact of cardinal}nat{in}T\" using compact_closed[OF car_nat] \n      by auto\n    from \\<open>A{is closed in}T\\<close>\\<open>B{is closed in}T\\<close> have \"(\\<Union>T)\\<inter>A=A\"\"(\\<Union>T)\\<inter>B=B\" unfolding IsClosed_def by auto\n    with com have \"A{is compact of cardinal}nat{in}T\" \"B{is compact of cardinal}nat{in}T\" by auto\n    then have \"A{is compact in}T\"\"B{is compact in}T\" using Compact_is_card_nat by auto\n    with \\<open>A\\<inter>B=0\\<close> have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. A\\<subseteq>U \\<and> B\\<subseteq>V \\<and> U\\<inter>V=0\" using T2_compact_compact assms(1) by auto\n  }\n  then show \" \\<forall>A. A {is closed in} T \\<longrightarrow> (\\<forall>B. B {is closed in} T \\<and> A \\<inter> B = 0 \\<longrightarrow> (\\<exists>U\\<in>T. \\<exists>V\\<in>T. A \\<subseteq> U \\<and> B \\<subseteq> V \\<and> U \\<inter> V = 0))\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2211
    },
    "1995": {
        "type": "definition",
        "text": "text\\<open>A topological property is hereditary if whenever a space has it, \nevery subspace also has it.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition IsHer (\"_{is hereditary}\" 90)\n  where \"P {is hereditary} \\<equiv> \\<forall>T. T{is a topology} \\<and> P(T) \\<longrightarrow> (\\<forall>A\\<in>Pow(\\<Union>T). P(T{restricted to}A))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2212
    },
    "1996": {
        "type": "theorem",
        "text": "text\\<open>The separation properties $T_0$, $T_1$, $T_2$ y $T_3$ are hereditary.\\<close>\n",
        "assumes": "assumes \"T{is regular}\" \"A\\<in>Pow(\\<Union>T)\" ",
        "using": [
            "IsClosed_def",
            "\\<open>C\\<subseteq>\\<Union>T-S\\<close>",
            "IsRegular_def"
        ],
        "statement": "theorem regular_here:\n  assumes \"T{is regular}\" \"A\\<in>Pow(\\<Union>T)\" shows \"(T{restricted to}A){is regular}\"\n",
        "proof": "proof-\n  {\n    fix C\n    assume A:\"C{is closed in}(T{restricted to}A)\"\n    {fix y assume \"y\\<in>\\<Union>(T{restricted to}A)\"\"y\\<notin>C\"\n    with A have \"(\\<Union>(T{restricted to}A))-C\\<in>(T{restricted to}A)\"\"C\\<subseteq>\\<Union>(T{restricted to}A)\" \"y\\<in>\\<Union>(T{restricted to}A)\"\"y\\<notin>C\" unfolding IsClosed_def\n      by auto\n    moreover\n    with assms(2) have \"\\<Union>(T{restricted to}A)=A\" unfolding RestrictedTo_def by auto\n    ultimately have \"A-C\\<in>T{restricted to}A\" \"y\\<in>A\"\"y\\<notin>C\"\"C\\<in>Pow(A)\" by auto\n    then obtain S where \"S\\<in>T\" \"A\\<inter>S=A-C\" \"y\\<in>A\"\"y\\<notin>C\" unfolding RestrictedTo_def by auto\n    then have \"y\\<in>A-C\"\"A\\<inter>S=A-C\" by auto\n    with \\<open>C\\<in>Pow(A)\\<close> have \"y\\<in>A\\<inter>S\"\"C=A-A\\<inter>S\" by auto\n    then have \"y\\<in>S\" \"C=A-S\" by auto\n    with assms(2) have \"y\\<in>S\" \"C\\<subseteq>\\<Union>T-S\" by auto\n    moreover\n    from \\<open>S\\<in>T\\<close> have \"\\<Union>T-(\\<Union>T-S)=S\" by auto\n    moreover\n    with \\<open>S\\<in>T\\<close> have \"(\\<Union>T-S) {is closed in}T\" using IsClosed_def by auto\n    ultimately have \"y\\<in>\\<Union>T-(\\<Union>T-S)\" \"(\\<Union>T-S) {is closed in}T\" by auto\n    with assms(1) have \"\\<forall>y\\<in>\\<Union>T-(\\<Union>T-S). \\<exists>U\\<in>T. \\<exists>V\\<in>T. (\\<Union>T-S)\\<subseteq>U\\<and>y\\<in>V\\<and>U\\<inter>V=0\" unfolding IsRegular_def by auto\n    with \\<open>y\\<in>\\<Union>T-(\\<Union>T-S)\\<close> have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. (\\<Union>T-S)\\<subseteq>U\\<and>y\\<in>V\\<and>U\\<inter>V=0\" by auto\n    then obtain U V where \"U\\<in>T\"\"V\\<in>T\" \"\\<Union>T-S\\<subseteq>U\"\"y\\<in>V\"\"U\\<inter>V=0\" by auto\n    then have \"A\\<inter>U\\<in>(T{restricted to}A)\"\"A\\<inter>V\\<in>(T{restricted to}A)\" \"C\\<subseteq>U\"\"y\\<in>V\"\"(A\\<inter>U)\\<inter>(A\\<inter>V)=0\"\n      unfolding RestrictedTo_def  using \\<open>C\\<subseteq>\\<Union>T-S\\<close> by auto\n    moreover\n    with \\<open>C\\<in>Pow(A)\\<close>\\<open>y\\<in>A\\<close> have \"C\\<subseteq>A\\<inter>U\"\"y\\<in>A\\<inter>V\" by auto\n    ultimately have \"\\<exists>U\\<in>(T{restricted to}A). \\<exists>V\\<in>(T{restricted to}A). C\\<subseteq>U\\<and>y\\<in>V\\<and>U\\<inter>V=0\" by auto\n  }\n    then have \"\\<forall>x\\<in>\\<Union>(T{restricted to}A)-C. \\<exists>U\\<in>(T{restricted to}A). \\<exists>V\\<in>(T{restricted to}A). C\\<subseteq>U\\<and>x\\<in>V\\<and>U\\<inter>V=0\" by auto\n  }\n  then have \"\\<forall>C. C{is closed in}(T{restricted to}A) \\<longrightarrow> (\\<forall>x\\<in>\\<Union>(T{restricted to}A)-C. \\<exists>U\\<in>(T{restricted to}A). \\<exists>V\\<in>(T{restricted to}A). C\\<subseteq>U\\<and>x\\<in>V\\<and>U\\<inter>V=0)\"\n   by blast\n  then show ?thesis using IsRegular_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2213
    },
    "1997": {
        "type": "definition",
        "text": "text\\<open>The spectrum of a property gives us the list of sets for which the property doesn't give\nany topological information. Being in the spectrum of a topological property is an invariant\nin the category of sets and function; mening that equipollent sets are in the same\nspectra.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition Spec (\"_ {is in the spectrum of} _\" 99)\n  where \"Spec(K,P) \\<equiv> \\<forall>T. ((T{is a topology} \\<and> \\<Union>T\\<approx>K) \\<longrightarrow> P(T))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2214
    },
    "1998": {
        "type": "theorem",
        "text": "text\\<open>Here is an example of the spectrum. The proof lies in the indiscrite filter \\<open>{A}\\<close>\nthat can be build for any set. In this proof, we see that without choice,\nthere is no way to define the sepctrum of a property with cardinals because if a set is not \ncomparable with any ordinal, its cardinal is defined as \\<open>0\\<close> without the set being\nempty.\\<close>\n",
        "assumes": "",
        "using": [
            "Spec_def",
            "IsFilter_def",
            "top_of_filter",
            "eqpoll_refl",
            "reg",
            "topology0.T3_is_T2",
            "topology0.T4_is_T3",
            "topology0_def",
            "top",
            "filter_T2_imp_card1[of",
            "\"{A}\"\"x\"]",
            "singleton_eqpoll_1",
            "empty_lepollI",
            "eqpoll_imp_lepoll",
            "eq_lepoll_trans",
            "lepoll_1_is_sing",
            "eqpoll_trans",
            "eqpoll_0_is_0",
            "isT2_def",
            "T2_is_T1",
            "empty_open",
            "IsClosed_def",
            "AS(1)",
            "IsNormal_def",
            "isT4_def",
            "eqpoll_trans[of",
            "\"\\<Union>T\"\"A\"\"1\"]",
            "eqpoll_sym",
            "\\<open>x\\<inter>y=0\\<close>",
            "\\<open>\\<Union>T={R}\\<close>",
            "\\<open>y\\<subseteq>\\<Union>T\\<close>",
            "IsATopology_def",
            "\\<open>x\\<subseteq>\\<Union>T\\<close>",
            "isT1_def",
            "\\<open>A\\<approx>0\\<or>A\\<approx>1\\<close>"
        ],
        "statement": "theorem T4_spectrum:\n  shows \"(A {is in the spectrum of} isT4) \\<longleftrightarrow> A \\<lesssim> 1\"\n",
        "proof": "proof\n  assume \"A {is in the spectrum of} isT4\"\n  then have reg:\"\\<forall>T. ((T{is a topology} \\<and> \\<Union>T\\<approx>A) \\<longrightarrow> (T {is T\\<^sub>4}))\" using Spec_def by auto\n  {\n    assume \"A\\<noteq>0\"\n    then obtain x where \"x\\<in>A\" by auto\n    then have \"x\\<in>\\<Union>{A}\" by auto\n    moreover\n    then have \"{A} {is a filter on}\\<Union>{A}\" using IsFilter_def by auto\n    moreover\n    then have \"({A}\\<union>{0}) {is a topology} \\<and> \\<Union>({A}\\<union>{0})=A\" using top_of_filter by auto\n    then have top:\"({A}\\<union>{0}) {is a topology}\" \"\\<Union>({A}\\<union>{0})\\<approx>A\" using eqpoll_refl by auto\n    then have \"({A}\\<union>{0}) {is T\\<^sub>4}\" using reg by auto\n    then have \"({A}\\<union>{0}) {is T\\<^sub>2}\" using topology0.T3_is_T2 topology0.T4_is_T3 topology0_def top by auto\n    ultimately have \"\\<Union>{A}={x}\" using filter_T2_imp_card1[of \"{A}\"\"x\"] by auto\n    then have \"A={x}\" by auto\n    then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n  }\n  moreover\n  have \"A=0 \\<longrightarrow> A\\<approx>0\" by auto\n  ultimately have \"A\\<approx>1\\<or>A\\<approx>0\" by blast\n  then show \"A\\<lesssim>1\" using empty_lepollI eqpoll_imp_lepoll eq_lepoll_trans by auto\nnext\n  assume \"A\\<lesssim>1\"\n  have \"A=0\\<or>A\\<noteq>0\" by auto\n  then obtain E where \"A=0\\<or>E\\<in>A\" by auto\n  then have \"A\\<approx>0\\<or>E\\<in>A\" by auto\n  with \\<open>A\\<lesssim>1\\<close> have \"A\\<approx>0\\<or>A={E}\" using lepoll_1_is_sing by auto\n  then have \"A\\<approx>0\\<or>A\\<approx>1\" using singleton_eqpoll_1 by auto\n  {\n    fix T\n    assume AS:\"T{is a topology}\"\"\\<Union>T\\<approx>A\"\n    {\n      assume \"A\\<approx>0\"\n      with AS have \"T{is a topology}\" and empty:\"\\<Union>T=0\" using eqpoll_trans eqpoll_0_is_0 by auto\n      then have \"T{is T\\<^sub>2}\" using isT2_def by auto\n      then have \"T{is T\\<^sub>1}\" using T2_is_T1 by auto\n      moreover\n      from empty have \"T\\<subseteq>{0}\" by auto\n      with AS(1) have \"T={0}\" using empty_open by auto\n      from empty have rr:\"\\<forall>A. A{is closed in}T \\<longrightarrow> A=0\" using IsClosed_def by auto\n      have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. 0\\<subseteq>U\\<and>0\\<subseteq>V\\<and>U\\<inter>V=0\" using empty_open AS(1) by auto\n      with rr have \"\\<forall>A. A{is closed in}T \\<longrightarrow> (\\<forall>B. B{is closed in}T \\<and> A\\<inter>B=0 \\<longrightarrow> (\\<exists>U\\<in>T. \\<exists>V\\<in>T. A\\<subseteq>U\\<and>B\\<subseteq>V\\<and>U\\<inter>V=0))\"\n        by blast\n      then have \"T{is normal}\" using IsNormal_def by auto\n      with \\<open>T{is T\\<^sub>1}\\<close> have \"T{is T\\<^sub>4}\" using isT4_def by auto\n    }\n    moreover\n    {\n      assume \"A\\<approx>1\"\n      with AS have \"T{is a topology}\" and NONempty:\"\\<Union>T\\<approx>1\" using eqpoll_trans[of \"\\<Union>T\"\"A\"\"1\"] by auto\n      then have \"\\<Union>T\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n      moreover\n      {\n        assume \"\\<Union>T=0\"\n        then have \"0\\<approx>\\<Union>T\" by auto\n        with NONempty have \"0\\<approx>1\" using eqpoll_trans by blast\n        then have \"0=1\" using eqpoll_0_is_0 eqpoll_sym by auto\n        then have \"False\" by auto\n      }\n      then have \"\\<Union>T\\<noteq>0\" by auto\n      then obtain R where \"R\\<in>\\<Union>T\" by blast\n      ultimately have \"\\<Union>T={R}\" using lepoll_1_is_sing by auto\n      {\n        fix x y\n        assume \"x{is closed in}T\"\"y{is closed in}T\" \"x\\<inter>y=0\"\n        then have \"x\\<subseteq>\\<Union>T\"\"y\\<subseteq>\\<Union>T\" using IsClosed_def by auto\n        then have \"x=0\\<or>y=0\" using \\<open>x\\<inter>y=0\\<close> \\<open>\\<Union>T={R}\\<close> by force\n        {\n          assume \"x=0\"\n          then have \"x\\<subseteq>0\"\"y\\<subseteq>\\<Union>T\" using \\<open>y\\<subseteq>\\<Union>T\\<close> by auto\n          moreover\n          have \"0\\<in>T\"\"\\<Union>T\\<in>T\" using AS(1) IsATopology_def empty_open by auto\n          ultimately have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<subseteq>U\\<and>y\\<subseteq>V\\<and>U\\<inter>V=0\" by auto\n        }\n        moreover\n        {\n          assume \"x\\<noteq>0\"\n          with \\<open>x=0\\<or>y=0\\<close> have \"y=0\" by auto\n          then have \"x\\<subseteq>\\<Union>T\"\"y\\<subseteq>0\" using \\<open>x\\<subseteq>\\<Union>T\\<close> by auto\n          moreover\n          have \"0\\<in>T\"\"\\<Union>T\\<in>T\" using AS(1) IsATopology_def empty_open by auto\n          ultimately have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<subseteq>U\\<and>y\\<subseteq>V\\<and>U\\<inter>V=0\" by auto\n        }\n        ultimately\n        have \"(\\<exists>U\\<in>T. \\<exists>V\\<in>T. x \\<subseteq> U \\<and> y \\<subseteq> V \\<and> U \\<inter> V = 0)\" by blast\n      }\n      then have \"T{is normal}\" using IsNormal_def by auto\n      moreover\n      {\n        fix x y\n        assume \"x\\<in>\\<Union>T\"\"y\\<in>\\<Union>T\"\"x\\<noteq>y\"\n        with \\<open>\\<Union>T={R}\\<close> have \"False\" by auto\n        then have \"\\<exists>U\\<in>T. x\\<in>U\\<and>y\\<notin>U\" by auto\n      }\n      then have \"T{is T\\<^sub>1}\" using isT1_def by auto\n      ultimately have \"T{is T\\<^sub>4}\" using isT4_def by auto\n    }\n    ultimately have \"T{is T\\<^sub>4}\" using \\<open>A\\<approx>0\\<or>A\\<approx>1\\<close> by auto\n  }\n  then have \"\\<forall>T. (T{is a topology} \\<and> \\<Union>T \\<approx> A) \\<longrightarrow> (T{is T\\<^sub>4})\" by auto\n  then show \"A {is in the spectrum of} isT4\" using Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2215
    },
    "1999": {
        "type": "lemma",
        "text": "text\\<open>If the topological properties are related, then so are the spectra.\\<close>\n",
        "assumes": "assumes \"\\<forall>T. T{is a topology} \\<longrightarrow> (Q(T) \\<longrightarrow> P(T))\"  \"A {is in the spectrum of} Q\"\n  ",
        "using": [
            "Spec_def"
        ],
        "statement": "lemma P_imp_Q_spec_inv:\n  assumes \"\\<forall>T. T{is a topology} \\<longrightarrow> (Q(T) \\<longrightarrow> P(T))\"  \"A {is in the spectrum of} Q\"\n  shows \"A {is in the spectrum of} P\"\n",
        "proof": "proof-\n  from assms(2) have \"\\<forall>T. T{is a topology} \\<and> \\<Union>T \\<approx> A \\<longrightarrow> Q(T)\" using Spec_def by auto\n  with assms(1) have \"\\<forall>T. T{is a topology} \\<and> \\<Union>T \\<approx> A \\<longrightarrow> P(T)\" by auto\n  then show ?thesis using Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2216
    },
    "2000": {
        "type": "theorem",
        "text": "text\\<open>Since we already now the spectrum of $T_4$; if we now the spectrum of $T_0$,\nit should be easier to compute the spectrum of $T_1$, $T_2$ and $T_3$.\\<close>\n",
        "assumes": "",
        "using": [
            "Spec_def",
            "IsFilter_def",
            "top_of_filter",
            "eqpoll_refl",
            "reg",
            "isT0_def",
            "singleton_eqpoll_1",
            "empty_lepollI",
            "eqpoll_imp_lepoll",
            "eq_lepoll_trans",
            "topology0.T4_is_T3",
            "topology0.T3_is_T2",
            "T2_is_T1",
            "T1_is_T0",
            "topology0_def",
            "P_imp_Q_spec_inv[of",
            "\"\\<lambda>T.",
            "(T{is",
            "T\\<^sub>4})\"\"\\<lambda>T.",
            "T{is",
            "T\\<^sub>0}\"]",
            "T4_spectrum",
            "\\<open>A\\<lesssim>1\\<close>"
        ],
        "statement": "theorem T0_spectrum:\n  shows \"(A {is in the spectrum of} isT0) \\<longleftrightarrow> A \\<lesssim> 1\"\n",
        "proof": "proof\n  assume \"A {is in the spectrum of} isT0\"\n  then have reg:\"\\<forall>T. ((T{is a topology} \\<and> \\<Union>T\\<approx>A) \\<longrightarrow> (T {is T\\<^sub>0}))\" using Spec_def by auto\n  {\n    assume \"A\\<noteq>0\"\n    then obtain x where \"x\\<in>A\" by auto\n    then have \"x\\<in>\\<Union>{A}\" by auto\n    moreover\n    then have \"{A} {is a filter on}\\<Union>{A}\" using IsFilter_def by auto\n    moreover\n    then have \"({A}\\<union>{0}) {is a topology} \\<and> \\<Union>({A}\\<union>{0})=A\" using top_of_filter by auto\n    then have \"({A}\\<union>{0}) {is a topology} \\<and> \\<Union>({A}\\<union>{0})\\<approx>A\" using eqpoll_refl by auto\n    then have \"({A}\\<union>{0}) {is T\\<^sub>0}\" using reg by auto\n    {\n      fix y\n      assume \"y\\<in>A\"\"x\\<noteq>y\"\n      with \\<open>({A}\\<union>{0}) {is T\\<^sub>0}\\<close> obtain U where \"U\\<in>({A}\\<union>{0})\" and dis:\"(x \\<in> U \\<and> y \\<notin> U) \\<or> (y \\<in> U \\<and> x \\<notin> U)\" using isT0_def by auto\n      then have \"U=A\" by auto\n      with dis \\<open>y\\<in>A\\<close> \\<open>x\\<in>\\<Union>{A}\\<close> have \"False\" by auto\n    }\n    then have \"\\<forall>y\\<in>A. y=x\" by auto\n    with \\<open>x\\<in>\\<Union>{A}\\<close> have \"A={x}\" by blast\n    then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n  }\n  moreover\n  have \"A=0 \\<longrightarrow> A\\<approx>0\" by auto\n  ultimately have \"A\\<approx>1\\<or>A\\<approx>0\" by blast\n  then show \"A\\<lesssim>1\" using empty_lepollI eqpoll_imp_lepoll eq_lepoll_trans by auto\nnext\n  assume \"A\\<lesssim>1\"\n  {\n    fix T\n    assume \"T{is a topology}\"\n    then have \"(T{is T\\<^sub>4})\\<longrightarrow>(T{is T\\<^sub>0})\" using topology0.T4_is_T3 topology0.T3_is_T2 T2_is_T1 T1_is_T0 \n      topology0_def by auto\n  }\n  then have \"\\<forall>T. T{is a topology} \\<longrightarrow> ((T{is T\\<^sub>4})\\<longrightarrow>(T{is T\\<^sub>0}))\" by auto\n  then have \"(A {is in the spectrum of} isT4) \\<longrightarrow> (A {is in the spectrum of} isT0)\"\n    using P_imp_Q_spec_inv[of \"\\<lambda>T. (T{is T\\<^sub>4})\"\"\\<lambda>T. T{is T\\<^sub>0}\"] by auto\n  then show \"(A {is in the spectrum of} isT0)\" using T4_spectrum \\<open>A\\<lesssim>1\\<close> by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2217
    },
    "2001": {
        "type": "theorem",
        "text": "text\\<open>It is, at least for some people, surprising that the spectrum of some properties cannot be completely\ndetermined in \\emph{ZF}.\\<close>\n",
        "assumes": "assumes \"{the axiom of}K{choice holds for subsets}(Pow(K))\" \"Card(K)\"\n  ",
        "using": [
            "Spec_def",
            "Pow_is_top[of",
            "\"A\"]",
            "FinPow_def",
            "apply_equality",
            "lepoll_def",
            "lesspoll_trans1",
            "Card_less_csucc_eq_le",
            "assms(2)",
            "Pow_is_top",
            "Pi_def",
            "function_def",
            "eqpoll_def",
            "eqpoll_sym",
            "eqpoll_trans",
            "eqpoll_imp_lepoll",
            "lepoll_trans",
            "compact_of_cardinal_Q[of",
            "\"K\"\"Pow(\\<Union>T)\"]",
            "compact_coarser"
        ],
        "statement": "theorem compactK_spectrum:\n  assumes \"{the axiom of}K{choice holds for subsets}(Pow(K))\" \"Card(K)\"\n  shows \"(A {is in the spectrum of} (\\<lambda>T. ((\\<Union>T){is compact of cardinal} csucc(K){in}T))) \\<longleftrightarrow> (A\\<lesssim>K)\"\n",
        "proof": "proof\n  assume \"A {is in the spectrum of} (\\<lambda>T. ((\\<Union>T){is compact of cardinal} csucc(K){in}T))\"\n  then have reg:\"\\<forall>T. T{is a topology}\\<and>\\<Union>T\\<approx>A \\<longrightarrow> ((\\<Union>T){is compact of cardinal} csucc(K){in}T)\" using Spec_def by auto\n  then have \"A{is compact of cardinal} csucc(K) {in} Pow(A)\" using Pow_is_top[of \"A\"] by auto\n  then have \"\\<forall>M\\<in>Pow(Pow(A)). A\\<subseteq>\\<Union>M \\<longrightarrow> (\\<exists>N\\<in>Pow(M). A\\<subseteq>\\<Union>N \\<and> N\\<prec>csucc(K))\" unfolding IsCompactOfCard_def by auto\n  moreover\n  have \"{{x}. x\\<in>A}\\<in>Pow(Pow(A))\" by auto\n  moreover\n  have \"A=\\<Union>{{x}. x\\<in>A}\" by auto\n  ultimately have \"\\<exists>N\\<in>Pow({{x}. x\\<in>A}). A\\<subseteq>\\<Union>N \\<and> N\\<prec>csucc(K)\" by auto\n  then obtain N where \"N\\<in>Pow({{x}. x\\<in>A})\" \"A\\<subseteq>\\<Union>N\" \"N\\<prec>csucc(K)\" by auto\n  then have \"N\\<subseteq>{{x}. x\\<in>A}\" \"N\\<prec>csucc(K)\" \"A\\<subseteq>\\<Union>N\" using FinPow_def by auto\n  {\n    fix t\n    assume \"t\\<in>{{x}. x\\<in>A}\"\n    then obtain x where \"x\\<in>A\"\"t={x}\" by auto\n    with \\<open>A\\<subseteq>\\<Union>N\\<close> have \"x\\<in>\\<Union>N\" by auto\n    then obtain B where \"B\\<in>N\"\"x\\<in>B\" by auto\n    with \\<open>N\\<subseteq>{{x}. x\\<in>A}\\<close> have \"B={x}\" by auto\n    with \\<open>t={x}\\<close>\\<open>B\\<in>N\\<close> have \"t\\<in>N\" by auto \n  }\n  with \\<open>N\\<subseteq>{{x}. x\\<in>A}\\<close> have \"N={{x}. x\\<in>A}\" by auto\n  let ?B=\"{\\<langle>x,{x}\\<rangle>. x\\<in>A}\"\n  from \\<open>N={{x}. x\\<in>A}\\<close> have \"?B:A\\<rightarrow> N\" unfolding Pi_def function_def by auto\n  with \\<open>N={{x}. x\\<in>A}\\<close> have \"?B:inj(A,N)\" unfolding inj_def using apply_equality by auto\n  then have \"A\\<lesssim>N\" using lepoll_def by auto\n  with \\<open>N\\<prec>csucc(K)\\<close> have \"A\\<prec>csucc(K)\" using lesspoll_trans1 by auto\n  then show \"A\\<lesssim>K\" using Card_less_csucc_eq_le assms(2) by auto\nnext\n  assume \"A\\<lesssim>K\"\n  {\n    fix T\n    assume \"T{is a topology}\"\"\\<Union>T\\<approx>A\"\n    have \"Pow(\\<Union>T){is a topology}\" using Pow_is_top by auto\n    {\n      fix B\n      assume AS:\"B\\<in>Pow(\\<Union>T)\"\n      then have \"{{i}. i\\<in>B}\\<subseteq>{{i} .i\\<in>\\<Union>T}\" by auto\n      moreover\n      have \"B=\\<Union>{{i}. i\\<in>B}\" by auto\n      ultimately have \"\\<exists>S\\<in>Pow({{i}. i\\<in>\\<Union>T}). B=\\<Union>S\" by auto\n      then have \"B\\<in>{\\<Union>U. U\\<in>Pow({{i}. i\\<in>\\<Union>T})}\" by auto\n    }\n    moreover\n    {\n      fix B\n      assume AS:\"B\\<in>{\\<Union>U. U\\<in>Pow({{i}. i\\<in>\\<Union>T})}\"\n      then have \"B\\<in>Pow(\\<Union>T)\" by auto\n    }\n    ultimately\n    have base:\"{{x}. x\\<in>\\<Union>T} {is a base for}Pow(\\<Union>T)\" unfolding IsAbaseFor_def by auto\n    let ?f=\"{\\<langle>i,{i}\\<rangle>. i\\<in>\\<Union>T}\"\n    have f:\"?f:\\<Union>T\\<rightarrow> {{x}. x\\<in>\\<Union>T}\" using Pi_def function_def by auto\n    moreover\n    {\n      fix w x\n      assume as:\"w\\<in>\\<Union>T\"\"x\\<in>\\<Union>T\"\"?f`w=?f`x\"\n      with f have \"?f`w={w}\" \"?f`x={x}\" using apply_equality by auto\n      with as(3) have \"w=x\" by auto\n    }\n    with f have \"?f:inj(\\<Union>T,{{x}. x\\<in>\\<Union>T})\" unfolding inj_def by auto\n    moreover\n    {\n      fix xa\n      assume \"xa\\<in>{{x}. x\\<in>\\<Union>T}\"\n      then obtain x where \"x\\<in>\\<Union>T\"\"xa={x}\" by auto\n      with f have \"?f`x=xa\" using apply_equality by auto\n      with \\<open>x\\<in>\\<Union>T\\<close> have \"\\<exists>x\\<in>\\<Union>T. ?f`x=xa\" by auto\n    }\n    then have \"\\<forall>xa\\<in>{{x}. x\\<in>\\<Union>T}. \\<exists>x\\<in>\\<Union>T. ?f`x=xa\" by blast\n    ultimately have \"?f:bij(\\<Union>T,{{x}. x\\<in>\\<Union>T})\" unfolding bij_def surj_def by auto\n    then have \"\\<Union>T\\<approx>{{x}. x\\<in>\\<Union>T}\" using eqpoll_def by auto\n    then have \"{{x}. x\\<in>\\<Union>T}\\<approx>\\<Union>T\" using eqpoll_sym by auto\n    with \\<open>\\<Union>T\\<approx>A\\<close> have \"{{x}. x\\<in>\\<Union>T}\\<approx>A\" using eqpoll_trans by blast\n    then have \"{{x}. x\\<in>\\<Union>T}\\<lesssim>A\" using eqpoll_imp_lepoll by auto\n    with \\<open>A\\<lesssim>K\\<close> have \"{{x}. x\\<in>\\<Union>T}\\<lesssim>K\" using lepoll_trans by blast\n    then have \"{{x}. x\\<in>\\<Union>T}\\<prec>csucc(K)\" using assms(2) Card_less_csucc_eq_le by auto\n    with base have \"Pow(\\<Union>T) {is of second type of cardinal}csucc(K)\" unfolding IsSecondOfCard_def by auto\n    moreover\n    have \"\\<Union>Pow(\\<Union>T)=\\<Union>T\" by auto\n    with calculation assms(1) \\<open>Pow(\\<Union>T){is a topology}\\<close> have \"(\\<Union>T) {is compact of cardinal}csucc(K){in}Pow(\\<Union>T)\" \n      using compact_of_cardinal_Q[of \"K\"\"Pow(\\<Union>T)\"] by auto\n    moreover\n    have \"T\\<subseteq>Pow(\\<Union>T)\" by auto\n    ultimately have \"(\\<Union>T) {is compact of cardinal}csucc(K){in}T\" using compact_coarser by auto\n  }\n  then show \"A {is in the spectrum of} (\\<lambda>T. ((\\<Union>T){is compact of cardinal}csucc(K) {in}T))\" using Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2218
    },
    "2002": {
        "type": "definition",
        "text": "text\\<open>The spectrum gives us the posibility to define what an anti-property means.\nA space is anti-\\<open>P\\<close> if the only subspaces which have the property\nare the ones in the spectrum of \\<open>P\\<close>. This concept tries to put together\nspaces that are completely opposite to spaces where \\<open>P(T)\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  antiProperty (\"_{is anti-}_\" 50)\n  where \"T{is anti-}P \\<equiv> \\<forall>A\\<in>Pow(\\<Union>T). P(T{restricted to}A) \\<longrightarrow> (A {is in the spectrum of} P)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2219
    },
    "2003": {
        "type": "theorem",
        "text": "text\\<open>A first, very simple, but very useful result is the following: when the properties\nare related and the spectra are equal, then the anti-properties are related in the oposite direction.\\<close>\n",
        "assumes": "assumes \"\\<forall>T. T{is a topology} \\<longrightarrow> P(T) \\<longrightarrow> Q(T)\" \"\\<forall>A. (A{is in the spectrum of}Q) \\<longrightarrow> (A{is in the spectrum of}P)\"\n    and \"T{is anti-}Q\"\n  ",
        "using": [
            "Top_1_L4",
            "antiProperty_def"
        ],
        "statement": "theorem (in topology0) eq_spect_rev_imp_anti:\n  assumes \"\\<forall>T. T{is a topology} \\<longrightarrow> P(T) \\<longrightarrow> Q(T)\" \"\\<forall>A. (A{is in the spectrum of}Q) \\<longrightarrow> (A{is in the spectrum of}P)\"\n    and \"T{is anti-}Q\"\n  shows \"T{is anti-}P\"\n",
        "proof": "proof-\n  {\n    fix A\n    assume \"A\\<in>Pow(\\<Union>T)\"\"P(T{restricted to}A)\"\n    with assms(1) have \"Q(T{restricted to}A)\" using Top_1_L4 by auto\n    with assms(3) \\<open>A\\<in>Pow(\\<Union>T)\\<close> have \"A{is in the spectrum of}Q\" using antiProperty_def by auto\n    with assms(2) have \"A{is in the spectrum of}P\" by auto\n  }\n  then show ?thesis using antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2220
    },
    "2004": {
        "type": "theorem",
        "text": "text\\<open>If a space can be \\<open>P(T)\\<and>Q(T)\\<close> only in case the underlying set is in the\nspectrum of \\<open>P\\<close>; then \\<open>Q(T)\\<longrightarrow>ANTI(P,T)\\<close> when \\<open>Q\\<close> is hereditary.\\<close>\n",
        "assumes": "assumes \"\\<forall>T. ((T{is a topology}\\<and>P(T)\\<and>Q(T))\\<longrightarrow> ((\\<Union>T){is in the spectrum of}P))\"\n    and \"Q{is hereditary}\"\n  ",
        "using": [
            "topology0.Top_1_L4",
            "topology0_def"
        ],
        "statement": "theorem Q_P_imp_Spec:\n  assumes \"\\<forall>T. ((T{is a topology}\\<and>P(T)\\<and>Q(T))\\<longrightarrow> ((\\<Union>T){is in the spectrum of}P))\"\n    and \"Q{is hereditary}\"\n  shows \"\\<forall>T. T{is a topology} \\<longrightarrow> (Q(T)\\<longrightarrow>(T{is anti-}P))\"\n",
        "proof": "proof\n  fix T\n  {\n    assume \"T{is a topology}\"\n    {\n      assume \"Q(T)\"\n      {\n        assume \"\\<not>(T{is anti-}P)\"\n        then obtain A where \"A\\<in>Pow(\\<Union>T)\" \"P(T{restricted to}A)\"\"\\<not>(A{is in the spectrum of}P)\"\n          unfolding antiProperty_def by auto\n        from \\<open>Q(T)\\<close>\\<open>T{is a topology}\\<close>\\<open>A\\<in>Pow(\\<Union>T)\\<close> assms(2) have \"Q(T{restricted to}A)\" \n          unfolding IsHer_def by auto\n        moreover\n        note \\<open>P(T{restricted to}A)\\<close> assms(1)\n        moreover\n        from \\<open>T{is a topology}\\<close> have \"(T{restricted to}A){is a topology}\" using topology0.Top_1_L4\n          topology0_def by auto\n        moreover\n        from \\<open>A\\<in>Pow(\\<Union>T)\\<close> have \"\\<Union>(T{restricted to}A)=A\" unfolding RestrictedTo_def by auto\n        ultimately have \"A{is in the spectrum of}P\" by auto\n        with \\<open>\\<not>(A{is in the spectrum of}P)\\<close> have \"False\" by auto\n      }\n      then have \"T{is anti-}P\" by auto\n    }\n    then have \"Q(T)\\<longrightarrow>(T{is anti-}P)\" by auto\n  }\n  then show \"(T {is a topology}) \\<longrightarrow> (Q(T) \\<longrightarrow> (T{is anti-}P))\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2221
    },
    "2005": {
        "type": "theorem",
        "text": "text\\<open>If a topologycal space has an hereditary property, then it has its double-anti property.\\<close>  \n",
        "assumes": "assumes \"P{is hereditary}\" \"P(T)\"\n  ",
        "using": [
            "subspace_of_subspace",
            "\\<open>A\\<in>Pow(\\<Union>T)\\<close>",
            "reg",
            "tot",
            "assms",
            "IsHer_def",
            "topSpaceAssum",
            "subset_imp_lepoll",
            "lepoll_eq_trans",
            "inj_bij_range",
            "eqpoll_iff_spec"
        ],
        "statement": "theorem (in topology0)her_P_imp_anti2P:\n  assumes \"P{is hereditary}\" \"P(T)\"\n  shows \"T{is anti-}ANTI(P)\"\n",
        "proof": "proof-\n  {\n    assume \"\\<not>(T{is anti-}ANTI(P))\"\n    then have \"\\<exists>A\\<in>Pow(\\<Union>T). ((T{restricted to}A){is anti-}P)\\<and>\\<not>(A{is in the spectrum of}ANTI(P))\"\n      unfolding antiProperty_def[of _ \"ANTI(P)\"] by auto\n    then obtain A where A_def:\"A\\<in>Pow(\\<Union>T)\"\"\\<not>(A{is in the spectrum of}ANTI(P))\"\"(T{restricted to}A){is anti-}P\"\n      by auto\n    from \\<open>A\\<in>Pow(\\<Union>T)\\<close> have tot:\"\\<Union>(T{restricted to}A)=A\" unfolding RestrictedTo_def by auto\n    from A_def have reg:\"\\<forall>B\\<in>Pow(\\<Union>(T{restricted to}A)). P((T{restricted to}A){restricted to}B) \\<longrightarrow> (B{is in the spectrum of}P)\"\n      unfolding antiProperty_def by auto\n    have \"\\<forall>B\\<in>Pow(A). (T{restricted to}A){restricted to}B=T{restricted to}B\" using subspace_of_subspace \\<open>A\\<in>Pow(\\<Union>T)\\<close> by auto\n    then have \"\\<forall>B\\<in>Pow(A). P(T{restricted to}B) \\<longrightarrow> (B{is in the spectrum of}P)\" using reg tot\n      by force\n    moreover\n    have \"\\<forall>B\\<in>Pow(A). P(T{restricted to}B)\" using assms \\<open>A\\<in>Pow(\\<Union>T)\\<close> unfolding IsHer_def using topSpaceAssum by blast\n    ultimately have reg2:\"\\<forall>B\\<in>Pow(A). (B{is in the spectrum of}P)\" by auto\n    from \\<open>\\<not>(A{is in the spectrum of}ANTI(P))\\<close> have \"\\<exists>T. T{is a topology} \\<and> \\<Union>T\\<approx>A \\<and> \\<not>(T{is anti-}P)\"\n      unfolding Spec_def by auto\n    then obtain S where \"S{is a topology}\" \"\\<Union>S\\<approx>A\" \"\\<not>(S{is anti-}P)\" by auto\n    from \\<open>\\<not>(S{is anti-}P)\\<close> have \"\\<exists>B\\<in>Pow(\\<Union>S). P(S{restricted to}B) \\<and> \\<not>(B{is in the spectrum of}P)\" unfolding antiProperty_def by auto\n    then obtain B where B_def:\"\\<not>(B{is in the spectrum of}P)\" \"B\\<in>Pow(\\<Union>S)\" by auto\n    then have \"B\\<lesssim>\\<Union>S\" using subset_imp_lepoll by auto\n    with \\<open>\\<Union>S\\<approx>A\\<close> have \"B\\<lesssim>A\" using lepoll_eq_trans by auto\n    then obtain f where \"f\\<in>inj(B,A)\" unfolding lepoll_def by auto\n    then have \"f\\<in>bij(B,range(f))\" using inj_bij_range by auto\n    then have \"B\\<approx>range(f)\" unfolding eqpoll_def by auto\n    with B_def(1) have \"\\<not>(range(f){is in the spectrum of}P)\" using eqpoll_iff_spec by auto\n    moreover\n    with \\<open>f\\<in>inj(B,A)\\<close> have \"range(f)\\<subseteq>A\" unfolding inj_def Pi_def by auto\n    with reg2 have \"range(f){is in the spectrum of}P\" by auto\n    ultimately have \"False\" by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2222
    },
    "2006": {
        "type": "theorem",
        "text": "text\\<open>The anti-properties are always hereditary\\<close>\n",
        "assumes": "",
        "using": [
            "subspace_of_subspace",
            "IsHer_def"
        ],
        "statement": "theorem anti_here:\n  shows \"ANTI(P){is hereditary}\"\n",
        "proof": "proof-\n  {\n    fix T\n    assume \"T {is a topology}\"\"ANTI(P,T)\"\n    {\n      fix A\n      assume \"A\\<in>Pow(\\<Union>T)\"\n      then have \"\\<Union>(T{restricted to}A)=A\" unfolding RestrictedTo_def by auto\n      moreover\n      {\n        fix B\n        assume \"B\\<in>Pow(A)\"\"P((T{restricted to}A){restricted to}B)\"\n        with \\<open>A\\<in>Pow(\\<Union>T)\\<close> have \"B\\<in>Pow(\\<Union>T)\"\"P(T{restricted to}B)\" using subspace_of_subspace by auto\n        with \\<open>ANTI(P,T)\\<close> have \"B{is in the spectrum of}P\" unfolding antiProperty_def by auto\n      }\n      ultimately have \"\\<forall>B\\<in>Pow(\\<Union>(T{restricted to}A)). (P((T{restricted to}A){restricted to}B)) \\<longrightarrow> (B{is in the spectrum of}P)\"\n        by auto\n      then have \"ANTI(P,(T{restricted to}A))\" unfolding antiProperty_def by auto\n    }\n    then have \"\\<forall>A\\<in>Pow(\\<Union>T). ANTI(P,(T{restricted to}A))\" by auto\n  }\n  then show ?thesis using IsHer_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2223
    },
    "2007": {
        "type": "theorem",
        "text": "text\\<open>In the article \\cite{ReVa80}, we can find some results on anti-properties.\\<close>\n",
        "assumes": "",
        "using": [
            "RestrictedTo_def",
            "isT0_def",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll",
            "T0_spectrum",
            "empty_lepollI",
            "eq_lepoll_trans",
            "antiProperty_def",
            "reg",
            "lepoll_1_is_sing[of",
            "\"{x,y}\"\"x\"]",
            "IsATopology_def",
            "empty_open"
        ],
        "statement": "theorem (in topology0) anti_T0:\n  shows \"(T{is anti-}isT0) \\<longleftrightarrow> T={0,\\<Union>T}\"\n",
        "proof": "proof\n  assume \"T={0,\\<Union>T}\"\n  {\n    fix A\n    assume \"A\\<in>Pow(\\<Union>T)\"\"(T{restricted to}A) {is T\\<^sub>0}\"\n    {\n      fix B\n      assume \"B\\<in>T{restricted to}A\"\n      then obtain S where \"S\\<in>T\" and \"B=A\\<inter>S\" unfolding RestrictedTo_def by auto\n      with \\<open>T={0,\\<Union>T}\\<close> have \"S\\<in>{0,\\<Union>T}\" by auto\n      then have \"S=0\\<or>S=\\<Union>T\" by auto\n      with \\<open>B=A\\<inter>S\\<close>\\<open>A\\<in>Pow(\\<Union>T)\\<close> have \"B=0\\<or>B=A\" by auto\n    }\n    moreover\n    {\n      have \"0\\<in>{0,\\<Union>T}\" \"\\<Union>T\\<in>{0,\\<Union>T}\" by auto\n      with \\<open>T={0,\\<Union>T}\\<close> have \"0\\<in>T\"\"(\\<Union>T)\\<in>T\" by auto\n      then have \"A\\<inter>0\\<in>(T{restricted to}A)\" \"A\\<inter>(\\<Union>T)\\<in>(T{restricted to}A)\" using RestrictedTo_def by auto\n      moreover\n      from \\<open>A\\<in>Pow(\\<Union>T)\\<close> have \"A\\<inter>(\\<Union>T)=A\" by auto\n      ultimately have \"0\\<in>(T{restricted to}A)\" \"A\\<in>(T{restricted to}A)\" by auto\n    }\n    ultimately have \"(T{restricted to}A)={0,A}\" by auto\n    with \\<open>(T{restricted to}A) {is T\\<^sub>0}\\<close> have \"{0,A} {is T\\<^sub>0}\" by auto\n    {\n      assume \"A\\<noteq>0\"\n      then obtain x where \"x\\<in>A\" by blast\n      {\n        fix y\n        assume \"y\\<in>A\"\"x\\<noteq>y\"\n        with \\<open>{0,A} {is T\\<^sub>0}\\<close> obtain U where \"U\\<in>{0,A}\" and dis:\"(x \\<in> U \\<and> y \\<notin> U) \\<or> (y \\<in> U \\<and> x \\<notin> U)\" using isT0_def by auto\n        then have \"U=A\" by auto\n        with dis \\<open>y\\<in>A\\<close> \\<open>x\\<in>A\\<close> have \"False\" by auto\n      }\n      then have \"\\<forall>y\\<in>A. y=x\" by auto\n      with \\<open>x\\<in>A\\<close> have \"A={x}\" by blast\n      then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n      then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n      then have \"A{is in the spectrum of}isT0\" using T0_spectrum by auto   \n    }\n    moreover\n    {\n      assume \"A=0\"\n      then have \"A\\<approx>0\" by auto\n      then have \"A\\<lesssim>1\" using empty_lepollI eq_lepoll_trans by auto\n      then have \"A{is in the spectrum of}isT0\" using T0_spectrum by auto\n    }\n    ultimately have \"A{is in the spectrum of}isT0\" by auto\n  }\n  then show \"T{is anti-}isT0\" using antiProperty_def by auto\nnext\n  assume \"T{is anti-}isT0\"\n  then have \"\\<forall>A\\<in>Pow(\\<Union>T). (T{restricted to}A){is T\\<^sub>0} \\<longrightarrow> (A{is in the spectrum of}isT0)\" using antiProperty_def by auto\n  then have reg:\"\\<forall>A\\<in>Pow(\\<Union>T). (T{restricted to}A){is T\\<^sub>0} \\<longrightarrow> (A\\<lesssim>1)\" using T0_spectrum by auto\n  {\n    assume \"\\<exists>A\\<in>T. A\\<noteq>0\\<and> A\\<noteq>\\<Union>T\"\n    then obtain A where \"A\\<in>T\"\"A\\<noteq>0\"\"A\\<noteq>\\<Union>T\" by auto\n    then obtain x y where \"x\\<in>A\" \"y\\<in>\\<Union>T-A\" by blast\n    with \\<open>A\\<in>T\\<close> have s:\"{x,y}\\<in>Pow(\\<Union>T)\" \"x\\<noteq>y\" by auto\n    note s\n    moreover\n    {\n      fix b1 b2\n      assume \"b1\\<in>\\<Union>(T{restricted to}{x,y})\"\"b2\\<in>\\<Union>(T{restricted to}{x,y})\"\"b1\\<noteq>b2\"\n      moreover\n      from s have \"\\<Union>(T{restricted to}{x,y})={x,y}\" unfolding RestrictedTo_def by auto\n      ultimately have \"(b1=x\\<and>b2=y)\\<or>(b1=y\\<and>b2=x)\" by auto\n      with \\<open>x\\<noteq>y\\<close> have \"(b1\\<in>{x}\\<and>b2\\<notin>{x}) \\<or> (b2\\<in>{x}\\<and>b1\\<notin>{x})\" by auto\n      moreover\n      from \\<open>y\\<in>\\<Union>T-A\\<close>\\<open>x\\<in>A\\<close> have \"{x}={x,y}\\<inter>A\" by auto\n      with \\<open>A\\<in>T\\<close> have \"{x}\\<in>(T{restricted to}{x,y})\" unfolding RestrictedTo_def by auto\n      ultimately have \"\\<exists>U\\<in>(T{restricted to}{x,y}). (b1\\<in>U\\<and>b2\\<notin>U) \\<or> (b2\\<in>U\\<and>b1\\<notin>U)\" by auto\n    }\n    then have \"(T{restricted to}{x,y}){is T\\<^sub>0}\" using isT0_def by auto\n    ultimately have \"{x,y}\\<lesssim>1\" using reg by auto\n    moreover\n    have \"x\\<in>{x,y}\" by auto\n    ultimately have \"{x,y}={x}\" using lepoll_1_is_sing[of \"{x,y}\"\"x\"] by auto\n    moreover\n    have \"y\\<in>{x,y}\" by auto\n    ultimately have \"y\\<in>{x}\" by auto\n    then have \"y=x\" by auto\n    with \\<open>x\\<noteq>y\\<close> have \"False\" by auto\n  }\n  then have \"T\\<subseteq>{0,\\<Union>T}\" by auto\n  moreover\n  from topSpaceAssum have \"0\\<in>T\"\"\\<Union>T\\<in>T\" using IsATopology_def empty_open by auto\n  ultimately show \"T={0,\\<Union>T}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2224
    },
    "2008": {
        "type": "definition",
        "text": "text\\<open>Let's define some anti-properties that we'll use in the future.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsAntiComp (\"_{is anti-compact}\")\n  where \"T{is anti-compact} \\<equiv> T{is anti-}(\\<lambda>T. (\\<Union>T){is compact in}T)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2226
    },
    "2009": {
        "type": "lemma",
        "text": "text\\<open>A function that is continuous at every point of its domain is continuous.\\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>\\<Union>\\<tau>\\<^sub>1. \\<forall>U\\<in>\\<tau>\\<^sub>2. f`x\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U)\" \"f\\<in>(\\<Union>\\<tau>\\<^sub>1)\\<rightarrow>(\\<Union>\\<tau>\\<^sub>2)\"  and \n    \"\\<tau>\\<^sub>1 {is a topology}\"\n  ",
        "using": [
            "func1_1_L6A",
            "func1_1_L15",
            "func1_1_L9",
            "topology0.open_neigh_open",
            "topology0_def",
            "IsContinuous_def"
        ],
        "statement": "lemma ccontinuous_all_x_imp_cont_global:\n  assumes \"\\<forall>x\\<in>\\<Union>\\<tau>\\<^sub>1. \\<forall>U\\<in>\\<tau>\\<^sub>2. f`x\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U)\" \"f\\<in>(\\<Union>\\<tau>\\<^sub>1)\\<rightarrow>(\\<Union>\\<tau>\\<^sub>2)\"  and \n    \"\\<tau>\\<^sub>1 {is a topology}\"\n  shows \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\"\n",
        "proof": "proof-\n  {\n    fix U\n    assume \"U\\<in>\\<tau>\\<^sub>2\"\n    {\n      fix x\n      assume AS: \"x\\<in>f-``U\"\n      note \\<open>U\\<in>\\<tau>\\<^sub>2\\<close>\n      moreover\n      from assms(2) have \"f -`` U \\<subseteq> \\<Union>\\<tau>\\<^sub>1\" using func1_1_L6A by auto\n      with AS have \"x\\<in>\\<Union>\\<tau>\\<^sub>1\" by auto\n      with assms(1) have \"\\<forall>U\\<in>\\<tau>\\<^sub>2. f`x\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U)\" by auto\n      moreover\n      from AS assms(2) have \"f`x\\<in>U\" using func1_1_L15 by auto\n      ultimately have \"\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U\" by auto\n      then obtain V where I: \"V\\<in>\\<tau>\\<^sub>1\" \"x\\<in>V\" \"f``(V)\\<subseteq>U\" by auto\n      moreover\n      from I have \"V\\<subseteq>\\<Union>\\<tau>\\<^sub>1\" by auto\n      moreover\n      from assms(2) \\<open>V\\<subseteq>\\<Union>\\<tau>\\<^sub>1\\<close> have \"V\\<subseteq>f-``(f``V)\" using func1_1_L9 by auto\n      ultimately have \"V \\<subseteq> f-``(U)\" by blast\n      with \\<open>V\\<in>\\<tau>\\<^sub>1\\<close> \\<open>x\\<in>V\\<close> have \"\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> V \\<subseteq> f-``(U)\" by auto\n    } hence \"\\<forall>x\\<in>f-``(U). \\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> V\\<subseteq>f-``(U)\" by auto\n    with assms(3) have \"f-``(U) \\<in> \\<tau>\\<^sub>1\" using topology0.open_neigh_open topology0_def \n      by auto\n  }\n  hence \"\\<forall>U\\<in>\\<tau>\\<^sub>2. f-``U\\<in>\\<tau>\\<^sub>1\" by auto\n  then show ?thesis using IsContinuous_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4",
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_6.thy",
        "id": 2230
    },
    "2010": {
        "type": "lemma",
        "text": "text\\<open>If the function is continuous then \n  if the filter converges to a point the image filter converges to the image point.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} X\\<^sub>1\" \"f {is continuous}\" \"\\<FF> \\<rightarrow>\\<^sub>F x {in} \\<tau>\\<^sub>1\"\n  ",
        "using": [
            "topology0.FilterConverges_def",
            "topol_cntxs_valid(1)",
            "X1_def",
            "topol_cntxs_valid(2)",
            "base_image_filter",
            "fmapAssum",
            "X2_def",
            "func1_1_L6A",
            "func1_1_L15",
            "topology0.Top_2_L2",
            "topology0.Top_2_L3",
            "function_image_vimage",
            "fun_is_fun",
            "topology0.Top_2_L1"
        ],
        "statement": "lemma (in two_top_spaces0) cont_imp_filter_conver_preserved:\n  assumes \"\\<FF> {is a filter on} X\\<^sub>1\" \"f {is continuous}\" \"\\<FF> \\<rightarrow>\\<^sub>F x {in} \\<tau>\\<^sub>1\"\n  shows \"(f[\\<FF>]..X\\<^sub>2) \\<rightarrow>\\<^sub>F (f`(x)) {in} \\<tau>\\<^sub>2\"\n",
        "proof": "proof -\n  from assms(1) assms(3) have \"x\\<in>X\\<^sub>1\" \n    using topology0.FilterConverges_def topol_cntxs_valid(1) X1_def by auto\n  have \"topology0(\\<tau>\\<^sub>2)\" using topol_cntxs_valid(2) by simp \n  moreover from assms(1) have \"(f[\\<FF>]..X\\<^sub>2) {is a filter on} (\\<Union>\\<tau>\\<^sub>2)\" and \"{f``B .B\\<in>\\<FF>} {is a base filter} (f[\\<FF>]..X\\<^sub>2)\" \n    using base_image_filter fmapAssum X1_def X2_def by auto\n  moreover have \"\\<forall>U\\<in>Pow(\\<Union>\\<tau>\\<^sub>2). (f`x)\\<in>Interior(U,\\<tau>\\<^sub>2) \\<longrightarrow> (\\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D\\<subseteq>U)\"\n  proof - \n    { fix U\n    assume \"U\\<in>Pow(X\\<^sub>2)\" \"(f`x)\\<in>Interior(U,\\<tau>\\<^sub>2)\"\n    with \\<open>x\\<in>X\\<^sub>1\\<close> have xim: \"x\\<in>f-``(Interior(U,\\<tau>\\<^sub>2))\" and sub: \"f-``(Interior(U,\\<tau>\\<^sub>2))\\<in>Pow(X\\<^sub>1)\" \n      using func1_1_L6A fmapAssum func1_1_L15 fmapAssum by auto\n    note sub \n    moreover\n    have \"Interior(U,\\<tau>\\<^sub>2)\\<in>\\<tau>\\<^sub>2\" using topology0.Top_2_L2 topol_cntxs_valid(2) by auto\n    with assms(2) have \"f-``(Interior(U,\\<tau>\\<^sub>2))\\<in>\\<tau>\\<^sub>1\" unfolding isContinuous_def IsContinuous_def\n      by auto\n    with xim have \"x\\<in>Interior(f-``(Interior(U,\\<tau>\\<^sub>2)),\\<tau>\\<^sub>1)\" \n      using topology0.Top_2_L3 topol_cntxs_valid(1) by auto\n    moreover from assms(1) assms(3) have \"{U\\<in>Pow(X\\<^sub>1). x\\<in>Interior(U,\\<tau>\\<^sub>1)}\\<subseteq>\\<FF>\" \n        using topology0.FilterConverges_def topol_cntxs_valid(1) X1_def by auto\n    ultimately have \"f-``(Interior(U,\\<tau>\\<^sub>2))\\<in>\\<FF>\" by auto\n    moreover have \"f``(f-``(Interior(U,\\<tau>\\<^sub>2)))\\<subseteq>Interior(U,\\<tau>\\<^sub>2)\" \n      using function_image_vimage fun_is_fun fmapAssum by auto\n    then have \"f``(f-``(Interior(U,\\<tau>\\<^sub>2)))\\<subseteq>U\" \n      using topology0.Top_2_L1 topol_cntxs_valid(2) by auto\n    ultimately have \"\\<exists>D\\<in>{f``(B) .B\\<in>\\<FF>}. D\\<subseteq>U\" by auto\n    } thus ?thesis by auto \n  qed\n  moreover from fmapAssum \\<open>x\\<in>X\\<^sub>1\\<close>  have \"f`(x) \\<in> X\\<^sub>2\"\n    by (rule apply_funtype) \n  hence \"f`(x) \\<in> \\<Union>\\<tau>\\<^sub>2\" by simp \n  ultimately show ?thesis by (rule topology0.convergence_filter_base2) \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4",
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_6.thy",
        "id": 2231
    },
    "2011": {
        "type": "lemma",
        "text": "text\\<open>Continuity in filter at every point of the domain implies global continuity.\\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>\\<Union>\\<tau>\\<^sub>1. \\<forall>\\<FF>. ((\\<FF> {is a filter on} X\\<^sub>1) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F x {in} \\<tau>\\<^sub>1)) \\<longrightarrow> ((f[\\<FF>]..X\\<^sub>2) \\<rightarrow>\\<^sub>F (f`x) {in} \\<tau>\\<^sub>2)\"\n  ",
        "using": [
            "topol_cntxs_valid(1)",
            "topology0.neigh_filter",
            "topol_cntxs_valid(2)",
            "topology0.Top_2_L3",
            "base_image_filter(2)",
            "NFil",
            "fmapAssum",
            "topology0.FilterConverges_def",
            "X1_def",
            "X2_def",
            "base_image_filter(1)",
            "basic_element_filter",
            "topology0.Top_2_L1",
            "topology0.Top_2_L2",
            "ccontinuous_all_x_imp_cont_global",
            "isContinuous_def",
            "tau1_is_top"
        ],
        "statement": "lemma (in two_top_spaces0) filter_conver_preserved_imp_cont:\n  assumes \"\\<forall>x\\<in>\\<Union>\\<tau>\\<^sub>1. \\<forall>\\<FF>. ((\\<FF> {is a filter on} X\\<^sub>1) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F x {in} \\<tau>\\<^sub>1)) \\<longrightarrow> ((f[\\<FF>]..X\\<^sub>2) \\<rightarrow>\\<^sub>F (f`x) {in} \\<tau>\\<^sub>2)\"\n  shows \"f{is continuous}\"\n",
        "proof": "proof-\n  {\n    fix x\n    assume as2: \"x\\<in>\\<Union>\\<tau>\\<^sub>1\"\n    with assms have reg: \n      \"\\<forall>\\<FF>. ((\\<FF> {is a filter on} X\\<^sub>1) \\<and> (\\<FF> \\<rightarrow>\\<^sub>F x {in} \\<tau>\\<^sub>1)) \\<longrightarrow> ((f[\\<FF>]..X\\<^sub>2) \\<rightarrow>\\<^sub>F (f`x) {in} \\<tau>\\<^sub>2)\" \n      by auto\n    let ?Neig = \"{U \\<in> Pow(\\<Union>\\<tau>\\<^sub>1) . x \\<in> Interior(U, \\<tau>\\<^sub>1)}\"\n    from as2 have NFil: \"?Neig{is a filter on}X\\<^sub>1\" and NCon: \"?Neig \\<rightarrow>\\<^sub>F x {in} \\<tau>\\<^sub>1\"\n      using topol_cntxs_valid(1) topology0.neigh_filter by auto\n    {\n      fix U\n      assume \"U\\<in>\\<tau>\\<^sub>2\" \"f`x\\<in>U\"\n      then have \"U\\<in>Pow(\\<Union>\\<tau>\\<^sub>2)\" \"f`x\\<in>Interior(U,\\<tau>\\<^sub>2)\" using topol_cntxs_valid(2) topology0.Top_2_L3 by auto\n      moreover\n      from NCon NFil reg have \"(f[?Neig]..X\\<^sub>2) \\<rightarrow>\\<^sub>F (f`x) {in} \\<tau>\\<^sub>2\" by auto \n      moreover have \"(f[?Neig]..X\\<^sub>2) {is a filter on} X\\<^sub>2\" \n        using base_image_filter(2) NFil fmapAssum by auto\n      ultimately have \"U\\<in>(f[?Neig]..X\\<^sub>2)\" \n        using topology0.FilterConverges_def topol_cntxs_valid(2) unfolding X1_def X2_def \n        by auto\n      moreover\n      from fmapAssum NFil have \"{f``B .B\\<in>?Neig} {is a base filter} (f[?Neig]..X\\<^sub>2)\" \n        using base_image_filter(1) X1_def X2_def by auto\n      ultimately have \"\\<exists>V\\<in>{f``B .B\\<in>?Neig}. V\\<subseteq>U\" using basic_element_filter by blast\n      then obtain B where \"B\\<in>?Neig\" \"f``B\\<subseteq>U\" by auto\n      moreover\n      have \"Interior(B,\\<tau>\\<^sub>1)\\<subseteq>B\" using topology0.Top_2_L1 topol_cntxs_valid(1) by auto\n      hence \"f``Interior(B,\\<tau>\\<^sub>1) \\<subseteq> f``(B)\" by auto\n      moreover have \"Interior(B,\\<tau>\\<^sub>1)\\<in>\\<tau>\\<^sub>1\" \n        using topology0.Top_2_L2 topol_cntxs_valid(1) by auto\n      ultimately have \"\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U\" by force\n    }\n    hence \"\\<forall>U\\<in>\\<tau>\\<^sub>2. f`x\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U)\" by auto\n  }\n  hence \"\\<forall>x\\<in>\\<Union>\\<tau>\\<^sub>1. \\<forall>U\\<in>\\<tau>\\<^sub>2. f`x\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U)\" by auto\n  then show ?thesis \n    using ccontinuous_all_x_imp_cont_global fmapAssum X1_def X2_def isContinuous_def tau1_is_top \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4",
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_6.thy",
        "id": 2232
    },
    "2012": {
        "type": "definition",
        "text": "text\\<open>A space is connected iff there is no clopen set other that the empty set\nand the total set.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition IsConnected (\"_{is connected}\" 70)\n  where \"T {is connected} \\<equiv> \\<forall>U. (U\\<in>T \\<and> (U {is closed in}T)) \\<longrightarrow> U=0\\<or>U=\\<Union>T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2233
    },
    "2013": {
        "type": "definition",
        "text": "text\\<open>The anti-property of connectedness is called total-diconnectedness.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition IsTotDis (\"_ {is totally-disconnected}\" 70)\n  where \"IsTotDis \\<equiv> ANTI(IsConnected)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2234
    },
    "2014": {
        "type": "lemma",
        "text": "text\\<open>The discrete space is a first example of totally-disconnected space.\\<close>\n",
        "assumes": "",
        "using": [
            "\\<open>A\\<in>Pow(X)\\<close>",
            "empty_lepollI[of",
            "\"1\"]",
            "conn_spectrum",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll"
        ],
        "statement": "lemma discrete_tot_dis:\n  shows \"Pow(X) {is totally-disconnected}\"\n",
        "proof": "proof-\n  {\n    fix A assume \"A\\<in>Pow(X)\" and con:\"(Pow(X){restricted to}A){is connected}\"\n    have res:\"(Pow(X){restricted to}A)=Pow(A)\" unfolding RestrictedTo_def using \\<open>A\\<in>Pow(X)\\<close>\n      by blast\n    {\n      assume \"A=0\"\n      then have \"A\\<lesssim>1\" using empty_lepollI[of \"1\"] by auto\n      then have \"A{is in the spectrum of}IsConnected\" using conn_spectrum by auto\n    }\n    moreover\n    {\n      assume \"A\\<noteq>0\"\n      then obtain E where \"E\\<in>A\" by blast\n      then have \"{E}\\<in>Pow(A)\" by auto\n      moreover\n      have \"A-{E}\\<in>Pow(A)\" by auto\n      ultimately have \"{E}\\<in>Pow(A)\\<and>{E}{is closed in}Pow(A)\" unfolding IsClosed_def by auto\n      with con res have \"{E}=A\" unfolding IsConnected_def by auto\n      then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n      then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n      then have \"A{is in the spectrum of}IsConnected\" using conn_spectrum by auto\n    }\n    ultimately have \"A{is in the spectrum of}IsConnected\" by auto\n  }\n  then show ?thesis unfolding IsTotDis_def antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2235
    },
    "2015": {
        "type": "definition",
        "text": "text\\<open>An space is hyperconnected iff every two non-empty open sets meet.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition IsHConnected (\"_{is hyperconnected}\"90)\n  where \"T{is hyperconnected} \\<equiv>\\<forall>U V. U\\<in>T \\<and> V\\<in>T \\<and> U\\<inter>V=0 \\<longrightarrow> U=0\\<or>V=0\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2236
    },
    "2016": {
        "type": "lemma",
        "text": "text\\<open>Every hyperconnected space is connected.\\<close>\n",
        "assumes": "assumes \"T{is hyperconnected}\"\n  ",
        "using": [
            "IsClosed_def",
            "IsHConnected_def",
            "IsConnected_def"
        ],
        "statement": "lemma HConn_imp_Conn:\n  assumes \"T{is hyperconnected}\"\n  shows \"T{is connected}\"\n",
        "proof": "proof-\n  {\n    fix U\n    assume \"U\\<in>T\"\"U {is closed in}T\"\n    then have \"\\<Union>T-U\\<in>T\"\"U\\<in>T\" using IsClosed_def by auto\n    moreover\n    have \"(\\<Union>T-U)\\<inter>U=0\" by auto\n    moreover\n    note assms\n    ultimately\n    have \"U=0\\<or>(\\<Union>T-U)=0\" using IsHConnected_def by auto\n    with \\<open>U\\<in>T\\<close> have \"U=0\\<or>U=\\<Union>T\" by auto\n  }\n  then show ?thesis using IsConnected_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2237
    },
    "2017": {
        "type": "lemma",
        "text": "text\\<open>A first example of an hyperconnected space but not indiscrete, is the cofinite topology on \nthe natural numbers.\\<close>\n",
        "assumes": "assumes \"\\<not>(X\\<prec>nat)\"\n  ",
        "using": [
            "less_less_imp_un_less[OF",
            "AS",
            "InfCard_nat]",
            "assms",
            "IsHConnected_def"
        ],
        "statement": "lemma Cofinite_nat_HConn:\n  assumes \"\\<not>(X\\<prec>nat)\"\n  shows \"(CoFinite X){is hyperconnected}\"\n",
        "proof": "proof-\n  {\n    fix U V\n    assume \"U\\<in>(CoFinite X)\"\"V\\<in>(CoFinite X)\"\"U\\<inter>V=0\"\n    then have eq:\"(X-U)\\<prec>nat\\<or>U=0\"\"(X-V)\\<prec>nat\\<or>V=0\" unfolding Cofinite_def\n      CoCardinal_def by auto\n    from \\<open>U\\<inter>V=0\\<close> have un:\"(X-U)\\<union>(X-V)=X\" by auto\n    {\n      assume AS:\"(X-U)\\<prec>nat\"\"(X-V)\\<prec>nat\"\n      from un have \"X\\<prec>nat\" using less_less_imp_un_less[OF AS InfCard_nat] by auto\n      then have \"False\" using assms by auto\n    }\n    with eq(1,2) have \"U=0\\<or>V=0\" by auto\n  }\n  then show \"(CoFinite X){is hyperconnected}\" using IsHConnected_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2238
    },
    "2018": {
        "type": "lemma",
        "text": "text\\<open>First, the closure of a point in every topological space is always hyperconnected.\nThis is the reason why every anti-hyperconnected space must be $T_1$: every singleton\nmust be closed.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>T\"\n  ",
        "using": [
            "Top_3_L11",
            "Top_3_L9",
            "cl_is_closed",
            "assms",
            "Top_3_L5(1)",
            "cl_contains_set",
            "Top_3_L13"
        ],
        "statement": "lemma (in topology0)cl_point_imp_HConn:\n  assumes \"x\\<in>\\<Union>T\"\n  shows \"(T{restricted to}Closure({x},T)){is hyperconnected}\"\n",
        "proof": "proof-\n  from assms have sub:\"Closure({x},T)\\<subseteq>\\<Union>T\" using Top_3_L11 by auto\n  then have tot:\"\\<Union>(T{restricted to}Closure({x},T))=Closure({x},T)\" unfolding RestrictedTo_def by auto\n  {\n    fix A B\n    assume AS:\"A\\<in>(T{restricted to}Closure({x},T))\"\"B\\<in>(T{restricted to}Closure({x},T))\"\"A\\<inter>B=0\"\n    then have \"B\\<subseteq>\\<Union>((T{restricted to}Closure({x},T)))\"\"A\\<subseteq>\\<Union>((T{restricted to}Closure({x},T)))\"\n      by auto\n    with tot have \"B\\<subseteq>Closure({x},T)\"\"A\\<subseteq>Closure({x},T)\" by auto\n    from AS(1,2) obtain UA UB where UAUB:\"UA\\<in>T\"\"UB\\<in>T\"\"A=UA\\<inter>Closure({x},T)\"\"B=UB\\<inter>Closure({x},T)\"\n      unfolding RestrictedTo_def by auto\n    then have \"Closure({x},T)-A=Closure({x},T)-(UA\\<inter>Closure({x},T))\" \"Closure({x},T)-B=Closure({x},T)-(UB\\<inter>Closure({x},T))\"\n      by auto\n    then have \"Closure({x},T)-A=Closure({x},T)-(UA)\" \"Closure({x},T)-B=Closure({x},T)-(UB)\"\n      by auto\n    with sub have \"Closure({x},T)-A=Closure({x},T)\\<inter>(\\<Union>T-UA)\" \"Closure({x},T)-B=Closure({x},T)\\<inter>(\\<Union>T-UB)\" by auto\n    moreover\n    from UAUB have \"(\\<Union>T-UA){is closed in}T\"\"(\\<Union>T-UB){is closed in}T\" using Top_3_L9 by auto\n    moreover\n    have \"Closure({x},T){is closed in}T\" using cl_is_closed assms by auto\n    ultimately have \"(Closure({x},T)-A){is closed in}T\"\"(Closure({x},T)-B){is closed in}T\"\n      using Top_3_L5(1) by auto\n    moreover\n    {\n      have \"x\\<in>Closure({x},T)\" using cl_contains_set assms by auto\n      moreover\n      from AS(3) have \"x\\<notin>A\\<or>x\\<notin>B\" by auto\n      ultimately have \"x\\<in>(Closure({x},T)-A)\\<or>x\\<in>(Closure({x},T)-B)\" by auto\n    }\n    ultimately have \"Closure({x},T)\\<subseteq>(Closure({x},T)-A) \\<or> Closure({x},T)\\<subseteq>(Closure({x},T)-B)\"\n      using Top_3_L13 by auto\n    then have \"A\\<inter>Closure({x},T)=0 \\<or> B\\<inter>Closure({x},T)=0\" by auto\n    with \\<open>B\\<subseteq>Closure({x},T)\\<close>\\<open>A\\<subseteq>Closure({x},T)\\<close> have \"A=0\\<or>B=0\" using cl_contains_set assms by blast\n  }\n  then show ?thesis unfolding IsHConnected_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2239
    },
    "2019": {
        "type": "lemma",
        "text": "text\\<open>A consequence is that every totally-disconnected space is $T_1$.\\<close>\n",
        "assumes": "assumes \"T{is totally-disconnected}\"\n  ",
        "using": [
            "cl_point_imp_HConn",
            "HConn_imp_Conn",
            "Top_3_L11(1)",
            "conn_spectrum",
            "cl_contains_set",
            "lepoll_1_is_sing[of",
            "\"Closure({x},T)\"",
            "\"x\"]",
            "Top_3_L8",
            "\\<open>x\\<in>\\<Union>T\\<close>"
        ],
        "statement": "lemma (in topology0) tot_dis_imp_T1:\n  assumes \"T{is totally-disconnected}\"\n  shows \"T{is T\\<^sub>1}\"\n",
        "proof": "proof-\n  {\n    fix x y\n    assume \"y\\<in>\\<Union>T\"\"x\\<in>\\<Union>T\"\"y\\<noteq>x\"\n    then have \"(T{restricted to}Closure({x},T)){is hyperconnected}\" using cl_point_imp_HConn by auto\n    then have \"(T{restricted to}Closure({x},T)){is connected}\" using HConn_imp_Conn by auto\n    moreover\n    from \\<open>x\\<in>\\<Union>T\\<close> have \"Closure({x},T)\\<subseteq>\\<Union>T\" using Top_3_L11(1) by auto\n    moreover\n    note assms \n    ultimately have \"Closure({x},T){is in the spectrum of}IsConnected\" unfolding IsTotDis_def antiProperty_def\n      by auto\n    then have \"Closure({x},T)\\<lesssim>1\" using conn_spectrum by auto\n    moreover\n    from \\<open>x\\<in>\\<Union>T\\<close> have \"x\\<in>Closure({x},T)\" using cl_contains_set by auto\n    ultimately have \"Closure({x},T)={x}\" using lepoll_1_is_sing[of \"Closure({x},T)\" \"x\"] by auto\n    then have \"{x}{is closed in}T\" using Top_3_L8 \\<open>x\\<in>\\<Union>T\\<close> by auto\n    then have \"\\<Union>T-{x}\\<in>T\" unfolding IsClosed_def by auto\n    moreover\n    from \\<open>y\\<in>\\<Union>T\\<close>\\<open>y\\<noteq>x\\<close> have \"y\\<in>\\<Union>T-{x}\\<and>x\\<notin>\\<Union>T-{x}\" by auto\n    ultimately have \"\\<exists>U\\<in>T. y\\<in>U\\<and>x\\<notin>U\" by force\n  }\n  then show ?thesis unfolding isT1_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2240
    },
    "2020": {
        "type": "theorem",
        "text": "text\\<open>Being sober is weaker than being anti-hyperconnected.\\<close>\n",
        "assumes": "assumes \"T{is anti-}IsHConnected\"\n  ",
        "using": [
            "HConn_spectrum",
            "lepoll_1_is_sing",
            "cl_contains_set",
            "IsSober_def"
        ],
        "statement": "theorem (in topology0) anti_HConn_imp_sober:\n  assumes \"T{is anti-}IsHConnected\"\n  shows \"T{is sober}\"\n",
        "proof": "proof-\n  {\n    fix A assume \"A\\<in>Pow(\\<Union>T)-{0}\"\"A{is closed in}T\"\"(T{restricted to}A){is hyperconnected}\"\n    with assms have \"A{is in the spectrum of}IsHConnected\" unfolding antiProperty_def by auto\n    then have \"A\\<lesssim>1\" using HConn_spectrum by auto\n    moreover\n    with \\<open>A\\<in>Pow(\\<Union>T)-{0}\\<close> have \"A\\<noteq>0\" by auto\n    then obtain x where \"x\\<in>A\" by auto\n    ultimately have \"A={x}\" using lepoll_1_is_sing by auto\n    with \\<open>A{is closed in}T\\<close> have \"{x}{is closed in}T\" by auto\n    moreover from \\<open>x\\<in>A\\<close> \\<open>A\\<in>Pow(\\<Union>T)-{0}\\<close> have \"{x}\\<in>Pow(\\<Union>T)\" by auto\n    ultimately\n    have \"Closure({x},T)={x}\" unfolding Closure_def ClosedCovers_def by auto\n    with \\<open>A={x}\\<close> have \"A=Closure({x},T)\" by auto\n    moreover\n    {\n      fix y assume \"y\\<in>\\<Union>T\"\"A=Closure({y},T)\"\n      then have \"{y}\\<subseteq>Closure({y},T)\" using cl_contains_set by auto\n      with \\<open>A=Closure({y},T)\\<close> have \"y\\<in>A\" by auto\n      with \\<open>A={x}\\<close> have \"y=x\" by auto\n    }\n    then have \"\\<forall>y\\<in>\\<Union>T. A=Closure({y},T) \\<longrightarrow> y=x\" by auto\n    moreover note \\<open>{x}\\<in>Pow(\\<Union>T)\\<close> \n    ultimately have \"\\<exists>x\\<in>\\<Union>T. A=Closure({x},T)\\<and>(\\<forall>y\\<in>\\<Union>T. A=Closure({y},T) \\<longrightarrow> y=x)\" by auto\n  }\n  then show ?thesis using IsSober_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2242
    },
    "2021": {
        "type": "lemma",
        "text": "text\\<open>Every sober space is $T_0$.\\<close>\n",
        "assumes": "assumes \"T{is sober}\"\n  ",
        "using": [
            "cl_is_closed",
            "Top_3_L11(1)",
            "IsClosed_def",
            "cl_contains_set",
            "Top_3_L13",
            "\\<open>x\\<in>\\<Union>T\\<close>",
            "\\<open>x\\<in>Closure({x},T)\\<close>",
            "cl_point_imp_HConn[OF",
            "\\<open>x\\<in>\\<Union>T\\<close>]",
            "\\<open>y\\<in>\\<Union>T\\<close>",
            "isT0_def"
        ],
        "statement": "lemma (in topology0) sober_imp_T0:\n  assumes \"T{is sober}\"\n  shows \"T{is T\\<^sub>0}\"\n",
        "proof": "proof-\n  {\n    fix x y\n    assume AS:\"x\\<in>\\<Union>T\"\"y\\<in>\\<Union>T\"\"x\\<noteq>y\"\"\\<forall>U\\<in>T. x\\<in>U \\<longleftrightarrow> y\\<in>U\"\n    from \\<open>x\\<in>\\<Union>T\\<close> have clx:\"Closure({x},T) {is closed in}T\" using cl_is_closed by auto\n    with \\<open>x\\<in>\\<Union>T\\<close> have \"(\\<Union>T-Closure({x},T))\\<in>T\" using Top_3_L11(1) unfolding IsClosed_def by auto\n    moreover\n    from \\<open>x\\<in>\\<Union>T\\<close> have \"x\\<in>Closure({x},T)\" using cl_contains_set by auto\n    moreover\n    note AS(1,4)\n    ultimately have \"y\\<notin>(\\<Union>T-Closure({x},T))\" by auto\n    with AS(2) have \"y\\<in>Closure({x},T)\" by auto\n    with clx have ineq1:\"Closure({y},T)\\<subseteq>Closure({x},T)\" using Top_3_L13 by auto\n    from \\<open>y\\<in>\\<Union>T\\<close> have cly:\"Closure({y},T) {is closed in}T\" using cl_is_closed by auto\n    with \\<open>y\\<in>\\<Union>T\\<close> have \"(\\<Union>T-Closure({y},T))\\<in>T\" using Top_3_L11(1) unfolding IsClosed_def by auto\n    moreover\n    from \\<open>y\\<in>\\<Union>T\\<close> have \"y\\<in>Closure({y},T)\" using cl_contains_set by auto\n    moreover\n    note AS(2,4)\n    ultimately have \"x\\<notin>(\\<Union>T-Closure({y},T))\" by auto\n    with AS(1) have \"x\\<in>Closure({y},T)\" by auto\n    with cly have \"Closure({x},T)\\<subseteq>Closure({y},T)\" using Top_3_L13 by auto\n    with ineq1 have eq:\"Closure({x},T)=Closure({y},T)\" by auto\n    have \"Closure({x},T)\\<in>Pow(\\<Union>T)-{0}\" using Top_3_L11(1) \\<open>x\\<in>\\<Union>T\\<close> \\<open>x\\<in>Closure({x},T)\\<close> by auto\n    moreover note assms clx\n    ultimately have \"\\<exists>t\\<in>\\<Union>T.( Closure({x},T) = Closure({t}, T) \\<and> (\\<forall>y\\<in>\\<Union>T. Closure({x},T) = Closure({y}, T) \\<longrightarrow> y = t))\" \n      unfolding IsSober_def using cl_point_imp_HConn[OF \\<open>x\\<in>\\<Union>T\\<close>] by auto\n    then obtain t where t_def:\"t\\<in>\\<Union>T\"\"Closure({x},T) = Closure({t}, T)\"\"\\<forall>y\\<in>\\<Union>T. Closure({x},T) = Closure({y}, T) \\<longrightarrow> y = t\"\n      by blast\n    with eq have \"y=t\" using \\<open>y\\<in>\\<Union>T\\<close> by auto\n    moreover from t_def \\<open>x\\<in>\\<Union>T\\<close> have \"x=t\" by blast\n    ultimately have \"y=x\" by auto\n    with \\<open>x\\<noteq>y\\<close> have \"False\" by auto\n  }\n  then have \"\\<forall>x y. x\\<in>\\<Union>T\\<and>y\\<in>\\<Union>T\\<and>x\\<noteq>y \\<longrightarrow> (\\<exists>U\\<in>T. (x\\<in>U\\<and>y\\<notin>U)\\<or>(y\\<in>U\\<and>x\\<notin>U))\" by auto\n  then show ?thesis using isT0_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2243
    },
    "2022": {
        "type": "theorem",
        "text": "text\\<open>Every $T_2$ space is anti-hyperconnected.\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>2}\"\n  ",
        "using": [
            "empty_lepollI",
            "HConn_spectrum",
            "IsHConnected_def",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll",
            "Q_P_imp_Spec[where",
            "P=IsHConnected",
            "and",
            "Q=isT2]",
            "assms",
            "topSpaceAssum"
        ],
        "statement": "theorem (in topology0) T2_imp_anti_HConn:\n  assumes \"T{is T\\<^sub>2}\"\n  shows \"T{is anti-}IsHConnected\"\n",
        "proof": "proof-\n  {\n    fix TT\n    assume \"TT{is a topology}\" \"TT{is hyperconnected}\"\"TT{is T\\<^sub>2}\"\n    {\n      assume \"\\<Union>TT=0\"\n      then have \"\\<Union>TT\\<lesssim>1\" using empty_lepollI by auto\n      then have \"(\\<Union>TT){is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n    }\n    moreover\n    {\n      assume \"\\<Union>TT\\<noteq>0\"\n      then obtain x where \"x\\<in>\\<Union>TT\" by blast\n      {\n        fix y\n        assume \"y\\<in>\\<Union>TT\"\"x\\<noteq>y\"\n        with \\<open>TT{is T\\<^sub>2}\\<close>\\<open>x\\<in>\\<Union>TT\\<close> obtain U V where \"U\\<in>TT\"\"V\\<in>TT\"\"x\\<in>U\"\"y\\<in>V\"\"U\\<inter>V=0\" unfolding isT2_def by blast\n        with \\<open>TT{is hyperconnected}\\<close> have \"False\" using IsHConnected_def by auto\n      }\n      with \\<open>x\\<in>\\<Union>TT\\<close> have \"\\<Union>TT={x}\" by auto\n      then have \"\\<Union>TT\\<approx>1\" using singleton_eqpoll_1 by auto\n      then have \"\\<Union>TT\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n      then have \"(\\<Union>TT){is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n    }\n    ultimately have \"(\\<Union>TT){is in the spectrum of}IsHConnected\" by blast\n  }\n  then have \"\\<forall>T. ((T{is a topology}\\<and>(T{is hyperconnected})\\<and>(T{is T\\<^sub>2}))\\<longrightarrow> ((\\<Union>T){is in the spectrum of}IsHConnected))\"\n    by auto\n  moreover\n  note here_T2\n  ultimately\n  have \"\\<forall>T.  T{is a topology} \\<longrightarrow> ((T{is T\\<^sub>2})\\<longrightarrow>(T{is anti-}IsHConnected))\" using Q_P_imp_Spec[where P=IsHConnected and Q=isT2]\n    by auto\n  then show ?thesis using assms topSpaceAssum by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2244
    },
    "2023": {
        "type": "theorem",
        "text": "text\\<open>Every anti-hyperconnected space is $T_1$.\\<close>\n",
        "assumes": "assumes \"T{is anti-}IsHConnected\"\n  ",
        "using": [
            "RestrictedTo_def",
            "HConn_spectrum",
            "lepoll_1_is_sing[of",
            "\"{x,y}\"\"x\"]",
            "isT1_def"
        ],
        "statement": "theorem anti_HConn_imp_T1:\n  assumes \"T{is anti-}IsHConnected\"\n  shows \"T{is T\\<^sub>1}\"\n",
        "proof": "proof-\n  {\n    fix x y\n    assume \"x\\<in>\\<Union>T\"\"y\\<in>\\<Union>T\"\"x\\<noteq>y\"\n    {\n      assume AS:\"\\<forall>U\\<in>T. x\\<notin>U\\<or>y\\<in>U\"\n      from \\<open>x\\<in>\\<Union>T\\<close>\\<open>y\\<in>\\<Union>T\\<close> have \"{x,y}\\<in>Pow(\\<Union>T)\" by auto\n      then have sub:\"(T{restricted to}{x,y})\\<subseteq>Pow({x,y})\" using RestrictedTo_def by auto\n      {\n        fix U V\n        assume H:\"U\\<in>T{restricted to}{x,y}\" \"V\\<in>(T{restricted to}{x,y})\"\"U\\<inter>V=0\"\n        with AS have \"x\\<in>U\\<longrightarrow>y\\<in>U\"\"x\\<in>V\\<longrightarrow>y\\<in>V\" unfolding RestrictedTo_def by auto\n        with H(1,2) sub have \"x\\<in>U\\<longrightarrow>U={x,y}\"\"x\\<in>V\\<longrightarrow>V={x,y}\" by auto\n        with H sub have \"x\\<in>U\\<longrightarrow>(U={x,y}\\<and>V=0)\"\"x\\<in>V\\<longrightarrow>(V={x,y}\\<and>U=0)\" by auto\n        then have \"(x\\<in>U\\<or>x\\<in>V)\\<longrightarrow>(U=0\\<or>V=0)\" by auto\n        moreover\n        from sub H have \"(x\\<notin>U\\<and>x\\<notin>V)\\<longrightarrow> (U=0\\<or>V=0)\" by blast\n        ultimately have \"U=0\\<or>V=0\" by auto\n      }\n      then have \"(T{restricted to}{x,y}){is hyperconnected}\" unfolding IsHConnected_def by auto\n      with assms\\<open>{x,y}\\<in>Pow(\\<Union>T)\\<close> have \"{x,y}{is in the spectrum of}IsHConnected\" unfolding antiProperty_def\n        by auto\n      then have \"{x,y}\\<lesssim>1\" using HConn_spectrum by auto\n      moreover\n      have \"x\\<in>{x,y}\" by auto\n      ultimately have \"{x,y}={x}\" using lepoll_1_is_sing[of \"{x,y}\"\"x\"] by auto\n      moreover\n      have \"y\\<in>{x,y}\" by auto\n      ultimately have \"y\\<in>{x}\" by auto\n      then have \"y=x\" by auto\n      with \\<open>x\\<noteq>y\\<close> have \"False\" by auto\n    }\n    then have \"\\<exists>U\\<in>T. x\\<in>U\\<and>y\\<notin>U\" by auto\n  }\n  then show ?thesis using isT1_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2245
    },
    "2024": {
        "type": "lemma",
        "text": "text\\<open>There is at least one topological space that is $T_1$, but not anti-hyperconnected.\nThis space is the cofinite topology on the natural numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "union_cocardinal",
            "subspace_cocardinal",
            "Cofinite_def",
            "Cofinite_nat_HConn[of",
            "\"nat\"]",
            "HConn_spectrum",
            "n_lesspoll_nat",
            "lesspoll_trans1",
            "cocardinal_is_T1",
            "InfCard_nat"
        ],
        "statement": "lemma Cofinite_not_anti_HConn:\n  shows \"\\<not>((CoFinite nat){is anti-}IsHConnected)\" and \"(CoFinite nat){is T\\<^sub>1}\"\n",
        "proof": "proof-\n  {\n    assume \"(CoFinite nat){is anti-}IsHConnected\"\n    moreover\n    have \"\\<Union>(CoFinite nat)=nat\" unfolding Cofinite_def using union_cocardinal by auto\n    moreover\n    have \"(CoFinite nat){restricted to}nat=(CoFinite nat)\" using subspace_cocardinal unfolding Cofinite_def\n      by auto\n    moreover\n    have \"\\<not>(nat\\<prec>nat)\" by auto\n    then have \"(CoFinite nat){is hyperconnected}\" using Cofinite_nat_HConn[of \"nat\"] by auto\n    ultimately have \"nat{is in the spectrum of}IsHConnected\" unfolding antiProperty_def by auto\n    then have \"nat\\<lesssim>1\" using HConn_spectrum by auto\n    moreover\n    have \"1\\<in>nat\" by auto\n    then have \"1\\<prec>nat\" using n_lesspoll_nat by auto\n    ultimately have \"nat\\<prec>nat\" using lesspoll_trans1 by auto\n    then have \"False\" by auto\n  }\n  then show \"\\<not>((CoFinite nat){is anti-}IsHConnected)\" by auto\nnext\n  show \"(CoFinite nat){is T\\<^sub>1}\" using cocardinal_is_T1 InfCard_nat unfolding Cofinite_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2246
    },
    "2025": {
        "type": "lemma",
        "text": "text\\<open>The join-topology build from the cofinite topology on the natural numbers,\nand the excluded set topology on the natural numbers excluding \\<open>{0,1}\\<close>;\nis just the union of both.\\<close>\n",
        "assumes": "",
        "using": [
            "CoCar_is_topology",
            "InfCard_nat",
            "excludedset_is_topology",
            "union_excludedset",
            "union_cocardinal",
            "Cofinite_def",
            "joinT_def",
            "CoCar_is_topology[OF",
            "InfCard_nat]",
            "IsATopology_def",
            "Top_subbase(2)",
            "same_subbase_same_top[where",
            "B=\"(CoFinite",
            "nat)\\<union>ExcludedSet(nat,{0,1})\",",
            "OF",
            "_",
            "Pa]",
            "the_equality[where",
            "a=\"{\\<Union>A.",
            "A\\<in>Pow({\\<Inter>B.",
            "B\\<in>FinPow((CoFinite",
            "nat)\\<union>ExcludedSet(nat,{0,1}))})}\"",
            "and",
            "P=\"\\<lambda>T.",
            "((CoFinite",
            "nat)\\<union>ExcludedSet(nat,{0,1})){is",
            "a",
            "subbase",
            "for}T\",",
            "topology0.fin_inter_open_open[OF",
            "topology0_CoCardinal[OF",
            "InfCard_nat]]",
            "subset_imp_lepoll",
            "lesspoll_trans1"
        ],
        "statement": "lemma join_top_cofinite_excluded_set:\n  shows \"(joinT {CoFinite nat,ExcludedSet(nat,{0,1})})=(CoFinite nat)\\<union> ExcludedSet(nat,{0,1})\"\n",
        "proof": "proof-\n  have coftop:\"(CoFinite nat){is a topology}\" unfolding Cofinite_def using CoCar_is_topology InfCard_nat by auto\n  moreover\n  have \"ExcludedSet(nat,{0,1}){is a topology}\" using excludedset_is_topology by auto\n  moreover\n  have exuni:\"\\<Union>ExcludedSet(nat,{0,1})=nat\" using union_excludedset by auto\n  moreover\n  have cofuni:\"\\<Union>(CoFinite nat)=nat\" using union_cocardinal unfolding Cofinite_def by auto\n  ultimately have \"(joinT {CoFinite nat,ExcludedSet(nat,{0,1})}) = (THE T. (CoFinite nat)\\<union>ExcludedSet(nat,{0,1}) {is a subbase for} T)\"\n    using joinT_def by auto\n  moreover\n  have \"\\<Union>(CoFinite nat)\\<in>CoFinite nat\" using CoCar_is_topology[OF InfCard_nat] unfolding Cofinite_def IsATopology_def\n    by auto\n  with cofuni have n:\"nat\\<in>CoFinite nat\" by auto\n  have Pa:\"(CoFinite nat)\\<union>ExcludedSet(nat,{0,1}) {is a subbase for}{\\<Union>A. A\\<in>Pow({\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))})}\"\n    using Top_subbase(2) by auto\n  have \"{\\<Union>A. A\\<in>Pow({\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))})}=(THE T. (CoFinite nat)\\<union>ExcludedSet(nat,{0,1}) {is a subbase for} T)\"\n    using same_subbase_same_top[where B=\"(CoFinite nat)\\<union>ExcludedSet(nat,{0,1})\", OF _ Pa] the_equality[where a=\"{\\<Union>A. A\\<in>Pow({\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))})}\" and P=\"\\<lambda>T. ((CoFinite nat)\\<union>ExcludedSet(nat,{0,1})){is a subbase for}T\",\n      OF Pa] by auto\n  ultimately have equal:\"(joinT {CoFinite nat,ExcludedSet(nat,{0,1})}) ={\\<Union>A. A\\<in>Pow({\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))})}\"\n    by auto\n  {\n    fix U assume \"U\\<in>{\\<Union>A. A\\<in>Pow({\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))})}\"\n    then obtain AU where \"U=\\<Union>AU\" and base:\"AU\\<in>Pow({\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))})\"\n      by auto\n    have \"(CoFinite nat)\\<subseteq>Pow(\\<Union>(CoFinite nat))\" by auto\n    moreover\n    have \"ExcludedSet(nat,{0,1})\\<subseteq>Pow(\\<Union>ExcludedSet(nat,{0,1}))\" by auto\n    moreover\n    note cofuni exuni\n    ultimately have sub:\"(CoFinite nat)\\<union>ExcludedSet(nat,{0,1})\\<subseteq>Pow(nat)\" by auto\n    from base have \"\\<forall>S\\<in>AU. S\\<in>{\\<Inter>B. B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))}\" by blast\n    then have \"\\<forall>S\\<in>AU. \\<exists>B\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1})). S=\\<Inter>B\" by blast\n    then have eq:\"\\<forall>S\\<in>AU. \\<exists>B\\<in>Pow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1})). S=\\<Inter>B\" unfolding FinPow_def by blast\n    { \n      fix S assume \"S\\<in>AU\"\n      with eq obtain B where \"B\\<in>Pow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))\"\"S=\\<Inter>B\" by auto\n      with sub have \"B\\<in>Pow(Pow(nat))\" by auto\n      {\n        fix x assume \"x\\<in>\\<Inter>B\"\n        then have \"\\<forall>N\\<in>B. x\\<in>N\"\"B\\<noteq>0\" by auto\n        with \\<open>B\\<in>Pow(Pow(nat))\\<close> have \"x\\<in>nat\" by blast\n      }\n      with \\<open>S=\\<Inter>B\\<close> have \"S\\<in>Pow(nat)\" by auto\n    }\n    then have \"\\<forall>S\\<in>AU. S\\<in>Pow(nat)\" by blast\n    with \\<open>U=\\<Union>AU\\<close> have \"U\\<in>Pow(nat)\" by auto\n    {\n      assume \"0\\<in>U\\<or>1\\<in>U\"\n      with \\<open>U=\\<Union>AU\\<close> obtain S where \"S\\<in>AU\"\"0\\<in>S\\<or>1\\<in>S\" by auto\n      with base obtain BS where \"S=\\<Inter>BS\" and bsbase:\"BS\\<in>FinPow((CoFinite nat)\\<union>ExcludedSet(nat,{0,1}))\" by auto\n      with \\<open>0\\<in>S\\<or>1\\<in>S\\<close> have \"\\<forall>M\\<in>BS. 0\\<in>M\\<or>1\\<in>M\" by auto\n      then have \"\\<forall>M\\<in>BS. M\\<notin>ExcludedSet(nat,{0,1})-{nat}\" unfolding ExcludedPoint_def ExcludedSet_def by auto\n      moreover\n      note bsbase n\n      ultimately have \"BS\\<in>FinPow(CoFinite nat)\" unfolding FinPow_def by auto\n      moreover\n      from \\<open>0\\<in>S\\<or>1\\<in>S\\<close> have \"S\\<noteq>0\" by auto\n      with \\<open>S=\\<Inter>BS\\<close> have \"BS\\<noteq>0\" by auto\n      moreover\n      note coftop \n      ultimately have \"\\<Inter>BS\\<in>CoFinite nat\" using topology0.fin_inter_open_open[OF topology0_CoCardinal[OF InfCard_nat]]\n        unfolding Cofinite_def by auto\n      with \\<open>S=\\<Inter>BS\\<close> have \"S\\<in>CoFinite nat\" by auto\n      with \\<open>0\\<in>S\\<or>1\\<in>S\\<close> have \"nat-S\\<prec>nat\" unfolding Cofinite_def CoCardinal_def by auto\n      moreover\n      from \\<open>U=\\<Union>AU\\<close>\\<open>S\\<in>AU\\<close> have \"S\\<subseteq>U\" by auto\n      then have \"nat-U\\<subseteq>nat-S\" by auto\n      then have \"nat-U\\<lesssim>nat-S\" using subset_imp_lepoll by auto\n      ultimately\n      have \"nat-U\\<prec>nat\" using lesspoll_trans1 by auto\n      with \\<open>U\\<in>Pow(nat)\\<close> have \"U\\<in>CoFinite nat\" unfolding Cofinite_def CoCardinal_def by auto\n      with \\<open>U\\<in>Pow(nat)\\<close> have \"U\\<in> (CoFinite nat)\\<union> ExcludedSet(nat,{0,1})\" by auto\n    }\n    with \\<open>U\\<in>Pow(nat)\\<close> have \"U\\<in>(CoFinite nat)\\<union> ExcludedSet(nat,{0,1})\" unfolding ExcludedSet_def by blast\n  }\n  then have \"({\\<Union>A . A \\<in> Pow({\\<Inter>B . B \\<in> FinPow((CoFinite nat) \\<union> ExcludedSet(nat,{0,1}))})}) \\<subseteq> (CoFinite nat)\\<union> ExcludedSet(nat,{0,1})\"\n    by blast\n  moreover\n  {\n    fix U\n    assume \"U\\<in>(CoFinite nat)\\<union> ExcludedSet(nat,{0,1})\"\n    then have \"{U}\\<in>FinPow((CoFinite nat) \\<union> ExcludedSet(nat,{0,1}))\" unfolding FinPow_def by auto\n    then have \"{U}\\<in>Pow({\\<Inter>B . B \\<in> FinPow((CoFinite nat) \\<union> ExcludedSet(nat,{0,1}))})\" by blast\n    moreover\n    have \"U=\\<Union>{U}\" by auto\n    ultimately have \"U\\<in>{\\<Union>A . A \\<in> Pow({\\<Inter>B . B \\<in> FinPow((CoFinite nat) \\<union> ExcludedSet(nat,{0,1}))})}\" by blast\n  }\n  then have \"(CoFinite nat)\\<union> ExcludedSet(nat,{0,1})\\<subseteq>{\\<Union>A . A \\<in> Pow({\\<Inter>B . B \\<in> FinPow((CoFinite nat) \\<union> ExcludedSet(nat,{0,1}))})}\"\n    by auto\n  ultimately have \"(CoFinite nat)\\<union> ExcludedSet(nat,{0,1})={\\<Union>A . A \\<in> Pow({\\<Inter>B . B \\<in> FinPow((CoFinite nat) \\<union> ExcludedSet(nat,{0,1}))})}\"\n    by auto\n  with equal show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2247
    },
    "2026": {
        "type": "theorem",
        "text": "text\\<open>The previous topology in not $T_2$, but is anti-hyperconnected.\\<close>\n",
        "assumes": "",
        "using": [
            "union_cocardinal",
            "union_excludedset",
            "join_top_cofinite_excluded_set",
            "isT2_def",
            "Cofinite_nat_HConn",
            "IsHConnected_def",
            "subspace_excludedset[of\"nat\"\"{0,1}\"\"A\"]",
            "subspace_cocardinal[of",
            "\"nat\"\"nat\"\"A\"]",
            "Cofinite_def",
            "empty_excludedset[of",
            "\"{0,1}\"\"A\"]",
            "CoCardinal_def",
            "HConn_imp_Conn",
            "discrete_tot_dis",
            "IsTotDis_def",
            "conn_spectrum",
            "HConn_spectrum",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll",
            "empty_open[of",
            "\"CoFinite",
            "A\"]",
            "CoCar_is_topology[OF",
            "InfCard_nat,of",
            "\"A\"]",
            "IsATopology_def",
            "n_lesspoll_nat",
            "eq_lesspoll_trans"
        ],
        "statement": "theorem join_Cofinite_ExclPoint_not_T2:\n  shows \n    \"\\<not>((joinT {CoFinite nat, ExcludedSet(nat,{0,1})}){is T\\<^sub>2})\" and \n    \"(joinT {CoFinite nat,ExcludedSet(nat,{0,1})}){is anti-} IsHConnected\"\n",
        "proof": "proof-\n  have \"(CoFinite nat) \\<subseteq> (CoFinite nat) \\<union> ExcludedSet(nat,{0,1})\" by auto\n  have \"\\<Union>((CoFinite nat)\\<union> ExcludedSet(nat,{0,1}))=(\\<Union>(CoFinite nat))\\<union> (\\<Union>ExcludedSet(nat,{0,1}))\"\n    by auto\n  moreover\n  have \"\\<dots>=nat \"unfolding Cofinite_def using union_cocardinal union_excludedset by auto\n  ultimately have tot:\"\\<Union>((CoFinite nat)\\<union> ExcludedSet(nat,{0,1}))=nat\" by auto\n  { \n    assume \"(joinT {CoFinite nat,ExcludedSet(nat,{0,1})}) {is T\\<^sub>2}\"\n    then have t2:\"((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})){is T\\<^sub>2}\" using join_top_cofinite_excluded_set\n      by auto\n    with tot have \"\\<exists>U\\<in>((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})). \\<exists>V\\<in>((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})). 0\\<in>U\\<and>1\\<in>V\\<and>U\\<inter>V=0\" using isT2_def by auto\n    then obtain U V where \"U \\<in> (CoFinite nat) \\<or> (0 \\<notin> U\\<and>1\\<notin>U)\"\"V \\<in> (CoFinite nat) \\<or> (0 \\<notin> V\\<and>1\\<notin>V)\"\"0\\<in>U\"\"1\\<in>V\"\"U\\<inter>V=0\" \n      unfolding ExcludedSet_def by auto\n    then have \"U\\<in>(CoFinite nat)\"\"V\\<in>(CoFinite nat)\" by auto\n    with \\<open>0\\<in>U\\<close>\\<open>1\\<in>V\\<close> have \"U\\<inter>V\\<noteq>0\" using Cofinite_nat_HConn IsHConnected_def by auto\n    with \\<open>U\\<inter>V=0\\<close> have \"False\" by auto\n  }\n  then show \"\\<not>((joinT {CoFinite nat,ExcludedSet(nat,{0,1})}){is T\\<^sub>2})\" by auto\n  {\n    fix A assume AS:\"A\\<in>Pow(\\<Union>((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})))\"\"(((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})){restricted to}A){is hyperconnected}\"\n    with tot have \"A\\<in>Pow(nat)\" by auto\n    then have sub:\"A\\<inter>nat=A\" by auto\n    have \"((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})){restricted to}A=((CoFinite nat){restricted to}A)\\<union> (ExcludedSet(nat,{0,1}){restricted to}A)\"\n      unfolding RestrictedTo_def by auto\n    also from sub have \"\\<dots>=(CoFinite A)\\<union>ExcludedSet(A,{0,1})\" using subspace_excludedset[of\"nat\"\"{0,1}\"\"A\"] subspace_cocardinal[of \"nat\"\"nat\"\"A\"] unfolding Cofinite_def\n      by auto\n    finally have \"((CoFinite nat)\\<union> ExcludedSet(nat,{0,1})){restricted to}A=(CoFinite A)\\<union>ExcludedSet(A,{0,1})\" by auto\n    with AS(2) have eq:\"((CoFinite A)\\<union>ExcludedSet(A,{0,1})){is hyperconnected}\" by auto\n    {\n      assume \"{0,1}\\<inter>A=0\"\n      then have \"(CoFinite A)\\<union>ExcludedSet(A,{0,1})=Pow(A)\" using empty_excludedset[of \"{0,1}\"\"A\"] unfolding Cofinite_def CoCardinal_def\n        by auto\n      with eq have \"Pow(A){is hyperconnected}\" by auto\n      then have \"Pow(A){is connected}\" using HConn_imp_Conn by auto\n      moreover\n      have \"Pow(A){is anti-}IsConnected\" using discrete_tot_dis unfolding IsTotDis_def by auto\n      moreover\n      have \"\\<Union>(Pow(A))\\<in>Pow(\\<Union>(Pow(A)))\" by auto\n      moreover\n      have \"Pow(A){restricted to}\\<Union>(Pow(A))=Pow(A)\" unfolding RestrictedTo_def by blast\n      ultimately have \"(\\<Union>(Pow(A))){is in the spectrum of}IsConnected\" unfolding antiProperty_def\n        by auto\n      then have \"A{is in the spectrum of}IsConnected\" by auto\n      then have \"A\\<lesssim>1\" using conn_spectrum  by auto\n      then have \"A{is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n    }\n    moreover\n    {\n      assume AS:\"{0,1}\\<inter>A\\<noteq>0\"\n      {\n        assume \"A={0}\\<or>A={1}\"\n        then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n        then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n        then have \"A{is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n      }\n      moreover\n      {  \n        assume AS2:\"\\<not>(A={0}\\<or>A={1})\"\n        {\n          assume AS3:\"A\\<subseteq>{0,1}\"\n          with AS AS2 have A_def:\"A={0,1}\" by blast\n          then have \"ExcludedSet(A,{0,1})=ExcludedSet(A,A)\" by auto\n          moreover have \"ExcludedSet(A,A)={0,A}\" unfolding ExcludedSet_def by blast\n          ultimately have \"ExcludedSet(A,{0,1})={0,A}\" by auto\n          moreover\n          have \"0\\<in>(CoFinite A)\" using empty_open[of \"CoFinite A\"]\n            CoCar_is_topology[OF InfCard_nat,of \"A\"] unfolding Cofinite_def by auto\n          moreover\n          have \"\\<Union>(CoFinite A)=A\" using union_cocardinal unfolding Cofinite_def by auto\n          then have \"A\\<in>(CoFinite A)\" using CoCar_is_topology[OF InfCard_nat,of \"A\"] unfolding Cofinite_def\n            IsATopology_def by auto\n          ultimately have \"(CoFinite A)\\<union>ExcludedSet(A,{0,1})=(CoFinite A)\" by auto\n          with eq have\"(CoFinite A){is hyperconnected}\" by auto\n          with A_def have  hyp:\"(CoFinite {0,1}){is hyperconnected}\" by auto\n          have \"{0}\\<approx>1\"\"{1}\\<approx>1\" using singleton_eqpoll_1 by auto\n          moreover\n          have \"1\\<prec>nat\" using n_lesspoll_nat by auto\n          ultimately have \"{0}\\<prec>nat\"\"{1}\\<prec>nat\" using eq_lesspoll_trans by auto\n          moreover\n          have \"{0,1}-{1}={0}\"\"{0,1}-{0}={1}\" by auto\n          ultimately have \"{1}\\<in>(CoFinite {0,1})\"\"{0}\\<in>(CoFinite {0,1})\" \"{1}\\<inter>{0}=0\" unfolding Cofinite_def CoCardinal_def\n            by auto\n          with hyp have \"False\" unfolding IsHConnected_def by auto\n        }\n        then obtain t where \"t\\<in>A\" \"t\\<noteq>0\" \"t\\<noteq>1\" by auto\n        then have \"{t}\\<in>ExcludedSet(A,{0,1})\" unfolding ExcludedSet_def by auto\n        moreover\n        {\n          have \"{t}\\<approx>1\" using singleton_eqpoll_1 by auto\n          moreover\n          have \"1\\<prec>nat\" using n_lesspoll_nat by auto\n          ultimately have \"{t}\\<prec>nat\" using eq_lesspoll_trans by auto\n          moreover\n          with \\<open>t\\<in>A\\<close> have \"A-(A-{t})={t}\" by auto\n          ultimately have \"A-{t}\\<in>(CoFinite A)\" unfolding Cofinite_def CoCardinal_def\n            by auto\n        }\n        ultimately have \"{t}\\<in>((CoFinite A)\\<union>ExcludedSet(A,{0,1}))\"\"A-{t}\\<in>((CoFinite A)\\<union>ExcludedSet(A,{0,1}))\"\n          \"{t}\\<inter>(A-{t})=0\" by auto\n        with eq have \"A-{t}=0\" unfolding IsHConnected_def by auto\n        with \\<open>t\\<in>A\\<close> have \"A={t}\" by auto\n        then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n        then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n        then have \"A{is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n      }\n      ultimately have \"A{is in the spectrum of}IsHConnected\" by auto\n    }\n    ultimately have \"A{is in the spectrum of}IsHConnected\" by auto\n  }\n  then have \"((CoFinite nat)\\<union>ExcludedSet(nat,{0,1})){is anti-}IsHConnected\" unfolding antiProperty_def\n    by auto\n  then show \"(joinT {CoFinite nat, ExcludedSet(nat,{0,1})}){is anti-}IsHConnected\" using join_top_cofinite_excluded_set\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2248
    },
    "2027": {
        "type": "theorem",
        "text": "text\\<open>Let's show that anti-hyperconnected is in fact $T_1$ and sober. The trick of the proof lies\nin the fact that if a subset is hyperconnected, its closure is so too (the closure of a point\nis then always hyperconnected because singletons are in the spectrum); since the closure\nis closed, we can apply the sober property on it.\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>1}\" and \"T{is sober}\"\n  ",
        "using": [
            "empty_lepollI",
            "HConn_spectrum",
            "IsHConnected_def",
            "cl_contains_set",
            "Top_3_L11(1)",
            "AS(1)",
            "Top_3_L9",
            "cl_is_closed",
            "Top_3_L5(1)",
            "Top_3_L13",
            "isT1_def",
            "open_neigh_open",
            "IsClosed_def",
            "Top_3_L8",
            "cl_contains_set[of",
            "\"A\"]",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll",
            "antiProperty_def"
        ],
        "statement": "theorem (in topology0) T1_sober_imp_anti_HConn:\n  assumes \"T{is T\\<^sub>1}\" and \"T{is sober}\"\n  shows \"T{is anti-}IsHConnected\"\n",
        "proof": "proof-\n  {\n    fix A assume AS:\"A\\<in>Pow(\\<Union>T)\"\"(T{restricted to}A){is hyperconnected}\"\n    {\n      assume \"A=0\"\n      then have \"A\\<lesssim>1\" using empty_lepollI by auto\n      then have \"A{is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n    }\n    moreover\n    {\n      assume \"A\\<noteq>0\"\n      then obtain x where \"x\\<in>A\" by blast\n      {\n        assume \"\\<not>((T{restricted to}Closure(A,T)){is hyperconnected})\"\n        then obtain U V where UV_def:\"U\\<in>(T{restricted to}Closure(A,T))\"\"V\\<in>(T{restricted to}Closure(A,T))\"\n          \"U\\<inter>V=0\"\"U\\<noteq>0\"\"V\\<noteq>0\" using IsHConnected_def by auto\n        then obtain UCA VCA where \"UCA\\<in>T\"\"VCA\\<in>T\"\"U=UCA\\<inter>Closure(A,T)\"\"V=VCA\\<inter>Closure(A,T)\"\n          unfolding RestrictedTo_def by auto\n        from \\<open>A\\<in>Pow(\\<Union>T)\\<close> have \"A\\<subseteq>Closure(A,T)\" using cl_contains_set by auto\n        then have \"UCA\\<inter>A\\<subseteq>UCA\\<inter>Closure(A,T)\"\"VCA\\<inter>A\\<subseteq>VCA\\<inter>Closure(A,T)\" by auto\n        with \\<open>U=UCA\\<inter>Closure(A,T)\\<close>\\<open>V=VCA\\<inter>Closure(A,T)\\<close>\\<open>U\\<inter>V=0\\<close> have \"(UCA\\<inter>A)\\<inter>(VCA\\<inter>A)=0\" by auto\n        moreover\n        from \\<open>UCA\\<in>T\\<close>\\<open>VCA\\<in>T\\<close> have \"UCA\\<inter>A\\<in>(T{restricted to}A)\"\"VCA\\<inter>A\\<in>(T{restricted to}A)\"\n          unfolding RestrictedTo_def by auto\n        moreover\n        note AS(2)\n        ultimately have \"UCA\\<inter>A=0\\<or>VCA\\<inter>A=0\" using IsHConnected_def by auto\n        with \\<open>A\\<subseteq>Closure(A,T)\\<close> have \"A\\<subseteq>Closure(A,T)-UCA\\<or>A\\<subseteq>Closure(A,T)-VCA\" by auto\n        moreover\n        {\n          have \"Closure(A,T)-UCA=Closure(A,T)\\<inter>(\\<Union>T-UCA)\"\"Closure(A,T)-VCA=Closure(A,T)\\<inter>(\\<Union>T-VCA)\"\n            using Top_3_L11(1) AS(1) by auto\n          moreover \n          with \\<open>UCA\\<in>T\\<close>\\<open>VCA\\<in>T\\<close> have \"(\\<Union>T-UCA){is closed in}T\"\"(\\<Union>T-VCA){is closed in}T\"\"Closure(A,T){is closed in}T\"\n            using Top_3_L9 cl_is_closed AS(1) by auto\n          ultimately have \"(Closure(A,T)-UCA){is closed in}T\"\"(Closure(A,T)-VCA){is closed in}T\"\n            using Top_3_L5(1) by auto\n        }\n        ultimately\n        have \"Closure(A,T)\\<subseteq>Closure(A,T)-UCA\\<or>Closure(A,T)\\<subseteq>Closure(A,T)-VCA\" using Top_3_L13\n          by auto\n        then have \"UCA\\<inter>Closure(A,T)=0\\<or>VCA\\<inter>Closure(A,T)=0\" by auto\n        with \\<open>U=UCA\\<inter>Closure(A,T)\\<close>\\<open>V=VCA\\<inter>Closure(A,T)\\<close> have \"U=0\\<or>V=0\" by auto\n        with \\<open>U\\<noteq>0\\<close>\\<open>V\\<noteq>0\\<close> have \"False\" by auto\n      }\n      then have \"(T{restricted to}Closure(A,T)){is hyperconnected}\" by auto\n      moreover\n      have \"Closure(A,T){is closed in}T\" using cl_is_closed AS(1) by auto\n      moreover\n      from \\<open>x\\<in>A\\<close> have \"Closure(A,T)\\<noteq>0\" using cl_contains_set AS(1) by auto\n      moreover\n      from AS(1) have \"Closure(A,T)\\<subseteq>\\<Union>T\" using Top_3_L11(1) by auto\n      ultimately have \"Closure(A,T)\\<in>Pow(\\<Union>T)-{0}\"\"(T {restricted to} Closure(A, T)){is hyperconnected}\" \"Closure(A, T) {is closed in} T\"\n        by auto\n      moreover note assms(2) \n      ultimately have \"\\<exists>x\\<in>\\<Union>T. (Closure(A,T)=Closure({x},T)\\<and> (\\<forall>y\\<in>\\<Union>T. Closure(A,T) = Closure({y}, T) \\<longrightarrow> y = x))\" unfolding IsSober_def\n        by auto\n      then obtain y where \"y\\<in>\\<Union>T\"\"Closure(A,T)=Closure({y},T)\" by auto\n      moreover\n      {\n        fix z assume \"z\\<in>(\\<Union>T)-{y}\"\n        with assms(1) \\<open>y\\<in>\\<Union>T\\<close> obtain U where \"U\\<in>T\" \"z\\<in>U\" \"y\\<notin>U\" using isT1_def by blast\n        then have \"U\\<in>T\" \"z\\<in>U\" \"U\\<subseteq>(\\<Union>T)-{y}\" by auto\n        then have \"\\<exists>U\\<in>T. z\\<in>U \\<and> U\\<subseteq>(\\<Union>T)-{y}\" by auto\n      }\n      then have \"\\<forall>z\\<in>(\\<Union>T)-{y}. \\<exists>U\\<in>T. z\\<in>U \\<and> U\\<subseteq>(\\<Union>T)-{y}\" by auto\n      then have \"\\<Union>T-{y}\\<in>T\" using open_neigh_open by auto\n      with \\<open>y\\<in>\\<Union>T\\<close> have \"{y} {is closed in}T\" using IsClosed_def by auto\n      with \\<open>y\\<in>\\<Union>T\\<close> have \"Closure({y},T)={y}\" using Top_3_L8 by auto\n      with \\<open>Closure(A,T)=Closure({y},T)\\<close> have \"Closure(A,T)={y}\" by auto\n      with AS(1) have \"A\\<subseteq>{y}\" using cl_contains_set[of \"A\"] by auto\n      with \\<open>A\\<noteq>0\\<close> have \"A={y}\" by auto\n      then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n      then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n      then have \"A{is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n    }\n    ultimately have \"A{is in the spectrum of}IsHConnected\" by blast\n  }\n  then show ?thesis using antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2249
    },
    "2028": {
        "type": "definition",
        "text": "text\\<open>A space is ultraconnected iff every two non-empty closed sets meet.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition IsUConnected (\"_{is ultraconnected}\"80)\n  where \"T{is ultraconnected}\\<equiv> \\<forall>A B. A{is closed in}T\\<and>B{is closed in}T\\<and>A\\<inter>B=0 \\<longrightarrow> A=0\\<or>B=0\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2250
    },
    "2029": {
        "type": "lemma",
        "text": "text\\<open>Every ultraconnected space is trivially normal.\\<close>\n",
        "assumes": "assumes \"T{is ultraconnected}\"\n  ",
        "using": [
            "IsUConnected_def",
            "empty_open",
            "topSpaceAssum",
            "IsATopology_def"
        ],
        "statement": "lemma (in topology0)UConn_imp_normal:\n  assumes \"T{is ultraconnected}\"\n  shows \"T{is normal}\"\n",
        "proof": "proof-\n  {\n    fix A B\n    assume AS:\"A{is closed in}T\" \"B{is closed in}T\"\"A\\<inter>B=0\"\n    with assms have \"A=0\\<or>B=0\" using IsUConnected_def by auto\n    with AS(1,2) have \"(A\\<subseteq>0\\<and>B\\<subseteq>\\<Union>T)\\<or>(A\\<subseteq>\\<Union>T\\<and>B\\<subseteq>0)\" unfolding IsClosed_def by auto\n    moreover\n    have \"0\\<in>T\" using empty_open topSpaceAssum by auto\n    moreover\n    have \"\\<Union>T\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    ultimately have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. A\\<subseteq>U\\<and>B\\<subseteq>V\\<and>U\\<inter>V=0\" by auto\n  }\n  then show ?thesis unfolding IsNormal_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2251
    },
    "2030": {
        "type": "lemma",
        "text": "text\\<open>Every ultraconnected space is connected.\\<close>\n",
        "assumes": "assumes \"T{is ultraconnected}\"\n  ",
        "using": [],
        "statement": "lemma UConn_imp_Conn:\n  assumes \"T{is ultraconnected}\"\n  shows \"T{is connected}\"\n",
        "proof": "proof-\n  {\n    fix U V\n    assume \"U\\<in>T\"\"U{is closed in}T\"\n    then have \"\\<Union>T-(\\<Union>T-U)=U\" by auto\n    with \\<open>U\\<in>T\\<close> have \"(\\<Union>T-U){is closed in}T\" unfolding IsClosed_def by auto\n    with \\<open>U{is closed in}T\\<close> assms have \"U=0\\<or>\\<Union>T-U=0\" unfolding IsUConnected_def by auto\n    with \\<open>U\\<in>T\\<close> have \"U=0\\<or>U=\\<Union>T\" by auto\n  }\n  then show ?thesis unfolding IsConnected_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2252
    },
    "2031": {
        "type": "theorem",
        "text": "text\\<open>This time, anti-ultraconnected is an old property.\\<close>\n",
        "assumes": "",
        "using": [
            "empty_lepollI",
            "UConn_spectrum",
            "isT1_def",
            "topology0.open_neigh_open",
            "topology0_def",
            "IsClosed_def",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll",
            "Q_P_imp_Spec[where",
            "Q=isT1",
            "and",
            "P=IsUConnected]",
            "lepoll_1_is_sing[of",
            "\"{x,y}\"\"x\"]",
            "\\<open>x\\<noteq>y\\<close>"
        ],
        "statement": "theorem (in topology0) anti_UConn:\n  shows \"(T{is anti-}IsUConnected) \\<longleftrightarrow> T{is T\\<^sub>1}\"\n",
        "proof": "proof\n  assume \"T{is T\\<^sub>1}\"\n  {\n    fix TT\n    {\n      assume \"TT{is a topology}\"\"TT{is T\\<^sub>1}\"\"TT{is ultraconnected}\"\n      {\n        assume \"\\<Union>TT=0\"\n        then have \"\\<Union>TT\\<lesssim>1\" using empty_lepollI by auto\n        then have \"((\\<Union>TT){is in the spectrum of}IsUConnected)\" using UConn_spectrum by auto\n      }\n      moreover\n      {\n        assume \"\\<Union>TT\\<noteq>0\"\n        then obtain t where \"t\\<in>\\<Union>TT\" by blast\n        {\n          fix x\n          assume p:\"x\\<in>\\<Union>TT\"\n          {\n            fix y assume \"y\\<in>(\\<Union>TT)-{x}\"\n            with \\<open>TT{is T\\<^sub>1}\\<close> p obtain U where \"U\\<in>TT\" \"y\\<in>U\" \"x\\<notin>U\" using isT1_def by blast\n            then have \"U\\<in>TT\" \"y\\<in>U\" \"U\\<subseteq>(\\<Union>TT)-{x}\" by auto\n            then have \"\\<exists>U\\<in>TT. y\\<in>U \\<and> U\\<subseteq>(\\<Union>TT)-{x}\" by auto\n          }\n          then have \"\\<forall>y\\<in>(\\<Union>TT)-{x}. \\<exists>U\\<in>TT. y\\<in>U \\<and> U\\<subseteq>(\\<Union>TT)-{x}\" by auto\n          with \\<open>TT{is a topology}\\<close> have \"\\<Union>TT-{x}\\<in>TT\" using topology0.open_neigh_open unfolding topology0_def by auto\n          with p have \"{x} {is closed in}TT\" using IsClosed_def by auto\n        }\n        then have reg:\"\\<forall>x\\<in>\\<Union>TT. {x}{is closed in}TT\" by auto\n        with \\<open>t\\<in>\\<Union>TT\\<close> have t_cl:\"{t}{is closed in}TT\" by auto\n        {\n          fix y\n          assume \"y\\<in>\\<Union>TT\"\n          with reg have \"{y}{is closed in}TT\" by auto\n          with \\<open>TT{is ultraconnected}\\<close> t_cl have \"y=t\" unfolding IsUConnected_def by auto\n        }\n        with \\<open>t\\<in>\\<Union>TT\\<close> have \"\\<Union>TT={t}\" by blast\n        then have \"\\<Union>TT\\<approx>1\" using singleton_eqpoll_1 by auto\n        then have \"\\<Union>TT\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n        then have \"(\\<Union>TT){is in the spectrum of}IsUConnected\" using UConn_spectrum by auto\n      }\n      ultimately have \"(\\<Union>TT){is in the spectrum of}IsUConnected\" by blast\n    }\n    then have \"(TT{is a topology}\\<and>TT{is T\\<^sub>1}\\<and>(TT{is ultraconnected}))\\<longrightarrow> ((\\<Union>TT){is in the spectrum of}IsUConnected)\"\n      by auto\n  }\n  then have \"\\<forall>TT. (TT{is a topology}\\<and>TT{is T\\<^sub>1}\\<and>(TT{is ultraconnected}))\\<longrightarrow> ((\\<Union>TT){is in the spectrum of}IsUConnected)\"\n    by auto\n  moreover\n  note here_T1\n  ultimately have \"\\<forall>T. T{is a topology} \\<longrightarrow> ((T{is T\\<^sub>1})\\<longrightarrow>(T{is anti-}IsUConnected))\" using Q_P_imp_Spec[where Q=isT1 and P=IsUConnected]\n    by auto\n  with topSpaceAssum have \"(T{is T\\<^sub>1})\\<longrightarrow>(T{is anti-}IsUConnected)\" by auto\n  with \\<open>T{is T\\<^sub>1}\\<close> show \"T{is anti-}IsUConnected\" by auto\nnext\n  assume ASS:\"T{is anti-}IsUConnected\"\n  {\n    fix x y\n    assume \"x\\<in>\\<Union>T\"\"y\\<in>\\<Union>T\"\"x\\<noteq>y\"\n    then have tot:\"\\<Union>(T{restricted to}{x,y})={x,y}\" unfolding RestrictedTo_def by auto\n    {\n      assume AS:\"\\<forall>U\\<in>T. x\\<in>U\\<longrightarrow>y\\<in>U\"\n      {\n        assume \"{y}{is closed in}(T{restricted to}{x,y})\"\n        moreover\n        from \\<open>x\\<noteq>y\\<close> have \"{x,y}-{y}={x}\" by auto\n        ultimately have \"{x}\\<in>(T{restricted to}{x,y})\" unfolding IsClosed_def by (simp only:tot)\n        then obtain U where \"U\\<in>T\"\"{x}={x,y}\\<inter>U\" unfolding RestrictedTo_def by auto\n        moreover\n        with \\<open>x\\<noteq>y\\<close> have \"y\\<notin>{x}\" \"y\\<in>{x,y}\" by (blast+)\n        with \\<open>{x}={x,y}\\<inter>U\\<close> have \"y\\<notin>U\" by auto\n        moreover have \"x\\<in>{x}\" by auto\n        with \\<open>{x}={x,y}\\<inter>U\\<close> have \"x\\<in>U\" by auto\n        ultimately have \"x\\<in>U\"\"y\\<notin>U\"\"U\\<in>T\" by auto\n        with AS have \"False\" by auto\n      }\n      then have y_no_cl:\"\\<not>({y}{is closed in}(T{restricted to}{x,y}))\" by auto\n      {\n        fix A B \n        assume cl:\"A{is closed in}(T{restricted to}{x,y})\"\"B{is closed in}(T{restricted to}{x,y})\"\"A\\<inter>B=0\"\n        with tot have \"A\\<subseteq>{x,y}\"\"B\\<subseteq>{x,y}\"\"A\\<inter>B=0\" unfolding IsClosed_def by auto\n        then have \"x\\<in>A\\<longrightarrow>x\\<notin>B\"\"y\\<in>A\\<longrightarrow>y\\<notin>B\"\"A\\<subseteq>{x,y}\"\"B\\<subseteq>{x,y}\" by auto\n        {\n          assume \"x\\<in>A\"\n          with \\<open>x\\<in>A\\<longrightarrow>x\\<notin>B\\<close>\\<open>B\\<subseteq>{x,y}\\<close> have \"B\\<subseteq>{y}\" by auto\n          then have \"B=0\\<or>B={y}\" by auto\n          with y_no_cl cl(2) have \"B=0\" by auto\n        }\n        moreover\n        {\n          assume \"x\\<notin>A\"\n          with \\<open>A\\<subseteq>{x,y}\\<close> have \"A\\<subseteq>{y}\" by auto\n          then have \"A=0\\<or>A={y}\" by auto\n          with y_no_cl cl(1) have \"A=0\" by auto\n        }\n        ultimately have \"A=0\\<or>B=0\" by auto\n      }\n      then have \"(T{restricted to}{x,y}){is ultraconnected}\" unfolding IsUConnected_def by auto\n      with ASS \\<open>x\\<in>\\<Union>T\\<close>\\<open>y\\<in>\\<Union>T\\<close> have \"{x,y}{is in the spectrum of}IsUConnected\" unfolding antiProperty_def\n        by auto\n      then have \"{x,y}\\<lesssim>1\" using UConn_spectrum by auto\n      moreover have \"x\\<in>{x,y}\" by auto\n      ultimately have \"{x}={x,y}\" using lepoll_1_is_sing[of \"{x,y}\"\"x\"] by auto\n      moreover\n      have \"y\\<in>{x,y}\" by auto\n      ultimately have \"y\\<in>{x}\" by auto\n      then have \"y=x\" by auto\n      then have \"False\" using \\<open>x\\<noteq>y\\<close> by auto\n    }\n    then have \"\\<exists>U\\<in>T. x\\<in>U\\<and>y\\<notin>U\" by auto\n  }\n  then show \"T{is T\\<^sub>1}\" unfolding isT1_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2253
    },
    "2032": {
        "type": "lemma",
        "text": "text\\<open>To end this section, let's try to charaterize anti-sober spaces.\\<close>\n",
        "assumes": "",
        "using": [
            "empty_lepollI",
            "Spec_def",
            "Indiscrete_HConn",
            "topology0.cl_is_closed",
            "topology0_def",
            "topology0.cl_contains_set",
            "topology0.Top_3_L11(1)",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll",
            "eq_lepoll_trans",
            "lepoll_1_is_sing",
            "empty_open",
            "topology0.Top_3_L1",
            "topology0.Top_3_L8"
        ],
        "statement": "lemma sober_spectrum:\n  shows \"(A{is in the spectrum of}IsSober) \\<longleftrightarrow> A\\<lesssim>1\"\n",
        "proof": "proof\n  assume AS:\"A{is in the spectrum of}IsSober\"\n  {\n    assume \"A=0\"\n    then have \"A\\<lesssim>1\" using empty_lepollI by auto\n  }\n  moreover\n  { \n    assume \"A\\<noteq>0\"\n    note AS\n    moreover\n    have top:\"{0,A}{is a topology}\" unfolding IsATopology_def by auto\n    moreover\n    have \"\\<Union>{0,A}=A\" by auto\n    then have \"\\<Union>{0,A}\\<approx>A\" by auto\n    ultimately have \"{0,A}{is sober}\" using Spec_def by auto\n    moreover\n    have \"{0,A}{is hyperconnected}\" using Indiscrete_HConn by auto\n    moreover\n    have \"{0,A}{restricted to}A={0,A}\" unfolding RestrictedTo_def by auto\n    moreover\n    have \"A{is closed in}{0,A}\" unfolding IsClosed_def by auto\n    moreover\n    note \\<open>A\\<noteq>0\\<close>\n    ultimately have \"\\<exists>x\\<in>A. A=Closure({x},{0,A})\\<and> (\\<forall>y\\<in>\\<Union>{0, A}. A = Closure({y}, {0, A}) \\<longrightarrow> y = x)\" unfolding IsSober_def by auto\n    then obtain x where \"x\\<in>A\" \"A=Closure({x},{0,A})\" and reg:\"\\<forall>y\\<in>A. A = Closure({y}, {0, A}) \\<longrightarrow> y = x\" by auto\n    {\n      fix y assume \"y\\<in>A\"\n      with top have \"Closure({y},{0,A}){is closed in}{0,A}\" using topology0.cl_is_closed\n        topology0_def by auto\n      moreover\n      from \\<open>y\\<in>A\\<close> top have \"y\\<in>Closure({y},{0,A})\" using topology0.cl_contains_set\n        topology0_def by auto\n      ultimately have \"A-Closure({y},{0,A})\\<in>{0,A}\"\"Closure({y},{0,A})\\<inter>A\\<noteq>0\" unfolding IsClosed_def\n        by auto\n      then have \"A-Closure({y},{0,A})=A\\<or>A-Closure({y},{0,A})=0\"\n        by auto\n      moreover\n      from \\<open>y\\<in>A\\<close>\\<open>y\\<in>Closure({y},{0,A})\\<close> have \"y\\<in>A\"\"y\\<notin>A-Closure({y},{0,A})\" by auto\n      ultimately have \"A-Closure({y},{0,A})=0\" by (cases \"A-Closure({y},{0,A})=A\", simp, auto)\n      moreover\n      from \\<open>y\\<in>A\\<close> top have \"Closure({y},{0,A})\\<subseteq>A\" using topology0_def topology0.Top_3_L11(1) by blast\n      then have \"A-(A-Closure({y},{0,A}))=Closure({y},{0,A})\" by auto\n      ultimately have \"A=Closure({y},{0,A})\" by auto\n    }\n    with reg have \"\\<forall>y\\<in>A. x=y\" by auto\n    with \\<open>x\\<in>A\\<close> have \"A={x}\" by blast\n    then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n    then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n  }\n  ultimately show \"A\\<lesssim>1\" by auto\nnext\n  assume \"A\\<lesssim>1\"\n  {\n    fix T assume \"T{is a topology}\"\"\\<Union>T\\<approx>A\"\n    {\n      assume \"\\<Union>T=0\"\n      then have \"T{is sober}\" unfolding IsSober_def by auto\n    }\n    moreover\n    {\n      assume \"\\<Union>T\\<noteq>0\"\n      then obtain x where \"x\\<in>\\<Union>T\" by blast\n      moreover\n      from \\<open>\\<Union>T\\<approx>A\\<close> \\<open>A\\<lesssim>1\\<close> have \"\\<Union>T\\<lesssim>1\" using eq_lepoll_trans by auto\n      ultimately have \"\\<Union>T={x}\" using lepoll_1_is_sing by auto\n      moreover\n      have \"T\\<subseteq>Pow(\\<Union>T)\" by auto\n      ultimately have \"T\\<subseteq>Pow({x})\" by auto\n      then have \"T\\<subseteq>{0,{x}}\" by blast\n      moreover\n      from \\<open>T{is a topology}\\<close> have \"0\\<in>T\" using empty_open by auto\n      moreover\n      from \\<open>T{is a topology}\\<close> have \"\\<Union>T\\<in>T\" unfolding IsATopology_def by auto\n      with \\<open>\\<Union>T={x}\\<close> have \"{x}\\<in>T\" by auto\n      ultimately have T_def:\"T={0,{x}}\" by auto\n      then have dd:\"Pow(\\<Union>T)-{0}={{x}}\" by auto\n      {\n        fix B assume \"B\\<in>Pow(\\<Union>T)-{0}\"\n        with dd have B_def:\"B={x}\" by auto\n        from \\<open>T{is a topology}\\<close> have \"(\\<Union>T){is closed in}T\" using topology0_def topology0.Top_3_L1\n          by auto\n        with \\<open>\\<Union>T={x}\\<close> \\<open>T{is a topology}\\<close> have \"Closure({x},T)={x}\" using topology0.Top_3_L8\n          unfolding topology0_def by auto\n        with B_def have \"B=Closure({x},T)\" by auto\n        moreover\n        {\n          fix y assume \"y\\<in>\\<Union>T\"\n          with \\<open>\\<Union>T={x}\\<close> have \"y=x\" by auto\n          }\n        then have \"(\\<forall>y\\<in>\\<Union>T. B = Closure({y}, T) \\<longrightarrow> y = x)\" by auto\n        moreover note \\<open>x\\<in>\\<Union>T\\<close>\n        ultimately have \"(\\<exists>x\\<in>\\<Union>T. B = Closure({x}, T) \\<and> (\\<forall>y\\<in>\\<Union>T. B = Closure({y}, T) \\<longrightarrow> y = x))\"\n          by auto\n      }\n      then have \"T{is sober}\" unfolding IsSober_def by auto\n    }\n    ultimately have \"T{is sober}\" by blast\n  }\n  then show \"A {is in the spectrum of} IsSober\" unfolding Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2254
    },
    "2033": {
        "type": "definition",
        "text": "text\\<open>For a topological space $X=\\bigcup T$ and a surjection $f:X\\rightarrow Y$\n  we define \\<open>{quotient topology in} Y {by} f\\<close> as the collection of subsets\n  of $Y$ whose inverse images by $f$ are open. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in topology0)\n  QuotientTop (\"{quotient topology in}_{by}_\" 80)\n  where \"f\\<in>surj(\\<Union>T,Y) \\<Longrightarrow>{quotient topology in} Y {by} f \\<equiv>\n    {U\\<in>Pow(Y). f-``U\\<in>T}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2255
    },
    "2034": {
        "type": "theorem",
        "text": "text\\<open>The quotient topology is indeed a topology.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  ",
        "using": [
            "QuotientTop_def",
            "assms",
            "vimage_eq_UN",
            "topSpaceAssum",
            "IsATopology_def",
            "invim_inter_inter_invim",
            "surj_def"
        ],
        "statement": "theorem (in topology0) quotientTop_is_top:\n  assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  shows \"({quotient topology in} Y {by} f) {is a topology}\"\n",
        "proof": "proof-\n  have \"({quotient topology in} Y {by} f)={U \\<in> Pow(Y) . f-``(U) \\<in> T}\" using QuotientTop_def assms\n    by auto \n  moreover\n  {\n    fix M x B assume M: \"M \\<subseteq> {U \\<in> Pow(Y) . f-``(U) \\<in> T}\"\n    then have \"\\<Union>M\\<subseteq>Y\" by blast \n    moreover have A1: \"f-``(\\<Union>M) = (\\<Union>y\\<in>(\\<Union>M). f-``{y})\" using vimage_eq_UN by blast\n    moreover \n    {\n      fix A assume \"A\\<in>M\"\n      with M have \"A\\<in>Pow(Y)\" \"f-``(A) \\<in> T\" by auto\n      have \"f-``(A) = (\\<Union>y\\<in>A. f-``{y})\" using vimage_eq_UN by blast\n    }\n    hence \"(\\<Union>A\\<in>M. f-``(A)) = (\\<Union>y\\<in>\\<Union>M. f-``{y})\" by auto\n    with A1 have A2: \"f-``(\\<Union>M)=\\<Union>{f-`` A. A\\<in>M}\" by auto\n    moreover \n    {\n      fix A assume \"A\\<in>M\"\n      with M have \"f-``(A)\\<in>T\" by auto\n    }\n    hence \"{f-``(A). A\\<in>M}\\<subseteq>T\" by auto\n    then have \"(\\<Union>{f-``(A). A\\<in>M})\\<in>T\" \n      using topSpaceAssum unfolding IsATopology_def by auto\n    with A2 have \"(f-``(\\<Union>M))\\<in>T\" by auto\n    ultimately have \"\\<Union>M\\<in>{U\\<in>Pow(Y). f-``U\\<in>T}\" by auto\n  }\n  moreover\n  {\n    fix U V assume \"U \\<in> {U\\<in>Pow(Y). f-``U\\<in>T}\" \"V\\<in>{U\\<in>Pow(Y). f-``U\\<in>T}\"\n    then have \"U\\<in>Pow(Y)\" \"V\\<in>Pow(Y)\" \"f-``U\\<in>T\"\"f-``V\\<in>T\" by auto\n    then have \"f-``(U\\<inter>V)\\<in>T\" using topSpaceAssum invim_inter_inter_invim assms\n      unfolding IsATopology_def surj_def by auto\n    with \\<open>U\\<in>Pow(Y)\\<close> \\<open>V\\<in>Pow(Y)\\<close> have \"U\\<inter>V\\<in>{U\\<in>Pow(Y). f-``(U)\\<in>T}\" by auto\n  }\n  ultimately show ?thesis using IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2256
    },
    "2035": {
        "type": "lemma",
        "text": "text\\<open>The quotient function is continuous.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  ",
        "using": [
            "QuotientTop_def",
            "assms"
        ],
        "statement": "lemma (in topology0) quotient_func_cont:\n  assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  shows \"IsContinuous(T,({quotient topology in} Y {by} f),f)\"\n    unfolding IsContinuous_def ",
        "proof": "using QuotientTop_def assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2257
    },
    "2036": {
        "type": "theorem",
        "text": "text\\<open>One of the important properties of this topology, is that a function\nfrom the quotient space is continuous iff the composition with the quotient\nfunction is continuous.\\<close>\n",
        "assumes": "assumes \"h\\<in>surj(\\<Union>\\<tau>\\<^sub>1,Y)\" \"g:Y\\<rightarrow>\\<Union>\\<tau>\\<^sub>2\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g O h)\"\n  ",
        "using": [
            "vimage_comp",
            "topology0.QuotientTop_def",
            "tau1_is_top",
            "func1_1_L3",
            "assms(2)",
            "topology0_def"
        ],
        "statement": "theorem (in two_top_spaces0) cont_quotient_top:\n  assumes \"h\\<in>surj(\\<Union>\\<tau>\\<^sub>1,Y)\" \"g:Y\\<rightarrow>\\<Union>\\<tau>\\<^sub>2\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,g O h)\"\n  shows \"IsContinuous(({quotient topology in} Y {by} h {from} \\<tau>\\<^sub>1),\\<tau>\\<^sub>2,g)\"\n",
        "proof": "proof-\n  {\n    fix U assume \"U\\<in>\\<tau>\\<^sub>2\"\n    with assms(3) have \"(g O h)-``(U)\\<in>\\<tau>\\<^sub>1\" unfolding IsContinuous_def by auto\n    then have \"h-``(g-``(U))\\<in>\\<tau>\\<^sub>1\" using vimage_comp by auto\n    with assms(1) have \"g-``(U)\\<in>({quotient topology in} Y {by} h {from} \\<tau>\\<^sub>1)\" \n      using topology0.QuotientTop_def tau1_is_top func1_1_L3 assms(2) \n      unfolding topology0_def by auto\n  }\n  then show ?thesis unfolding IsContinuous_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2258
    },
    "2037": {
        "type": "lemma",
        "text": "text\\<open>The underlying set of the quotient topology is $Y$.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  ",
        "using": [
            "func1_1_L4",
            "surj_def",
            "topSpaceAssum",
            "IsATopology_def",
            "QuotientTop_def",
            "assms"
        ],
        "statement": "lemma (in topology0) total_quo_func:\n  assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  shows \"(\\<Union>({quotient topology in} Y {by} f))=Y\"\n",
        "proof": "proof-\n  from assms have \"f-``Y=\\<Union>T\" using func1_1_L4 unfolding surj_def by auto moreover\n  have \"\\<Union>T\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto ultimately\n  have \"Y\\<in>({quotient topology in}Y{by}f{from}T)\" using QuotientTop_def assms by auto\n  then show ?thesis using QuotientTop_def assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2259
    },
    "2038": {
        "type": "lemma",
        "text": "text\\<open>The quotient projection $b\\mapsto r\\{ b\\}$ is a function that maps the domain of the \n  relation to the quotient. Note we do not need to assume that $r$ is an equivalence relation. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma quotient_proj_fun:\n  shows \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>A}:A\\<rightarrow>A//r\" unfolding Pi_def function_def domain_def\n    unfolding quotient_def by auto\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2260
    },
    "2039": {
        "type": "lemma",
        "text": "text\\<open>The quotient projection is a surjection. Again $r$ does not need to be an equivalence relation \n here \\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_tot_val1",
            "quotient_proj_fun",
            "surj_def"
        ],
        "statement": "lemma quotient_proj_surj:\n  shows \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>A}\\<in>surj(A,A//r)\"\n",
        "proof": "proof-\n  { fix y assume \"y\\<in>A//r\"\n    then obtain x where \"x\\<in>A\" \"y=r``{x}\" unfolding quotient_def by auto\n    then have \"\\<exists>x\\<in>A. {\\<langle>b,r``{b}\\<rangle>. b\\<in>A}`(x) = y\" using ZF_fun_from_tot_val1 \n      by auto\n  }\n  then show ?thesis using quotient_proj_fun unfolding surj_def by auto\nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2261
    },
    "2040": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of a subset $U$ of the quotient by the quotient projection is the union\n   of $U$. Note since $U$ is a subset of $A/r$ it is a collection of equivalence classes.\\<close>\n",
        "assumes": "assumes \"U\\<subseteq>A//r\" \"equiv(A,r)\"\n  ",
        "using": [
            "EquivClass_1_L1",
            "EquivClass_1_L2",
            "assms",
            "equiv_class_self"
        ],
        "statement": "lemma preim_equi_proj:\n  assumes \"U\\<subseteq>A//r\" \"equiv(A,r)\"\n  shows \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>A}-``(U) = \\<Union>U\"\n",
        "proof": "proof\n  {\n    fix y assume \"y\\<in>\\<Union>U\"\n    then obtain V where \"y\\<in>V\" and \"V\\<in>U\" by auto\n    with assms have \"y \\<in> {\\<langle>b,r``{b}\\<rangle>. b\\<in>A}-``(U)\"\n      using EquivClass_1_L1 EquivClass_1_L2 by blast\n  }\n  thus \"\\<Union>U\\<subseteq>{\\<langle>b,r``{b}\\<rangle>. b\\<in>A}-``U\" by blast\n  {\n    fix y assume \"y\\<in>{\\<langle>b,r``{b}\\<rangle>. b\\<in>A}-``U\"\n    then have yy: \"y\\<in>{x\\<in>A. r``{x}\\<in>U}\" by auto\n    hence \"r``{y}\\<in>U\" by auto \n    moreover from yy have \"y\\<in>r``{y}\" using assms equiv_class_self by auto \n    ultimately have \"y\\<in>\\<Union>U\" by auto\n  }\n  thus \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>A}-``U\\<subseteq>\\<Union>U\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2262
    },
    "2041": {
        "type": "definition",
        "text": "text\\<open>Now we define what a quotient topology from an equivalence relation is:\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in topology0)\n  EquivQuo (\"{quotient by} _\" 70)\n  where \"equiv(\\<Union>T,r)\\<Longrightarrow>({quotient by} r) \\<equiv> {quotient topology in} (\\<Union>T)//r {by} {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2263
    },
    "2042": {
        "type": "theorem",
        "text": "text\\<open>First, another description of the topology (more intuitive):\\<close>\n",
        "assumes": "assumes \"equiv(\\<Union>T,r)\"\n  ",
        "using": [
            "QuotientTop_def",
            "quotient_proj_surj",
            "preim_equi_proj",
            "EquivQuo_def",
            "assms"
        ],
        "statement": "theorem (in topology0) quotient_equiv_rel:\n  assumes \"equiv(\\<Union>T,r)\"\n  shows \"({quotient by}r)={U\\<in>Pow((\\<Union>T)//r). \\<Union>U\\<in>T}\"\n",
        "proof": "proof-\n  have \"({quotient topology in}(\\<Union>T)//r{by}{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T})=\n    {U\\<in>Pow((\\<Union>T)//r). {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}-``U\\<in>T}\"\n    using QuotientTop_def quotient_proj_surj by auto \n  moreover have \"{U\\<in>Pow((\\<Union>T)//r). {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}-``U\\<in>T}={U\\<in>Pow((\\<Union>T)//r). \\<Union>U\\<in>T}\"\n  proof\n    {\n      fix U assume \"U\\<in>{U\\<in>Pow((\\<Union>T)//r). {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}-``U\\<in>T}\"\n      with assms have \"U\\<in>{U\\<in>Pow((\\<Union>T)//r). \\<Union>U\\<in>T}\" using preim_equi_proj by auto\n    }\n    thus \"{U\\<in>Pow((\\<Union>T)//r). {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}-``U\\<in>T}\\<subseteq>{U\\<in>Pow((\\<Union>T)//r). \\<Union>U\\<in>T}\" by auto\n    {\n      fix U assume \"U\\<in>{U\\<in>Pow((\\<Union>T)//r). \\<Union>U\\<in>T}\"\n      with assms have \"U\\<in>{U\\<in>Pow((\\<Union>T)//r). {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}-``U\\<in>T}\" using preim_equi_proj\n        by auto\n     }\n     thus \"{U\\<in>Pow((\\<Union>T)//r). \\<Union>U\\<in>T}\\<subseteq>{U\\<in>Pow((\\<Union>T)//r). {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}-``U\\<in>T}\" by auto\n   qed\n  ultimately show ?thesis using EquivQuo_def assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2264
    },
    "2043": {
        "type": "theorem",
        "text": "text\\<open>The quotient by an equivalence relation is indeed a topology. \\<close>\n",
        "assumes": "assumes \"equiv(\\<Union>T,r)\"\n  ",
        "using": [
            "quotientTop_is_top",
            "quotient_proj_surj",
            "EquivQuo_def",
            "assms"
        ],
        "statement": "theorem (in topology0) equiv_quo_is_top:\n  assumes \"equiv(\\<Union>T,r)\"\n  shows \"({quotient by}r){is a topology}\"\n  ",
        "proof": "using quotientTop_is_top quotient_proj_surj EquivQuo_def assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2266
    },
    "2044": {
        "type": "theorem",
        "text": "text\\<open>The next theorem is the main result of this section: \n  all quotient topologies arise from an equivalence relation given by the quotient \n  function $f:X\\to Y$. This means that any quotient topology is homeomorphic to a topology\n  given by an equivalence relation quotient.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  defines \"r\\<equiv>{\\<langle>x,y\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T. f`(x)=f`(y)}\"\n  defines \"g\\<equiv>{\\<langle>y,f-``{y}\\<rangle>. y\\<in>Y}\"\n  ",
        "using": [
            "func1_1_L3",
            "ff",
            "vimage_iff",
            "func1_1_L15",
            "apply_equality",
            "assms(1)",
            "surj_def",
            "image_iff",
            "func1_1_L5A(1)",
            "A1(1)",
            "quotient_def",
            "total_quo_equi",
            "B",
            "QuotientTop_def",
            "topSpaceAssum",
            "vimage_eq_UN",
            "gg",
            "apply_type",
            "quotient_equiv_rel",
            "func_imagedef",
            "quotient_proj_fun",
            "apply_funtype",
            "b",
            "comp_fun_apply",
            "func1_1_L9",
            "Pi_def",
            "EquivClass_1_L2",
            "comeq",
            "comp_fun",
            "quotient_func_cont",
            "quotient_proj_surj",
            "EquivQuo_def",
            "gg2",
            "two_top_spaces0.cont_quotient_top",
            "equiv_quo_is_top",
            "two_top_spaces0_def",
            "surj_image_vimage",
            "feq",
            "comp_mem_surjD1",
            "total_quo_func",
            "bij_cont_open_homeo"
        ],
        "statement": "theorem (in topology0) equiv_quotient_top:\n  assumes \"f\\<in>surj(\\<Union>T,Y)\"\n  defines \"r\\<equiv>{\\<langle>x,y\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T. f`(x)=f`(y)}\"\n  defines \"g\\<equiv>{\\<langle>y,f-``{y}\\<rangle>. y\\<in>Y}\"\n  shows \"equiv(\\<Union>T,r)\" and \n    \"IsAhomeomorphism(({quotient topology in}Y{by}f),({quotient by}r),g)\"\n",
        "proof": "proof-\n  from assms(1) have ff: \"f:\\<Union>T\\<rightarrow>Y\" unfolding surj_def by auto\n  from assms(2) show B: \"equiv(\\<Union>T,r)\" \n    unfolding equiv_def refl_def sym_def trans_def r_def by auto\n  have gg: \"g:Y\\<rightarrow>((\\<Union>T)//r)\"\n  proof -\n    { fix B assume \"B\\<in>g\"\n      then obtain y where Y:\"y\\<in>Y\" \"B=\\<langle>y,f-``{y}\\<rangle>\" unfolding g_def \n        by auto\n      then have \"f-``{y}\\<subseteq>\\<Union>T\" using func1_1_L3 ff by blast\n      then have eq: \"f-``{y}={x\\<in>\\<Union>T. \\<langle>x,y\\<rangle>\\<in>f}\" using vimage_iff by auto\n      from assms(1) Y obtain A where A1: \"A\\<in>\\<Union>T\" \"f`(A)=y\" unfolding surj_def \n        by blast\n      with ff have A: \"A \\<in> f-``{y}\" using func1_1_L15 by simp\n      { fix t assume \"t\\<in>f-``{y}\"\n        with A eq have \"t\\<in>\\<Union>T\" \"A\\<in>\\<Union>T\" \"\\<langle>t,y\\<rangle>\\<in>f\" \"\\<langle>A,y\\<rangle>\\<in>f\" by auto\n        then have \"f`t=f`A\" using apply_equality assms(1) unfolding surj_def by auto\n        with assms(2) \\<open>t\\<in>\\<Union>T\\<close>\\<open>A\\<in>\\<Union>T\\<close> have \"\\<langle>A,t\\<rangle>\\<in>r\" by auto\n        then have \"t\\<in>r``{A}\" using image_iff by auto\n      } hence \"f-``{y}\\<subseteq>r``{A}\" by auto \n      moreover\n      { fix t assume \"t\\<in>r``{A}\"\n        with assms(2) have un: \"t\\<in>\\<Union>T\" \"A\\<in>\\<Union>T\" and eq2: \"f`(t)=f`(A)\"\n          using image_iff by simp_all\n        from ff un have \"\\<langle>t,f`(t)\\<rangle>\\<in>f\" using func1_1_L5A(1) by simp\n        with eq2 A1 un eq have \"t\\<in>f-``{y}\" by simp\n      } hence \"r``{A}\\<subseteq>f-``{y}\" by auto \n      ultimately have \"f-``{y}=r``{A}\" by auto\n      with A1(1) have \"f-``{y} \\<in> (\\<Union>T)//r\" \n        using A1(1) unfolding quotient_def by auto\n      with Y have \"B\\<in>Y\\<times>(\\<Union>T)//r\" by auto\n    } then show ?thesis unfolding Pi_def function_def domain_def g_def \n      by auto\n  qed\n  then have gg2: \"g:Y\\<rightarrow>(\\<Union>({quotient by}r))\" using total_quo_equi B \n    by auto\n  { fix s assume S: \"s\\<in>({quotient topology in}Y{by}f)\"\n    then have \"s\\<in>Pow(Y)\" and P: \"f-``(s)\\<in>T\" \n      using QuotientTop_def topSpaceAssum assms(1) by auto\n    have \"f-``s=(\\<Union>y\\<in>s. f-``{y})\" using vimage_eq_UN by blast \n    moreover\n    from \\<open>s\\<in>Pow(Y)\\<close> have \"\\<forall>y\\<in>s. \\<langle>y,f-``{y}\\<rangle>\\<in>g\" unfolding g_def by auto\n    then have \"\\<forall>y\\<in>s. g`y=f-``{y}\" using apply_equality gg by auto \n    ultimately have \"f-``s=(\\<Union>y\\<in>s. g`y)\" by auto\n    with P have \"(\\<Union>y\\<in>s. g`y)\\<in>T\" by auto \n    moreover from \\<open>s\\<in>Pow(Y)\\<close> have \"\\<forall>y\\<in>s. g`y\\<in>(\\<Union>T)//r\" using apply_type gg by auto\n    ultimately have \"{g`y. y\\<in>s}\\<in>({quotient by}r)\" using quotient_equiv_rel B by auto\n    with \\<open>s\\<in>Pow(Y)\\<close> have \"g``s\\<in>({quotient by}r)\" using func_imagedef gg by auto\n  } hence gopen: \"\\<forall>s\\<in>({quotient topology in}Y{by}f). g``s\\<in>(T{quotient by}r)\" \n    by auto\n  have pr_fun: \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}:\\<Union>T\\<rightarrow>(\\<Union>T)//r\" \n    using quotient_proj_fun by auto\n  { fix b assume b: \"b\\<in>\\<Union>T\"\n    have bY: \"f`(b)\\<in>Y\" using apply_funtype ff b by auto\n    with b have com: \"(g O f)`b=g`(f`b)\" using comp_fun_apply ff by auto\n    from bY have pg: \"\\<langle>f`b,f-``({f`b})\\<rangle>\\<in>g\" unfolding g_def by auto\n    then have \"g`(f`b) = f-``({f`b})\" using apply_equality gg by auto\n    with com have comeq: \"(g O f)`b=f-``({f`b})\" by auto\n    from b have A: \"f``{b}={f`b}\" \"{b}\\<subseteq>\\<Union>T\" using func_imagedef ff by auto\n    from A(2) have \"b \\<in> f-``(f `` {b})\" using func1_1_L9 ff by blast\n    with A(1) have \"b\\<in>f-``({f`b})\" by auto \n    moreover from pg have \"f-``({f`b})\\<in>(\\<Union>T)//r\" using gg unfolding Pi_def \n      by auto\n    ultimately have \"r``{b}=f-``({f`b})\" using EquivClass_1_L2 B by auto\n    then have \"(g O f)`b=r``{b}\" using comeq by auto \n    moreover from b pr_fun have \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`b=r``{b}\" \n      using apply_equality by simp\n    ultimately  have \"(g O f)`b={\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`b\" by simp\n  } hence reg: \"\\<forall>b\\<in>\\<Union>T. (g O f)`(b)={\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(b)\" by blast\n  moreover have compp: \"g O f\\<in>\\<Union>T\\<rightarrow>(\\<Union>T)//r\" using comp_fun ff gg by blast\n  moreover\n  from compp pr_fun reg have feq: \"(g O f)={\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\"\n    by (rule func_eq)\n  then have \"IsContinuous(T,{quotient by}r,(g O f))\" \n    using quotient_func_cont quotient_proj_surj EquivQuo_def topSpaceAssum B by auto \n  moreover have \"(g O f):\\<Union>T\\<rightarrow>\\<Union>({quotient by}r)\" using comp_fun ff gg2 by auto\n  ultimately have gcont: \"IsContinuous({quotient topology in}Y{by}f,{quotient by}r,g)\"\n    using two_top_spaces0.cont_quotient_top assms(1) gg2 topSpaceAssum equiv_quo_is_top B\n    unfolding two_top_spaces0_def by auto\n  { fix x y assume T: \"x\\<in>Y\" \"y\\<in>Y\" \"g`(x)=g`(y)\"\n    with assms(3) have \"f``(f-``{x})=f``(f-``{y})\" \n      using apply_equality gg by simp\n    with assms(1) T(1,2) have \"x=y\" using surj_image_vimage by auto\n  } with gg2 have \"g\\<in>inj(Y,\\<Union>({quotient by}r))\" unfolding inj_def by auto \n  moreover\n  have \"g O f\\<in>surj(\\<Union>T, (\\<Union>T)//r)\" using feq quotient_proj_surj by auto\n  with ff gg B have \"g\\<in>surj(Y,\\<Union>(T{quotient by}r))\" \n    using comp_mem_surjD1 total_quo_equi by auto\n  ultimately have \"g\\<in>bij(\\<Union>({quotient topology in}Y{by}f),\\<Union>({quotient by}r))\" \n    unfolding bij_def using total_quo_func assms(1) by auto\n  with gcont gopen show \"IsAhomeomorphism(({quotient topology in}Y{by}f),({quotient by}r),g)\"\n    using bij_cont_open_homeo by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2267
    },
    "2045": {
        "type": "lemma",
        "text": "text\\<open>The mapping $\\langle b,c \\rangle \\mapsto \\langle r\\{ a\\},r\\{ b\\}\\rangle$\n  is a function that maps the product of the carrier by itself to the\n  product of the quotients. Note $r$ does not have to be an equivalence relation. \\<close>\n",
        "assumes": "",
        "using": [
            "quotient_proj_fun",
            "apply_equality",
            "prod_fun"
        ],
        "statement": "lemma product_equiv_rel_fun:\n  shows \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}:(\\<Union>T\\<times>\\<Union>T)\\<rightarrow>((\\<Union>T)//r\\<times>(\\<Union>T)//r)\"\n",
        "proof": "proof-\n  have \" {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\\<in>\\<Union>T\\<rightarrow>(\\<Union>T)//r\" using quotient_proj_fun by auto \n  moreover have \"\\<forall>A\\<in>\\<Union>T. \\<langle>A,r``{A}\\<rangle>\\<in>{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\" by auto\n  ultimately have \"\\<forall>A\\<in>\\<Union>T. {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`A=r``{A}\" using apply_equality by auto\n  hence \"{\\<langle>\\<langle>b,c\\<rangle>,r``{b},r``{c}\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T} = \n    {\\<langle>\\<langle>x,y\\<rangle>,{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(x),{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(y)\\<rangle>. \\<langle>x,y\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\"\n    by force\n  then show ?thesis using prod_fun quotient_proj_fun by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2268
    },
    "2046": {
        "type": "lemma",
        "text": "text\\<open>The mapping $\\langle b,c \\rangle \\mapsto \\langle r\\{ a\\},r\\{ b\\}\\rangle$\n  is a surjection of the product of the carrier by itself onto the\n  carrier of the product topology. Again $r$ does not have to be an equivalence relation for this. \\<close>\n",
        "assumes": "",
        "using": [
            "product_equiv_rel_fun",
            "apply_equality",
            "Top_1_4_T1(3)",
            "topSpaceAssum"
        ],
        "statement": "lemma (in topology0) prod_equiv_rel_surj:\n  shows \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\\<in>surj(\\<Union>(T\\<times>\\<^sub>tT),((\\<Union>T)//r\\<times>(\\<Union>T)//r))\"\n",
        "proof": "proof-\n  have \n    fun: \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}:(\\<Union>T\\<times>\\<Union>T)\\<rightarrow>((\\<Union>T)//r\\<times>(\\<Union>T)//r)\" \n      using product_equiv_rel_fun by auto \n  moreover\n  { fix M assume \"M\\<in>((\\<Union>T)//r\\<times>(\\<Union>T)//r)\"\n    then obtain M1 M2 where M: \"M=\\<langle>M1,M2\\<rangle>\" \"M1\\<in>(\\<Union>T)//r\"\"M2\\<in>(\\<Union>T)//r\" by auto\n    then obtain m1 m2 where m: \"m1\\<in>\\<Union>T\" \"m2\\<in>\\<Union>T\" \"M1=r``{m1}\" \"M2=r``{m2}\" \n      unfolding quotient_def by auto\n    then have mm: \"\\<langle>m1,m2\\<rangle>\\<in>(\\<Union>T\\<times>\\<Union>T)\" by auto\n    hence \"\\<langle>\\<langle>m1,m2\\<rangle>,\\<langle>r``{m1},r``{m2}\\<rangle>\\<rangle>\\<in>{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\" \n      by auto\n    with fun have \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}`\\<langle>m1,m2\\<rangle>=\\<langle>r``{m1},r``{m2}\\<rangle>\"\n      using apply_equality by auto\n    with M(1) m(3,4) mm have \"\\<exists>R\\<in>(\\<Union>T\\<times>\\<Union>T). {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}`(R) = M\"\n      by auto\n  }\n  ultimately show ?thesis unfolding surj_def using Top_1_4_T1(3) topSpaceAssum \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2269
    },
    "2047": {
        "type": "lemma",
        "text": "text\\<open>The product quotient projection (i.e. the mapping the mapping \n  $\\langle b,c \\rangle \\mapsto \\langle r\\{ a\\},r\\{ b\\}\\rangle$ is continuous.\\<close>\n",
        "assumes": "assumes \"equiv(\\<Union>T,r)\"\n  ",
        "using": [
            "quotient_proj_fun",
            "apply_equality",
            "quotient_func_cont",
            "quotient_proj_surj",
            "EquivQuo_def",
            "total_quo_equi",
            "equiv_quo_is_top",
            "topSpaceAssum",
            "top",
            "two_top_spaces0.product_cont_functions"
        ],
        "statement": "lemma (in topology0) product_quo_fun:\n  assumes \"equiv(\\<Union>T,r)\"\n  shows \n    \"IsContinuous(T\\<times>\\<^sub>tT,({quotient by} r)\\<times>\\<^sub>t({quotient by} r),{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T})\"\n",
        "proof": "proof-\n  have \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}:\\<Union>T\\<rightarrow>(\\<Union>T)//r\" using quotient_proj_fun by auto\n  moreover have \"\\<forall>A\\<in>\\<Union>T. \\<langle>A,r``{A}\\<rangle> \\<in> {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\" by auto\n  ultimately have \"\\<forall>A\\<in>\\<Union>T. {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`A=r``{A}\" using apply_equality by auto\n  hence IN: \"{\\<langle>\\<langle>b,c\\<rangle>,r``{b},r``{c}\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T} = \n    {\\<langle>\\<langle>x,y\\<rangle>,{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}`(x),{\\<langle>b,r``{b}\\<rangle>.b\\<in>\\<Union>T}`(y)\\<rangle>. \\<langle>x,y\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\"\n    by force\n  with assms have cont: \"IsContinuous(T,{quotient by}r,{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T})\" \n    using quotient_func_cont quotient_proj_surj EquivQuo_def by auto\n  with assms have  tot: \"\\<Union>(T{quotient by}r) = (\\<Union>T) // r\" and \n    top: \"({quotient by}r) {is a topology}\" \n    using total_quo_equi equiv_quo_is_top by auto \n  then have fun: \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}:\\<Union>T\\<rightarrow>\\<Union>({quotient by}r)\" using quotient_proj_fun \n    by auto\n  then have \"two_top_spaces0(T,{quotient by}r,{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T})\" \n    unfolding two_top_spaces0_def using topSpaceAssum top by auto\n  with fun cont top IN show ?thesis \n    using two_top_spaces0.product_cont_functions topSpaceAssum by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2270
    },
    "2048": {
        "type": "definition",
        "text": "text\\<open>First, we define the set of homeomorphisms.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"HomeoG(T) \\<equiv> {f:\\<Union>T\\<rightarrow>\\<Union>T. IsAhomeomorphism(T,T,f)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2272
    },
    "2049": {
        "type": "lemma",
        "text": "text\\<open>The homeomorphisms are closed by composition.\\<close>\n",
        "assumes": "assumes \"f\\<in>HomeoG(T)\"\"g\\<in>HomeoG(T)\"\n  ",
        "using": [
            "comp_fun",
            "comp_bij",
            "comp_cont",
            "converse_comp",
            "func_ZF_5_L2",
            "fun"
        ],
        "statement": "lemma (in topology0) homeo_composition:\n  assumes \"f\\<in>HomeoG(T)\"\"g\\<in>HomeoG(T)\"\n  shows \"Composition(\\<Union>T)`\\<langle>f, g\\<rangle>\\<in>HomeoG(T)\"\n",
        "proof": "proof-\n  from assms have fun:\"f\\<in>\\<Union>T\\<rightarrow>\\<Union>T\"\"g\\<in>\\<Union>T\\<rightarrow>\\<Union>T\" and homeo:\"IsAhomeomorphism(T,T,f)\"\"IsAhomeomorphism(T,T,g)\" unfolding HomeoG_def\n    by auto\n  from fun have \"f O g\\<in>\\<Union>T\\<rightarrow>\\<Union>T\" using comp_fun by auto moreover\n  from homeo have bij:\"f\\<in>bij(\\<Union>T,\\<Union>T)\"\"g\\<in>bij(\\<Union>T,\\<Union>T)\" and cont:\"IsContinuous(T,T,f)\"\"IsContinuous(T,T,g)\" and contconv:\n    \"IsContinuous(T,T,converse(f))\"\"IsContinuous(T,T,converse(g))\" unfolding IsAhomeomorphism_def by auto\n  from bij have \"f O g\\<in>bij(\\<Union>T,\\<Union>T)\" using comp_bij by auto moreover\n  from cont have \"IsContinuous(T,T,f O g)\" using comp_cont by auto moreover\n  have \"converse(f O g)=converse(g) O converse(f)\" using converse_comp by auto\n  with contconv have \"IsContinuous(T,T,converse(f O g))\" using comp_cont by auto ultimately\n  have \"f O g\\<in>HomeoG(T)\" unfolding HomeoG_def IsAhomeomorphism_def by auto\n  then show ?thesis using func_ZF_5_L2 fun by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2273
    },
    "2050": {
        "type": "lemma",
        "text": "text\\<open>The identity function is a homeomorphism.\\<close>\n",
        "assumes": "",
        "using": [
            "left_comp_inverse",
            "id_bij",
            "right_comp_id",
            "id_cont",
            "id_type"
        ],
        "statement": "lemma (in topology0) homeo_id:\n  shows \"id(\\<Union>T)\\<in>HomeoG(T)\"\n",
        "proof": "proof-\n  have \"converse(id(\\<Union>T)) O id(\\<Union>T)=id(\\<Union>T)\" using left_comp_inverse id_bij by auto\n  then have \"converse(id(\\<Union>T))=id(\\<Union>T)\" using right_comp_id by auto\n  then show ?thesis unfolding HomeoG_def IsAhomeomorphism_def using id_cont id_type id_bij\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2274
    },
    "2051": {
        "type": "theorem",
        "text": "text\\<open>The homeomorphisms form a monoid and its neutral element is the identity.\\<close>\n",
        "assumes": "",
        "using": [
            "homeo_composition",
            "homeo_id",
            "Group_ZF_2_5_L2(2)",
            "Group_ZF_2_5_L2(1)",
            "monoid0.group0_1_T1",
            "monoid0_def",
            "group0_1_L6"
        ],
        "statement": "theorem (in topology0) homeo_submonoid:\n  shows \"IsAmonoid(HomeoG(T),restrict(Composition(\\<Union>T),HomeoG(T)\\<times>HomeoG(T)))\" \n  \"TheNeutralElement(HomeoG(T),restrict(Composition(\\<Union>T),HomeoG(T)\\<times>HomeoG(T)))=id(\\<Union>T)\"\n",
        "proof": "proof-\n  have cl:\"HomeoG(T) {is closed under} Composition(\\<Union>T)\" unfolding IsOpClosed_def using homeo_composition by auto\n  moreover have sub:\"HomeoG(T)\\<subseteq>\\<Union>T\\<rightarrow>\\<Union>T\" unfolding HomeoG_def by auto moreover\n  have ne:\"TheNeutralElement(\\<Union>T\\<rightarrow>\\<Union>T, Composition(\\<Union>T))\\<in>HomeoG(T)\" using homeo_id Group_ZF_2_5_L2(2) by auto\n  ultimately show \"IsAmonoid(HomeoG(T),restrict(Composition(\\<Union>T),HomeoG(T)\\<times>HomeoG(T)))\" using Group_ZF_2_5_L2(1)\n    monoid0.group0_1_T1 unfolding monoid0_def by force\n  from cl sub ne have \"TheNeutralElement(HomeoG(T),restrict(Composition(\\<Union>T),HomeoG(T)\\<times>HomeoG(T)))=TheNeutralElement(\\<Union>T\\<rightarrow>\\<Union>T, Composition(\\<Union>T))\" \n    using Group_ZF_2_5_L2(1) group0_1_L6 by blast moreover\n  have \"id(\\<Union>T)=TheNeutralElement(\\<Union>T\\<rightarrow>\\<Union>T, Composition(\\<Union>T))\" using Group_ZF_2_5_L2(2) by auto\n  ultimately show \"TheNeutralElement(HomeoG(T),restrict(Composition(\\<Union>T),HomeoG(T)\\<times>HomeoG(T)))=id(\\<Union>T)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2275
    },
    "2052": {
        "type": "theorem",
        "text": "text\\<open>As a first example, we show that the group of homeomorphisms of the cocardinal\ntopology is the group of bijective functions.\\<close>\n",
        "assumes": "assumes \"InfCard(Q)\"\n  ",
        "using": [
            "union_cocardinal",
            "bij_converse_bij",
            "assms",
            "n",
            "CoCar_is_topology",
            "closed_sets_cocardinal",
            "cinj",
            "restrict_bij",
            "eqpoll_sym",
            "eq_lesspoll_trans",
            "func1_1_L3",
            "func1_1_L4",
            "two_top_spaces0.Top_ZF_2_1_L4",
            "two_top_spaces0.Top_ZF_2_1_L3",
            "two_top_spaces0.Top_ZF_2_1_L2",
            "two"
        ],
        "statement": "theorem homeo_cocardinal:\n  assumes \"InfCard(Q)\"\n  shows \"HomeoG(CoCardinal(X,Q))=bij(X,X)\"\n",
        "proof": "proof\n  from assms have n:\"Q\\<noteq>0\" unfolding InfCard_def by auto\n  then show \"HomeoG(CoCardinal(X,Q)) \\<subseteq> bij(X, X)\" unfolding HomeoG_def IsAhomeomorphism_def\n    using union_cocardinal by auto\n  {\n    fix f assume a:\"f\\<in>bij(X,X)\"\n    then have \"converse(f)\\<in>bij(X,X)\" using bij_converse_bij by auto\n    then have cinj:\"converse(f)\\<in>inj(X,X)\" unfolding bij_def by auto\n    from a have fun:\"f\\<in>X\\<rightarrow>X\" unfolding bij_def inj_def by auto\n    then have two:\"two_top_spaces0((CoCardinal(X,Q)),(CoCardinal(X,Q)),f)\" unfolding two_top_spaces0_def\n      using union_cocardinal assms n CoCar_is_topology by auto\n    {\n      fix N assume \"N{is closed in}(CoCardinal(X,Q))\"\n      then have N_def:\"N=X \\<or> (N\\<in>Pow(X) \\<and> N\\<prec>Q)\" using closed_sets_cocardinal n by auto\n      then have \"restrict(converse(f),N)\\<in>bij(N,converse(f)``N)\" using cinj restrict_bij by auto\n      then have \"N\\<approx>f-``N\" unfolding vimage_def eqpoll_def by auto\n      then have \"f-``N\\<approx>N\" using eqpoll_sym by auto\n      with N_def have \"N=X \\<or> (f-``N\\<prec>Q \\<and> N\\<in>Pow(X))\" using eq_lesspoll_trans by auto\n      with fun have \"f-``N=X \\<or> (f-``N\\<prec>Q \\<and> (f-``N)\\<in>Pow(X))\" using func1_1_L3 func1_1_L4 by auto\n      then have \"f-``N {is closed in}(CoCardinal(X,Q))\" using closed_sets_cocardinal n by auto\n    }\n    then have \"\\<forall>N. N{is closed in}(CoCardinal(X,Q)) \\<longrightarrow> f-``N {is closed in}(CoCardinal(X,Q))\" by auto\n    then have \"IsContinuous((CoCardinal(X,Q)),(CoCardinal(X,Q)),f)\" using two_top_spaces0.Top_ZF_2_1_L4 \n      two_top_spaces0.Top_ZF_2_1_L3 two_top_spaces0.Top_ZF_2_1_L2 two by auto\n  }\n  then have \"\\<forall>f\\<in>bij(X,X). IsContinuous((CoCardinal(X,Q)),(CoCardinal(X,Q)),f)\" by auto\n  then have \"\\<forall>f\\<in>bij(X,X). IsContinuous((CoCardinal(X,Q)),(CoCardinal(X,Q)),f) \\<and> IsContinuous((CoCardinal(X,Q)),(CoCardinal(X,Q)),converse(f))\"\n    using bij_converse_bij by auto\n  then have \"\\<forall>f\\<in>bij(X,X). IsAhomeomorphism((CoCardinal(X,Q)),(CoCardinal(X,Q)),f)\" unfolding IsAhomeomorphism_def\n    using n union_cocardinal by auto\n  then show \"bij(X,X)\\<subseteq>HomeoG((CoCardinal(X,Q)))\" unfolding HomeoG_def bij_def inj_def using n union_cocardinal\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2276
    },
    "2053": {
        "type": "theorem",
        "text": "text\\<open>The group of homeomorphism of the excluded set is a direct product of the bijections on $X\\setminus T$\n  and the bijections on $X\\cap T$.\\<close>\n",
        "assumes": "",
        "using": [
            "union_excludedset",
            "IsAhomeomorphism_def",
            "fun",
            "restrict_fun",
            "sub1",
            "func_imagedef",
            "rfun",
            "surj_def",
            "apply_funtype",
            "bij_def",
            "inj_def",
            "surj",
            "bij",
            "\\<open>s\\<in>X-T\\<close>",
            "\\<open>d\\<in>T\\<close>",
            "int_top_invariant",
            "interior_set_excludedset",
            "func1_1_L6(2)",
            "A",
            "eq",
            "im",
            "ss",
            "bij_converse_bij",
            "confun",
            "conbij",
            "surj_image_vimage",
            "homeo_inv",
            "func1_1_L8",
            "inj_vimage_image",
            "surj_range_image_domain",
            "as(2)",
            "func1_1_L4",
            "as_3",
            "bij_cont_open_homeo"
        ],
        "statement": "theorem homeo_excluded:\n  shows \"HomeoG(ExcludedSet(X,T))={f\\<in>bij(X,X). f``(X-T)=(X-T)}\"\n",
        "proof": "proof\n  have sub1:\"X-T\\<subseteq>X\" by auto\n  {\n    fix g assume \"g\\<in>HomeoG(ExcludedSet(X,T))\"\n    then have fun:\"g:X\\<rightarrow>X\" and bij:\"g\\<in>bij(X,X)\" and hom:\"IsAhomeomorphism((ExcludedSet(X,T)),(ExcludedSet(X,T)),g)\" unfolding HomeoG_def\n      using union_excludedset unfolding IsAhomeomorphism_def by auto\n    {\n      assume A:\"g``(X-T)=X\" and B:\"X\\<inter>T\\<noteq>0\"\n      have rfun:\"restrict(g,X-T):X-T\\<rightarrow>X\" using fun restrict_fun sub1 by auto moreover\n      from A fun have \"{g`aa. aa\\<in>X-T}=X\" using func_imagedef sub1 by auto\n      then have \"\\<forall>x\\<in>X. x\\<in>{g`aa. aa\\<in>X-T}\" by auto\n      then have \"\\<forall>x\\<in>X. \\<exists>aa\\<in>X-T. x=g`aa\" by auto\n      then have \"\\<forall>x\\<in>X. \\<exists>aa\\<in>X-T. x=restrict(g,X-T)`aa\" by auto\n      with A have surj:\"restrict(g,X-T)\\<in>surj(X-T,X)\" using rfun unfolding surj_def by auto\n      from B obtain d where \"d\\<in>X\"\"d\\<in>T\" by auto\n      with bij have \"g`d\\<in>X\" using apply_funtype unfolding bij_def inj_def by auto\n      then obtain s where \"restrict(g,X-T)`s=g`d\"\"s\\<in>X-T\" using surj unfolding surj_def by blast\n      then have \"g`s=g`d\" by auto\n      with \\<open>d\\<in>X\\<close>\\<open>s\\<in>X-T\\<close> have \"s=d\" using bij unfolding bij_def inj_def by auto\n      then have \"False\" using \\<open>s\\<in>X-T\\<close> \\<open>d\\<in>T\\<close> by auto\n    }\n    then have \"g``(X-T)=X \\<longrightarrow> X\\<inter>T=0\" by auto\n    then have reg:\"g``(X-T)=X \\<longrightarrow> X-T=X\" by auto\n    then have \"g``(X-T)=X \\<longrightarrow> g``(X-T)=X-T\" by auto\n    then have \"g``(X-T)=X \\<longrightarrow> g\\<in>{f\\<in>bij(X,X). f``(X-T)=(X-T)}\" using bij by auto moreover\n    {\n      fix gg\n      assume A:\"gg``(X-T)\\<noteq>X\" and hom2:\"IsAhomeomorphism((ExcludedSet(X,T)),(ExcludedSet(X,T)),gg)\"\n      from hom2 have fun:\"gg\\<in>X\\<rightarrow>X\" and bij:\"gg\\<in>bij(X,X)\" unfolding IsAhomeomorphism_def bij_def inj_def using union_excludedset by auto\n      have sub:\"X-T\\<subseteq>\\<Union>(ExcludedSet(X,T))\" using union_excludedset by auto\n      with hom2 have \"gg``(Interior(X-T,(ExcludedSet(X,T))))=Interior(gg``(X-T),(ExcludedSet(X,T)))\"\n        using int_top_invariant by auto moreover\n      from sub1 have \"Interior(X-T,(ExcludedSet(X,T)))=X-T\" using interior_set_excludedset by auto\n      ultimately have \"gg``(X-T)=Interior(gg``(X-T),(ExcludedSet(X,T)))\" by auto moreover\n      have ss:\"gg``(X-T)\\<subseteq>X\" using fun func1_1_L6(2) by auto\n      then have \"Interior(gg``(X-T),(ExcludedSet(X,T))) = (gg``(X-T))-T\" using interior_set_excludedset A\n        by auto\n      ultimately have eq:\"gg``(X-T)=(gg``(X-T))-T\" by auto\n      {\n        assume \"(gg``(X-T))\\<inter>T\\<noteq>0\"\n        then obtain t where \"t\\<in>T\" and im:\"t\\<in>gg``(X-T)\" by blast\n        then have \"t\\<notin>(gg``(X-T))-T\" by auto\n        then have \"False\" using eq im by auto \n      }\n      then have \"(gg``(X-T))\\<inter>T=0\" by auto\n      then have \"gg``(X-T)\\<subseteq>X-T\" using ss by blast\n    }\n    then have \"\\<forall>gg. gg``(X-T)\\<noteq>X \\<and> IsAhomeomorphism(ExcludedSet(X,T),ExcludedSet(X,T),gg)\\<longrightarrow> gg``(X-T)\\<subseteq>X-T\" by auto moreover\n    from bij have conbij:\"converse(g)\\<in>bij(X,X)\" using bij_converse_bij by auto\n    then have confun:\"converse(g)\\<in>X\\<rightarrow>X\" unfolding bij_def inj_def by auto\n    {\n      assume A:\"converse(g)``(X-T)=X\" and B:\"X\\<inter>T\\<noteq>0\"\n      have rfun:\"restrict(converse(g),X-T):X-T\\<rightarrow>X\" using confun restrict_fun sub1 by auto moreover\n      from A confun have \"{converse(g)`aa. aa\\<in>X-T}=X\" using func_imagedef sub1 by auto\n      then have \"\\<forall>x\\<in>X. x\\<in>{converse(g)`aa. aa\\<in>X-T}\" by auto\n      then have \"\\<forall>x\\<in>X. \\<exists>aa\\<in>X-T. x=converse(g)`aa\" by auto\n      then have \"\\<forall>x\\<in>X. \\<exists>aa\\<in>X-T. x=restrict(converse(g),X-T)`aa\" by auto\n      with A have surj:\"restrict(converse(g),X-T)\\<in>surj(X-T,X)\" using rfun unfolding surj_def by auto\n      from B obtain d where \"d\\<in>X\"\"d\\<in>T\" by auto\n      with conbij have \"converse(g)`d\\<in>X\" using apply_funtype unfolding bij_def inj_def by auto\n      then obtain s where \"restrict(converse(g),X-T)`s=converse(g)`d\"\"s\\<in>X-T\" using surj unfolding surj_def by blast\n      then have \"converse(g)`s=converse(g)`d\" by auto\n      with \\<open>d\\<in>X\\<close>\\<open>s\\<in>X-T\\<close> have \"s=d\" using conbij unfolding bij_def inj_def by auto\n      then have \"False\" using \\<open>s\\<in>X-T\\<close> \\<open>d\\<in>T\\<close> by auto\n    }\n    then have \"converse(g)``(X-T)=X \\<longrightarrow> X\\<inter>T=0\" by auto\n    then have \"converse(g)``(X-T)=X \\<longrightarrow> X-T=X\" by auto\n    then have \"converse(g)``(X-T)=X \\<longrightarrow> g-``(X-T)=(X-T)\" unfolding vimage_def by auto\n    then have G:\"converse(g)``(X-T)=X \\<longrightarrow> g``(g-``(X-T))=g``(X-T)\" by auto\n    have GG:\"g``(g-``(X-T))=(X-T)\" using sub1 surj_image_vimage bij unfolding bij_def by auto\n    with G have \"converse(g)``(X-T)=X \\<longrightarrow> g``(X-T)=X-T\" by auto\n    then have \"converse(g)``(X-T)=X \\<longrightarrow> g\\<in>{f\\<in>bij(X,X). f``(X-T)=(X-T)}\" using bij by auto moreover\n    from hom have \"IsAhomeomorphism(ExcludedSet(X,T), ExcludedSet(X,T), converse(g))\" using homeo_inv by auto\n    moreover note hom ultimately have \"g\\<in>{f\\<in>bij(X,X). f``(X-T)=(X-T)} \\<or> (g``(X-T)\\<subseteq>X-T \\<and> converse(g)``(X-T)\\<subseteq>X-T)\"\n      by force\n    then have \"g\\<in>{f\\<in>bij(X,X). f``(X-T)=(X-T)} \\<or> (g``(X-T)\\<subseteq>X-T \\<and> g-``(X-T)\\<subseteq>X-T)\" unfolding vimage_def by auto moreover\n    have \"g-``(X-T)\\<subseteq>X-T \\<longrightarrow> g``(g-``(X-T))\\<subseteq>g``(X-T)\" using func1_1_L8 by auto\n    with GG have \"g-``(X-T)\\<subseteq>X-T \\<longrightarrow> (X-T)\\<subseteq>g``(X-T)\" by force\n    ultimately have \"g\\<in>{f\\<in>bij(X,X). f``(X-T)=(X-T)} \\<or> (g``(X-T)\\<subseteq>X-T \\<and> (X-T)\\<subseteq>g``(X-T))\" by auto\n    then have \"g\\<in>{f\\<in>bij(X,X). f``(X-T)=(X-T)}\" using bij by auto\n  }\n  then show \"HomeoG(ExcludedSet(X,T))\\<subseteq>{f\\<in>bij(X,X). f``(X-T)=(X-T)}\" by auto\n  {\n    fix g assume as:\"g\\<in>bij(X,X)\"\"g``(X-T)=X-T\"\n    then have inj:\"g\\<in>inj(X,X)\" and im:\"g-``(g``(X-T))=g-``(X-T)\" unfolding bij_def by auto\n    from inj have \"g-``(g``(X-T))=X-T\" using inj_vimage_image sub1 by force\n    with im have as_3:\"g-``(X-T)=X-T\" by auto\n    {\n      fix A\n      assume \"A\\<in>(ExcludedSet(X,T))\"\n      then have \"A=X\\<or>A\\<inter>T=0\" \"A\\<subseteq>X\" unfolding ExcludedSet_def by auto\n      then have \"A\\<subseteq>X-T\\<or>A=X\" by auto moreover\n      {\n        assume \"A=X\"\n        with as(1) have \"g``A=X\" using surj_range_image_domain unfolding bij_def by auto\n      }\n      moreover\n      {\n        assume \"A\\<subseteq>X-T\"\n        then have \"g``A\\<subseteq>g``(X-T)\" using func1_1_L8 by auto\n        then have \"g``A\\<subseteq>(X-T)\" using as(2)  by auto\n      }\n      ultimately have \"g``A\\<subseteq>(X-T) \\<or> g``A=X\" by auto\n      then have \"g``A\\<in>(ExcludedSet(X,T))\" unfolding ExcludedSet_def by auto\n    }\n    then have \"\\<forall>A\\<in>(ExcludedSet(X,T)). g``A\\<in>(ExcludedSet(X,T))\" by auto moreover\n    {\n      fix A assume \"A\\<in>(ExcludedSet(X,T))\"\n      then have \"A=X\\<or>A\\<inter>T=0\" \"A\\<subseteq>X\" unfolding ExcludedSet_def by auto\n      then have \"A\\<subseteq>X-T\\<or>A=X\" by auto moreover\n      {\n        assume \"A=X\"\n        with as(1) have \"g-``A=X\" using func1_1_L4 unfolding bij_def inj_def by auto\n      }\n      moreover\n      {\n        assume \"A\\<subseteq>X-T\"\n        then have \"g-``A\\<subseteq>g-``(X-T)\" using func1_1_L8 by auto\n        then have \"g-``A\\<subseteq>(X-T)\" using as_3 by auto\n      }\n      ultimately have \"g-``A\\<subseteq>(X-T) \\<or> g-``A=X\" by auto\n      then have \"g-``A\\<in>(ExcludedSet(X,T))\" unfolding ExcludedSet_def by auto\n    }\n    then have \"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),g)\" unfolding IsContinuous_def by auto moreover\n    note as(1) ultimately have \"IsAhomeomorphism(ExcludedSet(X,T),ExcludedSet(X,T),g)\" \n      using union_excludedset bij_cont_open_homeo by auto\n    with as(1) have \"g\\<in>HomeoG(ExcludedSet(X,T))\" unfolding bij_def inj_def HomeoG_def using union_excludedset by auto\n  }\n  then show \"{f \\<in> bij(X, X) . f `` (X - T) = X - T} \\<subseteq> HomeoG(ExcludedSet(X,T))\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2277
    },
    "2054": {
        "type": "lemma",
        "text": "text\\<open>We now give some lemmas that will help us compute \\<open>HomeoG(IncludedSet(X,T))\\<close>.\\<close>\n",
        "assumes": "assumes \"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),f)\" \"f:X\\<rightarrow>X\" \"T\\<subseteq>X\"\n  ",
        "using": [
            "union_includedset",
            "includedset_is_topology",
            "two_top_spaces0_def",
            "closed_sets_includedset",
            "assms",
            "two_top_spaces0.TopZF_2_1_L1",
            "assms(1)",
            "two",
            "assms(1,3)"
        ],
        "statement": "lemma cont_in_cont_ex:\n  assumes \"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),f)\" \"f:X\\<rightarrow>X\" \"T\\<subseteq>X\"\n  shows \"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),f)\"\n",
        "proof": "proof-\n  from assms(2,3) have two:\"two_top_spaces0(IncludedSet(X,T),IncludedSet(X,T),f)\" using union_includedset includedset_is_topology \n    unfolding two_top_spaces0_def by auto\n  {\n    fix A assume \"A\\<in>(ExcludedSet(X,T))\"\n    then have \"A\\<inter>T=0 \\<or> A=X\"\"A\\<subseteq>X\" unfolding ExcludedSet_def by auto\n    then have \"A{is closed in}(IncludedSet(X,T))\" using closed_sets_includedset assms by auto\n    then have \"f-``A{is closed in}(IncludedSet(X,T))\" using two_top_spaces0.TopZF_2_1_L1 assms(1)\n      two assms includedset_is_topology by auto\n    then have \"(f-``A)\\<inter>T=0 \\<or> f-``A=X\"\"f-``A\\<subseteq>X\" using closed_sets_includedset assms(1,3) by auto\n    then have \"f-``A\\<in>(ExcludedSet(X,T))\" unfolding ExcludedSet_def by auto\n  }\n  then show \"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),f)\" unfolding IsContinuous_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2278
    },
    "2055": {
        "type": "lemma",
        "text": "text\\<open>The previous lemmas imply that the group of homeomorphisms of the included set topology\nis the same as the one of the excluded set topology.\\<close>\n",
        "assumes": "assumes \"T\\<subseteq>X\"\n  ",
        "using": [
            "union_includedset",
            "assms",
            "cont_in_cont_ex",
            "fun",
            "bij_converse_bij",
            "bij",
            "bij_def",
            "inj_def",
            "union_excludedset",
            "cont_ex_cont_in",
            "homeo_excluded"
        ],
        "statement": "lemma homeo_included:\n  assumes \"T\\<subseteq>X\"\n  shows \"HomeoG(IncludedSet(X,T))={f \\<in> bij(X, X) . f `` (X - T) = X - T}\"\n",
        "proof": "proof-\n  {\n    fix f assume \"f\\<in>HomeoG(IncludedSet(X,T))\"\n    then have hom:\"IsAhomeomorphism(IncludedSet(X,T),IncludedSet(X,T),f)\" and fun:\"f\\<in>X\\<rightarrow>X\" and\n      bij:\"f\\<in>bij(X,X)\" unfolding HomeoG_def IsAhomeomorphism_def using union_includedset assms by auto\n    then have cont:\"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),f)\" unfolding IsAhomeomorphism_def by auto\n    then have \"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),f)\" using cont_in_cont_ex fun assms by auto moreover\n    {\n      from hom have cont1:\"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),converse(f))\" unfolding IsAhomeomorphism_def by auto moreover\n      have \"converse(f):X\\<rightarrow>X\" using bij_converse_bij bij unfolding bij_def inj_def by auto moreover\n      note assms ultimately \n      have \"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),converse(f))\" using cont_in_cont_ex assms by auto\n    }\n    then have \"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),converse(f))\" by auto\n    moreover note bij ultimately\n    have \"IsAhomeomorphism(ExcludedSet(X,T),ExcludedSet(X,T),f)\" unfolding IsAhomeomorphism_def\n      using union_excludedset by auto\n    with fun have \"f\\<in>HomeoG(ExcludedSet(X,T))\" unfolding HomeoG_def using union_excludedset by auto\n  }\n  then have \"HomeoG(IncludedSet(X,T))\\<subseteq>HomeoG(ExcludedSet(X,T))\" by auto moreover\n  {\n    fix f assume \"f\\<in>HomeoG(ExcludedSet(X,T))\"\n    then have hom:\"IsAhomeomorphism(ExcludedSet(X,T),ExcludedSet(X,T),f)\" and fun:\"f\\<in>X\\<rightarrow>X\" and\n      bij:\"f\\<in>bij(X,X)\" unfolding HomeoG_def IsAhomeomorphism_def using union_excludedset assms by auto\n    then have cont:\"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),f)\" unfolding IsAhomeomorphism_def by auto\n    then have \"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),f)\" using cont_ex_cont_in fun assms by auto moreover\n    {\n      from hom have cont1:\"IsContinuous(ExcludedSet(X,T),ExcludedSet(X,T),converse(f))\" unfolding IsAhomeomorphism_def by auto moreover\n      have \"converse(f):X\\<rightarrow>X\" using bij_converse_bij bij unfolding bij_def inj_def by auto moreover\n      note assms ultimately \n      have \"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),converse(f))\" using cont_ex_cont_in assms by auto\n    }\n    then have \"IsContinuous(IncludedSet(X,T),IncludedSet(X,T),converse(f))\" by auto\n    moreover note bij ultimately\n    have \"IsAhomeomorphism(IncludedSet(X,T),IncludedSet(X,T),f)\" unfolding IsAhomeomorphism_def\n      using union_includedset assms by auto\n    with fun have \"f\\<in>HomeoG(IncludedSet(X,T))\" unfolding HomeoG_def using union_includedset assms by auto\n  }\n  then have \"HomeoG(ExcludedSet(X,T))\\<subseteq>HomeoG(IncludedSet(X,T))\" by auto ultimately\n  show ?thesis using homeo_excluded by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2279
    },
    "2056": {
        "type": "lemma",
        "text": "text\\<open>Finally, let's compute part of the group of homeomorphisms of an order topology.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\"\"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  ",
        "using": [
            "bij",
            "bij_def",
            "inj_def",
            "union_ordtopology[OF",
            "assms]",
            "Ordtopology_is_a_topology(1)[OF",
            "assms(1)]",
            "A(2,1)",
            "ord",
            "AA(1)",
            "AA(2,3)",
            "apply_type",
            "surj_def",
            "s(2)",
            "y(2,3)",
            "y(4,5)",
            "s",
            "func_imagedef",
            "A",
            "AA(2)",
            "y(2)",
            "y(3)",
            "rray",
            "apply",
            "blast",
            "prefer",
            "2",
            "lray",
            "inter",
            "auto",
            "proof-",
            "fix",
            "xa",
            "y",
            "assume",
            "\"xa\\<in>X\"\"y\\<in>X\"",
            "then",
            "have",
            "\"f`xa\\<in>X\"\"f`y\\<in>X\"",
            "base_sets_open[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "assms(1)]]",
            "two_top_spaces0.base_image_open[OF",
            "twoSpac",
            "inj_vimage_image",
            "two_top_spaces0.Top_ZF_2_1_L5[OF",
            "bij_cont_open_homeo"
        ],
        "statement": "lemma homeo_order:\n  assumes \"IsLinOrder(X,r)\"\"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  shows \"ord_iso(X,r,X,r)\\<subseteq>HomeoG(OrdTopology X r)\"\n",
        "proof": "proof\n  fix f assume \"f\\<in>ord_iso(X,r,X,r)\"\n  then have bij:\"f\\<in>bij(X,X)\" and ord:\"\\<forall>x\\<in>X. \\<forall>y\\<in>X. \\<langle>x, y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>f ` x, f ` y\\<rangle> \\<in> r\"\n    unfolding ord_iso_def by auto\n  have twoSpac:\"two_top_spaces0(OrdTopology X r,OrdTopology X r,f)\" unfolding two_top_spaces0_def\n    using bij unfolding bij_def inj_def using union_ordtopology[OF assms] Ordtopology_is_a_topology(1)[OF assms(1)]\n    by auto\n  {\n    fix c d assume A:\"c\\<in>X\"\"d\\<in>X\"\n    {\n      fix x assume AA:\"x\\<in>X\"\"x\\<noteq>c\"\"x\\<noteq>d\"\"\\<langle>c,x\\<rangle>\\<in>r\"\"\\<langle>x,d\\<rangle>\\<in>r\"\n      then have \"\\<langle>f`c,f`x\\<rangle>\\<in>r\"\"\\<langle>f`x,f`d\\<rangle>\\<in>r\" using A(2,1) ord by auto moreover\n      {\n        assume \"f`x=f`c \\<or> f`x=f`d\"\n        then have \"x=c\\<or>x=d\" using bij unfolding bij_def inj_def using A(2,1) AA(1) by auto\n        then have \"False\" using AA(2,3) by auto\n      }\n      then have \"f`x\\<noteq>f`c\"\"f`x\\<noteq>f`d\" by auto moreover\n      have \"f`x\\<in>X\" using bij unfolding bij_def inj_def using apply_type AA(1) by auto\n      ultimately have \"f`x\\<in>IntervalX(X,r,f`c,f`d)\" unfolding IntervalX_def Interval_def by auto\n    }\n    then have \"{f`x. x\\<in>IntervalX(X,r,c,d)}\\<subseteq>IntervalX(X,r,f`c,f`d)\" unfolding IntervalX_def Interval_def by auto\n    moreover\n    {\n      fix y assume \"y\\<in>IntervalX(X,r,f`c,f`d)\"\n      then have y:\"y\\<in>X\"\"y\\<noteq>f`c\"\"y\\<noteq>f`d\"\"\\<langle>f`c,y\\<rangle>\\<in>r\"\"\\<langle>y,f`d\\<rangle>\\<in>r\" unfolding IntervalX_def Interval_def by auto\n      then obtain s where s:\"s\\<in>X\"\"y=f`s\" using bij unfolding bij_def surj_def by auto\n      {\n        assume \"s=c\\<or>s=d\"\n        then have \"f`s=f`c\\<or>f`s=f`d\" by auto\n        then have \"False\" using s(2) y(2,3) by auto\n      }\n      then have \"s\\<noteq>c\"\"s\\<noteq>d\" by auto moreover\n      have \"\\<langle>c,s\\<rangle>\\<in>r\"\"\\<langle>s,d\\<rangle>\\<in>r\" using y(4,5) s ord A(2,1) by auto moreover\n      note s(1) ultimately have \"s\\<in>IntervalX(X,r,c,d)\" unfolding IntervalX_def Interval_def by auto\n      then have \"y\\<in>{f`x. x\\<in>IntervalX(X,r,c,d)}\" using s(2) by auto\n    }\n    ultimately have \"{f`x. x\\<in>IntervalX(X,r,c,d)}=IntervalX(X,r,f`c,f`d)\" by auto moreover\n    have \"IntervalX(X,r,c,d)\\<subseteq>X\" unfolding IntervalX_def by auto moreover\n    have \"f:X\\<rightarrow>X\" using bij unfolding bij_def surj_def by auto ultimately\n    have \"f``IntervalX(X,r,c,d)=IntervalX(X,r,f`c,f`d)\" using func_imagedef by auto\n  }\n  then have inter:\"\\<forall>c\\<in>X. \\<forall>d\\<in>X. f``IntervalX(X,r,c,d)=IntervalX(X,r,f`c,f`d) \\<and> f`c\\<in>X \\<and> f`d\\<in>X\" using bij \n    unfolding bij_def inj_def by auto\n  {\n    fix c assume A:\"c\\<in>X\"\n    {\n      fix x assume AA:\"x\\<in>X\"\"x\\<noteq>c\"\"\\<langle>c,x\\<rangle>\\<in>r\"\n      then have \"\\<langle>f`c,f`x\\<rangle>\\<in>r\" using A ord by auto moreover\n      {\n        assume \"f`x=f`c\"\n        then have \"x=c\" using bij unfolding bij_def inj_def using A AA(1) by auto\n        then have \"False\" using AA(2) by auto\n      }\n      then have \"f`x\\<noteq>f`c\" by auto moreover\n      have \"f`x\\<in>X\" using bij unfolding bij_def inj_def using apply_type AA(1) by auto\n      ultimately have \"f`x\\<in>RightRayX(X,r,f`c)\" unfolding RightRayX_def by auto\n    }\n    then have \"{f`x. x\\<in>RightRayX(X,r,c)}\\<subseteq>RightRayX(X,r,f`c)\" unfolding RightRayX_def by auto\n    moreover\n    {\n      fix y assume \"y\\<in>RightRayX(X,r,f`c)\"\n      then have y:\"y\\<in>X\"\"y\\<noteq>f`c\"\"\\<langle>f`c,y\\<rangle>\\<in>r\" unfolding RightRayX_def by auto\n      then obtain s where s:\"s\\<in>X\"\"y=f`s\" using bij unfolding bij_def surj_def by auto\n      {\n        assume \"s=c\"\n        then have \"f`s=f`c\" by auto\n        then have \"False\" using s(2) y(2) by auto\n      }\n      then have \"s\\<noteq>c\" by auto moreover\n      have \"\\<langle>c,s\\<rangle>\\<in>r\" using y(3) s ord A by auto moreover\n      note s(1) ultimately have \"s\\<in>RightRayX(X,r,c)\" unfolding RightRayX_def by auto\n      then have \"y\\<in>{f`x. x\\<in>RightRayX(X,r,c)}\" using s(2) by auto\n    }\n    ultimately have \"{f`x. x\\<in>RightRayX(X,r,c)}=RightRayX(X,r,f`c)\" by auto moreover\n    have \"RightRayX(X,r,c)\\<subseteq>X\" unfolding RightRayX_def by auto moreover\n    have \"f:X\\<rightarrow>X\" using bij unfolding bij_def surj_def by auto ultimately\n    have \"f``RightRayX(X,r,c)=RightRayX(X,r,f`c)\" using func_imagedef by auto\n  }\n  then have rray:\"\\<forall>c\\<in>X. f``RightRayX(X,r,c)=RightRayX(X,r,f`c) \\<and> f`c\\<in>X\" using bij \n    unfolding bij_def inj_def by auto\n  {\n    fix c assume A:\"c\\<in>X\"\n    {\n      fix x assume AA:\"x\\<in>X\"\"x\\<noteq>c\"\"\\<langle>x,c\\<rangle>\\<in>r\"\n      then have \"\\<langle>f`x,f`c\\<rangle>\\<in>r\" using A ord by auto moreover\n      {\n        assume \"f`x=f`c\"\n        then have \"x=c\" using bij unfolding bij_def inj_def using A AA(1) by auto\n        then have \"False\" using AA(2) by auto\n      }\n      then have \"f`x\\<noteq>f`c\" by auto moreover\n      have \"f`x\\<in>X\" using bij unfolding bij_def inj_def using apply_type AA(1) by auto\n      ultimately have \"f`x\\<in>LeftRayX(X,r,f`c)\" unfolding LeftRayX_def by auto\n    }\n    then have \"{f`x. x\\<in>LeftRayX(X,r,c)}\\<subseteq>LeftRayX(X,r,f`c)\" unfolding LeftRayX_def by auto\n    moreover\n    {\n      fix y assume \"y\\<in>LeftRayX(X,r,f`c)\"\n      then have y:\"y\\<in>X\"\"y\\<noteq>f`c\"\"\\<langle>y,f`c\\<rangle>\\<in>r\" unfolding LeftRayX_def by auto\n      then obtain s where s:\"s\\<in>X\"\"y=f`s\" using bij unfolding bij_def surj_def by auto\n      {\n        assume \"s=c\"\n        then have \"f`s=f`c\" by auto\n        then have \"False\" using s(2) y(2) by auto\n      }\n      then have \"s\\<noteq>c\" by auto moreover\n      have \"\\<langle>s,c\\<rangle>\\<in>r\" using y(3) s ord A by auto moreover\n      note s(1) ultimately have \"s\\<in>LeftRayX(X,r,c)\" unfolding LeftRayX_def by auto\n      then have \"y\\<in>{f`x. x\\<in>LeftRayX(X,r,c)}\" using s(2) by auto\n    }\n    ultimately have \"{f`x. x\\<in>LeftRayX(X,r,c)}=LeftRayX(X,r,f`c)\" by auto moreover\n    have \"LeftRayX(X,r,c)\\<subseteq>X\" unfolding LeftRayX_def by auto moreover\n    have \"f:X\\<rightarrow>X\" using bij unfolding bij_def surj_def by auto ultimately\n    have \"f``LeftRayX(X,r,c)=LeftRayX(X,r,f`c)\" using func_imagedef by auto\n  }\n  then have lray:\"\\<forall>c\\<in>X. f``LeftRayX(X,r,c)=LeftRayX(X,r,f`c)\\<and>f`c\\<in>X\" using bij \n    unfolding bij_def inj_def by auto\n  have r1:\"\\<forall>U\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union>\n    {RightRayX(X, r, b) . b \\<in> X}. f``U\\<in>({IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union>\n    {RightRayX(X, r, b) . b \\<in> X})\" apply safe prefer 3 using rray apply blast prefer 2 using lray apply blast\n    using inter apply auto\n    proof-\n     fix xa y assume \"xa\\<in>X\"\"y\\<in>X\"\n     then have \"f`xa\\<in>X\"\"f`y\\<in>X\" using bij unfolding bij_def inj_def by auto\n     then show \"\\<exists>x\\<in>X. \\<exists>ya\\<in>X. IntervalX(X, r, f ` xa, f ` y) = IntervalX(X, r, x, ya)\" by auto\n    qed\n  have r2:\"{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X}\\<subseteq>(OrdTopology X r)\"\n    using base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by blast\n  {\n    fix U assume \"U\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X}\"\n    with r1 have \"f``U\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X}\"\n      by auto\n    with r2 have \"f``U\\<in>(OrdTopology X r)\" by blast\n  }\n  then have \"\\<forall>U\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union>\n    {RightRayX(X, r, b) . b \\<in> X}. f``U\\<in>(OrdTopology X r)\" by blast\n  then have f_open:\"\\<forall>U\\<in>(OrdTopology X r). f``U\\<in>(OrdTopology X r)\" using two_top_spaces0.base_image_open[OF twoSpac Ordtopology_is_a_topology(2)[OF assms(1)]]\n    by auto\n  {\n    fix c d assume A:\"c\\<in>X\"\"d\\<in>X\"\n    then obtain cc dd where pre:\"f`cc=c\"\"f`dd=d\"\"cc\\<in>X\"\"dd\\<in>X\" using bij unfolding bij_def surj_def by blast\n    with inter have \"f `` IntervalX(X, r, cc, dd) = IntervalX(X, r,  c,  d)\" by auto\n    then have \"f-``(f``IntervalX(X, r, cc, dd)) = f-``(IntervalX(X, r,  c,  d))\" by auto \n    moreover\n    have \"IntervalX(X, r, cc, dd)\\<subseteq>X\" unfolding IntervalX_def by auto moreover\n    have \"f\\<in>inj(X,X)\" using bij unfolding bij_def by auto ultimately\n    have \"IntervalX(X, r, cc, dd)=f-``IntervalX(X, r,  c,  d)\" using inj_vimage_image by auto\n    moreover\n    from pre(3,4) have \"IntervalX(X, r, cc, dd)\\<in>{IntervalX(X,r,e1,e2). \\<langle>e1,e2\\<rangle>\\<in>X\\<times>X}\" by auto\n    ultimately have \"f-``IntervalX(X, r,  c,  d)\\<in>(OrdTopology X r)\" using\n      base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n  }\n  then have inter:\"\\<forall>c\\<in>X. \\<forall>d\\<in>X. f-``IntervalX(X, r,  c,  d)\\<in>(OrdTopology X r)\" by auto\n  {\n    fix c assume A:\"c\\<in>X\"\n    then obtain cc where pre:\"f`cc=c\"\"cc\\<in>X\" using bij unfolding bij_def surj_def by blast\n    with rray have \"f `` RightRayX(X, r, cc) = RightRayX(X, r,  c)\" by auto\n    then have \"f-``(f``RightRayX(X, r, cc)) = f-``(RightRayX(X, r,  c))\" by auto \n    moreover\n    have \"RightRayX(X, r, cc)\\<subseteq>X\" unfolding RightRayX_def by auto moreover\n    have \"f\\<in>inj(X,X)\" using bij unfolding bij_def by auto ultimately\n    have \"RightRayX(X, r, cc)=f-``RightRayX(X, r,  c)\" using inj_vimage_image by auto\n    moreover\n    from pre(2) have \"RightRayX(X, r, cc)\\<in>{RightRayX(X,r,e2). e2\\<in>X}\" by auto\n    ultimately have \"f-``RightRayX(X, r,  c)\\<in>(OrdTopology X r)\" using\n      base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n  }\n  then have rray:\"\\<forall>c\\<in>X. f-``RightRayX(X, r,  c)\\<in>(OrdTopology X r)\" by auto\n  {\n    fix c assume A:\"c\\<in>X\"\n    then obtain cc where pre:\"f`cc=c\"\"cc\\<in>X\" using bij unfolding bij_def surj_def by blast\n    with lray have \"f `` LeftRayX(X, r, cc) = LeftRayX(X, r,  c)\" by auto\n    then have \"f-``(f``LeftRayX(X, r, cc)) = f-``(LeftRayX(X, r,  c))\" by auto \n    moreover\n    have \"LeftRayX(X, r, cc)\\<subseteq>X\" unfolding LeftRayX_def by auto moreover\n    have \"f\\<in>inj(X,X)\" using bij unfolding bij_def by auto ultimately\n    have \"LeftRayX(X, r, cc)=f-``LeftRayX(X, r,  c)\" using inj_vimage_image by auto\n    moreover\n    from pre(2) have \"LeftRayX(X, r, cc)\\<in>{LeftRayX(X,r,e2). e2\\<in>X}\" by auto\n    ultimately have \"f-``LeftRayX(X, r,  c)\\<in>(OrdTopology X r)\" using\n      base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n  }\n  then have lray:\"\\<forall>c\\<in>X. f-``LeftRayX(X, r,  c)\\<in>(OrdTopology X r)\" by auto\n  {\n    fix U assume \"U\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X}\"\n    with lray inter rray have \"f-``U\\<in>(OrdTopology X r)\" by auto\n  }\n  then have \"\\<forall>U\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union> {RightRayX(X, r, b) . b \\<in> X}.\n    f-``U\\<in>(OrdTopology X r)\" by blast\n  then have fcont:\"IsContinuous(OrdTopology X r,OrdTopology X r,f)\" using two_top_spaces0.Top_ZF_2_1_L5[OF twoSpac\n    Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n  from fcont f_open bij have \"IsAhomeomorphism(OrdTopology X r,OrdTopology X r,f)\" using bij_cont_open_homeo\n    union_ordtopology[OF assms] by auto\n  then show \"f\\<in>HomeoG(OrdTopology X r)\" unfolding HomeoG_def using bij union_ordtopology[OF assms]\n    unfolding bij_def inj_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2280
    },
    "2057": {
        "type": "theorem",
        "text": "text\\<open>The continuous image of a connected space is connected.\\<close>\n",
        "assumes": "assumes \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"f\\<in>surj(X\\<^sub>1,X\\<^sub>2)\" \"\\<tau>\\<^sub>1{is connected}\"\n  ",
        "using": [
            "TopZF_2_1_L1",
            "assms(3)",
            "IsConnected_def",
            "func1_1_L13",
            "Uop",
            "surj_image_vimage",
            "assms(2)",
            "surj_range_image_domain",
            "func1_1_L15",
            "surj_def"
        ],
        "statement": "theorem (in two_top_spaces0) cont_image_conn:\n  assumes \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"f\\<in>surj(X\\<^sub>1,X\\<^sub>2)\" \"\\<tau>\\<^sub>1{is connected}\"\n  shows \"\\<tau>\\<^sub>2{is connected}\"\n",
        "proof": "proof-\n  {\n    fix U\n    assume Uop:\"U\\<in>\\<tau>\\<^sub>2\" and Ucl:\"U{is closed in}\\<tau>\\<^sub>2\"\n    from Uop assms(1) have \"f-``U\\<in>\\<tau>\\<^sub>1\" unfolding IsContinuous_def by auto moreover\n    from Ucl assms(1) have  \"f-``U{is closed in}\\<tau>\\<^sub>1\" using TopZF_2_1_L1 by auto ultimately\n    have disj:\"f-``U=0 \\<or> f-``U=\\<Union>\\<tau>\\<^sub>1\" using assms(3) unfolding IsConnected_def by auto moreover\n    {\n      assume as:\"f-``U\\<noteq>0\"\n      then have \"U\\<noteq>0\" using func1_1_L13 by auto\n      from as disj have \"f-``U=\\<Union>\\<tau>\\<^sub>1\" by auto\n      then have \"f``(f-``U)=f``(\\<Union>\\<tau>\\<^sub>1)\" by auto moreover\n      have \"U\\<subseteq>\\<Union>\\<tau>\\<^sub>2\" using Uop by blast ultimately\n      have \"U=f``(\\<Union>\\<tau>\\<^sub>1)\" using surj_image_vimage assms(2) Uop by force\n      then have \"\\<Union>\\<tau>\\<^sub>2=U\" using surj_range_image_domain assms(2) by auto\n    }\n    moreover\n    {\n      assume as:\"U\\<noteq>0\"\n      from Uop have s:\"U\\<subseteq>\\<Union>\\<tau>\\<^sub>2\" by auto\n      with as obtain u where uU:\"u\\<in>U\" by auto\n      with s have \"u\\<in>\\<Union>\\<tau>\\<^sub>2\" by auto\n      with assms(2) obtain w where \"f`w=u\"\"w\\<in>\\<Union>\\<tau>\\<^sub>1\" unfolding surj_def X1_def X2_def by blast\n      with uU have \"w\\<in>f-``U\" using func1_1_L15 assms(2) unfolding surj_def by auto\n      then have \"f-``U\\<noteq>0\" by auto\n    }\n    ultimately have \"U=0\\<or>U=\\<Union>\\<tau>\\<^sub>2\" by auto\n  }\n  then show ?thesis unfolding IsConnected_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2281
    },
    "2058": {
        "type": "theorem",
        "text": "text\\<open>The continuous image of a compact space is compact.\\<close>\n",
        "assumes": "assumes \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"f\\<in>surj(X\\<^sub>1,X\\<^sub>2)\" \"X\\<^sub>1{is compact of cardinal}K{in}\\<tau>\\<^sub>1\"\n  ",
        "using": [
            "assms(1)",
            "IsContinuous_def",
            "image_UN",
            "func1_1_L4",
            "assms(2)",
            "surj_def",
            "as(2)",
            "surj_image_vimage",
            "FN",
            "apply_equality",
            "R_def",
            "assms(3)",
            "lesspoll_imp_lepoll",
            "IsCompactOfCard_def",
            "Card_is_Ord",
            "surj_fun_inv_2",
            "surj",
            "fin",
            "lesspoll_trans1",
            "cov",
            "surj_range_image_domain"
        ],
        "statement": "theorem (in two_top_spaces0) cont_image_com:\n  assumes \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"f\\<in>surj(X\\<^sub>1,X\\<^sub>2)\" \"X\\<^sub>1{is compact of cardinal}K{in}\\<tau>\\<^sub>1\"\n  shows \"X\\<^sub>2{is compact of cardinal}K{in}\\<tau>\\<^sub>2\"\n",
        "proof": "proof-\n  have \"X\\<^sub>2\\<subseteq>\\<Union>\\<tau>\\<^sub>2\" by auto moreover\n  {\n    fix U assume as:\"X\\<^sub>2\\<subseteq>\\<Union>U\" \"U\\<subseteq>\\<tau>\\<^sub>2\"\n    then have P:\"{f-``V. V\\<in>U}\\<subseteq>\\<tau>\\<^sub>1\" using assms(1) unfolding IsContinuous_def by auto\n    from as(1) have \"f-``X\\<^sub>2 \\<subseteq> f-``(\\<Union>U)\" by blast\n    then have \"f-``X\\<^sub>2 \\<subseteq> converse(f)``(\\<Union>U)\" unfolding vimage_def by auto moreover\n    have \"converse(f)``(\\<Union>U)=(\\<Union>V\\<in>U. converse(f)``V)\" using image_UN by force ultimately\n    have \"f-``X\\<^sub>2 \\<subseteq> (\\<Union>V\\<in>U. converse(f)``V)\" by auto\n    then have \"f-``X\\<^sub>2 \\<subseteq> (\\<Union>V\\<in>U. f-``V)\" unfolding vimage_def by auto\n    then have \"X\\<^sub>1 \\<subseteq> (\\<Union>V\\<in>U. f-``V)\" using func1_1_L4 assms(2) unfolding surj_def by force\n    then have \"X\\<^sub>1 \\<subseteq> \\<Union>{f-``V. V\\<in>U}\" by auto\n    with P assms(3) have \"\\<exists>N\\<in>Pow({f-``V. V\\<in>U}). X\\<^sub>1 \\<subseteq> \\<Union>N \\<and> N\\<prec>K\" unfolding IsCompactOfCard_def by auto\n    then obtain N where \"N\\<in>Pow({f-``V. V\\<in>U})\" \"X\\<^sub>1 \\<subseteq> \\<Union>N\" \"N\\<prec>K\" by auto\n    then have fin:\"N\\<prec>K\" and sub:\"N\\<subseteq>{f-``V. V\\<in>U}\" and cov:\"X\\<^sub>1 \\<subseteq> \\<Union>N\" unfolding FinPow_def by auto\n    from sub have \"{f``R. R\\<in>N}\\<subseteq>{f``(f-``V). V\\<in>U}\" by auto moreover\n    have \"\\<forall>V\\<in>U. V\\<subseteq>\\<Union>\\<tau>\\<^sub>2\" using as(2) by auto ultimately\n    have \"{f``R. R\\<in>N}\\<subseteq>U\" using surj_image_vimage assms(2) by auto moreover\n    let ?FN=\"{\\<langle>R,f``R\\<rangle>. R\\<in>N}\"\n    have FN:\"?FN:N\\<rightarrow>{f``R. R\\<in>N}\" unfolding Pi_def function_def domain_def by auto\n    {\n      fix S assume \"S\\<in>{f``R. R\\<in>N}\"\n      then obtain R where R_def:\"R\\<in>N\"\"f``R=S\" by auto\n      then have \"\\<langle>R,f``R\\<rangle>\\<in>?FN\" by auto\n      then have \"?FN`R=f``R\" using FN apply_equality by auto\n      then have \"\\<exists>R\\<in>N. ?FN`R=S\" using R_def by auto\n    }\n    then have surj:\"?FN\\<in>surj(N,{f``R. R\\<in>N})\" unfolding surj_def using FN by force\n    from fin have N:\"N\\<lesssim>K\" \"Ord(K)\" using assms(3) lesspoll_imp_lepoll unfolding IsCompactOfCard_def\n      using Card_is_Ord by auto\n    then have \"{f``R. R\\<in>N}\\<lesssim>N\" using surj_fun_inv_2 surj by auto\n    then have \"{f``R. R\\<in>N}\\<prec>K\" using fin lesspoll_trans1 by blast\n    moreover\n    have \"\\<Union>{f``R. R\\<in>N}=f``(\\<Union>N)\" using image_UN by auto\n    then have \"f``X\\<^sub>1 \\<subseteq> \\<Union>{f``R. R\\<in>N}\" using cov by blast\n    then have \"X\\<^sub>2 \\<subseteq> \\<Union>{f``R. R\\<in>N}\" using assms(2) surj_range_image_domain by auto\n    ultimately have \"\\<exists>NN\\<in>Pow(U). X\\<^sub>2 \\<subseteq> \\<Union>NN \\<and> NN\\<prec>K\" by auto\n  }\n  then have \"\\<forall>U\\<in>Pow(\\<tau>\\<^sub>2). X\\<^sub>2 \\<subseteq> \\<Union>U \\<longrightarrow> (\\<exists>NN\\<in>Pow(U). X\\<^sub>2 \\<subseteq> \\<Union>NN \\<and> NN\\<prec>K)\" by auto\n  ultimately show ?thesis using assms(3) unfolding IsCompactOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2282
    },
    "2059": {
        "type": "corollary",
        "text": "text\\<open>As it happends to connected spaces, a continuous function from a compact space\nto an anti-compact space has finite range.\\<close>\n",
        "assumes": "assumes \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"X\\<^sub>1{is compact in}\\<tau>\\<^sub>1\" \"\\<tau>\\<^sub>2{is anti-compact}\" \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"X\\<^sub>1\\<noteq>0\"\n  ",
        "using": [
            "fun_is_surj",
            "func1_1_L5B",
            "assms(4)",
            "restr_image_cont",
            "range_image_domain",
            "sub",
            "surj",
            "surj_def",
            "tau1_is_top",
            "topology0.Top_1_L4",
            "topology0_def",
            "tau2_is_top",
            "two_top_spaces0.cont_image_com",
            "cont",
            "union",
            "assms(2)",
            "Compact_is_card_nat",
            "assms(3)",
            "IsAntiComp_def",
            "antiProperty_def",
            "compact_spectrum",
            "func1_1_L15A"
        ],
        "statement": "corollary (in two_top_spaces0) cont_comp_anti_comp:\n  assumes \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"X\\<^sub>1{is compact in}\\<tau>\\<^sub>1\" \"\\<tau>\\<^sub>2{is anti-compact}\" \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"X\\<^sub>1\\<noteq>0\"\n  shows \"Finite(range(f))\" and \"range(f)\\<noteq>0\"\n",
        "proof": "proof-\n  from assms(4) have surj:\"f\\<in>surj(X\\<^sub>1,range(f))\" using fun_is_surj by auto\n  have sub:\"range(f)\\<subseteq>X\\<^sub>2\" using func1_1_L5B assms(4) by auto\n  from assms(1) have cont:\"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2{restricted to}range(f),f)\" using restr_image_cont range_image_domain\n    assms(4) by auto\n  have union:\"\\<Union>(\\<tau>\\<^sub>2{restricted to}range(f))=range(f)\" unfolding RestrictedTo_def using sub by auto\n  then have \"two_top_spaces0(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2{restricted to}range(f),f)\" unfolding two_top_spaces0_def\n    using surj unfolding surj_def using tau1_is_top topology0.Top_1_L4 unfolding topology0_def using tau2_is_top\n    by auto\n  then have \"range(f){is compact in}(\\<tau>\\<^sub>2{restricted to}range(f))\" using surj two_top_spaces0.cont_image_com cont union \n    assms(2) Compact_is_card_nat by force\n  then have \"range(f){is in the spectrum of}(\\<lambda>T. (\\<Union>T) {is compact in}T)\" using assms(3) sub unfolding IsAntiComp_def antiProperty_def\n    using union by auto\n  then show \"Finite(range(f))\" using compact_spectrum by auto moreover\n  from assms(5) have \"f``X\\<^sub>1\\<noteq>0\" using func1_1_L15A assms(4) by auto\n  then show \"range(f)\\<noteq>0\" using range_image_domain assms(4) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_8"
        ],
        "source": "IsarMathLib/Topology_ZF_9.thy",
        "id": 2283
    },
    "2060": {
        "type": "definition",
        "text": "text\\<open>The collection of subsets of a set whose complement\nis strictly bounded by a cardinal is a topology given some assumptions\non the cardinal.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n\"CoCardinal(X,T) \\<equiv> {F\\<in>Pow(X). X-F \\<prec> T}\\<union> {0}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2284
    },
    "2061": {
        "type": "lemma",
        "text": "text\\<open>For any set and any infinite cardinal we prove that\n\\<open>CoCardinal(X,Q)\\<close> forms a topology. The proof is done\nwith an infinite cardinal, but it is obvious that the set \\<open>Q\\<close>\ncan be any set equipollent with an infinite cardinal.\nIt is a topology also if the set where the topology is defined is\ntoo small or the cardinal too large; in this case, as it is later proved the topology\nis a discrete topology. And the last case corresponds with \\<open>\"Q=1\"\\<close> which translates\nin the indiscrete topology.\\<close>\n",
        "assumes": "assumes \"InfCard (Q)\"\n  ",
        "using": [
            "CoCardinal_def",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "less_less_imp_un_less",
            "assms",
            "IsATopology_def"
        ],
        "statement": "lemma CoCar_is_topology:\n  assumes \"InfCard (Q)\"\n  shows \"CoCardinal(X,Q) {is a topology}\"\n",
        "proof": "proof -\n  let ?T = \"CoCardinal(X,Q)\"\n  {\n    fix M\n    assume A:\"M\\<in>Pow(?T)\"\n    hence \"M\\<subseteq>?T\" by auto\n    then have \"M\\<subseteq>Pow(X)\" using CoCardinal_def by auto\n    then have \"\\<Union>M\\<in>Pow(X)\" by auto\n    moreover\n    {\n      assume B:\"M=0\"\n      then have \"\\<Union>M\\<in>?T\" using CoCardinal_def by auto\n    }\n    moreover\n    {\n      assume B:\"M={0}\"\n      then have \"\\<Union>M\\<in>?T\" using CoCardinal_def by auto\n    }\n    moreover\n    {\n      assume B:\"M \\<noteq>0\" \"M\\<noteq>{0}\"\n      from B obtain T where C:\"T\\<in>M\" and \"T\\<noteq>0\" by auto\n      with A have D:\"X-T \\<prec> (Q)\" using CoCardinal_def by auto\n      from C have \"X-\\<Union>M\\<subseteq>X-T\" by blast\n      with D have \"X-\\<Union>M\\<prec> (Q)\" using subset_imp_lepoll lesspoll_trans1 by blast\n    }\n    ultimately have \"\\<Union>M\\<in>?T\" using CoCardinal_def by auto\n  }\n  moreover\n  {\n    fix U and V\n    assume \"U\\<in>?T\" and \"V\\<in>?T\"\n    then have A:\"U=0 \\<or> (U\\<in>Pow(X) \\<and> X-U\\<prec> (Q))\" and\n      B:\"V=0 \\<or> (V\\<in>Pow(X) \\<and> X-V\\<prec> (Q))\" using CoCardinal_def by auto\n    hence D:\"U\\<in>Pow(X)\"\"V\\<in>Pow(X)\" by auto\n    have C:\"X-(U \\<inter> V)=(X-U)\\<union>(X-V)\" by fast\n    with A B C have \"U\\<inter>V=0\\<or>(U\\<inter>V\\<in>Pow(X) \\<and> X-(U \\<inter> V)\\<prec> (Q))\" using less_less_imp_un_less assms\n      by auto\n    then have \"U\\<inter>V\\<in>?T\" using CoCardinal_def by auto\n  }\n  ultimately show ?thesis using IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2285
    },
    "2062": {
        "type": "theorem",
        "text": "text\\<open> We can use theorems proven in \\<open>topology0\\<close> context for the co-cardinal topology. \\<close>\n",
        "assumes": "assumes \"InfCard(T)\"\n  ",
        "using": [
            "topology0_def",
            "CoCar_is_topology",
            "assms"
        ],
        "statement": "theorem topology0_CoCardinal:\n  assumes \"InfCard(T)\"\n  shows \"topology0(CoCardinal(X,T))\"\n  ",
        "proof": "using topology0_def CoCar_is_topology assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2286
    },
    "2063": {
        "type": "definition",
        "text": "text\\<open>Cocountable topology in fact consists of the empty set and all cocountable subsets of $X$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  Cocountable (\"CoCountable _\" 90) where\n  \"CoCountable X \\<equiv> CoCardinal(X,csucc(nat))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2287
    },
    "2064": {
        "type": "lemma",
        "text": "text\\<open>The topology is defined in the set $X$\\<close>\n",
        "assumes": "assumes \"T\\<noteq>0\"\n  ",
        "using": [
            "not_0_is_lepoll_1",
            "lepoll_imp_lesspoll_succ",
            "lesspoll_trans2",
            "CoCardinal_def"
        ],
        "statement": "lemma union_cocardinal:\n  assumes \"T\\<noteq>0\"\n  shows \"\\<Union> CoCardinal(X,T) = X\"\n",
        "proof": "proof-\n  have X:\"X-X=0\" by auto\n  have \"0 \\<lesssim> 0\" by auto\n  with assms have \"0\\<prec>1\"\"1 \\<lesssim>T\" using not_0_is_lepoll_1 lepoll_imp_lesspoll_succ by auto\n  then have \"0\\<prec>T\" using lesspoll_trans2  by auto\n  with X have \"(X-X)\\<prec>T\" by auto\n  then have \"X\\<in>CoCardinal(X,T)\" using CoCardinal_def by auto\n  hence \"X\\<subseteq>\\<Union> CoCardinal(X,T)\" by blast\n  then show  \"\\<Union> CoCardinal(X,T)=X\" using CoCardinal_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2288
    },
    "2065": {
        "type": "lemma",
        "text": "text\\<open>The interior of a set is itself if it is open or \\<open>0\\<close> if\nit isn't open.\\<close>\n",
        "assumes": "assumes noC: \"T\\<noteq>0\" and \"A\\<subseteq>X\"\n  ",
        "using": [
            "closed_sets_cocardinal",
            "IsClosed_def",
            "union_cocardinal",
            "Interior_def",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "CoCardinal_def"
        ],
        "statement": "lemma interior_set_cocardinal:\n  assumes noC: \"T\\<noteq>0\" and \"A\\<subseteq>X\"\n  shows \"Interior(A,CoCardinal(X,T))= (if ((X-A) \\<prec> T) then A else 0)\"\n",
        "proof": "proof-\n  from assms(2) have dif_dif:\"X-(X-A)=A\" by blast\n  {\n    assume \"(X-A) \\<prec> T\"\n    then have \"(X-A)\\<in>Pow(X) \\<and> (X-A) \\<prec> T\" by auto\n    with noC have \"(X-A) {is closed in} CoCardinal(X,T)\" using closed_sets_cocardinal\n      by auto\n    with noC have \"X-(X-A)\\<in>CoCardinal(X,T)\" using IsClosed_def union_cocardinal\n      by auto\n    with dif_dif have \"A\\<in>CoCardinal(X,T)\" by auto\n    hence \"A\\<in>{U\\<in>CoCardinal(X,T). U \\<subseteq> A}\" by auto\n    hence a1:\"A\\<subseteq>\\<Union>{U\\<in>CoCardinal(X,T). U \\<subseteq> A}\" by auto\n    have a2:\"\\<Union>{U\\<in>CoCardinal(X,T). U \\<subseteq> A}\\<subseteq>A\" by blast\n    from a1 a2 have \"Interior(A,CoCardinal(X,T))=A\" using Interior_def by auto}\n  moreover\n  {\n    assume as:\"~((X-A) \\<prec> T)\"\n    {\n      fix U\n      assume \"U \\<subseteq>A\"\n      hence \"X-A \\<subseteq> X-U\" by blast\n      then have Q:\"X-A \\<lesssim> X-U\" using subset_imp_lepoll by auto\n      {\n        assume \"X-U\\<prec> T\"\n        with Q have \"X-A\\<prec> T\" using lesspoll_trans1 by auto\n        with as have \"False\"  by auto\n      }\n      hence \"~((X-U) \\<prec> T)\" by auto\n      then have \"U\\<notin>CoCardinal(X,T)\\<or>U=0\" using CoCardinal_def by auto\n    }\n    hence \"{U\\<in>CoCardinal(X,T). U \\<subseteq> A}\\<subseteq>{0}\" by blast\n    then have \"Interior(A,CoCardinal(X,T))=0\" using Interior_def by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2290
    },
    "2066": {
        "type": "lemma",
        "text": "text\\<open> $X$ is a closed set that contains $A$.\nThis lemma is necessary because we cannot\nuse the lemmas proven in the \\<open>topology0\\<close> context since\n\\<open> T\\<noteq>0\"} \\<close> is too weak for\n \\<open>CoCardinal(X,T)\\<close> to be a topology.\\<close>\n",
        "assumes": "assumes \"T\\<noteq>0\" \"A\\<subseteq>X\"\n  ",
        "using": [
            "ClosedCovers_def",
            "union_cocardinal",
            "closed_sets_cocardinal",
            "assms"
        ],
        "statement": "lemma X_closedcov_cocardinal:\n  assumes \"T\\<noteq>0\" \"A\\<subseteq>X\"\n  shows \"X\\<in>ClosedCovers(A,CoCardinal(X,T))\" ",
        "proof": "using ClosedCovers_def\n  using union_cocardinal closed_sets_cocardinal assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2291
    },
    "2067": {
        "type": "lemma",
        "text": "text\\<open>The closure of a set is itself if it is closed or \\<open>X\\<close> if\nit isn't closed.\\<close>\n",
        "assumes": "assumes \"T\\<noteq>0\"\"A\\<subseteq>X\"\n  ",
        "using": [
            "closed_sets_cocardinal",
            "ClosedCovers_def",
            "union_cocardinal",
            "Closure_def",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "X_closedcov_cocardinal"
        ],
        "statement": "lemma closure_set_cocardinal:\n  assumes \"T\\<noteq>0\"\"A\\<subseteq>X\"\n  shows \"Closure(A,CoCardinal(X,T))=(if (A \\<prec> T) then A else X)\"\n",
        "proof": "proof-\n  {\n    assume \"A \\<prec> T\"\n    with assms have \"A {is closed in} CoCardinal(X,T)\" using closed_sets_cocardinal by auto\n    with assms(2) have \"A\\<in> {D \\<in> Pow(X). D {is closed in} CoCardinal(X,T) \\<and> A\\<subseteq>D}\" by auto\n    with assms(1) have S:\"A\\<in>ClosedCovers(A,CoCardinal(X,T))\" using ClosedCovers_def\n      using union_cocardinal by auto\n    hence l1:\"\\<Inter>ClosedCovers(A,CoCardinal(X,T))\\<subseteq>A\" by blast\n    from S have l2:\"A \\<subseteq> \\<Inter>ClosedCovers(A,CoCardinal(X,T))\" \n      unfolding  ClosedCovers_def by auto\n    from l1 l2 have \"Closure(A,CoCardinal(X,T))=A\" using Closure_def\n      by auto\n  }\n  moreover\n  {\n    assume as:\"\\<not> A \\<prec> T\"\n    {\n      fix U\n      assume \"A\\<subseteq>U\"\n      then have Q:\"A \\<lesssim> U\" using subset_imp_lepoll by auto\n      {\n        assume \"U\\<prec> T\"\n        with Q have \"A\\<prec> T\" using lesspoll_trans1 by auto\n        with as have \"False\" by auto\n      }\n      hence \"\\<not> U \\<prec> T\" by auto\n      with assms(1) have \"\\<not>(U {is closed in} CoCardinal(X,T)) \\<or> U=X\" using closed_sets_cocardinal\n      by auto\n    }\n    with assms(1) have \"\\<forall>U\\<in>Pow(X). U{is closed in}CoCardinal(X,T) \\<and> A\\<subseteq>U\\<longrightarrow>U=X\"\n      by auto\n    with assms(1) have \"ClosedCovers(A,CoCardinal(X,T))\\<subseteq>{X}\" \n      using union_cocardinal using ClosedCovers_def by auto\n    with assms have \"ClosedCovers(A,CoCardinal(X,T))={X}\" using X_closedcov_cocardinal\n      by auto\n    then have \" Closure(A,CoCardinal(X,T)) = X \" using Closure_def by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2292
    },
    "2068": {
        "type": "lemma",
        "text": "text\\<open>If the set is too small or the cardinal too large, then the topology\nis just the discrete topology.\\<close>\n",
        "assumes": "assumes \"X\\<prec>T\"\n  ",
        "using": [
            "CoCardinal_def",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "assms"
        ],
        "statement": "lemma discrete_cocardinal:\n  assumes \"X\\<prec>T\"\n  shows \"CoCardinal(X,T) = Pow(X)\"\n",
        "proof": "proof\n  {\n    fix U\n    assume \"U\\<in>CoCardinal(X,T)\"\n    then have \"U \\<in> Pow(X)\" using CoCardinal_def by auto\n  }\n  then show \"CoCardinal(X,T) \\<subseteq> Pow(X)\" by auto\n  {\n    fix U\n    assume A:\"U \\<in> Pow(X)\"\n    then have \"X-U \\<subseteq> X\" by auto\n    then have \"X-U \\<lesssim>X\" using subset_imp_lepoll by auto\n    then have \"X-U\\<prec> T\" using lesspoll_trans1 assms by auto\n    with A have \"U\\<in>CoCardinal(X,T)\" using CoCardinal_def\n      by auto\n  }\n  then show \"Pow(X) \\<subseteq> CoCardinal(X,T)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2294
    },
    "2069": {
        "type": "lemma",
        "text": "text\\<open>If the cardinal is taken as \\<open> T=1 \\<close> then the topology is indiscrete.\\<close>\n",
        "assumes": "",
        "using": [
            "CoCardinal_def",
            "lesspoll_succ_iff",
            "lepoll_0_iff"
        ],
        "statement": "lemma indiscrete_cocardinal:\n  shows \"CoCardinal(X,1) = {0,X}\"\n",
        "proof": "proof\n  {\n    fix Q\n    assume \"Q \\<in> CoCardinal(X,1)\"\n    then have \"Q \\<in> Pow(X)\" and \"Q=0 \\<or> X-Q\\<prec>1\" using CoCardinal_def by auto\n    then have \"Q \\<in> Pow(X)\" and \"Q=0 \\<or> X-Q=0\" using lesspoll_succ_iff lepoll_0_iff by auto\n    then have \"Q=0 \\<or> Q=X\" by blast\n  }\n  then show \"CoCardinal(X,1) \\<subseteq> {0, X}\" by auto\n  have \"0 \\<in> CoCardinal(X,1)\" using CoCardinal_def by auto\n  moreover\n  have \"0\\<prec>1\" and \"X-X=0\" using lesspoll_succ_iff by auto\n  then have \"X\\<in>CoCardinal(X,1)\" using CoCardinal_def by auto\n  ultimately show \"{0, X} \\<subseteq> CoCardinal(X,1) \" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2295
    },
    "2070": {
        "type": "lemma",
        "text": "text\\<open>The topological subspaces of the \\<open>CoCardinal(X,T)\\<close> topology\nare also CoCardinal topologies.\\<close>\n",
        "assumes": "",
        "using": [
            "RestrictedTo_def",
            "CoCardinal_def",
            "subset_imp_lepoll",
            "lesspoll_trans1"
        ],
        "statement": "lemma subspace_cocardinal:\n  shows \"CoCardinal(X,T) {restricted to} Y = CoCardinal(Y\\<inter>X,T)\"\n",
        "proof": "proof\n  {\n    fix M\n    assume \"M \\<in> (CoCardinal(X,T) {restricted to} Y)\"\n    then obtain A where A1:\"A \\<in> CoCardinal(X,T)\" \"M=Y \\<inter> A\" using RestrictedTo_def by auto\n    then have \"M \\<in> Pow(X \\<inter> Y)\" using CoCardinal_def by auto\n    moreover\n    from A1 have \"(Y \\<inter> X)-M = (Y \\<inter> X)-A\" using CoCardinal_def by auto\n    with \\<open>(Y \\<inter> X)-M = (Y \\<inter> X)-A\\<close> have \"(Y \\<inter> X)-M\\<subseteq> X-A\" by auto\n    then have \"(Y \\<inter> X)-M \\<lesssim> X-A\" using subset_imp_lepoll by auto\n    with A1 have \"(Y \\<inter> X)-M \\<prec> T \\<or> M=0\" using lesspoll_trans1 CoCardinal_def\n      by auto\n    ultimately have \"M \\<in> CoCardinal(Y\\<inter>X, T)\" using CoCardinal_def\n      by auto\n  }\n  then show \"CoCardinal(X,T) {restricted to} Y \\<subseteq> CoCardinal(Y\\<inter>X,T)\" by auto\n  {\n    fix M\n    let ?A = \"M \\<union> (X-Y)\"\n    assume A:\"M \\<in> CoCardinal(Y \\<inter> X,T)\"\n    {\n      assume \"M=0\"\n      hence \"M=0 \\<inter> Y\" by auto\n      then have \"M\\<in>CoCardinal(X,T) {restricted to} Y\" using RestrictedTo_def\n        CoCardinal_def by auto\n    }\n    moreover\n    {\n      assume AS:\"M\\<noteq>0\"\n      from A AS have A1:\"(M\\<in>Pow(Y \\<inter> X) \\<and> (Y \\<inter> X)-M\\<prec>T)\" using CoCardinal_def by auto\n      hence \"?A\\<in>Pow(X)\" by blast\n      moreover\n      have \"X-?A=(Y \\<inter> X)-M\" by blast\n      with A1 have \"X-?A\\<prec> T\" by auto\n      ultimately have \"?A\\<in>CoCardinal(X,T)\" using CoCardinal_def by auto\n      then have AT:\"Y \\<inter> ?A\\<in>CoCardinal(X,T) {restricted to} Y\" using RestrictedTo_def\n        by auto\n      have \"Y \\<inter> ?A=Y \\<inter> M\" by blast\n      also from A1 have \"\\<dots>=M\" by auto\n      finally have \"Y \\<inter> ?A=M\" by simp\n      with AT have \"M\\<in>CoCardinal(X,T) {restricted to} Y\"\n        by auto\n    }\n    ultimately have \"M\\<in>CoCardinal(X,T) {restricted to} Y\" by auto\n  }\n  then show \"CoCardinal(Y \\<inter> X, T) \\<subseteq> CoCardinal(X,T) {restricted to} Y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2296
    },
    "2071": {
        "type": "definition",
        "text": "text\\<open> The excluded set topology consists of subsets of $X$ that are disjoint with a fixed set $U$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \"ExcludedSet(X,U) \\<equiv> {F\\<in>Pow(X). U \\<inter> F=0}\\<union> {X}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2297
    },
    "2072": {
        "type": "theorem",
        "text": "text\\<open>For any set; we prove that\n\\<open>ExcludedSet(X,Q)\\<close> forms a topology.\\<close>\n",
        "assumes": "",
        "using": [
            "ExcludedSet_def",
            "IsATopology_def"
        ],
        "statement": "theorem excludedset_is_topology:\n  shows \"ExcludedSet(X,Q) {is a topology}\"\n",
        "proof": "proof-\n  {\n    fix M\n    assume \"M \\<in> Pow(ExcludedSet(X,Q))\"\n    then have A:\"M\\<subseteq>{F\\<in>Pow(X). Q \\<inter> F=0}\\<union> {X}\" using ExcludedSet_def by auto\n    hence \"\\<Union>M\\<in>Pow(X)\" by auto\n    moreover\n    {\n      have B:\"Q \\<inter>\\<Union>M=\\<Union>{Q \\<inter>T. T\\<in>M}\" by auto\n      {\n        assume \"X\\<notin>M\"\n        with A have \"M\\<subseteq>{F\\<in>Pow(X). Q \\<inter> F=0}\" by auto\n        with B have \"Q \\<inter> \\<Union>M=0\" by auto\n      }\n      moreover\n      {\n        assume \"X\\<in>M\"\n        with A have \"\\<Union>M=X\" by auto\n      }\n      ultimately have  \"Q \\<inter> \\<Union>M=0 \\<or> \\<Union>M=X\" by auto\n    }\n    ultimately have \"\\<Union>M\\<in>ExcludedSet(X,Q)\" using ExcludedSet_def by auto\n  }\n  moreover\n  {\n    fix U V\n    assume \"U\\<in>ExcludedSet(X,Q)\" \"V\\<in>ExcludedSet(X,Q)\"\n    then have \"U\\<in>Pow(X)\"\"V\\<in>Pow(X)\"\"U=X\\<or> U \\<inter> Q=0\"\"V=X\\<or> V \\<inter> Q=0\" using ExcludedSet_def by auto\n    hence \"U\\<in>Pow(X)\"\"V\\<in>Pow(X)\"\"(U \\<inter> V)=X \\<or> Q\\<inter>(U \\<inter> V)=0\" by auto\n    then have \"(U \\<inter> V)\\<in>ExcludedSet(X,Q)\" using ExcludedSet_def by auto\n  }\n  ultimately show ?thesis using IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2298
    },
    "2073": {
        "type": "theorem",
        "text": "text\\<open>We can use \\<open>topology0\\<close>  when discussing excluded set topology. \\<close>\n",
        "assumes": "",
        "using": [
            "topology0_def",
            "excludedset_is_topology"
        ],
        "statement": "theorem topology0_excludedset:\n  shows \"topology0(ExcludedSet(X,T))\"\n  ",
        "proof": "using topology0_def excludedset_is_topology by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2299
    },
    "2074": {
        "type": "lemma",
        "text": "text\\<open>The topology is defined in the set $X$\\<close>\n",
        "assumes": "",
        "using": [
            "ExcludedSet_def"
        ],
        "statement": "lemma union_excludedset:\n  shows \"\\<Union>ExcludedSet(X,T) = X\"\n",
        "proof": "proof-\n  have \"X \\<in>ExcludedSet(X,T)\" using ExcludedSet_def by auto\n  then show ?thesis using ExcludedSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2301
    },
    "2075": {
        "type": "lemma",
        "text": "text\\<open>The closed sets are those which contain the set \\<open>(X \\<inter> T)\\<close> and \\<open>0\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "ExcludedSet_def",
            "IsClosed_def",
            "union_excludedset"
        ],
        "statement": "lemma closed_sets_excludedset:\n  shows \"D {is closed in}ExcludedSet(X,T) \\<longleftrightarrow> (D\\<in>Pow(X) \\<and> (X \\<inter> T) \\<subseteq> D) \\<or> D=0\"\n",
        "proof": "proof-\n  {\n    fix x\n    assume A:\"D \\<subseteq> X\" \"X-D \\<in>ExcludedSet(X,T)\" \"D\\<noteq>0\" \"x\\<in>T\" \"x\\<in>X\"\n    from A(1) have B:\"X-(X-D)=D\" by auto\n    from A(2) have \"T\\<inter>(X-D)=0\\<or> X-D=X\" using ExcludedSet_def by auto\n    hence \"T\\<inter>(X-D)=0\\<or> X-(X-D)=X-X\" by auto\n    with B have \"T\\<inter>(X-D)=0\\<or> D=X-X\" by auto\n    hence \"T\\<inter>(X-D)=0\\<or> D=0\" by auto\n    with A(3) have \"T\\<inter>(X-D)=0\" by auto\n    with A(4) have \"x\\<notin>X-D\" by auto\n    with A(5) have \"x\\<in>D\" by auto\n  }\n  moreover\n  {\n    assume A:\"X\\<inter>T\\<subseteq>D\" \"D\\<subseteq>X\"\n    from A(1) have \"X-D\\<subseteq>X-(X\\<inter>T)\" by auto\n    also have \"\\<dots> = X-T\" by auto\n    finally have \"T\\<inter>(X-D) = 0\" by auto\n    moreover\n    have \"X-D \\<in> Pow(X)\" by auto\n    ultimately have \"X-D \\<in>ExcludedSet(X,T)\" using ExcludedSet_def by auto\n  }\n  ultimately show ?thesis using IsClosed_def union_excludedset ExcludedSet_def \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2302
    },
    "2076": {
        "type": "lemma",
        "text": "text\\<open>The interior of a set is itself if it is \\<open>X\\<close> or the difference with the set \\<open>T\\<close>\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\"\n  ",
        "using": [
            "ExcludedSet_def",
            "Interior_def",
            "union_excludedset",
            "topology0.Top_2_L3",
            "topology0_excludedset"
        ],
        "statement": "lemma interior_set_excludedset:\n  assumes \"A\\<subseteq>X\"\n  shows \"Interior(A,ExcludedSet(X,T)) = (if A=X then X else A-T)\"\n",
        "proof": "proof-\n  {\n    assume A:\"A\\<noteq>X\"\n    from assms have \"A-T \\<in>ExcludedSet(X,T)\" using ExcludedSet_def by auto\n    then have \"A-T\\<subseteq>Interior(A,ExcludedSet(X,T))\"\n    using Interior_def by auto\n    moreover\n    {\n      fix U\n      assume \"U \\<in>ExcludedSet(X,T)\" \"U\\<subseteq>A\"\n      then have \"T\\<inter>U=0 \\<or> U=X\"\"U\\<subseteq>A\" using ExcludedSet_def by auto\n      with A assms have \"T\\<inter>U=0\"\"U\\<subseteq>A\" by auto\n      then have \"U-T=U\"\"U-T\\<subseteq>A-T\" by auto \n      then have \"U\\<subseteq>A-T\" by auto\n    }\n    then have \"Interior(A,ExcludedSet(X,T))\\<subseteq>A-T\" using Interior_def by auto\n    ultimately have \"Interior(A,ExcludedSet(X,T))=A-T\" by auto\n  }\n  moreover\n  have \"X\\<in>ExcludedSet(X,T)\" using ExcludedSet_def\n  union_excludedset by auto\n  then have \"Interior(X,ExcludedSet(X,T)) = X\" using topology0.Top_2_L3\n  topology0_excludedset by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2303
    },
    "2077": {
        "type": "lemma",
        "text": "text\\<open>The closure of a set is itself if it is \\<open>0\\<close> or\nthe union with \\<open>T\\<close>.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\"\n  ",
        "using": [
            "ClosedCovers_def",
            "closed_sets_excludedset",
            "Closure_def",
            "assms",
            "union_excludedset",
            "topology0.Top_3_L3",
            "topology0_excludedset"
        ],
        "statement": "lemma closure_set_excludedset:\n  assumes \"A\\<subseteq>X\"\n  shows \"Closure(A,ExcludedSet(X,T))=(if A=0 then 0 else A \\<union>(X\\<inter> T))\"\n",
        "proof": "proof-\n  have \"0\\<in>ClosedCovers(0,ExcludedSet(X,T))\" using ClosedCovers_def\n    closed_sets_excludedset by auto\n  then have \"Closure(0,ExcludedSet(X,T))\\<subseteq>0\" using Closure_def by auto\n  hence \"Closure(0,ExcludedSet(X,T))=0\" by blast\n  moreover\n  {\n    assume A:\"A\\<noteq>0\"\n    with assms have \"(A\\<union>(X\\<inter>T)) {is closed in}ExcludedSet(X,T)\" using closed_sets_excludedset  \n      by blast\n    then have \"(A \\<union>(X\\<inter> T))\\<in> {D \\<in> Pow(X). D {is closed in}ExcludedSet(X,T) \\<and> A\\<subseteq>D}\"\n    using assms by auto\n    then have \"(A \\<union>(X\\<inter> T))\\<in>ClosedCovers(A,ExcludedSet(X,T))\" unfolding ClosedCovers_def\n    using union_excludedset by auto\n    then have l1:\"\\<Inter>ClosedCovers(A,ExcludedSet(X,T)) \\<subseteq> (A \\<union>(X\\<inter> T))\" by blast\n    {\n      fix U\n      assume \"U\\<in>ClosedCovers(A,ExcludedSet(X,T))\"\n      then have \"U{is closed in}ExcludedSet(X,T)\" and \"A\\<subseteq>U\" using ClosedCovers_def\n       union_excludedset by auto\n      then have \"U=0\\<or>(X\\<inter>T)\\<subseteq>U\" and \"A\\<subseteq>U\" using closed_sets_excludedset\n       by auto\n      with A have \"(X\\<inter>T)\\<subseteq>U\"\"A\\<subseteq>U\" by auto\n      hence \"(X\\<inter>T)\\<union>A\\<subseteq>U\" by auto\n    }\n    with assms have \"(A \\<union>(X\\<inter> T)) \\<subseteq> \\<Inter>ClosedCovers(A,ExcludedSet(X,T))\" \n      using topology0.Top_3_L3 topology0_excludedset union_excludedset \n      by auto\n    with l1 have \"\\<Inter>ClosedCovers(A,ExcludedSet(X,T)) = (A\\<union>(X\\<inter>T))\" by auto\n    then have \"Closure(A, ExcludedSet(X,T)) = A\\<union>(X\\<inter>T)\" using Closure_def \n      by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2304
    },
    "2078": {
        "type": "lemma",
        "text": "text\\<open>The boundary of a set is \\<open>0\\<close> if $A$ is \\<open>X\\<close> or \\<open>0\\<close>, and \\<open>X\\<inter>T\\<close> in other case. \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\"\n  ",
        "using": [
            "closure_set_excludedset",
            "Boundary_def",
            "union_excludedset",
            "assms"
        ],
        "statement": "lemma boundary_excludedset:\n  assumes \"A\\<subseteq>X\"\n  shows \"Boundary(A,ExcludedSet(X,T)) = (if A=0\\<or>A=X then 0 else X\\<inter>T)\"\n",
        "proof": "proof-\n  {\n    have \"Closure(0,ExcludedSet(X,T))=0\"\"Closure(X - 0,ExcludedSet(X,T))=X\"\n    using closure_set_excludedset by auto\n    then have \"Boundary(0,ExcludedSet(X,T)) = 0\"using Boundary_def using\n      union_excludedset assms by auto\n  }\n  moreover\n  {\n    have \"X-X=0\" by blast\n    then have \"Closure(X,ExcludedSet(X,T)) = X\" and \"Closure(X-X,ExcludedSet(X,T)) = 0\"\n    using closure_set_excludedset by auto\n    then have \"Boundary(X,ExcludedSet(X,T)) = 0\"unfolding Boundary_def using\n      union_excludedset by auto\n  }\n  moreover\n  {\n    assume \"A\\<noteq>0\" and \"A\\<noteq>X\"\n    then have \"X-A\\<noteq>0\" using assms by auto \n    with assms \\<open>A\\<noteq>0\\<close> \\<open>A\\<subseteq>X\\<close> have \"Closure(A,ExcludedSet(X,T)) = A \\<union> (X\\<inter>T)\"\n      using closure_set_excludedset by simp \n    moreover \n    from \\<open>A\\<subseteq>X\\<close> have \"X-A \\<subseteq> X\" by blast\n    with \\<open>X-A\\<noteq>0\\<close> have \"Closure(X-A,ExcludedSet(X,T)) = (X-A) \\<union> (X\\<inter>T)\"\n      using closure_set_excludedset by simp\n    ultimately have \"Boundary(A,ExcludedSet(X,T)) = X\\<inter>T\" \n      using Boundary_def union_excludedset by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2305
    },
    "2079": {
        "type": "lemma",
        "text": "text\\<open>The excluded set topology is equal in the sets \\<open>T\\<close> and \\<open>X\\<inter>T\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma smaller_excludedset:\n  shows \"ExcludedSet(X,T) = ExcludedSet(X,(X\\<inter>T))\"\n",
        "proof": "proof\n  show \"ExcludedSet(X,T) \\<subseteq> ExcludedSet(X, X\\<inter>T)\" and \"ExcludedSet(X, X\\<inter>T) \\<subseteq>ExcludedSet(X,T)\" \n    unfolding ExcludedSet_def by auto \nqed \n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2306
    },
    "2080": {
        "type": "lemma",
        "text": "text\\<open>If the set which is excluded is disjoint with \\<open>X\\<close>,\nthen the topology is discrete.\\<close>\n",
        "assumes": "assumes \"T\\<inter>X=0\"\n  ",
        "using": [
            "smaller_excludedset",
            "ExcludedSet_def"
        ],
        "statement": "lemma empty_excludedset:\n  assumes \"T\\<inter>X=0\"\n  shows \"ExcludedSet(X,T) = Pow(X)\"\n",
        "proof": "proof\n  from assms show \"ExcludedSet(X,T) \\<subseteq> Pow(X)\"  using smaller_excludedset ExcludedSet_def \n    by auto\n  from assms show \"Pow(X) \\<subseteq>ExcludedSet(X,T)\" unfolding ExcludedSet_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2307
    },
    "2081": {
        "type": "lemma",
        "text": "text\\<open>The topological subspaces of the \\<open>ExcludedSet X T\\<close> topology\nare also ExcludedSet topologies.\\<close>\n",
        "assumes": "",
        "using": [
            "A1"
        ],
        "statement": "lemma subspace_excludedset:\n  shows \"ExcludedSet(X,T) {restricted to} Y = ExcludedSet(Y \\<inter> X, T)\"\n",
        "proof": "proof\n  {\n    fix M\n    assume \"M\\<in>(ExcludedSet(X,T) {restricted to} Y)\"\n    then obtain A where A1:\"A:ExcludedSet(X,T)\" \"M=Y \\<inter> A\" unfolding RestrictedTo_def by auto\n    then have \"M\\<in>Pow(X \\<inter> Y)\" unfolding ExcludedSet_def by auto\n    moreover\n    from A1 have \"T\\<inter>M=0\\<or>M=Y\\<inter>X\" unfolding ExcludedSet_def by blast\n    ultimately have \"M \\<in> ExcludedSet(Y \\<inter> X,T)\" unfolding ExcludedSet_def\n      by auto\n  }\n  then show \"ExcludedSet(X,T) {restricted to} Y \\<subseteq> ExcludedSet(Y\\<inter>X,T)\" by auto\n  {\n    fix M\n    let ?A = \"M  \\<union> ((X\\<inter>Y-T)-Y)\"\n    assume A:\"M \\<in> ExcludedSet(Y\\<inter>X,T)\"\n    {\n      assume \"M = Y \\<inter> X\"\n      then have \"M \\<in> ExcludedSet(X,T) {restricted to} Y\" unfolding RestrictedTo_def\n        ExcludedSet_def by auto\n    }\n    moreover\n    {\n      assume AS:\"M\\<noteq>Y \\<inter> X\"\n      from A AS have A1:\"(M\\<in>Pow(Y \\<inter> X) \\<and> T\\<inter>M=0)\" unfolding ExcludedSet_def by auto\n      then have \"?A\\<in>Pow(X)\" by blast\n      moreover\n      have \"T\\<inter>?A=T\\<inter>M\" by blast\n      with A1 have \"T\\<inter>?A=0\" by auto\n      ultimately have \"?A \\<in>ExcludedSet(X,T)\" unfolding ExcludedSet_def by auto\n      then have AT:\"Y \\<inter> ?A \\<in>ExcludedSet(X,T) {restricted to} Y\" unfolding RestrictedTo_def\n        by auto\n      have \"Y \\<inter> ?A=Y \\<inter> M\" by blast\n      also have \"\\<dots>=M\" using A1 by auto\n      finally have \"Y\\<inter>?A = M\" by simp\n      with AT have \"M \\<in>ExcludedSet(X,T) {restricted to} Y\" by auto\n    }\n    ultimately have \"M \\<in>ExcludedSet(X,T) {restricted to} Y\" by auto\n  }\n  then show \"ExcludedSet(Y \\<inter> X,T) \\<subseteq> ExcludedSet(X,T) {restricted to} Y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2308
    },
    "2082": {
        "type": "definition",
        "text": "text\\<open> We define the included set topology as the collection of supersets of some fixed subset\n  of the space $X$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"IncludedSet(X,U) \\<equiv> {F\\<in>Pow(X). U \\<subseteq> F} \\<union> {0}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2309
    },
    "2083": {
        "type": "theorem",
        "text": "text\\<open> In the next theorem we prove that \\<open>IncludedSet X Q\\<close> forms a topology.\\<close>\n",
        "assumes": "",
        "using": [
            "IncludedSet_def",
            "A",
            "IsATopology_def"
        ],
        "statement": "theorem includedset_is_topology:\n  shows \"IncludedSet(X,Q) {is a topology}\"\n",
        "proof": "proof-\n  {\n    fix M\n    assume \"M \\<in> Pow(IncludedSet(X,Q))\"\n    then have A:\"M\\<subseteq>{F\\<in>Pow(X). Q \\<subseteq> F}\\<union> {0}\" using IncludedSet_def by auto\n    then have \"\\<Union>M\\<in>Pow(X)\" by auto\n    moreover\n    have\"Q \\<subseteq>\\<Union>M\\<or> \\<Union>M=0\" using A by blast\n    ultimately have \"\\<Union>M\\<in>IncludedSet(X,Q)\" using IncludedSet_def by auto\n  }\n  moreover\n  {\n    fix U V\n    assume \"U\\<in>IncludedSet(X,Q)\" \"V\\<in>IncludedSet(X,Q)\"\n    then have \"U\\<in>Pow(X)\"\"V\\<in>Pow(X)\"\"U=0\\<or> Q\\<subseteq>U\"\"V=0\\<or> Q\\<subseteq>V\" using IncludedSet_def by auto\n    then have \"U\\<in>Pow(X)\"\"V\\<in>Pow(X)\"\"(U \\<inter> V)=0 \\<or> Q\\<subseteq>(U \\<inter> V)\" by auto\n    then have \"(U \\<inter> V)\\<in>IncludedSet(X,Q)\" using IncludedSet_def by auto\n  }\n  ultimately show ?thesis using IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2310
    },
    "2084": {
        "type": "theorem",
        "text": "text\\<open> We can reference the theorems proven in the \\<open>topology0\\<close> context when discussing\n  the included set topology.\\<close>\n",
        "assumes": "",
        "using": [
            "topology0_def",
            "includedset_is_topology"
        ],
        "statement": "theorem topology0_includedset:\n  shows \"topology0(IncludedSet(X,T))\"\n  ",
        "proof": "using topology0_def includedset_is_topology by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2311
    },
    "2085": {
        "type": "lemma",
        "text": "text\\<open>The topology is defined in the set $X$.\\<close>\n",
        "assumes": "assumes \"T\\<subseteq>X \"\n  ",
        "using": [
            "IncludedSet_def"
        ],
        "statement": "lemma union_includedset:\n  assumes \"T\\<subseteq>X \"\n  shows \"\\<Union>IncludedSet(X,T) = X\"\n",
        "proof": "proof-\n  from assms have \"X \\<in> IncludedSet(X,T)\" using IncludedSet_def by auto\n  then show \"\\<Union>IncludedSet(X,T) = X\" using IncludedSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2313
    },
    "2086": {
        "type": "lemma",
        "text": "text\\<open>The closed sets are those which are disjoint with \\<open>T\\<close>\n and \\<open>X\\<close>.\\<close>\n",
        "assumes": "assumes \"T\\<subseteq>X\"\n  ",
        "using": [
            "IncludedSet_def",
            "IsClosed_def",
            "union_includedset",
            "assms"
        ],
        "statement": "lemma closed_sets_includedset:\n  assumes \"T\\<subseteq>X\"\n  shows \"D {is closed in} IncludedSet(X,T) \\<longleftrightarrow> (D\\<in>Pow(X) \\<and>  (D \\<inter> T)=0)\\<or> D=X\"\n",
        "proof": "proof-\n  have \"X-X=0\" by blast\n  then have \"X-X\\<in>IncludedSet(X,T)\" using IncludedSet_def by auto\n  moreover\n  {\n    assume A:\"D \\<subseteq> X\" \"X - D \\<in> IncludedSet(X,T) \"\" D \\<noteq> X\"\n    from A(2) have \"T\\<subseteq>(X-D)\\<or> X-D=0\" using IncludedSet_def by auto\n    with A(1) have \"T\\<subseteq>(X-D)\\<or> D=X\" by blast \n    with A(3) have \"T\\<subseteq>(X-D)\" by auto\n    hence \"D\\<inter>T=0\" by blast\n  }\n  moreover\n  {\n    assume A:\"D\\<inter>T=0\"\"D\\<subseteq>X\"\n    from A(1) assms have \"T\\<subseteq>(X-D)\" by blast\n    then have \"X-D\\<in>IncludedSet(X,T)\" using IncludedSet_def by auto\n  }\n  ultimately show ?thesis using IsClosed_def union_includedset assms by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2314
    },
    "2087": {
        "type": "lemma",
        "text": "text\\<open>The interior of a set is itself if it is open or the empty set if it isn't.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\"\n  ",
        "using": [
            "topology0.Top_2_L2",
            "topology0_includedset",
            "IncludedSet_def",
            "topology0.Top_2_L1",
            "topology0.Top_2_L3"
        ],
        "statement": "lemma interior_set_includedset:\n  assumes \"A\\<subseteq>X\"\n  shows \"Interior(A,IncludedSet(X,T))= (if T\\<subseteq>A then A else 0)\"\n",
        "proof": "proof-\n  {\n    fix x\n    assume A:\"Interior(A,IncludedSet(X,T)) \\<noteq> 0 \"\"x\\<in>T\"\n    have \"Interior(A,IncludedSet(X,T)) \\<in> IncludedSet(X,T)\" using\n      topology0.Top_2_L2 topology0_includedset by auto\n    with A(1) have \"T \\<subseteq> Interior(A,IncludedSet(X,T))\" using IncludedSet_def\n      by auto\n    with A(2) have \"x \\<in> Interior(A,IncludedSet(X,T))\" by auto\n    then have \"x\\<in>A\" using topology0.Top_2_L1 topology0_includedset by auto}\n    moreover\n  {\n    assume \"T\\<subseteq>A\"\n    with assms have \"A\\<in>IncludedSet(X,T)\" using IncludedSet_def by auto\n    then have \"Interior(A,IncludedSet(X,T)) = A\" using topology0.Top_2_L3\n      topology0_includedset by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2315
    },
    "2088": {
        "type": "lemma",
        "text": "text\\<open>The closure of a set is itself if it is closed or the whole space if it is not.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\" \"T\\<subseteq>X\"\n  ",
        "using": [
            "closed_sets_includedset",
            "assms",
            "topology0.Top_3_L8",
            "topology0_includedset",
            "union_includedset",
            "assms(2)",
            "ClosedCovers_def",
            "Closure_def",
            "AS",
            "topology0.Top_3_L3"
        ],
        "statement": "lemma closure_set_includedset:\n  assumes \"A\\<subseteq>X\" \"T\\<subseteq>X\"\n  shows \"Closure(A,IncludedSet(X,T)) = (if T\\<inter>A=0 then A else X)\"\n",
        "proof": "proof-\n  {\n    assume AS:\"T\\<inter>A=0\"\n    then have \"A {is closed in} IncludedSet(X,T)\" using closed_sets_includedset\n      assms by auto\n    with assms(1) have \"Closure(A,IncludedSet(X,T))=A\" using topology0.Top_3_L8\n      topology0_includedset union_includedset assms(2) by auto\n  }\n  moreover\n  {\n    assume AS:\"T\\<inter>A \\<noteq> 0\"\n    have \"X\\<in>ClosedCovers(A,IncludedSet(X,T))\" using ClosedCovers_def\n      closed_sets_includedset union_includedset assms by auto\n    then have l1:\"\\<Inter>ClosedCovers(A,IncludedSet(X,T))\\<subseteq>X\" using Closure_def\n      by auto\n    moreover\n    {\n      fix U\n      assume \"U\\<in>ClosedCovers(A,IncludedSet(X,T))\"  \n      then have \"U{is closed in}IncludedSet(X,T)\"\"A\\<subseteq>U\" using ClosedCovers_def\n        by auto\n      then have \"U=X\\<or>(T\\<inter>U)=0\"\"A\\<subseteq>U\" using closed_sets_includedset assms(2)\n        by auto\n      then have \"U=X\\<or>(T\\<inter>A)=0\" by auto\n      then have \"U=X\" using AS by auto\n    }\n    then have \"X \\<subseteq> \\<Inter>ClosedCovers(A,IncludedSet(X,T))\" using topology0.Top_3_L3\n      topology0_includedset union_includedset assms by auto\n    ultimately have \"\\<Inter>ClosedCovers(A,IncludedSet(X,T))=X\" by auto\n    then have \"Closure(A,IncludedSet(X,T)) = X \"\n      using Closure_def by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2316
    },
    "2089": {
        "type": "lemma",
        "text": "text\\<open>The boundary of a set is \\<open>X-A\\<close> if $A$ contains \\<open>T\\<close> completely, is \\<open>A\\<close> if $X-A$ contains \\<open>T\\<close>\n  completely and \\<open>X\\<close> if \\<open>T\\<close> is divided between the two sets. \n  The case where \\<open>T=0\\<close> is considered as a special case.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\" \"T\\<subseteq>X\" \"T\\<noteq>0\"\n  ",
        "using": [
            "closure_set_includedset",
            "Boundary_def",
            "union_includedset"
        ],
        "statement": "lemma boundary_includedset:\n  assumes \"A\\<subseteq>X\" \"T\\<subseteq>X\" \"T\\<noteq>0\"\n  shows \"Boundary(A,IncludedSet(X,T))=(if T\\<subseteq>A then X-A else (if T\\<inter>A=0 then A else X))\"\n",
        "proof": "proof -\n  from \\<open>A\\<subseteq>X\\<close> have \"X-A \\<subseteq> X\" by auto\n  {\n    assume \"T\\<subseteq>A\"\n    with assms(2,3) have \"T\\<inter>A\\<noteq>0\" and \"T\\<inter>(X-A)=0\" by auto\n    with assms(1,2)  \\<open>X-A \\<subseteq> X\\<close>  have\n      \"Closure(A,IncludedSet(X,T)) = X\" and \"Closure(X-A,IncludedSet(X,T)) = (X-A)\"\n      using closure_set_includedset by auto \n    with assms(2) have \"Boundary(A,IncludedSet(X,T)) = X-A\" \n      using Boundary_def union_includedset by auto\n  }\n  moreover\n  {\n    assume \"~(T\\<subseteq>A)\" and \"T\\<inter>A=0\"\n    with assms(2) have \"T\\<inter>(X-A)\\<noteq>0\" by auto \n    with assms(1,2) \\<open>T\\<inter>A=0\\<close> \\<open>X-A \\<subseteq> X\\<close> have\n      \"Closure(A,IncludedSet(X,T)) = A\" and \"Closure(X-A,IncludedSet(X,T)) = X\"\n      using  closure_set_includedset by auto\n    with assms(1,2) have \"Boundary(A,IncludedSet(X,T))=A\" using Boundary_def union_includedset\n      by auto\n  }\n  moreover\n  {\n    assume \"~(T\\<subseteq>A)\" and \"T\\<inter>A \\<noteq> 0\"\n    with assms(1,2) have \"T\\<inter>(X-A) \\<noteq> 0\" by auto\n    with assms(1,2) \\<open>T\\<inter>A\\<noteq>0\\<close>  \\<open>X-A \\<subseteq> X\\<close> have\n      \"Closure(A,IncludedSet(X,T)) = X\" and \"Closure(X-A,IncludedSet(X,T)) = X\"\n      using closure_set_includedset by auto \n    with assms(2) have \"Boundary(A,IncludedSet(X,T)) = X\" \n      using Boundary_def union_includedset  by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2317
    },
    "2090": {
        "type": "lemma",
        "text": "text\\<open>The topology is discrete if \\<open> T=0 \\<close>\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma smaller_includedset:\n  shows \"IncludedSet(X,0) = Pow(X)\"\n",
        "proof": "proof\n  show \"IncludedSet(X,0) \\<subseteq> Pow(X)\" and \"Pow(X) \\<subseteq> IncludedSet(X,0)\"\n    unfolding IncludedSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2318
    },
    "2091": {
        "type": "lemma",
        "text": "text\\<open>If the set which is included is not a subset of \\<open>X\\<close>,\nthen the topology is trivial.\\<close>\n",
        "assumes": "assumes \"~(T\\<subseteq>X)\"\n  ",
        "using": [],
        "statement": "lemma empty_includedset:\n  assumes \"~(T\\<subseteq>X)\"\n  shows \"IncludedSet(X,T) = {0}\"\n",
        "proof": "proof\n  from assms show \"IncludedSet(X,T) \\<subseteq> {0}\" and \"{0} \\<subseteq> IncludedSet(X,T)\"\n    unfolding IncludedSet_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2319
    },
    "2092": {
        "type": "lemma",
        "text": "text\\<open>The topological subspaces of the \\<open>IncludedSet(X,T)\\<close> topology\nare also IncludedSet topologies. The trivial case does not fit the idea\nin the demonstration because if \\<open>Y\\<subseteq>X\\<close>  then \\<open>IncludedSet(Y\\<inter>X, Y\\<inter>T)\\<close>\nis never trivial. There is no need for a separate proof because\nthe only subspace of the trivial topology is itself.\\<close>\n",
        "assumes": "assumes \"T\\<subseteq>X\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma subspace_includedset:\n  assumes \"T\\<subseteq>X\"\n  shows \"IncludedSet(X,T) {restricted to} Y = IncludedSet(Y\\<inter>X,Y\\<inter>T)\"\n",
        "proof": "proof\n  {\n    fix M\n    assume \"M \\<in> (IncludedSet(X,T) {restricted to} Y)\"\n    then obtain A where A1:\"A:IncludedSet(X,T)\" \"M = Y\\<inter>A\" unfolding RestrictedTo_def \n      by auto\n    then have \"M \\<in> Pow(X\\<inter>Y)\" unfolding IncludedSet_def by auto\n    moreover\n    from A1 have \"Y\\<inter>T\\<subseteq>M \\<or> M=0\" unfolding IncludedSet_def by blast\n    ultimately have \"M \\<in> IncludedSet(Y\\<inter>X, Y\\<inter>T)\" unfolding IncludedSet_def\n      by auto\n  }\n  then show \"IncludedSet(X,T) {restricted to} Y \\<subseteq> IncludedSet(Y\\<inter>X, Y\\<inter>T)\" \n    by auto\n  {\n    fix M\n    let ?A = \"M \\<union> T\"\n    assume A:\"M \\<in> IncludedSet(Y\\<inter>X, Y\\<inter>T)\"\n    {\n      assume \"M=0\"\n      then have \"M\\<in>IncludedSet(X,T) {restricted to} Y\" unfolding RestrictedTo_def\n        IncludedSet_def by auto\n    }\n    moreover\n    {\n      assume AS:\"M\\<noteq>0\"\n      from A AS have A1:\"M\\<in>Pow(Y\\<inter>X) \\<and> Y\\<inter>T\\<subseteq>M\" unfolding IncludedSet_def by auto\n      then have \"?A\\<in>Pow(X)\" using assms by blast\n      moreover\n      have \"T\\<subseteq>?A\" by blast\n      ultimately have \"?A \\<in> IncludedSet(X,T)\" unfolding IncludedSet_def by auto\n      then have AT:\"Y \\<inter> ?A \\<in> IncludedSet(X,T) {restricted to} Y\"unfolding RestrictedTo_def\n        by auto\n      from A1 have \"Y \\<inter> ?A=Y \\<inter> M\" by blast\n      also from A1 have \"\\<dots>=M\" by auto\n      finally have \"Y\\<inter>?A = M\" by simp \n      with AT have \"M \\<in> IncludedSet(X,T) {restricted to} Y\"\n        by auto\n    }\n    ultimately have \"M \\<in> IncludedSet(X,T) {restricted to} Y\" by auto\n  }\n  thus \"IncludedSet(Y\\<inter>X, Y\\<inter>T) \\<subseteq> IncludedSet(X,T) {restricted to} Y\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2320
    },
    "2093": {
        "type": "definition",
        "text": "text\\<open>Given a family of subsets satisfying the base condition,\n  it is possible to construct a topology where that family is a base of. Even more,\n  it is the only topology with such characteristics.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  TopologyWithBase (\"TopologyBase _ \" 50) where\n  \"U {satisfies the base condition} \\<Longrightarrow> TopologyBase U \\<equiv> THE T. U {is a base for} T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2321
    },
    "2094": {
        "type": "theorem",
        "text": "text\\<open> If a collection $U$ of sets satisfies the base condition then the topology\n  constructed from it is indeed a topology and $U$ is a base for this topology. \\<close>\n",
        "assumes": "assumes \"U {satisfies the base condition}\"\n  ",
        "using": [
            "Top_1_2_T1(2)",
            "same_base_same_top",
            "ex1I[where",
            "P=",
            "\"\\<lambda>T.",
            "U",
            "{is",
            "a",
            "base",
            "for}",
            "T\"]",
            "theI[where",
            "TopologyWithBase_def",
            "Top_1_2_T1(1)",
            "IsAbaseFor_def"
        ],
        "statement": "theorem Base_topology_is_a_topology:\n  assumes \"U {satisfies the base condition}\"\n  shows \"(TopologyBase U) {is a topology}\" and \"U {is a base for} (TopologyBase U)\"\n",
        "proof": "proof-\n  from assms obtain T where \"U {is a base for} T\" using\n    Top_1_2_T1(2) by blast\n  then have \"\\<exists>!T. U {is a base for} T\" using same_base_same_top ex1I[where P=\n    \"\\<lambda>T. U {is a base for} T\"] by blast\n  with assms show \"U {is a base for} (TopologyBase U) \" using theI[where P=\n    \"\\<lambda>T. U {is a base for} T\"] TopologyWithBase_def by auto\n  with assms  show \"(TopologyBase U) {is a topology}\" using Top_1_2_T1(1)\n    IsAbaseFor_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2322
    },
    "2095": {
        "type": "lemma",
        "text": "text\\<open>The interior of a set is the union of all the sets of the base which are fully\n  contained by it.\\<close>\n",
        "assumes": "assumes \"U {is a base for} T\" \"T{is a topology}\"\n  ",
        "using": [
            "IsAbaseFor_def",
            "assms(2)",
            "topology0.Top_2_L5",
            "topology0_def",
            "point_open_base_neigh",
            "topology0.Top_2_L2",
            "topology0.Top_2_L1"
        ],
        "statement": "lemma interior_set_base_topology:\n  assumes \"U {is a base for} T\" \"T{is a topology}\"\n  shows \"Interior(A,T) = \\<Union>{T\\<in>U. T\\<subseteq>A}\"\n",
        "proof": "proof\n  have \"{T\\<in>U. T\\<subseteq>A}\\<subseteq>U\" by auto\n  with assms(1) have \"\\<Union>{T\\<in>U. T\\<subseteq>A}\\<in>T\"\n    using IsAbaseFor_def by auto\n  moreover have \"\\<Union>{T\\<in>U. T\\<subseteq>A} \\<subseteq> A\" by blast\n  ultimately show  \"\\<Union>{T\\<in>U. T\\<subseteq>A} \\<subseteq> Interior(A,T)\"\n    using assms(2) topology0.Top_2_L5 topology0_def by auto\n  {\n    fix x\n    assume \"x \\<in> Interior(A,T)\"\n    with assms obtain V where \"V\\<in>U\" \"V \\<subseteq> Interior(A,T)\" \"x\\<in>V\"\n      using point_open_base_neigh topology0.Top_2_L2 topology0_def \n      by blast\n    with assms have \"V\\<in>U\" \"x\\<in>V\" \"V\\<subseteq>A\" using topology0.Top_2_L1 topology0_def\n      by auto  \n    hence \"x \\<in> \\<Union>{T\\<in>U. T\\<subseteq>A}\" by auto\n  }\n  thus \"Interior(A, T) \\<subseteq> \\<Union>{T \\<in> U . T \\<subseteq> A} \" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2324
    },
    "2096": {
        "type": "lemma",
        "text": "text\\<open>The restriction of a base is a base for the restriction.\\<close>\n",
        "assumes": "assumes \"B {is a base for} T\"\n  ",
        "using": [],
        "statement": "lemma subspace_base_topology:\n  assumes \"B {is a base for} T\"\n  shows \"(B {restricted to} Y) {is a base for} (T {restricted to} Y)\"\n",
        "proof": "proof -\n  from assms have \"(B {restricted to} Y) \\<subseteq> (T {restricted to} Y)\"\n    unfolding IsAbaseFor_def RestrictedTo_def by auto \n  moreover have \"(T {restricted to} Y) = {\\<Union>A. A \\<in> Pow(B {restricted to} Y)}\"\n  proof\n    { fix U assume \"U \\<in> (T {restricted to} Y)\"\n      then obtain W where \"W\\<in>T\" and \"U = W\\<inter>Y\" unfolding RestrictedTo_def by blast\n      with assms obtain C where \"C\\<in>Pow(B)\" and \"W=\\<Union>C\" unfolding IsAbaseFor_def\n        by blast\n      let ?A=\"{V\\<inter>Y. V\\<in>C}\"\n      from \\<open>C\\<in>Pow(B)\\<close> \\<open>U = W\\<inter>Y\\<close> \\<open>W=\\<Union>C\\<close> have \n        \"?A \\<in> Pow(B {restricted to} Y)\" and \"U=(\\<Union>?A)\" \n        unfolding RestrictedTo_def by auto \n      hence \"U \\<in> {\\<Union>A. A \\<in> Pow(B {restricted to} Y)}\" by blast \n    } thus \"(T {restricted to} Y) \\<subseteq> {\\<Union>A. A \\<in> Pow(B {restricted to} Y)}\"\n      by auto\n    { fix U assume \"U \\<in> {\\<Union>A. A \\<in> Pow(B {restricted to} Y)}\"\n      then obtain A where A: \"A \\<subseteq> (B {restricted to} Y)\" and \"U = (\\<Union>A)\" by auto\n      let ?A\\<^sub>0=\"{C\\<in>B. Y\\<inter>C\\<in>A}\"\n      from A have \"?A\\<^sub>0 \\<subseteq> B\" and \"A = ?A\\<^sub>0 {restricted to} Y\" unfolding RestrictedTo_def\n        by auto \n      with \\<open>U = (\\<Union>A)\\<close> have \"?A\\<^sub>0 \\<subseteq> B\" and \"U = \\<Union>(?A\\<^sub>0 {restricted to} Y)\" \n        by auto\n      with assms have \"U \\<in> (T {restricted to} Y)\" unfolding RestrictedTo_def IsAbaseFor_def\n        by auto\n    } thus \"{\\<Union>A. A \\<in> Pow(B {restricted to} Y)} \\<subseteq> (T {restricted to} Y)\" by blast \n  qed\n  ultimately show ?thesis unfolding IsAbaseFor_def by simp \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2326
    },
    "2097": {
        "type": "theorem",
        "text": "text\\<open>If the base of a topology is contained in the base of another\ntopology, then the topologies maintain the same relation.\\<close>\n",
        "assumes": "assumes \"B{is a base for}T\"\"B2{is a base for}T2\"\"B\\<subseteq>B2\"\n  ",
        "using": [
            "IsAbaseFor_def"
        ],
        "statement": "theorem base_subset:\n  assumes \"B{is a base for}T\"\"B2{is a base for}T2\"\"B\\<subseteq>B2\"\n  shows \"T\\<subseteq>T2\"\n",
        "proof": "proof\n  {\n    fix x\n    assume \"x\\<in>T\"\n    with assms(1) obtain M where \"M\\<subseteq>B\"\"x=\\<Union>M\" using IsAbaseFor_def by auto\n    with assms(3) have \"M\\<subseteq>B2\"\"x=\\<Union>M\" by auto\n    with assms(2) show \"x\\<in>T2\" using IsAbaseFor_def by auto\n  }\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2327
    },
    "2098": {
        "type": "definition",
        "text": "text\\<open>A dual base for closed sets is the collection of complements\nof sets of a base for the topology.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  DualBase (\"DualBase _ _\" 80) where\n  \"B{is a base for}T \\<Longrightarrow> DualBase B T\\<equiv>{\\<Union>T-U. U\\<in>B}\\<union>{\\<Union>T}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2328
    },
    "2099": {
        "type": "lemma",
        "text": "text\\<open>We have already seen for a base that whenever\nthere is a union of open sets, we can consider only basic open sets\ndue to the fact that any open set is a union of basic open sets.\nWhat we should expect now is that when there is an intersection\nof closed sets, we can consider only dual basic closed sets.\\<close>\n",
        "assumes": "assumes \"U {is a base for} Q\"\"Q{is a topology}\"\"A\\<subseteq>\\<Union>Q\"\n  ",
        "using": [
            "DualBase_def",
            "topology0.Top_3_L1",
            "topology0_def",
            "topology0.Top_3_L9",
            "base_sets_open",
            "Closure_def",
            "ClosedCovers_def",
            "closure_set_base_topology"
        ],
        "statement": "lemma closure_dual_base:\n  assumes \"U {is a base for} Q\"\"Q{is a topology}\"\"A\\<subseteq>\\<Union>Q\"\n  shows \"Closure(A,Q)=\\<Inter>{T\\<in>DualBase U Q. A\\<subseteq>T}\"\n",
        "proof": "proof\n  from assms(1) have T:\"\\<Union>Q\\<in>DualBase U Q\" using DualBase_def by auto\n  moreover\n  {\n    fix T\n    assume A:\"T\\<in>DualBase U Q\" \"A\\<subseteq>T\"\n    with assms(1) obtain R where \"(T=\\<Union>Q-R\\<and>R\\<in>U)\\<or>T=\\<Union>Q\" using DualBase_def\n      by auto\n    with A(2) assms(1,2) have  \"(T{is closed in}Q)\"\"A\\<subseteq>T\"\"T\\<in>Pow(\\<Union>Q)\" using topology0.Top_3_L1 topology0_def\n      topology0.Top_3_L9 base_sets_open by auto\n  }\n  then have SUB:\"{T\\<in>DualBase U Q. A\\<subseteq>T}\\<subseteq>{T\\<in>Pow(\\<Union>Q). (T{is closed in}Q)\\<and>A\\<subseteq>T}\"\n    by blast\n  with calculation assms(3) have \"\\<Inter>{T\\<in>Pow(\\<Union>Q). (T{is closed in}Q)\\<and>A\\<subseteq>T}\\<subseteq>\\<Inter>{T\\<in>DualBase U Q. A\\<subseteq>T}\"\n    by auto\n  then show \"Closure(A,Q)\\<subseteq>\\<Inter>{T\\<in>DualBase U Q. A\\<subseteq>T}\" using Closure_def ClosedCovers_def\n    by auto\n  {\n    fix x\n    assume A:\"x\\<in>\\<Inter>{T\\<in>DualBase U Q. A\\<subseteq>T}\"\n    {\n      fix T\n      assume B:\"x\\<in>T\"\"T\\<in>U\"\n      {\n        assume C:\"A\\<inter>T=0\"\n        from B(2) assms(1) have \"\\<Union>Q-T\\<in>DualBase U Q\" using DualBase_def\n          by auto\n        moreover\n        from C assms(3) have \"A\\<subseteq>\\<Union>Q-T\" by auto\n        moreover\n        from B(1) have \"x\\<notin>\\<Union>Q-T\" by auto\n        ultimately have \"x\\<notin>\\<Inter>{T\\<in>DualBase U Q. A\\<subseteq>T}\" by auto\n        with A have \"False\" by auto\n      }\n      hence \"A\\<inter>T\\<noteq>0\" by auto\n    }\n    hence \"\\<forall>T\\<in>U. x\\<in>T\\<longrightarrow>A\\<inter>T\\<noteq>0\" by auto\n    moreover\n    from T A assms(3) have \"x\\<in>\\<Union>Q\" by auto\n    with calculation assms have \"x\\<in>Closure(A,Q)\" using closure_set_base_topology\n     by auto\n  }\n  thus \"\\<Inter>{T \\<in> DualBase U Q . A \\<subseteq> T} \\<subseteq> Closure(A, Q)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2329
    },
    "2100": {
        "type": "definition",
        "text": "text\\<open>In the theory file Partitions\\_ZF.thy; there is\na definition to work with partitions. In this setting\nis much easier to work with a family of subsets.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsAPartition (\"_{is a partition of}_\" 90) where\n  \"(U {is a partition of} X) \\<equiv> (\\<Union>U=X \\<and> (\\<forall>A\\<in>U. \\<forall>B\\<in>U. A=B\\<or> A\\<inter>B=0)\\<and> 0\\<notin>U)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2330
    },
    "2101": {
        "type": "lemma",
        "text": "text\\<open>A subcollection of a partition is a partition\nof its union.\\<close>\n",
        "assumes": "assumes \"U {is a partition of} X\" \"V\\<subseteq>U\"\n  ",
        "using": [
            "assms",
            "IsAPartition_def"
        ],
        "statement": "lemma subpartition:\n  assumes \"U {is a partition of} X\" \"V\\<subseteq>U\"\n  shows \"V{is a partition of}\\<Union>V\" \n  ",
        "proof": "using assms unfolding IsAPartition_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2331
    },
    "2102": {
        "type": "lemma",
        "text": "text\\<open>A restriction of a partition is a partition. If the empty set appears\nit has to be removed.\\<close>\n",
        "assumes": "assumes \"U {is a partition of}X\"\n  ",
        "using": [
            "assms",
            "IsAPartition_def",
            "RestrictedTo_def"
        ],
        "statement": "lemma restriction_partition:\n  assumes \"U {is a partition of}X\"\n  shows \"((U {restricted to} Y)-{0}) {is a partition of} (X\\<inter>Y)\"\n  ",
        "proof": "using assms unfolding IsAPartition_def RestrictedTo_def\n  by fast\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2332
    },
    "2103": {
        "type": "lemma",
        "text": "text\\<open>A partition satisfies the base condition.\\<close>\n",
        "assumes": "assumes \"P {is a partition of} X\"\n  ",
        "using": [
            "IsAPartition_def",
            "SatisfiesBaseCondition_def"
        ],
        "statement": "lemma partition_base_condition:\n  assumes \"P {is a partition of} X\"\n  shows \"P {satisfies the base condition}\"\n",
        "proof": "proof-\n  {\n    fix U V\n    assume AS:\"U\\<in>P\\<and>V\\<in>P\"\n    with assms have A:\"U=V\\<or> U\\<inter>V=0\" using IsAPartition_def by auto\n    {\n      fix x\n      assume ASS:\"x\\<in>U\\<inter>V\"\n      with A have \"U=V\" by auto\n      with AS ASS have \"U\\<in>P\"\"x\\<in>U\\<and> U\\<subseteq>U\\<inter>V\" by auto\n      hence \"\\<exists>W\\<in>P. x\\<in>W\\<and> W\\<subseteq>U\\<inter>V\" by auto\n    }\n    hence \"(\\<forall>x \\<in> U\\<inter>V. \\<exists>W\\<in>P. x\\<in>W \\<and> W \\<subseteq> U\\<inter>V)\" by auto\n  }\n  then show ?thesis using SatisfiesBaseCondition_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2334
    },
    "2104": {
        "type": "lemma",
        "text": "text\\<open>The topology is defined in the set $X$\\<close>\n",
        "assumes": "assumes \"U {is a partition of} X\"\n  ",
        "using": [
            "assms",
            "Ptopology_is_a_topology(2)",
            "Top_1_2_L5",
            "IsAPartition_def"
        ],
        "statement": "lemma union_ptopology:\n  assumes \"U {is a partition of} X\"\n  shows \"\\<Union>(PTopology X U)=X\"\n  ",
        "proof": "using assms Ptopology_is_a_topology(2) Top_1_2_L5\n    IsAPartition_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2336
    },
    "2105": {
        "type": "lemma",
        "text": "text\\<open>The closed sets are the open sets.\\<close>\n",
        "assumes": "assumes \"T {is a partition of} X\"\n  ",
        "using": [
            "Ptopology_is_a_topology(2)",
            "IsClosed_def",
            "union_ptopology",
            "Top_1_2_L1[where",
            "B=\"T\"",
            "and",
            "U=\"X-D\"]",
            "diff_union_is_union_diff",
            "IsAbaseFor_def",
            "IsAPartition_def"
        ],
        "statement": "lemma closed_sets_ptopology:\n  assumes \"T {is a partition of} X\"\n  shows\"D {is closed in} (PTopology X T) \\<longleftrightarrow> D\\<in>(PTopology X T)\"\n",
        "proof": "proof\n  from assms\n  have B:\"T{is a base for}(PTopology X T)\" using Ptopology_is_a_topology(2) by auto\n  {\n    fix D\n    assume \"D {is closed in} (PTopology X T)\"\n    with assms have A:\"D\\<in>Pow(X)\"\"X-D\\<in>(PTopology X T)\"\n      using IsClosed_def union_ptopology by auto\n    from A(2) B obtain R where Q:\"R\\<subseteq>T\" \"X-D=\\<Union>R\" using Top_1_2_L1[where B=\"T\" and U=\"X-D\"]\n      by auto\n    from A(1) have \"X-(X-D)=D\" by blast \n    with Q(2) have \"D=X-\\<Union>R\" by auto\n    with Q(1) assms have \"D=\\<Union>(T-R)\" using diff_union_is_union_diff\n      by auto\n    with B show \"D\\<in>(PTopology X T)\" using IsAbaseFor_def by auto\n  }\n  {\n    fix D\n    assume \"D\\<in>(PTopology X T)\"\n    with B obtain R where Q:\"R\\<subseteq>T\"\"D=\\<Union>R\" using IsAbaseFor_def by auto\n    hence \"X-D=X-\\<Union>R\" by auto\n    with Q(1) assms have \"X-D=\\<Union>(T-R)\" using diff_union_is_union_diff\n      by auto\n    with B have \"X-D\\<in>(PTopology X T)\" using IsAbaseFor_def by auto\n    moreover\n    from Q have \"D\\<subseteq>\\<Union>T\" by auto\n    with assms have \"D\\<subseteq>X\" using IsAPartition_def by auto\n    with calculation assms show \"D{is closed in} (PTopology X T)\"\n      using IsClosed_def union_ptopology by auto\n  }\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2337
    },
    "2106": {
        "type": "lemma",
        "text": "text\\<open>There is a formula for the interior\ngiven by an intersection of sets of the dual base.\nIs the intersection of all the closed sets of the dual basis\nsuch that they do not complement $A$ to $X$.\nSince the interior of $X$ must be inside $X$, we have to \nenter $X$ as one of the sets to be intersected.\\<close>\n",
        "assumes": "assumes \"U {is a partition of} X\"\"A\\<subseteq>X\"\n  ",
        "using": [
            "topology0.open_open_neigh",
            "topology0_ptopology",
            "topology0.Top_2_L2",
            "topology0.Top_2_L1",
            "Ptopology_is_a_topology(2)",
            "IsAbaseFor_def",
            "union_ptopology[of",
            "\"U\"\"X\"]",
            "DualBase_def[of\"U\"]",
            "Ptopology_is_a_topology(2)[of",
            "DualBase_def",
            "union_ptopology",
            "Top_1_2_L5[of",
            "\"U\"\"PTopology",
            "X",
            "U\"]",
            "IsAPartition_def",
            "XX",
            "base_sets_open",
            "topology0.Top_3_L1[where",
            "T=\"PTopology",
            "topology0.Top_3_L9[where",
            "topology0.Top_3_L4[where",
            "K=\"{T\\<in>DualBase",
            "U",
            "(PTopology",
            "U).",
            "T=X\\<or>T\\<union>A\\<noteq>X}\"]",
            "topology0_ptopology[where",
            "U=\"U\"",
            "and",
            "X=\"X\"]",
            "closed_sets_ptopology",
            "subset_trans[where",
            "A=\"R\"",
            "C=\"X-R\"]",
            "topology0.Top_2_L6"
        ],
        "statement": "lemma interior_set_ptopology:\n  assumes \"U {is a partition of} X\"\"A\\<subseteq>X\"\n  shows \"Interior(A,(PTopology X U))=\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\"\n",
        "proof": "proof\n  {\n    fix x\n    assume \"x\\<in>Interior(A,(PTopology X U))\"\n    with assms obtain R where A:\"x\\<in>R\"\"R\\<in>(PTopology X U)\"\"R\\<subseteq>A\"\n      using topology0.open_open_neigh topology0_ptopology\n      topology0.Top_2_L2 topology0.Top_2_L1\n      by auto\n    with assms obtain B where B:\"B\\<subseteq>U\"\"R=\\<Union>B\" using Ptopology_is_a_topology(2)\n      IsAbaseFor_def by auto\n    from A(1,3) assms have XX:\"x\\<in>X\"\"X\\<in>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\"\n      using union_ptopology[of \"U\"\"X\"] DualBase_def[of\"U\"] Ptopology_is_a_topology(2)[of \"U\"\"X\"] by (safe,blast,auto)\n    moreover\n    from B(2) A(1) obtain S where C:\"S\\<in>B\"\"x\\<in>S\" by auto\n    {\n      fix T\n      assume AS:\"T\\<in>DualBase U (PTopology X U)\"\"T \\<union>A\\<noteq>X\"\n      from AS(1) assms obtain w where \"(T=X-w\\<and>w\\<in>U)\\<or>(T=X)\"\n        using DualBase_def union_ptopology Ptopology_is_a_topology(2)\n        by auto\n      with assms(2) AS(2) have D:\"T=X-w\"\"w\\<in>U\" by auto\n      from D(2) have \"w\\<subseteq>\\<Union>U\" by auto\n      with assms(1) have \"w\\<subseteq>\\<Union>(PTopology X U)\" using Ptopology_is_a_topology(2) Top_1_2_L5[of \"U\"\"PTopology X U\"]\n        by auto\n      with assms(1) have \"w\\<subseteq>X\" using union_ptopology by auto\n      with D(1) have \"X-T=w\" by auto\n      with D(2) have \"X-T\\<in>U\" by auto\n      { \n        assume \"x\\<in>X-T\"\n        with C B(1) have \"S\\<in>U\"\"S\\<inter>(X-T)\\<noteq>0\" by auto\n        with \\<open>X-T\\<in>U\\<close> assms(1) have \"X-T=S\" using IsAPartition_def by auto\n        with \\<open>X-T=w\\<close>\\<open>T=X-w\\<close> have \"X-S=T\" by auto\n        with AS(2) have \"X-S\\<union>A\\<noteq>X\" by auto\n        from A(3) B(2) C(1) have \"S\\<subseteq>A\" by auto\n        hence \"X-A\\<subseteq>X-S\" by auto\n        with assms(2) have \"X-S\\<union>A=X\"  by auto\n        with \\<open>X-S\\<union>A\\<noteq>X\\<close> have \"False\" by auto\n        }\n      then have \"x\\<in>T\" using XX by auto\n      }\n    ultimately have \"x\\<in>\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\"\n      by auto\n  }\n  thus \"Interior(A,(PTopology X U))\\<subseteq>\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\" by auto\n  {\n    fix x\n    assume p:\"x\\<in>\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\"\n    hence noE:\"\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\\<noteq>0\" by auto\n    {\n      fix T\n      assume \"T\\<in>DualBase U (PTopology X U)\"\n      with assms(1) obtain w where \"T=X\\<or>(w\\<in>U\\<and>T=X-w)\" using DualBase_def\n        Ptopology_is_a_topology(2) union_ptopology by auto\n      with assms(1) have \"T=X\\<or>(w\\<in>(PTopology X U)\\<and>T=X-w)\" using base_sets_open\n        Ptopology_is_a_topology(2) by blast\n      with assms(1) have \"T{is closed in}(PTopology X U)\" using topology0.Top_3_L1[where T=\"PTopology X U\"]\n        topology0_ptopology topology0.Top_3_L9[where T=\"PTopology X U\"] union_ptopology\n        by auto\n    }\n    moreover\n    from assms(1) p have \"X\\<in>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\"and X:\"x\\<in>X\" using Ptopology_is_a_topology(2) \n      DualBase_def union_ptopology by auto\n    with calculation assms(1) have \"(\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}) {is closed in}(PTopology X U)\"\n      using topology0.Top_3_L4[where K=\"{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\"] topology0_ptopology[where U=\"U\" and X=\"X\"]\n      by auto\n    with assms(1) have ab:\"(\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X})\\<in>(PTopology X U)\"\n      using closed_sets_ptopology by auto\n    with assms(1) obtain B where \"B\\<in>Pow(U)\"\"(\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X})=\\<Union>B\"\n      using Ptopology_is_a_topology(2) IsAbaseFor_def by auto\n    with p obtain R where \"x\\<in>R\"\"R\\<in>U\"\"R\\<subseteq>(\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X})\"\n      by auto\n    with assms(1) have R:\"x\\<in>R\"\"R\\<in>(PTopology X U)\"\"R\\<subseteq>(\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X})\"\"X-R\\<in>DualBase U (PTopology X U)\"\n      using base_sets_open Ptopology_is_a_topology(2) DualBase_def union_ptopology\n      by (safe,blast,simp,blast)\n    {\n      assume \"(X-R) \\<union>A\\<noteq>X\"\n      with R(4) have \"X-R\\<in>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\" by auto\n      hence \"\\<Inter>{T\\<in>DualBase U (PTopology X U). T=X\\<or>T\\<union>A\\<noteq>X}\\<subseteq>X-R\" by auto\n      with R(3) have \"R\\<subseteq>X-R\" using subset_trans[where A=\"R\" and C=\"X-R\"] by auto\n      hence \"R=0\" by blast\n      with R(1) have \"False\" by auto\n    }\n    hence I:\"(X-R) \\<union>A=X\" by auto\n    {\n      fix y\n      assume ASR:\"y\\<in>R\"\n      with R(2) have \"y\\<in>\\<Union>(PTopology X U)\" by auto\n      with assms(1) have XX:\"y\\<in>X\" using union_ptopology by auto\n      with I have \"y\\<in>(X-R) \\<union>A\" by auto\n      with XX have \"y\\<notin>R\\<or>y\\<in>A\" by auto\n      with ASR have \"y\\<in>A\" by auto\n    }\n    hence \"R\\<subseteq>A\" by auto\n    with R(1,2) have \"\\<exists>R\\<in>(PTopology X U). (x\\<in>R\\<and>R\\<subseteq>A)\" by auto\n    with assms(1) have \"x\\<in>Interior(A,(PTopology X U))\" using topology0.Top_2_L6\n      topology0_ptopology by auto\n  }\n  thus \"\\<Inter>{T \\<in> DualBase U PTopology X U . T = X \\<or> T \\<union> A \\<noteq> X} \\<subseteq> Interior(A, PTopology X U)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2338
    },
    "2107": {
        "type": "lemma",
        "text": "text\\<open>The closure of a set is the union of\nall the sets of the partition which intersect\nwith \\<open>A\\<close>.\\<close>\n",
        "assumes": "assumes \"U {is a partition of} X\"\"A\\<subseteq>X\"\n  ",
        "using": [
            "topology0.Top_3_L11(1)[where",
            "T=\"PTopology",
            "X",
            "U\"",
            "and",
            "A=\"A\"]",
            "topology0_ptopology",
            "union_ptopology",
            "Top_1_2_L5[where",
            "B=\"U\"",
            "U\"]",
            "Ptopology_is_a_topology(2)",
            "base_sets_open",
            "topology0_ptopology[where",
            "U=\"U\"",
            "X=\"X\"]",
            "topology0.cl_inter_neigh",
            "IsAbaseFor_def",
            "IsAPartition_def",
            "topology0.inter_neigh_cl"
        ],
        "statement": "lemma closure_set_ptopology:\n  assumes \"U {is a partition of} X\"\"A\\<subseteq>X\"\n  shows \"Closure(A,(PTopology X U))=\\<Union>{T\\<in>U. T\\<inter>A\\<noteq>0}\"\n",
        "proof": "proof\n  {\n    fix x\n    assume A:\"x\\<in>Closure(A,(PTopology X U))\"\n    with assms have \"x\\<in>\\<Union>(PTopology X U)\" using topology0.Top_3_L11(1)[where T=\"PTopology X U\"\n      and A=\"A\"] topology0_ptopology union_ptopology by auto\n    with assms(1) have \"x\\<in>\\<Union>U\" using Top_1_2_L5[where B=\"U\" and T=\"PTopology X U\"] Ptopology_is_a_topology(2) by auto\n    then obtain W where B:\"x\\<in>W\"\"W\\<in>U\" by auto\n    with A have \"x\\<in>Closure(A,(PTopology X U))\\<inter>W\" by auto\n    moreover\n    from assms B(2) have \"W\\<in>(PTopology X U)\"\"A\\<subseteq>X\" using base_sets_open Ptopology_is_a_topology(2)\n      by (safe,blast)\n    with calculation assms(1) have \"A\\<inter>W\\<noteq>0\" using topology0_ptopology[where U=\"U\" and X=\"X\"]\n      topology0.cl_inter_neigh union_ptopology by auto\n    with B have \"x\\<in>\\<Union>{T\\<in>U. T\\<inter>A\\<noteq>0}\" by blast\n  }\n  thus \"Closure(A, PTopology X U) \\<subseteq> \\<Union>{T \\<in> U . T \\<inter> A \\<noteq> 0}\" by auto\n  {\n    fix x\n    assume \"x\\<in>\\<Union>{T \\<in> U . T \\<inter> A \\<noteq> 0}\"\n    then obtain T where A:\"x\\<in>T\"\"T\\<in>U\"\"T\\<inter>A\\<noteq>0\" by auto\n    from assms have \"A\\<subseteq>\\<Union>(PTopology X U)\" using union_ptopology by auto\n    moreover\n    from A(1,2) assms(1) have \"x\\<in>\\<Union>(PTopology X U)\" using Top_1_2_L5[where B=\"U\" and T=\"PTopology X U\"]\n      Ptopology_is_a_topology(2) by auto\n    moreover\n    {\n      fix Q\n      assume B:\"Q\\<in>(PTopology X U)\"\"x\\<in>Q\"\n      with assms(1) obtain M where C:\"Q=\\<Union>M\"\"M\\<subseteq>U\" using \n        Ptopology_is_a_topology(2)\n        IsAbaseFor_def by auto\n      from B(2) C(1) obtain R where D:\"R\\<in>M\"\"x\\<in>R\" by auto\n      with C(2) A(1,2) have \"R\\<inter>T\\<noteq>0\"\"R\\<in>U\"\"T\\<in>U\" by auto\n      with assms(1) have \"R=T\" using IsAPartition_def by auto\n      with C(1) D(1) have \"T\\<subseteq>Q\" by auto\n      with A(3) have \"Q\\<inter>A\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>Q\\<in>(PTopology X U). x\\<in>Q \\<longrightarrow> Q\\<inter>A\\<noteq>0\" by auto\n    with calculation assms(1) have \"x\\<in>Closure(A,(PTopology X U))\" using topology0.inter_neigh_cl\n      topology0_ptopology by auto\n  }\n  then show \"\\<Union>{T \\<in> U . T \\<inter> A \\<noteq> 0} \\<subseteq> Closure(A, PTopology X U) \" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2339
    },
    "2108": {
        "type": "lemma",
        "text": "text\\<open>The boundary of a set is given by the union of the sets\nof the partition which have non empty intersection with the set\nbut that are not fully contained in it. Another equivalent\nstatement would be: the union of the sets\nof the partition which have non empty intersection with the set\nand its complement.\\<close>\n",
        "assumes": "assumes \"U {is a partition of} X\"\"A\\<subseteq>X\"\n  ",
        "using": [
            "closure_set_ptopology",
            "interior_set_base_topology",
            "Ptopology_is_a_topology[where",
            "U=\"U\"",
            "and",
            "X=\"X\"]",
            "topology0.Top_3_L12",
            "topology0_ptopology",
            "union_ptopology",
            "subpartition",
            "IsAPartition_def",
            "diff_union_is_union_diff"
        ],
        "statement": "lemma boundary_set_ptopology:\n  assumes \"U {is a partition of} X\"\"A\\<subseteq>X\"\n  shows \"Boundary(A,(PTopology X U))=\\<Union>{T\\<in>U. T\\<inter>A\\<noteq>0 \\<and> ~(T\\<subseteq>A)}\"\n",
        "proof": "proof-\n  from assms have \"Closure(A,(PTopology X U))=\\<Union>{T \\<in> U . T \\<inter> A \\<noteq> 0}\" using\n    closure_set_ptopology by auto\n  moreover\n  from assms(1) have \"Interior(A,(PTopology X U))=\\<Union>{T \\<in> U . T \\<subseteq> A}\" using\n    interior_set_base_topology Ptopology_is_a_topology[where U=\"U\" and X=\"X\"] by auto\n  with calculation assms have A:\"Boundary(A,(PTopology X U))=\\<Union>{T \\<in> U . T \\<inter> A \\<noteq> 0} - \\<Union>{T \\<in> U . T \\<subseteq> A}\"\n    using topology0.Top_3_L12 topology0_ptopology union_ptopology\n    by auto\n  from assms(1) have \"({T \\<in> U . T \\<inter> A \\<noteq> 0}) {is a partition of} \\<Union>({T \\<in> U . T \\<inter> A \\<noteq> 0})\"\n    using subpartition by blast\n  moreover\n  {\n    fix T\n    assume \"T\\<in>U\"\"T\\<subseteq>A\"\n    with assms(1) have \"T\\<inter>A=T\"\"T\\<noteq>0\" using IsAPartition_def by auto\n    with \\<open>T\\<in>U\\<close> have \"T\\<inter>A\\<noteq>0\"\"T\\<in>U\" by auto\n  }\n  then have \"{T \\<in> U . T \\<subseteq> A}\\<subseteq>{T \\<in> U . T \\<inter> A \\<noteq> 0}\"  by auto\n  ultimately have \"\\<Union>{T \\<in> U . T \\<inter> A \\<noteq> 0} - \\<Union>{T \\<in> U . T \\<subseteq> A}=\\<Union>(({T \\<in> U . T \\<inter> A \\<noteq> 0})-({T \\<in> U . T \\<subseteq> A}))\"\n  using diff_union_is_union_diff by auto\n  also have \"\\<dots>=\\<Union>({T \\<in> U . T \\<inter> A \\<noteq> 0 \\<and> ~(T\\<subseteq>A)})\" by blast\n  with calculation A show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2340
    },
    "2109": {
        "type": "lemma",
        "text": "text\\<open>The discrete and the indiscrete topologies appear as special\ncases of this partition topologies.\\<close>\n",
        "assumes": "",
        "using": [
            "IsAPartition_def"
        ],
        "statement": "lemma discrete_partition:\n  shows \"{{x}.x\\<in>X} {is a partition of}X\"\n  ",
        "proof": "using IsAPartition_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2341
    },
    "2110": {
        "type": "lemma",
        "text": "text\\<open>The topological subspaces of the \\<open>(PTopology X U)\\<close>\nare partition topologies.\\<close>\n",
        "assumes": "assumes \"U{is a partition of}X\"\n  ",
        "using": [
            "Ptopology_is_a_topology(2)",
            "subspace_base_topology",
            "base_no_0",
            "restriction_partition",
            "same_base_same_top"
        ],
        "statement": "lemma subspace_ptopology:\n  assumes \"U{is a partition of}X\"\n  shows \"(PTopology X U) {restricted to} Y=(PTopology (X\\<inter>Y) ((U {restricted to} Y)-{0}))\"\n",
        "proof": "proof-\n  from assms have \"U{is a base for}(PTopology X U)\" using Ptopology_is_a_topology(2)\n    by auto\n  then have \"(U{restricted to} Y){is a base for}(PTopology X U){restricted to} Y\"\n    using subspace_base_topology by auto\n  then have \"((U{restricted to} Y)-{0}){is a base for}(PTopology X U){restricted to} Y\" using base_no_0\n    by auto\n  moreover\n  from assms have \"((U{restricted to} Y)-{0}) {is a partition of} (X\\<inter>Y)\"\n    using restriction_partition by auto\n  then have \"((U{restricted to} Y)-{0}){is a base for}(PTopology (X\\<inter>Y) ((U {restricted to} Y)-{0}))\"\n    using Ptopology_is_a_topology(2) by auto\n  ultimately show ?thesis using same_base_same_top by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2342
    },
    "2111": {
        "type": "definition",
        "text": "text\\<open>Given a totally ordered set, several topologies can be defined\nusing the order relation. First we define an open interval, notice that\nthe set defined as \\<open>Interval\\<close> is a closed interval; and open rays.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IntervalX where\n  \"IntervalX(X,r,b,c)\\<equiv>(Interval(r,b,c)\\<inter>X)-{b,c}\"\ndefinition\n  LeftRayX where\n  \"LeftRayX(X,r,b)\\<equiv>{c\\<in>X. \\<langle>c,b\\<rangle>\\<in>r}-{b}\"\ndefinition\n  RightRayX where\n  \"RightRayX(X,r,b)\\<equiv>{c\\<in>X. \\<langle>b,c\\<rangle>\\<in>r}-{b}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2343
    },
    "2112": {
        "type": "lemma",
        "text": "text\\<open>Intersections of intervals and rays.\\<close>\n",
        "assumes": "assumes \"bu\\<in>X\"\"bv\\<in>X\"\"cu\\<in>X\"\"cv\\<in>X\"\"IsLinOrder(X,r)\"\n  ",
        "using": [
            "assms",
            "GreaterOf_def",
            "SmallerOf_def",
            "IntervalX_def",
            "BB(6,3)",
            "BB(7,4)",
            "BB(2,5)",
            "Order_ZF_2_L1A",
            "Order_ZF_2_L1",
            "T",
            "CC(1)",
            "IsLinOrder_def",
            "trans_def",
            "IsTotal_def",
            "R(2)",
            "antisym_def",
            "AS",
            "BB(3)",
            "R(1)",
            "CC(2)",
            "BB(4)"
        ],
        "statement": "lemma inter_two_intervals:\n  assumes \"bu\\<in>X\"\"bv\\<in>X\"\"cu\\<in>X\"\"cv\\<in>X\"\"IsLinOrder(X,r)\"\n  shows \"IntervalX(X,r,bu,cu)\\<inter>IntervalX(X,r,bv,cv)=IntervalX(X,r,GreaterOf(r,bu,bv),SmallerOf(r,cu,cv))\"\n",
        "proof": "proof\n  have T:\"GreaterOf(r,bu,bv)\\<in>X\"\"SmallerOf(r,cu,cv)\\<in>X\" using assms \n    GreaterOf_def SmallerOf_def by (cases \"\\<langle>bu,bv\\<rangle>\\<in>r\",simp,simp,cases \"\\<langle>cu,cv\\<rangle>\\<in>r\",simp,simp)\n  {\n    fix x\n    assume ASS:\"x\\<in>IntervalX(X,r,bu,cu)\\<inter>IntervalX(X,r,bv,cv)\"\n    then have \"x\\<in>IntervalX(X,r,bu,cu)\"\"x\\<in>IntervalX(X,r,bv,cv)\" by auto\n    then have BB:\"x\\<in>X\"\"x\\<in>Interval(r,bu,cu)\"\"x\\<noteq>bu\"\"x\\<noteq>cu\"\"x\\<in>Interval(r,bv,cv)\"\"x\\<noteq>bv\"\"x\\<noteq>cv\"\n    using IntervalX_def assms by auto\n    then have \"x\\<in>X\" by auto\n    moreover\n    have \"x\\<noteq>GreaterOf(r,bu,bv)\"\"x\\<noteq>SmallerOf(r,cu,cv)\"\n    proof-\n      show \"x\\<noteq>GreaterOf(r,bu,bv)\" using GreaterOf_def BB(6,3) by (cases \"\\<langle>bu,bv\\<rangle>\\<in>r\",simp+)\n      show \"x\\<noteq>SmallerOf(r,cu,cv)\" using SmallerOf_def BB(7,4) by (cases \"\\<langle>cu,cv\\<rangle>\\<in>r\",simp+)\n    qed\n    moreover\n    have \"\\<langle>bu,x\\<rangle>\\<in>r\"\"\\<langle>x,cu\\<rangle>\\<in>r\"\"\\<langle>bv,x\\<rangle>\\<in>r\"\"\\<langle>x,cv\\<rangle>\\<in>r\" using BB(2,5) Order_ZF_2_L1A by auto\n    then have \"\\<langle>GreaterOf(r,bu,bv),x\\<rangle>\\<in>r\"\"\\<langle>x,SmallerOf(r,cu,cv)\\<rangle>\\<in>r\" using GreaterOf_def SmallerOf_def \n      by (cases \"\\<langle>bu,bv\\<rangle>\\<in>r\",simp,simp,cases \"\\<langle>cu,cv\\<rangle>\\<in>r\",simp,simp)\n    then have \"x\\<in>Interval(r,GreaterOf(r,bu,bv),SmallerOf(r,cu,cv))\" using Order_ZF_2_L1 by auto\n    ultimately\n    have \"x\\<in>IntervalX(X,r,GreaterOf(r,bu,bv),SmallerOf(r,cu,cv))\" using IntervalX_def T by auto\n  }\n  then show \"IntervalX(X, r, bu, cu) \\<inter> IntervalX(X, r, bv, cv) \\<subseteq> IntervalX(X, r, GreaterOf(r, bu, bv), SmallerOf(r, cu, cv))\"\n    by auto\n  {\n    fix x\n    assume \"x\\<in>IntervalX(X,r,GreaterOf(r,bu,bv),SmallerOf(r,cu,cv))\"\n    then have BB:\"x\\<in>X\"\"x\\<in>Interval(r,GreaterOf(r,bu,bv),SmallerOf(r,cu,cv))\"\"x\\<noteq>GreaterOf(r,bu,bv)\"\"x\\<noteq>SmallerOf(r,cu,cv)\"\n    using IntervalX_def T by auto\n    then have \"x\\<in>X\" by auto\n    moreover\n    from BB(2) have CC:\"\\<langle>GreaterOf(r,bu,bv),x\\<rangle>\\<in>r\"\"\\<langle>x,SmallerOf(r,cu,cv)\\<rangle>\\<in>r\" using Order_ZF_2_L1A by auto\n    {\n      {\n        assume AS:\"\\<langle>bu,bv\\<rangle>\\<in>r\"\n        then have \"GreaterOf(r,bu,bv)=bv\" using GreaterOf_def by auto\n        then have \"\\<langle>bv,x\\<rangle>\\<in>r\" using CC(1) by auto\n        with AS have \"\\<langle>bu,x\\<rangle>\\<in>r\" \"\\<langle>bv,x\\<rangle>\\<in>r\" using assms IsLinOrder_def trans_def by (safe, blast)\n      }\n      moreover\n      {\n        assume AS:\"\\<langle>bu,bv\\<rangle>\\<notin>r\"\n        then have \"GreaterOf(r,bu,bv)=bu\" using GreaterOf_def by auto\n        then have \"\\<langle>bu,x\\<rangle>\\<in>r\" using CC(1) by auto\n        from AS have \"\\<langle>bv,bu\\<rangle>\\<in>r\" using assms IsLinOrder_def IsTotal_def assms by auto\n        with \\<open>\\<langle>bu,x\\<rangle>\\<in>r\\<close> have \"\\<langle>bu,x\\<rangle>\\<in>r\" \"\\<langle>bv,x\\<rangle>\\<in>r\" using assms IsLinOrder_def trans_def by (safe, blast)\n      }\n      ultimately have R:\"\\<langle>bu,x\\<rangle>\\<in>r\" \"\\<langle>bv,x\\<rangle>\\<in>r\" by auto\n      moreover\n      {\n        assume AS:\"x=bu\"\n        then have \"\\<langle>bv,bu\\<rangle>\\<in>r\" using R(2) by auto\n        then have \"GreaterOf(r,bu,bv)=bu\" using GreaterOf_def assms IsLinOrder_def\n        antisym_def by auto\n        then have \"False\" using AS BB(3) by auto\n      }\n      moreover\n      {\n        assume AS:\"x=bv\"\n        then have \"\\<langle>bu,bv\\<rangle>\\<in>r\" using R(1) by auto\n        then have \"GreaterOf(r,bu,bv)=bv\" using GreaterOf_def by auto\n        then have \"False\" using AS BB(3) by auto\n      }\n      ultimately have \"\\<langle>bu,x\\<rangle>\\<in>r\" \"\\<langle>bv,x\\<rangle>\\<in>r\"\"x\\<noteq>bu\"\"x\\<noteq>bv\" by auto\n    }\n    moreover\n    {\n      {\n        assume AS:\"\\<langle>cu,cv\\<rangle>\\<in>r\"\n        then have \"SmallerOf(r,cu,cv)=cu\" using SmallerOf_def by auto\n        then have \"\\<langle>x,cu\\<rangle>\\<in>r\" using CC(2) by auto\n        with AS have \"\\<langle>x,cu\\<rangle>\\<in>r\" \"\\<langle>x,cv\\<rangle>\\<in>r\" using assms IsLinOrder_def trans_def by(safe ,blast)\n      }\n      moreover\n      {\n        assume AS:\"\\<langle>cu,cv\\<rangle>\\<notin>r\"\n        then have \"SmallerOf(r,cu,cv)=cv\" using SmallerOf_def by auto\n        then have \"\\<langle>x,cv\\<rangle>\\<in>r\" using CC(2) by auto\n        from AS have \"\\<langle>cv,cu\\<rangle>\\<in>r\" using assms IsLinOrder_def IsTotal_def by auto\n        with \\<open>\\<langle>x,cv\\<rangle>\\<in>r\\<close> have \"\\<langle>x,cv\\<rangle>\\<in>r\" \"\\<langle>x,cu\\<rangle>\\<in>r\" using assms IsLinOrder_def trans_def by(safe ,blast)\n      }\n      ultimately have R:\"\\<langle>x,cv\\<rangle>\\<in>r\" \"\\<langle>x,cu\\<rangle>\\<in>r\" by auto\n      moreover\n      {\n        assume AS:\"x=cv\"\n        then have \"\\<langle>cv,cu\\<rangle>\\<in>r\" using R(2) by auto\n        then have \"SmallerOf(r,cu,cv)=cv\" using SmallerOf_def assms IsLinOrder_def\n        antisym_def by auto\n        then have \"False\" using AS BB(4) by auto\n      }\n      moreover\n      {\n        assume AS:\"x=cu\"\n        then have \"\\<langle>cu,cv\\<rangle>\\<in>r\" using R(1) by auto\n        then have \"SmallerOf(r,cu,cv)=cu\" using SmallerOf_def by auto\n        then have \"False\" using AS BB(4) by auto\n      }\n      ultimately have \"\\<langle>x,cu\\<rangle>\\<in>r\" \"\\<langle>x,cv\\<rangle>\\<in>r\"\"x\\<noteq>cu\"\"x\\<noteq>cv\" by auto\n    }\n    ultimately\n    have \"x\\<in>IntervalX(X,r,bu,cu)\" \"x\\<in>IntervalX(X,r,bv,cv)\" using Order_ZF_2_L1 IntervalX_def\n      assms by auto\n    then have \"x\\<in>IntervalX(X, r, bu, cu) \\<inter> IntervalX(X, r, bv, cv) \" by auto\n  }\n  then show \"IntervalX(X,r,GreaterOf(r,bu,bv),SmallerOf(r,cu,cv)) \\<subseteq> IntervalX(X, r, bu, cu) \\<inter> IntervalX(X, r, bv, cv)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2344
    },
    "2113": {
        "type": "lemma",
        "text": "text\\<open>The open intervals and rays satisfy the base condition.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\"\n  ",
        "using": [
            "inter_two_intervals",
            "assms",
            "SmallerOf_def",
            "inter_lray_interval",
            "GreaterOf_def",
            "inter_rray_interval",
            "dU",
            "inter_lray_rray",
            "inter_lray_lray",
            "inter_rray_rray",
            "dV",
            "S",
            "SatisfiesBaseCondition_def"
        ],
        "statement": "lemma intervals_rays_base_condition:\n  assumes \"IsLinOrder(X,r)\"\n  shows \"{IntervalX(X,r,b,c). \\<langle>b,c\\<rangle>\\<in>X\\<times>X}\\<union>{LeftRayX(X,r,b). b\\<in>X}\\<union>{RightRayX(X,r,b). b\\<in>X} {satisfies the base condition}\"\n",
        "proof": "proof-\n  let ?I=\"{IntervalX(X,r,b,c). \\<langle>b,c\\<rangle>\\<in>X\\<times>X}\"\n  let ?R=\"{RightRayX(X,r,b). b\\<in>X}\"\n  let ?L=\"{LeftRayX(X,r,b). b\\<in>X}\"\n  let ?B=\"{IntervalX(X,r,b,c). \\<langle>b,c\\<rangle>\\<in>X\\<times>X}\\<union>{LeftRayX(X,r,b). b\\<in>X}\\<union>{RightRayX(X,r,b). b\\<in>X}\"\n  {\n    fix U V\n    assume A:\"U\\<in>?B\"\"V\\<in>?B\"\n    then have dU:\"U\\<in>?I\\<or>U\\<in>?L\\<or>U\\<in>?R\"and dV:\"V\\<in>?I\\<or>V\\<in>?L\\<or>V\\<in>?R\" by auto\n    {\n      assume S:\"V\\<in>?I\"\n      {\n        assume \"U\\<in>?I\"\n        with S obtain bu cu bv cv where A:\"U=IntervalX(X,r,bu,cu)\"\"V=IntervalX(X,r,bv,cv)\"\"bu\\<in>X\"\"cu\\<in>X\"\"bv\\<in>X\"\"cv\\<in>X\"\n          by auto\n        then have \"SmallerOf(r,cu,cv)\\<in>X\"\"GreaterOf(r,bu,bv)\\<in>X\" by (cases \"\\<langle>cu,cv\\<rangle>\\<in>r\",simp add:SmallerOf_def A,simp add:SmallerOf_def A,\n          cases \"\\<langle>bu,bv\\<rangle>\\<in>r\",simp add:GreaterOf_def A,simp add:GreaterOf_def A)\n        with A have \"U\\<inter>V\\<in>?B\" using inter_two_intervals assms by auto\n      }\n      moreover\n      {\n        assume \"U\\<in>?L\"\n        with S obtain bu bv cv where A:\"U=LeftRayX(X, r,bu)\"\"V=IntervalX(X,r,bv,cv)\"\"bu\\<in>X\"\"bv\\<in>X\"\"cv\\<in>X\"\n        by auto\n        then have \"SmallerOf(r,bu,cv)\\<in>X\" using SmallerOf_def by (cases \"\\<langle>bu,cv\\<rangle>\\<in>r\",auto)\n        with A have \"U\\<inter>V\\<in>?B\" using inter_lray_interval assms by auto\n      }\n      moreover\n      {\n        assume \"U\\<in>?R\" \n        with S obtain cu bv cv where A:\"U=RightRayX(X,r,cu)\"\"V=IntervalX(X,r,bv,cv)\"\"cu\\<in>X\"\"bv\\<in>X\"\"cv\\<in>X\"\n        by auto\n        then have \"GreaterOf(r,cu,bv)\\<in>X\" using GreaterOf_def by (cases \"\\<langle>cu,bv\\<rangle>\\<in>r\",auto)\n        with A have \"U\\<inter>V\\<in>?B\" using inter_rray_interval assms by auto\n      }\n      ultimately have \"U\\<inter>V\\<in>?B\" using dU by auto\n    }\n    moreover\n    {\n      assume S:\"V\\<in>?L\" \n      {\n        assume \"U\\<in>?I\"\n        with S obtain bu bv cv where A:\"V=LeftRayX(X, r,bu)\"\"U=IntervalX(X,r,bv,cv)\"\"bu\\<in>X\"\"bv\\<in>X\"\"cv\\<in>X\"\n          by auto\n        then have \"SmallerOf(r,bu,cv)\\<in>X\" using SmallerOf_def by (cases \"\\<langle>bu,cv\\<rangle>\\<in>r\", auto)\n        have \"U\\<inter>V=V\\<inter>U\" by auto\n        with A \\<open>SmallerOf(r,bu,cv)\\<in>X\\<close> have \"U\\<inter>V\\<in>?B\" using inter_lray_interval assms by auto\n      }\n      moreover\n      {\n        assume \"U\\<in>?R\"\n        with S obtain bu cv where A:\"V=LeftRayX(X,r,bu)\"\"U=RightRayX(X,r,cv)\"\"bu\\<in>X\"\"cv\\<in>X\"\n        by auto\n        have \"U\\<inter>V=V\\<inter>U\" by auto\n        with A have \"U\\<inter>V\\<in>?B\" using inter_lray_rray assms by auto\n      }\n      moreover\n      {\n        assume \"U\\<in>?L\"\n        with S obtain bu bv where A:\"U=LeftRayX(X,r,bu)\"\"V=LeftRayX(X,r,bv)\"\"bu\\<in>X\"\"bv\\<in>X\"\n        by auto\n        then have \"SmallerOf(r,bu,bv)\\<in>X\" using SmallerOf_def by (cases \"\\<langle>bu,bv\\<rangle>\\<in>r\", auto)\n        with A have \"U\\<inter>V\\<in>?B\" using inter_lray_lray assms by auto\n      }\n      ultimately have \"U\\<inter>V\\<in>?B\" using dU by auto\n    }\n    moreover\n    {\n      assume S:\"V\\<in>?R\"\n      {\n        assume \"U\\<in>?I\"\n        with S obtain cu bv cv where A:\"V=RightRayX(X,r,cu)\"\"U=IntervalX(X,r,bv,cv)\"\"cu\\<in>X\"\"bv\\<in>X\"\"cv\\<in>X\"\n        by auto\n        then have \"GreaterOf(r,cu,bv)\\<in>X\" using GreaterOf_def by (cases \"\\<langle>cu,bv\\<rangle>\\<in>r\",auto)\n        have \"U\\<inter>V=V\\<inter>U\" by auto\n        with A \\<open>GreaterOf(r,cu,bv)\\<in>X\\<close> have \"U\\<inter>V\\<in>?B\" using inter_rray_interval assms by auto\n      }\n      moreover\n      {\n        assume \"U\\<in>?L\" \n        with S obtain bu cv where A:\"U=LeftRayX(X,r,bu)\"\"V=RightRayX(X,r,cv)\"\"bu\\<in>X\"\"cv\\<in>X\"\n        by auto\n        then have \"U\\<inter>V\\<in>?B\" using inter_lray_rray assms by auto\n      }\n      moreover\n      {\n        assume \"U\\<in>?R\" \n        with S obtain cu cv where A:\"U=RightRayX(X,r,cu)\"\"V=RightRayX(X,r,cv)\"\"cu\\<in>X\"\"cv\\<in>X\"\n        by auto\n        then have \"GreaterOf(r,cu,cv)\\<in>X\" using GreaterOf_def by (cases \"\\<langle>cu,cv\\<rangle>\\<in>r\",auto)\n        with A have \"U\\<inter>V\\<in>?B\" using inter_rray_rray assms by auto\n      }\n      ultimately have \"U\\<inter>V\\<in>?B\" using dU by auto\n    }\n    ultimately have  S:\"U\\<inter>V\\<in>?B\" using dV by auto\n    {\n      fix x\n      assume \"x\\<in>U\\<inter>V\"\n      then have \"x\\<in>U\\<inter>V\\<and>U\\<inter>V\\<subseteq>U\\<inter>V\" by auto\n      then have \"\\<exists>W. W\\<in>(?B)\\<and> x\\<in>W \\<and> W \\<subseteq> U\\<inter>V\" using S by blast\n      then have \"\\<exists>W\\<in>(?B). x\\<in>W \\<and> W \\<subseteq> U\\<inter>V\" by blast\n    }\n    hence \"(\\<forall>x \\<in> U\\<inter>V. \\<exists>W\\<in>(?B). x\\<in>W \\<and> W \\<subseteq> U\\<inter>V)\" by auto\n  }\n  then show ?thesis using SatisfiesBaseCondition_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2345
    },
    "2114": {
        "type": "lemma",
        "text": "text\\<open>The topology is defined on the set $X$\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\"\n  ",
        "using": [
            "Top_1_2_L5[OF",
            "LOrdtopology_ROrdtopology_are_topologies(2)[OF",
            "assms]]",
            "LOrdtopology_ROrdtopology_are_topologies(4)[OF",
            "LeftRayX_def",
            "RightRayX_def"
        ],
        "statement": "lemma union_lordtopology_rordtopology:\n  assumes \"IsLinOrder(X,r)\"\n  shows \"\\<Union>(LOrdTopology X r)=X\" and \"\\<Union>(ROrdTopology X r)=X\" \n  ",
        "proof": "using Top_1_2_L5[OF LOrdtopology_ROrdtopology_are_topologies(2)[OF assms]]\n    Top_1_2_L5[OF LOrdtopology_ROrdtopology_are_topologies(4)[OF assms]]\n  unfolding LeftRayX_def RightRayX_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2348
    },
    "2115": {
        "type": "definition",
        "text": "text\\<open>The union of two topologies is not a topology. A way to \novercome this fact is to define the following topology:\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  joinT (\"joinT _\" 90) where\n  \"(\\<forall>T\\<in>M. T{is a topology} \\<and> (\\<forall>Q\\<in>M. \\<Union>Q=\\<Union>T)) \\<Longrightarrow> (joinT M \\<equiv> THE T. (\\<Union>M){is a subbase for} T)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2349
    },
    "2116": {
        "type": "theorem",
        "text": "text\\<open>The first result states that from any family of sets\nwe get a base using finite intersections of them.\nThe second one states that any family of sets is a subbase\nof some topology.\\<close>\n",
        "assumes": "",
        "using": [
            "FinPow_def",
            "MR(5,6)",
            "MR(1,2)",
            "MR(3,4)",
            "AS",
            "N",
            "SatisfiesBaseCondition_def"
        ],
        "statement": "theorem subset_as_subbase:\n  shows \"{\\<Inter>A. A \\<in> FinPow(B)} {satisfies the base condition}\"\n",
        "proof": "proof-\n  {\n    fix U V\n    assume A:\"U\\<in>{\\<Inter>A. A \\<in> FinPow(B)} \\<and> V\\<in>{\\<Inter>A. A \\<in> FinPow(B)}\"\n    then obtain M R where MR:\"Finite(M)\"\"Finite(R)\"\"M\\<subseteq>B\"\"R\\<subseteq>B\"\n    \"U=\\<Inter>M\"\"V=\\<Inter>R\"\n    using FinPow_def by auto\n    {\n      fix x\n      assume AS:\"x\\<in>U\\<inter>V\"\n      then have N:\"M\\<noteq>0\"\"R\\<noteq>0\" using MR(5,6) by auto\n      have \"Finite(M \\<union>R)\" using MR(1,2) by auto\n      moreover\n      have \"M \\<union> R\\<in>Pow(B)\" using MR(3,4) by auto\n      ultimately have \"M\\<union>R\\<in>FinPow(B)\" using FinPow_def by auto\n      then have \"\\<Inter>(M\\<union>R)\\<in>{\\<Inter>A. A \\<in> FinPow(B)}\" by auto\n      moreover\n      from N have \"\\<Inter>(M\\<union>R)\\<subseteq>\\<Inter>M\"\"\\<Inter>(M\\<union>R)\\<subseteq>\\<Inter>R\" by auto\n      then have \"\\<Inter>(M\\<union>R)\\<subseteq>U\\<inter>V\" using MR(5,6) by auto\n      moreover\n      {\n        fix S\n        assume \"S\\<in>M \\<union> R\"\n        then have \"S\\<in>M\\<or>S\\<in>R\" by auto\n        then have \"x\\<in>S\" using AS MR(5,6) by auto\n      }\n      then have \"x\\<in>\\<Inter>(M \\<union> R)\" using N by auto\n      ultimately have \"\\<exists>W\\<in>{\\<Inter>A. A \\<in> FinPow(B)}. x\\<in>W\\<and>W\\<subseteq>U\\<inter>V\" by blast\n    }\n    then have \"(\\<forall>x \\<in> U\\<inter>V. \\<exists>W\\<in>{\\<Inter>A. A \\<in> FinPow(B)}. x\\<in>W \\<and> W \\<subseteq> U\\<inter>V)\" by auto\n  }\n  then have \"\\<forall>U V. ((U\\<in>{\\<Inter>A. A \\<in> FinPow(B)} \\<and> V\\<in>{\\<Inter>A. A \\<in> FinPow(B)}) \\<longrightarrow> \n    (\\<forall>x \\<in> U\\<inter>V. \\<exists>W\\<in>{\\<Inter>A. A \\<in> FinPow(B)}. x\\<in>W \\<and> W \\<subseteq> U\\<inter>V))\" by auto\n  then show \"{\\<Inter>A. A \\<in> FinPow(B)} {satisfies the base condition}\"\n    using SatisfiesBaseCondition_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2350
    },
    "2117": {
        "type": "theorem",
        "text": "text\\<open>A subbase defines a unique topology.\\<close>\n",
        "assumes": "assumes \"B {is a subbase for} T\" and \"B {is a subbase for} S\" \n  ",
        "using": [
            "IsAsubBaseFor_def",
            "assms",
            "same_base_same_top"
        ],
        "statement": "theorem same_subbase_same_top:\n  assumes \"B {is a subbase for} T\" and \"B {is a subbase for} S\" \n  shows \"T = S\"\n  ",
        "proof": "using IsAsubBaseFor_def assms same_base_same_top\n  by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2351
    },
    "2118": {
        "type": "definition",
        "text": "text\\<open>It is already defined what is a compact topological space, but the is a\ngeneralization which may be useful sometimes.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsCompactOfCard (\"_{is compact of cardinal}_ {in}_\" 90)\n  where \"K{is compact of cardinal} Q{in}T \\<equiv> (Card(Q) \\<and> K \\<subseteq> \\<Union>T \\<and> \n  (\\<forall> M\\<in>Pow(T). K \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists> N \\<in> Pow(M). K \\<subseteq> \\<Union>N \\<and> N\\<prec>Q)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2352
    },
    "2119": {
        "type": "lemma",
        "text": "text\\<open>The usual compact property is the one defined over the cardinal\nof the natural numbers.\\<close>\n",
        "assumes": "",
        "using": [
            "IsCompact_def",
            "FinPow_def",
            "Finite_def",
            "n_lesspoll_nat",
            "lesspoll_def",
            "eq_lepoll_trans",
            "eqpoll_sym",
            "eqpoll_trans",
            "IsCompactOfCard_def",
            "Card_nat",
            "lesspoll_nat_is_Finite"
        ],
        "statement": "lemma Compact_is_card_nat:\n  shows \"K{is compact in}T \\<longleftrightarrow> (K{is compact of cardinal} nat {in}T)\"\n",
        "proof": "proof\n  {\n    assume \"K{is compact in}T\"\n    then have sub:\"K \\<subseteq> \\<Union>T\"  and reg:\"(\\<forall> M\\<in>Pow(T). K \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists> N \\<in> FinPow(M). K \\<subseteq> \\<Union>N))\"\n      using IsCompact_def by auto\n    {\n      fix M\n      assume \"M\\<in>Pow(T)\"\"K\\<subseteq>\\<Union>M\"\n      with reg obtain N where \"N\\<in>FinPow(M)\" \"K\\<subseteq>\\<Union>N\" by blast\n      then have \"Finite(N)\" using FinPow_def by auto\n      then obtain n where A:\"n\\<in>nat\"\"N \\<approx>n\" using Finite_def by auto\n      from A(1) have \"n\\<prec>nat\" using n_lesspoll_nat by auto\n      with A(2) have \"N\\<lesssim>nat\" using lesspoll_def eq_lepoll_trans by auto\n      moreover\n      {\n        assume \"N \\<approx>nat\"\n        then have \"nat \\<approx> N\" using eqpoll_sym by auto \n        with A(2) have \"nat \\<approx>n\" using eqpoll_trans by blast\n        then have \"n \\<approx>nat\" using eqpoll_sym by auto\n        with \\<open>n\\<prec>nat\\<close> have \"False\" using lesspoll_def by auto\n      }\n      then have \"~(N \\<approx>nat)\" by auto\n      with calculation \\<open>K\\<subseteq>\\<Union>N\\<close>\\<open>N\\<in>FinPow(M)\\<close> have \"N\\<prec>nat\"\"K\\<subseteq>\\<Union>N\"\"N\\<in>Pow(M)\" using lesspoll_def\n        FinPow_def by auto\n      hence \"(\\<exists> N \\<in> Pow(M). K \\<subseteq> \\<Union>N \\<and> N\\<prec>nat)\" by auto\n    }\n    with sub show \"K{is compact of cardinal} nat {in}T\" using IsCompactOfCard_def Card_nat by auto\n  }\n  {\n    assume \"(K{is compact of cardinal} nat {in}T)\"\n    then have sub:\"K\\<subseteq>\\<Union>T\" and reg:\"(\\<forall> M\\<in>Pow(T). K \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists> N \\<in> Pow(M). K \\<subseteq> \\<Union>N \\<and> N\\<prec>nat))\"\n      using IsCompactOfCard_def by auto\n    {\n      fix M\n      assume \"M\\<in>Pow(T)\"\"K\\<subseteq>\\<Union>M\"\n      with reg have \"(\\<exists> N \\<in> Pow(M). K \\<subseteq> \\<Union>N \\<and> N\\<prec>nat)\" by auto\n      then obtain N where \"N\\<in>Pow(M)\"\"K\\<subseteq>\\<Union>N\"\"N\\<prec>nat\" by blast\n      then have \"N\\<in>FinPow(M)\"\"K\\<subseteq>\\<Union>N\" using lesspoll_nat_is_Finite FinPow_def by auto\n      hence \"\\<exists>N\\<in>FinPow(M). K\\<subseteq>\\<Union>N\" by auto\n    }\n    with sub show \"K{is compact in}T\" using IsCompact_def by auto\n  }\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2353
    },
    "2120": {
        "type": "definition",
        "text": "text\\<open>Another property of this kind widely used is the Lindeloef property;\nit is the one on the successor of the natural numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsLindeloef  (\"_{is lindeloef in}_\" 90) where\n  \"K {is lindeloef in} T\\<equiv>K{is compact of cardinal}csucc(nat){in}T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2354
    },
    "2121": {
        "type": "theorem",
        "text": "text\\<open>However, if the topology has not many open sets, then the topological\nspace is indeed compact.\\<close>\n",
        "assumes": "assumes \"Card(Q)\" \"T\\<prec>Q\" \"K\\<subseteq>\\<Union>T\"\n  ",
        "using": [
            "subset_imp_lepoll",
            "lesspoll_trans1"
        ],
        "statement": "theorem card_top_comp:\n  assumes \"Card(Q)\" \"T\\<prec>Q\" \"K\\<subseteq>\\<Union>T\"\n  shows \"(K){is compact of cardinal}Q{in}T\"\n",
        "proof": "proof-\n  {      \n    fix M assume M:\"M\\<subseteq>T\" \"K\\<subseteq>\\<Union>M\"\n    from M(1) assms(2) have \"M\\<prec>Q\" using subset_imp_lepoll lesspoll_trans1 by blast\n    with M(2) have \"\\<exists>N\\<in>Pow(M). K\\<subseteq>\\<Union>N \\<and> N\\<prec>Q\" by auto\n  }\n  with assms(1,3) show ?thesis unfolding IsCompactOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2355
    },
    "2122": {
        "type": "theorem",
        "text": "text\\<open>The union of two compact sets, is compact; of any cardinality.\\<close>\n",
        "assumes": "assumes \"K{is compact of cardinal}Q{in}T\" \"K1{is compact of cardinal}Q{in}T\" \"InfCard(Q)\"\n  ",
        "using": [
            "assms(1)",
            "IsCompactOfCard_def",
            "assms(2)",
            "assms",
            "assms(3)",
            "less_less_imp_un_less"
        ],
        "statement": "theorem union_compact:\n  assumes \"K{is compact of cardinal}Q{in}T\" \"K1{is compact of cardinal}Q{in}T\" \"InfCard(Q)\"\n  shows \"(K \\<union> K1){is compact of cardinal}Q{in}T\" unfolding IsCompactOfCard_def\n",
        "proof": "proof(safe)\n  from assms(1) show \"Card(Q)\" unfolding IsCompactOfCard_def by auto\n  fix x assume \"x\\<in>K\" then show \"x\\<in>\\<Union>T\" using assms(1) unfolding IsCompactOfCard_def by blast\nnext\n  fix x assume \"x\\<in>K1\" then show \"x\\<in>\\<Union>T\" using assms(2) unfolding IsCompactOfCard_def by blast\nnext\n  fix M assume \"M\\<subseteq>T\" \"K\\<union>K1\\<subseteq>\\<Union>M\"\n  then have \"K\\<subseteq>\\<Union>M\"\"K1\\<subseteq>\\<Union>M\" by auto\n  with \\<open>M\\<subseteq>T\\<close> have \"\\<exists>N\\<in>Pow(M). K \\<subseteq> \\<Union>N \\<and> N \\<prec> Q\"\"\\<exists>N\\<in>Pow(M). K1 \\<subseteq> \\<Union>N \\<and> N \\<prec> Q\" using assms unfolding IsCompactOfCard_def\n    by auto\n  then obtain NK NK1 where \"NK\\<in>Pow(M)\"\"NK1\\<in>Pow(M)\"\"K \\<subseteq> \\<Union>NK\"\"K1 \\<subseteq> \\<Union>NK1\"\"NK \\<prec> Q\"\"NK1 \\<prec> Q\" by auto\n  then have \"NK\\<union>NK1 \\<prec> Q\"\"K\\<union>K1\\<subseteq>\\<Union>(NK\\<union>NK1)\"\"NK\\<union>NK1\\<in>Pow(M)\" using assms(3) less_less_imp_un_less by auto\n  then show \"\\<exists>N\\<in>Pow(M). K\\<union>K1\\<subseteq>\\<Union>N \\<and> N\\<prec>Q\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2356
    },
    "2123": {
        "type": "theorem",
        "text": "text\\<open>If a set is compact of cardinality \\<open>Q\\<close> for some topology,\nit is compact of cardinality \\<open>Q\\<close> for every coarser topology.\\<close>\n",
        "assumes": "assumes \"T1\\<subseteq>T\" and \"\\<Union>T1=\\<Union>T\" and \"(K){is compact of cardinal}Q{in}T\"\n  ",
        "using": [
            "assms(1)",
            "assms(3)",
            "IsCompactOfCard_def",
            "assms(3,2)"
        ],
        "statement": "theorem compact_coarser:\n  assumes \"T1\\<subseteq>T\" and \"\\<Union>T1=\\<Union>T\" and \"(K){is compact of cardinal}Q{in}T\"\n  shows \"(K){is compact of cardinal}Q{in}T1\"\n",
        "proof": "proof-\n  {\n    fix M\n    assume AS:\"M\\<in>Pow(T1)\"\"K\\<subseteq>\\<Union>M\"\n    then have \"M\\<in>Pow(T)\"\"K\\<subseteq>\\<Union>M\" using assms(1) by auto\n    then have \"\\<exists>N\\<in>Pow(M).K\\<subseteq>\\<Union>N\\<and>N\\<prec>Q\" using assms(3) unfolding IsCompactOfCard_def by auto\n  }\n  then show \"(K){is compact of cardinal}Q{in}T1\" using assms(3,2) unfolding IsCompactOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2357
    },
    "2124": {
        "type": "theorem",
        "text": "text\\<open>If some set is compact for some cardinal, it is compact for any greater cardinal.\\<close>\n",
        "assumes": "assumes \"Q\\<lesssim>Q1\" and \"(K){is compact of cardinal}Q{in}T\" and \"Card(Q1)\"\n  ",
        "using": [
            "assms(2)",
            "IsCompactOfCard_def",
            "assms(1)",
            "lesspoll_trans2",
            "assms(2,3)"
        ],
        "statement": "theorem compact_greater_card:\n  assumes \"Q\\<lesssim>Q1\" and \"(K){is compact of cardinal}Q{in}T\" and \"Card(Q1)\"\n  shows \"(K){is compact of cardinal}Q1{in}T\"\n",
        "proof": "proof-\n  {\n    fix M\n    assume AS: \"M\\<in>Pow(T)\"\"K\\<subseteq>\\<Union>M\"\n    then have \"\\<exists>N\\<in>Pow(M).K\\<subseteq>\\<Union>N\\<and>N\\<prec>Q\" using assms(2) unfolding IsCompactOfCard_def by auto\n    then have \"\\<exists>N\\<in>Pow(M).K\\<subseteq>\\<Union>N\\<and>N\\<prec>Q1\" using assms(1) lesspoll_trans2\n      unfolding IsCompactOfCard_def by auto\n  }\n  then show ?thesis using assms(2,3) unfolding IsCompactOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2358
    },
    "2125": {
        "type": "theorem",
        "text": "text\\<open>A closed subspace of a compact space of any cardinality, is also\ncompact of the same cardinality.\\<close>\n",
        "assumes": "assumes \"K {is compact of cardinal} Q {in} T\"\n    and \"R {is closed in} T\"\n  ",
        "using": [
            "assms(2)",
            "IsClosed_def",
            "assms(1)",
            "IsCompactOfCard_def",
            "cub(1)",
            "cub(2)",
            "subset_imp_lepoll",
            "lesspoll_trans1"
        ],
        "statement": "theorem compact_closed:\n  assumes \"K {is compact of cardinal} Q {in} T\"\n    and \"R {is closed in} T\"\n  shows \"(K\\<inter>R) {is compact of cardinal} Q {in} T\"\n",
        "proof": "proof-\n  {\n    fix M\n    assume AS:\"M\\<in>Pow(T)\"\"K\\<inter>R\\<subseteq>\\<Union>M\"\n    have \"\\<Union>T-R\\<in>T\" using assms(2) IsClosed_def by auto\n    have \"K-R\\<subseteq>(\\<Union>T-R)\" using assms(1) IsCompactOfCard_def by auto\n    with \\<open>\\<Union>T-R\\<in>T\\<close> have \"K\\<subseteq>\\<Union>(M \\<union>{\\<Union>T-R})\" and \"M \\<union>{\\<Union>T-R}\\<in>Pow(T)\"\n    proof (safe)\n      {\n        fix x\n        assume \"x\\<in>M\"\n        with AS(1) show \"x\\<in>T\" by auto\n      }\n      {\n        fix x\n        assume \"x\\<in>K\"\n        have \"x\\<in>R\\<or>x\\<notin>R\" by auto\n        with \\<open>x\\<in>K\\<close> have \"x\\<in>K\\<inter>R\\<or>x\\<in>K-R\" by auto\n        with AS(2) \\<open>K-R\\<subseteq>(\\<Union>T-R)\\<close> have \"x\\<in>\\<Union>M\\<or>x\\<in>(\\<Union>T-R)\" by auto\n        then show \"x\\<in>\\<Union>(M \\<union>{\\<Union>T-R})\" by auto\n      }\n    qed\n    with assms(1) have \"\\<exists>N\\<in>Pow(M\\<union>{\\<Union>T-R}). K \\<subseteq> \\<Union>N \\<and> N \\<prec> Q\" unfolding IsCompactOfCard_def by auto\n    then obtain N where cub:\"N\\<in>Pow(M\\<union>{\\<Union>T-R})\" \"K\\<subseteq>\\<Union>N\" \"N\\<prec>Q\" by auto\n    have \"N-{\\<Union>T-R}\\<in>Pow(M)\"\"K\\<inter>R\\<subseteq>\\<Union>(N-{\\<Union>T-R})\" \"N-{\\<Union>T-R}\\<prec>Q\"\n    proof (safe)\n      {\n        fix x\n        assume \"x\\<in>N\"\"x\\<notin>M\"\n        then show \"x=\\<Union>T-R\" using cub(1) by auto\n      }\n      {\n        fix x\n        assume \"x\\<in>K\"\"x\\<in>R\"\n        then have \"x\\<notin>\\<Union>T-R\"\"x\\<in>K\" by auto\n        then show \"x\\<in>\\<Union>(N-{\\<Union>T-R})\" using cub(2) by blast\n      }\n      have \"N-{\\<Union>T-R}\\<subseteq>N\" by auto\n      with cub(3) show \"N-{\\<Union>T-R}\\<prec>Q\" using subset_imp_lepoll lesspoll_trans1 by blast\n    qed\n    then have \"\\<exists>N\\<in>Pow(M). K\\<inter>R\\<subseteq>\\<Union>N \\<and> N\\<prec>Q\" by auto\n  }\n  then have \"\\<forall>M\\<in>Pow(T). (K \\<inter> R \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists>N\\<in>Pow(M). K \\<inter> R \\<subseteq> \\<Union>N \\<and> N \\<prec> Q))\" by auto\n  then show ?thesis using IsCompactOfCard_def assms(1) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2359
    },
    "2126": {
        "type": "definition",
        "text": "text\\<open>The properties of numerability deal with cardinals of some sets\nbuilt from the topology. The properties which are normally used\nare the ones related to the cardinal of the natural numbers or its successor.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsFirstOfCard (\"_ {is of first type of cardinal}_\" 90) where\n  \"(T {is of first type of cardinal} Q) \\<equiv> \\<forall>x\\<in>\\<Union>T. (\\<exists>B. (B {is a base for} T) \\<and> ({b\\<in>B. x\\<in>b} \\<prec> Q))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2360
    },
    "2127": {
        "type": "theorem",
        "text": "text\\<open>If a set is of second type of cardinal \\<open>Q\\<close>, then it is of\nfirst type of that same cardinal.\\<close>\n",
        "assumes": "assumes \"T{is of second type of cardinal}Q\"\n  ",
        "using": [
            "IsSecondOfCard_def",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "IsFirstOfCard_def"
        ],
        "statement": "theorem second_imp_first:\n  assumes \"T{is of second type of cardinal}Q\"\n  shows \"T{is of first type of cardinal}Q\"\n",
        "proof": "proof-\n  from assms have \"\\<exists>B. (B {is a base for} T) \\<and> (B \\<prec> Q)\" using IsSecondOfCard_def by auto\n  then obtain B where base:\"(B {is a base for} T) \\<and> (B \\<prec> Q)\" by auto\n  {\n    fix x\n    assume \"x\\<in>\\<Union>T\"\n    have \"{b\\<in>B. x\\<in>b}\\<subseteq>B\" by auto\n    then have \"{b\\<in>B. x\\<in>b}\\<lesssim>B\" using subset_imp_lepoll by auto\n    with base have \"{b\\<in>B. x\\<in>b}\\<prec>Q\" using lesspoll_trans1 by auto\n    with base have \"(B {is a base for} T) \\<and> {b\\<in>B. x\\<in>b}\\<prec>Q\" by auto\n  }\n  then have \"\\<forall>x\\<in>\\<Union>T. \\<exists>B. (B {is a base for} T) \\<and> {b\\<in>B. x\\<in>b}\\<prec>Q\" by auto\n  then show ?thesis using IsFirstOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2361
    },
    "2128": {
        "type": "lemma",
        "text": "text\\<open>A set is dense iff it intersects all non-empty, open sets of the topology.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\" and \"A\\<subseteq>\\<Union>T\"\n  ",
        "using": [
            "topology0.cl_inter_neigh",
            "topology0_def",
            "AS",
            "topology0.inter_neigh_cl",
            "topology0.Top_3_L11(1)"
        ],
        "statement": "lemma dense_int_open:\n  assumes \"T{is a topology}\" and \"A\\<subseteq>\\<Union>T\"\n  shows \"Closure(A,T)=\\<Union>T \\<longleftrightarrow> (\\<forall>U\\<in>T. U\\<noteq>0 \\<longrightarrow> A\\<inter>U\\<noteq>0)\"\n",
        "proof": "proof\n  assume AS:\"Closure(A,T)=\\<Union>T\"\n  {\n    fix U\n    assume Uopen:\"U\\<in>T\" and \"U\\<noteq>0\"\n    then have \"U\\<inter>\\<Union>T\\<noteq>0\" by auto\n    with AS have \"U\\<inter>Closure(A,T) \\<noteq>0\" by auto\n    with assms Uopen have \"U\\<inter>A\\<noteq>0\" using topology0.cl_inter_neigh topology0_def by blast\n  }\n  then show \"\\<forall>U\\<in>T. U\\<noteq>0 \\<longrightarrow> A\\<inter>U\\<noteq>0\" by auto\n  next\n  assume AS:\"\\<forall>U\\<in>T. U\\<noteq>0 \\<longrightarrow> A\\<inter>U\\<noteq>0\"\n  {\n    fix x\n    assume A:\"x\\<in>\\<Union>T\"\n    then have \"\\<forall>U\\<in>T. x\\<in>U \\<longrightarrow> U\\<inter>A\\<noteq>0\" using AS by auto\n    with assms A have \"x\\<in>Closure(A,T)\" using topology0.inter_neigh_cl topology0_def by auto\n  }\n  then have \"\\<Union>T\\<subseteq>Closure(A,T)\" by auto\n  with assms show \"Closure(A,T)=\\<Union>T\" using topology0.Top_3_L11(1) topology0_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2362
    },
    "2129": {
        "type": "theorem",
        "text": "text\\<open>If a topology is of second type of cardinal \\<open>csucc(Q)\\<close>, then it is separable\nof the same cardinal. This result makes use of the axiom of choice for the cardinal\n \\<open>Q\\<close> on subsets of \\<open>\\<Union>T\\<close>.\\<close>\n",
        "assumes": "assumes \"T{is of second type of cardinal}csucc(Q)\" \n    and \"{the axiom of} Q {choice holds for subsets} \\<Union>T\"\n    and \"T{is a topology}\"\n  ",
        "using": [
            "IsSecondOfCard_def",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "base_sets_open",
            "AxiomCardinalChoice_def",
            "Card_less_csucc_eq_le",
            "car",
            "Top_1_2_L1",
            "base",
            "f2",
            "baseOpen",
            "dense_int_open",
            "assms(3)",
            "f",
            "range_of_fun",
            "fun_is_surj",
            "surj_fun_inv_2[of",
            "\"f\"\"?B\"\"range(f)\"\"Q\"]",
            "prec",
            "Card_is_Ord",
            "apply_rangeI[OF",
            "ffun]",
            "lepoll_trans",
            "IsSeparableOfCard_def"
        ],
        "statement": "theorem Q_choice_imp_second_imp_separable:\n  assumes \"T{is of second type of cardinal}csucc(Q)\" \n    and \"{the axiom of} Q {choice holds for subsets} \\<Union>T\"\n    and \"T{is a topology}\"\n  shows \"T{is separable of cardinal}csucc(Q)\"\n",
        "proof": "proof-\n  from assms(1) have \"\\<exists>B. (B {is a base for} T) \\<and> (B \\<prec> csucc(Q))\" using IsSecondOfCard_def by auto\n  then obtain B where base:\"(B {is a base for} T) \\<and> (B \\<prec> csucc(Q))\" by auto\n  let ?N=\"\\<lambda>b\\<in>B. b\"\n  let ?B=\"B-{0}\"\n  have \"B-{0}\\<subseteq>B\" by auto\n  with base have prec:\"B-{0}\\<prec>csucc(Q)\" using subset_imp_lepoll lesspoll_trans1 by blast\n  from base have baseOpen:\"\\<forall>b\\<in>B. ?N`b\\<in>T\" using base_sets_open by auto\n  from assms(2) have car:\"Card(Q)\" and reg:\"(\\<forall> M N. (M \\<lesssim>Q \\<and>  (\\<forall>t\\<in>M. N`t\\<noteq>0 \\<and> N`t\\<subseteq>\\<Union>T)) \\<longrightarrow> (\\<exists>f. f:Pi(M,\\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. f`t\\<in>N`t)))\"\n  using AxiomCardinalChoice_def by auto\n  then have \"(?B \\<lesssim>Q \\<and>  (\\<forall>t\\<in>?B. ?N`t\\<noteq>0 \\<and> ?N`t\\<subseteq>\\<Union>T)) \\<longrightarrow> (\\<exists>f. f:Pi(?B,\\<lambda>t. ?N`t) \\<and> (\\<forall>t\\<in>?B. f`t\\<in>?N`t))\" by blast\n  with prec have \"(\\<forall>t\\<in>?B. ?N`t\\<subseteq>\\<Union>T) \\<longrightarrow> (\\<exists>f. f:Pi(?B,\\<lambda>t. ?N`t) \\<and> (\\<forall>t\\<in>?B. f`t\\<in>?N`t))\" using Card_less_csucc_eq_le car by auto\n  with baseOpen have \"\\<exists>f. f:Pi(?B,\\<lambda>t. ?N`t) \\<and> (\\<forall>t\\<in>?B. f`t\\<in>?N`t)\" by blast\n  then obtain f where f:\"f:Pi(?B,\\<lambda>t. ?N`t)\" and f2:\"\\<forall>t\\<in>?B. f`t\\<in>?N`t\" by auto\n  {\n    fix U\n    assume \"U\\<in>T\" and \"U\\<noteq>0\"\n    then obtain b where A1:\"b\\<in>B-{0}\" and \"b\\<subseteq>U\" using Top_1_2_L1 base by blast\n    with f2 have \"f`b\\<in>U\" by auto\n    with A1 have \"{f`b. b\\<in>?B}\\<inter>U\\<noteq>0\" by auto\n  }\n  then have r:\"\\<forall>U\\<in>T. U\\<noteq>0 \\<longrightarrow> {f`b. b\\<in>?B}\\<inter>U\\<noteq>0\" by auto\n  have \"{f`b. b\\<in>?B}\\<subseteq>\\<Union>T\" using f2 baseOpen by auto\n  moreover\n  with r have \"Closure({f`b. b\\<in>?B},T)=\\<Union>T\" using dense_int_open assms(3) by auto\n  moreover\n  have ffun:\"f:?B\\<rightarrow>range(f)\" using f range_of_fun by auto\n  then have \"f\\<in>surj(?B,range(f))\" using fun_is_surj by auto\n  then have des1:\"range(f)\\<lesssim>?B\" using surj_fun_inv_2[of \"f\"\"?B\"\"range(f)\"\"Q\"] prec Card_less_csucc_eq_le car\n    Card_is_Ord by auto\n  then have \"{f`b. b\\<in>?B}\\<subseteq>range(f)\" using apply_rangeI[OF ffun] by auto\n  then have \"{f`b. b\\<in>?B}\\<lesssim>range(f)\" using subset_imp_lepoll by auto\n  with des1 have \"{f`b. b\\<in>?B}\\<lesssim>?B\" using lepoll_trans by blast\n  with prec have \"{f`b. b\\<in>?B}\\<prec>csucc(Q)\" using lesspoll_trans1 by auto\n  ultimately show ?thesis using IsSeparableOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2363
    },
    "2130": {
        "type": "theorem",
        "text": "text\\<open>The next theorem resolves that the axiom of \\<open>Q\\<close> choice for subsets\nof \\<open>\\<Union>T\\<close> is necessary for second type spaces to be separable of the same cardinal\n\\<open>csucc(Q)\\<close>.\\<close>\n",
        "assumes": "assumes \"\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> (T{is separable of cardinal}csucc(Q))\" \n  and \"Card(Q)\"\n  ",
        "using": [],
        "statement": "theorem second_imp_separable_imp_Q_choice:\n  assumes \"\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> (T{is separable of cardinal}csucc(Q))\" \n  and \"Card(Q)\"\n  shows \"{the axiom of} Q {choice holds}\"\nproof-\n  {\n    fix N M\n    assume AS:\"M \\<lesssim>Q \\<and>  (\\<forall>t\\<in>M. N`t\\<noteq>0)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2364
    },
    "2131": {
        "type": "theorem",
        "text": "text\\<open>Here is the equivalence from the two previous results.\\<close>\n",
        "assumes": "assumes \"Card(Q)\"\n  ",
        "using": [
            "Q_choice_imp_second_imp_separable",
            "choice_subset_imp_choice",
            "second_imp_separable_imp_Q_choice",
            "assms"
        ],
        "statement": "theorem Q_choice_eq_secon_imp_sepa:\n  assumes \"Card(Q)\"\n  shows \"(\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> (T{is separable of cardinal}csucc(Q)))\n    \\<longleftrightarrow>({the axiom of} Q {choice holds})\"\n  ",
        "proof": "using Q_choice_imp_second_imp_separable choice_subset_imp_choice\n  using second_imp_separable_imp_Q_choice assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2365
    },
    "2132": {
        "type": "lemma",
        "text": "text\\<open>Given a base injective with a set, then we can find a\nbase whose elements are indexed by that set.\\<close>\n",
        "assumes": "assumes \"B \\<lesssim>Q\" \"B {is a base for}T\"\n  ",
        "using": [
            "function_imp_Pi[of",
            "\"?ff\"]",
            "apply_equality[OF",
            "_",
            "fun]",
            "f_def",
            "inj_def",
            "AS(1,2)",
            "inj_bij_range",
            "a",
            "rr]",
            "apply_type[OF",
            "rr",
            "a].",
            "from",
            "ig",
            "have",
            "t:\"?ff`t\\<in>Q\"",
            "a]",
            "function_apply_equality[OF",
            "FN]",
            "left_inverse[OF",
            "injj",
            "t(1)",
            "apply_funtype[OF",
            "inj_is_fun[OF",
            "bij_is_inj[OF",
            "bij_converse_bij[OF",
            "bij]]]",
            "AS]",
            "R(3,2)",
            "R(1,2)",
            "base_no_0[of",
            "\"B\"\"T\"]",
            "assms(2)",
            "\"B",
            "\\<union>{0}\"\"T\"]"
        ],
        "statement": "lemma base_to_indexed_base:\n  assumes \"B \\<lesssim>Q\" \"B {is a base for}T\"\n  shows \"\\<exists>N. {N`i. i\\<in>Q}{is a base for}T\"\n",
        "proof": "proof-\n  from assms obtain f where f_def:\"f\\<in>inj(B,Q)\" unfolding lepoll_def by auto\n  let ?ff=\"{\\<langle>b,f`b\\<rangle>. b\\<in>B}\"\n  have \"domain(?ff)=B\" by auto\n  moreover\n  have \"relation(?ff)\" unfolding relation_def by auto\n  moreover\n  have \"function(?ff)\" unfolding function_def by auto\n  ultimately\n  have fun:\"?ff:B\\<rightarrow>range(?ff)\" using function_imp_Pi[of \"?ff\"] by auto\n  then have injj:\"?ff\\<in>inj(B,range(?ff))\" unfolding inj_def\n  proof\n    {\n      fix w x\n      assume AS:\"w\\<in>B\"\"x\\<in>B\"\"{\\<langle>b, f ` b\\<rangle> . b \\<in> B} ` w = {\\<langle>b, f ` b\\<rangle> . b \\<in> B} ` x\"\n      then have \"f`w=f`x\" using apply_equality[OF _ fun] by auto\n      then have \"w=x\" using f_def inj_def AS(1,2) by auto\n    }\n    then show \"\\<forall>w\\<in>B. \\<forall>x\\<in>B. {\\<langle>b, f ` b\\<rangle> . b \\<in> B} ` w = {\\<langle>b, f ` b\\<rangle> . b \\<in> B} ` x \\<longrightarrow> w = x\" by auto\n  qed\n  then have bij:\"?ff\\<in>bij(B,range(?ff))\" using inj_bij_range by auto\n  from fun have \"range(?ff)={f`b. b\\<in>B}\" by auto\n  with f_def have ran:\"range(?ff)\\<subseteq>Q\" using inj_def by auto\n  let ?N=\"{\\<langle>i,(if i\\<in>range(?ff) then converse(?ff)`i else 0)\\<rangle>. i\\<in>Q}\"\n  have FN:\"function(?N)\" unfolding function_def by auto\n  have \"B \\<subseteq>{?N`i. i\\<in>Q}\"\n  proof\n    fix t\n    assume a:\"t\\<in>B\"\n    from bij have rr:\"?ff:B\\<rightarrow>range(?ff)\" unfolding bij_def inj_def by auto\n    have ig:\"?ff`t=f`t\" using a apply_equality[OF _ rr] by auto\n    have r:\"?ff`t\\<in>range(?ff)\" using apply_type[OF rr a].\n    from ig have t:\"?ff`t\\<in>Q\" using apply_type[OF _ a] f_def unfolding inj_def by auto\n    with r have \"?N`(?ff`t)=converse(?ff)`(?ff`t)\" using function_apply_equality[OF _ FN] by auto\n    then have \"?N`(?ff`t)=t\" using left_inverse[OF injj a] by auto\n    then have \"t=?N`(?ff`t)\" by auto\n    then have \"\\<exists>i\\<in>Q. t=?N`i\" using t(1) by auto\n    then show \"t\\<in>{?N`i. i\\<in>Q}\" by simp\n  qed\n  moreover\n  have \"\\<forall>r\\<in>{?N`i. i\\<in>Q}-B. r=0\"\n  proof\n    fix r\n    assume \"r\\<in>{?N`i. i\\<in>Q}-B\"\n    then obtain j where R:\"j\\<in>Q\"\"r=?N`j\"\"r\\<notin>B\" by auto\n    {\n      assume AS:\"j\\<in>range(?ff)\"\n      with R(1) have \"?N`j=converse(?ff)`j\" using function_apply_equality[OF _ FN] by auto\n      then have \"?N`j\\<in>B\" using  apply_funtype[OF inj_is_fun[OF bij_is_inj[OF bij_converse_bij[OF bij]]] AS]\n      by auto\n      then have \"False\" using R(3,2) by auto\n    }\n    then have \"j\\<notin>range(?ff)\" by auto\n    then show \"r=0\" using function_apply_equality[OF _ FN] R(1,2) by auto\n  qed\n  ultimately have \"{?N`i. i\\<in>Q}=B\\<or>{?N`i. i\\<in>Q}=B \\<union>{0}\" by blast\n  moreover\n  have \"(B \\<union>{0})-{0}=B-{0}\" by blast\n  then have \"(B \\<union>{0})-{0} {is a base for}T\" using base_no_0[of \"B\"\"T\"] assms(2) by auto\n  then have \"B \\<union>{0} {is a base for}T\" using base_no_0[of \"B \\<union>{0}\"\"T\"] by auto\n  ultimately\n  have \"{?N`i. i\\<in>Q}{is a base for}T\" using assms(2) by auto\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2366
    },
    "2133": {
        "type": "theorem",
        "text": "text\\<open>If the axiom of \\<open>Q\\<close> choice holds, then any topology\nof second type of cardinal \\<open>csucc(Q)\\<close> is compact of cardinal \\<open>csucc(Q)\\<close>\\<close>\n",
        "assumes": "assumes \"{the axiom of} Q {choice holds for subsets} (Pow(Q))\"\n    \"T{is of second type of cardinal}csucc(Q)\"\n    \"T{is a topology}\"\n  ",
        "using": [
            "AxiomCardinalChoice_def",
            "Card_less_csucc_eq_le",
            "CC",
            "lam_type[of",
            "\"M\"\"\\<lambda>U.",
            "{i",
            "\\<in>",
            "Q",
            ".",
            "N`(i)",
            "\\<subseteq>",
            "U}\"\"%t.",
            "Pow(Q)\"]",
            "assms(3)",
            "topology0.Top_2_L3[of",
            "\"T\"]",
            "topology0_def[of",
            "interior_set_base_topology",
            "base",
            "UN(1)",
            "S(3)",
            "S(2)",
            "AS(3)",
            "j",
            "UN(2)",
            "j(2)",
            "subset_imp_lepoll",
            "reg[of",
            "\"?M\"\"?X\"]",
            "inj",
            "inj_def",
            "YY",
            "ex1I[of",
            "\"%Y.",
            "Y\\<in>M\\<and>",
            "f`m=?\\<alpha>`Y\",OF",
            "Y",
            "r]",
            "ex1YY",
            "theI[of",
            "f`m=?\\<alpha>`Y\"]",
            "ree",
            "f(2)[OF",
            "D]",
            "QQ",
            "t",
            "inj_apply_equality[OF",
            "inj]",
            "r",
            "tt[OF",
            "r(1)]",
            "r(1)",
            "point_open_base_neigh[OF",
            "base,of",
            "\"U\"\"x\"]",
            "BB(1)",
            "BC(1)",
            "BC(3)",
            "subset_trans[of",
            "\"\\<Union>T\"\"(\\<Union>m\\<in>?M.",
            "N`(m))\"\"(\\<Union>m\\<in>?M.",
            "?YYm`m)\"]",
            "function_imp_Pi[of",
            "\"?YYm\"]",
            "fun_is_surj[OF",
            "fun]",
            "lepoll_trans",
            "function_apply_Pair[OF",
            "f]",
            "d",
            "apply_equality[OF",
            "Card_less_csucc_eq_le[OF",
            "CC]",
            "IsCompactOfCard_def",
            "Card_csucc",
            "Card_is_Ord"
        ],
        "statement": "theorem compact_of_cardinal_Q:\n  assumes \"{the axiom of} Q {choice holds for subsets} (Pow(Q))\"\n    \"T{is of second type of cardinal}csucc(Q)\"\n    \"T{is a topology}\"\n  shows \"((\\<Union>T){is compact of cardinal}csucc(Q){in}T)\"\n",
        "proof": "proof-\n  from assms(1) have CC:\"Card(Q)\" and reg:\"\\<And> M N. (M \\<lesssim>Q \\<and> (\\<forall>t\\<in>M. N`t\\<noteq>0\\<and>N`t\\<subseteq>Pow(Q))) \\<longrightarrow> (\\<exists>f. f:Pi(M,\\<lambda>t. N`t) \\<and> (\\<forall>t\\<in>M. f`t\\<in>N`t))\" using\n  AxiomCardinalChoice_def by auto\n  from assms(2) obtain R where \"R\\<lesssim>Q\"\"R{is a base for}T\" unfolding IsSecondOfCard_def using Card_less_csucc_eq_le CC by auto\n  with base_to_indexed_base obtain N where base:\"{N`i. i\\<in>Q}{is a base for}T\"  by blast\n  {\n    fix M\n    assume A:\"\\<Union>T\\<subseteq>\\<Union>M\"\"M\\<in>Pow(T)\"\n    let ?\\<alpha>=\"\\<lambda>U\\<in>M. {i\\<in>Q. N`(i)\\<subseteq>U}\"\n    have inj:\"?\\<alpha>\\<in>inj(M,Pow(Q))\" unfolding inj_def\n    proof\n    {\n      show \"(\\<lambda>U\\<in>M. {i \\<in> Q . N ` i \\<subseteq> U}) \\<in> M \\<rightarrow> Pow(Q)\" using lam_type[of \"M\"\"\\<lambda>U. {i \\<in> Q . N`(i) \\<subseteq> U}\"\"%t. Pow(Q)\"] by auto\n      {\n        fix w x\n        assume AS:\"w\\<in>M\"\"x\\<in>M\"\"{i \\<in> Q . N`(i) \\<subseteq> w} = {i \\<in> Q . N`(i) \\<subseteq> x}\"\n        from AS(1,2) A(2) have \"w\\<in>T\"\"x\\<in>T\" by auto\n        then have \"w=Interior(w,T)\"\"x=Interior(x,T)\" using assms(3) topology0.Top_2_L3[of \"T\"]\n          topology0_def[of \"T\"] by auto\n        then have UN:\"w=(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>w})\"\"x=(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>x})\"\n          using interior_set_base_topology assms(3) base by auto\n        {\n          fix b\n          assume \"b\\<in>w\"\n          then have \"b\\<in>\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>w}\" using UN(1) by auto\n          then obtain S where S:\"S\\<in>{N`(i). i\\<in>Q}\" \"b\\<in>S\" \"S\\<subseteq>w\" by blast\n          then obtain j where j:\"j\\<in>Q\"\"S=N`(j)\" by auto\n          then have \"j\\<in>{i \\<in> Q . N`(i) \\<subseteq> w}\" using S(3) by auto\n          then have \"N`(j)\\<subseteq>x\"\"b\\<in>N`(j)\"\"j\\<in>Q\" using S(2) AS(3) j by auto\n          then have \"b\\<in>(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>x})\" by auto\n          then have \"b\\<in>x\" using UN(2) by auto\n        }\n        moreover\n        {\n          fix b\n          assume \"b\\<in>x\"\n          then have \"b\\<in>\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>x}\" using UN(2) by auto\n          then obtain S where S:\"S\\<in>{N`(i). i\\<in>Q}\" \"b\\<in>S\" \"S\\<subseteq>x\" by blast\n          then obtain j where j:\"j\\<in>Q\"\"S=N`(j)\" by auto\n          then have \"j\\<in>{i \\<in> Q . N`(i) \\<subseteq> x}\" using S(3) by auto\n          then have \"j\\<in>{i \\<in> Q . N`(i) \\<subseteq> w}\" using AS(3) by auto\n          then have \"N`(j)\\<subseteq>w\"\"b\\<in>N`(j)\"\"j\\<in>Q\" using S(2) j(2) by auto\n          then have \"b\\<in>(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>w})\" by auto\n          then have \"b\\<in>w\" using UN(2) by auto\n        }\n        ultimately have \"w=x\" by auto\n      }\n      then show \"\\<forall>w\\<in>M. \\<forall>x\\<in>M. (\\<lambda>U\\<in>M. {i \\<in> Q . N ` i \\<subseteq> U}) ` w = (\\<lambda>U\\<in>M. {i \\<in> Q . N ` i \\<subseteq> U}) ` x \\<longrightarrow> w = x\" by auto\n    }\n    qed\n    let ?X=\"\\<lambda>i\\<in>Q. {?\\<alpha>`U. U\\<in>{V\\<in>M. N`(i)\\<subseteq>V}}\"\n    let ?M=\"{i\\<in>Q. ?X`i\\<noteq>0}\"\n    have subMQ:\"?M\\<subseteq>Q\" by auto\n    then have ddd:\"?M \\<lesssim>Q\" using subset_imp_lepoll by auto\n    then have \"?M \\<lesssim>Q\"\"\\<forall>i\\<in>?M. ?X`i\\<noteq>0\"\"\\<forall>i\\<in>?M. ?X`i\\<subseteq>Pow(Q)\" by auto\n    then have \"?M \\<lesssim>Q\"\"\\<forall>i\\<in>?M. ?X`i\\<noteq>0\"\"\\<forall>i\\<in>?M. ?X`i \\<lesssim> Pow(Q)\" using subset_imp_lepoll by auto\n    then have \"(\\<exists>f. f:Pi(?M,\\<lambda>t. ?X`t) \\<and> (\\<forall>t\\<in>?M. f`t\\<in>?X`t))\" using reg[of \"?M\"\"?X\"] by auto\n    then obtain f where f:\"f:Pi(?M,\\<lambda>t. ?X`t)\"\"(!!t. t\\<in>?M \\<Longrightarrow> f`t\\<in>?X`t)\" by auto\n    {\n      fix m\n      assume S:\"m\\<in>?M\"\n      from f(2) S obtain YY where YY:\"(YY\\<in>M)\" \"(f`m=?\\<alpha>`YY)\" by auto\n      then have Y:\"(YY\\<in>M)\\<and>(f`m=?\\<alpha>`YY)\" by auto\n      moreover\n      { \n        fix U\n        assume \"U\\<in>M\\<and>(f`m=?\\<alpha>`U)\"\n        then have \"U=YY\" using inj inj_def YY by auto\n      }\n      then have r:\"\\<And>x. x\\<in>M\\<and>(f`m=?\\<alpha>`x) \\<Longrightarrow> x=YY\" by blast\n      have \"\\<exists>!YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY\" using ex1I[of \"%Y. Y\\<in>M\\<and> f`m=?\\<alpha>`Y\",OF Y r] by auto\n    }\n    then have ex1YY:\"\\<forall>m\\<in>?M. \\<exists>!YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY\" by auto\n    let ?YYm=\"{\\<langle>m,(THE YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY)\\<rangle>. m\\<in>?M}\"\n    have aux:\"\\<And>m. m\\<in>?M \\<Longrightarrow> ?YYm`m=(THE YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY)\" unfolding apply_def by auto\n    have ree:\"\\<forall>m\\<in>?M. (?YYm`m)\\<in>M \\<and> f`m=?\\<alpha>`(?YYm`m)\"\n    proof\n      fix m\n      assume C:\"m\\<in>?M\"\n      then have \"\\<exists>!YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY\" using ex1YY by auto\n      then have \"(THE YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY)\\<in>M\\<and>f`m=?\\<alpha>`(THE YY. YY\\<in>M \\<and> f`m=?\\<alpha>`YY)\"\n        using theI[of \"%Y. Y\\<in>M\\<and> f`m=?\\<alpha>`Y\"] by blast\n      then show \"(?YYm`m)\\<in>M \\<and> f`m=?\\<alpha>`(?YYm`m)\" apply (simp only: aux[OF C]) done\n    qed\n    have tt:\"\\<And>m. m\\<in>?M \\<Longrightarrow> N`(m)\\<subseteq>?YYm`m\"\n    proof-\n      fix m\n      assume D:\"m\\<in>?M\"\n      then have QQ:\"m\\<in>Q\" by auto\n      from D have t:\"(?YYm`m)\\<in>M \\<and> f`m=?\\<alpha>`(?YYm`m)\" using ree by blast\n      then have \"f`m=?\\<alpha>`(?YYm`m)\" by blast\n      then have \"(?\\<alpha>`(?YYm`m))\\<in>(\\<lambda>i\\<in>Q. {?\\<alpha>`U. U\\<in>{V\\<in>M. N`(i)\\<subseteq>V}})`m\" using f(2)[OF D]\n        by auto\n      then have \"(?\\<alpha>`(?YYm`m))\\<in>{?\\<alpha>`U. U\\<in>{V\\<in>M. N`(m)\\<subseteq>V}}\" using QQ by auto\n      then obtain U where \"U\\<in>{V\\<in>M. N`(m)\\<subseteq>V}\"\"?\\<alpha>`(?YYm`m)=?\\<alpha>`U\" by auto\n      then have r:\"U\\<in>M\"\"N`(m)\\<subseteq>U\"\"?\\<alpha>`(?YYm`m)=?\\<alpha>`U\"\"(?YYm`m)\\<in>M\" using t by auto\n      then have \"?YYm`m=U\" using  inj_apply_equality[OF inj] by blast\n      then show \"N`(m)\\<subseteq>?YYm`m\" using r by auto\n    qed\n    then have \"(\\<Union>m\\<in>?M. N`(m))\\<subseteq>(\\<Union>m\\<in>?M. ?YYm`m)\"\n    proof-\n      {\n        fix s\n        assume \"s\\<in>(\\<Union>m\\<in>?M. N`(m))\"\n        then obtain t where r:\"t\\<in>?M\"\"s\\<in>N`(t)\" by auto\n        then have \"s\\<in>?YYm`t\" using tt[OF r(1)] by blast\n        then have \"s\\<in>(\\<Union>m\\<in>?M. ?YYm`m)\" using r(1) by blast\n      }\n      then show ?thesis by blast\n    qed\n    moreover\n    {\n      fix x\n      assume AT:\"x\\<in>\\<Union>T\"\n      with A obtain U where BB:\"U\\<in>M\"\"U\\<in>T\"\"x\\<in>U\" by auto\n      then obtain j where BC:\"j\\<in>Q\" \"N`(j)\\<subseteq>U\"\"x\\<in>N`(j)\" using point_open_base_neigh[OF base,of \"U\"\"x\"] by auto\n      then have \"?X`j\\<noteq>0\" using BB(1) by auto\n      then have \"j\\<in>?M\" using BC(1) by auto\n      then have \"x\\<in>(\\<Union>m\\<in>?M. N`(m))\" using BC(3) by auto\n    }\n    then have \"\\<Union>T\\<subseteq>(\\<Union>m\\<in>?M. N`(m))\" by blast\n    ultimately have covers:\"\\<Union>T\\<subseteq>(\\<Union>m\\<in>?M. ?YYm`m)\" using subset_trans[of \"\\<Union>T\"\"(\\<Union>m\\<in>?M. N`(m))\"\"(\\<Union>m\\<in>?M. ?YYm`m)\"]\n      by auto\n    have \"relation(?YYm)\" unfolding relation_def by auto\n    moreover\n    have f:\"function(?YYm)\" unfolding function_def by auto\n    moreover\n    have d:\"domain(?YYm)=?M\" by auto\n    moreover\n    have r:\"range(?YYm)=?YYm``?M\" by auto\n    ultimately\n    have fun:\"?YYm:?M\\<rightarrow>?YYm``?M\" using function_imp_Pi[of \"?YYm\"] by auto\n    have \"?YYm\\<in>surj(?M,?YYm``?M)\" using fun_is_surj[OF fun] r by auto\n    with surj_fun_inv[OF this subMQ Card_is_Ord[OF CC]]\n    have \"?YYm``?M \\<lesssim> ?M\" by auto\n    with ddd have Rw:\"?YYm``?M \\<lesssim>Q\" using lepoll_trans by blast\n    {\n      fix m assume \"m\\<in>?M\"\n      then have \"\\<langle>m,?YYm`m\\<rangle>\\<in>?YYm\" using function_apply_Pair[OF f] d by blast\n      then have \"?YYm`m\\<in>?YYm``?M\" by auto}\n      then have l1:\"{?YYm`m. m\\<in>?M}\\<subseteq>?YYm``?M\" by blast\n      {\n        fix t assume \"t\\<in>?YYm``?M\"\n        then have \"\\<exists>x\\<in>?M. \\<langle>x,t\\<rangle>\\<in>?YYm\" unfolding image_def by auto\n        then obtain r where S:\"r\\<in>?M\"\"\\<langle>r,t\\<rangle>\\<in>?YYm\" by auto\n        have \"?YYm`r=t\" using apply_equality[OF S(2) fun] by auto\n        with S(1) have \"t\\<in>{?YYm`m. m\\<in>?M}\" by auto\n      }\n      with l1 have \"{?YYm`m. m\\<in>?M}=?YYm``?M\" by blast\n      with Rw have \"{?YYm`m. m\\<in>?M} \\<lesssim>Q\" by auto\n      with covers have \"{?YYm`m. m\\<in>?M}\\<in>Pow(M)\\<and>\\<Union>T\\<subseteq>\\<Union>{?YYm`m. m\\<in>?M}\\<and>{?YYm`m. m\\<in>?M} \\<prec>csucc(Q)\" using ree \n        Card_less_csucc_eq_le[OF CC] by blast\n      then have \"\\<exists>N\\<in>Pow(M). \\<Union>T\\<subseteq>\\<Union>N\\<and>N\\<prec>csucc(Q)\" by auto\n    }\n  then have \"\\<forall>M\\<in>Pow(T). \\<Union>T \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists>N\\<in>Pow(M). \\<Union>T \\<subseteq> \\<Union>N \\<and> N \\<prec> csucc(Q))\" by auto\n  then show ?thesis using IsCompactOfCard_def Card_csucc CC Card_is_Ord by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2367
    },
    "2134": {
        "type": "theorem",
        "text": "text\\<open>The two previous results, state the following equivalence:\\<close>\n",
        "assumes": "assumes \"InfCard(Q)\"\n  ",
        "using": [
            "second_imp_compact_imp_Q_choice_PowQ",
            "compact_of_cardinal_Q",
            "assms"
        ],
        "statement": "theorem Q_choice_Pow_eq_secon_imp_comp:\n  assumes \"InfCard(Q)\"\n  shows  \"(\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> ((\\<Union>T){is compact of cardinal}csucc(Q){in}T))\n    \\<longleftrightarrow>({the axiom of} Q {choice holds for subsets} (Pow(Q)))\"\n    ",
        "proof": "using second_imp_compact_imp_Q_choice_PowQ compact_of_cardinal_Q assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2369
    },
    "2135": {
        "type": "theorem",
        "text": "text\\<open>In the next result we will prove that if the space $(\\kappa,Pow(\\kappa))$,\nfor $\\kappa$ an infinite cardinal, is compact of its successor cardinal; then all\ntopologycal spaces which are of second type of the successor cardinal of $\\kappa$\nare also compact of that cardinal.\\<close>\n",
        "assumes": "assumes \"InfCard(Q)\" \"(Q){is compact of cardinal}csucc(Q){in}Pow(Q)\"\n  ",
        "using": [
            "InfCard_is_Card",
            "Card_is_Ord",
            "Card_csucc",
            "IsSecondOfCard_def",
            "Card_less_csucc_eq_le",
            "base_to_indexed_base",
            "Pi_iff",
            "apply_equality",
            "top",
            "topology0.Top_2_L3[of",
            "\"T\"]",
            "topology0_def[of",
            "interior_set_base_topology",
            "base",
            "UN(1)",
            "S(3)",
            "S(2)",
            "ASS",
            "j",
            "UN(2)",
            "j(2)",
            "fun_is_surj",
            "bij_def",
            "inj_def",
            "surj_def",
            "IsClosed_def",
            "IsCompactOfCard_def",
            "bij_converse_bij",
            "restrict_bij",
            "SS_def(1)",
            "point_open_base_neigh",
            "SS_def(2)",
            "rr",
            "left_inverse[OF",
            "_",
            "p]",
            "Pi_def",
            "relation_def",
            "relation_converse_converse",
            "relation_converse_converse[of",
            "\"?S\"]",
            "con",
            "apply_funtype",
            "\\<open>?S:M\\<rightarrow>Pow(Q)\\<close>",
            "\\<open>j\\<in>SR\\<close>",
            "image_function[of",
            "\"converse(?S)\"",
            "\"SS\"]",
            "range_def",
            "eqpoll_def",
            "SS_def(3)",
            "eq_lesspoll_trans"
        ],
        "statement": "theorem Q_csuccQ_comp_eq_Q_choice_Pow:\n  assumes \"InfCard(Q)\" \"(Q){is compact of cardinal}csucc(Q){in}Pow(Q)\"\n  shows \"\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> ((\\<Union>T){is compact of cardinal}csucc(Q){in}T)\"\n",
        "proof": "proof\n  fix T\n  {\n    assume top:\"T {is a topology}\" and sec:\"T{is of second type of cardinal}csucc(Q)\"\n    from assms have \"Card(csucc(Q))\" \"Card(Q)\" using InfCard_is_Card Card_is_Ord Card_csucc by auto\n    moreover\n    have \"\\<Union>T\\<subseteq>\\<Union>T\" by auto\n    moreover\n    {\n      fix M\n      assume MT:\"M\\<in>Pow(T)\" and cover:\"\\<Union>T\\<subseteq>\\<Union>M\"\n      from sec obtain B where \"B {is a base for} T\" \"B\\<prec>csucc(Q)\" using IsSecondOfCard_def by auto\n      with \\<open>Card(Q)\\<close> obtain N where base:\"{N`i. i\\<in>Q}{is a base for}T\" using Card_less_csucc_eq_le\n        base_to_indexed_base by blast\n      let ?S=\"{\\<langle>u,{i\\<in>Q. N`i\\<subseteq>u}\\<rangle>. u\\<in>M}\"\n      have \"function(?S)\" unfolding function_def by auto\n      then have \"?S:M\\<rightarrow>Pow(Q)\" using Pi_iff by auto\n      then have \"?S\\<in>inj(M,Pow(Q))\" unfolding inj_def\n        proof\n        {\n          fix w x\n          assume AS:\"w\\<in>M\"\"x\\<in>M\"\"{\\<langle>u, {i \\<in> Q . N ` i \\<subseteq> u}\\<rangle> . u \\<in> M} ` w = {\\<langle>u, {i \\<in> Q . N ` i \\<subseteq> u}\\<rangle> . u \\<in> M} ` x\"\n          with \\<open>?S:M\\<rightarrow>Pow(Q)\\<close> have ASS:\"{i \\<in> Q . N ` i \\<subseteq> w}={i \\<in> Q . N ` i \\<subseteq> x}\" using apply_equality by auto\n          from AS(1,2) MT have \"w\\<in>T\"\"x\\<in>T\" by auto\n          then have \"w=Interior(w,T)\"\"x=Interior(x,T)\" using top topology0.Top_2_L3[of \"T\"]\n            topology0_def[of \"T\"] by auto\n          then have UN:\"w=(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>w})\"\"x=(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>x})\"\n            using interior_set_base_topology top base by auto\n          {\n            fix b\n            assume \"b\\<in>w\"\n            then have \"b\\<in>\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>w}\" using UN(1) by auto\n            then obtain S where S:\"S\\<in>{N`(i). i\\<in>Q}\" \"b\\<in>S\" \"S\\<subseteq>w\" by blast\n            then obtain j where j:\"j\\<in>Q\"\"S=N`(j)\" by auto\n            then have \"j\\<in>{i \\<in> Q . N`(i) \\<subseteq> w}\" using S(3) by auto\n            then have \"N`(j)\\<subseteq>x\"\"b\\<in>N`(j)\"\"j\\<in>Q\" using S(2) ASS j by auto\n            then have \"b\\<in>(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>x})\" by auto\n            then have \"b\\<in>x\" using UN(2) by auto\n          }\n          moreover\n          {\n            fix b\n            assume \"b\\<in>x\"\n            then have \"b\\<in>\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>x}\" using UN(2) by auto\n            then obtain S where S:\"S\\<in>{N`(i). i\\<in>Q}\" \"b\\<in>S\" \"S\\<subseteq>x\" by blast\n            then obtain j where j:\"j\\<in>Q\"\"S=N`(j)\" by auto\n            then have \"j\\<in>{i \\<in> Q . N`(i) \\<subseteq> x}\" using S(3) by auto\n            then have \"j\\<in>{i \\<in> Q . N`(i) \\<subseteq> w}\" using ASS by auto\n            then have \"N`(j)\\<subseteq>w\"\"b\\<in>N`(j)\"\"j\\<in>Q\" using S(2) j(2) by auto\n            then have \"b\\<in>(\\<Union>{B\\<in>{N`(i). i\\<in>Q}. B\\<subseteq>w})\" by auto\n            then have \"b\\<in>w\" using UN(2) by auto\n          }\n          ultimately have \"w=x\" by auto \n        }\n        then show \"\\<forall>w\\<in>M. \\<forall>x\\<in>M. {\\<langle>u, {i \\<in> Q . N ` i \\<subseteq> u}\\<rangle> . u \\<in> M} ` w = {\\<langle>u, {i \\<in> Q . N ` i \\<subseteq> u}\\<rangle> . u \\<in> M} ` x \\<longrightarrow> w = x\" by auto\n      qed\n      then have \"?S\\<in>bij(M,range(?S))\" using fun_is_surj unfolding bij_def inj_def surj_def by force\n      have \"range(?S)\\<subseteq>Pow(Q)\" by auto\n      then have \"range(?S)\\<in>Pow(Pow(Q))\" by auto\n      moreover\n      have \"(\\<Union>(range(?S))) {is closed in} Pow(Q)\" \"Q\\<inter>(\\<Union>range(?S))=(\\<Union>range(?S))\" using IsClosed_def by auto\n      from this(2) compact_closed[OF assms(2) this(1)] have \"(\\<Union>range(?S)){is compact of cardinal}csucc(Q) {in}Pow(Q)\"\n        by auto\n      moreover\n      have \"\\<Union>(range(?S))\\<subseteq>\\<Union>(range(?S))\" by auto\n      ultimately have \"\\<exists>S\\<in>Pow(range(?S)). (\\<Union>(range(?S)))\\<subseteq>\\<Union>S \\<and> S\\<prec> csucc(Q)\" using IsCompactOfCard_def by auto\n      then obtain SS where SS_def:\"SS\\<subseteq>range(?S)\" \"(\\<Union>(range(?S)))\\<subseteq>\\<Union>SS\" \"SS\\<prec> csucc(Q)\" by auto\n      with \\<open>?S\\<in>bij(M,range(?S))\\<close> have con:\"converse(?S)\\<in>bij(range(?S),M)\" using bij_converse_bij by auto\n      then have r1:\"restrict(converse(?S),SS)\\<in>bij(SS,converse(?S)``SS)\" using restrict_bij bij_def SS_def(1) by auto\n      then have rr:\"converse(restrict(converse(?S),SS))\\<in>bij(converse(?S)``SS,SS)\" using bij_converse_bij by auto\n      {\n        fix x\n        assume \"x\\<in>\\<Union>T\"\n        with cover have \"x\\<in>\\<Union>M\" by auto\n        then obtain R where \"R\\<in>M\" \"x\\<in>R\" by auto\n        with MT have \"R\\<in>T\" \"x\\<in>R\" by auto\n        then have \"\\<exists>V\\<in>{N`i. i\\<in>Q}. V\\<subseteq>R \\<and> x\\<in>V\" using point_open_base_neigh base by force\n        then obtain j where \"j\\<in>Q\" \"N`j\\<subseteq>R\" and x_p:\"x\\<in>N`j\" by auto\n        with \\<open>R\\<in>M\\<close> \\<open>?S:M\\<rightarrow>Pow(Q)\\<close> \\<open>?S\\<in>bij(M,range(?S))\\<close> have \"?S`R\\<in>range(?S) \\<and> j\\<in>?S`R\" using apply_equality \n          bij_def inj_def by auto\n        from exI[where P=\"\\<lambda>t. t\\<in>range(?S) \\<and> j\\<in>t\", OF this] have \"\\<exists>A\\<in>range(?S). j\\<in>A\" unfolding Bex_def\n          by auto\n        then have \"j\\<in>(\\<Union>(range(?S)))\" by auto\n        then have \"j\\<in>\\<Union>SS\" using SS_def(2) by blast\n        then obtain SR where \"SR\\<in>SS\" \"j\\<in>SR\" by auto\n        moreover\n        have \"converse(restrict(converse(?S),SS))\\<in>surj(converse(?S)``SS,SS)\" using rr bij_def by auto\n        ultimately obtain RR where \"converse(restrict(converse(?S),SS))`RR=SR\" and p:\"RR\\<in>converse(?S)``SS\" unfolding surj_def by blast\n        then have \"converse(converse(restrict(converse(?S),SS)))`(converse(restrict(converse(?S),SS))`RR)=converse(converse(restrict(converse(?S),SS)))`SR\"\n          by auto\n        moreover\n        have \"converse(restrict(converse(?S),SS))\\<in>inj(converse(?S)``SS,SS)\" using rr unfolding bij_def by auto\n        moreover\n        ultimately have \"RR=converse(converse(restrict(converse(?S),SS)))`SR\" using left_inverse[OF _ p]\n          by force\n        moreover\n        with r1 have \"restrict(converse(?S),SS)\\<in>SS\\<rightarrow>converse(?S)``SS\" unfolding bij_def inj_def by auto\n        then have \"relation(restrict(converse(?S),SS))\" using Pi_def relation_def by auto\n        then have \"converse(converse(restrict(converse(?S),SS)))=restrict(converse(?S),SS)\" using relation_converse_converse by auto\n        ultimately have \"RR=restrict(converse(?S),SS)`SR\" by auto\n        with \\<open>SR\\<in>SS\\<close> have eq:\"RR=converse(?S)`SR\" unfolding restrict by auto\n        then have \"converse(converse(?S))`RR=converse(converse(?S))`(converse(?S)`SR)\" by auto\n        moreover\n        with \\<open>SR\\<in>SS\\<close> have \"SR\\<in>range(?S)\" using SS_def(1) by auto\n        from con left_inverse[OF _ this] have \"converse(converse(?S))`(converse(?S)`SR)=SR\" unfolding bij_def\n          by auto\n        ultimately have \"converse(converse(?S))`RR=SR\" by auto\n        then have \"?S`RR=SR\" using relation_converse_converse[of \"?S\"] unfolding relation_def by auto\n        moreover\n        have \"converse(?S):range(?S)\\<rightarrow>M\" using con bij_def inj_def by auto\n        with \\<open>SR\\<in>range(?S)\\<close> have \"converse(?S)`SR\\<in>M\" using apply_funtype\n          by auto\n        with eq have \"RR\\<in>M\" by auto\n        ultimately have \"SR={i\\<in>Q. N`i\\<subseteq>RR}\" using \\<open>?S:M\\<rightarrow>Pow(Q)\\<close> apply_equality by auto\n        then have \"N`j\\<subseteq>RR\" using \\<open>j\\<in>SR\\<close> by auto\n        with x_p have \"x\\<in>RR\" by auto\n        with p have \"x\\<in>\\<Union>(converse(?S)``SS)\" by auto\n      }\n      then have \"\\<Union>T\\<subseteq>\\<Union>(converse(?S)``SS)\" by blast\n      moreover\n      {\n        from con have \"converse(?S)``SS={converse(?S)`R. R\\<in>SS}\" using image_function[of \"converse(?S)\" \"SS\"]\n          SS_def(1) unfolding range_def bij_def inj_def Pi_def by auto\n        have \"{converse(?S)`R. R\\<in>SS}\\<subseteq>{converse(?S)`R. R\\<in>range(?S)}\" using SS_def(1) by auto\n        moreover\n        have \"converse(?S):range(?S)\\<rightarrow>M\" using con unfolding bij_def inj_def by auto\n        then have \"{converse(?S)`R. R\\<in>range(?S)}\\<subseteq>M\" using apply_funtype by force\n        ultimately\n        have \"(converse(?S)``SS)\\<subseteq>M\" by auto\n      }\n      then have \"converse(?S)``SS\\<in>Pow(M)\" by auto\n      moreover\n      with rr have \"converse(?S)``SS\\<approx>SS\" using eqpoll_def by auto\n      then have \"converse(?S)``SS\\<prec>csucc(Q)\" using SS_def(3) eq_lesspoll_trans by auto\n      ultimately\n      have \"\\<exists>N\\<in>Pow(M). \\<Union>T\\<subseteq>\\<Union>N \\<and> N\\<prec>csucc(Q)\" by auto\n    }\n    then have \"\\<forall>M\\<in>Pow(T). \\<Union>T\\<subseteq>\\<Union>M \\<longrightarrow> (\\<exists>N\\<in>Pow(M). \\<Union>T\\<subseteq>\\<Union>N \\<and> N\\<prec>csucc(Q))\" by auto\n    ultimately have \"(\\<Union>T){is compact of cardinal}csucc(Q){in}T\" unfolding IsCompactOfCard_def\n      by auto\n  }\n  then show \"(T {is a topology}) \\<and> (T {is of second type of cardinal}csucc(Q)) \\<longrightarrow> ((\\<Union>T){is compact of cardinal}csucc(Q) {in}T)\"\n  by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2370
    },
    "2136": {
        "type": "lemma",
        "text": "text\\<open>The discrete topology is locally finite.\\<close>\n",
        "assumes": "",
        "using": [
            "reg",
            "IsLocally_def[OF",
            "Pow_is_top]"
        ],
        "statement": "lemma discrete_locally_finite:\n  shows \"Pow(A){is locally}(\\<lambda>A.(\\<lambda>B. Finite(A)))\"\n",
        "proof": "proof-\n  have \"\\<forall>b\\<in>Pow(A). \\<Union>(Pow(A){restricted to}b)=b\" unfolding RestrictedTo_def by blast\n  then have \"\\<forall>b\\<in>{{x}. x\\<in>A}. Finite(b)\" by auto moreover\n  have reg:\"\\<forall>S\\<in>Pow(A). Interior(S,Pow(A))=S\" unfolding Interior_def by auto\n  {\n    fix x b assume \"x\\<in>\\<Union>Pow(A)\" \"b\\<in>Pow(A)\" \"x\\<in>b\"\n    then have \"{x}\\<subseteq>b\" \"x\\<in>Interior({x},Pow(A))\" \"Finite({x})\" using reg by auto\n    then have \"\\<exists>c\\<in>Pow(b). x\\<in>Interior(c,Pow(A))\\<and>Finite(c)\" by blast\n  }\n  then have \"\\<forall>x\\<in>\\<Union>Pow(A). \\<forall>b\\<in>Pow(A). x\\<in>b \\<longrightarrow> (\\<exists>c\\<in>Pow(b). x\\<in>Interior(c,Pow(A)) \\<and> Finite(c))\" by auto\n  then show ?thesis using IsLocally_def[OF Pow_is_top] by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2373
    },
    "2137": {
        "type": "lemma",
        "text": "text\\<open>The included set topology is locally finite when the set is finite.\\<close>\n",
        "assumes": "assumes \"Finite(A)\" and \"A\\<subseteq>X\"\n  ",
        "using": [
            "assms(2)",
            "sub",
            "\\<open>x\\<in>b\\<close>",
            "interior_set_includedset[of",
            "\"A\\<union>{x}\"\"X\"\"A\"]",
            "rr",
            "IsLocally_def",
            "includedset_is_topology"
        ],
        "statement": "lemma included_finite_locally_finite:\n  assumes \"Finite(A)\" and \"A\\<subseteq>X\"\n  shows \"(IncludedSet(X,A)){is locally}(\\<lambda>A.(\\<lambda>B. Finite(A)))\"\n",
        "proof": "proof-\n  have \"\\<forall>b\\<in>Pow(X). b\\<inter>A\\<subseteq>b\" by auto moreover\n  note assms(1)\n  ultimately have rr:\"\\<forall>b\\<in>{A\\<union>{x}. x\\<in>X}. Finite(b)\" by force\n  {\n    fix x b assume \"x\\<in>\\<Union>(IncludedSet(X,A))\" \"b\\<in>(IncludedSet(X,A))\" \"x\\<in>b\"\n    then have \"A\\<union>{x}\\<subseteq>b\" \"A\\<union>{x}\\<in>{A\\<union>{x}. x\\<in>X}\" and sub: \"b\\<subseteq>X\" unfolding IncludedSet_def by auto\n    moreover have \"A \\<union> {x} \\<subseteq> X\" using assms(2) sub \\<open>x\\<in>b\\<close> by auto\n    then have \"x\\<in>Interior(A\\<union>{x},IncludedSet(X,A))\" using interior_set_includedset[of \"A\\<union>{x}\"\"X\"\"A\"] by auto\n    ultimately have \"\\<exists>c\\<in>Pow(b). x\\<in>Interior(c,IncludedSet(X,A))\\<and> Finite(c)\" using rr by blast\n  }\n  then have \"\\<forall>x\\<in>\\<Union>(IncludedSet(X,A)). \\<forall>b\\<in>(IncludedSet(X,A)). x\\<in>b \\<longrightarrow> (\\<exists>c\\<in>Pow(b). x\\<in>Interior(c,IncludedSet(X,A))\\<and> Finite(c))\" by auto\n  then show ?thesis using IsLocally_def includedset_is_topology by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2374
    },
    "2138": {
        "type": "lemma",
        "text": "text\\<open>If a subset is compact of some cardinal for a topological space, it is compact of the same cardinal\nin the subspace topology.\\<close>\n",
        "assumes": "assumes \"A{is compact of cardinal}K{in}T\" \"A\\<subseteq>B\"\n  ",
        "using": [
            "assms(2)",
            "RestrictedTo_def",
            "apply_equality",
            "surj_fun_inv_2",
            "Card_is_Ord",
            "C",
            "lesspoll_trans1"
        ],
        "statement": "lemma compact_imp_compact_subspace:\n  assumes \"A{is compact of cardinal}K{in}T\" \"A\\<subseteq>B\"\n  shows \"A{is compact of cardinal}K{in}(T{restricted to}B)\" unfolding IsCompactOfCard_def\n",
        "proof": "proof\n  from assms show C:\"Card(K)\" unfolding IsCompactOfCard_def by auto\n  from assms have \"A\\<subseteq>\\<Union>T\" unfolding IsCompactOfCard_def by auto\n  then have AA:\"A\\<subseteq>\\<Union>(T{restricted to}B)\" using assms(2) unfolding RestrictedTo_def by auto moreover\n  {\n    fix M assume \"M\\<in>Pow(T{restricted to}B)\" \"A\\<subseteq>\\<Union>M\"\n    let ?M=\"{S\\<in>T. B\\<inter>S\\<in>M}\"\n    from \\<open>M\\<in>Pow(T{restricted to}B)\\<close> have \"\\<Union>M\\<subseteq>\\<Union>?M\" unfolding RestrictedTo_def by auto\n    with \\<open>A\\<subseteq>\\<Union>M\\<close> have \"A\\<subseteq>\\<Union>?M\"\"?M\\<in>Pow(T)\" by auto\n    with assms have \"\\<exists>N\\<in>Pow(?M). A\\<subseteq>\\<Union>N\\<and>N\\<prec>K\" unfolding IsCompactOfCard_def by auto\n    then obtain N where \"N\\<in>Pow(?M)\" \"A\\<subseteq>\\<Union>N\" \"N\\<prec>K\" by auto\n    then have \"N{restricted to}B\\<subseteq>M\" unfolding RestrictedTo_def FinPow_def by auto\n    moreover\n    let ?f=\"{\\<langle>\\<BB>,B\\<inter>\\<BB>\\<rangle>. \\<BB>\\<in>N}\"\n    have \"?f:N\\<rightarrow>(N{restricted to}B)\" unfolding Pi_def function_def domain_def RestrictedTo_def by auto\n    then have \"?f\\<in>surj(N,N{restricted to}B)\" unfolding surj_def RestrictedTo_def using apply_equality\n      by auto\n    from \\<open>N\\<prec>K\\<close> have \"N\\<lesssim>K\" unfolding lesspoll_def by auto\n    with \\<open>?f\\<in>surj(N,N{restricted to}B)\\<close> have \"N{restricted to}B\\<lesssim>N\" using surj_fun_inv_2 Card_is_Ord C by auto\n    with \\<open>N\\<prec>K\\<close> have \"N{restricted to}B\\<prec>K\" using lesspoll_trans1 by auto\n    moreover from \\<open>A\\<subseteq>\\<Union>N\\<close> have \"A\\<subseteq>\\<Union>(N{restricted to}B)\" using assms(2) unfolding RestrictedTo_def by auto\n    ultimately have \"\\<exists>N\\<in>Pow(M). A\\<subseteq>\\<Union>N \\<and> N\\<prec>K\" by auto\n  }\n  with AA show \"A \\<subseteq> \\<Union>(T {restricted to} B) \\<and> (\\<forall>M\\<in>Pow(T {restricted to} B). A \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists>N\\<in>Pow(M). A \\<subseteq> \\<Union>N \\<and> N\\<prec>K))\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2375
    },
    "2139": {
        "type": "lemma",
        "text": "text\\<open>The converse of the previous result is not always true. For compactness, it holds because the axiom of finite choice\nalways holds.\\<close>\n",
        "assumes": "assumes \"A{is compact in}(T{restricted to}B)\" \"A\\<subseteq>B\"\n  ",
        "using": [
            "assms(2)",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "lesspoll_nat_is_Finite",
            "eqpoll_imp_lepoll",
            "finite_choice",
            "AxiomCardinalChoiceGen_def",
            "beta_if",
            "inj_bij_range",
            "range_image_domain",
            "FF",
            "func_imagedef",
            "eqpoll_sym",
            "eqpoll_trans"
        ],
        "statement": "lemma compact_subspace_imp_compact:\n  assumes \"A{is compact in}(T{restricted to}B)\" \"A\\<subseteq>B\"\n  shows \"A{is compact in}T\" unfolding IsCompact_def\n",
        "proof": "proof\n  from assms show \"A\\<subseteq>\\<Union>T\" unfolding IsCompact_def RestrictedTo_def by auto\nnext\n  {\n    fix M assume \"M\\<in>Pow(T)\" \"A\\<subseteq>\\<Union>M\"\n    let ?M=\"M{restricted to}B\"\n    from \\<open>M\\<in>Pow(T)\\<close> have \"?M\\<in>Pow(T{restricted to}B)\" unfolding RestrictedTo_def by auto\n    from \\<open>A\\<subseteq>\\<Union>M\\<close> have \"A\\<subseteq>\\<Union>?M\" unfolding RestrictedTo_def using assms(2) by auto\n    with assms \\<open>?M\\<in>Pow(T{restricted to}B)\\<close> obtain N where \"N\\<in>FinPow(?M)\" \"A\\<subseteq>\\<Union>N\" unfolding IsCompact_def by blast\n    from \\<open>N\\<in>FinPow(?M)\\<close> have \"N\\<prec>nat\" unfolding FinPow_def Finite_def using n_lesspoll_nat eq_lesspoll_trans\n      by auto\n    then have \"Finite(N)\" using lesspoll_nat_is_Finite by auto\n    then obtain n where \"n\\<in>nat\" \"N\\<approx>n\" unfolding Finite_def by auto\n    then have \"N\\<lesssim>n\" using eqpoll_imp_lepoll by auto\n    moreover \n    {\n      fix BB assume \"BB\\<in>N\"\n      with \\<open>N\\<in>FinPow(?M)\\<close> have \"BB\\<in>?M\" unfolding FinPow_def by auto\n      then obtain S where \"S\\<in>M\" and \"BB=B\\<inter>S\" unfolding RestrictedTo_def by auto\n      then have \"S\\<in>{S\\<in>M. B\\<inter>S=BB}\" by auto\n      then obtain \"{S\\<in>M. B\\<inter>S=BB}\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>BB\\<in>N. ((\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W})`BB)\\<noteq>0\" by auto moreover\n    from \\<open>n\\<in>nat\\<close> have \" (N \\<lesssim> n \\<and> (\\<forall>t\\<in>N. (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t \\<noteq> 0) \\<longrightarrow> (\\<exists>f. f \\<in> Pi(N,\\<lambda>t. (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t) \\<and> (\\<forall>t\\<in>N. f ` t \\<in> (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t)))\" using finite_choice unfolding AxiomCardinalChoiceGen_def by blast\n    ultimately\n    obtain f where AA:\"f\\<in>Pi(N,\\<lambda>t. (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t)\" \"\\<forall>t\\<in>N. f`t\\<in>(\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t\" by blast\n    from AA(2) have ss:\"\\<forall>t\\<in>N. f`t\\<in>{S\\<in>M. B\\<inter>S=t}\" using beta_if by auto\n    then have \"{f`t. t\\<in>N}\\<subseteq>M\" by auto\n    {\n      fix t assume \"t\\<in>N\"\n      with ss have \"f`t\\<in>{S\\<in>M. B\\<inter>S\\<in>N}\" by auto\n    }\n    with AA(1) have FF:\"f:N\\<rightarrow>{S\\<in>M. B\\<inter>S\\<in>N}\" unfolding Pi_def Sigma_def using beta_if by auto moreover\n    {\n      fix aa bb assume AAA:\"aa\\<in>N\" \"bb\\<in>N\" \"f`aa=f`bb\"\n      from AAA(1) ss have \"B\\<inter> (f`aa) =aa\" by auto\n      with AAA(3) have \"B\\<inter>(f`bb)=aa\" by auto\n      with ss AAA(2) have \"aa=bb\" by auto\n    }\n    ultimately have \"f\\<in>inj(N,{S\\<in>M. B\\<inter>S\\<in>N})\" unfolding inj_def by auto\n    then have \"f\\<in>bij(N,range(f))\" using inj_bij_range by auto\n    then have \"f\\<in>bij(N,f``N)\" using range_image_domain FF by auto\n    then have \"f\\<in>bij(N,{f`t. t\\<in>N})\" using func_imagedef FF by auto\n    then have \"N\\<approx>{f`t. t\\<in>N}\" unfolding eqpoll_def by auto\n    with \\<open>N\\<approx>n\\<close> have \"{f`t. t\\<in>N}\\<approx>n\" using eqpoll_sym eqpoll_trans by blast\n    with \\<open>n\\<in>nat\\<close> have \"Finite({f`t. t\\<in>N})\" unfolding Finite_def by auto\n    with ss have \"{f`t. t\\<in>N}\\<in>FinPow(M)\" unfolding FinPow_def by auto moreover\n    {\n      fix aa assume \"aa\\<in>A\"\n      with \\<open>A\\<subseteq>\\<Union>N\\<close> obtain b where \"b\\<in>N\" and \"aa\\<in>b\" by auto\n      with ss have \"B\\<inter>(f`b)=b\" by auto\n      with \\<open>aa\\<in>b\\<close> have \"aa\\<in>B\\<inter>(f`b)\" by auto\n      then have \"aa\\<in> f`b\" by auto\n      with \\<open>b\\<in>N\\<close> have \"aa\\<in>\\<Union>{f`t. t\\<in>N}\" by auto\n    }\n    then have \"A\\<subseteq>\\<Union>{f`t. t\\<in>N}\" by auto ultimately\n    have \"\\<exists>R\\<in>FinPow(M). A\\<subseteq>\\<Union>R\" by auto\n  }\n  then show \"\\<forall>M\\<in>Pow(T). A \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists>N\\<in>FinPow(M). A \\<subseteq> \\<Union>N)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2376
    },
    "2140": {
        "type": "lemma",
        "text": "text\\<open>If the axiom of choice holds for some cardinal,\nthen we can drop the compact sets of that cardial are compact of the same cardinal\nas subspaces of every superspace.\\<close>\n",
        "assumes": "assumes \"A{is compact of cardinal}Q{in}(T{restricted to}B)\" \"A\\<subseteq>B\" \"({the axiom of} Q {choice holds})\"\n  ",
        "using": [
            "assms(2)",
            "lesspoll_imp_lepoll",
            "assms(3)",
            "AxiomCardinalChoiceGen_def",
            "beta_if",
            "inj_bij_range",
            "range_image_domain",
            "FF",
            "func_imagedef",
            "eqpoll_sym",
            "eq_lesspoll_trans",
            "a1",
            "a2",
            "IsCompactOfCard_def"
        ],
        "statement": "lemma Kcompact_subspace_imp_Kcompact:\n  assumes \"A{is compact of cardinal}Q{in}(T{restricted to}B)\" \"A\\<subseteq>B\" \"({the axiom of} Q {choice holds})\"\n  shows \"A{is compact of cardinal}Q{in}T\"\n",
        "proof": "proof -\n  from assms(1) have a1:\"Card(Q)\" unfolding IsCompactOfCard_def RestrictedTo_def by auto\n  from assms(1) have a2:\"A\\<subseteq>\\<Union>T\" unfolding IsCompactOfCard_def RestrictedTo_def by auto\n  {\n    fix M assume \"M\\<in>Pow(T)\" \"A\\<subseteq>\\<Union>M\"\n    let ?M=\"M{restricted to}B\"\n    from \\<open>M\\<in>Pow(T)\\<close> have \"?M\\<in>Pow(T{restricted to}B)\" unfolding RestrictedTo_def by auto\n    from \\<open>A\\<subseteq>\\<Union>M\\<close> have \"A\\<subseteq>\\<Union>?M\" unfolding RestrictedTo_def using assms(2) by auto\n    with assms \\<open>?M\\<in>Pow(T{restricted to}B)\\<close> obtain N where N:\"N\\<in>Pow(?M)\" \"A\\<subseteq>\\<Union>N\" \"N \\<prec> Q\" unfolding IsCompactOfCard_def by blast\n    from N(3) have \"N\\<lesssim>Q\" using lesspoll_imp_lepoll by auto moreover \n    {\n      fix BB assume \"BB\\<in>N\"\n      with \\<open>N\\<in>Pow(?M)\\<close> have \"BB\\<in>?M\" unfolding FinPow_def by auto\n      then obtain S where \"S\\<in>M\" and \"BB=B\\<inter>S\" unfolding RestrictedTo_def by auto\n      then have \"S\\<in>{S\\<in>M. B\\<inter>S=BB}\" by auto\n      then obtain \"{S\\<in>M. B\\<inter>S=BB}\\<noteq>0\" by auto\n    }\n    then have \"\\<forall>BB\\<in>N. ((\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W})`BB)\\<noteq>0\" by auto moreover\n    have \" (N \\<lesssim> Q \\<and> (\\<forall>t\\<in>N. (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t \\<noteq> 0) \\<longrightarrow> (\\<exists>f. f \\<in> Pi(N,\\<lambda>t. (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t) \\<and> (\\<forall>t\\<in>N. f ` t \\<in> (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t)))\" \n      using assms(3) unfolding AxiomCardinalChoiceGen_def by blast\n    ultimately\n    obtain f where AA:\"f\\<in>Pi(N,\\<lambda>t. (\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t)\" \"\\<forall>t\\<in>N. f`t\\<in>(\\<lambda>W\\<in>N. {S\\<in>M. B\\<inter>S=W}) ` t\" by blast\n    from AA(2) have ss:\"\\<forall>t\\<in>N. f`t\\<in>{S\\<in>M. B\\<inter>S=t}\" using beta_if by auto\n    then have \"{f`t. t\\<in>N}\\<subseteq>M\" by auto\n    {\n      fix t assume \"t\\<in>N\"\n      with ss have \"f`t\\<in>{S\\<in>M. B\\<inter>S\\<in>N}\" by auto\n    }\n    with AA(1) have FF:\"f:N\\<rightarrow>{S\\<in>M. B\\<inter>S\\<in>N}\" unfolding Pi_def Sigma_def using beta_if by auto moreover\n    {\n      fix aa bb assume AAA:\"aa\\<in>N\" \"bb\\<in>N\" \"f`aa=f`bb\"\n      from AAA(1) ss have \"B\\<inter> (f`aa) =aa\" by auto\n      with AAA(3) have \"B\\<inter>(f`bb)=aa\" by auto\n      with ss AAA(2) have \"aa=bb\" by auto\n    }\n    ultimately have \"f\\<in>inj(N,{S\\<in>M. B\\<inter>S\\<in>N})\" unfolding inj_def by auto\n    then have \"f\\<in>bij(N,range(f))\" using inj_bij_range by auto\n    then have \"f\\<in>bij(N,f``N)\" using range_image_domain FF by auto\n    then have \"f\\<in>bij(N,{f`t. t\\<in>N})\" using func_imagedef FF by auto\n    then have \"N\\<approx>{f`t. t\\<in>N}\" unfolding eqpoll_def by auto\n    with \\<open>N\\<prec>Q\\<close> have \"{f`t. t\\<in>N}\\<prec>Q\" using eqpoll_sym eq_lesspoll_trans by blast moreover\n    with ss have \"{f`t. t\\<in>N}\\<in>Pow(M)\" unfolding FinPow_def by auto moreover\n    {\n      fix aa assume \"aa\\<in>A\"\n      with \\<open>A\\<subseteq>\\<Union>N\\<close> obtain b where \"b\\<in>N\" and \"aa\\<in>b\" by auto\n      with ss have \"B\\<inter>(f`b)=b\" by auto\n      with \\<open>aa\\<in>b\\<close> have \"aa\\<in>B\\<inter>(f`b)\" by auto\n      then have \"aa\\<in> f`b\" by auto\n      with \\<open>b\\<in>N\\<close> have \"aa\\<in>\\<Union>{f`t. t\\<in>N}\" by auto\n    }\n    then have \"A\\<subseteq>\\<Union>{f`t. t\\<in>N}\" by auto ultimately\n    have \"\\<exists>R\\<in>Pow(M). A\\<subseteq>\\<Union>R \\<and> R\\<prec>Q\" by auto\n  }\n  then show ?thesis using a1 a2 unfolding IsCompactOfCard_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2377
    },
    "2141": {
        "type": "lemma",
        "text": "text\\<open>Every set, with the cofinite topology is compact.\\<close>\n",
        "assumes": "",
        "using": [
            "union_cocardinal",
            "Cofinite_def",
            "lesspoll_nat_is_Finite",
            "compact_spectrum",
            "InfCard_nat",
            "CoCar_is_topology",
            "subspace_cocardinal",
            "compact_subspace_imp_compact[of",
            "\"X-U\"\"CoFinite",
            "X\"\"X-U\"]",
            "\\<open>X\\<subseteq>\\<Union>M\\<close>"
        ],
        "statement": "lemma cofinite_compact:\n  shows \"X {is compact in}(CoFinite X)\" unfolding IsCompact_def\n",
        "proof": "proof\n  show \"X\\<subseteq>\\<Union>(CoFinite X)\" using union_cocardinal unfolding Cofinite_def by auto\nnext\n  {\n    fix M assume \"M\\<in>Pow(CoFinite X)\" \"X\\<subseteq>\\<Union>M\"\n    {\n      assume \"M=0\\<or>M={0}\"\n      then have \"M\\<in>FinPow(M)\" unfolding FinPow_def by auto\n      with \\<open>X\\<subseteq>\\<Union>M\\<close> have \"\\<exists>N\\<in>FinPow(M). X\\<subseteq>\\<Union>N\" by auto\n    }\n    moreover\n    {\n      assume \"M\\<noteq>0\"\"M\\<noteq>{0}\"\n      then obtain U where \"U\\<in>M\"\"U\\<noteq>0\" by auto\n      with \\<open>M\\<in>Pow(CoFinite X)\\<close> have \"U\\<in>CoFinite X\" by auto\n      with \\<open>U\\<noteq>0\\<close> have \"U\\<subseteq>X\" \"(X-U)\\<prec>nat\" unfolding Cofinite_def CoCardinal_def by auto\n      then have \"Finite(X-U)\" using lesspoll_nat_is_Finite by auto\n      then have \"(X-U){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using compact_spectrum\n        by auto\n      then have \"((\\<Union>(CoFinite (X-U)))\\<approx>X-U) \\<longrightarrow> ((\\<Union>(CoFinite (X-U))){is compact in}(CoFinite (X-U)))\" unfolding Spec_def\n        using InfCard_nat CoCar_is_topology unfolding Cofinite_def by auto\n      then have com:\"(X-U){is compact in}(CoFinite (X-U))\" using union_cocardinal unfolding Cofinite_def by auto\n      have \"(X-U)\\<inter>X=X-U\" by auto\n      then have \"(CoFinite X){restricted to}(X-U)=(CoFinite (X-U))\" using subspace_cocardinal unfolding Cofinite_def by auto\n      with com have \"(X-U){is compact in}(CoFinite X)\" using compact_subspace_imp_compact[of \"X-U\"\"CoFinite X\"\"X-U\"] by auto\n      moreover have \"X-U\\<subseteq>\\<Union>M\" using \\<open>X\\<subseteq>\\<Union>M\\<close> by auto\n      moreover note \\<open>M\\<in>Pow(CoFinite X)\\<close>\n      ultimately have \"\\<exists>N\\<in>FinPow(M). X-U\\<subseteq>\\<Union>N\" unfolding IsCompact_def by auto\n      then obtain N where \"N\\<subseteq>M\" \"Finite(N)\" \"X-U\\<subseteq>\\<Union>N\" unfolding FinPow_def by auto\n      with \\<open>U\\<in>M\\<close> have \"N \\<union>{U}\\<subseteq>M\" \"Finite(N \\<union>{U})\" \"X\\<subseteq>\\<Union>(N \\<union>{U})\" by auto\n      then have \"\\<exists>N\\<in>FinPow(M). X\\<subseteq>\\<Union>N\" unfolding FinPow_def by blast\n    }\n    ultimately\n    have \"\\<exists>N\\<in>FinPow(M). X\\<subseteq>\\<Union>N\" by auto\n  }\n  then show \"\\<forall>M\\<in>Pow(CoFinite X). X \\<subseteq> \\<Union>M \\<longrightarrow> (\\<exists>N\\<in>FinPow(M). X \\<subseteq> \\<Union>N)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2378
    },
    "2142": {
        "type": "theorem",
        "text": "text\\<open>In every locally compact space, by definition, every point has a compact neighbourhood.\\<close>\n",
        "assumes": "assumes \"T{is locally-compact}\"\n  ",
        "using": [
            "union_open",
            "topSpaceAssum",
            "assms",
            "IsLocally_def",
            "IsLocallyComp_def"
        ],
        "statement": "theorem (in topology0) locally_compact_exist_compact_neig:\n  assumes \"T{is locally-compact}\"\n  shows \"\\<forall>x\\<in>\\<Union>T. \\<exists>A\\<in>Pow(\\<Union>T). A{is compact in}T \\<and> x\\<in>int(A)\"\n",
        "proof": "proof-\n  {\n    fix x assume \"x\\<in>\\<Union>T\" moreover\n    then have \"\\<Union>T\\<noteq>0\" by auto\n    have \"\\<Union>T\\<in>T\" using union_open topSpaceAssum by auto\n    ultimately have \"\\<exists>c\\<in>Pow(\\<Union>T). x\\<in>int(c)\\<and> c{is compact in}T\" using assms \n      IsLocally_def topSpaceAssum unfolding IsLocallyComp_def by auto\n    then have \"\\<exists>c\\<in>Pow(\\<Union>T). c{is compact in}T \\<and> x\\<in>int(c)\" by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2380
    },
    "2143": {
        "type": "theorem",
        "text": "text\\<open>In Hausdorff spaces, the previous result is an equivalence.\\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>\\<Union>T. \\<exists>A\\<in>Pow(\\<Union>T). x\\<in>int(A) \\<and> A{is compact in}T\" \"T{is T\\<^sub>2}\"\n  ",
        "using": [
            "in_t2_compact_is_cl",
            "assms(2)",
            "Top_2_L2",
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L1",
            "Top_2_L5",
            "Acl",
            "Top_3_L13",
            "cl_is_closed(1)",
            "\\<open>?V\\<subseteq>A\\<close>",
            "\\<open>A\\<subseteq>\\<Union>T\\<close>",
            "Acom",
            "compact_closed[of",
            "\"A\"\"nat\"\"T\"\"cl(?V)\"]",
            "Compact_is_card_nat",
            "compact_imp_compact_subspace[of",
            "\"cl(?V)\"\"nat\"\"T\"]",
            "clcl",
            "IsClosed_def",
            "T2_here",
            "topology0.T2_compact_is_normal",
            "topology0_def",
            "Top_1_L4",
            "isT4_def",
            "T2_is_T1",
            "topology0.T4_is_T3",
            "isT3_def",
            "cl_contains_set",
            "topology0.regular_imp_exist_clos_neig",
            "clvreg",
            "topology0.cl_contains_set",
            "\\<open>?V\\<subseteq>cl(?V)\\<close>",
            "Top_3_L11(1)",
            "subspace_of_subspace",
            "Wop",
            "Top_2_L6",
            "cinW",
            "topology0.cl_is_closed(1)",
            "compact_closed",
            "\\<open>?V\\<subseteq>A\\<close>\\<open>A\\<subseteq>\\<Union>T\\<close>",
            "compact_subspace_imp_compact[of",
            "\"Closure(W,T{restricted",
            "to}cl(?V))\"]",
            "cont"
        ],
        "statement": "theorem (in topology0) exist_compact_neig_T2_imp_locally_compact:\n  assumes \"\\<forall>x\\<in>\\<Union>T. \\<exists>A\\<in>Pow(\\<Union>T). x\\<in>int(A) \\<and> A{is compact in}T\" \"T{is T\\<^sub>2}\"\n  shows \"T{is locally-compact}\"\n",
        "proof": "proof-\n  {\n    fix x assume \"x\\<in>\\<Union>T\"\n    with assms(1) obtain A where \"A\\<in>Pow(\\<Union>T)\" \"x\\<in>int(A)\" and Acom:\"A{is compact in}T\" by blast\n    then have Acl:\"A{is closed in}T\" using in_t2_compact_is_cl assms(2) by auto\n    then have sub:\"A\\<subseteq>\\<Union>T\" unfolding IsClosed_def by auto\n    {\n      fix U assume \"U\\<in>T\" \"x\\<in>U\"\n      let ?V=\"int(A\\<inter>U)\"\n      from \\<open>x\\<in>U\\<close> \\<open>x\\<in>int(A)\\<close> have \"x\\<in>U\\<inter>(int (A))\" by auto\n      moreover from \\<open>U\\<in>T\\<close> have \"U\\<inter>(int(A))\\<in>T\" using Top_2_L2 topSpaceAssum unfolding IsATopology_def\n        by auto moreover\n      have \"U\\<inter>(int(A))\\<subseteq>A\\<inter>U\" using Top_2_L1 by auto\n      ultimately have \"x\\<in>?V\" using Top_2_L5 by blast\n      have \"?V\\<subseteq>A\" using Top_2_L1 by auto\n      then have \"cl(?V)\\<subseteq>A\" using Acl Top_3_L13 by auto\n      then have \"A\\<inter>cl(?V)=cl(?V)\" by auto moreover\n      have clcl:\"cl(?V){is closed in}T\" using cl_is_closed(1) \\<open>?V\\<subseteq>A\\<close> \\<open>A\\<subseteq>\\<Union>T\\<close> by auto\n      ultimately have comp:\"cl(?V){is compact in}T\" using Acom compact_closed[of \"A\"\"nat\"\"T\"\"cl(?V)\"] Compact_is_card_nat\n        by auto\n      {\n        then have \"cl(?V){is compact in}(T{restricted to}cl(?V))\" using compact_imp_compact_subspace[of \"cl(?V)\"\"nat\"\"T\"] Compact_is_card_nat\n          by auto moreover\n        have \"\\<Union>(T{restricted to}cl(?V))=cl(?V)\" unfolding RestrictedTo_def using clcl unfolding IsClosed_def by auto moreover\n        ultimately have \"(\\<Union>(T{restricted to}cl(?V))){is compact in}(T{restricted to}cl(?V))\" by auto\n      }\n      then have \"(\\<Union>(T{restricted to}cl(?V))){is compact in}(T{restricted to}cl(?V))\" by auto moreover\n      have \"(T{restricted to}cl(?V)){is T\\<^sub>2}\" using assms(2) T2_here clcl unfolding IsClosed_def by auto\n      ultimately have \"(T{restricted to}cl(?V)){is T\\<^sub>4}\" using topology0.T2_compact_is_normal unfolding topology0_def\n        using Top_1_L4 unfolding isT4_def using T2_is_T1 by auto\n      then have clvreg:\"(T{restricted to}cl(?V)){is regular}\" using topology0.T4_is_T3 unfolding topology0_def isT3_def using Top_1_L4\n        by auto \n      have \"?V\\<subseteq>cl(?V)\" using cl_contains_set \\<open>?V\\<subseteq>A\\<close> \\<open>A\\<subseteq>\\<Union>T\\<close> by auto\n      then have \"?V\\<in>(T{restricted to}cl(?V))\" unfolding RestrictedTo_def using Top_2_L2 by auto\n      with \\<open>x\\<in>?V\\<close> obtain W where Wop:\"W\\<in>(T{restricted to}cl(?V))\" and clcont:\"Closure(W,(T{restricted to}cl(?V)))\\<subseteq>?V\" and cinW:\"x\\<in>W\"\n      using topology0.regular_imp_exist_clos_neig unfolding topology0_def using Top_1_L4 clvreg\n        by blast\n      from clcont Wop have \"W\\<subseteq>?V\" using topology0.cl_contains_set unfolding topology0_def using Top_1_L4 by auto\n      with Wop have \"W\\<in>(T{restricted to}cl(?V)){restricted to}?V\" unfolding RestrictedTo_def by auto\n      moreover from \\<open>?V\\<subseteq>A\\<close> \\<open>A\\<subseteq>\\<Union>T\\<close> have \"?V\\<subseteq>\\<Union>T\" by auto\n      then have \"?V\\<subseteq>cl(?V)\"\"cl(?V)\\<subseteq>\\<Union>T\" using \\<open>?V\\<subseteq>cl(?V)\\<close> Top_3_L11(1) by auto\n      then have \"(T{restricted to}cl(?V)){restricted to}?V=(T{restricted to}?V)\" using subspace_of_subspace by auto\n      ultimately have \"W\\<in>(T{restricted to}?V)\" by auto\n      then obtain UU where \"UU\\<in>T\" \"W=UU\\<inter>?V\" unfolding RestrictedTo_def by auto\n      then have \"W\\<in>T\" using Top_2_L2 topSpaceAssum unfolding IsATopology_def by auto moreover\n      have \"W\\<subseteq>Closure(W,(T{restricted to}cl(?V)))\" using topology0.cl_contains_set unfolding topology0_def\n        using Top_1_L4 Wop by auto\n      ultimately have A1:\"x\\<in>int(Closure(W,(T{restricted to}cl(?V))))\" using Top_2_L6 cinW by auto\n      from clcont have A2:\"Closure(W,(T{restricted to}cl(?V)))\\<subseteq>U\" using Top_2_L1 by auto\n      have clwcl:\"Closure(W,(T{restricted to}cl(?V))) {is closed in}(T{restricted to}cl(?V))\"\n        using topology0.cl_is_closed(1) Top_1_L4 Wop unfolding topology0_def by auto\n      from comp have \"cl(?V){is compact in}(T{restricted to}cl(?V))\" using compact_imp_compact_subspace[of \"cl(?V)\"\"nat\"\"T\"] Compact_is_card_nat\n          by auto\n      with clwcl have \"((cl(?V)\\<inter>(Closure(W,(T{restricted to}cl(?V)))))){is compact in}(T{restricted to}cl(?V))\"\n        using compact_closed Compact_is_card_nat by auto moreover\n      from clcont have cont:\"(Closure(W,(T{restricted to}cl(?V))))\\<subseteq>cl(?V)\" using cl_contains_set \\<open>?V\\<subseteq>A\\<close>\\<open>A\\<subseteq>\\<Union>T\\<close>\n        by blast\n      then have \"((cl(?V)\\<inter>(Closure(W,(T{restricted to}cl(?V))))))=Closure(W,(T{restricted to}cl(?V)))\" by auto\n      ultimately have \"Closure(W,(T{restricted to}cl(?V))){is compact in}(T{restricted to}cl(?V))\" by auto\n      then have \"Closure(W,(T{restricted to}cl(?V))){is compact in}T\" using compact_subspace_imp_compact[of \"Closure(W,T{restricted to}cl(?V))\"]\n        cont by auto\n      with A1 A2 have \"\\<exists>c\\<in>Pow(U). x\\<in>int(c)\\<and>c{is compact in}T\" by auto\n    }\n    then have \"\\<forall>U\\<in>T. x\\<in>U \\<longrightarrow> (\\<exists>c\\<in>Pow(U). x\\<in>int(c)\\<and>c{is compact in}T)\" by auto\n  }\n  then show ?thesis unfolding IsLocally_def[OF topSpaceAssum] IsLocallyComp_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2381
    },
    "2144": {
        "type": "definition",
        "text": "text\\<open>Given a topological space, we can always add one point to the space and get a new compact topology; as we\nwill check in this section.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  OPCompactification (\"{one-point compactification of}_\" 90)\n  where \"{one-point compactification of}T\\<equiv>T\\<union>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2382
    },
    "2145": {
        "type": "theorem",
        "text": "text\\<open>Firstly, we check that what we defined is indeed a topology.\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "IsATopology_def",
            "mem_not_refl",
            "c1",
            "MK_def",
            "Top_3_L4",
            "Compact_is_card_nat",
            "compact_closed[of",
            "\"K1\"\"nat\"\"T\"\"\\<Inter>?KK\"]",
            "Union_iff",
            "\\<open>(\\<Inter>?KK){is",
            "closed",
            "in}T\\<close>\\<open>(\\<Union>T-(\\<Union>?MT)){is",
            "in}T\\<close>",
            "Top_3_L5",
            "\"\\<Inter>?KK\"\"nat\"\"T\"\"(\\<Union>T-\\<Union>?MT)\"]",
            "A(2)",
            "V(3)",
            "V(1)",
            "IsClosed_def",
            "A(1)",
            "A",
            "U(3)",
            "U(1)",
            "union_compact[of",
            "\"KV\"\"nat\"\"T\"\"KU\"]",
            "InfCard_nat"
        ],
        "statement": "theorem (in topology0) op_comp_is_top:\n  shows \"({one-point compactification of}T){is a topology}\" unfolding IsATopology_def\n",
        "proof": "proof(safe)\n  fix M assume \"M\\<subseteq>{one-point compactification of}T\"\n  then have disj:\"M\\<subseteq>T\\<union>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}\" unfolding OPCompactification_def by auto\n  let ?MT=\"{A\\<in>M. A\\<in>T}\"\n  have \"?MT\\<subseteq>T\" by auto\n  then have c1:\"\\<Union>?MT\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n  let ?MK=\"{A\\<in>M. A\\<notin>T}\"\n  have \"\\<Union>M=\\<Union>?MK \\<union> \\<Union>?MT\" by auto\n  from disj have \"?MK\\<subseteq>{A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}\" by auto\n  moreover have N:\"\\<Union>T\\<notin>(\\<Union>T)\" using mem_not_refl by auto\n  {\n    fix B assume \"B\\<in>M\" \"B\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}\"\n    then obtain K where \"K\\<in>Pow(\\<Union>T)\" \"B={\\<Union>T}\\<union>((\\<Union>T)-K)\" by auto\n    with N have \"\\<Union>T\\<in>B\" by auto\n    with N have \"B\\<notin>T\" by auto\n    with \\<open>B\\<in>M\\<close> have \"B\\<in>?MK\" by auto\n  }\n  then have \"{A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}\\<subseteq>?MK\" by auto\n  ultimately have MK_def:\"?MK={A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}\" by auto\n  let ?KK=\"{K\\<in>Pow(\\<Union>T). {\\<Union>T}\\<union>((\\<Union>T)-K)\\<in>?MK}\"\n  {\n    assume \"?MK=0\"\n    then have \"\\<Union>M=\\<Union>?MT\" by auto\n    then have \"\\<Union>M\\<in>T\" using c1 by auto\n    then have \"\\<Union>M\\<in>{one-point compactification of}T\" unfolding OPCompactification_def by auto\n  }\n  moreover\n  {\n    assume \"?MK\\<noteq>0\"\n    then obtain A where \"A\\<in>?MK\" by auto\n    then obtain K1 where \"A={\\<Union>T}\\<union>((\\<Union>T)-K1)\" \"K1\\<in>Pow(\\<Union>T)\" \"K1{is closed in}T\" \"K1{is compact in}T\" using MK_def by auto\n    with \\<open>A\\<in>?MK\\<close> have \"\\<Inter>?KK\\<subseteq>K1\" by auto\n    from \\<open>A\\<in>?MK\\<close> \\<open>A={\\<Union>T}\\<union>((\\<Union>T)-K1)\\<close> \\<open>K1\\<in>Pow(\\<Union>T)\\<close> have \"?KK\\<noteq>0\" by blast\n    {\n      fix K assume \"K\\<in>?KK\"\n      then have \"{\\<Union>T}\\<union>((\\<Union>T)-K)\\<in>?MK\" \"K\\<subseteq>\\<Union>T\" by auto\n      then obtain KK where A:\"{\\<Union>T}\\<union>((\\<Union>T)-K)={\\<Union>T}\\<union>((\\<Union>T)-KK)\" \"KK\\<subseteq>\\<Union>T\" \"KK{is compact in}T\" \"KK{is closed in}T\" using MK_def by auto\n      note A(1) moreover\n      have \"(\\<Union>T)-K\\<subseteq>{\\<Union>T}\\<union>((\\<Union>T)-K)\" \"(\\<Union>T)-KK\\<subseteq>{\\<Union>T}\\<union>((\\<Union>T)-KK)\" by auto\n      ultimately have \"(\\<Union>T)-K\\<subseteq>{\\<Union>T}\\<union>((\\<Union>T)-KK)\" \"(\\<Union>T)-KK\\<subseteq>{\\<Union>T}\\<union>((\\<Union>T)-K)\" by auto moreover\n      from N have \"\\<Union>T\\<notin>(\\<Union>T)-K\" \"\\<Union>T\\<notin>(\\<Union>T)-KK\" by auto ultimately\n      have \"(\\<Union>T)-K\\<subseteq>((\\<Union>T)-KK)\" \"(\\<Union>T)-KK\\<subseteq>((\\<Union>T)-K)\" by auto\n      then have \"(\\<Union>T)-K=(\\<Union>T)-KK\" by auto moreover\n      from \\<open>K\\<subseteq>\\<Union>T\\<close> have \"K=(\\<Union>T)-((\\<Union>T)-K)\" by auto ultimately\n      have \"K=(\\<Union>T)-((\\<Union>T)-KK)\" by auto\n      with \\<open>KK\\<subseteq>\\<Union>T\\<close> have \"K=KK\" by auto\n      with A(4) have \"K{is closed in}T\" by auto\n    }\n    then have \"\\<forall>K\\<in>?KK. K{is closed in}T\" by auto\n    with \\<open>?KK\\<noteq>0\\<close> have \"(\\<Inter>?KK){is closed in}T\" using Top_3_L4 by auto\n    with \\<open>K1{is compact in}T\\<close> have \"(K1\\<inter>(\\<Inter>?KK)){is compact in}T\" using Compact_is_card_nat\n      compact_closed[of \"K1\"\"nat\"\"T\"\"\\<Inter>?KK\"] by auto moreover\n    from \\<open>\\<Inter>?KK\\<subseteq>K1\\<close> have \"K1\\<inter>(\\<Inter>?KK)=(\\<Inter>?KK)\" by auto ultimately\n    have \"(\\<Inter>?KK){is compact in}T\" by auto\n    with \\<open>(\\<Inter>?KK){is closed in}T\\<close> \\<open>\\<Inter>?KK\\<subseteq>K1\\<close> \\<open>K1\\<in>Pow(\\<Union>T)\\<close> have \"({\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK)))\\<in>({one-point compactification of}T)\"\n      unfolding OPCompactification_def by blast\n    have t:\"\\<Union>?MK=\\<Union>{A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}\"\n      using MK_def by auto\n    {\n      fix x assume \"x\\<in>\\<Union>?MK\"\n      with t have \"x\\<in>\\<Union>{A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}\" by auto \n      then have \"\\<exists>AA\\<in>{A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}. x\\<in>AA\"\n        using Union_iff by auto\n      then obtain AA where AAp:\"AA\\<in>{A\\<in>M. A\\<in>{{\\<Union>T}\\<union>((\\<Union>T)-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T \\<and> B{is closed in}T}}}\" \"x\\<in>AA\" by auto\n      then obtain K2 where \"AA={\\<Union>T}\\<union>((\\<Union>T)-K2)\" \"K2\\<in>Pow(\\<Union>T)\"\"K2{is compact in}T\" \"K2{is closed in}T\" by auto\n      with \\<open>x\\<in>AA\\<close> have \"x=\\<Union>T \\<or> (x\\<in>(\\<Union>T) \\<and> x\\<notin>K2)\" by auto\n      from \\<open>K2\\<in>Pow(\\<Union>T)\\<close> \\<open>AA={\\<Union>T}\\<union>((\\<Union>T)-K2)\\<close> AAp(1) MK_def have \"K2\\<in>?KK\" by auto\n      then have \"\\<Inter>?KK\\<subseteq>K2\" by auto\n      with \\<open>x=\\<Union>T \\<or> (x\\<in>(\\<Union>T) \\<and> x\\<notin>K2)\\<close> have \"x=\\<Union>T\\<or>(x\\<in>\\<Union>T \\<and> x\\<notin>\\<Inter>?KK)\" by auto\n     then have \"x\\<in>{\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK))\" by auto\n    }\n    then have \"\\<Union>?MK\\<subseteq>{\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK))\" by auto\n    moreover\n    {\n      fix x assume \"x\\<in>{\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK))\"\n      then have \"x=\\<Union>T\\<or>(x\\<in>(\\<Union>T)\\<and> x\\<notin>\\<Inter>?KK)\" by auto\n      with \\<open>?KK\\<noteq>0\\<close> obtain K2 where \"K2\\<in>?KK\" \"x=\\<Union>T\\<or>(x\\<in>\\<Union>T\\<and> x\\<notin>K2)\" by auto\n      then have \"{\\<Union>T}\\<union>((\\<Union>T)-K2)\\<in>?MK\" by auto\n      with \\<open>x=\\<Union>T\\<or>(x\\<in>\\<Union>T\\<and> x\\<notin>K2)\\<close> have \"x\\<in>\\<Union>?MK\" by auto\n    }\n    then have \"{\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK))\\<subseteq>\\<Union>?MK\" by (safe,auto)\n    ultimately have \"\\<Union>?MK={\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK))\" by blast\n    from \\<open>\\<Union>?MT\\<in>T\\<close> have \"\\<Union>T-(\\<Union>T-\\<Union>?MT)=\\<Union>?MT\" by auto\n    with \\<open>\\<Union>?MT\\<in>T\\<close> have \"(\\<Union>T-\\<Union>?MT){is closed in}T\" unfolding IsClosed_def by auto\n    have \"((\\<Union>T)-(\\<Inter>?KK))\\<union>(\\<Union>T-(\\<Union>T-\\<Union>?MT))=(\\<Union>T)-((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT))\" by auto\n    then have \"({\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK)))\\<union>(\\<Union>T-(\\<Union>T-\\<Union>?MT))={\\<Union>T}\\<union>((\\<Union>T)-((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)))\" by auto\n    with \\<open>\\<Union>?MK={\\<Union>T}\\<union>((\\<Union>T)-(\\<Inter>?KK))\\<close>\\<open>\\<Union>T-(\\<Union>T-\\<Union>?MT)=\\<Union>?MT\\<close> have \"\\<Union>?MK\\<union>\\<Union>?MT={\\<Union>T}\\<union>((\\<Union>T)-((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)))\"\n    by auto\n    with \\<open>\\<Union>M=\\<Union>?MK \\<union>\\<Union>?MT\\<close> have unM:\"\\<Union>M={\\<Union>T}\\<union>((\\<Union>T)-((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)))\" by auto\n    have \"((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)) {is closed in}T\" using \\<open>(\\<Inter>?KK){is closed in}T\\<close>\\<open>(\\<Union>T-(\\<Union>?MT)){is closed in}T\\<close>\n      Top_3_L5 by auto\n    moreover  \n    note \\<open>(\\<Union>T-(\\<Union>?MT)){is closed in}T\\<close> \\<open>(\\<Inter>?KK){is compact in}T\\<close>\n    then have \"((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)){is compact of cardinal}nat{in}T\" using compact_closed[of \"\\<Inter>?KK\"\"nat\"\"T\"\"(\\<Union>T-\\<Union>?MT)\"] Compact_is_card_nat\n      by auto\n    then have \"((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)){is compact in}T\" using Compact_is_card_nat by auto\n    ultimately have \"{\\<Union>T}\\<union>(\\<Union>T-((\\<Inter>?KK)\\<inter>(\\<Union>T-\\<Union>?MT)))\\<in>{one-point compactification of}T\"\n      unfolding OPCompactification_def IsClosed_def by auto\n    with unM have \"\\<Union>M\\<in>{one-point compactification of}T\" by auto\n  }\n  ultimately show \"\\<Union>M\\<in>{one-point compactification of}T\" by auto\nnext\n  fix U V assume \"U\\<in>{one-point compactification of}T\" and \"V\\<in>{one-point compactification of}T\"\n  then have A:\"U\\<in>T\\<or>(\\<exists>KU\\<in>Pow(\\<Union>T). U={\\<Union>T}\\<union>(\\<Union>T-KU)\\<and>KU{is closed in}T\\<and>KU{is compact in}T)\"\n    \"V\\<in>T\\<or>(\\<exists>KV\\<in>Pow(\\<Union>T). V={\\<Union>T}\\<union>(\\<Union>T-KV)\\<and>KV{is closed in}T\\<and>KV{is compact in}T)\" unfolding OPCompactification_def\n    by auto\n have N:\"\\<Union>T\\<notin>(\\<Union>T)\" using mem_not_refl by auto\n  {\n    assume \"U\\<in>T\"\"V\\<in>T\"\n    then have \"U\\<inter>V\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    then have \"U\\<inter>V\\<in>{one-point compactification of}T\" unfolding OPCompactification_def\n    by auto\n  }\n  moreover\n  {\n    assume \"U\\<in>T\"\"V\\<notin>T\"\n    then obtain KV where V:\"KV{is closed in}T\"\"KV{is compact in}T\"\"V={\\<Union>T}\\<union>(\\<Union>T-KV)\"\n    using A(2) by auto\n    with N \\<open>U\\<in>T\\<close> have \"\\<Union>T\\<notin>U\" by auto\n    then have \"\\<Union>T\\<notin>U\\<inter>V\" by auto\n    then have \"U\\<inter>V=U\\<inter>(\\<Union>T-KV)\" using V(3) by auto\n    moreover have \"\\<Union>T-KV\\<in>T\" using V(1) unfolding IsClosed_def by auto\n    with \\<open>U\\<in>T\\<close> have \"U\\<inter>(\\<Union>T-KV)\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    with \\<open>U\\<inter>V=U\\<inter>(\\<Union>T-KV)\\<close> have \"U\\<inter>V\\<in>T\" by auto\n    then have \"U\\<inter>V\\<in>{one-point compactification of}T\" unfolding OPCompactification_def by auto\n    }\n  moreover\n  {\n    assume \"U\\<notin>T\"\"V\\<in>T\"\n    then obtain KV where V:\"KV{is closed in}T\"\"KV{is compact in}T\"\"U={\\<Union>T}\\<union>(\\<Union>T-KV)\"\n    using A(1) by auto\n    with N \\<open>V\\<in>T\\<close> have \"\\<Union>T\\<notin>V\" by auto\n    then have \"\\<Union>T\\<notin>U\\<inter>V\" by auto\n    then have \"U\\<inter>V=(\\<Union>T-KV)\\<inter>V\" using V(3) by auto\n    moreover have \"\\<Union>T-KV\\<in>T\" using V(1) unfolding IsClosed_def by auto\n    with \\<open>V\\<in>T\\<close> have \"(\\<Union>T-KV)\\<inter>V\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    with \\<open>U\\<inter>V=(\\<Union>T-KV)\\<inter>V\\<close> have \"U\\<inter>V\\<in>T\" by auto\n    then have \"U\\<inter>V\\<in>{one-point compactification of}T\" unfolding OPCompactification_def by auto\n  }\n  moreover\n  {\n    assume \"U\\<notin>T\"\"V\\<notin>T\"\n    then obtain KV KU where V:\"KV{is closed in}T\"\"KV{is compact in}T\"\"V={\\<Union>T}\\<union>(\\<Union>T-KV)\"\n     and U:\"KU{is closed in}T\"\"KU{is compact in}T\"\"U={\\<Union>T}\\<union>(\\<Union>T-KU)\"\n    using A by auto\n    with V(3) U(3) have \"\\<Union>T\\<in>U\\<inter>V\" by auto\n    then have \"U\\<inter>V={\\<Union>T}\\<union>((\\<Union>T-KV)\\<inter>(\\<Union>T-KU))\" using V(3) U(3) by auto\n    moreover have \"\\<Union>T-KV\\<in>T\"\"\\<Union>T-KU\\<in>T\" using V(1) U(1) unfolding IsClosed_def by auto\n    then have \"(\\<Union>T-KV)\\<inter>(\\<Union>T-KU)\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    then have \"(\\<Union>T-KV)\\<inter>(\\<Union>T-KU)=\\<Union>T-(\\<Union>T-((\\<Union>T-KV)\\<inter>(\\<Union>T-KU)))\" by auto moreover\n    with \\<open>(\\<Union>T-KV)\\<inter>(\\<Union>T-KU)\\<in>T\\<close> have \"(\\<Union>T-(\\<Union>T-KV)\\<inter>(\\<Union>T-KU)){is closed in}T\" unfolding IsClosed_def\n      by auto moreover\n    from V(1) U(1) have \"(\\<Union>T-(\\<Union>T-KV)\\<inter>(\\<Union>T-KU))=KV\\<union>KU\" unfolding IsClosed_def by auto\n    with V(2) U(2) have \"(\\<Union>T-(\\<Union>T-KV)\\<inter>(\\<Union>T-KU)){is compact in}T\" using union_compact[of \"KV\"\"nat\"\"T\"\"KU\"] Compact_is_card_nat\n      InfCard_nat by auto ultimately\n    have \"U\\<inter>V\\<in>{one-point compactification of}T\" unfolding OPCompactification_def by auto\n  }\n  ultimately show \"U\\<inter>V\\<in>{one-point compactification of}T\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2383
    },
    "2146": {
        "type": "theorem",
        "text": "text\\<open>The original topology is an open subspace of the new topology.\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "IsATopology_def",
            "mem_not_refl",
            "IsClosed_def"
        ],
        "statement": "theorem (in topology0) open_subspace:\n  shows \"\\<Union>T\\<in>{one-point compactification of}T\" and \"({one-point compactification of}T){restricted to}\\<Union>T=T\"\n",
        "proof": "proof-\n  show \"\\<Union>T\\<in>{one-point compactification of}T\"\n  unfolding OPCompactification_def using topSpaceAssum unfolding IsATopology_def by auto\n  have \"T\\<subseteq>({one-point compactification of}T){restricted to}\\<Union>T\" unfolding OPCompactification_def RestrictedTo_def by auto\n  moreover\n  {\n    fix A assume \"A\\<in>({one-point compactification of}T){restricted to}\\<Union>T\"\n    then obtain R where \"R\\<in>({one-point compactification of}T)\" \"A=\\<Union>T\\<inter>R\" unfolding RestrictedTo_def by auto\n    then obtain K where K:\"R\\<in>T \\<or> (R={\\<Union>T}\\<union>(\\<Union>T-K) \\<and> K{is closed in}T)\" unfolding OPCompactification_def by auto\n    with \\<open>A=\\<Union>T\\<inter>R\\<close> have \"(A=R\\<and>R\\<in>T)\\<or>(A=\\<Union>T-K \\<and> K{is closed in}T)\" using mem_not_refl unfolding IsClosed_def by auto\n    with K have \"A\\<in>T\" unfolding IsClosed_def by auto\n  }\n  ultimately\n  show \"({one-point compactification of}T){restricted to}\\<Union>T=T\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2384
    },
    "2147": {
        "type": "lemma",
        "text": "text\\<open>We added only one new point to the space.\\<close>\n",
        "assumes": "",
        "using": [
            "TT"
        ],
        "statement": "lemma (in topology0) op_compact_total:\n  shows \"\\<Union>({one-point compactification of}T)={\\<Union>T}\\<union>(\\<Union>T)\"\n",
        "proof": "proof-\n  have \"0{is compact in}T\" unfolding IsCompact_def FinPow_def by auto\n  moreover note Top_3_L2 ultimately have TT:\"0\\<in>{A\\<in>Pow(\\<Union>T). A{is compact in}T \\<and>A{is closed in}T}\" by auto\n  have \"\\<Union>({one-point compactification of}T)=(\\<Union>T)\\<union>(\\<Union>{{\\<Union>T}\\<union>(\\<Union>T-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T\\<and>B{is closed in}T}})\" unfolding OPCompactification_def\n    by blast\n  also have \"\\<dots>=(\\<Union>T)\\<union>{\\<Union>T}\\<union>(\\<Union>{(\\<Union>T-K). K\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}T\\<and>B{is closed in}T}})\" using TT by auto\n  ultimately show \"\\<Union>({one-point compactification of}T)={\\<Union>T}\\<union>(\\<Union>T)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2385
    },
    "2148": {
        "type": "theorem",
        "text": "text\\<open>The one point compactification, gives indeed a compact topological space.\\<close>\n",
        "assumes": "",
        "using": [
            "open_subspace",
            "mem_not_refl",
            "open_subspace(2)",
            "compact_subspace_imp_compact",
            "\\<open>K{is",
            "closed",
            "in}T\\<close>",
            "IsClosed_def"
        ],
        "statement": "theorem (in topology0) compact_op:\n  shows \"({\\<Union>T}\\<union>(\\<Union>T)){is compact in}({one-point compactification of}T)\" unfolding IsCompact_def\n",
        "proof": "proof(safe)\n  have \"0{is compact in}T\" unfolding IsCompact_def FinPow_def by auto\n  moreover note Top_3_L2 ultimately have \"0\\<in>{A\\<in>Pow(\\<Union>T). A{is compact in}T \\<and>A{is closed in}T}\" by auto\n  then have \"{\\<Union>T}\\<union>(\\<Union>T)\\<in>{one-point compactification of}T\" unfolding OPCompactification_def by auto\n  then show \"\\<Union>T \\<in> \\<Union>{one-point compactification of}T\" by auto\nnext\n  fix x B assume \"x\\<in>B\"\"B\\<in>T\"\n  then show \"x\\<in>\\<Union>({one-point compactification of}T)\" using open_subspace by auto\nnext\n  fix M assume A:\"M\\<subseteq>({one-point compactification of}T)\" \"{\\<Union>T} \\<union> \\<Union>T \\<subseteq> \\<Union>M\"\n  then obtain R where \"R\\<in>M\"\"\\<Union>T\\<in>R\" by auto\n  have \"\\<Union>T\\<notin>\\<Union>T\" using mem_not_refl by auto\n  with \\<open>R\\<in>M\\<close> \\<open>\\<Union>T\\<in>R\\<close> A(1) obtain K where K:\"R={\\<Union>T}\\<union>(\\<Union>T-K)\" \"K{is compact in}T\"\"K{is closed in}T\"\n    unfolding OPCompactification_def by auto\n  from K(1,2) have B:\"{\\<Union>T} \\<union> (\\<Union>T) = R \\<union> K\" unfolding IsCompact_def by auto\n  with A(2) have \"K\\<subseteq>\\<Union>M\" by auto\n  from K(2) have \"K{is compact in}(({one-point compactification of}T){restricted to}\\<Union>T)\" using open_subspace(2)\n    by auto\n  then have \"K{is compact in}({one-point compactification of}T)\" using compact_subspace_imp_compact\n    \\<open>K{is closed in}T\\<close> unfolding IsClosed_def by auto\n  with \\<open>K\\<subseteq>\\<Union>M\\<close> A(1) have \"(\\<exists>N\\<in>FinPow(M). K \\<subseteq> \\<Union>N)\" unfolding IsCompact_def by auto\n  then obtain N where \"N\\<in>FinPow(M)\" \"K\\<subseteq>\\<Union>N\" by auto\n  with \\<open>R\\<in>M\\<close> have \"(N \\<union>{R})\\<in>FinPow(M)\"\"R\\<union>K\\<subseteq>\\<Union>(N\\<union>{R})\" unfolding FinPow_def by auto\n  with B show \"\\<exists>N\\<in>FinPow(M). {\\<Union>T} \\<union> (\\<Union>T)\\<subseteq>\\<Union>N\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2386
    },
    "2149": {
        "type": "lemma",
        "text": "text\\<open>The one point compactification is Hausdorff iff the original space is also\nHausdorff and locally compact.\\<close>\n",
        "assumes": "assumes \"({one-point compactification of}T){is T\\<^sub>2}\"\n  ",
        "using": [
            "T2_here[OF",
            "assms,",
            "of",
            "\"\\<Union>T\"]",
            "open_subspace"
        ],
        "statement": "lemma (in topology0) op_compact_T2_1:\n  assumes \"({one-point compactification of}T){is T\\<^sub>2}\"\n  shows \"T{is T\\<^sub>2}\"\n  ",
        "proof": "using T2_here[OF assms, of \"\\<Union>T\"] open_subspace by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2387
    },
    "2150": {
        "type": "corollary",
        "text": "text\\<open>In conclusion, every locally compact Hausdorff topological space is regular; since this property is hereditary.\\<close>\n",
        "assumes": "assumes \"T{is locally-compact}\" \"T{is T\\<^sub>2}\"\n  ",
        "using": [
            "op_compact_T2_3",
            "T2_is_T1",
            "topology0.T2_compact_is_normal",
            "op_comp_is_top",
            "topology0_def",
            "op_compact_total",
            "compact_op",
            "topology0.T4_is_T3",
            "isT3_def",
            "regular_here",
            "open_subspace(2)"
        ],
        "statement": "corollary (in topology0) locally_compact_T2_imp_regular:\n  assumes \"T{is locally-compact}\" \"T{is T\\<^sub>2}\"\n  shows \"T{is regular}\"\n",
        "proof": "proof-\n  from assms have \"( {one-point compactification of}T) {is T\\<^sub>2}\" using op_compact_T2_3 by auto\n  then have \"({one-point compactification of}T) {is T\\<^sub>4}\" unfolding isT4_def using T2_is_T1 topology0.T2_compact_is_normal\n    op_comp_is_top unfolding topology0_def using op_compact_total compact_op by auto\n  then have \"({one-point compactification of}T) {is T\\<^sub>3}\" using topology0.T4_is_T3 op_comp_is_top unfolding topology0_def\n    by auto\n  then have \"({one-point compactification of}T) {is regular}\" using isT3_def by auto moreover\n  have \"\\<Union>T\\<subseteq>\\<Union>({one-point compactification of}T)\" using op_compact_total by auto\n  ultimately have \"(({one-point compactification of}T){restricted to}\\<Union>T) {is regular}\" using regular_here by auto\n  then show \"T{is regular}\" using open_subspace(2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2388
    },
    "2151": {
        "type": "definition",
        "text": "text\\<open>This last corollary has an explanation: In Hausdorff spaces, compact sets are closed\nand regular spaces are exactly the \"locally closed spaces\"(those which have a neighbourhood basis of closed sets).\nSo the neighbourhood basis of compact sets also works as the neighbourhood basis of closed sets we needed to find.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsLocallyClosed (\"_{is locally-closed}\")\n  where \"T{is locally-closed} \\<equiv> T{is locally}(\\<lambda>B TT. B{is closed in}TT)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2389
    },
    "2152": {
        "type": "lemma",
        "text": "text\\<open>If a property is hereditary in open sets, then local properties are equivalent\nto find just one open neighbourhood with that property instead of a whole local basis.\\<close>\n",
        "assumes": "assumes \"\\<forall>TT. \\<forall>B\\<in>Pow(\\<Union>TT). \\<forall>A\\<in>TT. TT{is a topology}\\<and>P(B,TT) \\<longrightarrow> P(B\\<inter>A,TT)\"\n  ",
        "using": [
            "topSpaceAssum",
            "IsATopology_def",
            "Top_2_L2",
            "b(2)",
            "A_def(1)",
            "Top_2_L3"
        ],
        "statement": "lemma (in topology0) her_P_is_loc_P:\n  assumes \"\\<forall>TT. \\<forall>B\\<in>Pow(\\<Union>TT). \\<forall>A\\<in>TT. TT{is a topology}\\<and>P(B,TT) \\<longrightarrow> P(B\\<inter>A,TT)\"\n  shows \"(T{is locally}P) \\<longleftrightarrow> (\\<forall>x\\<in>\\<Union>T. \\<exists>A\\<in>T. x\\<in>A\\<and>P(A,T))\"\n",
        "proof": "proof\n  assume A:\"T{is locally}P\"\n  {\n    fix x assume x:\"x\\<in>\\<Union>T\"\n    with A have \"\\<forall>b\\<in>T. x\\<in>b \\<longrightarrow> (\\<exists>c\\<in>Pow(b). x\\<in>int(c)\\<and>P(c,T))\" unfolding IsLocally_def[OF topSpaceAssum]\n      by auto moreover\n    note x moreover\n    have \"\\<Union>T\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    ultimately have \"\\<exists>c\\<in>Pow(\\<Union>T). x\\<in>int(c)\\<and> P(c,T)\" by auto\n    then obtain c where c:\"c\\<subseteq>\\<Union>T\"\"x\\<in>int(c)\"\"P(c,T)\" by auto\n    have P:\"int(c)\\<in>T\" using Top_2_L2 by auto moreover\n    from c(1,3) topSpaceAssum assms have \"\\<forall>A\\<in>T. P(c\\<inter>A,T)\" by auto\n    ultimately have \"P(c\\<inter>int(c),T)\" by auto moreover\n    from Top_2_L1[of \"c\"] have \"int(c)\\<subseteq>c\" by auto\n    then have \"c\\<inter>int(c)=int(c)\" by auto\n    ultimately have \"P(int(c),T)\" by auto\n    with P c(2) have \"\\<exists>V\\<in>T. x\\<in>V\\<and>P(V,T)\" by auto\n  }\n  then show \"\\<forall>x\\<in>\\<Union>T. \\<exists>V\\<in>T. x\\<in>V\\<and>P(V,T)\" by auto\n  next\n  assume A:\"\\<forall>x\\<in>\\<Union>T. \\<exists>A\\<in>T. x \\<in> A \\<and> P(A, T)\"\n  {\n    fix x assume x:\"x\\<in>\\<Union>T\"\n    {\n      fix b assume b:\"x\\<in>b\"\"b\\<in>T\"\n      from x A obtain A where A_def:\"A\\<in>T\"\"x\\<in>A\"\"P(A,T)\" by auto\n      from A_def(1,3) assms topSpaceAssum have \"\\<forall>G\\<in>T. P(A\\<inter>G,T)\" by auto\n      with b(2) have \"P(A\\<inter>b,T)\" by auto\n      moreover from b(1) A_def(2) have \"x\\<in>A\\<inter>b\" by auto moreover\n      have \"A\\<inter>b\\<in>T\" using b(2) A_def(1) topSpaceAssum IsATopology_def by auto\n      then have \"int(A\\<inter>b)=A\\<inter>b\" using Top_2_L3 by auto\n      ultimately have \"x\\<in>int(A\\<inter>b)\\<and>P(A\\<inter>b,T)\" by auto\n      then have \"\\<exists>c\\<in>Pow(b). x\\<in>int(c)\\<and>P(c,T)\" by auto\n    }\n    then have \"\\<forall>b\\<in>T. x\\<in>b\\<longrightarrow>(\\<exists>c\\<in>Pow(b). x\\<in>int(c)\\<and>P(c,T))\" by auto\n  }\n  then show \"T{is locally}P\" unfolding IsLocally_def[OF topSpaceAssum] by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2390
    },
    "2153": {
        "type": "theorem",
        "text": "text\\<open>It is easy to check that any open set containing $p$ meets infinite other non-empty\nopen set. The question is if such a topology exists.\\<close>\n",
        "assumes": "assumes \"T{is T\\<^sub>1}\"\"\\<not>(\\<Union>T\\<prec>nat)\"\n  ",
        "using": [
            "mem_not_refl",
            "topSpaceAssum",
            "IsATopology_def",
            "M",
            "topology0.op_comp_is_top[OF",
            "topology0_CoCardinal[OF",
            "InfCard_nat]]",
            "Cofinite_def",
            "assms(1)",
            "T1_cocardinal_coarser",
            "union_open[OF",
            "topSpaceAssum,",
            "of",
            "\"{\\<Union>?MT,\\<Union>?MK}\"]",
            "MM",
            "union_cocardinal",
            "closed_sets_cocardinal",
            "CO2",
            "subset_imp_lepoll",
            "natB",
            "lesspoll_trans1",
            "B(1)",
            "union_cocardinal[of",
            "\"nat\"\"\\<Union>T\"]",
            "subspace_cocardinal",
            "cofinite_compact",
            "compact_subspace_imp_compact",
            "MK(1)",
            "N",
            "G",
            "topology0.open_subspace(2)[OF",
            "topology0.op_compact_total[OF",
            "Q",
            "Cofinite_nat_HConn[OF",
            "assms(2)]",
            "IsHConnected_def",
            "RR",
            "UV(1)",
            "UV(2)"
        ],
        "statement": "theorem (in topology0) COF_comp_is_top:\n  assumes \"T{is T\\<^sub>1}\"\"\\<not>(\\<Union>T\\<prec>nat)\"\n  shows \"((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T) {is a topology}\"\n",
        "proof": "proof-\n  have N:\"\\<Union>T\\<notin>(\\<Union>T)\" using mem_not_refl by auto    \n  {\n    fix M assume M:\"M\\<subseteq>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)\"\n    let ?MT=\"{A\\<in>M. A\\<in>T}\"\n    let ?MK=\"{A\\<in>M. A\\<notin>T}\"\n    have MM:\"(\\<Union>?MT)\\<union>(\\<Union>?MK)=\\<Union>M\" by auto\n    have MN:\"\\<Union>?MT\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n    then have sub:\"?MK\\<subseteq>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\"\n      using M by auto\n    then have \"?MK\\<subseteq>({one-point compactification of}(CoFinite (\\<Union>T)))\" by auto\n    then have CO:\"\\<Union>?MK\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" using \n      topology0.op_comp_is_top[OF topology0_CoCardinal[OF InfCard_nat]] unfolding Cofinite_def\n      IsATopology_def by auto\n    {\n      assume AS:\"\\<Union>?MK={\\<Union>T}\"\n      moreover have \"\\<forall>R\\<in>?MK. R\\<subseteq>\\<Union>?MK\" by auto\n      ultimately have \"\\<forall>R\\<in>?MK. R\\<subseteq>{\\<Union>T}\" by auto\n      then have \"\\<forall>R\\<in>?MK. R={\\<Union>T}\\<or>R=0\" by force moreover\n      with sub have \"\\<forall>R\\<in>?MK. R=0\" by auto\n      then have \"\\<Union>?MK=0\" by auto\n      with AS have \"False\" by auto\n    }\n    with CO have CO2:\"\\<Union>?MK\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n    {\n      assume \"\\<Union>?MK\\<in>(CoFinite (\\<Union>T))\"\n      then have \"\\<Union>?MK\\<in>T\" using assms(1) T1_cocardinal_coarser by auto\n      with MN have \"{\\<Union>?MT,\\<Union>?MK}\\<subseteq>(T)\" by auto\n      then have \"(\\<Union>?MT)\\<union>(\\<Union>?MK)\\<in>T\" using union_open[OF topSpaceAssum, of \"{\\<Union>?MT,\\<Union>?MK}\"] by auto\n      then have \"\\<Union>M\\<in>T\" using MM by auto\n    }\n    moreover\n    {\n      assume \"\\<Union>?MK\\<notin>(CoFinite (\\<Union>T))\"\n      with CO obtain B where \"B{is compact in}(CoFinite (\\<Union>T))\"\"B{is closed in}(CoFinite (\\<Union>T))\"\n        \"\\<Union>?MK={\\<Union>CoFinite \\<Union>T}\\<union>(\\<Union>(CoFinite \\<Union>T)-B)\" unfolding OPCompactification_def by auto\n      then have MK:\"\\<Union>?MK={\\<Union>T}\\<union>(\\<Union>T-B)\"\"B{is closed in}(CoFinite (\\<Union>T))\"\n        using union_cocardinal unfolding Cofinite_def by auto\n      then have B:\"B\\<subseteq>\\<Union>T\" \"B\\<prec>nat\\<or>B=\\<Union>T\" using closed_sets_cocardinal unfolding Cofinite_def by auto\n      {\n        assume \"B=\\<Union>T\"\n        with MK have \"\\<Union>?MK={\\<Union>T}\" by auto\n        then have \"False\" using CO2 by auto\n      }\n      with B have \"B\\<subseteq>\\<Union>T\" and natB:\"B\\<prec>nat\" by auto\n      have \"(\\<Union>T-(\\<Union>?MT))\\<inter>B\\<subseteq>B\" by auto\n      then have \"(\\<Union>T-(\\<Union>?MT))\\<inter>B\\<lesssim>B\" using subset_imp_lepoll by auto\n      then have \"(\\<Union>T-(\\<Union>?MT))\\<inter>B\\<prec>nat\" using natB lesspoll_trans1 by auto\n      then have \"((\\<Union>T-(\\<Union>?MT))\\<inter>B){is closed in}(CoFinite (\\<Union>T))\" using closed_sets_cocardinal\n        B(1) unfolding Cofinite_def by auto\n      then have \"\\<Union>T-((\\<Union>T-(\\<Union>?MT))\\<inter>B)\\<in>(CoFinite (\\<Union>T))\" unfolding IsClosed_def using union_cocardinal unfolding Cofinite_def by auto\n      also have \"\\<Union>T-((\\<Union>T-(\\<Union>?MT))\\<inter>B)=(\\<Union>T-(\\<Union>T-(\\<Union>?MT)))\\<union>(\\<Union>T-B)\" by auto\n      also have \"\\<dots>=(\\<Union>?MT)\\<union>(\\<Union>T-B)\" by auto\n      ultimately have P:\"(\\<Union>?MT)\\<union>(\\<Union>T-B)\\<in>(CoFinite (\\<Union>T))\" by auto\n      then have eq:\"\\<Union>T-(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B)))=(\\<Union>?MT)\\<union>(\\<Union>T-B)\" by auto\n      from P eq have \"(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B))){is closed in}(CoFinite (\\<Union>T))\" unfolding IsClosed_def\n        using union_cocardinal[of \"nat\"\"\\<Union>T\"] unfolding Cofinite_def by auto moreover\n      have \"(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B)))\\<inter>\\<Union>T=(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B)))\" by auto\n      then have \"(CoFinite \\<Union>T){restricted to}(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B)))=CoFinite (\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B)))\" using subspace_cocardinal unfolding Cofinite_def by auto\n      then have \"(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B))){is compact in}((CoFinite \\<Union>T){restricted to}(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B))))\" using cofinite_compact\n        union_cocardinal unfolding Cofinite_def by auto\n      then have \"(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B))){is compact in}(CoFinite \\<Union>T)\" using compact_subspace_imp_compact by auto ultimately\n      have \"{\\<Union>T}\\<union>(\\<Union>T-(\\<Union>T-((\\<Union>?MT)\\<union>(\\<Union>T-B))))\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\"\n        unfolding OPCompactification_def using union_cocardinal unfolding Cofinite_def by auto\n      with eq have \"{\\<Union>T}\\<union>((\\<Union>?MT)\\<union>(\\<Union>T-B))\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" by auto\n      moreover have AA:\"{\\<Union>T}\\<union>((\\<Union>?MT)\\<union>(\\<Union>T-B))=((\\<Union>?MT)\\<union>(\\<Union>?MK))\" using MK(1) by auto\n      ultimately have AA2:\"((\\<Union>?MT)\\<union>(\\<Union>?MK))\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" by auto\n      {\n        assume AS:\"(\\<Union>?MT)\\<union>(\\<Union>?MK)={\\<Union>T}\"\n        from MN have T:\"\\<Union>T\\<notin>\\<Union>?MT\" using N by auto\n        {\n          fix x assume G:\"x\\<in>\\<Union>?MT\"\n          then have \"x\\<in>(\\<Union>?MT)\\<union>(\\<Union>?MK)\" by auto\n          with AS have \"x\\<in>{\\<Union>T}\" by auto\n          then have \"x=\\<Union>T\" by auto\n          with T have \"False\" using G by auto\n        }\n        then have \"\\<Union>?MT=0\" by auto\n        with AS have \"(\\<Union>?MK)={\\<Union>T}\" by auto\n        then have \"False\" using CO2 by auto\n      }\n      with AA2 have \"((\\<Union>?MT)\\<union>(\\<Union>?MK))\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n      with MM have \"\\<Union>M\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n    }\n    ultimately\n    have \"\\<Union>M\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" by auto\n  }\n  then have \"\\<forall>M\\<in>Pow((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T). \\<Union>M\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\"\n    by auto moreover\n  {\n    fix U V assume \"U\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\"\"V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" moreover\n    {\n      assume \"U\\<in>T\"\"V\\<in>T\"\n      then have \"U\\<inter>V\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n      then have \"U\\<inter>V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" by auto\n    }\n    moreover\n    {\n      assume UV:\"U\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\"\"V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\"\n      then have O:\"U\\<inter>V\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" using topology0.op_comp_is_top[OF topology0_CoCardinal[OF InfCard_nat]] unfolding Cofinite_def\n        IsATopology_def by auto\n      then have \"\\<Union>T\\<inter>(U\\<inter>V)\\<in>({one-point compactification of}(CoFinite (\\<Union>T))){restricted to}\\<Union>T\"\n        unfolding RestrictedTo_def by auto\n      then have \"\\<Union>T\\<inter>(U\\<inter>V)\\<in>CoFinite \\<Union>T\" using topology0.open_subspace(2)[OF topology0_CoCardinal[OF InfCard_nat]]\n        union_cocardinal unfolding Cofinite_def by auto\n      from UV have \"U\\<noteq>{\\<Union>T}\"\"V\\<noteq>{\\<Union>T}\"\"\\<Union>T\\<inter>U\\<in>({one-point compactification of}(CoFinite (\\<Union>T))){restricted to}\\<Union>T\"\"\\<Union>T\\<inter>V\\<in>({one-point compactification of}(CoFinite (\\<Union>T))){restricted to}\\<Union>T\"\n        unfolding RestrictedTo_def by auto\n      then have R:\"U\\<noteq>{\\<Union>T}\"\"V\\<noteq>{\\<Union>T}\"\"\\<Union>T\\<inter>U\\<in>CoFinite \\<Union>T\"\"\\<Union>T\\<inter>V\\<in>CoFinite \\<Union>T\" using topology0.open_subspace(2)[OF topology0_CoCardinal[OF InfCard_nat]]\n        union_cocardinal unfolding Cofinite_def by auto\n      from UV have \"U\\<subseteq>\\<Union>({one-point compactification of}(CoFinite (\\<Union>T)))\"\"V\\<subseteq>\\<Union>({one-point compactification of}(CoFinite (\\<Union>T)))\" by auto\n      then have \"U\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\"\"V\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" using topology0.op_compact_total[OF topology0_CoCardinal[OF InfCard_nat]]\n        union_cocardinal unfolding Cofinite_def by auto\n      then have E:\"U=(\\<Union>T\\<inter>U)\\<union>({\\<Union>T}\\<inter>U)\"\"V=(\\<Union>T\\<inter>V)\\<union>({\\<Union>T}\\<inter>V)\"\"U\\<inter>V=(\\<Union>T\\<inter>U\\<inter>V)\\<union>({\\<Union>T}\\<inter>U\\<inter>V)\" by auto\n      {\n        assume Q:\"U\\<inter>V={\\<Union>T}\"\n        then have RR:\"\\<Union>T\\<inter>(U\\<inter>V)=0\" using N by auto\n        {\n          assume \"\\<Union>T\\<inter>U=0\"\n          with E(1) have \"U={\\<Union>T}\\<inter>U\" by auto\n          also have \"\\<dots>\\<subseteq>{\\<Union>T}\" by auto\n          ultimately have \"U\\<subseteq>{\\<Union>T}\" by auto\n          then have \"U=0\\<or>U={\\<Union>T}\" by auto\n          with R(1) have \"U=0\" by auto\n          then have \"U\\<inter>V=0\" by auto\n          then have \"False\" using Q by auto\n        }\n        moreover\n        {\n          assume \"\\<Union>T\\<inter>V=0\"\n          with E(2) have \"V={\\<Union>T}\\<inter>V\" by auto\n          also have \"\\<dots>\\<subseteq>{\\<Union>T}\" by auto\n          ultimately have \"V\\<subseteq>{\\<Union>T}\" by auto\n          then have \"V=0\\<or>V={\\<Union>T}\" by auto\n          with R(2) have \"V=0\" by auto\n          then have \"U\\<inter>V=0\" by auto\n          then have \"False\" using Q by auto\n        }\n        moreover\n        {\n          assume \"\\<Union>T\\<inter>U\\<noteq>0\"\"\\<Union>T\\<inter>V\\<noteq>0\"\n          with R(3,4) have \"(\\<Union>T\\<inter>U)\\<inter>(\\<Union>T\\<inter>V)\\<noteq>0\" using Cofinite_nat_HConn[OF assms(2)]\n            unfolding IsHConnected_def by auto\n          then have \"\\<Union>T\\<inter>(U\\<inter>V)\\<noteq>0\" by auto\n          then have \"False\" using RR by auto\n        }\n        ultimately have \"False\" by auto\n      }\n      with O have \"U\\<inter>V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" by auto\n    }\n    moreover\n    {\n      assume UV:\"U\\<in>T\"\"V\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\"\n      from UV(2) obtain B where \"V\\<in>(CoFinite \\<Union>T)\\<or>(V={\\<Union>T}\\<union>(\\<Union>T-B)\\<and>B{is closed in}(CoFinite (\\<Union>T)))\" unfolding OPCompactification_def\n        using union_cocardinal unfolding Cofinite_def by auto\n      with assms(1) have \"V\\<in>T\\<or>(V={\\<Union>T}\\<union>(\\<Union>T-B)\\<and>B{is closed in}(CoFinite (\\<Union>T)))\" using T1_cocardinal_coarser by auto\n      then have \"V\\<in>T\\<or>(U\\<inter>V=U\\<inter>(\\<Union>T-B)\\<and>B{is closed in}(CoFinite (\\<Union>T)))\" using UV(1) N by auto\n      then have \"V\\<in>T\\<or>(U\\<inter>V=U\\<inter>(\\<Union>T-B)\\<and>(\\<Union>T-B)\\<in>(CoFinite (\\<Union>T)))\" unfolding IsClosed_def using union_cocardinal unfolding Cofinite_def by auto\n      then have \"V\\<in>T\\<or>(U\\<inter>V=U\\<inter>(\\<Union>T-B)\\<and>(\\<Union>T-B)\\<in>T)\" using assms(1) T1_cocardinal_coarser by auto\n      with UV(1) have \"U\\<inter>V\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n      then have \"U\\<inter>V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" by auto\n    }\n    moreover\n    {\n      assume UV:\"U\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\"\"V\\<in>T\"\n      from UV(1) obtain B where \"U\\<in>(CoFinite \\<Union>T)\\<or>(U={\\<Union>T}\\<union>(\\<Union>T-B)\\<and>B{is closed in}(CoFinite (\\<Union>T)))\" unfolding OPCompactification_def\n        using union_cocardinal unfolding Cofinite_def by auto\n      with assms(1) have \"U\\<in>T\\<or>(U={\\<Union>T}\\<union>(\\<Union>T-B)\\<and>B{is closed in}(CoFinite (\\<Union>T)))\" using T1_cocardinal_coarser by auto\n      then have \"U\\<in>T\\<or>(U\\<inter>V=(\\<Union>T-B)\\<inter>V\\<and>B{is closed in}(CoFinite (\\<Union>T)))\" using UV(2) N by auto\n      then have \"U\\<in>T\\<or>(U\\<inter>V=(\\<Union>T-B)\\<inter>V\\<and>(\\<Union>T-B)\\<in>(CoFinite (\\<Union>T)))\" unfolding IsClosed_def using union_cocardinal unfolding Cofinite_def by auto\n      then have \"U\\<in>T\\<or>(U\\<inter>V=(\\<Union>T-B)\\<inter>V\\<and>(\\<Union>T-B)\\<in>T)\" using assms(1) T1_cocardinal_coarser by auto\n      with UV(2) have \"U\\<inter>V\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n      then have \"U\\<inter>V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" by auto\n    }\n    ultimately\n    have \"U\\<inter>V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" by auto\n  }\n  ultimately show ?thesis unfolding IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2392
    },
    "2154": {
        "type": "theorem",
        "text": "text\\<open>The previous construction preserves anti-hyperconnectedness.\\<close>\n",
        "assumes": "assumes \"T{is anti-}IsHConnected\" \"\\<not>(\\<Union>T\\<prec>nat)\"\n  ",
        "using": [
            "mem_not_refl",
            "anti_HConn_imp_T1",
            "topology0.op_compact_total[OF",
            "topology0_CoCardinal[OF",
            "InfCard_nat],",
            "of",
            "\"\\<Union>T\"]",
            "union_cocardinal[of",
            "\"nat\"\"\\<Union>T\"]",
            "Cofinite_def",
            "union_open[OF",
            "topology0.op_comp_is_top[OF",
            "InfCard_nat]],of",
            "\"{one-point",
            "compactification",
            "of}(CoFinite",
            "(\\<Union>T))\"]",
            "tot1",
            "empty_lepollI",
            "eqpoll_0_is_0",
            "eqpoll_sym",
            "subspace_of_subspace[of",
            "\"A\"\"\\<Union>T\"\"((({one-point",
            "(\\<Union>T)))-{{\\<Union>T}})\\<union>T)\"]",
            "TOT",
            "topology0.open_subspace(2)[OF",
            "InfCard_nat]]",
            "union_cocardinal",
            "T1_cocardinal_coarser",
            "topSpaceAssum",
            "IsATopology_def",
            "topology0.open_subspace_hyperconn",
            "topology0.Top_1_L4",
            "COF_comp_is_top[OF",
            "T1",
            "assms(2)]",
            "topology0_def",
            "\"\\<Union>T\\<inter>B\"\"B\"\"((({one-point",
            "HConn_spectrum",
            "lepoll_1_is_sing",
            "sub",
            "topology0.T1_iff_singleton_closed[OF",
            "cocardinal_is_T1[OF",
            "InfCard_nat]",
            "x",
            "compact_spectrum",
            "topology0.Top_1_L4[OF",
            "RestrictedTo_def",
            "compact_subspace_imp_compact",
            "A",
            "singleton_eqpoll_1",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "assms(2)",
            "B",
            "eqpoll_imp_lepoll",
            "subset_imp_lepoll",
            "lepoll_eq_trans"
        ],
        "statement": "theorem (in topology0) COF_comp_antiHConn:\n  assumes \"T{is anti-}IsHConnected\" \"\\<not>(\\<Union>T\\<prec>nat)\"\n  shows \"((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T) {is anti-}IsHConnected\"\n",
        "proof": "proof-\n  have N:\"\\<Union>T\\<notin>(\\<Union>T)\" using mem_not_refl by auto\n  from assms(1) have T1:\"T{is T\\<^sub>1}\" using anti_HConn_imp_T1 by auto\n  have tot1:\"\\<Union>({one-point compactification of}(CoFinite (\\<Union>T)))={\\<Union>T}\\<union>\\<Union>T\" using topology0.op_compact_total[OF topology0_CoCardinal[OF InfCard_nat], of \"\\<Union>T\"]\n        union_cocardinal[of \"nat\"\"\\<Union>T\"] unfolding Cofinite_def by auto \n  then have \"(\\<Union>({one-point compactification of}(CoFinite (\\<Union>T))))\\<union>\\<Union>T={\\<Union>T}\\<union>\\<Union>T\" by auto moreover\n  have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)=(\\<Union>({one-point compactification of}(CoFinite (\\<Union>T))))\\<union>\\<Union>T\"\n    by auto\n  ultimately have tot2:\"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)={\\<Union>T}\\<union>\\<Union>T\" by auto\n  have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" using union_open[OF topology0.op_comp_is_top[OF topology0_CoCardinal[OF InfCard_nat]],of \"{one-point compactification of}(CoFinite (\\<Union>T))\"]\n    tot1 unfolding Cofinite_def by auto moreover\n  {\n    assume \"\\<Union>T=0\"\n    with assms(2) have \"\\<not>(0\\<prec>nat)\" by auto\n    then have \"False\" unfolding lesspoll_def using empty_lepollI eqpoll_0_is_0\n      eqpoll_sym by auto\n  }\n  then have \"\\<Union>T\\<noteq>0\" by auto\n  with N have Not:\"\\<not>(\\<Union>T\\<subseteq>{\\<Union>T})\" by auto\n  {\n    assume \"{\\<Union>T}\\<union>\\<Union>T={\\<Union>T}\" moreover\n    have \"\\<Union>T\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" by auto ultimately\n    have \"\\<Union>T\\<subseteq>{\\<Union>T}\" by auto\n    with Not have \"False\" by auto\n  }\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<noteq>{\\<Union>T}\" by auto ultimately\n  have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T\" by auto\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\" by auto moreover\n  have \"({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T\\<subseteq>({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T\" by auto\n  then have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)\" by auto\n  with tot2 have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" by auto\n  ultimately have TOT:\"\\<Union>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)={\\<Union>T}\\<union>\\<Union>T\" by auto\n  {\n    fix A assume AS:\"A\\<subseteq>\\<Union>T\" \"(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}A) {is hyperconnected}\"\n    from AS(1,2) have e0:\"((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}A=(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}\\<Union>T){restricted to}A\"\n      using subspace_of_subspace[of \"A\"\"\\<Union>T\"\"((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)\"] TOT by auto\n    have e1:\"(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}(\\<Union>T))=((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}){restricted to}\\<Union>T)\\<union>(T{restricted to}\\<Union>T)\"\n      unfolding RestrictedTo_def by auto\n    {\n      fix A assume \"A\\<in>T{restricted to}\\<Union>T\"\n      then obtain B where \"B\\<in>T\"\"A=B\\<inter>\\<Union>T\" unfolding RestrictedTo_def by auto\n      then have \"A=B\" by auto\n      with \\<open>B\\<in>T\\<close> have \"A\\<in>T\" by auto\n    }\n    then have \"T{restricted to}\\<Union>T\\<subseteq>T\" by auto moreover\n      {\n      fix A assume \"A\\<in>T\"\n      then have \"\\<Union>T\\<inter>A=A\" by auto\n      with \\<open>A\\<in>T\\<close> have \"A\\<in>T{restricted to}\\<Union>T\" unfolding RestrictedTo_def by auto\n    }\n    ultimately have \"T{restricted to}\\<Union>T=T\" by auto moreover\n    {\n      fix A assume \"A\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}){restricted to}\\<Union>T\"\n      then obtain B where \"B\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\"\"\\<Union>T\\<inter>B=A\" unfolding RestrictedTo_def by auto\n      then have \"B\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\"\"\\<Union>T\\<inter>B=A\" by auto\n      then have \"A\\<in>({one-point compactification of}(CoFinite (\\<Union>T))){restricted to}\\<Union>T\" unfolding RestrictedTo_def by auto\n      then have \"A\\<in>(CoFinite (\\<Union>T))\" using topology0.open_subspace(2)[OF topology0_CoCardinal[OF InfCard_nat]]\n        union_cocardinal unfolding Cofinite_def by auto\n      with T1 have \"A\\<in>T\" using T1_cocardinal_coarser by auto\n    }\n    then have \"(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}){restricted to}\\<Union>T\\<subseteq>T\" by auto\n    moreover note e1 ultimately\n    have \"((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}} \\<union> T) {restricted to} (\\<Union>T)) =T\" by auto\n    with e0 have \"((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}A=T{restricted to}A\" by auto\n    with assms(1) AS have \"A{is in the spectrum of}IsHConnected\" unfolding antiProperty_def by auto\n  }\n  then have reg:\"\\<forall>A\\<in>Pow(\\<Union>T). ((((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}A) {is hyperconnected}) \\<longrightarrow>(A{is in the spectrum of}IsHConnected)\" by auto\n  have \"\\<Union>T\\<in>T\" using topSpaceAssum unfolding IsATopology_def by auto\n  then have P:\"\\<Union>T\\<in>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)\" by auto\n  {\n    fix B assume sub:\"B\\<in>Pow(\\<Union>T \\<union>{\\<Union>T})\" and hyp:\"((((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B) {is hyperconnected})\"\n    from P have  subop:\"\\<Union>T\\<inter>B\\<in>(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B)\" unfolding RestrictedTo_def by auto\n    with hyp have hypSub:\"((((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B){restricted to}(\\<Union>T\\<inter>B)){is hyperconnected}\" using topology0.open_subspace_hyperconn\n      topology0.Top_1_L4 COF_comp_is_top[OF T1 assms(2)] unfolding topology0_def by auto\n    from sub TOT have \"B \\<subseteq> \\<Union>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}} \\<union> T)\" by auto\n    then have \"(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}(\\<Union>T\\<inter>B))=(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B){restricted to}(\\<Union>T\\<inter>B)\"\n      using subspace_of_subspace[of \"\\<Union>T\\<inter>B\"\"B\"\"((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)\"] by auto\n    with hypSub have \"((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}} \\<union> T) {restricted to} (\\<Union>T \\<inter> B)){is hyperconnected}\" by auto\n    with reg have \"(\\<Union>T\\<inter>B){is in the spectrum of}IsHConnected\" by auto\n    then have le:\"\\<Union>T\\<inter>B\\<lesssim>1\" using HConn_spectrum by auto\n    {\n      fix x assume x:\"x\\<in>\\<Union>T\\<inter>B\"\n      with le have sing:\"\\<Union>T\\<inter>B={x}\" using lepoll_1_is_sing by auto\n      {\n        fix y assume y:\"y\\<in>B\"\n        then have \"y\\<in>\\<Union>T \\<union>{\\<Union>T}\" using sub by auto\n        with y have \"y\\<in>\\<Union>T\\<inter>B\\<or>y=\\<Union>T\" by auto\n        with sing have \"y=x\\<or>y=\\<Union>T\" by auto\n      }\n      then have \"B\\<subseteq>{x,\\<Union>T}\" by auto\n      with x have disj:\"B={x}\\<or>B={x,\\<Union>T}\" by auto\n      {\n        assume \"\\<Union>T\\<in>B\"\n        with disj have B:\"B={x,\\<Union>T}\" by auto\n        from sing subop have singOp:\"{x}\\<in>(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B)\"\n          by auto\n        have \"{x}{is closed in}(CoFinite \\<Union>T)\" using topology0.T1_iff_singleton_closed[OF topology0_CoCardinal[OF InfCard_nat]] cocardinal_is_T1[OF InfCard_nat]\n          x union_cocardinal unfolding Cofinite_def by auto\n        moreover \n        have \"Finite({x})\" by auto\n        then have spec:\"{x}{is in the spectrum of} (\\<lambda>T. (\\<Union>T) {is compact in}T)\" using compact_spectrum by auto\n        have \"((CoFinite \\<Union>T){restricted to}{x}){is a topology}\"\"\\<Union>((CoFinite \\<Union>T){restricted to}{x})={x}\"\n          using topology0.Top_1_L4[OF topology0_CoCardinal[OF InfCard_nat]] unfolding RestrictedTo_def Cofinite_def\n          using x union_cocardinal by auto\n        with spec have \"{x}{is compact in}((CoFinite \\<Union>T){restricted to}{x})\" unfolding Spec_def\n          by auto\n        then have \"{x}{is compact in}(CoFinite \\<Union>T)\" using compact_subspace_imp_compact\n          by auto moreover note x\n        ultimately have \"{\\<Union>T}\\<union>(\\<Union>T-{x})\\<in>{one-point compactification of}(CoFinite (\\<Union>T))\" unfolding OPCompactification_def\n          using union_cocardinal unfolding Cofinite_def by auto moreover\n        {\n          assume A:\"{\\<Union>T}\\<union>(\\<Union>T-{x})={\\<Union>T}\"\n          {\n            fix y assume P:\"y\\<in>\\<Union>T-{x}\"\n            then have \"y\\<in>{\\<Union>T}\\<union>(\\<Union>T-{x})\" by auto\n            then have \"y=\\<Union>T\" using A by auto\n            with N P have \"False\" by auto\n          }\n          then have \"\\<Union>T-{x}=0\" by auto\n          with x have \"\\<Union>T={x}\" by auto\n          then have \"\\<Union>T\\<approx>1\" using singleton_eqpoll_1 by auto moreover\n          have \"1\\<prec>nat\" using n_lesspoll_nat by auto\n          ultimately have \"\\<Union>T\\<prec>nat\" using eq_lesspoll_trans by auto\n          then have \"False\" using assms(2) by auto\n        }\n        ultimately have \"{\\<Union>T}\\<union>(\\<Union>T-{x})\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n        then have  \"{\\<Union>T}\\<union>(\\<Union>T-{x})\\<in>(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T))\" by auto\n        then have \"B\\<inter>({\\<Union>T}\\<union>(\\<Union>T-{x}))\\<in>(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B)\" unfolding RestrictedTo_def by auto\n        moreover have \"B\\<inter>({\\<Union>T}\\<union>(\\<Union>T-{x}))={\\<Union>T}\" using B by auto\n        ultimately have \"{\\<Union>T}\\<in>(((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T){restricted to}B)\" by auto\n        with singOp hyp N x have \"False\" unfolding IsHConnected_def by auto\n      }\n      with disj have \"B={x}\" by auto\n      then have \"B\\<approx>1\" using singleton_eqpoll_1 by auto\n      then have \"B\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n    }\n    then have \"\\<Union>T\\<inter>B\\<noteq>0\\<longrightarrow>B\\<lesssim>1\" by blast\n    moreover\n    {\n      assume \"\\<Union>T\\<inter>B=0\"\n      with sub have \"B\\<subseteq>{\\<Union>T}\" by auto\n      then have \"B\\<lesssim>{\\<Union>T}\" using subset_imp_lepoll by auto\n      then have \"B\\<lesssim>1\" using singleton_eqpoll_1 lepoll_eq_trans by auto\n    }\n    ultimately have \"B\\<lesssim>1\" by auto\n    then have \"B{is in the spectrum of}IsHConnected\" using HConn_spectrum by auto\n  }\n  then show ?thesis unfolding antiProperty_def using TOT by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2393
    },
    "2155": {
        "type": "theorem",
        "text": "text\\<open>Every open set that contains \\<open>\\<Union>T\\<close> is dense, when considering the order\ntopology in a densely ordered set with more than two points.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\" \"U\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" \"\\<Union>T\\<in>U\"\n    \"V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" \"V\\<noteq>0\"\n  ",
        "using": [
            "mem_not_refl",
            "topology0.op_compact_total[OF",
            "topology0_CoCardinal[OF",
            "InfCard_nat],",
            "of",
            "\"\\<Union>T\"]",
            "union_cocardinal[of",
            "\"nat\"\"\\<Union>T\"]",
            "Cofinite_def",
            "union_open[OF",
            "topology0.op_comp_is_top[OF",
            "InfCard_nat]],of",
            "\"{one-point",
            "compactification",
            "of}(CoFinite",
            "(\\<Union>T))\"]",
            "tot1",
            "union_ordtopology[OF",
            "assms(2)]",
            "assms(4)",
            "union_cocardinal",
            "order_top_T2[OF",
            "T2_is_T1",
            "topology0.T1_cocardinal_coarser[OF",
            "topology0_ordtopology(1)[OF",
            "assms(2)]]",
            "T_def",
            "TOT",
            "NN",
            "assms(6)",
            "T1",
            "closed_sets_cocardinal",
            "U(2)",
            "IsClosed_def",
            "lesspoll_nat_is_Finite",
            "subset_Finite",
            "point_open_base_neigh[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "dense_order_inf_intervals[OF",
            "assms(2)",
            "_",
            "assms(3)]",
            "dense_order_inf_lrays[OF",
            "dense_order_inf_rrays[OF",
            "assms(2)_"
        ],
        "statement": "theorem neigh_infPoint_dense:\n  fixes T X r\n  defines T_def:\"T \\<equiv> (OrdTopology X r)\"\n  assumes \"IsLinOrder(X,r)\" \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\" \"U\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" \"\\<Union>T\\<in>U\"\n    \"V\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T\" \"V\\<noteq>0\"\n  shows \"U\\<inter>V\\<noteq>0\"\n",
        "proof": "proof\n  have N:\"\\<Union>T\\<notin>(\\<Union>T)\" using mem_not_refl by auto\n  have tot1:\"\\<Union>({one-point compactification of}(CoFinite (\\<Union>T)))={\\<Union>T}\\<union>\\<Union>T\" using topology0.op_compact_total[OF topology0_CoCardinal[OF InfCard_nat], of \"\\<Union>T\"]\n        union_cocardinal[of \"nat\"\"\\<Union>T\"] unfolding Cofinite_def by auto \n  then have \"(\\<Union>({one-point compactification of}(CoFinite (\\<Union>T))))\\<union>\\<Union>T={\\<Union>T}\\<union>\\<Union>T\" by auto moreover\n  have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)=(\\<Union>({one-point compactification of}(CoFinite (\\<Union>T))))\\<union>\\<Union>T\"\n    by auto\n  ultimately have tot2:\"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)={\\<Union>T}\\<union>\\<Union>T\" by auto\n  have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" using union_open[OF topology0.op_comp_is_top[OF topology0_CoCardinal[OF InfCard_nat]],of \"{one-point compactification of}(CoFinite (\\<Union>T))\"]\n    tot1 unfolding Cofinite_def by auto moreover\n  {\n    assume \"\\<Union>T=0\"\n    then have \"X=0\" unfolding T_def using union_ordtopology[OF assms(2)] assms(4) by auto\n    then have \"False\" using assms(4) by auto\n  }\n  then have \"\\<Union>T\\<noteq>0\" by auto\n  with N have Not:\"\\<not>(\\<Union>T\\<subseteq>{\\<Union>T})\" by auto\n  {\n    assume \"{\\<Union>T}\\<union>\\<Union>T={\\<Union>T}\" moreover\n    have \"\\<Union>T\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" by auto ultimately\n    have \"\\<Union>T\\<subseteq>{\\<Union>T}\" by auto\n    with Not have \"False\" by auto\n  }\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<noteq>{\\<Union>T}\" by auto ultimately\n  have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T\" by auto\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\" by auto moreover\n  have \"({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T\\<subseteq>({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T\" by auto\n  then have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)\" by auto\n  with tot2 have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" by auto\n  ultimately have TOT:\"\\<Union>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)={\\<Union>T}\\<union>\\<Union>T\" by auto\n  assume A:\"U\\<inter>V=0\"\n  with assms(6) have NN:\"\\<Union>T\\<notin>V\" by auto\n  with assms(7) have \"V\\<in>(CoFinite \\<Union>T)\\<union>T\" unfolding OPCompactification_def using union_cocardinal\n    unfolding Cofinite_def by auto\n  moreover have \"T{is T\\<^sub>2}\" unfolding T_def using order_top_T2[OF assms(2)] assms(4) by auto\n  then have T1:\"T{is T\\<^sub>1}\" using T2_is_T1 by auto\n  ultimately have VopT:\"V\\<in>T\" using topology0.T1_cocardinal_coarser[OF topology0_ordtopology(1)[OF assms(2)]]\n    unfolding T_def by auto\n  from A assms(7) have \"V\\<subseteq>\\<Union>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)-U\" by auto\n  then have \"V\\<subseteq>({\\<Union>T}\\<union>\\<Union>T)-U\" using TOT by auto\n  then have \"V\\<subseteq>(\\<Union>T)-U\" using NN by auto\n  from N have \"U\\<notin>T\" using assms(6) by auto\n  then have \"U\\<notin>(CoFinite \\<Union>T)\\<union>T\" using T1 topology0.T1_cocardinal_coarser[OF topology0_ordtopology(1)[OF assms(2)]]\n    unfolding T_def using union_cocardinal union_ordtopology[OF assms(2)] assms(4) by auto\n  with assms(5,6) obtain B where U:\"U={\\<Union>T}\\<union>(\\<Union>T-B)\" \"B{is closed in}(CoFinite \\<Union>T)\" \"B\\<noteq>\\<Union>T\"\n    unfolding OPCompactification_def using union_cocardinal unfolding Cofinite_def by auto\n  then have \"U={\\<Union>T}\\<union>(\\<Union>T-B)\" \"B=\\<Union>T \\<or> B\\<prec>nat\" \"B\\<noteq>\\<Union>T\" using closed_sets_cocardinal unfolding Cofinite_def\n    by auto\n  then have \"U={\\<Union>T}\\<union>(\\<Union>T-B)\" \"B\\<prec>nat\" by auto\n  with N have \"\\<Union>T-U=\\<Union>T-(\\<Union>T-B)\" by auto\n  then have \"\\<Union>T-U=B\" using U(2) unfolding IsClosed_def using union_cocardinal unfolding Cofinite_def\n    by auto\n  with \\<open>B\\<prec>nat\\<close> have \"Finite(\\<Union>T-U)\" using lesspoll_nat_is_Finite by auto\n  with \\<open>V\\<subseteq>(\\<Union>T)-U\\<close> have \"Finite(V)\" using subset_Finite by auto\n  from assms(8) obtain v where \"v\\<in>V\" by auto\n  with VopT have \"\\<exists>R\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union>{RightRayX(X, r, b) . b \\<in> X}. R \\<subseteq> V \\<and> v \\<in> R\" using \n    point_open_base_neigh[OF Ordtopology_is_a_topology(2)[OF assms(2)]] unfolding T_def by auto\n  then obtain R where R_def:\"R\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X} \\<union> {LeftRayX(X, r, b) . b \\<in> X} \\<union>{RightRayX(X, r, b) . b \\<in> X}\" \"R\\<subseteq>V\" \"v\\<in>R\" by blast\n  moreover\n  {\n    assume \"R\\<in>{IntervalX(X, r, b, c) . \\<langle>b,c\\<rangle> \\<in> X \\<times> X}\"\n    then obtain b c where lim:\"b\\<in>X\"\"c\\<in>X\"\"R=IntervalX(X, r, b, c)\" by auto\n    with \\<open>v\\<in>R\\<close> have \" \\<not> Finite(R)\" using dense_order_inf_intervals[OF assms(2) _ _ _ assms(3)] \n      by auto\n    with \\<open>R\\<subseteq>V\\<close> \\<open>Finite(V)\\<close> have \"False\" using subset_Finite by auto\n  } moreover\n  {\n    assume \"R\\<in>{LeftRayX(X, r, b) . b \\<in> X}\"\n    then obtain b where lim:\"b\\<in>X\"\"R=LeftRayX(X, r, b)\" by auto\n    with \\<open>v\\<in>R\\<close> have \" \\<not> Finite(R)\" using dense_order_inf_lrays[OF assms(2) _ _ assms(3)] by auto \n    with \\<open>R\\<subseteq>V\\<close> \\<open>Finite(V)\\<close> have \"False\" using subset_Finite by auto\n  } moreover\n  {\n    assume \"R\\<in>{RightRayX(X, r, b) . b \\<in> X}\"\n    then obtain b where lim:\"b\\<in>X\"\"R=RightRayX(X, r, b)\" by auto\n    with \\<open>v\\<in>R\\<close> have \" \\<not> Finite(R)\" using dense_order_inf_rrays[OF assms(2)_ _ assms(3)] by auto\n    with \\<open>R\\<subseteq>V\\<close> \\<open>Finite(V)\\<close> have \"False\" using subset_Finite by auto\n  } ultimately\n  show \"False\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2394
    },
    "2156": {
        "type": "theorem",
        "text": "text\\<open>A densely ordered set with more than one point gives an order topology.\nApplying the previous construction to this topology we get a non locally-Hausdorff space.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  ",
        "using": [
            "mem_not_refl",
            "topology0.op_compact_total[OF",
            "topology0_CoCardinal[OF",
            "InfCard_nat],",
            "of",
            "\"\\<Union>T\"]",
            "union_cocardinal[of",
            "\"nat\"\"\\<Union>T\"]",
            "Cofinite_def",
            "union_open[OF",
            "topology0.op_comp_is_top[OF",
            "InfCard_nat]],of",
            "\"{one-point",
            "compactification",
            "of}(CoFinite",
            "(\\<Union>T))\"]",
            "tot1",
            "union_ordtopology[OF",
            "assms(2)]",
            "assms(4)",
            "order_top_T2[OF",
            "assms(2,4)]",
            "T2_is_T1",
            "T_def",
            "\\<open>b\\<in>X\\<close>\\<open>c\\<in>X\\<close>",
            "Order_ZF_2_L1",
            "dense_order_inf_intervals[OF",
            "assms(2)",
            "_",
            "\\<open>c\\<in>X\\<close>\\<open>b\\<in>X\\<close>",
            "assms(3)]",
            "subset_Finite",
            "lesspoll_nat_is_Finite",
            "topology0.COF_comp_is_top[OF",
            "topology0_ordtopology[OF",
            "assms(2)]]",
            "TOT",
            "top",
            "IsATopology_def",
            "topology0.Top_2_L1",
            "topology0_def",
            "subspace_of_subspace[OF",
            "sub",
            "C(1)]",
            "T2_here[OF",
            "T2",
            "pp]",
            "topology0.Top_1_L4",
            "T2_2",
            "isT2_def",
            "intOP"
        ],
        "statement": "theorem OPComp_cofinite_dense_order_not_loc_T2:\n  fixes T X r\n  defines T_def:\"T \\<equiv> (OrdTopology X r)\"\n  assumes \"IsLinOrder(X,r)\" \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  shows \"\\<not>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T){is locally-T\\<^sub>2})\"\n",
        "proof": "proof\n  have N:\"\\<Union>T\\<notin>(\\<Union>T)\" using mem_not_refl by auto\n  have tot1:\"\\<Union>({one-point compactification of}(CoFinite (\\<Union>T)))={\\<Union>T}\\<union>\\<Union>T\" using topology0.op_compact_total[OF topology0_CoCardinal[OF InfCard_nat], of \"\\<Union>T\"]\n        union_cocardinal[of \"nat\"\"\\<Union>T\"] unfolding Cofinite_def by auto \n  then have \"(\\<Union>({one-point compactification of}(CoFinite (\\<Union>T))))\\<union>\\<Union>T={\\<Union>T}\\<union>\\<Union>T\" by auto moreover\n  have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)=(\\<Union>({one-point compactification of}(CoFinite (\\<Union>T))))\\<union>\\<Union>T\"\n    by auto\n  ultimately have tot2:\"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)={\\<Union>T}\\<union>\\<Union>T\" by auto\n  have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))\" using union_open[OF topology0.op_comp_is_top[OF topology0_CoCardinal[OF InfCard_nat]],of \"{one-point compactification of}(CoFinite (\\<Union>T))\"]\n    tot1 unfolding Cofinite_def by auto moreover\n  {\n    assume \"\\<Union>T=0\"\n    then have \"X=0\" unfolding T_def using union_ordtopology[OF assms(2)] assms(4) by auto\n    then have \"False\" using assms(4) by auto\n  }\n  then have \"\\<Union>T\\<noteq>0\" by auto\n  with N have Not:\"\\<not>(\\<Union>T\\<subseteq>{\\<Union>T})\" by auto\n  {\n    assume \"{\\<Union>T}\\<union>\\<Union>T={\\<Union>T}\" moreover\n    have \"\\<Union>T\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" by auto ultimately\n    have \"\\<Union>T\\<subseteq>{\\<Union>T}\" by auto\n    with Not have \"False\" by auto\n  }\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<noteq>{\\<Union>T}\" by auto ultimately\n  have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\" by auto\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<in>({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T\" by auto\n  then have \"{\\<Union>T}\\<union>\\<Union>T\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\" by auto moreover\n  have \"({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T\\<subseteq>({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T\" by auto\n  then have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))\\<union>T)\" by auto\n  with tot2 have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<subseteq>{\\<Union>T}\\<union>\\<Union>T\" by auto\n  ultimately have TOT:\"\\<Union>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}})\\<union>T)={\\<Union>T}\\<union>\\<Union>T\" by auto\n  have T1:\"T{is T\\<^sub>1}\" using order_top_T2[OF assms(2,4)] T2_is_T1 unfolding T_def by auto moreover\n  from assms(4) obtain b c where B:\"b\\<in>X\"\"c\\<in>X\"\"b\\<noteq>c\" by auto\n  {\n    assume \"\\<langle>b,c\\<rangle>\\<notin>r\"\n    with assms(2) have \"\\<langle>c,b\\<rangle>\\<in>r\" unfolding IsLinOrder_def IsTotal_def using \\<open>b\\<in>X\\<close>\\<open>c\\<in>X\\<close> by auto\n    with assms(3) B obtain z where \"z\\<in>X-{b,c}\"\"\\<langle>c,z\\<rangle>\\<in>r\"\"\\<langle>z,b\\<rangle>\\<in>r\" unfolding IsDense_def by auto\n    then have \"IntervalX(X,r,c,b)\\<noteq>0\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n    then have \"\\<not>(Finite(IntervalX(X,r,c,b)))\" using dense_order_inf_intervals[OF assms(2) _ \\<open>c\\<in>X\\<close>\\<open>b\\<in>X\\<close> assms(3)]\n      by auto moreover\n    have \"IntervalX(X,r,c,b)\\<subseteq>X\" unfolding IntervalX_def by auto\n    ultimately have \"\\<not>(Finite(X))\" using subset_Finite by auto\n    then have \"\\<not>(X\\<prec>nat)\" using lesspoll_nat_is_Finite by auto\n  }\n  moreover\n  {\n    assume \"\\<langle>b,c\\<rangle>\\<in>r\"\n    with assms(3) B obtain z where \"z\\<in>X-{b,c}\"\"\\<langle>b,z\\<rangle>\\<in>r\"\"\\<langle>z,c\\<rangle>\\<in>r\" unfolding IsDense_def by auto\n    then have \"IntervalX(X,r,b,c)\\<noteq>0\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n    then have \"\\<not>(Finite(IntervalX(X,r,b,c)))\" using dense_order_inf_intervals[OF assms(2) _ \\<open>b\\<in>X\\<close>\\<open>c\\<in>X\\<close> assms(3)]\n      by auto moreover\n    have \"IntervalX(X,r,b,c)\\<subseteq>X\" unfolding IntervalX_def by auto\n    ultimately have \"\\<not>(Finite(X))\" using subset_Finite by auto\n    then have \"\\<not>(X\\<prec>nat)\" using lesspoll_nat_is_Finite by auto\n  }\n  ultimately have \"\\<not>(X\\<prec>nat)\" by auto\n  with T1 have top:\"(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T){is a topology}\" using topology0.COF_comp_is_top[OF topology0_ordtopology[OF assms(2)]] unfolding T_def\n    using union_ordtopology[OF assms(2,4)] by auto\n  assume \"(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T){is locally-T\\<^sub>2}\" moreover\n  have \"\\<Union>T\\<in>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\" using TOT by auto\n  moreover have \"\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\\<in>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\"\n    using top unfolding IsATopology_def by auto\n  ultimately have \"\\<exists>c\\<in>Pow(\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)). \\<Union>T \\<in> Interior(c, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T) \\<and>\n            ((({one-point compactification of}CoFinite \\<Union>T) - {{\\<Union>T}} \\<union> T) {restricted to} c) {is T\\<^sub>2}\" unfolding IsLocallyT2_def IsLocally_def[OF top] by auto\n  then obtain C where C:\"C\\<subseteq>\\<Union>(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T)\" \"\\<Union>T \\<in> Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)\" and T2:\"((({one-point compactification of}CoFinite \\<Union>T) - {{\\<Union>T}} \\<union> T) {restricted to} C) {is T\\<^sub>2}\"\n    by auto\n  have sub:\"Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)\\<subseteq>C\" using topology0.Top_2_L1\n    top unfolding topology0_def by auto\n  have \"(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}C){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))=((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\"\n    using subspace_of_subspace[OF sub C(1)] by auto moreover\n  have \"(\\<Union>((({one-point compactification of}CoFinite \\<Union>T) - {{\\<Union>T}} \\<union> T) {restricted to} C))\\<subseteq>C\" unfolding RestrictedTo_def by auto\n  with C(1) have \"(\\<Union>((({one-point compactification of}CoFinite \\<Union>T) - {{\\<Union>T}} \\<union> T) {restricted to} C))=C\" unfolding RestrictedTo_def by auto\n  with sub have pp:\"Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)\\<in>Pow(\\<Union>((({one-point compactification of}CoFinite \\<Union>T) - {{\\<Union>T}} \\<union> T) {restricted to} C))\" by auto\n  ultimately have T2_2:\"(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))){is T\\<^sub>2}\"\n    using T2_here[OF T2 pp] by auto\n  have top2:\"(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))){is a topology}\"\n    using topology0.Top_1_L4 top unfolding topology0_def by auto\n  from C(2) pp have p1:\"\\<Union>T\\<in>\\<Union>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))\"\n    unfolding RestrictedTo_def by auto\n    from top topology0.Top_2_L2 have intOP:\"(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\\<in>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T\" unfolding topology0_def by auto\n  {\n    fix x assume \"x\\<noteq>\\<Union>T\" \"x\\<in>\\<Union>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))\"\n    with p1 have \"\\<exists>U\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))). \\<exists>V\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))).\n      x\\<in>U\\<and>\\<Union>T\\<in>V\\<and>U\\<inter>V=0\" using T2_2 unfolding isT2_def by auto\n    then obtain U V where UV:\"U\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))\"\n      \"V\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))\"\n      \"U\\<noteq>0\"\"\\<Union>T\\<in>V\"\"U\\<inter>V=0\" by auto\n    from UV(1) obtain UC where \"U=(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\\<inter>UC\"\"UC\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\"\n      unfolding RestrictedTo_def by auto\n    with top intOP have Uop:\"U\\<in>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T\" unfolding IsATopology_def by auto\n    from UV(2) obtain VC where \"V=(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\\<inter>VC\"\"VC\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\"\n      unfolding RestrictedTo_def by auto\n    with top intOP have \"V\\<in>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T\" unfolding IsATopology_def by auto\n    with UV(3-5) Uop neigh_infPoint_dense[OF assms(2-4),of \"V\"\"U\"] union_ordtopology[OF assms(2,4)]\n      have \"False\" unfolding T_def by auto\n  }\n  then have \"\\<Union>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))\\<subseteq>{\\<Union>T}\"\n    by auto\n  with p1 have \"\\<Union>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))={\\<Union>T}\"\n    by auto\n  with top2 have \"{\\<Union>T}\\<in>(((({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T){restricted to}(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T)))\"\n    unfolding IsATopology_def by auto\n  then obtain W where UT:\"{\\<Union>T}=(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\\<inter>W\"\"W\\<in>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T\"\n    unfolding RestrictedTo_def by auto\n  from this(2) have \"(Interior(C, (({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T))\\<inter>W\\<in>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T\" using intOP\n    top unfolding IsATopology_def by auto\n  with UT(1) have \"{\\<Union>T}\\<in>(({one-point compactification of}(CoFinite \\<Union>T)) - {{\\<Union>T}}) \\<union> T\" by auto\n  then have \"{\\<Union>T}\\<in>T\" by auto\n  with N show \"False\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2395
    },
    "2157": {
        "type": "theorem",
        "text": "text\\<open>This topology, from the previous result, gives a counter-example for\nanti-hyperconnected implies locally-$T_2$.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  ",
        "using": [
            "OPComp_cofinite_dense_order_not_loc_T2[OF",
            "assms(2-4)]",
            "dense_order_infinite[OF",
            "union_ordtopology[OF",
            "assms(2,4)]",
            "topology0.COF_comp_antiHConn[OF",
            "topology0_ordtopology[OF",
            "assms(2)]",
            "topology0.T2_imp_anti_HConn[OF",
            "order_top_T2[OF",
            "assms(2,4)]]]",
            "T_def"
        ],
        "statement": "theorem antiHConn_not_imp_loc_T2:\n  fixes T X r\n  defines T_def:\"T \\<equiv> (OrdTopology X r)\"\n  assumes \"IsLinOrder(X,r)\" \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  shows \"\\<not>((({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T){is locally-T\\<^sub>2})\"\n  and \"(({one-point compactification of}(CoFinite (\\<Union>T)))-{{\\<Union>T}}\\<union>T){is anti-}IsHConnected\"\n  ",
        "proof": "using OPComp_cofinite_dense_order_not_loc_T2[OF assms(2-4)] dense_order_infinite[OF assms(2-4)] union_ordtopology[OF assms(2,4)]\n  topology0.COF_comp_antiHConn[OF topology0_ordtopology[OF assms(2)] topology0.T2_imp_anti_HConn[OF topology0_ordtopology[OF assms(2)] order_top_T2[OF assms(2,4)]]]\n  unfolding T_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2396
    },
    "2158": {
        "type": "lemma",
        "text": "text\\<open>A first example of an anti-compact space is the discrete space.\\<close>\n",
        "assumes": "assumes \"B{is compact in}Pow(A)\"\n  ",
        "using": [
            "Finite_Union[of",
            "\"N\"]",
            "subset_Finite"
        ],
        "statement": "lemma pow_compact_imp_finite:\n  assumes \"B{is compact in}Pow(A)\"\n  shows \"Finite(B)\"\n",
        "proof": "proof-\n  from assms have B:\"B\\<subseteq>A\" \"\\<forall>M\\<in>Pow(Pow(A)). B\\<subseteq>\\<Union>M \\<longrightarrow>(\\<exists>N\\<in>FinPow(M). B\\<subseteq>\\<Union>N)\"\n    unfolding IsCompact_def by auto\n  from B(1) have \"{{x}. x\\<in>B}\\<in>Pow(Pow(A))\" \"B\\<subseteq>\\<Union>{{x}. x\\<in>B}\" by auto\n  with B(2) have \"\\<exists>N\\<in>FinPow({{x}. x\\<in>B}). B\\<subseteq>\\<Union>N\" by auto\n  then obtain N where \"N\\<in>FinPow({{x}. x\\<in>B})\" \"B\\<subseteq>\\<Union>N\" by auto\n  then have \"Finite(N)\" \"N\\<subseteq>{{x}. x\\<in>B}\" \"B\\<subseteq>\\<Union>N\" unfolding FinPow_def by auto\n  then have \"Finite(N)\" \"\\<forall>b\\<in>N. Finite(b)\" \"B\\<subseteq>\\<Union>N\" by auto\n  then have \"B\\<subseteq>\\<Union>N\" \"Finite(\\<Union>N)\" using Finite_Union[of \"N\"] by auto\n  then show \"Finite(B)\" using subset_Finite by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2397
    },
    "2159": {
        "type": "lemma",
        "text": "text\\<open>We first differenciate the spectrum of the lindeloef property depending\non some axiom of choice.\\<close>\n",
        "assumes": "assumes \"{the axiom of} nat {choice holds for subsets}(Pow(nat))\"\n  ",
        "using": [],
        "statement": "lemma lindeloef_spec1:\n  assumes \"{the axiom of} nat {choice holds for subsets}(Pow(nat))\"\n  shows \"(A {is in the spectrum of} (\\<lambda>T. ((\\<Union>T){is lindeloef in}T))) \\<longleftrightarrow> (A\\<lesssim>nat)\"\n  ",
        "proof": "using compactK_spectrum[OF assms Card_nat] unfolding IsLindeloef_def.\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2398
    },
    "2160": {
        "type": "theorem",
        "text": "text\\<open>If the axiom of countable choice holds for subsets of the power set of the\nnatural numbers, then there exists a topological space that is anti-lindeloef\nbut no anti-compact.\\<close>\n",
        "assumes": "assumes \"({the axiom of} nat {choice holds for subsets}(Pow(nat)))\"\n  ",
        "using": [
            "topology0.op_compact_total",
            "topology0_def",
            "Pow_is_top",
            "singleton_eqpoll_1",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "lt_Card_imp_lesspoll[OF",
            "Card_csucc]",
            "lt_csucc[OF",
            "Ord_nat]",
            "lesspoll_trans",
            "less_less_imp_un_less[OF",
            "_",
            "InfCard_csucc[OF",
            "InfCard_nat]]",
            "Card_less_csucc_eq_le[OF",
            "Card_nat]",
            "subset_imp_lepoll",
            "lepoll_trans",
            "assms",
            "lindeloef_spec1"
        ],
        "statement": "theorem no_choice_imp_anti_lindeloef_is_anti_comp:\n  assumes \"({the axiom of} nat {choice holds for subsets}(Pow(nat)))\"\n  shows \"({one-point compactification of}Pow(nat)){is anti-lindeloef}\"\n",
        "proof": "proof-\n  have t:\"\\<Union>({one-point compactification of}Pow(nat))={nat}\\<union>nat\" using topology0.op_compact_total\n    unfolding topology0_def using Pow_is_top by auto\n  have \"{nat}\\<approx>1\" using singleton_eqpoll_1 by auto\n  then have \"{nat}\\<prec>nat\" using n_lesspoll_nat eq_lesspoll_trans by auto moreover\n  have s:\"nat\\<prec>csucc(nat)\" using lt_Card_imp_lesspoll[OF Card_csucc] lt_csucc[OF Ord_nat] by auto\n  ultimately have \"{nat}\\<prec>csucc(nat)\" using lesspoll_trans by blast\n  with s have \"{nat}\\<union>nat\\<prec>csucc(nat)\" using less_less_imp_un_less[OF _ _ InfCard_csucc[OF InfCard_nat]]\n    by auto\n  then have \"{nat}\\<union>nat\\<lesssim>nat\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n  with t have r:\"\\<Union>({one-point compactification of}Pow(nat))\\<lesssim>nat\" by auto\n  {\n    fix A assume A:\"A\\<in>Pow(\\<Union>({one-point compactification of}Pow(nat)))\" \"(\\<Union>(({one-point compactification of}Pow(nat)){restricted to}A)){is lindeloef in}(({one-point compactification of}Pow(nat)){restricted to}A)\"\n    from A(1) have \"A\\<subseteq>\\<Union>({one-point compactification of}Pow(nat))\" by auto\n    with r have \"A\\<lesssim>nat\" using subset_imp_lepoll lepoll_trans by blast\n    then have \"A{is in the spectrum of}(\\<lambda>T. ((\\<Union>T){is lindeloef in}T))\" using assms\n      lindeloef_spec1 by auto\n  }\n  then show ?thesis unfolding IsAntiLin_def antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2399
    },
    "2161": {
        "type": "theorem",
        "text": "text\\<open>The axiom of countable choice holds for subsets of the power set of the\nnatural numbers if and only if there exists a topological space which is anti-lindeloef\nbut not anti-compact; this space can be chosen as the one-point compactification\nof the discrete topology on $\\mathbb{N}$.\\<close>\n",
        "assumes": "",
        "using": [
            "op_comp_pow_nat_no_anti_comp",
            "no_choice_imp_anti_lindeloef_is_anti_comp",
            "topology0.no_choice_imp_anti_lindeloef_is_anti_comp",
            "topology0.op_comp_is_top",
            "Pow_is_top[of",
            "\"nat\"]",
            "topology0_def"
        ],
        "statement": "theorem acc_pow_nat_equiv1:\n  shows \"({the axiom of} nat {choice holds for subsets}(Pow(nat))) \\<longleftrightarrow> (({one-point compactification of}Pow(nat)){is anti-lindeloef})\"\n  ",
        "proof": "using op_comp_pow_nat_no_anti_comp no_choice_imp_anti_lindeloef_is_anti_comp\n  topology0.no_choice_imp_anti_lindeloef_is_anti_comp topology0.op_comp_is_top\n  Pow_is_top[of \"nat\"] unfolding topology0_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2400
    },
    "2162": {
        "type": "theorem",
        "text": "text\\<open>Now, we could wonder if the class of compact spaces and the class of lindeloef spaces being equal\nis consistent in ZF. Let's find a topological space which is lindeloef and no compact\nwithout assuming any axiom of choice or any negation of one. This will prove\nthat the class of lindeloef spaces and the class of compact spaces cannot be equal\nin any model of ZF.\\<close>\n",
        "assumes": "",
        "using": [
            "LeastI[OF",
            "_",
            "nat_into_Ord,",
            "where",
            "P=\"\\<lambda>i.",
            "i\\<in>nat",
            "\\<and>",
            "\\<Union>U\\<subseteq>",
            "LeftRayX(nat,Le,i)\"]",
            "UU",
            "y",
            "Le_directs_nat(1)",
            "IsLinOrder_def",
            "IsTotal_def",
            "trans_def",
            "antisym_def",
            "b(2)",
            "Least_le",
            "not_le_iff_lt[OF",
            "nat_into_Ord[OF",
            "i]",
            "nat_into_Ord]",
            "le_iff",
            "le_trans[OF",
            "sn(1)",
            "ni]",
            "le_anti_sym[OF",
            "sn(1)]",
            "ni",
            "i",
            "le_in_nat",
            "LeftRayX_def",
            "LOrdtopology_ROrdtopology_are_topologies(2)[OF",
            "Le_directs_nat(1)]",
            "IsAbaseFor_def"
        ],
        "statement": "theorem lord_nat:\n  shows \"(LOrdTopology nat Le)={LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}\"\n",
        "proof": "proof-\n  {\n    fix U assume U:\"U\\<subseteq>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat}\" \"U\\<noteq>0\"\n    {\n      assume \"nat\\<in>U\"\n      with U have \"\\<Union>U=nat\" unfolding LeftRayX_def by auto\n      then have \"\\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat}\\<union>{0}\" by auto\n    }\n    moreover\n    {\n      assume \"nat\\<notin>U\"\n      with U have UU:\"U\\<subseteq>{LeftRayX(nat,Le,n). n\\<in>nat}\\<union>{0}\" by auto\n      {\n        assume A:\"\\<exists>i. i\\<in>nat\\<and> \\<Union>U\\<subseteq> LeftRayX(nat,Le,i)\"\n        let ?M=\"\\<mu> i. i\\<in>nat \\<and> \\<Union>U\\<subseteq> LeftRayX(nat,Le,i)\"\n        from A have M:\"?M\\<in>nat\" \"\\<Union>U\\<subseteq> LeftRayX(nat,Le,?M)\" using LeastI[OF _ nat_into_Ord, where P=\"\\<lambda>i. i\\<in>nat \\<and> \\<Union>U\\<subseteq> LeftRayX(nat,Le,i)\"]\n          by auto\n        {\n          fix y assume V:\"y\\<in>LeftRayX(nat,Le,?M)\"\n          then have y:\"y\\<in>nat\" unfolding LeftRayX_def by auto\n          {\n            assume \"\\<forall>V\\<in>U. y\\<notin>V\"\n            then have \"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat,Le,n)\\<in>U}. y\\<notin>LeftRayX(nat,Le,m)\" using UU by auto\n            then have \"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat,Le,n)\\<in>U}. \\<langle>y,m\\<rangle>\\<notin>Le\\<or>y=m\" unfolding LeftRayX_def using y\n              by auto\n            then have RR:\"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat,Le,n)\\<in>U}. \\<langle>m,y\\<rangle>\\<in>Le\" using Le_directs_nat(1) y unfolding IsLinOrder_def IsTotal_def by blast\n            {\n              fix rr V assume \"rr\\<in>\\<Union>U\"\n              then obtain V where V:\"V\\<in>U\" \"rr\\<in>V\" by auto\n              with UU obtain m where m:\"V=LeftRayX(nat,Le,m)\" \"m\\<in>nat\" by auto\n              with V(1) RR have a:\"\\<langle>m,y\\<rangle>\\<in>Le\" by auto\n              from V(2) m(1) have b:\"\\<langle>rr,m\\<rangle>\\<in>Le\" \"rr\\<in>nat-{m}\" unfolding LeftRayX_def by auto\n              from a b(1) have \"\\<langle>rr,y\\<rangle>\\<in>Le\" using Le_directs_nat(1) unfolding IsLinOrder_def\n                trans_def by blast moreover\n              {\n                assume \"rr=y\"\n                with a b have \"False\" using Le_directs_nat(1) unfolding IsLinOrder_def antisym_def by blast\n              }\n              ultimately have \"rr\\<in>LeftRayX(nat,Le,y)\" unfolding LeftRayX_def using b(2) by auto\n            }\n            then have \"\\<Union>U\\<subseteq>LeftRayX(nat,Le,y)\" by auto\n            with y M(1) have \"\\<langle>?M,y\\<rangle>\\<in>Le\" using Least_le by auto\n            with V have \"False\" unfolding LeftRayX_def using Le_directs_nat(1) unfolding IsLinOrder_def antisym_def by blast\n          }\n          then have \"y\\<in>\\<Union>U\" by auto\n        }\n        then have \"LeftRayX(nat,Le,?M)\\<subseteq>\\<Union>U\" by auto\n        with M(2) have \"\\<Union>U=LeftRayX(nat,Le,?M)\" by auto\n        with M(1) have \"\\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat}\" by auto\n      }\n      moreover\n      {\n        assume \"\\<not>(\\<exists>i. i \\<in> nat \\<and> \\<Union>U \\<subseteq> LeftRayX(nat, Le, i))\"\n        then have A:\"\\<forall>i. i\\<in>nat \\<longrightarrow> \\<not>(\\<Union>U \\<subseteq> LeftRayX(nat, Le, i))\" by auto\n        {\n          fix i assume i:\"i\\<in>nat\"\n          with A have AA:\"\\<not>(\\<Union>U \\<subseteq> LeftRayX(nat, Le, i))\" by auto\n          {\n            assume \"i\\<notin>\\<Union>U\"\n            then have \"\\<forall>V\\<in>U. i\\<notin>V\" by auto\n            then have \"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat, Le, n)\\<in>U}. i\\<notin>LeftRayX(nat, Le, m)\" by auto\n            with i have \"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat, Le, n)\\<in>U}. \\<langle>i,m\\<rangle>\\<notin>Le\\<or>i=m\" unfolding LeftRayX_def by auto\n            with i have \"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat, Le, n)\\<in>U}. \\<not>(i\\<le>m)\\<or>i=m\" unfolding Le_def by auto\n            then have \"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat, Le, n)\\<in>U}. m<i\\<or>m=i\" using not_le_iff_lt[OF nat_into_Ord[OF i]\n              nat_into_Ord] by auto\n            then have M:\"\\<forall>m\\<in>{n\\<in>nat. LeftRayX(nat, Le, n)\\<in>U}. m\\<le>i\" using le_iff nat_into_Ord[OF i] by auto\n            {\n              fix s assume \"s\\<in>\\<Union>U\"\n              then obtain n where n:\"n\\<in>nat\" \"s\\<in>LeftRayX(nat, Le, n)\" \"LeftRayX(nat, Le, n)\\<in>U\"\n                using UU by auto\n              with M have ni:\"n\\<le>i\" by auto\n              from n(2) have sn:\"s\\<le>n\" \"s\\<noteq>n\" unfolding LeftRayX_def by auto\n              then have \"s\\<le>i\" \"s\\<noteq>i\" using le_trans[OF sn(1) ni] le_anti_sym[OF sn(1)] ni by auto\n              then have \"s\\<in>LeftRayX(nat, Le, i)\" using i le_in_nat unfolding LeftRayX_def by auto\n            }\n            with AA have \"False\" by auto\n          }\n          then have \"i\\<in>\\<Union>U\" by auto\n        }\n        then have \"nat\\<subseteq>\\<Union>U\" by auto\n        then have \"\\<Union>U=nat\" using UU unfolding LeftRayX_def by auto\n        then have \"\\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}\" by auto\n      }\n      ultimately have \"\\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}\" by auto\n    }\n    ultimately have \"\\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}\" by auto\n  }\n  moreover\n  {\n    fix U assume \"U=0\"\n    then have \"\\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}\" by auto\n  }\n  ultimately have \"\\<forall>U. U\\<subseteq>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<longrightarrow> \\<Union>U\\<in>{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}\"\n    by auto\n  then have \"{LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat} \\<union>{0}={\\<Union>U. U\\<in>Pow({LeftRayX(nat,Le,n). n\\<in>nat} \\<union>{nat})}\" by blast\n  then show ?thesis using LOrdtopology_ROrdtopology_are_topologies(2)[OF Le_directs_nat(1)]\n    unfolding IsAbaseFor_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2402
    },
    "2163": {
        "type": "definition",
        "text": "text\\<open>We start with a property that has already appeared in\n@{file \"Topology_ZF_1b.thy\"}. A KC-space is a space where\ncompact sets are closed.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsKC (\"_ {is KC}\") where\n  \"T{is KC} \\<equiv> \\<forall>A\\<in>Pow(\\<Union>T). A{is compact in}T \\<longrightarrow> A{is closed in}T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2403
    },
    "2164": {
        "type": "definition",
        "text": "text\\<open>Another type of space is an US-space; those where sequences\nhave at most one limit.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsUS (\"_{is US}\") where\n  \"T{is US} \\<equiv> \\<forall>N x y. (N:nat\\<rightarrow>\\<Union>T) \\<and> NetConvTop(\\<langle>N,Le\\<rangle>,x,T) \\<and> NetConvTop(\\<langle>N,Le\\<rangle>,y,T) \\<longrightarrow> y=x\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2404
    },
    "2165": {
        "type": "theorem",
        "text": "text\\<open>US spaces are also $T_1$.\\<close>\n",
        "assumes": "assumes \"T{is US}\"\n  ",
        "using": [
            "cl_inter_neigh[OF",
            "\\<open>{x}\\<subseteq>\\<Union>T\\<close>]",
            "x",
            "func1_3_L1",
            "func1_1_L1",
            "Le_directs_nat",
            "IsNet_def",
            "Top_2_L1",
            "func1_3_L2",
            "dom",
            "r",
            "Top_2_L2",
            "y(2)",
            "Top_3_L11(1)[OF",
            "assms",
            "IsUS_def",
            "fun",
            "cl_contains_set[OF",
            "Top_3_L8",
            "T1_iff_singleton_closed"
        ],
        "statement": "theorem (in topology0) US_imp_T1:\n  assumes \"T{is US}\"\n  shows \"T{is T\\<^sub>1}\"\n",
        "proof": "proof-\n  {\n    fix x assume x:\"x\\<in>\\<Union>T\"\n    then have \"{x}\\<subseteq>\\<Union>T\" by auto\n    {\n      fix y assume y:\"y\\<noteq>x\" \"y\\<in>cl({x})\"\n      then have r:\"\\<forall>U\\<in>T. y\\<in>U \\<longrightarrow> x\\<in>U\" using cl_inter_neigh[OF \\<open>{x}\\<subseteq>\\<Union>T\\<close>] by auto\n      let ?N=\"ConstantFunction(nat,x)\"\n      have fun:\"?N:nat\\<rightarrow>\\<Union>T\" using x func1_3_L1 by auto\n      then have dom:\"domain(?N)=nat\" using func1_1_L1 by auto\n      with fun have Net:\"\\<langle>?N,Le\\<rangle>{is a net on}\\<Union>T\" using Le_directs_nat unfolding IsNet_def\n        by auto\n      {\n        fix U assume \"U\\<in>Pow(\\<Union>T)\" \"x\\<in>int(U)\"\n        then have \"x\\<in>U\" using Top_2_L1 by auto\n        then have \"\\<forall>n\\<in>nat. ?N`n\\<in>U\" using func1_3_L2 by auto\n        then have \"\\<forall>n\\<in>nat. \\<langle>0,n\\<rangle>\\<in>Le \\<longrightarrow>?N`n\\<in>U\" by auto\n        then have \"\\<exists>r\\<in>nat. \\<forall>n\\<in>nat. \\<langle>r,n\\<rangle>\\<in>Le \\<longrightarrow>?N`n\\<in>U\" by auto\n      }\n      then have \"\\<langle>?N,Le\\<rangle> \\<rightarrow>\\<^sub>N x\" unfolding NetConverges_def[OF Net] using x dom by auto moreover\n      {\n        fix U assume \"U\\<in>Pow(\\<Union>T)\" \"y\\<in>int(U)\"\n        then have \"x\\<in>int(U)\" using r Top_2_L2 by auto\n        then have \"x\\<in>U\" using Top_2_L1 by auto\n        then have \"\\<forall>n\\<in>nat. ?N`n\\<in>U\" using func1_3_L2 by auto\n        then have \"\\<forall>n\\<in>nat. \\<langle>0,n\\<rangle>\\<in>Le \\<longrightarrow>?N`n\\<in>U\" by auto\n        then have \"\\<exists>r\\<in>nat. \\<forall>n\\<in>nat. \\<langle>r,n\\<rangle>\\<in>Le \\<longrightarrow>?N`n\\<in>U\" by auto\n      }\n      then have \"\\<langle>?N,Le\\<rangle> \\<rightarrow>\\<^sub>N y\" unfolding NetConverges_def[OF Net] using y(2) dom\n        Top_3_L11(1)[OF \\<open>{x}\\<subseteq>\\<Union>T\\<close>] by auto\n      ultimately have \"x=y\" using assms unfolding IsUS_def using fun by auto\n      with y(1) have \"False\" by auto\n    }\n    then have \"cl({x})\\<subseteq>{x}\" by auto\n    then have \"cl({x})={x}\" using cl_contains_set[OF \\<open>{x}\\<subseteq>\\<Union>T\\<close>] by auto\n    then have \"{x}{is closed in}T\" using Top_3_L8 x by auto\n  }\n  then show ?thesis using T1_iff_singleton_closed by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2405
    },
    "2166": {
        "type": "lemma",
        "text": "text\\<open>In the file @{file \"Topology_ZF_properties_2.thy\"} we built a topological space\nwhich is locally-$T_2$ but no $T_2$. It happends actually that this space is not even US\ngiven the appropiate topology \\<open>T\\<close>.\\<close>\n",
        "assumes": "assumes \"{m}\\<notin>T\" \"{m}{is closed in}T\" \"\\<exists>N\\<in>nat\\<rightarrow>\\<Union>T. (\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N m) \\<and> m\\<notin>N``nat\" \n  ",
        "using": [
            "assms(2)",
            "union_doublepoint_top",
            "func1_1_L1B",
            "func1_1_L1",
            "Le_directs_nat",
            "dom",
            "topology0.Top_2_L2",
            "doble_point_top",
            "topology0_def",
            "open_subspace_double_point(1)",
            "Top_2_L3",
            "topology0.Top_2_L1[of",
            "\"T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W.",
            "\\<langle>U,W\\<rangle>\\<in>{V\\<in>T.",
            "m\\<in>V}\\<times>T}\"\"U\"]",
            "doble_point_top[OF",
            "assms(2)]",
            "topology0_def.",
            "have",
            "\"m\\<in>\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W.",
            "m\\<in>V}\\<times>T})\"",
            "IsClosed_def",
            "VW(3)",
            "func_imagedef[OF",
            "N(1)]",
            "VW(1)",
            "topology0.Top_2_L1"
        ],
        "statement": "lemma (in topology0) locT2_not_US_1:\n  assumes \"{m}\\<notin>T\" \"{m}{is closed in}T\" \"\\<exists>N\\<in>nat\\<rightarrow>\\<Union>T. (\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N m) \\<and> m\\<notin>N``nat\" \n  shows \"\\<exists>N\\<in>nat\\<rightarrow>\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}). (\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N \\<Union>T {in} (T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}))\n    \\<and> (\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N m {in} (T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}))\"\n",
        "proof": "proof-\n  from assms(3) obtain N where N:\"N:nat\\<rightarrow>\\<Union>T\" \"\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N m\" \"m\\<notin>N``nat\" by auto\n  have \"\\<Union>T\\<subseteq>\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\" using assms(2) union_doublepoint_top\n    by auto\n  with N(1) have fun:\"N:nat\\<rightarrow>\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\" using func1_1_L1B by auto\n  then have dom:\"domain(N)=nat\" using func1_1_L1 by auto\n  with fun have Net:\"\\<langle>N,Le\\<rangle>{is a net on}\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\" unfolding\n    IsNet_def using Le_directs_nat by auto\n  from N(1) dom have Net2:\"\\<langle>N,Le\\<rangle>{is a net on}\\<Union>T\" unfolding IsNet_def using Le_directs_nat by auto\n  from N(2) have R:\"\\<forall>U\\<in>Pow(\\<Union>T). m\\<in>int(U) \\<longrightarrow>(\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U)\"\n    unfolding NetConverges_def[OF Net2] using dom by auto\n  {\n    fix U assume U:\"U\\<in>Pow(\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}))\"  \"m\\<in>Interior(U,T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\"\n    let ?I=\"Interior(U,T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\"\n    have \"?I\\<in>T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}\" using topology0.Top_2_L2 assms(2) doble_point_top unfolding topology0_def by blast\n    then have \"(\\<Union>T)\\<inter>?I\\<in>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}){restricted to}\\<Union>T\" unfolding RestrictedTo_def by blast\n    then have \"(\\<Union>T)\\<inter>?I\\<in>T\" using open_subspace_double_point(1) assms(2) by auto moreover\n    then have \"int((\\<Union>T)\\<inter>?I)=(\\<Union>T)\\<inter>?I\" using Top_2_L3 by auto\n    with U(2) assms(2) have \"m\\<in>int((\\<Union>T)\\<inter>?I)\" unfolding IsClosed_def by auto\n    moreover note R ultimately have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>(\\<Union>T)\\<inter>?I\" by blast\n    then have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>?I\" by blast\n    then have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U\" using topology0.Top_2_L1[of \"T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}\"\"U\"] doble_point_top assms(2)\n      unfolding topology0_def by auto\n  }\n  then have \"\\<forall>U\\<in>Pow(\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})). m\\<in>Interior(U,T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}) \\<longrightarrow>(\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U)\" by auto\n  moreover have tt:\"topology0(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\" using doble_point_top[OF assms(2)] unfolding topology0_def. \n  have \"m\\<in>\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\" using assms(2) union_doublepoint_top unfolding IsClosed_def by auto ultimately\n  have con1:\"(\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N m {in} (T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}))\" unfolding topology0.NetConverges_def[OF tt Net]\n    using dom by auto\n  {\n    fix U assume U:\"U\\<in>Pow(\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}))\"  \"\\<Union>T\\<in>Interior(U,T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\"\n    let ?I=\"Interior(U,T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\"\n    have \"?I\\<in>T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}\" using topology0.Top_2_L2 assms(2) doble_point_top unfolding topology0_def by blast\n    with U(2) mem_not_refl have \"?I\\<in>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}\" by auto\n    then obtain V W where VW:\"?I=(V-{m})\\<union>{\\<Union>T}\\<union>W\" \"W\\<in>T\" \"V\\<in>T\" \"m\\<in>V\" by auto\n    from VW(3,4) have \"m\\<in>int(V)\" using Top_2_L3 by auto moreover\n    have \"V\\<in>Pow(\\<Union>T)\" using VW(3) by auto moreover\n    note R ultimately\n    have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>V\" by blast moreover\n    from N(3) have \"\\<forall>s\\<in>nat. N`s\\<noteq>m\" using func_imagedef[OF N(1)] by auto ultimately\n    have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>V-{m}\" by blast\n    then have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>?I\" using VW(1) by auto\n    then have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U\" using topology0.Top_2_L1 assms(2) doble_point_top unfolding topology0_def by blast\n  }\n  then have \"\\<forall>U\\<in>Pow(\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})). \\<Union>T\\<in>Interior(U,T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}) \\<longrightarrow> (\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U)\" by auto\n  moreover have \"\\<Union>T\\<in>\\<Union>(T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T})\" using assms(2) union_doublepoint_top by auto ultimately\n  have \"(\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N \\<Union>T {in} (T\\<union>{(U-{m})\\<union>{\\<Union>T}\\<union>W. \\<langle>U,W\\<rangle>\\<in>{V\\<in>T. m\\<in>V}\\<times>T}))\" unfolding topology0.NetConverges_def[OF tt Net]\n    using dom by auto\n  with con1 fun show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2406
    },
    "2167": {
        "type": "lemma",
        "text": "text\\<open>Anti-compactness ereases the differences between several properties.\\<close>\n",
        "assumes": "assumes \"T{is anti-compact}\"\n  ",
        "using": [
            "KC_imp_T1",
            "compact_imp_compact_subspace",
            "Compact_is_card_nat",
            "compact_spectrum",
            "eq_lesspoll_trans",
            "n_lesspoll_nat",
            "A(2)",
            "AS",
            "T1_cocardinal_coarser"
        ],
        "statement": "lemma (in topology0) anticompact_KC_equiv_T1:\n  assumes \"T{is anti-compact}\"\n  shows \"T{is KC}\\<longleftrightarrow>T{is T\\<^sub>1}\"\n",
        "proof": "proof\n  assume \"T{is KC}\"\n  then show \"T{is T\\<^sub>1}\" using KC_imp_T1 by auto\nnext\n  assume AS:\"T{is T\\<^sub>1}\"\n  {\n    fix A assume A:\"A{is compact in}T\" \"A\\<in>Pow(\\<Union>T)\"\n    then have \"A{is compact in}(T{restricted to}A)\" \"A\\<in>Pow(\\<Union>T)\" using compact_imp_compact_subspace\n      Compact_is_card_nat by auto\n    moreover then have \"\\<Union>(T{restricted to}A)=A\" unfolding RestrictedTo_def by auto\n    ultimately have \"(\\<Union>(T{restricted to}A)){is compact in}(T{restricted to}A)\" \"A\\<in>Pow(\\<Union>T)\" by auto\n    with assms have \"Finite(A)\" unfolding IsAntiComp_def antiProperty_def using compact_spectrum by auto\n    then obtain n where \"n\\<in>nat\" \"A\\<approx>n\" unfolding Finite_def by auto\n    then have \"A\\<prec>nat\" using eq_lesspoll_trans n_lesspoll_nat by auto moreover\n    have \"\\<Union>T-(\\<Union>T-A)=A\" using A(2) by auto\n    ultimately have \"\\<Union>T-(\\<Union>T-A)\\<prec>nat\" by auto\n    then have \"\\<Union>T-A\\<in>CoFinite \\<Union>T\" unfolding Cofinite_def CoCardinal_def by auto\n    then have \"\\<Union>T-A\\<in>T\" using AS T1_cocardinal_coarser by auto\n    with A(2) have \"A{is closed in}T\" unfolding IsClosed_def by auto\n  }\n  then show \"T{is KC}\" unfolding IsKC_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2407
    },
    "2168": {
        "type": "lemma",
        "text": "text\\<open>The cocountable topology on \\<open>csucc(nat)\\<close> is such a topology.\\<close>\ntext\\<open>The cocountable topology on $\\mathbb{N}^+$ is hyperconnected.\\<close>\n",
        "assumes": "",
        "using": [
            "less_less_imp_un_less[",
            "OF",
            "_",
            "InfCard_csucc[OF",
            "InfCard_nat]]"
        ],
        "statement": "lemma cocountable_in_csucc_nat_HConn:\n  shows \"(CoCountable csucc(nat)){is hyperconnected}\"\n",
        "proof": "proof-\n  {\n    fix U V assume as:\"U\\<in>(CoCountable csucc(nat))\"\"V\\<in>(CoCountable csucc(nat))\"\"U\\<inter>V=0\"\n    then have \"csucc(nat)-U\\<prec>csucc(nat)\\<or>U=0\"\"csucc(nat)-V\\<prec>csucc(nat)\\<or>V=0\"\n      unfolding Cocountable_def CoCardinal_def by auto\n    then have \"(csucc(nat)-U)\\<union>(csucc(nat)-V)\\<prec>csucc(nat)\\<or>U=0\\<or>V=0\" using less_less_imp_un_less[\n      OF _ _ InfCard_csucc[OF InfCard_nat]] by auto moreover\n    {\n      assume \"(csucc(nat)-U)\\<union>(csucc(nat)-V)\\<prec>csucc(nat)\" moreover\n      have \"(csucc(nat)-U)\\<union>(csucc(nat)-V)=csucc(nat)-U\\<inter>V\" by auto\n      with as(3) have \"(csucc(nat)-U)\\<union>(csucc(nat)-V)=csucc(nat)\" by auto\n      ultimately have \"csucc(nat)\\<prec>csucc(nat)\" by auto\n      then have \"False\" by auto\n    }\n    ultimately have \"U=0\\<or>V=0\" by auto\n  }\n  then show \"(CoCountable csucc(nat)){is hyperconnected}\" unfolding IsHConnected_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2408
    },
    "2169": {
        "type": "corollary",
        "text": "text\\<open>The cocountable topology on $\\mathbb{N}^+$ is not anti-hyperconnected.\\<close>\n",
        "assumes": "",
        "using": [
            "cocountable_in_csucc_nat_HConn",
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "union_cocardinal",
            "Cocountable_def",
            "uni",
            "HConn_spectrum",
            "n_lesspoll_nat",
            "lesspoll_trans1",
            "lt_csucc[OF",
            "lt_Card_imp_lesspoll[OF",
            "Card_csucc[OF",
            "Ord_nat]]",
            "lesspoll_trans"
        ],
        "statement": "corollary cocountable_in_csucc_nat_notAntiHConn:\n  shows \"\\<not>((CoCountable csucc(nat)){is anti-}IsHConnected)\"\n",
        "proof": "proof\n  assume as:\"(CoCountable csucc(nat)){is anti-}IsHConnected\"\n  have \"(CoCountable csucc(nat)){is hyperconnected}\" using cocountable_in_csucc_nat_HConn by auto moreover\n  have \"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto\n  then have uni:\"\\<Union>(CoCountable csucc(nat))=csucc(nat)\" using union_cocardinal unfolding Cocountable_def by auto\n  have \"\\<forall>A\\<in>(CoCountable csucc(nat)). A\\<subseteq>\\<Union>(CoCountable csucc(nat))\" by fast\n  with uni have \"\\<forall>A\\<in>(CoCountable csucc(nat)). A\\<subseteq>csucc(nat)\" by auto\n  then have \"\\<forall>A\\<in>(CoCountable csucc(nat)). csucc(nat)\\<inter>A=A\" by auto\n  ultimately have \"((CoCountable csucc(nat)){restricted to}csucc(nat)){is hyperconnected}\"\n    unfolding RestrictedTo_def by auto\n  with as have \"(csucc(nat)){is in the spectrum of}IsHConnected\" unfolding antiProperty_def\n    using uni by auto\n  then have \"csucc(nat)\\<lesssim>1\" using HConn_spectrum by auto\n  then have \"csucc(nat)\\<prec>nat\" using n_lesspoll_nat lesspoll_trans1 by auto\n  then show \"False\" using lt_csucc[OF Ord_nat] lt_Card_imp_lesspoll[OF Card_csucc[OF Ord_nat]]\n    lesspoll_trans by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2409
    },
    "2170": {
        "type": "theorem",
        "text": "text\\<open>The cocountable topology on $\\mathbb{N}^+$ is not $T_2$.\\<close>\n",
        "assumes": "",
        "using": [
            "topology0.T2_imp_anti_HConn[OF",
            "topology0_CoCardinal[OF",
            "InfCard_csucc[OF",
            "InfCard_nat]]]",
            "Cocountable_def",
            "cocountable_in_csucc_nat_notAntiHConn"
        ],
        "statement": "theorem cocountable_in_csucc_nat_noT2:\n  shows \"\\<not>(CoCountable csucc(nat)){is T\\<^sub>2}\"\n",
        "proof": "proof\n  assume \"(CoCountable csucc(nat)){is T\\<^sub>2}\" \n  then have antiHC:\"(CoCountable csucc(nat)){is anti-}IsHConnected\" \n    using topology0.T2_imp_anti_HConn[OF topology0_CoCardinal[OF InfCard_csucc[OF InfCard_nat]]]\n    unfolding Cocountable_def by auto\n  then show \"False\" using cocountable_in_csucc_nat_notAntiHConn by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2410
    },
    "2171": {
        "type": "theorem",
        "text": "text\\<open>The cocountable topology on $\\mathbb{N}^+$ is $T_1$.\\<close>\n",
        "assumes": "",
        "using": [
            "cocardinal_is_T1[OF",
            "InfCard_csucc[OF",
            "InfCard_nat]]",
            "Cocountable_def"
        ],
        "statement": "theorem cocountable_in_csucc_nat_T1:\n  shows \"(CoCountable csucc(nat)){is T\\<^sub>1}\"\n  ",
        "proof": "using cocardinal_is_T1[OF InfCard_csucc[OF InfCard_nat]] unfolding Cocountable_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2411
    },
    "2172": {
        "type": "theorem",
        "text": "text\\<open>The cocountable topology on $\\mathbb{N}^+$ is anti-compact.\\<close>\n",
        "assumes": "",
        "using": [
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "union_cocardinal[OF",
            "noE]",
            "Cocountable_def",
            "subspace_cocardinal",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "closed_sets_cocardinal[of",
            "\"csucc(nat)\"",
            "\"A-{t}\"\"A\"]",
            "noE,",
            "of",
            "\"A\"]",
            "topology0.open_neigh_open[OF",
            "topology0_CoCardinal[",
            "OF",
            "InfCard_csucc[OF",
            "InfCard_nat]]]",
            "pow_anti_compact[of",
            "compact_imp_compact_subspace",
            "Compact_is_card_nat",
            "tot",
            "RestrictedTo_def",
            "comp",
            "IsAntiComp_def",
            "antiProperty_def",
            "lepoll_iff_leqpoll",
            "eqpoll_sym",
            "lesspoll_eq_trans",
            "lt_csucc[OF",
            "lt_Card_imp_lesspoll[OF",
            "Card_csucc[OF",
            "Ord_nat]]",
            "fun_is_surj",
            "eq_lesspoll_trans",
            "\"range(f)\"\"A\"]",
            "func1_1_L5B[OF",
            "fun]",
            "noE",
            "compact_closed",
            "\"range(f)-{t}\"\"range(f)\"]",
            "\"range(f)\"]",
            "compact_spectrum",
            "e",
            "eqpoll_imp_Finite_iff",
            "nat_not_Finite"
        ],
        "statement": "theorem cocountable_in_csucc_nat_antiCompact:\n  shows \"(CoCountable csucc(nat)){is anti-compact}\"\n",
        "proof": "proof-\n  have noE:\"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto \n  {\n    fix A assume as:\"A\\<subseteq>\\<Union>(CoCountable csucc(nat))\" \"(\\<Union>((CoCountable csucc(nat)){restricted to}A)){is compact in}((CoCountable csucc(nat)){restricted to}A)\"\n    from as(1) have ass:\"A\\<subseteq>csucc(nat)\" using union_cocardinal[OF noE] unfolding Cocountable_def by auto\n    have \"((CoCountable csucc(nat)){restricted to}A)=CoCountable (A\\<inter>csucc(nat))\" using subspace_cocardinal\n      unfolding Cocountable_def by auto moreover\n    from ass have \"A\\<inter>csucc(nat)=A\" by auto\n    ultimately have \"((CoCountable csucc(nat)){restricted to}A)=CoCountable A\" by auto\n    with as(2) have comp:\"(\\<Union>(CoCountable A)){is compact in}(CoCountable A)\" by auto   \n    {\n      assume as2:\"A\\<prec>csucc(nat)\" moreover\n      {\n        fix t assume t:\"t\\<in>A\"\n        have \"A-{t}\\<subseteq>A\" by auto\n        then have \"A-{t}\\<lesssim>A\" using subset_imp_lepoll by auto\n        with as2 have \"A-{t}\\<prec>csucc(nat)\" using lesspoll_trans1 by auto moreover note noE\n        ultimately have \"(A-{t}){is closed in}(CoCountable A)\" using closed_sets_cocardinal[of \"csucc(nat)\"\n          \"A-{t}\"\"A\"] unfolding Cocountable_def by auto\n        then have \"A-(A-{t})\\<in>(CoCountable A)\" unfolding IsClosed_def using union_cocardinal[OF noE, of \"A\"]\n          unfolding Cocountable_def by auto moreover\n        from t have \"A-(A-{t})={t}\" by auto ultimately\n        have \"{t}\\<in>(CoCountable A)\" by auto\n      }\n      then have r:\"\\<forall>t\\<in>A. {t}\\<in>(CoCountable A)\" by auto\n      {\n        fix U assume U:\"U\\<in>Pow(A)\"\n        {\n          fix t assume \"t\\<in>U\"\n          with U r have \"t\\<in>{t}\"\"{t}\\<subseteq>U\"\"{t}\\<in>(CoCountable A)\" by auto\n          then have \"\\<exists>V\\<in>(CoCountable A). t\\<in>V \\<and> V\\<subseteq>U\" by auto\n        }\n        then have \"U\\<in>(CoCountable A)\" using topology0.open_neigh_open[OF topology0_CoCardinal[\n          OF InfCard_csucc[OF InfCard_nat]]] unfolding Cocountable_def by auto\n      }\n      then have \"Pow(A)\\<subseteq>(CoCountable A)\" by auto moreover\n      {\n        fix B assume \"B\\<in>(CoCountable A)\"\n        then have \"B\\<in>Pow(\\<Union>(CoCountable A))\" by auto\n        then have \"B\\<in>Pow(A)\" using union_cocardinal[OF noE] unfolding Cocountable_def by auto\n      }\n      ultimately have p:\"Pow(A)=(CoCountable A)\" by auto\n      then have \"(CoCountable A){is anti-compact}\" using pow_anti_compact[of \"A\"] by auto moreover\n      from p have \"\\<Union>(CoCountable A)=\\<Union>Pow(A)\" by auto\n      then have tot:\"\\<Union>(CoCountable A)=A\" by auto\n      from comp have \"(\\<Union>((CoCountable A){restricted to}(\\<Union>(CoCountable A)))){is compact in}((CoCountable A){restricted to}(\\<Union>(CoCountable A)))\" using compact_imp_compact_subspace\n        Compact_is_card_nat tot unfolding RestrictedTo_def by auto\n      ultimately have \"A{is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\"\n        using comp tot unfolding IsAntiComp_def antiProperty_def by auto\n    }\n    moreover\n    {\n      assume as1:\"\\<not>(A\\<prec>csucc(nat))\"\n      from ass have \"A\\<lesssim>csucc(nat)\" using subset_imp_lepoll by auto\n      with as1 have \"A\\<approx>csucc(nat)\" using lepoll_iff_leqpoll by auto\n      then have \"csucc(nat)\\<approx>A\" using eqpoll_sym by auto\n      then have \"nat\\<prec>A\" using lesspoll_eq_trans lt_csucc[OF Ord_nat]\n        lt_Card_imp_lesspoll[OF Card_csucc[OF Ord_nat]] by auto\n      then have \"nat\\<lesssim>A\" using lepoll_iff_leqpoll by auto\n      then obtain f where \"f\\<in>inj(nat,A)\" unfolding lepoll_def by auto moreover\n      then have fun:\"f:nat\\<rightarrow>A\" unfolding inj_def by auto\n      then have \"f\\<in>surj(nat,range(f))\" using fun_is_surj by auto\n      ultimately have \"f\\<in>bij(nat,range(f))\" unfolding bij_def inj_def surj_def by auto\n      then have \"nat\\<approx>range(f)\" unfolding eqpoll_def by auto\n      then have e:\"range(f)\\<approx>nat\" using eqpoll_sym by auto\n      then have as2:\"range(f)\\<prec>csucc(nat)\" using lt_Card_imp_lesspoll[OF Card_csucc[OF Ord_nat]]\n        lt_csucc[OF Ord_nat] eq_lesspoll_trans by auto\n      then have \"range(f){is closed in}(CoCountable A)\" using closed_sets_cocardinal[of \"csucc(nat)\"\n          \"range(f)\"\"A\"] unfolding Cocountable_def using func1_1_L5B[OF fun] noE by auto\n      then have \"(A\\<inter>range(f)){is compact in}(CoCountable A)\" using compact_closed union_cocardinal[OF noE, of \"A\"]\n        comp Compact_is_card_nat unfolding Cocountable_def by auto\n      moreover have int:\"A\\<inter>range(f)=range(f)\"\"range(f)\\<inter>A=range(f)\" using func1_1_L5B[OF fun] by auto\n      ultimately have \"range(f){is compact in}(CoCountable A)\" by auto\n      then have \"range(f){is compact in}((CoCountable A){restricted to}range(f))\" using compact_imp_compact_subspace\n        Compact_is_card_nat by auto\n      moreover have \"((CoCountable A){restricted to}range(f))=CoCountable (range(f)\\<inter>A)\"\n        using subspace_cocardinal unfolding Cocountable_def by auto\n      with int(2) have \"((CoCountable A){restricted to}range(f))=CoCountable range(f)\" by auto\n      ultimately have comp2:\"range(f){is compact in}(CoCountable range(f))\" by auto\n      {\n        fix t assume t:\"t\\<in>range(f)\"\n        have \"range(f)-{t}\\<subseteq>range(f)\" by auto\n        then have \"range(f)-{t}\\<lesssim>range(f)\" using subset_imp_lepoll by auto\n        with as2 have \"range(f)-{t}\\<prec>csucc(nat)\" using lesspoll_trans1 by auto moreover note noE\n        ultimately have \"(range(f)-{t}){is closed in}(CoCountable range(f))\" using closed_sets_cocardinal[of \"csucc(nat)\"\n          \"range(f)-{t}\"\"range(f)\"] unfolding Cocountable_def by auto\n        then have \"range(f)-(range(f)-{t})\\<in>(CoCountable range(f))\" unfolding IsClosed_def using union_cocardinal[OF noE, of \"range(f)\"]\n          unfolding Cocountable_def by auto moreover\n        from t have \"range(f)-(range(f)-{t})={t}\" by auto ultimately\n        have \"{t}\\<in>(CoCountable range(f))\" by auto\n      }\n      then have r:\"\\<forall>t\\<in>range(f). {t}\\<in>(CoCountable range(f))\" by auto\n      {\n        fix U assume U:\"U\\<in>Pow(range(f))\"\n        {\n          fix t assume \"t\\<in>U\"\n          with U r have \"t\\<in>{t}\"\"{t}\\<subseteq>U\"\"{t}\\<in>(CoCountable range(f))\" by auto\n          then have \"\\<exists>V\\<in>(CoCountable range(f)). t\\<in>V \\<and> V\\<subseteq>U\" by auto\n        }\n        then have \"U\\<in>(CoCountable range(f))\" using topology0.open_neigh_open[OF topology0_CoCardinal[\n          OF InfCard_csucc[OF InfCard_nat]]] unfolding Cocountable_def by auto\n      }\n      then have \"Pow(range(f))\\<subseteq>(CoCountable range(f))\" by auto moreover\n      {\n        fix B assume \"B\\<in>(CoCountable range(f))\"\n        then have \"B\\<in>Pow(\\<Union>(CoCountable range(f)))\" by auto\n        then have \"B\\<in>Pow(range(f))\" using union_cocardinal[OF noE] unfolding Cocountable_def by auto\n      }\n      ultimately have p:\"Pow(range(f))=(CoCountable range(f))\" by blast\n      then have \"(CoCountable range(f)){is anti-compact}\" using pow_anti_compact[of \"range(f)\"] by auto moreover\n      from p have \"\\<Union>(CoCountable range(f))=\\<Union>Pow(range(f))\" by auto\n      then have tot:\"\\<Union>(CoCountable range(f))=range(f)\" by auto\n      from comp2 have \"(\\<Union>((CoCountable range(f)){restricted to}(\\<Union>(CoCountable range(f))))){is compact in}((CoCountable range(f)){restricted to}(\\<Union>(CoCountable range(f))))\" using compact_imp_compact_subspace\n        Compact_is_card_nat tot unfolding RestrictedTo_def by auto\n      ultimately have \"range(f){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\"\n        using comp tot unfolding IsAntiComp_def antiProperty_def by auto\n      then have \"Finite(range(f))\" using compact_spectrum by auto\n      then have \"Finite(nat)\" using e eqpoll_imp_Finite_iff by auto\n      then have \"False\" using nat_not_Finite by auto\n    }\n    ultimately have \"A{is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" by auto\n  }\n  then have \"\\<forall>A\\<in>Pow(\\<Union>(CoCountable csucc(nat))). ((\\<Union>((CoCountable csucc(nat)) {restricted to} A)) {is compact in} ((CoCountable csucc(nat)) {restricted to} A))\n    \\<longrightarrow> (A{is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T))\" by auto\n  then show ?thesis unfolding IsAntiComp_def antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2412
    },
    "2173": {
        "type": "theorem",
        "text": "text\\<open>The cofinite topology on the natural numbers is $T_1$, but\nnot US.\\<close>\n",
        "assumes": "",
        "using": [
            "id_type",
            "union_cocardinal",
            "Cofinite_def",
            "func1_1_L1",
            "Le_directs_nat",
            "topology0.Top_2_L2",
            "topology0_CoCardinal[OF",
            "InfCard_nat]",
            "U(2)",
            "CoCardinal_def",
            "lesspoll_nat_is_Finite",
            "topology0.Top_2_L1",
            "subset_Finite",
            "Le_directs_nat(1)",
            "ord_linear_subset[of",
            "\"nat\"",
            "\"Le\"",
            "\"nat-U\"]",
            "linord_max_props(3)[of",
            "\"nat-U\"\"Le\"\"nat-U\"]",
            "FinPow_def",
            "apply_type[OF",
            "f]",
            "linord_max_props(2)[OF",
            "lin",
            "_",
            "s(2)]",
            "fin",
            "nat_succI",
            "id_conv",
            "r_def(1)",
            "lt_trans2",
            "dom",
            "A",
            "IsUS_def",
            "fun"
        ],
        "statement": "theorem cofinite_not_US:\n  shows \"\\<not>((CoFinite nat){is US})\"\n",
        "proof": "proof\n  assume A:\"(CoFinite nat){is US}\"\n  let ?N=\"id(nat)\"\n  have f:\"?N:nat\\<rightarrow>nat\" using id_type by auto\n  then have fun:\"?N:nat\\<rightarrow>\\<Union>(CoCardinal(nat,nat))\" using union_cocardinal unfolding Cofinite_def by auto\n  then have dom:\"domain(?N)=nat\" using func1_1_L1 by auto\n  with fun have NET:\"\\<langle>?N,Le\\<rangle>{is a net on}\\<Union>(CoCardinal(nat,nat))\" unfolding IsNet_def\n    using Le_directs_nat by auto\n  have tot:\"\\<Union>(CoCardinal(nat,nat))=nat\" using union_cocardinal by auto\n  {\n    fix U n assume U:\"U\\<in>Pow(\\<Union>(CoFinite nat))\" \"n\\<in>Interior(U,(CoFinite nat))\"\n    have \"Interior(U,(CoFinite nat))\\<in>(CoFinite nat)\" using topology0.Top_2_L2\n      topology0_CoCardinal[OF InfCard_nat] unfolding Cofinite_def by auto\n    then have \"nat-Interior(U,(CoFinite nat))\\<prec>nat\" using U(2) unfolding Cofinite_def\n      CoCardinal_def by auto\n    then have \"Finite(nat-Interior(U,(CoFinite nat)))\" using lesspoll_nat_is_Finite by auto moreover\n    have \"nat-U\\<subseteq>nat-Interior(U,(CoFinite nat))\" using topology0.Top_2_L1\n      topology0_CoCardinal[OF InfCard_nat] unfolding Cofinite_def by auto\n    ultimately have fin:\"Finite(nat-U)\" using subset_Finite by auto\n    moreover have lin:\"IsLinOrder(nat,Le)\" using Le_directs_nat(1) by auto\n    then have \"IsLinOrder(nat-U,Le)\" using ord_linear_subset[of \"nat\" \"Le\" \"nat-U\"] by auto\n    ultimately have r:\"nat-U=0 \\<or> (\\<forall>r\\<in>nat-U. \\<langle>r,Maximum(Le,nat-U)\\<rangle>\\<in>Le)\" using linord_max_props(3)[of \"nat-U\"\"Le\"\"nat-U\"]\n      unfolding FinPow_def by auto\n    {\n      assume reg:\"\\<forall>s\\<in>nat. \\<exists>r\\<in>nat. \\<langle>s,r\\<rangle>\\<in>Le \\<and> ?N`r\\<notin>U\"\n      with r have s:\"(\\<forall>r\\<in>nat-U. \\<langle>r,Maximum(Le,nat-U)\\<rangle>\\<in>Le)\" \"nat-U\\<noteq>0\" using apply_type[OF f] by auto\n      have \"Maximum(Le,nat-U)\\<in>nat\" using linord_max_props(2)[OF lin _ s(2)] fin\n        unfolding FinPow_def by auto\n      then have \"succ(Maximum(Le,nat-U))\\<in>nat\" using nat_succI by auto\n      with reg have \"\\<exists>r\\<in>nat. \\<langle>succ(Maximum(Le,nat-U)),r\\<rangle>\\<in>Le \\<and> ?N`r\\<notin>U\" by auto\n      then obtain r where r_def:\"r\\<in>nat\" \"\\<langle>succ(Maximum(Le,nat-U)),r\\<rangle>\\<in>Le\" \"?N`r\\<notin>U\" by auto\n      from r_def(1,3) have \"?N`r\\<in>nat-U\" using apply_type[OF f] by auto\n      with s(1) have \"\\<langle>?N`r,Maximum(Le,nat-U)\\<rangle>\\<in>Le\" by auto\n      then have \"\\<langle>r,Maximum(Le,nat-U)\\<rangle>\\<in>Le\" using id_conv r_def(1) by auto\n      then have \"r<succ(Maximum(Le,nat-U))\" by auto\n      with r_def(2) have \"r<r\" using lt_trans2 by auto\n      then have \"False\" by auto\n    }\n    then have \"\\<exists>s\\<in>nat. \\<forall>r\\<in>nat. \\<langle>s,r\\<rangle>\\<in>Le \\<longrightarrow> ?N`r\\<in>U\" by auto\n  }\n  then have \"\\<forall>n\\<in>nat. \\<forall>U\\<in>Pow(\\<Union>(CoFinite nat)). n\\<in>Interior(U,CoFinite nat) \\<longrightarrow> (\\<exists>s\\<in>nat. \\<forall>r\\<in>nat. \\<langle>s,r\\<rangle>\\<in>Le \\<longrightarrow> ?N`r\\<in>U)\" by auto\n  with tot have \"\\<forall>n\\<in>\\<Union>(CoCardinal(nat,nat)). \\<forall>U\\<in>Pow(\\<Union>(CoCardinal(nat,nat))). n\\<in>Interior(U,CoCardinal(nat,nat)) \\<longrightarrow> (\\<exists>s\\<in>nat. \\<forall>r\\<in>nat. \\<langle>s,r\\<rangle>\\<in>Le \\<longrightarrow> ?N`r\\<in>U)\"\n    unfolding Cofinite_def by auto\n  then have \"\\<forall>n\\<in>\\<Union>(CoCardinal(nat,nat)). (\\<langle>?N,Le\\<rangle>\\<rightarrow>\\<^sub>N n {in}(CoCardinal(nat,nat)))\" unfolding topology0.NetConverges_def[OF topology0_CoCardinal[OF InfCard_nat] NET]\n    using dom by auto\n  with tot have \"\\<forall>n\\<in>nat. (\\<langle>?N,Le\\<rangle>\\<rightarrow>\\<^sub>N n {in}(CoFinite nat))\" unfolding Cofinite_def by auto\n  then have \"(\\<langle>?N,Le\\<rangle>\\<rightarrow>\\<^sub>N 0 {in}(CoFinite nat)) \\<and> (\\<langle>?N,Le\\<rangle>\\<rightarrow>\\<^sub>N 1 {in}(CoFinite nat)) \\<and> 0\\<noteq>1\" by auto\n  then show \"False\" using A unfolding IsUS_def using fun unfolding Cofinite_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2413
    },
    "2174": {
        "type": "theorem",
        "text": "text\\<open>To end, we need a space which is US but no KC. This example\ncomes from the one point compactification of a $T_2$, anti-compact\nand non discrete space. This $T_2$, anti-compact and non discrete space\ncomes from a construction over the cardinal $\\mathbb{N}^+$ or \\<open>csucc(nat)\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "mem_not_refl",
            "unM",
            "CoCar_is_topology[OF",
            "InfCard_csucc[OF",
            "InfCard_nat]]",
            "IsATopology_def",
            "Cocountable_def",
            "a1",
            "M",
            "mem_not_refl[of",
            "\"csucc(nat)\"]",
            "subset_imp_lepoll",
            "lesspoll_trans1",
            "unSC",
            "union_cocardinal[OF",
            "noE]",
            "unMP",
            "CoCardinal_def",
            "noe",
            "UV",
            "cocountable_in_csucc_nat_HConn",
            "IsHConnected_def"
        ],
        "statement": "theorem extension_pow_top:\n  shows \"(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){is a topology}\"\n",
        "proof": "proof-\n  have noE:\"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto \n  {\n    fix M assume M:\"M\\<subseteq>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n    let ?MP=\"{U\\<in>M. U\\<in>Pow(csucc(nat))}\"\n    let ?MN=\"{U\\<in>M. U\\<notin>Pow(csucc(nat))}\"\n    have unM:\"\\<Union>M=(\\<Union>?MP)\\<union>(\\<Union>?MN)\" by auto\n    have \"csucc(nat)\\<notin>csucc(nat)\" using mem_not_refl by auto\n    with M have MN:\"?MN={U\\<in>M. U\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}}\" by auto\n    have unMP:\"\\<Union>?MP\\<in>Pow(csucc(nat))\" by auto\n    then have \"?MN=0\\<longrightarrow>\\<Union>M\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n      using unM by auto moreover\n    {\n      assume \"?MN\\<noteq>0\"\n      with MN have \"{U\\<in>M. U\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}}\\<noteq>0\" by auto\n      then obtain U where U:\"U\\<in>M\" \"U\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by blast\n      then obtain S where S:\"U={csucc(nat)}\\<union>S\" \"S\\<in>(CoCountable csucc(nat))-{0}\" by auto\n      with U MN have \"csucc(nat)\\<in>U\" \"U\\<in>?MN\" by auto\n      then have a1:\"csucc(nat)\\<in>\\<Union>?MN\" by auto\n      let ?SC=\"{S\\<in>(CoCountable csucc(nat)). {csucc(nat)}\\<union>S\\<in>M}\"\n      have unSC:\"\\<Union>?SC\\<in>(CoCountable csucc(nat))\" using CoCar_is_topology[OF InfCard_csucc[OF InfCard_nat]]\n        unfolding IsATopology_def unfolding Cocountable_def by blast\n      {\n        fix s assume \"s\\<in>{csucc(nat)}\\<union>\\<Union>?SC\"\n        then have \"s=csucc(nat)\\<or>s\\<in>\\<Union>?SC\" by auto\n        then have \"s\\<in>\\<Union>?MN\\<or>(\\<exists>S\\<in>?SC. s\\<in>S)\" using a1 by auto\n        then have \"s\\<in>\\<Union>?MN\\<or>(\\<exists>S\\<in>(CoCountable csucc(nat)). {csucc(nat)}\\<union>S\\<in>M \\<and> s\\<in>S)\" by auto\n        with MN have \"s\\<in>\\<Union>?MN\\<or>(\\<exists>S\\<in>(CoCountable csucc(nat)). {csucc(nat)}\\<union>S\\<in>?MN \\<and> s\\<in>S)\" by auto\n        then have \"s\\<in>\\<Union>?MN\" by blast\n      }\n      then have \"{csucc(nat)}\\<union>\\<Union>?SC\\<subseteq>\\<Union>?MN\" by blast\n      moreover\n      {\n        fix s assume \"s\\<in>\\<Union>?MN\"\n        then obtain U where U:\"s\\<in>U\" \"U\\<in>M\" \"U\\<notin>Pow(csucc(nat))\" by auto\n        with M have \"U\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))}\" by auto\n        then obtain S where S:\"U={csucc(nat)}\\<union>S\" \"S\\<in>(CoCountable csucc(nat))\" by auto\n        with U(1) have \"s=csucc(nat)\\<or>s\\<in>S\" by auto\n        with S U(2) have \"s=csucc(nat)\\<or>s\\<in>\\<Union>?SC\" by auto\n        then have \"s\\<in>{csucc(nat)}\\<union>\\<Union>?SC\" by auto\n      }\n      then have \"\\<Union>?MN\\<subseteq>{csucc(nat)}\\<union>\\<Union>?SC\" by blast\n      ultimately have unMN:\"\\<Union>?MN={csucc(nat)}\\<union>\\<Union>?SC\" by auto\n      from unSC have b1:\"csucc(nat)-\\<Union>?SC\\<prec>csucc(nat)\\<or>\\<Union>?SC=0\" unfolding Cocountable_def CoCardinal_def\n        by auto\n      {\n        assume \"0\\<in>?SC\"\n        then have \"{csucc(nat)}\\<in>M\" by auto\n        then have \"{csucc(nat)}\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" using mem_not_refl\n          M by auto\n        then obtain S where S:\"S\\<in>(CoCountable csucc(nat))-{0}\" \"{csucc(nat)}={csucc(nat)}\\<union>S\" by auto\n        {\n          fix x assume \"x\\<in>S\"\n          then have \"x\\<in>{csucc(nat)}\\<union>S\" by auto\n          with S(2) have \"x\\<in>{csucc(nat)}\" by auto\n          then have \"x=csucc(nat)\" by auto\n        }\n        then have \"S\\<subseteq>{csucc(nat)}\" by auto\n        with S(1) have \"S={csucc(nat)}\" by auto\n        with S(1) have \"csucc(nat)-{csucc(nat)}\\<prec>csucc(nat)\" unfolding Cocountable_def CoCardinal_def\n          by auto moreover\n        then have \"csucc(nat)-{csucc(nat)}=csucc(nat)\" using mem_not_refl[of \"csucc(nat)\"] by force\n        ultimately have \"False\" by auto\n      }\n      then have \"0\\<notin>?SC\" by auto moreover\n      from S U(1) have \"S\\<in>?SC\" by auto\n      ultimately have \"S\\<subseteq>\\<Union>?SC\" \"S\\<noteq>0\" by auto\n      then have noe:\"\\<Union>?SC\\<noteq>0\" by auto\n      with b1 have \"csucc(nat)-\\<Union>?SC\\<prec>csucc(nat)\" by auto\n      moreover have \"csucc(nat)-(\\<Union>?SC \\<union> \\<Union>?MP)\\<subseteq>csucc(nat)-\\<Union>?SC\" by auto\n      then have \"csucc(nat)-(\\<Union>?SC \\<union> \\<Union>?MP)\\<lesssim>csucc(nat)-\\<Union>?SC\" using subset_imp_lepoll by auto\n      ultimately have \"csucc(nat)-(\\<Union>?SC \\<union> \\<Union>?MP)\\<prec>csucc(nat)\" using lesspoll_trans1 by auto moreover\n      have \"\\<Union>?SC\\<subseteq>\\<Union>(CoCountable csucc(nat))\" using unSC by auto\n      then have \"\\<Union>?SC\\<subseteq>csucc(nat)\" using union_cocardinal[OF noE] unfolding Cocountable_def by auto\n      ultimately have \"(\\<Union>?SC \\<union> \\<Union>?MP)\\<in>(CoCountable csucc(nat))\"\n        using unMP unfolding Cocountable_def CoCardinal_def by auto\n      then have \"{csucc(nat)}\\<union>(\\<Union>?SC \\<union> \\<Union>?MP)\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n        using noe by auto moreover\n      from unM unMN have \"\\<Union>M=({csucc(nat)}\\<union>\\<Union>?SC) \\<union> \\<Union>?MP\" by auto\n      then have \"\\<Union>M={csucc(nat)}\\<union>(\\<Union>?SC \\<union> \\<Union>?MP)\" by auto\n      ultimately have \"\\<Union>M\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n    }\n    ultimately have \"\\<Union>M\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  }\n  then have \"\\<forall>M\\<in>Pow(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}). \\<Union>M\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  moreover\n  {\n    fix U V assume UV:\"U\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" \"V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n    {\n      assume \"csucc(nat)\\<notin>U\\<or>csucc(nat)\\<notin>V\"\n      with UV have \"U\\<in>Pow(csucc(nat))\\<or>V\\<in>Pow(csucc(nat))\" by auto\n      then have \"U\\<inter>V\\<in>Pow(csucc(nat))\" by auto\n      then have \"U\\<inter>V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n    }\n    moreover\n    {\n      assume \"csucc(nat)\\<in>U\\<and>csucc(nat)\\<in>V\"\n      then obtain SU SV where S:\"U={csucc(nat)}\\<union>SU\" \"V={csucc(nat)}\\<union>SV\" \"SU\\<in>(CoCountable csucc(nat))-{0}\"\n        \"SV\\<in>(CoCountable csucc(nat))-{0}\" using UV mem_not_refl by auto\n      from S(1,2) have \"U\\<inter>V={csucc(nat)}\\<union>(SU\\<inter>SV)\" by auto moreover\n      from S(3,4) have \"SU\\<inter>SV\\<in>(CoCountable csucc(nat))\" using CoCar_is_topology[OF InfCard_csucc[OF InfCard_nat]] unfolding IsATopology_def\n        unfolding Cocountable_def by blast moreover\n      from S(3,4) have \"SU\\<inter>SV\\<noteq>0\" using cocountable_in_csucc_nat_HConn unfolding IsHConnected_def\n        by auto ultimately\n      have \"U\\<inter>V\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by auto\n      then have \"U\\<inter>V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n    }\n    ultimately have \"U\\<inter>V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  }\n  then have \"\\<forall>U\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}). \\<forall>V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}). U\\<inter>V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  ultimately show ?thesis unfolding IsATopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2414
    },
    "2175": {
        "type": "lemma",
        "text": "text\\<open>This topology is defined over $\\mathbb{N}^+\\cup\\{\\mathbb{N}^+\\}$ or \\<open>csucc(nat)\\<union>{csucc(nat)}\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "CoCar_is_topology[OF",
            "InfCard_csucc[OF",
            "InfCard_nat]]",
            "IsATopology_def",
            "Cocountable_def",
            "union_cocardinal[OF",
            "noE]"
        ],
        "statement": "lemma extension_pow_union:\n  shows \"\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})=csucc(nat)\\<union>{csucc(nat)}\"\n",
        "proof": "proof\n  have noE:\"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto \n  have \"\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})=\\<Union>(Pow(csucc(nat))) \\<union> (\\<Union>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n    by blast\n  also have \"\\<dots>=csucc(nat) \\<union> (\\<Union>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  ultimately have A:\"\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})=csucc(nat) \\<union> (\\<Union>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  have \"\\<Union>(CoCountable csucc(nat))\\<in>(CoCountable csucc(nat))\" using CoCar_is_topology[OF InfCard_csucc[OF InfCard_nat]]\n    unfolding IsATopology_def Cocountable_def by auto\n  then have \"csucc(nat)\\<in>(CoCountable csucc(nat))\" using union_cocardinal[OF noE] unfolding Cocountable_def\n    by auto\n  with noE have \"csucc(nat)\\<in>(CoCountable csucc(nat))-{0}\" by auto\n  then have \"{csucc(nat)}\\<union>csucc(nat)\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by auto\n  then have \"{csucc(nat)}\\<union>csucc(nat)\\<subseteq>\\<Union>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by blast\n  with A show \"csucc(nat)\\<union>{csucc(nat)}\\<subseteq>\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n    by auto\n  {\n    fix x assume x:\"x\\<in>(\\<Union>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" \"x\\<noteq>csucc(nat)\"\n    then obtain U where U:\"U\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" \"x\\<in>U\" by blast\n    then obtain S where S:\"U={csucc(nat)}\\<union>S\" \"S\\<in>(CoCountable csucc(nat))-{0}\" by auto\n    with U(2) x(2) have \"x\\<in>S\" by auto\n    with S(2) have \"x\\<in>\\<Union>(CoCountable csucc(nat))\" by auto\n    then have \"x\\<in>csucc(nat)\" using union_cocardinal[OF noE] unfolding Cocountable_def by auto\n  }\n  then have \"(\\<Union>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\\<subseteq>csucc(nat) \\<union>{csucc(nat)}\" by blast\n  with A show \"\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\\<subseteq>csucc(nat)\\<union>{csucc(nat)}\"\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2415
    },
    "2176": {
        "type": "lemma",
        "text": "text\\<open>This topology has a discrete open subspace.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma extension_pow_subspace:\n  shows \"(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)=Pow(csucc(nat))\"\n  and \"csucc(nat)\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n",
        "proof": "proof\n  show \"csucc(nat)\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n  {\n    fix x assume \"x\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\"\n    then obtain R where \"x=csucc(nat)\\<inter>R\" \"R\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" unfolding RestrictedTo_def\n      by auto\n    then have \"x\\<in>Pow(csucc(nat))\" by auto\n  }\n  then show \"(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\\<subseteq>Pow(csucc(nat))\" by auto\n  {\n    fix x assume x:\"x\\<in>Pow(csucc(nat))\"\n    then have \"x=csucc(nat)\\<inter>x\" by auto\n    with x have \"x\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\"\n      unfolding RestrictedTo_def by auto\n  }\n  then show \"Pow(csucc(nat))\\<subseteq>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2416
    },
    "2177": {
        "type": "theorem",
        "text": "text\\<open>This topology is Hausdorff.\\<close>\n",
        "assumes": "",
        "using": [
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "extension_pow_union",
            "AB",
            "extension_pow_subspace(1)",
            "extension_pow_subspace(2)",
            "extension_pow_top",
            "IsATopology_def",
            "AB(2)",
            "singleton_eqpoll_1",
            "eq_lesspoll_trans",
            "n_lesspoll_nat",
            "lesspoll_imp_lepoll",
            "Card_less_csucc_eq_le[OF",
            "Card_nat]",
            "closed_sets_cocardinal[OF",
            "noE]",
            "union_cocardinal[OF",
            "p",
            "mem_not_refl[of",
            "\"csucc(nat)\"]",
            "ass(1)",
            "disj",
            "AB(1)",
            "exI[where",
            "P=\"\\<lambda>U.",
            "U\\<in>Pow(csucc(nat))",
            "\\<union>",
            "{{csucc(nat)}\\<union>S.",
            "S\\<in>(CoCountable",
            "csucc(nat))-{0}}\\<and>(\\<exists>V\\<in>Pow(csucc(nat))",
            "csucc(nat))-{0}}.",
            "A\\<in>U\\<and>csucc(nat)\\<in>V\\<and>U\\<inter>V=0)\"",
            "and",
            "x=\"{A}\"]",
            "Bex_def",
            "ass"
        ],
        "statement": "theorem extension_pow_T2:\n  shows \"(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){is T\\<^sub>2}\"\n",
        "proof": "proof-\n  have noE:\"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto \n  {\n    fix A B assume \"A\\<in>\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n      \"B\\<in>\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" \"A\\<noteq>B\"\n    then have AB:\"A\\<in>csucc(nat)\\<union>{csucc(nat)}\" \"B\\<in>csucc(nat)\\<union>{csucc(nat)}\" \"A\\<noteq>B\" using extension_pow_union by auto\n    {\n      assume \"A\\<noteq>csucc(nat)\" \"B\\<noteq>csucc(nat)\"\n      then have \"A\\<in>csucc(nat)\" \"B\\<in>csucc(nat)\" using AB by auto\n      then have sub:\"{A}\\<in>Pow(csucc(nat))\" \"{B}\\<in>Pow(csucc(nat))\" by auto\n      then have \"{A}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\" \n        \"{B}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\" using extension_pow_subspace(1)\n        by auto \n      then obtain RA RB where \"{A}=csucc(nat)\\<inter>RA\" \"{B}=csucc(nat)\\<inter>RB\" \"RA\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n        \"RB\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" unfolding RestrictedTo_def by auto\n      then have \"{A}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" \"{B}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n        using extension_pow_subspace(2) extension_pow_top unfolding IsATopology_def by auto\n      moreover\n      from AB(3) have \"{A}\\<inter>{B}=0\" by auto ultimately\n      have \"\\<exists>U\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}). \\<exists>V\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}). A\\<in>U\\<and>B\\<in>V\\<and>U\\<inter>V=0\" by auto\n    }\n    moreover\n    {\n      assume \"A=csucc(nat)\\<or>B=csucc(nat)\"\n      with AB(3) have disj:\"(A=csucc(nat)\\<and>B\\<noteq>csucc(nat))\\<or>(B=csucc(nat)\\<and>A\\<noteq>csucc(nat))\" by auto\n      {\n        assume ass:\"A=csucc(nat)\\<and>B\\<noteq>csucc(nat)\" \n        then have p:\"B\\<in>csucc(nat)\" using AB(2) by auto\n        have \"{B}\\<approx>1\" using singleton_eqpoll_1 by auto\n        then have \"{B}\\<prec>nat\" using eq_lesspoll_trans n_lesspoll_nat by auto\n        then have \"{B}\\<lesssim>nat\" using lesspoll_imp_lepoll by auto\n        then have \"{B}\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n        with p have \"{B}{is closed in}(CoCountable csucc(nat))\" unfolding Cocountable_def\n          using closed_sets_cocardinal[OF noE] by auto\n        then have \"csucc(nat)-{B}\\<in>(CoCountable csucc(nat))\" unfolding IsClosed_def\n          Cocountable_def using union_cocardinal[OF noE] by auto moreover\n        {\n          assume \"csucc(nat)-{B}=0\"\n          with p have \"csucc(nat)={B}\" by auto\n          then have \"csucc(nat)\\<approx>1\" using singleton_eqpoll_1 by auto\n          then have \"csucc(nat)\\<lesssim>nat\" using eq_lesspoll_trans n_lesspoll_nat lesspoll_imp_lepoll by auto\n          then have \"csucc(nat)\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n          then have \"False\" by auto\n        }\n        ultimately\n        have \"{csucc(nat)}\\<union>(csucc(nat)-{B})\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by auto\n        then have U1:\"{csucc(nat)}\\<union>(csucc(nat)-{B})\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n        have \"{B}\\<in>Pow(csucc(nat))\" using p by auto\n        then have \"{B}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\"\n          using extension_pow_subspace(1) by auto\n        then obtain R where \"R\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" \"{B}=csucc(nat)\\<inter>R\"\n          unfolding RestrictedTo_def by auto\n        then have U2:\"{B}\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" using extension_pow_subspace(2)\n          extension_pow_top unfolding IsATopology_def by auto\n        have \"({csucc(nat)}\\<union>(csucc(nat)-{B}))\\<inter>{B}=0\" using p mem_not_refl[of \"csucc(nat)\"] by auto\n        with U1 U2 have \"\\<exists>U\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}. \\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>U\\<and>B\\<in>V\\<and>U\\<inter>V=0\" using ass(1) by auto\n      }\n      moreover\n      {\n        assume \"\\<not>(A=csucc(nat)\\<and>B\\<noteq>csucc(nat))\" \n        then have ass:\"B = csucc(nat) \\<and> A \\<noteq> csucc(nat)\" using disj by auto\n        then have p:\"A\\<in>csucc(nat)\" using AB(1) by auto\n        have \"{A}\\<approx>1\" using singleton_eqpoll_1 by auto\n        then have \"{A}\\<prec>nat\" using eq_lesspoll_trans n_lesspoll_nat by auto\n        then have \"{A}\\<lesssim>nat\" using lesspoll_imp_lepoll by auto\n        then have \"{A}\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n        with p have \"{A}{is closed in}(CoCountable csucc(nat))\" unfolding Cocountable_def\n          using closed_sets_cocardinal[OF noE] by auto\n        then have \"csucc(nat)-{A}\\<in>(CoCountable csucc(nat))\" unfolding IsClosed_def\n          Cocountable_def using union_cocardinal[OF noE] by auto moreover\n        {\n          assume \"csucc(nat)-{A}=0\"\n          with p have \"csucc(nat)={A}\" by auto\n          then have \"csucc(nat)\\<approx>1\" using singleton_eqpoll_1 by auto\n          then have \"csucc(nat)\\<lesssim>nat\" using eq_lesspoll_trans n_lesspoll_nat lesspoll_imp_lepoll by auto\n          then have \"csucc(nat)\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n          then have \"False\" by auto\n        }\n        ultimately\n        have \"{csucc(nat)}\\<union>(csucc(nat)-{A})\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by auto\n        then have U1:\"{csucc(nat)}\\<union>(csucc(nat)-{A})\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n        have \"{A}\\<in>Pow(csucc(nat))\" using p by auto\n        then have \"{A}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat)\"\n          using extension_pow_subspace(1) by auto\n        then obtain R where \"R\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" \"{A}=csucc(nat)\\<inter>R\"\n          unfolding RestrictedTo_def by auto\n        then have U2:\"{A}\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" using extension_pow_subspace(2)\n          extension_pow_top unfolding IsATopology_def by auto\n        have int:\"{A}\\<inter>({csucc(nat)}\\<union>(csucc(nat)-{A}))=0\" using p mem_not_refl[of \"csucc(nat)\"] by auto\n        have \"A\\<in>{A}\" \"csucc(nat)\\<in>({csucc(nat)}\\<union>(csucc(nat)-{A}))\" by auto\n        with int U1 have \"\\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>{A}\\<and>csucc(nat)\\<in>V\\<and>{A}\\<inter>V=0\" by auto\n        with U2 have \"\\<exists>U\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}. \\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>U\\<and>csucc(nat)\\<in>V\\<and>U\\<inter>V=0\" using exI[where P=\"\\<lambda>U. U\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\\<and>(\\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>U\\<and>csucc(nat)\\<in>V\\<and>U\\<inter>V=0)\" and x=\"{A}\"] unfolding Bex_def by auto\n        then have \"\\<exists>U\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}. \\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>U\\<and>B\\<in>V\\<and>U\\<inter>V=0\" using ass by auto\n      } \n      ultimately have \"\\<exists>U\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}. \\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>U\\<and>B\\<in>V\\<and>U\\<inter>V=0\" by auto\n    }\n    ultimately have \"\\<exists>U\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}. \\<exists>V\\<in>Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}.\n          A\\<in>U\\<and>B\\<in>V\\<and>U\\<inter>V=0\" by auto\n  }\n  then show ?thesis unfolding isT2_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2417
    },
    "2178": {
        "type": "theorem",
        "text": "text\\<open>The topology we built is not discrete; i.e., not every set is open.\\<close>\n",
        "assumes": "",
        "using": [
            "mem_not_refl",
            "mem_not_refl[of",
            "\"csucc(nat)\"]"
        ],
        "statement": "theorem extension_pow_notDiscrete:\n  shows \"{csucc(nat)}\\<notin>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n",
        "proof": "proof\n  assume \"{csucc(nat)}\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n  then have \"{csucc(nat)}\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" using mem_not_refl by auto\n  then obtain S where S:\"S\\<in>(CoCountable csucc(nat))-{0}\" \"{csucc(nat)}={csucc(nat)}\\<union>S\" by auto\n  {\n    fix x assume \"x\\<in>S\"\n    then have \"x\\<in>{csucc(nat)}\\<union>S\" by auto\n    with S(2) have \"x\\<in>{csucc(nat)}\" by auto\n    then have \"x=csucc(nat)\" by auto\n  }\n  then have \"S\\<subseteq>{csucc(nat)}\" by auto\n  with S(1) have \"S={csucc(nat)}\" by auto\n  with S(1) have \"csucc(nat)-{csucc(nat)}\\<prec>csucc(nat)\" unfolding Cocountable_def CoCardinal_def\n    by auto moreover\n  then have \"csucc(nat)-{csucc(nat)}=csucc(nat)\" using mem_not_refl[of \"csucc(nat)\"] by force\n  ultimately show \"False\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2418
    },
    "2179": {
        "type": "theorem",
        "text": "text\\<open>The topology we built is anti-compact.\\<close>\n",
        "assumes": "",
        "using": [
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "extension_pow_union",
            "RestrictedTo_def",
            "compact_subspace_imp_compact",
            "compact_imp_compact_subspace",
            "comp",
            "Compact_is_card_nat",
            "extension_pow_subspace(1)",
            "ss",
            "pow_anti_compact",
            "IsAntiComp_def",
            "antiProperty_def",
            "closed_sets_cocardinal[OF",
            "noE]",
            "Cocountable_def",
            "union_cocardinal[OF",
            "compact_closed",
            "compact_spectrum",
            "Diff_Finite[of",
            "\"{csucc(nat)}\"",
            "\"K\"]",
            "lepoll_iff_leqpoll",
            "subset_imp_lepoll[of",
            "\"K-{csucc(nat)}\"",
            "\"csucc(nat)\"]",
            "eqpoll_sym",
            "lesspoll_eq_trans",
            "lt_csucc[OF",
            "lt_Card_imp_lesspoll[OF",
            "Card_csucc[OF",
            "Ord_nat]]",
            "fun_is_surj",
            "eq_lesspoll_trans",
            "closed_sets_cocardinal[of",
            "\"csucc(nat)\"",
            "\"range(f)\"\"csucc(nat)\"]",
            "func1_1_L5B[OF",
            "fun]",
            "noE",
            "compact_imp_compact_subspace[of",
            "\"range(f)\"",
            "\"nat\"",
            "\"Pow(csucc(nat))",
            "\\<union>",
            "{{csucc(nat)}\\<union>S.",
            "S\\<in>(CoCountable",
            "csucc(nat))-{0}}\"",
            "pow_anti_compact[of",
            "e",
            "eqpoll_imp_Finite_iff",
            "nat_not_Finite"
        ],
        "statement": "theorem extension_pow_antiCompact:\n  shows \"(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){is anti-compact}\"\n",
        "proof": "proof-\n  have noE:\"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto \n  {\n    fix K assume K:\"K\\<subseteq>\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" \n      \"(\\<Union>((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}K)){is compact in}((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}K)\"\n    from K(1) have sub:\"K\\<subseteq>csucc(nat) \\<union>{csucc(nat)}\" using extension_pow_union by auto\n    have \"(\\<Union>((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}K))=(csucc(nat) \\<union>{csucc(nat)})\\<inter>K\"\n      using extension_pow_union unfolding RestrictedTo_def by auto moreover\n    from sub have \"(csucc(nat) \\<union>{csucc(nat)})\\<inter>K=K\" by auto\n    ultimately have \"(\\<Union>((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}K))=K\" by auto\n    with K(2) have \"K{is compact in}((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}K)\" by auto\n    then have comp:\"K{is compact in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" using \n      compact_subspace_imp_compact by auto\n    {\n      assume ss:\"K\\<subseteq>csucc(nat)\"\n      then have \"K{is compact in}((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat))\"\n        using compact_imp_compact_subspace comp Compact_is_card_nat by auto\n      then have \"K{is compact in}Pow(csucc(nat))\" using extension_pow_subspace(1) by auto\n      then have \"K{is compact in}(Pow(csucc(nat)){restricted to}K)\" using compact_imp_compact_subspace\n        Compact_is_card_nat by auto moreover\n      have \"\\<Union>(Pow(csucc(nat)){restricted to}K)=K\" using ss unfolding RestrictedTo_def by auto\n      ultimately have \"(\\<Union>(Pow(csucc(nat)){restricted to}K)){is compact in}(Pow(csucc(nat)){restricted to}K)\" by auto\n      then have \"K{is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using pow_anti_compact \n        unfolding IsAntiComp_def antiProperty_def using ss by auto\n    }\n    moreover\n    {\n      assume \"\\<not>(K\\<subseteq>csucc(nat))\"\n      with sub have \"csucc(nat)\\<in>K\" by auto\n      with sub have ss:\"K-{csucc(nat)}\\<subseteq>csucc(nat)\" by auto\n      {\n        assume prec:\"K-{csucc(nat)}\\<prec>csucc(nat)\"\n        then have \"(K-{csucc(nat)}){is closed in}(CoCountable csucc(nat))\"\n          using closed_sets_cocardinal[OF noE] ss unfolding Cocountable_def by auto\n        then have \"csucc(nat)-(K-{csucc(nat)})\\<in>(CoCountable csucc(nat))\" unfolding IsClosed_def\n          Cocountable_def using union_cocardinal[OF noE] by auto moreover\n        {\n          assume \"csucc(nat)-(K-{csucc(nat)})=0\"\n          with ss have \"csucc(nat)=(K-{csucc(nat)})\" by auto\n          with prec have \"False\" by auto\n        }\n        ultimately have \"{csucc(nat)} \\<union>(csucc(nat)-(K-{csucc(nat)}))\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\"\n          by auto\n        moreover have \"{csucc(nat)} \\<union>(csucc(nat)-(K-{csucc(nat)}))=({csucc(nat)} \\<union> csucc(nat))-(K-{csucc(nat)})\" by blast\n        ultimately have \"({csucc(nat)} \\<union> csucc(nat))-(K-{csucc(nat)})\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by auto\n        then have \"({csucc(nat)} \\<union> csucc(nat))-(K-{csucc(nat)})\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          by auto moreover\n        have \"csucc(nat) \\<union> {csucc(nat)}={csucc(nat)} \\<union> csucc(nat)\" by auto\n        ultimately have \"(csucc(nat) \\<union> {csucc(nat)})-(K-{csucc(nat)})\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          by auto\n        then have \"(\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}))-(K-{csucc(nat)})\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          using extension_pow_union by auto\n        then have \"(K-{csucc(nat)}){is closed in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          unfolding IsClosed_def using ss by auto\n        with comp have \"(K\\<inter>(K-{csucc(nat)})){is compact in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" using compact_closed\n          Compact_is_card_nat by auto\n        moreover have \"K\\<inter>(K-{csucc(nat)})=(K-{csucc(nat)})\" by auto\n        ultimately have \"(K-{csucc(nat)}){is compact in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n        with ss have \"(K-{csucc(nat)}){is compact in}((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat))\"\n          using compact_imp_compact_subspace comp Compact_is_card_nat by auto\n        then have \"(K-{csucc(nat)}){is compact in}(Pow(csucc(nat)))\" using extension_pow_subspace(1) by auto\n        then have \"(K-{csucc(nat)}){is compact in}(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))\" using compact_imp_compact_subspace\n          Compact_is_card_nat by auto moreover\n        have \"\\<Union>(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))=(K-{csucc(nat)})\" using ss unfolding RestrictedTo_def by auto\n        ultimately have \"(\\<Union>(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))){is compact in}(Pow(csucc(nat)){restricted to}(K-{csucc(nat)}))\" by auto\n        then have \"(K-{csucc(nat)}){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using pow_anti_compact \n          unfolding IsAntiComp_def antiProperty_def using ss by auto\n        then have \"Finite(K-{csucc(nat)})\" using compact_spectrum by auto moreover\n        have \"Finite({csucc(nat)})\" by auto ultimately\n        have \"Finite(K)\" using Diff_Finite[of \"{csucc(nat)}\" \"K\"] by auto\n        then have \"K{is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using compact_spectrum by auto\n      }\n      moreover\n      {\n        assume \"\\<not>(K-{csucc(nat)}\\<prec>csucc(nat))\"\n        with ss have \"K-{csucc(nat)}\\<approx>csucc(nat)\" using lepoll_iff_leqpoll subset_imp_lepoll[of \"K-{csucc(nat)}\"\n          \"csucc(nat)\"] by auto\n        then have \"csucc(nat)\\<approx>K-{csucc(nat)}\" using eqpoll_sym by auto\n        then have \"nat\\<prec>K-{csucc(nat)}\" using lesspoll_eq_trans lt_csucc[OF Ord_nat]\n          lt_Card_imp_lesspoll[OF Card_csucc[OF Ord_nat]] by auto\n        then have \"nat\\<lesssim>K-{csucc(nat)}\" using lepoll_iff_leqpoll by auto\n        then obtain f where \"f\\<in>inj(nat,K-{csucc(nat)})\" unfolding lepoll_def by auto moreover\n        then have fun:\"f:nat\\<rightarrow>K-{csucc(nat)}\" unfolding inj_def by auto\n        then have \"f\\<in>surj(nat,range(f))\" using fun_is_surj by auto\n        ultimately have \"f\\<in>bij(nat,range(f))\" unfolding bij_def inj_def surj_def by auto\n        then have \"nat\\<approx>range(f)\" unfolding eqpoll_def by auto\n        then have e:\"range(f)\\<approx>nat\" using eqpoll_sym by auto\n        then have as2:\"range(f)\\<prec>csucc(nat)\" using lt_Card_imp_lesspoll[OF Card_csucc[OF Ord_nat]]\n          lt_csucc[OF Ord_nat] eq_lesspoll_trans by auto\n        then have \"range(f){is closed in}(CoCountable csucc(nat))\" using closed_sets_cocardinal[of \"csucc(nat)\"\n            \"range(f)\"\"csucc(nat)\"] unfolding Cocountable_def using func1_1_L5B[OF fun] ss noE by auto\n        then have \"csucc(nat)-(range(f))\\<in>(CoCountable csucc(nat))\" unfolding IsClosed_def\n          Cocountable_def using union_cocardinal[OF noE] by auto moreover\n        {\n          assume \"csucc(nat)-(range(f))=0\"\n          with ss func1_1_L5B[OF fun] have \"csucc(nat)=(range(f))\" by blast\n          with as2 have \"False\" by auto\n        }\n        ultimately have \"{csucc(nat)} \\<union>(csucc(nat)-(range(f)))\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\"\n          by auto\n        moreover have \"{csucc(nat)} \\<union>(csucc(nat)-(range(f)))=({csucc(nat)} \\<union> csucc(nat))-(range(f))\" using func1_1_L5B[OF fun] by blast\n        ultimately have \"({csucc(nat)} \\<union> csucc(nat))-(range(f))\\<in>{{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" by auto\n        then have \"({csucc(nat)} \\<union> csucc(nat))-(range(f))\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          by auto moreover\n        have \"csucc(nat) \\<union> {csucc(nat)}={csucc(nat)} \\<union> csucc(nat)\" by auto\n        ultimately have \"(csucc(nat) \\<union> {csucc(nat)})-(range(f))\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          by auto\n        then have \"(\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}))-(range(f))\\<in>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          using extension_pow_union by auto moreover\n        have \"range(f)\\<subseteq>\\<Union>(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" using ss func1_1_L5B[OF fun] by auto\n        ultimately have \"(range(f)){is closed in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n          unfolding IsClosed_def by blast\n        with comp have \"(K\\<inter>(range(f))){is compact in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" using compact_closed\n          Compact_is_card_nat by auto\n        moreover have \"K\\<inter>(range(f))=(range(f))\" using func1_1_L5B[OF fun] by auto\n        ultimately have \"(range(f)){is compact in}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\" by auto\n        with ss func1_1_L5B[OF fun] have \"(range(f)){is compact in}((Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}){restricted to}csucc(nat))\"\n          using compact_imp_compact_subspace[of \"range(f)\" \"nat\" \"Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}}\" \"csucc(nat)\"] comp Compact_is_card_nat by auto\n        then have \"(range(f)){is compact in}(Pow(csucc(nat)))\" using extension_pow_subspace(1) by auto\n        then have \"(range(f)){is compact in}(Pow(csucc(nat)){restricted to}(range(f)))\" using compact_imp_compact_subspace\n          Compact_is_card_nat by auto moreover\n        have \"\\<Union>(Pow(csucc(nat)){restricted to}(range(f)))=(range(f))\" using ss func1_1_L5B[OF fun] unfolding RestrictedTo_def by auto\n        ultimately have \"(\\<Union>(Pow(csucc(nat)){restricted to}(range(f)))){is compact in}(Pow(csucc(nat)){restricted to}(range(f)))\" by auto\n        then have \"(range(f)){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using pow_anti_compact[of \"csucc(nat)\"]\n          unfolding IsAntiComp_def antiProperty_def using ss func1_1_L5B[OF fun] by auto\n        then have \"Finite(range(f))\" using compact_spectrum by auto moreover\n        then have \"Finite(nat)\" using e eqpoll_imp_Finite_iff by auto ultimately\n        have \"False\" using nat_not_Finite by auto\n      }\n      ultimately have \"K {is in the spectrum of}( \\<lambda>T. (\\<Union>T) {is compact in} T)\" by auto\n    }\n    ultimately have \"K {is in the spectrum of}( \\<lambda>T. (\\<Union>T) {is compact in} T)\" by auto\n  }\n  then show ?thesis unfolding IsAntiComp_def antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2419
    },
    "2180": {
        "type": "theorem",
        "text": "text\\<open>If a topological space is KC, then its one-point compactification\nis US.\\<close>\n",
        "assumes": "assumes \"T{is KC}\"\n  ",
        "using": [
            "Le_directs_nat(2).",
            "from",
            "A(1)",
            "have",
            "dom:\"domain(N)=nat\"",
            "func1_1_L1",
            "A(2,3)",
            "topology0.NetConverges_def[OF",
            "_",
            "NET]",
            "topology0_def",
            "op_comp_is_top",
            "dom",
            "op_compact_total",
            "NET,",
            "of",
            "\"x\"]",
            "\"y\"]",
            "open_subspace",
            "topology0.Top_2_L3",
            "p(1)",
            "open_subspace(1)",
            "A(2)",
            "mem_not_refl",
            "LeastI[of",
            "\"\\<lambda>m.",
            "N`m\\<noteq>\\<Union>T",
            "\\<and>",
            "\\<langle>n,m\\<rangle>\\<in>Le\"",
            "\"m\"]",
            "nat_into_Ord[of",
            "apply_type[OF",
            "A(1)]",
            "apply_equality[OF",
            "NFun]",
            "func1_1_L1A[OF",
            "R",
            "dir",
            "Top_2_L2",
            "comp",
            "Top_2_L1",
            "\\<langle>s,m\\<rangle>\\<in>Le\"",
            "nat_into_Ord",
            "le_trans",
            "AA",
            "NetConverges_def[OF",
            "net2]",
            "xy(1)",
            "dom2",
            "op2",
            "p(2)",
            "xy(2)",
            "KC_imp_US",
            "IsUS_def",
            "pp(2)",
            "y",
            "A(3)",
            "Top_2_L3",
            "VT",
            "restrict_fun",
            "[OF",
            "R,",
            "\"{n\\<in>nat.",
            "\\<langle>n,r\\<rangle>\\<in>Le}\"]",
            "fun_is_surj",
            "subset_imp_lepoll",
            "surj_fun_inv_2",
            "le_imp_subset",
            "succ_explained",
            "subset_imp_le",
            "\\<open>t\\<in>nat\\<close>",
            "\\<open>j\\<in>nat\\<close>",
            "Ord_def",
            "Transset_def",
            "as(2)",
            "Finite_cons",
            "subset_Finite",
            "lepoll_Finite[of",
            "\"range(restrict(?NN,",
            "{n",
            "\\<in>",
            "nat",
            ".",
            "\\<langle>n,",
            "r\\<rangle>",
            "Le}))\"",
            "\"{n",
            "Le}\"]",
            "ind_on_nat[OF",
            "\\<open>r\\<in>nat\\<close>,",
            "where",
            "P=\"\\<lambda>t.",
            "Finite({n\\<in>nat.",
            "\\<langle>n,t\\<rangle>\\<in>Le})\"]",
            "range_image_domain[OF",
            "NresFun]",
            "restrict_image",
            "compact_spectrum",
            "func1_1_L6(2)[OF",
            "R]",
            "Top_1_L4",
            "compact_subspace_imp_compact",
            "V(2)",
            "FinPow_def",
            "func_imagedef[OF",
            "Ord_linear_le[where",
            "thesis=\"\\<langle>n,r\\<rangle>\\<in>Le\"]",
            "nat_into_Ord[OF",
            "rr(1)]",
            "n(1)]",
            "ss",
            "x",
            "\\<open>r\\<in>nat\\<close>",
            "nat_succI"
        ],
        "statement": "theorem (in topology0) KC_imp_OP_comp_is_US:\n  assumes \"T{is KC}\"\n  shows \"({one-point compactification of}T){is US}\"\n",
        "proof": "proof-\n  {\n    fix N x y assume A:\"N:nat\\<rightarrow>\\<Union>({one-point compactification of}T)\" \"\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N x{in}({one-point compactification of}T)\" \"\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N y{in}({one-point compactification of}T)\" \"x\\<noteq>y\"\n    have dir:\"Le directs nat\" using Le_directs_nat(2).\n    from A(1) have dom:\"domain(N)=nat\" using func1_1_L1 by auto\n    with dir A(1) have NET:\"\\<langle>N,Le\\<rangle>{is a net on}\\<Union>({one-point compactification of}T)\" unfolding IsNet_def by auto\n    have xy:\"x\\<in>\\<Union>({one-point compactification of}T)\" \"y\\<in>\\<Union>({one-point compactification of}T)\"\n      using A(2,3) topology0.NetConverges_def[OF _ NET] unfolding topology0_def using op_comp_is_top dom by auto \n    then have pp:\"x\\<in>\\<Union>T \\<union>{\\<Union>T}\" \"y\\<in>\\<Union>T \\<union>{\\<Union>T}\" using op_compact_total by auto\n    from A(2) have comp:\"\\<forall>U\\<in>Pow(\\<Union>{one-point compactification of}T).\n        x \\<in> Interior(U, {one-point compactification of}T) \\<longrightarrow>\n        (\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> U)\" using topology0.NetConverges_def[OF _ NET, of \"x\"]\n        unfolding topology0_def using op_comp_is_top dom op_compact_total by auto\n    from A(3) have op2:\"\\<forall>U\\<in>Pow(\\<Union>{one-point compactification of}T).\n        y \\<in> Interior(U, {one-point compactification of}T) \\<longrightarrow>\n        (\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> U)\" using topology0.NetConverges_def[OF _ NET, of \"y\"]\n        unfolding topology0_def using op_comp_is_top dom op_compact_total by auto\n    {\n      assume p:\"x\\<in>\\<Union>T\" \"y\\<in>\\<Union>T\"\n      {\n        assume B:\"\\<exists>n\\<in>nat. \\<forall>m\\<in>nat. \\<langle>n,m\\<rangle>\\<in>Le \\<longrightarrow> N`m=\\<Union>T\"\n        have \"\\<Union>T\\<in>({one-point compactification of}T)\" using open_subspace by auto\n        then have \"\\<Union>T=Interior(\\<Union>T,{one-point compactification of}T)\" using topology0.Top_2_L3\n          unfolding topology0_def using op_comp_is_top by auto\n        then have \"x\\<in>Interior(\\<Union>T,{one-point compactification of}T)\" using p(1) by auto moreover\n        have \"\\<Union>T\\<in>Pow(\\<Union>({one-point compactification of}T))\" using open_subspace(1) by auto\n        ultimately have \"\\<exists>t\\<in>domain(fst(\\<langle>N, Le\\<rangle>)). \\<forall>m\\<in>domain(fst(\\<langle>N, Le\\<rangle>)). \\<langle>t, m\\<rangle> \\<in> snd(\\<langle>N, Le\\<rangle>) \\<longrightarrow> fst(\\<langle>N, Le\\<rangle>) ` m \\<in> \\<Union>T\" using A(2)\n          using topology0.NetConverges_def[OF _ NET] op_comp_is_top unfolding topology0_def by blast\n        then have \"\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> \\<Union>T\" using dom by auto\n        then obtain t where t:\"t\\<in>nat\" \"\\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> \\<Union>T\" by auto\n        from B obtain n where n:\"n\\<in>nat\" \"\\<forall>m\\<in>nat. \\<langle>n,m\\<rangle>\\<in>Le \\<longrightarrow> N`m=\\<Union>T\" by auto\n        from t(1) n(1) dir obtain z where z:\"z\\<in>nat\" \"\\<langle>n,z\\<rangle>\\<in>Le\" \"\\<langle>t,z\\<rangle>\\<in>Le\" unfolding IsDirectedSet_def\n          by auto\n        from t(2) z(1,3) have \"N`z\\<in>\\<Union>T\" by auto moreover\n        from n(2) z(1,2) have \"N`z=\\<Union>T\" by auto ultimately\n        have \"False\" using mem_not_refl by auto\n      }\n      then have reg:\"\\<forall>n\\<in>nat. \\<exists>m\\<in>nat. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" by auto\n      let ?NN=\"{\\<langle>n,N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<rangle>. n\\<in>nat}\"\n      {\n        fix x z assume A1:\"\\<langle>x, z\\<rangle> \\<in> ?NN\"\n        {\n          fix y' assume A2:\"\\<langle>x,y'\\<rangle>\\<in>?NN\"\n          with A1 have \"z=y'\" by auto\n        }\n        then have \"\\<forall>y'. \\<langle>x,y'\\<rangle>\\<in>?NN \\<longrightarrow> z=y'\" by auto\n      }\n      then have \"\\<forall>x z. \\<langle>x, z\\<rangle> \\<in> ?NN \\<longrightarrow> (\\<forall>y'. \\<langle>x,y'\\<rangle>\\<in>?NN \\<longrightarrow> z=y')\" by auto\n      moreover\n      {\n      fix n assume as:\"n\\<in>nat\"\n        with reg obtain m where \"N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\\<in>nat\" by auto\n        then have LI:\"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<noteq>\\<Union>T\" \"\\<langle>n,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\"]\n          nat_into_Ord[of \"m\"] by auto\n        then have \"(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<in>nat\" by auto\n        then have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<in>\\<Union>({one-point compactification of}T)\" using apply_type[OF A(1)] op_compact_total by auto\n        with as have \"\\<langle>n,N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<rangle>\\<in>nat\\<times>\\<Union>({one-point compactification of}T)\" by auto\n      }\n      then have \"?NN\\<in>Pow(nat\\<times>\\<Union>({one-point compactification of}T))\" by auto\n      ultimately have NFun:\"?NN:nat\\<rightarrow>\\<Union>({one-point compactification of}T)\" unfolding Pi_def function_def domain_def by auto\n      {\n        fix n assume as:\"n\\<in>nat\"\n        with reg obtain m where \"N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\\<in>nat\" by auto\n        then have LI:\"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<noteq>\\<Union>T\" \"\\<langle>n,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\"]\n          nat_into_Ord[of \"m\"] by auto\n        then have \"?NN`n\\<noteq>\\<Union>T\" using apply_equality[OF _ NFun] by auto\n      }\n      then have noy:\"\\<forall>n\\<in>nat. ?NN`n\\<noteq>\\<Union>T\" by auto\n      then have \"\\<forall>n\\<in>nat. ?NN`n\\<in>\\<Union>T\" using apply_type[OF NFun] op_compact_total by auto\n      then have R:\"?NN:nat\\<rightarrow>\\<Union>T\" using func1_1_L1A[OF NFun] by auto\n      have dom2:\"domain(?NN)=nat\" by auto\n      then have net2:\"\\<langle>?NN,Le\\<rangle>{is a net on}\\<Union>T\" unfolding IsNet_def using R dir by auto\n      {\n        fix U assume U:\"U\\<subseteq>\\<Union>T\" \"x\\<in>int(U)\"\n        have intT:\"int(U)\\<in>T\" using Top_2_L2 by auto\n        then have \"int(U)\\<in>({one-point compactification of}T)\" unfolding OPCompactification_def\n          by auto\n        then have \"Interior(int(U),{one-point compactification of}T)=int(U)\" using topology0.Top_2_L3\n          unfolding topology0_def using op_comp_is_top by auto\n        with U(2) have \"x\\<in>Interior(int(U),{one-point compactification of}T)\" by auto\n        with intT have \"(\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>int(U))\" using comp op_compact_total by auto\n        then obtain r where r_def:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U\" using Top_2_L1 by auto\n        {\n          fix s assume AA:\"\\<langle>r,s\\<rangle>\\<in>Le\"\n          with reg obtain m where \"N`m\\<noteq>\\<Union>T\" \"\\<langle>s,m\\<rangle>\\<in>Le\" by auto\n          then have \"\\<langle>s,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>s,m\\<rangle>\\<in>Le\" \"m\"]\n            nat_into_Ord by auto\n          with AA have \"\\<langle>r,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using le_trans by auto\n          with r_def(2) have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le)\\<in>U\" by blast\n          then have \"?NN`s\\<in>U\" using apply_equality[OF _ NFun] AA by auto\n        }\n        then have \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n        with r_def(1) have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n      }\n      then have \"\\<forall>U\\<in>Pow(\\<Union>T). x \\<in> int(U)\n        \\<longrightarrow> (\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r, s\\<rangle> \\<in> Le \\<longrightarrow> ?NN ` s \\<in> U)\" by auto\n      then have conx:\"\\<langle>?NN,Le\\<rangle>\\<rightarrow>\\<^sub>N x{in}T\" using NetConverges_def[OF net2] p(1) op_comp_is_top \n        unfolding topology0_def using xy(1) dom2 by auto\n      {\n        fix U assume U:\"U\\<subseteq>\\<Union>T\" \"y\\<in>int(U)\"\n        have intT:\"int(U)\\<in>T\" using Top_2_L2 by auto\n        then have \"int(U)\\<in>({one-point compactification of}T)\" unfolding OPCompactification_def\n          by auto\n        then have \"Interior(int(U),{one-point compactification of}T)=int(U)\" using topology0.Top_2_L3\n          unfolding topology0_def using op_comp_is_top by auto\n        with U(2) have \"y\\<in>Interior(int(U),{one-point compactification of}T)\" by auto\n        with intT have \"(\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>int(U))\" using op2 op_compact_total by auto\n        then obtain r where r_def:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U\" using Top_2_L1 by auto\n        {\n          fix s assume AA:\"\\<langle>r,s\\<rangle>\\<in>Le\"\n          with reg obtain m where \"N`m\\<noteq>\\<Union>T\" \"\\<langle>s,m\\<rangle>\\<in>Le\" by auto\n          then have \"\\<langle>s,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>s,m\\<rangle>\\<in>Le\" \"m\"]\n            nat_into_Ord by auto\n          with AA have \"\\<langle>r,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using le_trans by auto\n          with r_def(2) have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le)\\<in>U\" by blast\n          then have \"?NN`s\\<in>U\" using apply_equality[OF _ NFun] AA by auto\n        }\n        then have \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n        with r_def(1) have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n      }\n      then have \"\\<forall>U\\<in>Pow(\\<Union>T). y \\<in> int(U)\n        \\<longrightarrow> (\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r, s\\<rangle> \\<in> Le \\<longrightarrow> ?NN ` s \\<in> U)\" by auto\n      then have cony:\"\\<langle>?NN,Le\\<rangle>\\<rightarrow>\\<^sub>N y{in}T\" using NetConverges_def[OF net2] p(2) op_comp_is_top \n        unfolding topology0_def using xy(2) dom2 by auto\n      with conx assms have \"x=y\" using KC_imp_US unfolding IsUS_def using R by auto\n      with A(4) have \"False\" by auto\n    }\n    moreover\n    {\n      assume AAA:\"x\\<notin>\\<Union>T\\<or>y\\<notin>\\<Union>T\"\n      with pp have \"x=\\<Union>T\\<or>y=\\<Union>T\" by auto\n      {\n        assume x:\"x=\\<Union>T\"\n        with A(4) have y:\"y\\<in>\\<Union>T\" using pp(2) by auto\n        {\n          assume B:\"\\<exists>n\\<in>nat. \\<forall>m\\<in>nat. \\<langle>n,m\\<rangle>\\<in>Le \\<longrightarrow> N`m=\\<Union>T\"\n          have \"\\<Union>T\\<in>({one-point compactification of}T)\" using open_subspace by auto\n          then have \"\\<Union>T=Interior(\\<Union>T,{one-point compactification of}T)\" using topology0.Top_2_L3\n            unfolding topology0_def using op_comp_is_top by auto\n          then have \"y\\<in>Interior(\\<Union>T,{one-point compactification of}T)\" using y by auto moreover\n          have \"\\<Union>T\\<in>Pow(\\<Union>({one-point compactification of}T))\" using open_subspace(1) by auto\n          ultimately have \"\\<exists>t\\<in>domain(fst(\\<langle>N, Le\\<rangle>)). \\<forall>m\\<in>domain(fst(\\<langle>N, Le\\<rangle>)). \\<langle>t, m\\<rangle> \\<in> snd(\\<langle>N, Le\\<rangle>) \\<longrightarrow> fst(\\<langle>N, Le\\<rangle>) ` m \\<in> \\<Union>T\" using A(3)\n            using topology0.NetConverges_def[OF _ NET] op_comp_is_top unfolding topology0_def by blast\n          then have \"\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> \\<Union>T\" using dom by auto\n          then obtain t where t:\"t\\<in>nat\" \"\\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> \\<Union>T\" by auto\n          from B obtain n where n:\"n\\<in>nat\" \"\\<forall>m\\<in>nat. \\<langle>n,m\\<rangle>\\<in>Le \\<longrightarrow> N`m=\\<Union>T\" by auto\n          from t(1) n(1) dir obtain z where z:\"z\\<in>nat\" \"\\<langle>n,z\\<rangle>\\<in>Le\" \"\\<langle>t,z\\<rangle>\\<in>Le\" unfolding IsDirectedSet_def\n            by auto\n          from t(2) z(1,3) have \"N`z\\<in>\\<Union>T\" by auto moreover\n          from n(2) z(1,2) have \"N`z=\\<Union>T\" by auto ultimately\n          have \"False\" using mem_not_refl by auto\n        }\n        then have reg:\"\\<forall>n\\<in>nat. \\<exists>m\\<in>nat. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" by auto\n        let ?NN=\"{\\<langle>n,N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<rangle>. n\\<in>nat}\"\n        {\n          fix x z assume A1:\"\\<langle>x, z\\<rangle> \\<in> ?NN\"\n          {\n            fix y' assume A2:\"\\<langle>x,y'\\<rangle>\\<in>?NN\"\n            with A1 have \"z=y'\" by auto\n          }\n          then have \"\\<forall>y'. \\<langle>x,y'\\<rangle>\\<in>?NN \\<longrightarrow> z=y'\" by auto\n        }\n        then have \"\\<forall>x z. \\<langle>x, z\\<rangle> \\<in> ?NN \\<longrightarrow> (\\<forall>y'. \\<langle>x,y'\\<rangle>\\<in>?NN \\<longrightarrow> z=y')\" by auto\n        moreover\n        {\n          fix n assume as:\"n\\<in>nat\"\n          with reg obtain m where \"N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\\<in>nat\" by auto\n          then have LI:\"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<noteq>\\<Union>T\" \"\\<langle>n,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\"]\n            nat_into_Ord[of \"m\"] by auto\n          then have \"(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<in>nat\" by auto\n          then have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<in>\\<Union>({one-point compactification of}T)\" using apply_type[OF A(1)] op_compact_total by auto\n          with as have \"\\<langle>n,N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<rangle>\\<in>nat\\<times>\\<Union>({one-point compactification of}T)\" by auto\n        }\n        then have \"?NN\\<in>Pow(nat\\<times>\\<Union>({one-point compactification of}T))\" by auto\n        ultimately have NFun:\"?NN:nat\\<rightarrow>\\<Union>({one-point compactification of}T)\" unfolding Pi_def function_def domain_def by auto\n        {\n          fix n assume as:\"n\\<in>nat\"\n          with reg obtain m where \"N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\\<in>nat\" by auto\n          then have LI:\"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<noteq>\\<Union>T\" \"\\<langle>n,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\"]\n            nat_into_Ord[of \"m\"] by auto\n          then have \"?NN`n\\<noteq>\\<Union>T\" using apply_equality[OF _ NFun] by auto\n        }\n        then have noy:\"\\<forall>n\\<in>nat. ?NN`n\\<noteq>\\<Union>T\" by auto\n        then have \"\\<forall>n\\<in>nat. ?NN`n\\<in>\\<Union>T\" using apply_type[OF NFun] op_compact_total by auto\n        then have R:\"?NN:nat\\<rightarrow>\\<Union>T\" using func1_1_L1A[OF NFun] by auto\n        have dom2:\"domain(?NN)=nat\" by auto\n        then have net2:\"\\<langle>?NN,Le\\<rangle>{is a net on}\\<Union>T\" unfolding IsNet_def using R dir by auto\n        {\n          fix U assume U:\"U\\<subseteq>\\<Union>T\" \"y\\<in>int(U)\"\n          have intT:\"int(U)\\<in>T\" using Top_2_L2 by auto\n          then have \"int(U)\\<in>({one-point compactification of}T)\" unfolding OPCompactification_def\n            by auto\n          then have \"Interior(int(U),{one-point compactification of}T)=int(U)\" using topology0.Top_2_L3\n            unfolding topology0_def using op_comp_is_top by auto\n          with U(2) have \"y\\<in>Interior(int(U),{one-point compactification of}T)\" by auto\n          with intT have \"(\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>int(U))\" using op2 op_compact_total by auto\n          then obtain r where r_def:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U\" using Top_2_L1 by auto\n          {\n            fix s assume AA:\"\\<langle>r,s\\<rangle>\\<in>Le\"\n            with reg obtain m where \"N`m\\<noteq>\\<Union>T\" \"\\<langle>s,m\\<rangle>\\<in>Le\" by auto\n            then have \"\\<langle>s,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>s,m\\<rangle>\\<in>Le\" \"m\"]\n              nat_into_Ord by auto\n            with AA have \"\\<langle>r,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using le_trans by auto\n            with r_def(2) have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le)\\<in>U\" by blast\n            then have \"?NN`s\\<in>U\" using apply_equality[OF _ NFun] AA by auto\n          }\n          then have \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n          with r_def(1) have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n        }\n        then have \"\\<forall>U\\<in>Pow(\\<Union>T). y \\<in> int(U)\n          \\<longrightarrow> (\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r, s\\<rangle> \\<in> Le \\<longrightarrow> ?NN ` s \\<in> U)\" by auto\n        then have cony:\"\\<langle>?NN,Le\\<rangle>\\<rightarrow>\\<^sub>N y{in}T\" using NetConverges_def[OF net2] y op_comp_is_top \n          unfolding topology0_def using xy(2) dom2 by auto\n        let ?A=\"{y}\\<union>?NN``nat\"\n        {\n          fix M assume Acov:\"?A\\<subseteq>\\<Union>M\" \"M\\<subseteq>T\"\n          then have \"y\\<in>\\<Union>M\" by auto\n          then obtain V where V:\"y\\<in>V\" \"V\\<in>M\" by auto\n          with Acov(2) have VT:\"V\\<in>T\" by auto\n          then have \"V=int(V)\" using Top_2_L3 by auto\n          with V(1) have \"y\\<in>int(V)\" by auto\n          with cony obtain r where rr:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>V\"\n            unfolding NetConverges_def[OF net2, of \"y\"] using dom2 VT y by auto\n          have NresFun:\"restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}):{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<rightarrow>\\<Union>T\" using restrict_fun\n            [OF R, of \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\"] by auto\n          then have \"restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le})\\<in>surj({n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le},range(restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le})))\"\n            using fun_is_surj by auto moreover\n          have \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<subseteq>nat\" by auto\n          then have \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<lesssim>nat\" using subset_imp_lepoll by auto\n          ultimately have \"range(restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}))\\<lesssim>{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\" using surj_fun_inv_2 by auto\n          moreover\n          have \"{n\\<in>nat. \\<langle>n,0\\<rangle>\\<in>Le}={0}\" by auto\n          then have \"Finite({n\\<in>nat. \\<langle>n,0\\<rangle>\\<in>Le})\" by auto moreover\n          {\n            fix j assume as:\"j\\<in>nat\" \"Finite({n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le})\"\n            {\n              fix t assume \"t\\<in>{n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le}\"\n              then have \"t\\<in>nat\" \"\\<langle>t,succ(j)\\<rangle>\\<in>Le\" by auto\n              then have \"t\\<le>succ(j)\" by auto\n              then have \"t\\<subseteq>succ(j)\" using le_imp_subset by auto\n              then have \"t\\<subseteq>j \\<union>{j}\" using succ_explained by auto\n              then have \"j\\<in>t\\<or>t\\<subseteq>j\" by auto\n              then have \"j\\<in>t\\<or>t\\<le>j\" using subset_imp_le \\<open>t\\<in>nat\\<close> \\<open>j\\<in>nat\\<close> nat_into_Ord by auto\n              then have \"j \\<union>{j}\\<subseteq>t\\<or>t\\<le>j\" using \\<open>t\\<in>nat\\<close> \\<open>j\\<in>nat\\<close> nat_into_Ord unfolding Ord_def\n                Transset_def by auto\n              then have \"succ(j)\\<subseteq>t\\<or>t\\<le>j\" using succ_explained by auto\n              with \\<open>t\\<subseteq>succ(j)\\<close> have \"t=succ(j)\\<or>t\\<le>j\" by auto\n              with \\<open>t\\<in>nat\\<close> \\<open>j\\<in>nat\\<close> have \"t\\<in>{n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le} \\<union> {succ(j)}\" by auto\n            }\n            then have \"{n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le} \\<subseteq>{n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le} \\<union> {succ(j)}\" by auto\n            moreover have \"Finite({n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le} \\<union> {succ(j)})\" using as(2) Finite_cons\n              by auto\n            ultimately have \"Finite({n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le})\" using subset_Finite by auto\n          }\n          then have \"\\<forall>j\\<in>nat. Finite({n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le}) \\<longrightarrow> Finite({n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le})\"\n            by auto\n          ultimately have \"Finite(range(restrict(?NN, {n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})))\"\n            using lepoll_Finite[of \"range(restrict(?NN, {n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}))\"\n              \"{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}\"] ind_on_nat[OF \\<open>r\\<in>nat\\<close>, where P=\"\\<lambda>t. Finite({n\\<in>nat. \\<langle>n,t\\<rangle>\\<in>Le})\"] by auto\n          then have \"Finite((restrict(?NN, {n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}))``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\" using range_image_domain[OF NresFun]\n            by auto\n          then have \"Finite(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\" using restrict_image by auto\n          then have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using compact_spectrum by auto\n          moreover have \"\\<Union>(T{restricted to}?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})=\\<Union>T\\<inter>?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}\"\n            unfolding RestrictedTo_def by auto moreover\n          have \"\\<Union>T\\<inter>?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}=?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}\"\n            using func1_1_L6(2)[OF R] by blast\n          moreover have \"(T{restricted to}?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is a topology}\"\n            using Top_1_L4 unfolding topology0_def by auto\n          ultimately have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is compact in}(T{restricted to}?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\"\n            unfolding Spec_def by force\n          then have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is compact in}(T)\" using compact_subspace_imp_compact by auto\n          moreover from Acov(1) have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\\<subseteq>\\<Union>M\" by auto\n          moreover note Acov(2) ultimately\n          obtain \\<NN> where \\<NN>:\"\\<NN>\\<in>FinPow(M)\" \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\\<subseteq>\\<Union>\\<NN>\"\n            unfolding IsCompact_def by blast\n          from \\<NN>(1) have \"\\<NN> \\<union>{V}\\<in>FinPow(M)\" using V(2) unfolding FinPow_def by auto moreover\n          {\n            fix s assume s:\"s\\<in>?A\" \"s\\<notin>V\"\n            with V(1) have \"s\\<in>?NN``nat\" by auto\n            then have \"s\\<in>{?NN`n. n\\<in>nat}\" using func_imagedef[OF NFun] by auto\n            then obtain n where n:\"n\\<in>nat\" \"s=?NN`n\" by auto\n            {\n              assume \"\\<langle>r,n\\<rangle>\\<in>Le\"\n              with rr have \"?NN`n\\<in>V\" by auto\n              with n(2) s(2) have \"False\" by auto\n            }\n            then have \"\\<langle>r,n\\<rangle>\\<notin>Le\" by auto\n            with rr(1) n(1) have \"\\<not>(r\\<le>n)\" by auto\n            then have \"n\\<le>r\" using Ord_linear_le[where thesis=\"\\<langle>n,r\\<rangle>\\<in>Le\"] nat_into_Ord[OF rr(1)]\n              nat_into_Ord[OF n(1)] by auto\n            with rr(1) n(1) have \"\\<langle>n,r\\<rangle>\\<in>Le\" by auto\n            with n(2) have \"s\\<in>{?NN`t. t\\<in>{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}}\" by auto moreover\n            have \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<subseteq>nat\" by auto\n            ultimately have \"s\\<in>?NN``{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\" using func_imagedef[OF NFun]\n              by auto\n            with \\<NN>(2) have \"s\\<in>\\<Union>\\<NN>\" by auto\n          }\n          then have \"?A\\<subseteq>\\<Union>\\<NN> \\<union> V\" by auto\n          then have \"?A\\<subseteq>\\<Union>(\\<NN> \\<union> {V})\" by auto ultimately\n          have \"\\<exists>\\<NN>\\<in>FinPow(M). ?A\\<subseteq>\\<Union>\\<NN>\" by auto\n        }\n        then have \"\\<forall>M\\<in>Pow(T). ?A\\<subseteq>\\<Union>M \\<longrightarrow> (\\<exists>\\<NN>\\<in>FinPow(M). ?A\\<subseteq>\\<Union>\\<NN>)\" by auto moreover\n        have ss:\"?A\\<subseteq>\\<Union>(T)\" using func1_1_L6(2)[OF R] y by blast ultimately\n        have \"?A{is compact in}(T)\" unfolding IsCompact_def by auto moreover\n        with assms have \"?A{is closed in}(T)\" unfolding IsKC_def IsCompact_def by auto ultimately\n        have \"?A\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}(T)\\<and>B{is closed in}(T)}\" using ss by auto\n        then have \"{\\<Union>T}\\<union>(\\<Union>T-?A)\\<in>({one-point compactification of}T)\" unfolding OPCompactification_def\n          by auto\n        then have \"{\\<Union>T}\\<union>(\\<Union>T-?A)=Interior({\\<Union>T}\\<union>(\\<Union>T-?A),{one-point compactification of}T)\" using topology0.Top_2_L3 op_comp_is_top\n          unfolding topology0_def by auto moreover\n        {\n          assume \"x\\<in>?A\"\n          with A(4) have \"x\\<in>?NN``nat\" by auto\n          then have \"x\\<in>{?NN`n. n\\<in>nat}\" using func_imagedef[OF NFun] by auto\n          then obtain n where \"n\\<in>nat\"\"?NN`n=x\" by auto\n          with noy x have \"False\" by auto\n        }\n        with y have \"x\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" using x by force ultimately\n        have \"x\\<in>Interior({\\<Union>T}\\<union>(\\<Union>T-?A),{one-point compactification of}T)\" \"{\\<Union>T}\\<union>(\\<Union>T-?A)\\<in>Pow(\\<Union>({one-point compactification of}T))\"\n          using op_compact_total by auto moreover\n        have \"(\\<forall>U\\<in>Pow(\\<Union>({one-point compactification of}T)).  x \\<in> Interior(U,{one-point compactification of}T) \\<longrightarrow> (\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> U))\"\n          using A(2) dom topology0.NetConverges_def[OF _ NET] op_comp_is_top unfolding topology0_def by auto\n        ultimately have \"\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> {\\<Union>T}\\<union>(\\<Union>T-?A)\" by blast\n        then obtain r where r_def:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" by auto\n        {\n          fix s assume AA:\"\\<langle>r,s\\<rangle>\\<in>Le\"\n          with reg obtain m where \"N`m\\<noteq>\\<Union>T\" \"\\<langle>s,m\\<rangle>\\<in>Le\" by auto\n          then have \"\\<langle>s,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>s,m\\<rangle>\\<in>Le\" \"m\"]\n            nat_into_Ord by auto\n          with AA have \"\\<langle>r,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using le_trans by auto\n          with r_def(2) have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le)\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" by auto\n          then have \"?NN`s\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" using apply_equality[OF _ NFun] AA by auto\n          with noy have \"?NN`s\\<in>(\\<Union>T-?A)\" using AA by auto\n          moreover have \"?NN`s\\<in>{?NN`t. t\\<in>nat}\" using AA by auto\n          then have \"?NN`s\\<in>?NN``nat\" using func_imagedef[OF NFun] by auto\n          then have \"?NN`s\\<in>?A\" by auto\n          ultimately have \"False\" by auto\n        }\n        moreover have \"r\\<subseteq>succ(r)\" using succ_explained by auto\n        then have \"r\\<le>succ(r)\" using subset_imp_le nat_into_Ord \\<open>r\\<in>nat\\<close> nat_succI\n          by auto\n        then have \"\\<langle>r,succ(r)\\<rangle>\\<in>Le\" using \\<open>r\\<in>nat\\<close> nat_succI by auto\n        ultimately have \"False\" by auto\n      }\n      then have \"x\\<noteq>\\<Union>T\" by auto\n      with xy(1) AAA have \"y\\<notin>\\<Union>T\" \"x\\<in>\\<Union>T\" using op_compact_total by auto\n      with xy(2) have y:\"y=\\<Union>T\" and x:\"x\\<in>\\<Union>T\" using op_compact_total by auto\n      {\n        assume B:\"\\<exists>n\\<in>nat. \\<forall>m\\<in>nat. \\<langle>n,m\\<rangle>\\<in>Le \\<longrightarrow> N`m=\\<Union>T\"\n        have \"\\<Union>T\\<in>({one-point compactification of}T)\" using open_subspace by auto\n        then have \"\\<Union>T=Interior(\\<Union>T,{one-point compactification of}T)\" using topology0.Top_2_L3\n          unfolding topology0_def using op_comp_is_top by auto\n        then have \"x\\<in>Interior(\\<Union>T,{one-point compactification of}T)\" using x by auto moreover\n        have \"\\<Union>T\\<in>Pow(\\<Union>({one-point compactification of}T))\" using open_subspace(1) by auto\n        ultimately have \"\\<exists>t\\<in>domain(fst(\\<langle>N, Le\\<rangle>)). \\<forall>m\\<in>domain(fst(\\<langle>N, Le\\<rangle>)). \\<langle>t, m\\<rangle> \\<in> snd(\\<langle>N, Le\\<rangle>) \\<longrightarrow> fst(\\<langle>N, Le\\<rangle>) ` m \\<in> \\<Union>T\" using A(2)\n          using topology0.NetConverges_def[OF _ NET] op_comp_is_top unfolding topology0_def by blast\n        then have \"\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> \\<Union>T\" using dom by auto\n        then obtain t where t:\"t\\<in>nat\" \"\\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> \\<Union>T\" by auto\n        from B obtain n where n:\"n\\<in>nat\" \"\\<forall>m\\<in>nat. \\<langle>n,m\\<rangle>\\<in>Le \\<longrightarrow> N`m=\\<Union>T\" by auto\n        from t(1) n(1) dir obtain z where z:\"z\\<in>nat\" \"\\<langle>n,z\\<rangle>\\<in>Le\" \"\\<langle>t,z\\<rangle>\\<in>Le\" unfolding IsDirectedSet_def\n          by auto\n        from t(2) z(1,3) have \"N`z\\<in>\\<Union>T\" by auto moreover\n        from n(2) z(1,2) have \"N`z=\\<Union>T\" by auto ultimately\n        have \"False\" using mem_not_refl by auto\n      }\n      then have reg:\"\\<forall>n\\<in>nat. \\<exists>m\\<in>nat. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" by auto\n      let ?NN=\"{\\<langle>n,N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<rangle>. n\\<in>nat}\"\n      {\n        fix x z assume A1:\"\\<langle>x, z\\<rangle> \\<in> ?NN\"\n        {\n          fix y' assume A2:\"\\<langle>x,y'\\<rangle>\\<in>?NN\"\n          with A1 have \"z=y'\" by auto\n        }\n        then have \"\\<forall>y'. \\<langle>x,y'\\<rangle>\\<in>?NN \\<longrightarrow> z=y'\" by auto\n      }\n      then have \"\\<forall>x z. \\<langle>x, z\\<rangle> \\<in> ?NN \\<longrightarrow> (\\<forall>y'. \\<langle>x,y'\\<rangle>\\<in>?NN \\<longrightarrow> z=y')\" by auto\n      moreover\n      {\n        fix n assume as:\"n\\<in>nat\"\n        with reg obtain m where \"N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\\<in>nat\" by auto\n        then have LI:\"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<noteq>\\<Union>T\" \"\\<langle>n,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\"]\n          nat_into_Ord[of \"m\"] by auto\n        then have \"(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<in>nat\" by auto\n        then have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<in>\\<Union>({one-point compactification of}T)\" using apply_type[OF A(1)] op_compact_total by auto\n        with as have \"\\<langle>n,N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<rangle>\\<in>nat\\<times>\\<Union>({one-point compactification of}T)\" by auto\n      }\n      then have \"?NN\\<in>Pow(nat\\<times>\\<Union>({one-point compactification of}T))\" by auto\n      ultimately have NFun:\"?NN:nat\\<rightarrow>\\<Union>({one-point compactification of}T)\" unfolding Pi_def function_def domain_def by auto\n      {\n        fix n assume as:\"n\\<in>nat\"\n        with reg obtain m where \"N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\\<in>nat\" by auto\n        then have LI:\"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le)\\<noteq>\\<Union>T\" \"\\<langle>n,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>n,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>n,m\\<rangle>\\<in>Le\" \"m\"]\n          nat_into_Ord[of \"m\"] by auto\n        then have \"?NN`n\\<noteq>\\<Union>T\" using apply_equality[OF _ NFun] by auto\n      }\n      then have noy:\"\\<forall>n\\<in>nat. ?NN`n\\<noteq>\\<Union>T\" by auto\n      then have \"\\<forall>n\\<in>nat. ?NN`n\\<in>\\<Union>T\" using apply_type[OF NFun] op_compact_total by auto\n      then have R:\"?NN:nat\\<rightarrow>\\<Union>T\" using func1_1_L1A[OF NFun] by auto\n      have dom2:\"domain(?NN)=nat\" by auto\n      then have net2:\"\\<langle>?NN,Le\\<rangle>{is a net on}\\<Union>T\" unfolding IsNet_def using R dir by auto\n      {\n        fix U assume U:\"U\\<subseteq>\\<Union>T\" \"x\\<in>int(U)\"\n        have intT:\"int(U)\\<in>T\" using Top_2_L2 by auto\n        then have \"int(U)\\<in>({one-point compactification of}T)\" unfolding OPCompactification_def\n          by auto\n        then have \"Interior(int(U),{one-point compactification of}T)=int(U)\" using topology0.Top_2_L3\n          unfolding topology0_def using op_comp_is_top by auto\n        with U(2) have \"x\\<in>Interior(int(U),{one-point compactification of}T)\" by auto\n        with intT have \"(\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>int(U))\" using comp op_compact_total by auto\n        then obtain r where r_def:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>U\" using Top_2_L1 by auto\n        {\n          fix s assume AA:\"\\<langle>r,s\\<rangle>\\<in>Le\"\n          with reg obtain m where \"N`m\\<noteq>\\<Union>T\" \"\\<langle>s,m\\<rangle>\\<in>Le\" by auto\n          then have \"\\<langle>s,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>s,m\\<rangle>\\<in>Le\" \"m\"]\n            nat_into_Ord by auto\n          with AA have \"\\<langle>r,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using le_trans by auto\n          with r_def(2) have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le)\\<in>U\" by blast\n          then have \"?NN`s\\<in>U\" using apply_equality[OF _ NFun] AA by auto\n        }\n        then have \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n        with r_def(1) have \"\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>U\" by auto\n      }\n      then have \"\\<forall>U\\<in>Pow(\\<Union>T). x \\<in> int(U)\n        \\<longrightarrow> (\\<exists>r\\<in>nat. \\<forall>s\\<in>nat. \\<langle>r, s\\<rangle> \\<in> Le \\<longrightarrow> ?NN ` s \\<in> U)\" by auto\n      then have cony:\"\\<langle>?NN,Le\\<rangle>\\<rightarrow>\\<^sub>N x{in}T\" using NetConverges_def[OF net2] x op_comp_is_top \n        unfolding topology0_def using xy(2) dom2 by auto\n      let ?A=\"{x}\\<union>?NN``nat\"\n      {\n        fix M assume Acov:\"?A\\<subseteq>\\<Union>M\" \"M\\<subseteq>T\"\n        then have \"x\\<in>\\<Union>M\" by auto\n        then obtain V where V:\"x\\<in>V\" \"V\\<in>M\" by auto\n        with Acov(2) have VT:\"V\\<in>T\" by auto\n        then have \"V=int(V)\" using Top_2_L3 by auto\n        with V(1) have \"x\\<in>int(V)\" by auto\n        with cony VT obtain r where rr:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> ?NN`s\\<in>V\"\n          unfolding NetConverges_def[OF net2, of \"x\"] using dom2 y by auto\n        have NresFun:\"restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}):{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<rightarrow>\\<Union>T\" using restrict_fun\n          [OF R, of \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\"] by auto\n        then have \"restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le})\\<in>surj({n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le},range(restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le})))\"\n          using fun_is_surj by auto moreover\n        have \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<subseteq>nat\" by auto\n        then have \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<lesssim>nat\" using subset_imp_lepoll by auto\n        ultimately have \"range(restrict(?NN,{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}))\\<lesssim>{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\" using surj_fun_inv_2 by auto\n        moreover\n        have \"{n\\<in>nat. \\<langle>n,0\\<rangle>\\<in>Le}={0}\" by auto\n        then have \"Finite({n\\<in>nat. \\<langle>n,0\\<rangle>\\<in>Le})\" by auto moreover\n        {\n          fix j assume as:\"j\\<in>nat\" \"Finite({n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le})\"\n          {\n            fix t assume \"t\\<in>{n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le}\"\n            then have \"t\\<in>nat\" \"\\<langle>t,succ(j)\\<rangle>\\<in>Le\" by auto\n            then have \"t\\<le>succ(j)\" by auto\n            then have \"t\\<subseteq>succ(j)\" using le_imp_subset by auto\n            then have \"t\\<subseteq>j \\<union>{j}\" using succ_explained by auto\n            then have \"j\\<in>t\\<or>t\\<subseteq>j\" by auto\n            then have \"j\\<in>t\\<or>t\\<le>j\" using subset_imp_le \\<open>t\\<in>nat\\<close> \\<open>j\\<in>nat\\<close> nat_into_Ord by auto\n            then have \"j \\<union>{j}\\<subseteq>t\\<or>t\\<le>j\" using \\<open>t\\<in>nat\\<close> \\<open>j\\<in>nat\\<close> nat_into_Ord unfolding Ord_def\n              Transset_def by auto\n            then have \"succ(j)\\<subseteq>t\\<or>t\\<le>j\" using succ_explained by auto\n            with \\<open>t\\<subseteq>succ(j)\\<close> have \"t=succ(j)\\<or>t\\<le>j\" by auto\n            with \\<open>t\\<in>nat\\<close> \\<open>j\\<in>nat\\<close> have \"t\\<in>{n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le} \\<union> {succ(j)}\" by auto\n          }\n          then have \"{n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le} \\<subseteq>{n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le} \\<union> {succ(j)}\" by auto\n          moreover have \"Finite({n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le} \\<union> {succ(j)})\" using as(2) Finite_cons\n            by auto\n          ultimately have \"Finite({n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le})\" using subset_Finite by auto\n        }\n        then have \"\\<forall>j\\<in>nat. Finite({n\\<in>nat. \\<langle>n,j\\<rangle>\\<in>Le}) \\<longrightarrow> Finite({n\\<in>nat. \\<langle>n,succ(j)\\<rangle>\\<in>Le})\"\n          by auto\n        ultimately have \"Finite(range(restrict(?NN, {n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})))\"\n          using lepoll_Finite[of \"range(restrict(?NN, {n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}))\"\n            \"{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}\"] ind_on_nat[OF \\<open>r\\<in>nat\\<close>, where P=\"\\<lambda>t. Finite({n\\<in>nat. \\<langle>n,t\\<rangle>\\<in>Le})\"] by auto\n        then have \"Finite((restrict(?NN, {n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}))``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\" using range_image_domain[OF NresFun]\n          by auto\n        then have \"Finite(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\" using restrict_image by auto\n        then have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using compact_spectrum by auto\n        moreover have \"\\<Union>(T{restricted to}?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})=\\<Union>T\\<inter>?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}\"\n          unfolding RestrictedTo_def by auto moreover\n        have \"\\<Union>T\\<inter>?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}=?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}\"\n          using func1_1_L6(2)[OF R] by blast\n        moreover have \"(T{restricted to}?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is a topology}\"\n          using Top_1_L4 unfolding topology0_def by auto\n        ultimately have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is compact in}(T{restricted to}?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\"\n          unfolding Spec_def by force\n        then have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le}){is compact in}(T)\" using compact_subspace_imp_compact by auto\n        moreover from Acov(1) have \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\\<subseteq>\\<Union>M\" by auto\n        moreover note Acov(2) ultimately\n        obtain \\<NN> where \\<NN>:\"\\<NN>\\<in>FinPow(M)\" \"(?NN``{n \\<in> nat . \\<langle>n, r\\<rangle> \\<in> Le})\\<subseteq>\\<Union>\\<NN>\"\n          unfolding IsCompact_def by blast\n        from \\<NN>(1) have \"\\<NN> \\<union>{V}\\<in>FinPow(M)\" using V(2) unfolding FinPow_def by auto moreover\n        {\n          fix s assume s:\"s\\<in>?A\" \"s\\<notin>V\"\n          with V(1) have \"s\\<in>?NN``nat\" by auto\n          then have \"s\\<in>{?NN`n. n\\<in>nat}\" using func_imagedef[OF NFun] by auto\n          then obtain n where n:\"n\\<in>nat\" \"s=?NN`n\" by auto\n          {\n            assume \"\\<langle>r,n\\<rangle>\\<in>Le\"\n            with rr have \"?NN`n\\<in>V\" by auto\n            with n(2) s(2) have \"False\" by auto\n          }\n          then have \"\\<langle>r,n\\<rangle>\\<notin>Le\" by auto\n          with rr(1) n(1) have \"\\<not>(r\\<le>n)\" by auto\n          then have \"n\\<le>r\" using Ord_linear_le[where thesis=\"\\<langle>n,r\\<rangle>\\<in>Le\"] nat_into_Ord[OF rr(1)]\n            nat_into_Ord[OF n(1)] by auto\n          with rr(1) n(1) have \"\\<langle>n,r\\<rangle>\\<in>Le\" by auto\n          with n(2) have \"s\\<in>{?NN`t. t\\<in>{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}}\" by auto moreover\n          have \"{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\\<subseteq>nat\" by auto\n          ultimately have \"s\\<in>?NN``{n\\<in>nat. \\<langle>n,r\\<rangle>\\<in>Le}\" using func_imagedef[OF NFun]\n            by auto\n          with \\<NN>(2) have \"s\\<in>\\<Union>\\<NN>\" by auto\n        }\n        then have \"?A\\<subseteq>\\<Union>\\<NN> \\<union> V\" by auto\n        then have \"?A\\<subseteq>\\<Union>(\\<NN> \\<union> {V})\" by auto ultimately\n        have \"\\<exists>\\<NN>\\<in>FinPow(M). ?A\\<subseteq>\\<Union>\\<NN>\" by auto\n      }\n      then have \"\\<forall>M\\<in>Pow(T). ?A\\<subseteq>\\<Union>M \\<longrightarrow> (\\<exists>\\<NN>\\<in>FinPow(M). ?A\\<subseteq>\\<Union>\\<NN>)\" by auto moreover\n      have ss:\"?A\\<subseteq>\\<Union>(T)\" using func1_1_L6(2)[OF R] x by blast ultimately\n      have \"?A{is compact in}(T)\" unfolding IsCompact_def by auto moreover\n      with assms have \"?A{is closed in}(T)\" unfolding IsKC_def IsCompact_def by auto ultimately\n      have \"?A\\<in>{B\\<in>Pow(\\<Union>T). B{is compact in}(T)\\<and>B{is closed in}(T)}\" using ss by auto\n      then have \"{\\<Union>T}\\<union>(\\<Union>T-?A)\\<in>({one-point compactification of}T)\" unfolding OPCompactification_def\n        by auto\n      then have \"{\\<Union>T}\\<union>(\\<Union>T-?A)=Interior({\\<Union>T}\\<union>(\\<Union>T-?A),{one-point compactification of}T)\" using topology0.Top_2_L3 op_comp_is_top\n        unfolding topology0_def by auto moreover\n      {\n        assume \"y\\<in>?A\"\n        with A(4) have \"y\\<in>?NN``nat\" by auto\n        then have \"y\\<in>{?NN`n. n\\<in>nat}\" using func_imagedef[OF NFun] by auto\n        then obtain n where \"n\\<in>nat\"\"?NN`n=y\" by auto\n        with noy y have \"False\" by auto\n      }\n      with y have \"y\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" by force ultimately\n      have \"y\\<in>Interior({\\<Union>T}\\<union>(\\<Union>T-?A),{one-point compactification of}T)\" \"{\\<Union>T}\\<union>(\\<Union>T-?A)\\<in>Pow(\\<Union>({one-point compactification of}T))\"\n        using op_compact_total by auto moreover\n      have \"(\\<forall>U\\<in>Pow(\\<Union>({one-point compactification of}T)). y \\<in> Interior(U,{one-point compactification of}T) \\<longrightarrow> (\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> U))\"\n        using A(3) dom topology0.NetConverges_def[OF _ NET] op_comp_is_top unfolding topology0_def by auto\n      ultimately have \"\\<exists>t\\<in>nat. \\<forall>m\\<in>nat. \\<langle>t, m\\<rangle> \\<in> Le \\<longrightarrow> N ` m \\<in> {\\<Union>T}\\<union>(\\<Union>T-?A)\" by blast\n      then obtain r where r_def:\"r\\<in>nat\" \"\\<forall>s\\<in>nat. \\<langle>r,s\\<rangle>\\<in>Le \\<longrightarrow> N`s\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" by auto\n      {\n        fix s assume AA:\"\\<langle>r,s\\<rangle>\\<in>Le\"\n        with reg obtain m where \"N`m\\<noteq>\\<Union>T\" \"\\<langle>s,m\\<rangle>\\<in>Le\" by auto\n        then have \"\\<langle>s,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using LeastI[of \"\\<lambda>m. N`m\\<noteq>\\<Union>T \\<and> \\<langle>s,m\\<rangle>\\<in>Le\" \"m\"]\n          nat_into_Ord by auto\n        with AA have \"\\<langle>r,\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le\\<rangle>\\<in>Le\" using le_trans by auto\n        with r_def(2) have \"N`(\\<mu> i. N`i\\<noteq>\\<Union>T \\<and> \\<langle>s,i\\<rangle>\\<in>Le)\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" by auto\n        then have \"?NN`s\\<in>{\\<Union>T}\\<union>(\\<Union>T-?A)\" using apply_equality[OF _ NFun] AA by auto\n        with noy have \"?NN`s\\<in>(\\<Union>T-?A)\" using AA by auto\n        moreover have \"?NN`s\\<in>{?NN`t. t\\<in>nat}\" using AA by auto\n        then have \"?NN`s\\<in>?NN``nat\" using func_imagedef[OF NFun] by auto\n        then have \"?NN`s\\<in>?A\" by auto\n        ultimately have \"False\" by auto\n      }\n      moreover have \"r\\<subseteq>succ(r)\" using succ_explained by auto\n      then have \"r\\<le>succ(r)\" using subset_imp_le nat_into_Ord \\<open>r\\<in>nat\\<close> nat_succI\n        by auto\n      then have \"\\<langle>r,succ(r)\\<rangle>\\<in>Le\" using \\<open>r\\<in>nat\\<close> nat_succI by auto\n      ultimately have \"False\" by auto\n    }\n    ultimately have \"False\" by auto\n  }\n  then have \"\\<forall>N x y. N:nat\\<rightarrow>(\\<Union>{one-point compactification of}T) \\<and> (\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N x{in}({one-point compactification of}T))\n    \\<and> (\\<langle>N,Le\\<rangle>\\<rightarrow>\\<^sub>N y{in}({one-point compactification of}T)) \\<longrightarrow> x=y\" by auto\n  then show ?thesis unfolding IsUS_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2420
    },
    "2181": {
        "type": "theorem",
        "text": "text\\<open>In the one-point compactification of an anti-compact space,\never subspace that contains the infinite point is compact.\\<close>\n",
        "assumes": "assumes \"T{is anti-compact}\" \"A\\<subseteq>\\<Union>({one-point compactification of}T)\" \"\\<Union>T\\<in>A\"\n  ",
        "using": [
            "mem_not_refl[of",
            "\"\\<Union>T\"]",
            "compact_imp_compact_subspace",
            "Compact_is_card_nat",
            "K(1)",
            "IsCompact_def",
            "compact_spectrum",
            "op_compact_total",
            "subset_Finite",
            "assms(2)",
            "K(3)",
            "topology0.Top_1_L4",
            "op_comp_is_top",
            "topology0_def",
            "compact_subspace_imp_compact",
            "M(2)"
        ],
        "statement": "theorem (in topology0) anti_comp_imp_OP_inf_comp:\n  assumes \"T{is anti-compact}\" \"A\\<subseteq>\\<Union>({one-point compactification of}T)\" \"\\<Union>T\\<in>A\"\n  shows \"A{is compact in}({one-point compactification of}T)\"\n",
        "proof": "proof-\n  {\n    fix M assume M:\"M\\<subseteq>({one-point compactification of}T)\" \"A\\<subseteq>\\<Union>M\"\n    with assms(3) obtain U where U:\"\\<Union>T\\<in>U\" \"U\\<in>M\" by auto\n    with M(1) obtain K where K:\"K{is compact in}T\" \"K{is closed in}T\" \"U={\\<Union>T}\\<union>(\\<Union>T-K)\"\n      unfolding OPCompactification_def using mem_not_refl[of \"\\<Union>T\"] by auto\n    from K(1) have \"K{is compact in}(T{restricted to}K)\" using compact_imp_compact_subspace Compact_is_card_nat\n      by auto\n    moreover have \"\\<Union>(T{restricted to}K)=\\<Union>T\\<inter>K\" unfolding RestrictedTo_def by auto\n    with K(1) have \"\\<Union>(T{restricted to}K)=K\" unfolding IsCompact_def by auto ultimately\n    have \"(\\<Union>(T{restricted to}K)){is compact in}(T{restricted to}K)\" by auto\n    with assms(1) have \"K{is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" unfolding IsAntiComp_def\n      antiProperty_def using K(1) unfolding IsCompact_def by auto\n    then have finK:\"Finite(K)\" using compact_spectrum by auto\n    from assms(2) have \"A-U\\<subseteq>(\\<Union>T \\<union>{\\<Union>T}) -U\" using op_compact_total by auto\n    with K(3) have \"A-U\\<subseteq>K\" by auto\n    with finK have \"Finite(A-U)\" using subset_Finite by auto\n    then have \"(A-U){is in the spectrum of}(\\<lambda>T. (\\<Union>T){is compact in}T)\" using compact_spectrum by auto moreover\n    have \"\\<Union>(({one-point compactification of}T){restricted to}(A-U))=A-U\" unfolding RestrictedTo_def using assms(2) K(3)\n      op_compact_total by auto moreover\n    have \"(({one-point compactification of}T){restricted to}(A-U)){is a topology}\" using topology0.Top_1_L4\n      op_comp_is_top unfolding topology0_def by auto\n    ultimately have \"(A-U){is compact in}(({one-point compactification of}T){restricted to}(A-U))\"\n      unfolding Spec_def by auto\n    then have \"(A-U){is compact in}({one-point compactification of}T)\" using compact_subspace_imp_compact by auto\n    moreover have \"A-U\\<subseteq>\\<Union>M\" using M(2) by auto moreover\n    note M(1) ultimately obtain N where N:\"N\\<in>FinPow(M)\" \"A-U\\<subseteq>\\<Union>N\" unfolding IsCompact_def by blast\n    from N(1) U(2) have \"N \\<union>{U}\\<in>FinPow(M)\" unfolding FinPow_def by auto moreover\n    from N(2) have \"A\\<subseteq>\\<Union>(N \\<union>{U})\" by auto\n    ultimately have \"\\<exists>R\\<in>FinPow(M). A\\<subseteq>\\<Union>R\" by auto\n  }\n  then show ?thesis using op_compact_total assms(2) unfolding IsCompact_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2421
    },
    "2182": {
        "type": "theorem",
        "text": "text\\<open>As a last result in this section, the one-point compactification of our topology is not a KC space.\\<close>\n",
        "assumes": "",
        "using": [
            "Ord_0_lt_csucc[OF",
            "Ord_nat]",
            "mem_not_refl",
            "extension_pow_notDiscrete",
            "extension_pow_union",
            "topology0.op_compact_total",
            "topology0_def",
            "extension_pow_top",
            "topology0.anti_comp_imp_OP_inf_comp[of",
            "\"?T\"",
            "\"(\\<Union>({one-point",
            "compactification",
            "of}?T)-{csucc(nat)})\"]",
            "extension_pow_antiCompact"
        ],
        "statement": "theorem extension_pow_OP_not_KC:\n  shows \"\\<not>(({one-point compactification of}(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})){is KC})\"\n",
        "proof": "proof\n  have noE:\"csucc(nat)\\<noteq>0\" using Ord_0_lt_csucc[OF Ord_nat] by auto\n  let ?T=\"(Pow(csucc(nat)) \\<union> {{csucc(nat)}\\<union>S. S\\<in>(CoCountable csucc(nat))-{0}})\"\n  assume ass:\"({one-point compactification of}?T){is KC}\"\n  from extension_pow_notDiscrete have \"{csucc(nat)} \\<notin> (Pow(csucc(nat)) \\<union> {{csucc(nat)} \\<union> S . S \\<in> (CoCountable csucc(nat)) - {0}})\"\n    by auto\n  {\n    assume \"csucc(nat)=csucc(nat)\\<union>{csucc(nat)}\" moreover\n    have \"csucc(nat)\\<in>csucc(nat)\\<union>{csucc(nat)}\" by auto\n    ultimately have \"csucc(nat)\\<in>csucc(nat)\" by auto\n    then have \"False\" using mem_not_refl by auto\n  }\n  then have dist:\"csucc(nat)\\<noteq>csucc(nat)\\<union>{csucc(nat)}\" by blast\n  {\n    assume \"{csucc(nat)}\\<in>({one-point compactification of}(Pow(csucc(nat)) \\<union> {{csucc(nat)} \\<union> S . S \\<in> (CoCountable csucc(nat)) - {0}}))\"\n    then have \"{csucc(nat)}\\<in>{{\\<Union>?T}\\<union>((\\<Union>?T)-K). K\\<in>{B\\<in>Pow(\\<Union>?T). B{is compact in}?T \\<and> B{is closed in}?T}}\"\n      unfolding OPCompactification_def using extension_pow_notDiscrete by auto\n    then obtain K where \"{csucc(nat)}={\\<Union>?T}\\<union>((\\<Union>?T)-K)\" by auto moreover\n    have \"\\<Union>?T\\<in>{\\<Union>?T}\\<union>((\\<Union>?T)-K)\" by auto\n    ultimately have \"\\<Union>?T\\<in>{csucc(nat)}\" by auto\n    with dist have \"False\" using extension_pow_union by auto\n  }\n  then have \"{csucc(nat)}\\<notin>({one-point compactification of}?T)\" by auto moreover\n  have \"\\<Union>({one-point compactification of}?T)-(\\<Union>({one-point compactification of}?T)-{csucc(nat)})={csucc(nat)}\" using extension_pow_union\n    topology0.op_compact_total unfolding topology0_def using extension_pow_top by auto ultimately\n  have di:\"\\<Union>({one-point compactification of}?T)-(\\<Union>({one-point compactification of}?T)-{csucc(nat)})\\<notin>({one-point compactification of}?T)\" by auto\n  {\n    assume \"(\\<Union>({one-point compactification of}?T)-{csucc(nat)}){is closed in}({one-point compactification of}?T)\"\n    then have \"\\<Union>({one-point compactification of}?T)-(\\<Union>({one-point compactification of}?T)-{csucc(nat)})\\<in>({one-point compactification of}?T)\" unfolding IsClosed_def by auto\n    with di have \"False\" by auto\n  }\n  then have n:\"\\<not>((\\<Union>({one-point compactification of}?T)-{csucc(nat)}){is closed in}({one-point compactification of}?T))\" by auto moreover\n  from dist have \"\\<Union>?T\\<in>(\\<Union>({one-point compactification of}?T)-{csucc(nat)})\" using topology0.op_compact_total unfolding topology0_def using extension_pow_top\n    extension_pow_union by auto\n  then have \"(\\<Union>({one-point compactification of}?T)-{csucc(nat)}){is compact in}({one-point compactification of}?T)\" using topology0.anti_comp_imp_OP_inf_comp[of \"?T\"\n    \"(\\<Union>({one-point compactification of}?T)-{csucc(nat)})\"] unfolding topology0_def using extension_pow_antiCompact extension_pow_top by auto\n  with ass have \"(\\<Union>({one-point compactification of}?T)-{csucc(nat)}){is closed in}({one-point compactification of}?T)\" unfolding IsKC_def by auto\n  with n show \"False\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2422
    },
    "2183": {
        "type": "definition",
        "text": "text\\<open>A space is called perfect if it has no isolated points.\nThis definition may vary in the literature to similar, but not equivalent definitions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsPerf (\"_ {is perfect}\") where\n  \"T{is perfect} \\<equiv> \\<forall>x\\<in>\\<Union>T. {x}\\<notin>T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2423
    },
    "2184": {
        "type": "definition",
        "text": "text\\<open>An anti-perfect space is called scattered.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsScatt (\"_ {is scattered}\") where\n  \"T{is scattered} \\<equiv> T{is anti-}IsPerf\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2424
    },
    "2185": {
        "type": "definition",
        "text": "text\\<open>A topological space with two disjoint dense subspaces\nis called resolvable.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsRes (\"_ {is resolvable}\") where\n  \"T{is resolvable} \\<equiv> \\<exists>U\\<in>Pow(\\<Union>T). \\<exists>V\\<in>Pow(\\<Union>T). Closure(U,T)=\\<Union>T \\<and> Closure(V,T)=\\<Union>T \\<and> U\\<inter>V=0\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2425
    },
    "2186": {
        "type": "definition",
        "text": "text\\<open>A topological space where every dense subset is open\nis called submaximal.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsSubMax (\"_ {is submaximal}\") where\n  \"T{is submaximal} \\<equiv> \\<forall>U\\<in>Pow(\\<Union>T). Closure(U,T)=\\<Union>T \\<longrightarrow> U\\<in>T\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2426
    },
    "2187": {
        "type": "definition",
        "text": "text\\<open>A subset of a topological space is nowhere-dense if\nthe interior of its closure is empty.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsNowhereDense (\"_ {is nowhere dense in} _\") where\n  \"A{is nowhere dense in}T \\<equiv> A\\<subseteq>\\<Union>T \\<and> Interior(Closure(A,T),T)=0\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2427
    },
    "2188": {
        "type": "definition",
        "text": "text\\<open>A topological space is then a Luzin space if\nevery nowhere-dense subset is countable.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsLuzin (\"_ {is luzin}\") where\n  \"T{is luzin} \\<equiv> \\<forall>A\\<in>Pow(\\<Union>T). (A{is nowhere dense in}T) \\<longrightarrow> A\\<lesssim>nat\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2428
    },
    "2189": {
        "type": "definition",
        "text": "text\\<open>An also useful property is local-connexion.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsLocConn (\"_{is locally-connected}\") where\n  \"T{is locally-connected} \\<equiv> T{is locally}(\\<lambda>T. \\<lambda>B. ((T{restricted to}B){is connected}))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2429
    },
    "2190": {
        "type": "definition",
        "text": "text\\<open>An SI-space is an anti-resolvable perfect space.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsAntiRes (\"_{is anti-resolvable}\") where\n  \"T{is anti-resolvable} \\<equiv> T{is anti-}IsRes\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2430
    },
    "2191": {
        "type": "lemma",
        "text": "text\\<open>Firstly, we need to compute the spectrum of\nthe being perfect.\\<close>\n",
        "assumes": "",
        "using": [
            "Pow_is_top",
            "eqpoll_0_is_0"
        ],
        "statement": "lemma spectrum_perfect:\n  shows \"(A{is in the spectrum of}IsPerf) \\<longleftrightarrow> A=0\"\n",
        "proof": "proof\n  assume \"A{is in the spectrum of}IsPerf\"\n  then have \"Pow(A){is perfect}\" unfolding Spec_def using Pow_is_top by auto\n  then have \"\\<forall>b\\<in>A. {b}\\<notin>Pow(A)\" unfolding IsPerf_def by auto\n  then show \"A=0\" by auto\nnext\n  assume A:\"A=0\"\n  {\n    fix T assume T:\"T{is a topology}\" \"\\<Union>T\\<approx>A\"\n    with T(2) A have \"\\<Union>T\\<approx>0\" by auto\n    then have \"\\<Union>T=0\" using eqpoll_0_is_0 by auto\n    then have \"T{is perfect}\" unfolding IsPerf_def by auto\n  }\n  then show \"A{is in the spectrum of}IsPerf\" unfolding Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2431
    },
    "2192": {
        "type": "lemma",
        "text": "text\\<open>The discrete space is clearly scattered:\\<close>\n",
        "assumes": "",
        "using": [
            "spectrum_perfect",
            "IsScatt_def",
            "antiProperty_def"
        ],
        "statement": "lemma pow_is_scattered:\n  shows \"Pow(A){is scattered}\"\n",
        "proof": "proof-\n  {\n    fix B assume B:\"B\\<subseteq>\\<Union>Pow(A)\" \"(Pow(A){restricted to}B){is perfect}\"\n    from B(1) have \"Pow(A){restricted to}B=Pow(B)\" unfolding RestrictedTo_def by blast\n    with B(2) have \"Pow(B){is perfect}\" by auto\n    then have \"\\<forall>b\\<in>B. {b}\\<notin>Pow(B)\" unfolding IsPerf_def by auto\n    then have \"B=0\" by auto\n  }\n  then show ?thesis using spectrum_perfect unfolding IsScatt_def antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2432
    },
    "2193": {
        "type": "lemma",
        "text": "text\\<open>The spectrum of Luzin spaces is the class of countable sets, so there\nare lots of examples of Luzin spaces.\\<close>\n",
        "assumes": "",
        "using": [
            "empty_lepollI",
            "x",
            "topology0.Top_3_L9",
            "topology0_def",
            "top",
            "tot",
            "topology0.Top_3_L8[of",
            "\"{0,{x},A}\"]",
            "topology0.Top_2_L1",
            "topology0.Top_2_L2",
            "Card_less_csucc_eq_le[OF",
            "Card_nat]",
            "singleton_eqpoll_1",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "lesspoll_imp_lepoll",
            "less_less_imp_un_less[OF",
            "_",
            "InfCard_csucc[OF",
            "InfCard_nat]]",
            "subset_imp_lepoll",
            "lepoll_eq_trans",
            "lepoll_trans"
        ],
        "statement": "lemma spectrum_Luzin:\n  shows \"(A{is in the spectrum of}IsLuzin) \\<longleftrightarrow> A\\<lesssim>nat\"\n",
        "proof": "proof\n  assume A:\"A{is in the spectrum of}IsLuzin\"\n  {\n    assume \"A=0\"\n    then have \"A\\<lesssim>nat\" using empty_lepollI by auto\n  }\n  moreover\n  {\n    assume \"A\\<noteq>0\"\n    then obtain x where x:\"x\\<in>A\" by auto\n    {\n      fix M assume \"M\\<subseteq>{0,{x},A}\"\n      then have \"\\<Union>M\\<in>{0,{x},A}\" using x by blast\n    }\n    moreover\n    {\n      fix U V assume \"U\\<in>{0,{x},A}\" \"V\\<in>{0,{x},A}\"\n      then have \"U\\<inter>V\\<in>{0,{x},A}\" by auto\n    }\n    ultimately have top:\"{0,{x},A}{is a topology}\" unfolding IsATopology_def by auto\n    moreover have tot:\"\\<Union>{0,{x},A}=A\" using x by auto\n    moreover note A ultimately have luz:\"{0,{x},A}{is luzin}\" unfolding Spec_def by auto\n    moreover have \"{x}\\<in>{0,{x},A}\" by auto\n    then have \"((\\<Union>{0,{x},A})-{x}){is closed in}{0,{x},A}\" using topology0.Top_3_L9\n      unfolding topology0_def using top by blast\n    then have \"(A-{x}){is closed in}{0,{x},A}\" using tot by auto\n    then have \"Closure(A-{x},{0,{x},A})=A-{x}\" using tot top topology0.Top_3_L8[of \"{0,{x},A}\"]\n      unfolding topology0_def by auto\n    then have B:\"Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})=Interior(A-{x},{0,{x},A})\" by auto\n    then have C:\"Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})\\<subseteq>A-{x}\" using top topology0.Top_2_L1\n      unfolding topology0_def by auto\n    then have D:\"Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})\\<in>{0,{x},A}\" using topology0.Top_2_L2 \n      unfolding topology0_def using top by auto\n    from x have \"\\<not>(A\\<subseteq>A-{x})\" by auto\n    with C D have \"Interior(Closure(A-{x},{0,{x},A}),{0,{x},A})=0\" by auto\n    then have \"(A-{x}){is nowhere dense in}{0,{x},A}\" unfolding IsNowhereDense_def using tot\n      by auto\n    with luz have \"A-{x}\\<lesssim>nat\" unfolding IsLuzin_def using tot by auto\n    then have U1:\"A-{x}\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n    have \"{x}\\<approx>1\" using singleton_eqpoll_1 by auto\n    then have \"{x}\\<prec>nat\" using n_lesspoll_nat eq_lesspoll_trans by auto\n    then have \"{x}\\<lesssim>nat\" using lesspoll_imp_lepoll by auto\n    then have U2:\"{x}\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n    with U1 have U:\"(A-{x})\\<union>{x}\\<prec>csucc(nat)\" using less_less_imp_un_less[OF _ _ InfCard_csucc[OF InfCard_nat]]\n      by auto\n    have \"(A-{x})\\<union>{x}=A\" using x by auto\n    with U have \"A\\<prec>csucc(nat)\" by auto\n    then have \"A\\<lesssim>nat\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n  }\n  ultimately\n  show \"A\\<lesssim>nat\" by auto\nnext\n  assume A:\"A\\<lesssim>nat\"\n  {\n    fix T assume T:\"T{is a topology}\" \"\\<Union>T\\<approx>A\"\n    {\n      fix B assume \"B\\<subseteq>\\<Union>T\" \"B{is nowhere dense in}T\"\n      then have \"B\\<lesssim>\\<Union>T\" using subset_imp_lepoll by auto\n      with T(2) have \"B\\<lesssim>A\" using lepoll_eq_trans by auto\n      with A have \"B\\<lesssim>nat\" using lepoll_trans by blast\n    }\n    then have \"\\<forall>B\\<in>Pow(\\<Union>T). (B{is nowhere dense in}T) \\<longrightarrow> B\\<lesssim>nat\" by auto\n    then have \"T{is luzin}\" unfolding IsLuzin_def by auto\n  }\n  then show \"A{is in the spectrum of}IsLuzin\" unfolding Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2435
    },
    "2194": {
        "type": "theorem",
        "text": "text\\<open>Every resolvable space is also perfect.\\<close>\n",
        "assumes": "assumes \"T{is resolvable}\"\n  ",
        "using": [
            "Top_3_L9",
            "cl",
            "Top_3_L13"
        ],
        "statement": "theorem (in topology0) resolvable_imp_perfect:\n  assumes \"T{is resolvable}\"\n  shows \"T{is perfect}\"\n",
        "proof": "proof-\n  {\n    assume \"\\<not>(T{is perfect})\"\n    then obtain x where x:\"x\\<in>\\<Union>T\" \"{x}\\<in>T\" unfolding IsPerf_def by auto\n    then have cl:\"(\\<Union>T-{x}){is closed in}T\" using Top_3_L9 by auto\n    from assms obtain U V where UV:\"U\\<subseteq>\\<Union>T\" \"V\\<subseteq>\\<Union>T\" \"cl(U)=\\<Union>T\" \"cl(V)=\\<Union>T\" \"U\\<inter>V=0\" unfolding IsRes_def by auto\n    {\n      fix W assume \"x\\<notin>W\" \"W\\<subseteq>\\<Union>T\"\n      then have \"W\\<subseteq>\\<Union>T-{x}\" by auto\n      then have \"cl(W)\\<subseteq>\\<Union>T-{x}\" using cl Top_3_L13 by auto\n      with x(1) have \"\\<not>(\\<Union>T\\<subseteq>cl(W))\" by auto\n      then have \"\\<not>(cl(W)=\\<Union>T)\" by auto\n    }\n    with UV have \"False\" by auto\n  }\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2436
    },
    "2195": {
        "type": "corollary",
        "text": "text\\<open>The spectrum of being resolvable follows:\\<close>\n",
        "assumes": "",
        "using": [
            "topology0.resolvable_imp_perfect",
            "topology0_def",
            "P_imp_Q_spec_inv[of",
            "IsRes",
            "IsPerf]",
            "spectrum_perfect",
            "eqpoll_0_is_0",
            "topology0.Top_3_L2",
            "T(1)",
            "topology0.Top_3_L8"
        ],
        "statement": "corollary spectrum_resolvable:\n  shows \"(A{is in the spectrum of}IsRes) \\<longleftrightarrow> A=0\"\n",
        "proof": "proof\n  assume A:\"A{is in the spectrum of}IsRes\"\n  have \"\\<forall>T. T{is a topology} \\<longrightarrow> IsRes(T) \\<longrightarrow> IsPerf(T)\" using topology0.resolvable_imp_perfect \n    unfolding topology0_def by auto\n  with A have \"A{is in the spectrum of}IsPerf\" using P_imp_Q_spec_inv[of IsRes IsPerf] by auto\n  then show \"A=0\" using spectrum_perfect by auto\nnext\n  assume A:\"A=0\"\n  {\n    fix T assume T:\"T{is a topology}\" \"\\<Union>T\\<approx>A\"\n    with T(2) A have \"\\<Union>T\\<approx>0\" by auto\n    then have \"\\<Union>T=0\" using eqpoll_0_is_0 by auto\n    then have \"Closure(0,T)=\\<Union>T\" using topology0.Top_3_L2 T(1)\n      topology0.Top_3_L8 unfolding topology0_def by auto\n    then have \"T{is resolvable}\" unfolding IsRes_def by auto\n  }\n  then show \"A{is in the spectrum of}IsRes\" unfolding Spec_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2437
    },
    "2196": {
        "type": "definition",
        "text": "text\\<open> There are several definitions of uniform spaces. \n  The fact that these definitions are equivalent is far from obvious\n  (some people call such phenomenon cryptomorphism). \n  We will use the definition of the uniform structure (or ''uniformity'') \n  based on entourages. This was the original definition by Weil and it seems \n  to be the most commonly used.\n  A uniformity consists of entourages that are binary relations between points of space $X$ \n  that satisfy a certain collection of conditions, specified below. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsUniformity (\"_ {is a uniformity on} _\" 90) where\n    \"\\<Phi> {is a uniformity on} X \\<equiv>(\\<Phi> {is a filter on} (X\\<times>X))\n    \\<and> (\\<forall>U\\<in>\\<Phi>. id(X) \\<subseteq> U \\<and> (\\<exists>V\\<in>\\<Phi>. V O V \\<subseteq> U) \\<and> converse(U) \\<in> \\<Phi>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2440
    },
    "2197": {
        "type": "lemma",
        "text": "text\\<open> If $\\Phi$ is a uniformity on $X$, then the every element $V$ of $\\Phi$ \n  is a certain relation on $X$ (a subset of $X\\times X$) and is called \n  an ''entourage''. For an $x\\in X$ we call $V\\{ x\\}$ a neighborhood of $x$. \n  The first useful fact we will show is that neighborhoods are non-empty. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" and \"x\\<in>X\"\n  ",
        "using": [],
        "statement": "lemma neigh_not_empty: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" and \"x\\<in>X\"\n  shows \"W``{x} \\<noteq> 0\" and \"x \\<in> W``{x}\"\n",
        "proof": "proof -\n  from assms(1,2) have \"id(X) \\<subseteq> W\" \n    unfolding IsUniformity_def IsFilter_def by auto\n  with \\<open>x\\<in>X\\<close> show\" x\\<in>W``{x}\" and \"W``{x} \\<noteq> 0\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2441
    },
    "2198": {
        "type": "lemma",
        "text": "text\\<open>The filter part of the definition of uniformity for easier reference:\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  ",
        "using": [
            "assms",
            "IsUniformity_def"
        ],
        "statement": "lemma unif_filter: assumes \"\\<Phi> {is a uniformity on} X\"\n  shows \"\\<Phi> {is a filter on} (X\\<times>X)\"\n  ",
        "proof": "using assms unfolding IsUniformity_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2442
    },
    "2199": {
        "type": "lemma",
        "text": "text\\<open>The second part of the definition of uniformity for easy reference:\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" and \"A\\<in>\\<Phi>\"\n  ",
        "using": [
            "unif_filter",
            "IsFilter_def"
        ],
        "statement": "lemma entourage_props: \n  assumes \"\\<Phi> {is a uniformity on} X\" and \"A\\<in>\\<Phi>\"\n  shows\n    \"A \\<subseteq> X\\<times>X\"\n    \"id(X) \\<subseteq> A\"\n    \"\\<exists>V\\<in>\\<Phi>. V O V \\<subseteq> A\"\n    \"converse(A) \\<in> \\<Phi>\"\n",
        "proof": "proof -\n  from assms show \"id(X) \\<subseteq> A\" \"\\<exists>V\\<in>\\<Phi>. V O V \\<subseteq> A\" \"converse(A) \\<in> \\<Phi>\"\n    unfolding IsUniformity_def by auto\n  from assms show \"A \\<subseteq> X\\<times>X\"\n    using unif_filter unfolding IsFilter_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2443
    },
    "2200": {
        "type": "lemma",
        "text": "text\\<open>The definition of uniformity states (among other things) that for every member $U$\n  of uniformity $\\Phi$ there is another one, say $V$ such that $V\\circ V\\subseteq U$. Sometimes such $V$\n  is said to be half the size of $U$. The next lemma states that $V$ can be taken to be symmetric. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \n  ",
        "using": [],
        "statement": "lemma half_size_symm: assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \n  shows \"\\<exists>V\\<in>\\<Phi>. V O V \\<subseteq> W \\<and> V=converse(V)\"\n",
        "proof": "proof -\n  from assms obtain U where \"U\\<in>\\<Phi>\" and \"U O U \\<subseteq> W\"\n    unfolding IsUniformity_def by auto\n  let ?V = \"U \\<inter> converse(U)\"\n  from assms(1) \\<open>U\\<in>\\<Phi>\\<close> have \"?V \\<in> \\<Phi>\" and \"?V = converse(?V)\" \n    unfolding IsUniformity_def IsFilter_def by auto\n  moreover from \\<open>U O U \\<subseteq> W\\<close> have \"?V O ?V \\<subseteq> W\" by auto\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2444
    },
    "2201": {
        "type": "lemma",
        "text": "text\\<open>Inside every member $W$ of the uniformity $\\Phi$ we can find one that is symmetric and \n  smaller than a third of size $W$. Compare with the Metamath's theorem with the same name.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"A\\<in>\\<Phi>\"\n  ",
        "using": [
            "half_size_symm",
            "entourage_props(1,2)"
        ],
        "statement": "lemma ustex3sym: assumes \"\\<Phi> {is a uniformity on} X\" \"A\\<in>\\<Phi>\"\n  shows \"\\<exists>B\\<in>\\<Phi>. B O (B O B) \\<subseteq> A \\<and> B=converse(B)\"\n",
        "proof": "proof -\n  from assms obtain C where \"C\\<in>\\<Phi>\" and \"C O C \\<subseteq> A\"\n    unfolding IsUniformity_def by auto\n  from assms(1) \\<open>C\\<in>\\<Phi>\\<close> obtain B where \n    \"B\\<in>\\<Phi>\" \"B O B \\<subseteq> C\" and \"B=converse(B)\"\n    using half_size_symm by blast\n  with \\<open>C O C \\<subseteq> A\\<close> have \"(B O B) O (B O B) \\<subseteq> A\" by blast\n  with assms(1) \\<open>B\\<in>\\<Phi>\\<close> have \"B O (B O B) \\<subseteq> A\"\n    using entourage_props(1,2) by blast\n  with \\<open>B\\<in>\\<Phi>\\<close> \\<open>B=converse(B)\\<close> show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2445
    },
    "2202": {
        "type": "lemma",
        "text": "text\\<open>If $\\Phi$ is a uniformity on $X$ then every element of $\\Phi$ is a subset of $X\\times X$ \n  whose domain is $X$. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \n  ",
        "using": [],
        "statement": "lemma uni_domain: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \n  shows \"W \\<subseteq> X\\<times>X\" and \"domain(W) = X\" \n",
        "proof": "proof -\n  from assms show \"W \\<subseteq> X\\<times>X\" unfolding IsUniformity_def IsFilter_def \n    by blast\n  show \"domain(W) = X\"\n  proof \n    from assms show \"domain(W) \\<subseteq> X\" unfolding IsUniformity_def IsFilter_def \n      by auto\n    from assms show \"X \\<subseteq> domain(W)\" unfolding IsUniformity_def by blast\n  qed\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2446
    },
    "2203": {
        "type": "lemma",
        "text": "text\\<open>If $\\Phi$ is a uniformity on $X$ and $W\\in \\Phi$ the for every $x\\in X$ \n  the image of the singleton $\\{ x\\}$ by $W$ is contained in $X$. Compare\n  the Metamath's theorem with the same name. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "uni_domain(1)"
        ],
        "statement": "lemma ustimasn: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" and \"x\\<in>X\"\n  shows \"W``{x} \\<subseteq> X\"\n  ",
        "proof": "using assms uni_domain(1) by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2447
    },
    "2204": {
        "type": "lemma",
        "text": "text\\<open> Uniformity \\<open>\\<Phi>\\<close>  defines a natural topology on its space $X$ via the neighborhood system \n  that assigns the collection $\\{V(\\{x\\}):V\\in \\Phi\\}$ to every point $x\\in X$. \n  In the next lemma we show that if we define a function\n  this way the values of that function are what they should be. This is only a technical\n  fact which is useful to shorten the remaining proofs, usually treated as obvious in standard\n  mathematics. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  defines \"\\<M> \\<equiv> {\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>.x\\<in>X}\"\n  ",
        "using": [
            "IsUniformity_def",
            "IsFilter_def",
            "image_subset",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma neigh_filt_fun: \n  assumes \"\\<Phi> {is a uniformity on} X\"\n  defines \"\\<M> \\<equiv> {\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>.x\\<in>X}\"\n  shows \"\\<M>:X\\<rightarrow>Pow(Pow(X))\" and \"\\<forall>x\\<in>X. \\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>x\\<in>X. {V``{x}.V\\<in>\\<Phi>} \\<in> Pow(Pow(X))\" \n    using IsUniformity_def IsFilter_def image_subset by auto\n  with assms show \"\\<M>:X\\<rightarrow>Pow(Pow(X))\" using ZF_fun_from_total by simp\n  with assms show \"\\<forall>x\\<in>X. \\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\" using ZF_fun_from_tot_val\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2448
    },
    "2205": {
        "type": "lemma",
        "text": "text\\<open> In the next lemma we show that the collection defined in lemma \\<open>neigh_filt_fun\\<close> is a filter on $X$.\n   The proof is kind of long, but it just checks that all filter conditions hold.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" and \"x\\<in>X\"\n  defines \"\\<M> \\<equiv> {\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>.x\\<in>X}\" \n  ",
        "using": [
            "IsUniformity_def",
            "neigh_filt_fun",
            "neigh_not_empty",
            "apply_funtype",
            "IsFilter_def",
            "image_greater_rel",
            "image_Int_subset_left"
        ],
        "statement": "lemma filter_from_uniformity: \n  assumes \"\\<Phi> {is a uniformity on} X\" and \"x\\<in>X\"\n  defines \"\\<M> \\<equiv> {\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>.x\\<in>X}\" \n  shows \"\\<M>`(x) {is a filter on} X\"\n",
        "proof": "proof -\n  from assms have PhiFilter: \"\\<Phi> {is a filter on} (X\\<times>X)\" and \n    \"\\<M>:X\\<rightarrow>Pow(Pow(X))\" and \"\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\"\n    using IsUniformity_def neigh_filt_fun by auto\n  have \"0 \\<notin> \\<M>`(x)\"\n  proof -\n    from assms \\<open>x\\<in>X\\<close> have \"0 \\<notin> {V``{x}.V\\<in>\\<Phi>}\" using neigh_not_empty by blast  \n    with \\<open>\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\\<close> show \"0 \\<notin> \\<M>`(x)\" by simp \n  qed\n  moreover have \"X \\<in> \\<M>`(x)\"\n  proof -\n    note \\<open>\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\\<close> \n    moreover from assms have \"X\\<times>X \\<in> \\<Phi>\" unfolding IsUniformity_def IsFilter_def \n      by blast\n    hence \"(X\\<times>X)``{x} \\<in> {V``{x}.V\\<in>\\<Phi>}\" by auto\n    moreover from \\<open>x\\<in>X\\<close> have \"(X\\<times>X)``{x} = X\" by auto\n    ultimately show \"X \\<in> \\<M>`(x)\" by simp \n  qed\n  moreover from \\<open>\\<M>:X\\<rightarrow>Pow(Pow(X))\\<close> \\<open>x\\<in>X\\<close> have \"\\<M>`(x) \\<subseteq> Pow(X)\" using apply_funtype\n    by blast\n  moreover have LargerIn: \"\\<forall>B \\<in> \\<M>`(x). \\<forall>C \\<in> Pow(X). B\\<subseteq>C \\<longrightarrow> C \\<in> \\<M>`(x)\"\n  proof -\n  { fix B assume \"B \\<in> \\<M>`(x)\"\n    fix C assume \"C \\<in> Pow(X)\" and \"B\\<subseteq>C\"\n    from \\<open>\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\\<close> \\<open>B \\<in> \\<M>`(x)\\<close> obtain U where\n         \"U\\<in>\\<Phi>\" and \"B = U``{x}\" by auto \n    let ?V = \"U \\<union> C\\<times>C\"\n    from assms \\<open>U\\<in>\\<Phi>\\<close> \\<open>C \\<in> Pow(X)\\<close> have \"?V \\<in> Pow(X\\<times>X)\" and \"U\\<subseteq>?V\" \n      using IsUniformity_def IsFilter_def by auto\n    with \\<open>U\\<in>\\<Phi>\\<close> PhiFilter have \"?V\\<in>\\<Phi>\" using IsFilter_def by simp\n    moreover from assms \\<open>U\\<in>\\<Phi>\\<close> \\<open>x\\<in>X\\<close> \\<open>B = U``{x}\\<close> \\<open>B\\<subseteq>C\\<close> have \"C = ?V``{x}\"\n      using neigh_not_empty image_greater_rel by simp  \n    ultimately have \"C \\<in> {V``{x}.V\\<in>\\<Phi>}\" by auto \n    with \\<open>\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\\<close> have \"C \\<in> \\<M>`(x)\" by simp\n  } thus ?thesis by blast\n  qed\n  moreover have \"\\<forall>A \\<in> \\<M>`(x).\\<forall>B \\<in> \\<M>`(x). A\\<inter>B \\<in> \\<M>`(x)\"\n  proof -\n  { fix A B assume \"A \\<in> \\<M>`(x)\" and \"B \\<in> \\<M>`(x)\"\n    with \\<open>\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\\<close> obtain V\\<^sub>A V\\<^sub>B where\n      \"A = V\\<^sub>A``{x}\" \"B = V\\<^sub>B``{x}\" and  \"V\\<^sub>A \\<in> \\<Phi>\" \"V\\<^sub>B \\<in> \\<Phi>\"\n      by auto \n    let ?C = \"V\\<^sub>A``{x} \\<inter> V\\<^sub>B``{x}\"\n    from assms \\<open>V\\<^sub>A \\<in> \\<Phi>\\<close> \\<open>V\\<^sub>B \\<in> \\<Phi>\\<close> have \"V\\<^sub>A\\<inter>V\\<^sub>B \\<in> \\<Phi>\" using IsUniformity_def IsFilter_def \n      by simp\n    with \\<open>\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\\<close> have \"(V\\<^sub>A\\<inter>V\\<^sub>B)``{x} \\<in> \\<M>`(x)\" by auto\n    moreover from PhiFilter \\<open>V\\<^sub>A \\<in> \\<Phi>\\<close> \\<open>V\\<^sub>B \\<in> \\<Phi>\\<close> have \"?C \\<in> Pow(X)\" unfolding IsFilter_def\n            by auto \n    moreover have \"(V\\<^sub>A\\<inter>V\\<^sub>B)``{x} \\<subseteq> ?C\" using image_Int_subset_left by simp\n    moreover note LargerIn\n    ultimately have \"?C \\<in> \\<M>`(x)\" by simp\n    with \\<open>A = V\\<^sub>A``{x}\\<close> \\<open>B = V\\<^sub>B``{x}\\<close> have \"A\\<inter>B \\<in> \\<M>`(x)\" by blast\n  } thus ?thesis by simp\n  qed\n  ultimately show ?thesis unfolding IsFilter_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2449
    },
    "2206": {
        "type": "corollary",
        "text": "text\\<open>A frequently used property of filters is that they are \"upward closed\" i.e.  supersets \n  of a filter element are also in the filter. The next lemma makes this explicit\n  for easy reference as applied to the natural filter created from a uniformity.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"x\\<in>X\" \"U \\<in> {V``{x}. V\\<in>\\<Phi>}\" \"W\\<subseteq>X\" \"U\\<subseteq>W\"\n  ",
        "using": [
            "assms",
            "filter_from_uniformity",
            "ZF_fun_from_tot_val1",
            "IsFilter_def"
        ],
        "statement": "corollary unif_filter_up_closed: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"x\\<in>X\" \"U \\<in> {V``{x}. V\\<in>\\<Phi>}\" \"W\\<subseteq>X\" \"U\\<subseteq>W\"\n  shows \"W \\<in> {V``{x}.V\\<in>\\<Phi>}\"\n  ",
        "proof": "using assms filter_from_uniformity ZF_fun_from_tot_val1\n  unfolding IsFilter_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2451
    },
    "2207": {
        "type": "theorem",
        "text": "text\\<open> The function defined in the premises of lemma \\<open>neigh_filt_fun\\<close>\n  (or \\<open>filter_from_uniformity\\<close>) is a neighborhood system. The proof uses the existence\n  of the \"half-the-size\" neighborhood condition (\\<open>\\<exists>V\\<in>\\<Phi>. V O V \\<subseteq> U\\<close>) of the uniformity definition, \n  but not the \\<open>converse(U) \\<in> \\<Phi>\\<close> part. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  ",
        "using": [
            "IsUniformity_def",
            "neigh_filt_fun",
            "filter_from_uniformity",
            "neigh_not_empty",
            "apply_funtype"
        ],
        "statement": "theorem neigh_from_uniformity: \n  assumes \"\\<Phi> {is a uniformity on} X\"\n  shows \"{\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>.x\\<in>X} {is a neighborhood system on} X\"\n",
        "proof": "proof -\n  let ?\\<M> = \"{\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>.x\\<in>X}\"\n  from assms have \"?\\<M>:X\\<rightarrow>Pow(Pow(X))\" and Mval: \"\\<forall>x\\<in>X. ?\\<M>`(x) = {V``{x}.V\\<in>\\<Phi>}\"\n    using IsUniformity_def neigh_filt_fun by auto \n  moreover from assms have \"\\<forall>x\\<in>X. (?\\<M>`(x) {is a filter on} X)\" using filter_from_uniformity\n    by simp\n  moreover \n  { fix x assume \"x\\<in>X\"\n    have \"\\<forall>N\\<in>?\\<M>`(x). x\\<in>N \\<and> (\\<exists>U\\<in>?\\<M>`(x).\\<forall>y\\<in>U.(N\\<in>?\\<M>`(y)))\"\n    proof -\n      { fix N assume \"N\\<in>?\\<M>`(x)\"\n        have \"x\\<in>N\" and \"\\<exists>U\\<in>?\\<M>`(x).\\<forall>y\\<in>U.(N \\<in> ?\\<M>`(y))\"\n        proof -\n          from \\<open>?\\<M>:X\\<rightarrow>Pow(Pow(X))\\<close> Mval \\<open>x\\<in>X\\<close> \\<open>N\\<in>?\\<M>`(x)\\<close> \n          obtain U where \"U\\<in>\\<Phi>\" and \"N = U``{x}\" by auto \n          with assms \\<open>x\\<in>X\\<close> show \"x\\<in>N\" using neigh_not_empty by simp\n          from assms \\<open>U\\<in>\\<Phi>\\<close> obtain V where \"V\\<in>\\<Phi>\"  and  \"V O V \\<subseteq> U\" \n            unfolding IsUniformity_def by auto\n          let ?W = \"V``{x}\"\n          from \\<open>V\\<in>\\<Phi>\\<close> Mval \\<open>x\\<in>X\\<close> have \"?W \\<in> ?\\<M>`(x)\" by auto\n          moreover have \"\\<forall>y\\<in>?W. N \\<in> ?\\<M>`(y)\"\n          proof -\n            { fix y assume \"y\\<in>?W\"\n              with \\<open>?\\<M>:X\\<rightarrow>Pow(Pow(X))\\<close> \\<open>x\\<in>X\\<close> \\<open>?W \\<in> ?\\<M>`(x)\\<close> have \"y\\<in>X\" \n                using apply_funtype by blast\n              with assms have \"?\\<M>`(y) {is a filter on} X\" using filter_from_uniformity\n                by simp\n              moreover from assms \\<open>y\\<in>X\\<close> \\<open>V\\<in>\\<Phi>\\<close> have \"V``{y} \\<in> ?\\<M>`(y)\" \n                using neigh_filt_fun by auto      \n              moreover from \\<open>?\\<M>:X\\<rightarrow>Pow(Pow(X))\\<close> \\<open>x\\<in>X\\<close> \\<open>N \\<in> ?\\<M>`(x)\\<close> have \"N \\<in> Pow(X)\" \n                using apply_funtype by blast \n              moreover from \\<open>V O V \\<subseteq> U\\<close> \\<open>y\\<in>?W\\<close> have \n                \"V``{y} \\<subseteq> (V O V)``{x}\" and \"(V O V)``{x} \\<subseteq> U``{x}\"\n                by auto \n              with \\<open>N = U``{x}\\<close>  have \"V``{y} \\<subseteq> N\" by blast\n              ultimately have \"N \\<in> ?\\<M>`(y)\" unfolding IsFilter_def by simp\n            } thus ?thesis by simp \n          qed\n          ultimately show \"\\<exists>U\\<in>?\\<M>`(x).\\<forall>y\\<in>U.(N \\<in> ?\\<M>`(y))\" by auto\n        qed\n      } thus ?thesis by simp\n    qed \n  }   \n  ultimately show ?thesis unfolding IsNeighSystem_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2452
    },
    "2208": {
        "type": "definition",
        "text": "text\\<open> When we have a uniformity $\\Phi$ on $X$ we can define a topology on $X$ in a (relatively)\n  natural way. We will call that topology the \\<open> UniformTopology(\\<Phi>)\\<close>.\n  We could probably reformulate the definition to skip \n  the $X$ parameter because if $\\Phi$ is a uniformity on $X$ then $X$ can be recovered \n  from (is determined by) $\\Phi$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"UniformTopology(\\<Phi>,X) \\<equiv> {U\\<in>Pow(X). \\<forall>x\\<in>U. U\\<in>{V``{x}. V\\<in>\\<Phi>}}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2453
    },
    "2209": {
        "type": "lemma",
        "text": "text\\<open>An identity showing how the definition of uniform topology is constructed.\n  Here, the $M = \\{\\langle t,\\{ V\\{ t\\} : V\\in \\Phi\\}\\rangle : t\\in X\\}$ is the neighborhood system\n  (a function on $X$) created from uniformity $\\Phi$. \n  Then for each $x\\in X$, $M(x) = \\{ V\\{ t\\} : V\\in \\Phi\\}$ is the set of neighborhoods of $x$. \\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma uniftop_def_alt: \n  shows \"UniformTopology(\\<Phi>,X) = {U \\<in> Pow(X). \\<forall>x\\<in>U. U \\<in> {\\<langle>t,{V``{t}.V\\<in>\\<Phi>}\\<rangle>.t\\<in>X}`(x)}\"\n",
        "proof": "proof -\n  let ?\\<M> = \"{\\<langle>x,{V``{x}. V\\<in>\\<Phi>}\\<rangle>. x\\<in>X}\"\n  have \"\\<forall>U\\<in>Pow(X).\\<forall>x\\<in>U. ?\\<M>`(x) = {V``{x}. V\\<in>\\<Phi>}\"\n    using ZF_fun_from_tot_val1 by auto\n  then show ?thesis unfolding UniformTopology_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2454
    },
    "2210": {
        "type": "theorem",
        "text": "text\\<open> The collection of sets constructed in the \\<open> UniformTopology \\<close> definition\n  is indeed a topology on $X$. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  ",
        "using": [
            "assms",
            "neigh_from_uniformity",
            "uniftop_def_alt",
            "topology_from_neighs"
        ],
        "statement": "theorem uniform_top_is_top:\n  assumes \"\\<Phi> {is a uniformity on} X\"\n  shows \n  \"UniformTopology(\\<Phi>,X) {is a topology}\" and \"\\<Union> UniformTopology(\\<Phi>,X) = X\"\n  ",
        "proof": "using assms neigh_from_uniformity uniftop_def_alt topology_from_neighs\n  by auto \n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2455
    },
    "2211": {
        "type": "theorem",
        "text": "text\\<open>If we have a uniformity $\\Phi$ we can create a neighborhood system from it in two ways.\n  We can create a a neighborhood system directly from $\\Phi$ using the formula \n  $X \\ni x \\mapsto \\{V\\{x\\} | x\\in X\\}$ (see theorem \\<open>neigh_from_uniformity\\<close>).\n  Alternatively we can construct a topology from $\\Phi$ as in theorem \n  \\<open>uniform_top_is_top\\<close> and then create a neighborhood system from this topology\n  as in theorem \\<open>neigh_from_topology\\<close>. The next theorem states that these two ways give the same \n  result. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  ",
        "using": [
            "assms",
            "neigh_from_uniformity",
            "nei_top_nei_round_trip",
            "uniftop_def_alt"
        ],
        "statement": "theorem neigh_unif_same: assumes \"\\<Phi> {is a uniformity on} X\"\n  shows \n    \"{\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>. x\\<in>X} = {neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  ",
        "proof": "using assms neigh_from_uniformity nei_top_nei_round_trip uniftop_def_alt\n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2456
    },
    "2212": {
        "type": "lemma",
        "text": "text\\<open>Another form of the definition of topology generated from a uniformity.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  ",
        "using": [
            "unif_filter_at_point",
            "is_filter_def_split(5)"
        ],
        "statement": "lemma uniftop_def_alt1: assumes \"\\<Phi> {is a uniformity on} X\"\n  shows \"UniformTopology(\\<Phi>,X) = {U\\<in>Pow(X).  \\<forall>x\\<in>U. \\<exists>W\\<in>\\<Phi>. W``{x} \\<subseteq> U}\"\n",
        "proof": "proof\n  let ?T = \"UniformTopology(\\<Phi>,X)\"\n  show \"?T \\<subseteq> {U\\<in>Pow(X).  \\<forall>x\\<in>U. \\<exists>W\\<in>\\<Phi>. W``{x} \\<subseteq> U}\"\n    unfolding UniformTopology_def by auto\n  { fix U assume \"U\\<in>{U\\<in>Pow(X).  \\<forall>x\\<in>U. \\<exists>W\\<in>\\<Phi>. W``{x} \\<subseteq> U}\"\n    then have \"U\\<in>Pow(X)\" and I: \"\\<forall>x\\<in>U. \\<exists>W\\<in>\\<Phi>. W``{x} \\<subseteq> U\" by auto\n    { fix x assume \"x\\<in>U\"\n      with I obtain W where \"W\\<in>\\<Phi>\" and \"W``{x} \\<subseteq> U\"\n        by auto\n      let ?\\<FF> = \"{V``{x}.V\\<in>\\<Phi>}\"\n      from assms(1) \\<open>U\\<in>Pow(X)\\<close> \\<open>x\\<in>U\\<close> \\<open>W\\<in>\\<Phi>\\<close> have \n        \"?\\<FF> {is a filter on} X\" and \"W``{x} \\<in> ?\\<FF>\"\n        using unif_filter_at_point by auto\n      with \\<open>U\\<in>Pow(X)\\<close> \\<open>W``{x} \\<subseteq> U\\<close> have \"U\\<in>?\\<FF>\"\n        using is_filter_def_split(5) by blast\n    } hence \"\\<forall>x\\<in>U. U \\<in> {V``{x}.V\\<in>\\<Phi>}\" by simp\n    with \\<open>U\\<in>Pow(X)\\<close> have \"U\\<in>?T\"\n      unfolding UniformTopology_def by simp\n  } thus \"{U\\<in>Pow(X).  \\<forall>x\\<in>U. \\<exists>W\\<in>\\<Phi>. W``{x} \\<subseteq> U} \\<subseteq> ?T\"\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2457
    },
    "2213": {
        "type": "lemma",
        "text": "text\\<open>Images of singletons by entourages are neighborhoods of those singletons.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"V\\<in>\\<Phi>\" \"x\\<in>X\"\n  defines \"\\<M> \\<equiv> {neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  ",
        "using": [
            "neigh_unif_same",
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma image_singleton_ent_nei: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"V\\<in>\\<Phi>\" \"x\\<in>X\"\n  defines \"\\<M> \\<equiv> {neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  shows \"V``{x} \\<in> \\<M>`(x)\"\n",
        "proof": "proof -\n  from assms(1,4) have \"\\<M> = {\\<langle>x,{V``{x}.V\\<in>\\<Phi>}\\<rangle>. x\\<in>X}\"\n    using neigh_unif_same by simp\n  with assms(2,3) show ?thesis\n    using ZF_fun_from_tot_val1 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2458
    },
    "2214": {
        "type": "lemma",
        "text": "text\\<open>The set neighborhoods of a singleton $\\{ x\\}$ where $x\\in X$ consist\n  of images of the singleton by the entourages $W\\in \\Phi$. \n  See also the Metamath's theorem with the same name. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"x\\<in>X\"\n  defines \"\\<S> \\<equiv> {set neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  ",
        "using": [
            "uniform_top_is_top(2)",
            "neigh_from_nei",
            "neigh_unif_same",
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma utopsnneip: assumes \"\\<Phi> {is a uniformity on} X\" \"x\\<in>X\"\n  defines \"\\<S> \\<equiv> {set neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  shows \"\\<S>`{x} = {W``{x}. W\\<in>\\<Phi>}\"\n",
        "proof": "proof -\n  let ?T = \"UniformTopology(\\<Phi>,X)\"\n  let ?\\<M> = \"{neighborhood system of} ?T\"\n  from assms(1,2) have \"x \\<in> \\<Union>?T\"\n    using uniform_top_is_top(2) by simp\n  with assms(3) have \"?\\<M>`(x) = \\<S>`{x}\"\n    using neigh_from_nei by simp\n  moreover \n  from assms(1) have \"?\\<M> = {\\<langle>x,{W``{x}.W\\<in>\\<Phi>}\\<rangle>. x\\<in>X}\"\n    using neigh_unif_same by simp\n  with assms(2) have \"?\\<M>`(x) =  {W``{x}.W\\<in>\\<Phi>}\"\n    using ZF_fun_from_tot_val1 by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2459
    },
    "2215": {
        "type": "corollary",
        "text": "text\\<open>Images of singletons by entourages are set neighborhoods of those singletons.\n  See also the Metamath theorem with the same name.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \"x\\<in>X\"\n  defines \"\\<S> \\<equiv> {set neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  ",
        "using": [
            "assms",
            "utopsnneip"
        ],
        "statement": "corollary utopsnnei: assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \"x\\<in>X\"\n  defines \"\\<S> \\<equiv> {set neighborhood system of} UniformTopology(\\<Phi>,X)\"\n  shows \"W``{x} \\<in> \\<S>`{x}\" ",
        "proof": "using assms utopsnneip by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2460
    },
    "2216": {
        "type": "lemma",
        "text": "text\\<open>If $\\Phi$ is a uniformity on $X$ that generates a topology $T$, $R$ is any relation\n  on $X$ (i.e. $R\\subseteq X\\times X$), $W$ is a symmetric entourage (i.e. $W\\in \\Phi$,\n  and $W$ is symmetric (i.e. equal to its converse)), then the closure of $R$ in the product topology\n  is contained the the composition $V\\circ (M \\circ V)$. \n  Metamath has a similar theorem with the same name.  \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"R\\<subseteq>X\\<times>X\" \"W\\<in>\\<Phi>\" \"W=converse(W)\"\n  defines \"J \\<equiv> UniformTopology(\\<Phi>,X)\"\n  ",
        "using": [
            "uniform_top_is_top",
            "Top_1_4_T1(1,3)",
            "topology0.Top_3_L11(1)",
            "utopsnnei",
            "neitx",
            "neindisj",
            "sym_rel_comp"
        ],
        "statement": "lemma utop3cls: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"R\\<subseteq>X\\<times>X\" \"W\\<in>\\<Phi>\" \"W=converse(W)\"\n  defines \"J \\<equiv> UniformTopology(\\<Phi>,X)\"\n  shows \"Closure(R,J\\<times>\\<^sub>tJ) \\<subseteq> W O (R O W)\"\n",
        "proof": "proof\n  let ?M = \"{set neighborhood system of} (J\\<times>\\<^sub>tJ)\"\n  fix z assume zMem: \"z \\<in> Closure(R,J\\<times>\\<^sub>tJ)\"\n  from assms(1,5) have Jtop: \"J {is a topology}\" and \"\\<Union>J = X\"\n    using uniform_top_is_top by auto\n  then have JJtop: \"(J\\<times>\\<^sub>tJ) {is a topology}\" and JxJ: \"\\<Union>(J\\<times>\\<^sub>tJ) = X\\<times>X\"\n    using Top_1_4_T1(1,3) by auto\n  with assms(2) have \"topology0(J\\<times>\\<^sub>tJ)\" and \"R \\<subseteq> \\<Union>(J\\<times>\\<^sub>tJ)\"\n    unfolding topology0_def by auto\n  then have \"Closure(R,J\\<times>\\<^sub>tJ) \\<subseteq> \\<Union>(J\\<times>\\<^sub>tJ)\"\n    using topology0.Top_3_L11(1) by simp\n  with \\<open>z \\<in> Closure(R,J\\<times>\\<^sub>tJ)\\<close> JxJ have \"z\\<in>X\\<times>X\" by auto\n  let ?x = \"fst(z)\"\n  let ?y = \"snd(z)\"\n  from \\<open>z\\<in>X\\<times>X\\<close> have \"?x\\<in>X\" \"?y\\<in>X\" \"z = \\<langle>?x,?y\\<rangle>\" by auto\n  with assms(1,3,5) Jtop have \"(W``{?x})\\<times>(W``{?y}) \\<in> ?M`({?x}\\<times>{?y})\"\n    using utopsnnei neitx by simp\n  moreover from \\<open>z = \\<langle>?x,?y\\<rangle>\\<close> have \"{?x}\\<times>{?y} = {z}\" \n    by (rule pair_prod)\n  ultimately have \"(W``{?x})\\<times>(W``{?y}) \\<in> ?M`{z}\" by simp\n  with zMem JJtop \\<open>R \\<subseteq> \\<Union>(J\\<times>\\<^sub>tJ)\\<close> have \"(W``{?x})\\<times>(W``{?y}) \\<inter> R \\<noteq> 0\" \n    using neindisj by blast\n  with assms(4) have \"\\<langle>?x,?y\\<rangle> \\<in> W O (R O W)\" \n    using sym_rel_comp by simp\n  with \\<open>z = \\<langle>?x,?y\\<rangle>\\<close> show \"z \\<in> W O (R O W)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2461
    },
    "2217": {
        "type": "theorem",
        "text": "text\\<open>Uniform spaces are regular ($T_3$). \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\"\n  ",
        "using": [
            "uniform_top_is_top",
            "topology0_def",
            "open_nei_singl",
            "utopsnneip",
            "ustex3sym",
            "utopsnnei",
            "ustimasn",
            "entourage_props(1)",
            "topology0.top_closure_mono",
            "imasncls",
            "utop3cls",
            "is_regular_def_alt"
        ],
        "statement": "theorem utopreg: \n  assumes \"\\<Phi> {is a uniformity on} X\"\n  shows \"UniformTopology(\\<Phi>,X) {is regular}\"\n",
        "proof": "proof -\n  let ?J = \"UniformTopology(\\<Phi>,X)\"\n  let ?\\<S> = \"{set neighborhood system of} ?J\"\n  from assms have \"\\<Union>?J = X\"\n    and Jtop: \"?J {is a topology}\" and cntx: \"topology0(?J)\"\n    using uniform_top_is_top unfolding topology0_def by auto \n  have \"\\<forall>U\\<in>?J. \\<forall>x\\<in>U. \\<exists>V\\<in>?J. x\\<in>V \\<and> Closure(V,?J)\\<subseteq>U\"\n  proof -\n    { fix U x assume \"U\\<in>?J\" \"x\\<in>U\"\n      then have \"U \\<in> ?\\<S>`{x}\" using open_nei_singl by simp\n      from \\<open>U\\<in>?J\\<close> have \"U\\<subseteq>\\<Union>?J\" by auto\n      with \\<open>x\\<in>U\\<close> \\<open>\\<Union>?J = X\\<close> have \"x\\<in>X\" by auto\n      from assms(1) \\<open>x\\<in>X\\<close> \\<open>U \\<in> ?\\<S>`{x}\\<close> obtain A \n        where \"U=A``{x}\" and \"A\\<in>\\<Phi>\"\n        using utopsnneip by auto\n      from assms(1) \\<open>A\\<in>\\<Phi>\\<close> obtain W where \n        \"W\\<in>\\<Phi>\" \"W O (W O W) \\<subseteq> A\" and Wsymm: \"W=converse(W)\"\n        using ustex3sym by blast\n      with assms(1) \\<open>x\\<in>X\\<close> have \"W``{x} \\<in> ?\\<S>`{x}\" and \"W``{x} \\<subseteq> X\"\n        using utopsnnei ustimasn by auto\n      from \\<open>W``{x} \\<in> ?\\<S>`{x}\\<close> have \"\\<exists>V\\<in>?J. {x}\\<subseteq>V \\<and> V\\<subseteq>W``{x}\"\n        by (rule neii2)\n      then obtain V where \"V\\<in>?J\" \"x\\<in>V\" \"V\\<subseteq>W``{x}\"\n        by blast\n      have \"Closure(V,?J) \\<subseteq> U\"\n      proof -\n        from assms(1) \\<open>W\\<in>\\<Phi>\\<close> \\<open>\\<Union>?J = X\\<close> have \"W \\<subseteq> X\\<times>X\"\n          using entourage_props(1) by simp\n        from cntx \\<open>W``{x} \\<subseteq> X\\<close> \\<open>\\<Union>?J = X\\<close> \\<open>V\\<subseteq>W``{x}\\<close>\n          have \"Closure(V,?J) \\<subseteq> Closure(W``{x},?J)\"\n            using topology0.top_closure_mono by simp\n        also have \"Closure(W``{x},?J) \\<subseteq> Closure(W,?J\\<times>\\<^sub>t?J)``{x}\"\n        proof -\n          from \\<open>W\\<subseteq>X\\<times>X\\<close> \\<open>x\\<in>X\\<close> \\<open>\\<Union>?J = X\\<close> \n            have \"W\\<subseteq>(\\<Union>?J)\\<times>(\\<Union>?J)\" \"x\\<in>\\<Union>?J\" by auto\n          with \\<open>?J {is a topology}\\<close> show ?thesis \n            using imasncls by simp\n        qed\n        also from assms(1) \\<open>W\\<subseteq>X\\<times>X\\<close> \\<open>W\\<in>\\<Phi>\\<close> Wsymm \\<open>W O (W O W) \\<subseteq> A\\<close>\n          have \"Closure(W,?J\\<times>\\<^sub>t?J)``{x} \\<subseteq> A``{x}\"\n            using utop3cls by blast\n        finally have \"Closure(V,?J) \\<subseteq> A``{x}\"\n          by simp\n        with \\<open>U=A``{x}\\<close> show ?thesis by auto\n      qed\n      with \\<open>V\\<in>?J\\<close> \\<open>x\\<in>V\\<close> have \"\\<exists>V\\<in>?J. x\\<in>V \\<and> Closure(V,?J)\\<subseteq>U\" \n        by blast\n    } thus ?thesis by simp\n  qed\n  with Jtop show \"?J {is regular}\" using is_regular_def_alt\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2462
    },
    "2218": {
        "type": "definition",
        "text": "text\\<open> A map between 2 uniformities is uniformly continuous if it preserves\nthe entourages: \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsUniformlyCont (\"_ {is uniformly continuous between} _ {and} _\" 90) where\n  \"f:X\\<rightarrow>Y \\<Longrightarrow> \\<Phi> {is a uniformity on} X  \\<Longrightarrow> \\<Gamma> {is a uniformity on} Y \\<Longrightarrow> \n  f {is uniformly continuous between} \\<Phi> {and} \\<Gamma> \\<equiv> \\<forall>V\\<in>\\<Gamma>. (ProdFunction(f,f)-``V) \\<in> \\<Phi>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.UniformSpace_ZF",
            "IsarMathLib.Topology_ZF_2"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_1.thy",
        "id": 2463
    },
    "2219": {
        "type": "definition",
        "text": "text\\<open> The set of all covers of $X$ is called \\<open>Covers(X)\\<close>. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  \"Covers(X) \\<equiv> {P \\<in> Pow(Pow(X)). \\<Union>P = X}\" \n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2465
    },
    "2220": {
        "type": "lemma",
        "text": "text\\<open>A cover of a nonempty set must have a nonempty member.\\<close>\n",
        "assumes": "assumes \"X\\<noteq>0\" \"P \\<in> Covers(X)\"\n  ",
        "using": [
            "assms",
            "Covers_def"
        ],
        "statement": "lemma cover_nonempty: assumes \"X\\<noteq>0\" \"P \\<in> Covers(X)\"\n  shows \"\\<exists>U\\<in>P. U\\<noteq>0\"\n  ",
        "proof": "using assms unfolding Covers_def by blast  \n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2466
    },
    "2221": {
        "type": "definition",
        "text": "text\\<open> A \"star\" of $R$ with respect to $\\mathcal{R}$ is the union of all $S\\in \\mathcal{R}$ that\n  intersect $R$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Star(R,\\<R>) \\<equiv> \\<Union>{S\\<in>\\<R>. S\\<inter>R \\<noteq> 0}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2467
    },
    "2222": {
        "type": "lemma",
        "text": "text\\<open>An element of $\\mathcal{R}$ is a subset of its star with respect to $\\mathcal{R}$. \\<close>\n",
        "assumes": "assumes \"U\\<in>P\" ",
        "using": [
            "assms",
            "Star_def"
        ],
        "statement": "lemma element_subset_star: assumes \"U\\<in>P\" shows \"U \\<subseteq> Star(U,P)\"\n  ",
        "proof": "using assms unfolding Star_def by auto\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2468
    },
    "2223": {
        "type": "lemma",
        "text": "text\\<open>An alternative formula for star of a singleton.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma star_singleton: shows \"(\\<Union>{V\\<times>V. V\\<in>P})``{x} = Star({x},P)\"\n  unfolding Star_def by blast\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2469
    },
    "2224": {
        "type": "lemma",
        "text": "text\\<open>Star of a larger set is larger.\\<close>\n",
        "assumes": "assumes \"U\\<subseteq>V\" ",
        "using": [
            "assms",
            "Star_def"
        ],
        "statement": "lemma star_mono: assumes \"U\\<subseteq>V\" shows \"Star(U,P) \\<subseteq> Star(V,P)\"\n  ",
        "proof": "using assms unfolding Star_def by blast\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2470
    },
    "2225": {
        "type": "corollary",
        "text": "text\\<open>In particular, star of a set is larger than star of any singleton in that set.\\<close>\n",
        "assumes": "assumes \"x\\<in>U\" ",
        "using": [
            "assms",
            "star_mono"
        ],
        "statement": "corollary star_single_mono: assumes \"x\\<in>U\" shows \"Star({x},P) \\<subseteq> Star(U,P)\"\n  ",
        "proof": "using assms star_mono by auto\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2471
    },
    "2226": {
        "type": "definition",
        "text": "text\\<open>A cover $\\mathcal{R}$ (of $X$) is said to be a \"barycentric refinement\" of a cover $\\mathcal{C}$ \n  iff for every $x\\in X$ the star of $\\{x\\}$ in $\\mathcal{R}$ is contained \n  in some $C\\in \\mathcal{C}$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsBarycentricRefinement (\"_ <\\<^sup>B _\" 90) \n  where \"P <\\<^sup>B Q \\<equiv> \\<forall>x\\<in>\\<Union>P.\\<exists>U\\<in>Q.  Star({x},P) \\<subseteq> U\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2472
    },
    "2227": {
        "type": "lemma",
        "text": "text\\<open>A cover is a barycentric refinement of the collection of stars of the singletons\n  $\\{x \\}$ as $x$ ranges over $X$.\\<close>\n",
        "assumes": "assumes \"P \\<in> Covers(X)\" ",
        "using": [
            "assms",
            "Covers_def",
            "IsBarycentricRefinement_def"
        ],
        "statement": "lemma singl_star_bary: \n  assumes \"P \\<in> Covers(X)\" shows \"P <\\<^sup>B {Star({x},P). x\\<in>X}\"\n  ",
        "proof": "using assms unfolding Covers_def IsBarycentricRefinement_def by blast    \n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2473
    },
    "2228": {
        "type": "definition",
        "text": "text\\<open> A cover $\\mathcal{R}$ is a \"star refinement\" of a cover $\\mathcal{C}$  iff \n  for each $R\\in \\mathcal{R}$ there is a $C\\in \\mathcal{C}$ such that the star of $R$ with \n  respect to $\\mathcal{R}$ is contained in $C$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsStarRefinement (\"_ <\\<^sup>* _\" 90)\n  where \"P <\\<^sup>* Q \\<equiv> \\<forall>U\\<in>P.\\<exists>V\\<in>Q. Star(U,P) \\<subseteq> V\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2474
    },
    "2229": {
        "type": "lemma",
        "text": "text\\<open>Star refinement implies barycentric refinement. \\<close>\n",
        "assumes": "assumes \"Q\\<in>Covers(X)\" and \"Q <\\<^sup>* P\"\n  ",
        "using": [
            "star_single_mono"
        ],
        "statement": "lemma star_is_bary: assumes \"Q\\<in>Covers(X)\" and \"Q <\\<^sup>* P\"\n  shows \"Q <\\<^sup>B P\"\n",
        "proof": "proof -\n  from assms(1) have \"\\<Union>Q = X\" unfolding Covers_def by simp\n  { fix x assume \"x\\<in>X\"\n    with \\<open>\\<Union>Q = X\\<close> obtain R where \"R\\<in>Q\" and \"x\\<in>R\" by auto\n    with assms(2) obtain U where \"U\\<in>P\" and \"Star(R,Q) \\<subseteq> U\"\n      unfolding IsStarRefinement_def by auto\n    from \\<open>x\\<in>R\\<close> \\<open>Star(R,Q) \\<subseteq> U\\<close> have \"Star({x},Q) \\<subseteq> U\"\n      using star_single_mono by blast\n    with \\<open>U\\<in>P\\<close> have \"\\<exists>U\\<in>P. Star({x},Q) \\<subseteq> U\" by auto\n } with \\<open>\\<Union>Q = X\\<close> show ?thesis unfolding IsBarycentricRefinement_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2476
    },
    "2230": {
        "type": "lemma",
        "text": "text\\<open> Barycentric refinement of a barycentric refinement is a star refinement. \\<close>\n",
        "assumes": "assumes \"P\\<in>Covers(X)\" \"Q\\<in>Covers(X)\" \"R\\<in>Covers(X)\" \"P <\\<^sup>B Q\" \"Q <\\<^sup>B R\" \"X\\<noteq>0\" \n  ",
        "using": [
            "cover_nonempty"
        ],
        "statement": "lemma bary_bary_star: \n  assumes \"P\\<in>Covers(X)\" \"Q\\<in>Covers(X)\" \"R\\<in>Covers(X)\" \"P <\\<^sup>B Q\" \"Q <\\<^sup>B R\" \"X\\<noteq>0\" \n  shows \"P <\\<^sup>* R\"\n",
        "proof": "proof -\n  { fix U assume \"U\\<in>P\" \n    { assume \"U = 0\"\n      then have \"Star(U,P) = 0\" unfolding Star_def by simp\n      from assms(6,3) obtain V where \"V\\<in>R\" using cover_nonempty by auto\n      with \\<open>Star(U,P) = 0\\<close> have \"\\<exists>V\\<in>R. Star(U,P) \\<subseteq> V\" by auto\n    }\n    moreover \n    { assume \"U\\<noteq>0\"\n      then obtain x\\<^sub>0 where \"x\\<^sub>0\\<in>U\" by auto\n      with assms(1,2,5) \\<open>U\\<in>P\\<close> obtain V where \"V\\<in>R\" and \"Star({x\\<^sub>0},Q) \\<subseteq> V\"\n        unfolding Covers_def IsBarycentricRefinement_def by auto\n      have \"Star(U,P) \\<subseteq> V\"\n      proof -\n        { fix W assume \"W\\<in>P\" and \"W\\<inter>U \\<noteq> 0\"\n          from \\<open>W\\<inter>U \\<noteq> 0\\<close> obtain x where \"x\\<in>W\\<inter>U\" by auto\n          with assms(2) \\<open>U\\<in>P\\<close> have  \"x\\<in>\\<Union>P\" by auto\n          with assms(4) obtain C where \"C\\<in>Q\" and \"Star({x},P) \\<subseteq> C\"\n            unfolding IsBarycentricRefinement_def by blast\n          with \\<open>U\\<in>P\\<close> \\<open>W\\<in>P\\<close> \\<open>x\\<in>W\\<inter>U\\<close> \\<open>x\\<^sub>0\\<in>U\\<close> \\<open>Star({x\\<^sub>0},Q) \\<subseteq> V\\<close> have \"W\\<subseteq>V\" \n            unfolding Star_def by blast\n        } then show \"Star(U,P) \\<subseteq> V\" unfolding Star_def by auto        \n      qed\n      with \\<open>V\\<in>R\\<close> have \"\\<exists>V\\<in>R. Star(U,P) \\<subseteq> V\" by auto\n    }\n    ultimately have \"\\<exists>V\\<in>R. Star(U,P) \\<subseteq> V\" by auto\n  } then show \"P <\\<^sup>* R\" unfolding IsStarRefinement_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2477
    },
    "2231": {
        "type": "lemma",
        "text": "text\\<open>A family of uniform covers contain the trivial cover $\\{ X\\}$.\\<close>\n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" \n  ",
        "using": [
            "cover_stref_triv",
            "AreUniformCovers_def",
            "Covers_def"
        ],
        "statement": "lemma unicov_contains_triv: assumes \"\\<Theta> {are uniform covers of} X\" \n  shows \"{X} \\<in> \\<Theta>\"\n",
        "proof": "proof -\n  from assms obtain \\<R> where \"\\<R>\\<in>\\<Theta>\" unfolding AreUniformCovers_def by blast\n  with assms show ?thesis using cover_stref_triv \n    unfolding AreUniformCovers_def Covers_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2478
    },
    "2232": {
        "type": "lemma",
        "text": "text\\<open>If $\\Theta$ are uniform covers of $X$ then we can recover $X$ from $\\Theta$ by taking \n  $\\bigcup\\bigcup \\Theta$. \\<close>\n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" ",
        "using": [
            "unicov_contains_triv",
            "AreUniformCovers_def"
        ],
        "statement": "lemma space_from_unicov: assumes \"\\<Theta> {are uniform covers of} X\" shows \"X = \\<Union>\\<Union>\\<Theta>\"\n",
        "proof": "proof\n  from assms show \"X \\<subseteq> \\<Union>\\<Union>\\<Theta>\" using unicov_contains_triv \n    unfolding AreUniformCovers_def by auto\n  from assms show \"\\<Union>\\<Union>\\<Theta> \\<subseteq> X\" unfolding AreUniformCovers_def Covers_def \n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2479
    },
    "2233": {
        "type": "lemma",
        "text": "text\\<open> Every uniform cover has a star refinement. \\<close>\n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" and \"P\\<in>\\<Theta>\"\n  ",
        "using": [
            "assms",
            "AreUniformCovers_def"
        ],
        "statement": "lemma unicov_has_star_ref: \n  assumes \"\\<Theta> {are uniform covers of} X\" and \"P\\<in>\\<Theta>\"\n  shows \"\\<exists>Q\\<in>\\<Theta>. (Q <\\<^sup>* P)\"\n  ",
        "proof": "using assms unfolding AreUniformCovers_def by blast\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2480
    },
    "2234": {
        "type": "corollary",
        "text": "text\\<open> In particular, every uniform cover has a barycentric refinement. \\<close>\n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" and \"P\\<in>\\<Theta>\"\n  ",
        "using": [
            "unicov_has_star_ref",
            "star_is_bary"
        ],
        "statement": "corollary unicov_has_bar_ref:\n  assumes \"\\<Theta> {are uniform covers of} X\" and \"P\\<in>\\<Theta>\"\n  shows \"\\<exists>Q\\<in>\\<Theta>. (Q <\\<^sup>B P)\"\n",
        "proof": "proof - \n  from assms obtain Q where \"Q\\<in>\\<Theta>\" and \"Q <\\<^sup>* P\" \n    using unicov_has_star_ref by blast\n  with assms show ?thesis \n    unfolding AreUniformCovers_def using star_is_bary by blast\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2481
    },
    "2235": {
        "type": "lemma",
        "text": "text\\<open> From the definition of uniform covers we know that if a uniform cover $P$ \n  is a star-refinement of a cover $Q$ then $Q$ is in a uniform cover. The next lemma\n  shows that in order for $Q$ to be a uniform cover it is sufficient that $P$ is a \n  barycentric refinement of $Q$. \\<close>\n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" \"P\\<in>\\<Theta>\" \"Q \\<in> Covers(X)\" \"P <\\<^sup>B Q\" and \"X\\<noteq>0\" \n  ",
        "using": [
            "unicov_has_bar_ref",
            "bary_bary_star",
            "AreUniformCovers_def"
        ],
        "statement": "lemma unicov_bary_cov: \n  assumes \"\\<Theta> {are uniform covers of} X\" \"P\\<in>\\<Theta>\" \"Q \\<in> Covers(X)\" \"P <\\<^sup>B Q\" and \"X\\<noteq>0\" \n  shows \"Q\\<in>\\<Theta>\"\n",
        "proof": "proof -\n  from assms(1,2) obtain R where \"R\\<in>\\<Theta>\" and \"R <\\<^sup>B P\"\n    using unicov_has_bar_ref by blast\n  from assms(1,2,3) \\<open>R\\<in>\\<Theta>\\<close> have \n    \"P \\<in> Covers(X)\" \"Q \\<in> Covers(X)\" \"R \\<in> Covers(X)\"\n    unfolding AreUniformCovers_def by auto\n  with assms(1,3,4,5) \\<open>R\\<in>\\<Theta>\\<close> \\<open>R <\\<^sup>B P\\<close> show ?thesis \n    using bary_bary_star unfolding AreUniformCovers_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2482
    },
    "2236": {
        "type": "lemma",
        "text": "text\\<open> A technical lemma to simplify proof of the \\<open>uniformity_from_unicov\\<close> theorem. \\<close>\n",
        "assumes": "assumes \"U\\<in>P\" \"P<\\<^sup>*Q\" and \"\\<Union>{W\\<times>W. W\\<in>Q} \\<subseteq> A\"\n  ",
        "using": [],
        "statement": "lemma star_ref_mem: assumes \"U\\<in>P\" \"P<\\<^sup>*Q\" and \"\\<Union>{W\\<times>W. W\\<in>Q} \\<subseteq> A\"\n  shows \"U\\<times>U \\<subseteq> A\"\n",
        "proof": "proof -\n  from assms(1,2) obtain W where \"W\\<in>Q\" and \"\\<Union>{S\\<in>P. S\\<inter>U \\<noteq> 0} \\<subseteq> W\"\n    unfolding IsStarRefinement_def Star_def by auto\n  with assms(1,3) show \"U\\<times>U \\<subseteq> A\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2483
    },
    "2237": {
        "type": "lemma",
        "text": "text\\<open>An identity related to square (in the sense of composition) of a relation of the \n  form $\\bigcup \\{U\\times U : U\\in P\\}$. \n  I am amazed that Isabelle can see that this is true without an explicit proof, I can't. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma rel_square_starr: shows \n  \"(\\<Union>{U\\<times>U. U\\<in>P}) O (\\<Union>{U\\<times>U. U\\<in>P}) = \\<Union>{U\\<times>Star(U,P). U\\<in>P}\"\n  unfolding Star_def by blast\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2484
    },
    "2238": {
        "type": "lemma",
        "text": "text\\<open>A somewhat technical identity about the square of a symmetric relation: \\<close>\n",
        "assumes": "assumes \"W = converse(W)\"  \"domain(W) \\<subseteq> X\" \n  ",
        "using": [
            "rel_compdef"
        ],
        "statement": "lemma rel_sq_image: \n  assumes \"W = converse(W)\"  \"domain(W) \\<subseteq> X\" \n  shows \"Star({x},{W``{t}. t\\<in>X}) = (W O W)``{x}\"\n",
        "proof": "proof\n  have I: \"Star({x},{W``{t}. t\\<in>X}) = \\<Union>{S\\<in>{W``{t}. t\\<in>X}. x\\<in>S}\" \n    unfolding Star_def by auto\n  { fix y assume \"y \\<in> Star({x},{W``{t}. t\\<in>X})\"\n    with I obtain S where \"y\\<in>S\" \"x\\<in>S\" \"S \\<in> {W``{t}. t\\<in>X}\" by auto\n    from \\<open>S \\<in> {W``{t}. t\\<in>X}\\<close> obtain t where \"t\\<in>X\" and \"S = W``{t}\" \n      by auto\n    with \\<open>x\\<in>S\\<close> \\<open>y\\<in>S\\<close> have \"\\<langle>t,x\\<rangle> \\<in> W\" and \"\\<langle>t,y\\<rangle> \\<in> W\" \n      by auto\n    from \\<open>\\<langle>t,x\\<rangle> \\<in> W\\<close> have \"\\<langle>x,t\\<rangle> \\<in> converse(W)\" by auto\n    with assms(1) \\<open>\\<langle>t,y\\<rangle> \\<in> W\\<close> have \"y \\<in> (W O W)``{x}\" \n      using rel_compdef by auto\n  } then show \"Star({x},{W``{t}. t\\<in>X}) \\<subseteq> (W O W)``{x}\" \n    by blast\n  { fix y assume \"y\\<in>(W O W)``{x}\"\n    then obtain t where \"\\<langle>x,t\\<rangle> \\<in> W\" and \"\\<langle>t,y\\<rangle> \\<in> W\"\n      using rel_compdef by auto\n    from assms(2) \\<open>\\<langle>t,y\\<rangle> \\<in> W\\<close> have \"t\\<in>X\" by auto\n    from \\<open>\\<langle>x,t\\<rangle> \\<in> W\\<close> have \"\\<langle>t,x\\<rangle> \\<in> converse(W)\" by auto\n    with assms(1) I \\<open>\\<langle>t,y\\<rangle> \\<in> W\\<close> \\<open>t\\<in>X\\<close> have \"y \\<in> Star({x},{W``{t}. t\\<in>X})\"\n      by auto\n  } then show \"(W O W)``{x} \\<subseteq> Star({x},{W``{t}. t\\<in>X})\"\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2486
    },
    "2239": {
        "type": "definition",
        "text": "text\\<open> Given a family of uniform covers of $X$ we can create a uniformity on $X$ by taking the supersets\n  of $\\bigcup \\{A\\times A: A\\in P \\}$ as $P$ ranges over the uniform covers. The next definition\n  specifies the operation creating entourages from uniform covers. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"UniformityFromUniCov(X,\\<Theta>) \\<equiv> Supersets(X\\<times>X,{\\<Union>{U\\<times>U. U\\<in>P}. P\\<in>\\<Theta>})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2487
    },
    "2240": {
        "type": "lemma",
        "text": "text\\<open>For any member $P$ of a cover $\\Theta$ the set $\\bigcup \\{U\\times U : U\\in P\\}$ \n  is a member of \\<open>UniformityFromUniCov(X,\\<Theta>)\\<close>. \\<close>\n",
        "assumes": "assumes \"\\<Theta> \\<subseteq> Covers(X)\" \"P\\<in>\\<Theta>\"\n  ",
        "using": [
            "assms",
            "UniformityFromUniCov_def",
            "Supersets_def",
            "Covers_def"
        ],
        "statement": "lemma basic_unif: assumes \"\\<Theta> \\<subseteq> Covers(X)\" \"P\\<in>\\<Theta>\"\n  shows \"\\<Union>{U\\<times>U. U\\<in>P} \\<in> UniformityFromUniCov(X,\\<Theta>)\"\n  ",
        "proof": "using assms unfolding UniformityFromUniCov_def Supersets_def Covers_def\n  by blast\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2488
    },
    "2241": {
        "type": "theorem",
        "text": "text\\<open>If $\\Theta$ is a family of uniform covers of $X$ then \n  \\<open>UniformityFromUniCov(X,\\<Theta>)\\<close> is a uniformity on $X$ \\<close> \n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" \"X\\<noteq>0\"\n  ",
        "using": [
            "unicov_contains_triv",
            "AreUniformCovers_def",
            "star_ref_mem",
            "unicov_has_star_ref",
            "rel_square_starr",
            "element_subset_star"
        ],
        "statement": "theorem uniformity_from_unicov: \n  assumes \"\\<Theta> {are uniform covers of} X\" \"X\\<noteq>0\"\n  shows \"UniformityFromUniCov(X,\\<Theta>) {is a uniformity on} X\"\n",
        "proof": "proof -\n  let ?\\<Phi> = \"UniformityFromUniCov(X,\\<Theta>)\"\n  have \"?\\<Phi> {is a filter on} (X\\<times>X)\"\n  proof -\n    have \"0 \\<notin> ?\\<Phi>\"\n    proof -\n      { assume \"0 \\<in> ?\\<Phi>\"\n        then obtain P where \"P\\<in>\\<Theta>\" and \"0 = \\<Union>{U\\<times>U. U\\<in>P}\"\n          unfolding UniformityFromUniCov_def Supersets_def by auto\n        hence \"\\<Union>P = 0\" by auto\n        with assms \\<open>P\\<in>\\<Theta>\\<close> have False unfolding AreUniformCovers_def Covers_def\n          by auto\n      } thus ?thesis by auto\n    qed\n    moreover have \"X\\<times>X \\<in> ?\\<Phi>\"\n    proof -\n      from assms have \"X\\<times>X \\<in> {\\<Union>{U\\<times>U. U\\<in>P}. P\\<in>\\<Theta>}\" \n        using unicov_contains_triv unfolding AreUniformCovers_def \n        by auto\n      then show ?thesis unfolding Supersets_def UniformityFromUniCov_def \n        by blast\n    qed\n    moreover have \"?\\<Phi> \\<subseteq> Pow(X\\<times>X)\" \n      unfolding UniformityFromUniCov_def Supersets_def by auto\n    moreover have \"\\<forall>A\\<in>?\\<Phi>.\\<forall>B\\<in>?\\<Phi>. A\\<inter>B \\<in> ?\\<Phi>\"\n    proof -\n      { fix A B assume \"A\\<in>?\\<Phi>\" \"B\\<in>?\\<Phi>\"\n        then have \"A\\<inter>B \\<subseteq> X\\<times>X\" unfolding UniformityFromUniCov_def Supersets_def\n          by auto\n        from \\<open>A\\<in>?\\<Phi>\\<close> \\<open>B\\<in>?\\<Phi>\\<close> obtain P\\<^sub>A P\\<^sub>B where \n          \"P\\<^sub>A\\<in>\\<Theta>\" \"P\\<^sub>B\\<in>\\<Theta>\" and I:\"\\<Union>{U\\<times>U. U\\<in>P\\<^sub>A} \\<subseteq> A\"  \"\\<Union>{U\\<times>U. U\\<in>P\\<^sub>B} \\<subseteq> B\" \n          unfolding UniformityFromUniCov_def Supersets_def by auto\n        from assms(1) \\<open>P\\<^sub>A\\<in>\\<Theta>\\<close> \\<open>P\\<^sub>B\\<in>\\<Theta>\\<close> obtain P \n          where \"P\\<in>\\<Theta>\" and \"P<\\<^sup>*P\\<^sub>A\" and \"P<\\<^sup>*P\\<^sub>B\"\n          unfolding AreUniformCovers_def by blast\n        have \"\\<Union>{U\\<times>U. U\\<in>P} \\<subseteq> A\\<inter>B\"\n        proof -\n          { fix U assume \"U\\<in>P\" \n            with \\<open>P<\\<^sup>*P\\<^sub>A\\<close>  \\<open>P<\\<^sup>*P\\<^sub>B\\<close> I have \"U\\<times>U \\<subseteq> A\" and \"U\\<times>U \\<subseteq> B\" \n              using star_ref_mem by auto\n          } thus ?thesis by blast\n        qed\n        with \\<open>A\\<inter>B \\<subseteq> X\\<times>X\\<close> \\<open>P\\<in>\\<Theta>\\<close> have \"A\\<inter>B \\<in> ?\\<Phi>\" \n          unfolding Supersets_def UniformityFromUniCov_def by auto\n      } thus ?thesis by auto\n    qed\n    moreover have \n      \"\\<forall>B\\<in>?\\<Phi>.\\<forall>C\\<in>Pow(X\\<times>X). B\\<subseteq>C \\<longrightarrow> C\\<in>?\\<Phi>\"\n    proof -\n      { fix B C assume \"B\\<in>?\\<Phi>\" \"C\\<in>Pow(X\\<times>X)\" \"B\\<subseteq>C\"\n        from \\<open>B\\<in>?\\<Phi>\\<close> obtain P\\<^sub>B where  \"\\<Union>{U\\<times>U. U\\<in>P\\<^sub>B} \\<subseteq> B\" \"P\\<^sub>B\\<in>\\<Theta>\"\n          unfolding UniformityFromUniCov_def Supersets_def by auto\n        with \\<open>C\\<in>Pow(X\\<times>X)\\<close> \\<open>B\\<subseteq>C\\<close> have \"C\\<in>?\\<Phi>\"\n          unfolding UniformityFromUniCov_def Supersets_def by blast\n      } thus ?thesis by auto\n    qed\n    ultimately show ?thesis unfolding IsFilter_def by simp\n  qed\n  moreover have \"\\<forall>A\\<in>?\\<Phi>. id(X) \\<subseteq> A \\<and> (\\<exists>B\\<in>?\\<Phi>. B O B \\<subseteq> A) \\<and> converse(A) \\<in> ?\\<Phi>\"\n  proof\n    fix A assume \"A\\<in>?\\<Phi>\"\n    then obtain P where \"\\<Union>{U\\<times>U. U\\<in>P} \\<subseteq> A\" \"P\\<in>\\<Theta>\" \n      unfolding UniformityFromUniCov_def Supersets_def by auto\n    have \"id(X)\\<subseteq>A\"\n    proof -\n      from assms(1) \\<open>P\\<in>\\<Theta>\\<close> have \"\\<Union>P = X\" unfolding AreUniformCovers_def Covers_def\n        by auto\n      with \\<open>\\<Union>{U\\<times>U. U\\<in>P} \\<subseteq> A\\<close> show ?thesis by auto\n    qed\n    moreover have \"\\<exists>B\\<in>?\\<Phi>. B O B \\<subseteq> A\"\n    proof -\n      from assms(1) \\<open>P\\<in>\\<Theta>\\<close> have \"\\<Union>{U\\<times>U. U\\<in>P} \\<in> ?\\<Phi>\" \n        unfolding AreUniformCovers_def Covers_def UniformityFromUniCov_def Supersets_def\n        by auto\n      from assms(1) \\<open>P\\<in>\\<Theta>\\<close> obtain Q where \"Q\\<in>\\<Theta>\" and  \"Q <\\<^sup>* P\" using unicov_has_star_ref\n        by blast\n      let ?B = \"\\<Union>{U\\<times>U. U\\<in>Q}\"\n      from assms(1) \\<open>Q\\<in>\\<Theta>\\<close> have \"?B \\<in> ?\\<Phi>\" \n        unfolding AreUniformCovers_def Covers_def UniformityFromUniCov_def Supersets_def\n        by auto\n      moreover have \"?B O ?B \\<subseteq> A\"\n      proof -\n        have II: \"?B O ?B = \\<Union>{U\\<times>Star(U,Q). U\\<in>Q}\" using rel_square_starr \n          by simp\n        have \"\\<forall>U\\<in>Q. \\<exists>V\\<in>P. U\\<times>Star(U,Q) \\<subseteq> V\\<times>V\"\n        proof\n          fix U assume \"U\\<in>Q\"\n          with \\<open>Q <\\<^sup>* P\\<close> obtain V where \"V\\<in>P\" and \"Star(U,Q) \\<subseteq> V\"\n            unfolding IsStarRefinement_def by blast\n          with \\<open>U\\<in>Q\\<close> have \"V\\<in>P\" and \"U\\<times>Star(U,Q) \\<subseteq> V\\<times>V\" using element_subset_star\n            by auto\n          thus \"\\<exists>V\\<in>P. U\\<times>Star(U,Q) \\<subseteq> V\\<times>V\" by auto\n        qed\n        hence \"\\<Union>{U\\<times>Star(U,Q). U\\<in>Q} \\<subseteq> \\<Union>{V\\<times>V. V\\<in>P}\" by blast \n        with \\<open>\\<Union>{V\\<times>V. V\\<in>P} \\<subseteq> A\\<close> have \"\\<Union>{U\\<times>Star(U,Q). U\\<in>Q} \\<subseteq> A\" by blast\n        with II show ?thesis by simp\n      qed\n      ultimately show ?thesis by auto\n    qed\n    moreover from \\<open>A\\<in>?\\<Phi>\\<close> \\<open>P\\<in>\\<Theta>\\<close> \\<open>\\<Union>{U\\<times>U. U\\<in>P} \\<subseteq> A\\<close> have \"converse(A) \\<in> ?\\<Phi>\"\n      unfolding AreUniformCovers_def UniformityFromUniCov_def Supersets_def \n      by auto\n    ultimately show \"id(X) \\<subseteq> A \\<and> (\\<exists>B\\<in>?\\<Phi>. B O B \\<subseteq> A) \\<and> converse(A) \\<in> ?\\<Phi>\" \n      by simp\n  qed\n  ultimately show \"?\\<Phi>  {is a uniformity on} X\" unfolding IsUniformity_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2489
    },
    "2242": {
        "type": "definition",
        "text": "text\\<open>Given a uniformity $\\Phi$ on $X$ we can create a family of uniform covers by taking the \n  collection of covers $P$ for which there exist an entourage $U\\in \\Phi$ such that \n  for each $x\\in X$, there is an $A\\in P$ such that $U(\\{ x\\}) \\subseteq A$. The next definition\n  specifies the operation of creating a family of uniform covers from a uniformity. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"UniCovFromUniformity(X,\\<Phi>) \\<equiv> {P\\<in>Covers(X). \\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2490
    },
    "2243": {
        "type": "lemma",
        "text": "text\\<open>When we convert the quantifiers into unions and intersections in the definition\n  of \\<open>UniCovFromUniformity\\<close> we get an alternative definition of the operation\n  that creates a family of uniform covers from a uniformity. Just a curiosity, not used anywhere.\\<close>\n",
        "assumes": "assumes \"X\\<noteq>0\"\n  ",
        "using": [
            "subset_iff"
        ],
        "statement": "lemma UniCovFromUniformityDef: assumes \"X\\<noteq>0\"\n  shows \"UniCovFromUniformity(X,\\<Phi>) = (\\<Union>U\\<in>\\<Phi>.\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\"\n",
        "proof": "proof -\n  have \"{P\\<in>Covers(X). \\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A} = \n  (\\<Union>U\\<in>\\<Phi>.\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\"\n  proof\n  { fix P assume \"P\\<in>{P\\<in>Covers(X). \\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A}\"\n    then have \"P\\<in>Covers(X)\" and \"\\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A\" by auto\n    then obtain U where \"U\\<in>\\<Phi>\" and \"\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A\" by auto\n    with assms \\<open>P\\<in>Covers(X)\\<close> have \"P \\<in> (\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\" \n      by auto\n    with \\<open>U\\<in>\\<Phi>\\<close>  have \"P\\<in>(\\<Union>U\\<in>\\<Phi>.\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\" \n      by blast\n  } then show \n    \"{P\\<in>Covers(X). \\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A} \\<subseteq> \n    (\\<Union>U\\<in>\\<Phi>.\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\"\n    using subset_iff by simp\n  { fix P assume \"P\\<in>(\\<Union>U\\<in>\\<Phi>.\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\"\n    then obtain U where \"U\\<in>\\<Phi>\" \"P \\<in> (\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A})\" \n      by auto\n    with assms have \"P\\<in>Covers(X)\" and \"\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A\" by auto\n    with \\<open>U\\<in>\\<Phi>\\<close> have \"P\\<in>{P\\<in>Covers(X). \\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A}\"\n      by auto\n  } then show \"(\\<Union>U\\<in>\\<Phi>.\\<Inter>x\\<in>X. {P\\<in>Covers(X). \\<exists>A\\<in>P. U``({x}) \\<subseteq> A}) \\<subseteq> \n    {P\\<in>Covers(X). \\<exists>U\\<in>\\<Phi>.\\<forall>x\\<in>X.\\<exists>A\\<in>P. U``({x}) \\<subseteq> A}\" by auto\n  qed\n  then show ?thesis unfolding UniCovFromUniformity_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2491
    },
    "2244": {
        "type": "lemma",
        "text": "text\\<open>If $\\Phi$ is a (diagonal) uniformity on $X$, then every two elements \n  of  \\<open>UniCovFromUniformity(X,\\<Phi>)\\<close> have a common barycentric refinement.\\<close>\n",
        "assumes": "assumes \n    \"\\<Phi> {is a uniformity on} X\" \n    \"\\<Theta> = UniCovFromUniformity(X,\\<Phi>)\"\n    \"\\<C>\\<in>\\<Theta>\" \"\\<D>\\<in>\\<Theta>\"\n  ",
        "using": [
            "half_size_symm",
            "cover_image",
            "rel_sq_image"
        ],
        "statement": "lemma common_bar_refinemnt: \n  assumes \n    \"\\<Phi> {is a uniformity on} X\" \n    \"\\<Theta> = UniCovFromUniformity(X,\\<Phi>)\"\n    \"\\<C>\\<in>\\<Theta>\" \"\\<D>\\<in>\\<Theta>\"\n  shows \"\\<exists>\\<R>\\<in>\\<Theta>.(\\<R> <\\<^sup>B \\<C>) \\<and> (\\<R> <\\<^sup>B \\<D>)\"\n",
        "proof": "proof -\n  from assms(2,3) obtain U where \"U\\<in>\\<Phi>\" and I: \"\\<forall>x\\<in>X.\\<exists>C\\<in>\\<C>. U``{x} \\<subseteq> C\"\n    unfolding UniCovFromUniformity_def by auto\n  from assms(2,4) obtain V where \"V\\<in>\\<Phi>\" and II: \"\\<forall>x\\<in>X.\\<exists>D\\<in>\\<D>. V``{x} \\<subseteq> D\"\n    unfolding UniCovFromUniformity_def by auto    \n  from assms(1) \\<open>U\\<in>\\<Phi>\\<close> \\<open>V\\<in>\\<Phi>\\<close> have \"U\\<inter>V \\<in> \\<Phi>\"  \n    unfolding IsUniformity_def IsFilter_def by auto\n  with assms(1) obtain W where \"W\\<in>\\<Phi>\" and \"W O W \\<subseteq> U\\<inter>V\" and \"W=converse(W)\"\n    using half_size_symm by blast\n  from assms(1) \\<open>W\\<in>\\<Phi>\\<close> have \"domain(W) \\<subseteq> X\" \n    unfolding IsUniformity_def IsFilter_def by auto\n  let ?P = \"{W``{t}. t\\<in>X}\"\n  have \"?P\\<in>\\<Theta>\" \"?P <\\<^sup>B \\<C>\" \"?P <\\<^sup>B \\<D>\"\n  proof -\n    from assms(1,2) \\<open>W\\<in>\\<Phi>\\<close> show \"?P\\<in>\\<Theta>\" using cover_image by simp\n    with assms(2) have \"\\<Union>?P = X\" unfolding UniCovFromUniformity_def Covers_def\n      by simp\n    { fix x assume \"x\\<in>X\"\n      from \\<open>W=converse(W)\\<close> \\<open>domain(W) \\<subseteq> X\\<close> \\<open>W O W \\<subseteq> U\\<inter>V\\<close> \n      have \"Star({x},?P) \\<subseteq> U``{x}\" and \"Star({x},?P) \\<subseteq> V``{x}\"\n        using rel_sq_image by auto\n      from \\<open>x\\<in>X\\<close> I obtain C where \"C\\<in>\\<C>\" and \"U``{x} \\<subseteq> C\"\n        by auto\n      with \\<open>Star({x},?P) \\<subseteq> U``{x}\\<close> \\<open>C\\<in>\\<C>\\<close> have \"\\<exists>C\\<in>\\<C>. Star({x},?P) \\<subseteq> C\"\n        by auto\n      moreover \n      from \\<open>x\\<in>X\\<close> II obtain D where \"D\\<in>\\<D>\" and \"V``{x} \\<subseteq> D\"\n        by auto\n      with \\<open>Star({x},?P) \\<subseteq> V``{x}\\<close> \\<open>D\\<in>\\<D>\\<close> have \"\\<exists>D\\<in>\\<D>. Star({x},?P) \\<subseteq> D\"\n        by auto\n      ultimately have \"\\<exists>C\\<in>\\<C>. Star({x},?P) \\<subseteq> C\" and \"\\<exists>D\\<in>\\<D>. Star({x},?P) \\<subseteq> D\"\n        by auto\n    } hence \"\\<forall>x\\<in>X. \\<exists>C\\<in>\\<C>. Star({x},?P) \\<subseteq> C\" and \"\\<forall>x\\<in>X.\\<exists>D\\<in>\\<D>. Star({x},?P) \\<subseteq> D\"\n      by auto \n    with \\<open>\\<Union>?P = X\\<close> show \"?P <\\<^sup>B \\<C>\" and \"?P <\\<^sup>B \\<D>\"\n      unfolding IsBarycentricRefinement_def by auto\n  qed\n  thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2493
    },
    "2245": {
        "type": "corollary",
        "text": "text\\<open>If $\\Phi$ is a (diagonal) uniformity on $X$, then every element\n  of  \\<open>UniCovFromUniformity(X,\\<Phi>)\\<close> has a barycentric refinement there.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"\\<Theta> = UniCovFromUniformity(X,\\<Phi>)\" \"\\<C> \\<in> \\<Theta>\"\n  ",
        "using": [
            "assms",
            "common_bar_refinemnt"
        ],
        "statement": "corollary bar_refinement_ex:\n  assumes \"\\<Phi> {is a uniformity on} X\" \"\\<Theta> = UniCovFromUniformity(X,\\<Phi>)\" \"\\<C> \\<in> \\<Theta>\"\n  shows \"\\<exists>\\<R>\\<in>\\<Theta>. (\\<R> <\\<^sup>B \\<C>)\"\n  ",
        "proof": "using assms common_bar_refinemnt by blast\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2494
    },
    "2246": {
        "type": "theorem",
        "text": "text\\<open> If $\\Phi$ is a (diagonal) uniformity on $X$, then \\<open>UniCovFromUniformity(X,\\<Phi>)\\<close> is \n  a family of uniform covers.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" and \"X\\<noteq>0\" \n  ",
        "using": [
            "element_subset_star",
            "common_bar_refinemnt",
            "bar_refinement_ex",
            "bary_bary_star"
        ],
        "statement": "theorem unicov_from_uniformity: assumes \"\\<Phi> {is a uniformity on} X\" and \"X\\<noteq>0\" \n  shows \"UniCovFromUniformity(X,\\<Phi>) {are uniform covers of} X\"\n",
        "proof": "proof -\n  let ?\\<Theta> = \"UniCovFromUniformity(X,\\<Phi>)\"\n  from assms(1) have \"?\\<Theta> \\<subseteq> Covers(X)\" unfolding UniCovFromUniformity_def \n    by auto\n  moreover \n  from assms(1) have \"{X} \\<in> ?\\<Theta>\"\n    unfolding Covers_def IsUniformity_def IsFilter_def UniCovFromUniformity_def\n    by auto\n  hence \"?\\<Theta> \\<noteq> 0\" by auto\n  moreover have \"\\<forall>\\<R>\\<in>?\\<Theta>.\\<forall>\\<C>\\<in>Covers(X). ((\\<R> <\\<^sup>* \\<C>) \\<longrightarrow> \\<C>\\<in>?\\<Theta>)\"\n  proof -\n    { fix \\<R> \\<C> assume \"\\<R>\\<in>?\\<Theta>\" \"\\<C>\\<in>Covers(X)\" \"\\<R> <\\<^sup>* \\<C>\"\n      have \"\\<C>\\<in>?\\<Theta>\"\n      proof -\n        from \\<open>\\<R>\\<in>?\\<Theta>\\<close> obtain U where \"U\\<in>\\<Phi>\" and I: \"\\<forall>x\\<in>X.\\<exists>R\\<in>\\<R>. U``({x}) \\<subseteq> R\"\n          unfolding UniCovFromUniformity_def by auto\n        { fix x assume \"x\\<in>X\" \n          with I obtain R where \"R\\<in>\\<R>\" and \"U``({x}) \\<subseteq> R\" by auto\n          from \\<open>R\\<in>\\<R>\\<close> \\<open>\\<R> <\\<^sup>* \\<C>\\<close> obtain C where \"C\\<in>\\<C>\" and \"Star(R,\\<R>) \\<subseteq> C\"\n            unfolding IsStarRefinement_def by auto\n          with \\<open>U``({x}) \\<subseteq> R\\<close> \\<open>R\\<in>\\<R>\\<close> have \"U``({x}) \\<subseteq> C\" \n            using element_subset_star by blast\n          with \\<open>C\\<in>\\<C>\\<close> have \"\\<exists>C\\<in>\\<C>. U``({x}) \\<subseteq> C\" by auto\n        } hence \"\\<forall>x\\<in>X.\\<exists>C\\<in>\\<C>. U``({x}) \\<subseteq> C\" by auto\n        with \\<open>U\\<in>\\<Phi>\\<close> \\<open>\\<C>\\<in>Covers(X)\\<close> show ?thesis unfolding UniCovFromUniformity_def\n          by auto\n      qed\n    } thus ?thesis by auto\n  qed\n  moreover have \"\\<forall>\\<C>\\<in>?\\<Theta>.\\<forall>\\<D>\\<in>?\\<Theta>.\\<exists>\\<R>\\<in>?\\<Theta>.(\\<R> <\\<^sup>* \\<C>) \\<and> (\\<R> <\\<^sup>* \\<D>)\"\n  proof -\n    { fix \\<C> \\<D> assume \"\\<C>\\<in>?\\<Theta>\" \"\\<D>\\<in>?\\<Theta>\" \n      with assms(1) obtain P where \"P\\<in>?\\<Theta>\" and \"P <\\<^sup>B \\<C>\" \"P <\\<^sup>B \\<D>\"\n        using common_bar_refinemnt by blast\n      from assms(1) \\<open>P\\<in>?\\<Theta>\\<close> obtain \\<R> where \"\\<R>\\<in>?\\<Theta>\" and \"\\<R> <\\<^sup>B P\"\n        using bar_refinement_ex by blast\n      from \\<open>\\<R>\\<in>?\\<Theta>\\<close> \\<open>P\\<in>?\\<Theta>\\<close> \\<open>\\<C>\\<in>?\\<Theta>\\<close> \\<open>\\<D>\\<in>?\\<Theta>\\<close> have \n        \"P \\<in> Covers(X)\" \"\\<R> \\<in> Covers(X)\" \"\\<C> \\<in> Covers(X)\" \"\\<D> \\<in> Covers(X)\"\n        unfolding UniCovFromUniformity_def by auto\n      with assms(2) \\<open>\\<R> <\\<^sup>B P\\<close> \\<open>P <\\<^sup>B \\<C>\\<close> \\<open>P <\\<^sup>B \\<D>\\<close> have \"\\<R> <\\<^sup>* \\<C>\" and \"\\<R> <\\<^sup>* \\<D>\" \n        using bary_bary_star by auto\n      with \\<open>\\<R>\\<in>?\\<Theta>\\<close> have \"\\<exists>\\<R>\\<in>?\\<Theta>.(\\<R> <\\<^sup>* \\<C>) \\<and> (\\<R> <\\<^sup>* \\<D>)\" by auto\n    } thus ?thesis by simp\n  qed\n  ultimately show ?thesis unfolding AreUniformCovers_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2495
    },
    "2247": {
        "type": "theorem",
        "text": "text\\<open> The \\<open>UniCovFromUniformity\\<close> operation is the inverse of \\<open>UniformityFromUniCov\\<close>. \\<close>\n",
        "assumes": "assumes \"\\<Theta> {are uniform covers of} X\" \"X\\<noteq>0\"\n  ",
        "using": [
            "uniformity_from_unicov",
            "unicov_from_uniformity",
            "bar_refinement_ex",
            "star_singleton",
            "bary_bary_star",
            "unicov_has_bar_ref",
            "superset_gen",
            "UniformityFromUniCov_def",
            "half_size_symm",
            "cover_image",
            "UniCovFromUniformity_def",
            "Covers_def",
            "uni_domain",
            "rel_sq_image",
            "unicov_bary_cov"
        ],
        "statement": "theorem unicov_from_unif_inv: assumes \"\\<Theta> {are uniform covers of} X\" \"X\\<noteq>0\"\n  shows \"UniCovFromUniformity(X,UniformityFromUniCov(X,\\<Theta>)) = \\<Theta>\"\n",
        "proof": "proof\n  let ?\\<Phi> = \"UniformityFromUniCov(X,\\<Theta>)\"\n  let ?L = \"UniCovFromUniformity(X,?\\<Phi>)\"\n  from assms have I: \"?\\<Phi> {is a uniformity on} X\" \n    using uniformity_from_unicov by simp\n  with assms(2) have II: \"?L {are uniform covers of} X\" \n    using unicov_from_uniformity by simp\n  { fix P assume \"P\\<in>?L\"\n    with I obtain Q where \"Q\\<in>?L\" and \"Q <\\<^sup>B P\" \n      using bar_refinement_ex by blast\n    from \\<open>Q\\<in>?L\\<close> obtain U where \"U\\<in>?\\<Phi>\" and III:\"\\<forall>x\\<in>X.\\<exists>A\\<in>Q. U``{x} \\<subseteq> A\"\n      unfolding UniCovFromUniformity_def by auto\n    from \\<open>U\\<in>?\\<Phi>\\<close> have \"U \\<in> Supersets(X\\<times>X,{\\<Union>{U\\<times>U. U\\<in>P}. P\\<in>\\<Theta>})\"\n      unfolding UniformityFromUniCov_def by simp\n    then obtain B where \"B\\<subseteq>X\\<times>X\" \"B\\<subseteq>U\" and \"\\<exists>C\\<in>{\\<Union>{U\\<times>U. U\\<in>P}. P\\<in>\\<Theta>}. C\\<subseteq>B\" \n      unfolding Supersets_def by auto\n    then obtain C where \"C \\<in> {\\<Union>{U\\<times>U. U\\<in>P}. P\\<in>\\<Theta>}\" and \"C\\<subseteq>B\" by auto\n    then obtain R where \"R\\<in>\\<Theta>\" and \"C = \\<Union>{V\\<times>V. V\\<in>R}\" by auto\n    with \\<open>C\\<subseteq>B\\<close> \\<open>B\\<subseteq>U\\<close> have \"\\<Union>{V\\<times>V. V\\<in>R} \\<subseteq> U\" by auto\n    from assms(1) II \\<open>P\\<in>?L\\<close> \\<open>Q\\<in>?L\\<close> \\<open>R\\<in>\\<Theta>\\<close> have\n      IV: \"P\\<in>Covers(X)\" \"Q\\<in>Covers(X)\" \"R\\<in>Covers(X)\"\n      unfolding AreUniformCovers_def by auto\n    have \"R <\\<^sup>B Q\"\n    proof -\n      { fix x assume \"x\\<in>X\"\n        with III obtain A where \"A\\<in>Q\" and \"U``{x} \\<subseteq> A\" by auto\n        with \\<open>\\<Union>{V\\<times>V. V\\<in>R} \\<subseteq> U\\<close> have \"(\\<Union>{V\\<times>V. V\\<in>R})``{x} \\<subseteq> A\"\n          by auto\n        with \\<open>A\\<in>Q\\<close> have \"\\<exists>A\\<in>Q. Star({x},R) \\<subseteq> A\" using star_singleton by auto\n      } then have \"\\<forall>x\\<in>X. \\<exists>A\\<in>Q. Star({x},R) \\<subseteq> A\" by simp\n      moreover from \\<open>R\\<in>Covers(X)\\<close> have \"\\<Union>R = X\" unfolding Covers_def\n        by simp\n      ultimately show ?thesis unfolding IsBarycentricRefinement_def\n        by simp\n    qed\n    with assms(2) \\<open>Q <\\<^sup>B P\\<close> IV have \"R <\\<^sup>* P\" using bary_bary_star by simp\n    with assms(1) \\<open>R\\<in>\\<Theta>\\<close> \\<open>P\\<in>Covers(X)\\<close> have \"P\\<in>\\<Theta>\" \n      unfolding AreUniformCovers_def by simp\n  } thus \"?L\\<subseteq>\\<Theta>\" by auto\n  { fix P assume \"P\\<in>\\<Theta>\"\n    with assms(1) have \"P \\<in> Covers(X)\" \n      unfolding AreUniformCovers_def by auto\n    from assms(1) \\<open>P\\<in>\\<Theta>\\<close> obtain Q where \"Q \\<in> \\<Theta>\" and \"Q <\\<^sup>B P\" \n      using unicov_has_bar_ref by blast\n    let ?A = \"\\<Union>{V\\<times>V. V\\<in>Q}\"\n    have \"?A \\<in> ?\\<Phi>\" \n    proof -\n      from assms(1) \\<open>Q\\<in>\\<Theta>\\<close> have \"?A \\<subseteq> X\\<times>X\" and \"?A \\<in> {\\<Union>{V\\<times>V. V\\<in>Q}. Q\\<in>\\<Theta>}\"\n        unfolding AreUniformCovers_def Covers_def by auto \n      then show ?thesis \n        using superset_gen unfolding UniformityFromUniCov_def \n        by auto\n    qed\n    with I obtain B where \"B\\<in>?\\<Phi>\" \"B O B \\<subseteq> ?A\" and \"B=converse(B)\"\n      using half_size_symm by blast\n    let ?R = \"{B``{x}. x\\<in>X}\"\n    from I II \\<open>B\\<in>?\\<Phi>\\<close> have \"?R\\<in>?L\" and \"\\<Union>?R =X\"\n      using cover_image unfolding UniCovFromUniformity_def Covers_def\n      by auto\n    have \"?R <\\<^sup>B P\"\n    proof -\n      { fix x assume \"x\\<in>X\"\n        from assms(1) \\<open>Q \\<in> \\<Theta>\\<close> have \"\\<Union>Q = X\" \n          unfolding AreUniformCovers_def Covers_def by auto\n        with \\<open>Q <\\<^sup>B P\\<close> \\<open>x\\<in>X\\<close> obtain C where \"C\\<in>P\" and \"Star({x},Q) \\<subseteq> C\"\n          unfolding IsBarycentricRefinement_def by auto\n        from \\<open>B=converse(B)\\<close> I \\<open>B\\<in>?\\<Phi>\\<close> have \"Star({x},?R) = (B O B)``{x}\"\n          using  uni_domain rel_sq_image by auto\n        moreover from  \\<open>(B O B) \\<subseteq> ?A\\<close> have \"(B O B)``{x} \\<subseteq> ?A``{x}\" by blast\n        moreover have \"?A``{x} = Star({x},Q)\" using star_singleton by simp\n        ultimately have \"Star({x},?R) \\<subseteq> Star({x},Q)\" by auto\n        with \\<open>Star({x},Q) \\<subseteq> C\\<close> \\<open>C\\<in>P\\<close> have \"\\<exists>C\\<in>P. Star({x},?R) \\<subseteq> C\"\n          by auto\n      } with \\<open>\\<Union>?R = X\\<close> show ?thesis unfolding IsBarycentricRefinement_def\n        by auto\n    qed\n    with assms(2) II \\<open>P \\<in> Covers(X)\\<close> \\<open>?R\\<in>?L\\<close> \\<open>?R <\\<^sup>B P\\<close> have \"P\\<in>?L\" \n       using unicov_bary_cov by simp\n  } thus \"\\<Theta>\\<subseteq>?L\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2496
    },
    "2248": {
        "type": "theorem",
        "text": "text\\<open>The \\<open>UniformityFromUniCov\\<close> operation is the inverse of \\<open>UniCovFromUniformity\\<close>. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"X\\<noteq>0\"\n  ",
        "using": [
            "unicov_from_uniformity",
            "uniformity_from_unicov",
            "half_size_symm",
            "uni_domain(1)",
            "cover_image",
            "basic_unif",
            "uni_domain(2)",
            "symm_sq_prod_image",
            "entourage_props(1)",
            "entourage_props(1,2)",
            "refl_union_singl_image"
        ],
        "statement": "theorem unif_from_unicov_inv: assumes \"\\<Phi> {is a uniformity on} X\" \"X\\<noteq>0\"\n  shows \"UniformityFromUniCov(X,UniCovFromUniformity(X,\\<Phi>)) = \\<Phi>\"\n",
        "proof": "proof \n  let ?\\<Theta> = \"UniCovFromUniformity(X,\\<Phi>)\"\n  let ?L = \"UniformityFromUniCov(X,?\\<Theta>)\"\n  from assms have I: \"?\\<Theta> {are uniform covers of} X\"\n    using unicov_from_uniformity by simp\n  with assms have II: \"?L {is a uniformity on} X\" \n    using uniformity_from_unicov by simp\n  { fix A assume \"A\\<in>\\<Phi>\"\n    with assms(1) obtain B where \"B\\<in>\\<Phi>\" \"B O B \\<subseteq> A\" and \"B = converse(B)\"\n      using half_size_symm by blast\n    from assms(1) \\<open>A\\<in>\\<Phi>\\<close> have \"A \\<subseteq> X\\<times>X\" using uni_domain(1)\n      by simp\n    let ?P = \"{B``{x}. x\\<in>X}\"\n    from assms(1) \\<open>B\\<in>\\<Phi>\\<close> have \"?P\\<in>?\\<Theta>\" using cover_image\n      by simp\n    let ?C = \"\\<Union>{U\\<times>U. U\\<in>?P}\"\n    from I \\<open>?P\\<in>?\\<Theta>\\<close> have \"?C\\<in>?L\" \n      unfolding AreUniformCovers_def using basic_unif by blast  \n    from assms(1) \\<open>B\\<in>\\<Phi>\\<close> \\<open>B = converse(B)\\<close> \\<open>B O B \\<subseteq> A\\<close> have \"?C \\<subseteq> A\" \n      using uni_domain(2) symm_sq_prod_image by simp\n    with II \\<open>A \\<subseteq> X\\<times>X\\<close> \\<open>?C\\<in>?L\\<close> have \"A\\<in>?L\"\n      unfolding IsUniformity_def IsFilter_def by simp\n  } thus \"\\<Phi>\\<subseteq>?L\" by auto\n  { fix A assume \"A\\<in>?L\" \n    with II have \"A \\<subseteq> X\\<times>X\" using entourage_props(1) by simp\n    from \\<open>A\\<in>?L\\<close> obtain P where \"P\\<in>?\\<Theta>\" and \"\\<Union>{U\\<times>U. U\\<in>P} \\<subseteq> A\"\n      unfolding UniformityFromUniCov_def Supersets_def by blast\n    from \\<open>P\\<in>?\\<Theta>\\<close> obtain B where \"B\\<in>\\<Phi>\" and III: \"\\<forall>x\\<in>X. \\<exists>V\\<in>P. B``{x} \\<subseteq> V\"\n      unfolding UniCovFromUniformity_def by auto\n    have \"B\\<subseteq>A\"\n    proof -\n      from assms(1) \\<open>B\\<in>\\<Phi>\\<close> have \"B \\<subseteq> \\<Union>{B``{x}\\<times>B``{x}. x\\<in>X}\"\n        using entourage_props(1,2) refl_union_singl_image by simp\n      moreover have \"\\<Union>{B``{x}\\<times>B``{x}. x\\<in>X} \\<subseteq> A\"\n      proof -\n        { fix x assume \"x\\<in>X\"\n          with III obtain V where \"V\\<in>P\" and \"B``{x} \\<subseteq> V\" by auto\n          hence \"B``{x}\\<times>B``{x} \\<subseteq> \\<Union>{U\\<times>U. U\\<in>P}\" by auto\n        } hence \"\\<Union>{B``{x}\\<times>B``{x}. x\\<in>X} \\<subseteq> \\<Union>{U\\<times>U. U\\<in>P}\" by blast\n        with \\<open>\\<Union>{U\\<times>U. U\\<in>P} \\<subseteq> A\\<close> show ?thesis by blast\n      qed\n      ultimately show ?thesis by auto\n    qed\n    with assms(1) \\<open>B\\<in>\\<Phi>\\<close> \\<open>A \\<subseteq> X\\<times>X\\<close> have \"A\\<in>\\<Phi>\"\n      unfolding IsUniformity_def IsFilter_def by simp\n  } thus \"?L\\<subseteq>\\<Phi>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2497
    },
    "2249": {
        "type": "lemma",
        "text": "text\\<open>A set cannot be a member of itself. This is exactly lemma \\<open>mem_not_refl\\<close>\n  from Isabelle/ZF \\<open>upair.thy\\<close>, we put it here for easy reference. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma mem_self: shows \"x\\<notin>x\" by (rule mem_not_refl)\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2498
    },
    "2250": {
        "type": "lemma",
        "text": "text\\<open>If one collection is contained in another, then we can say the same\n  about their unions.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>B\" ",
        "using": [],
        "statement": "lemma collection_contain: assumes \"A\\<subseteq>B\" shows \"\\<Union>A \\<subseteq> \\<Union>B\"\n",
        "proof": "proof\n  fix x assume \"x \\<in> \\<Union>A\"\n  then obtain X where \"x\\<in>X\" and \"X\\<in>A\" by auto\n  with assms show \"x \\<in> \\<Union>B\" by auto\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2499
    },
    "2251": {
        "type": "lemma",
        "text": "text\\<open>If all sets of a nonempty collection are the same, then its union \n  is the same.\\<close>\n",
        "assumes": "assumes \"C\\<noteq>0\" and \"\\<forall>y\\<in>C. b(y) = A\" \n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma ZF1_1_L1: assumes \"C\\<noteq>0\" and \"\\<forall>y\\<in>C. b(y) = A\" \n  shows \"(\\<Union>y\\<in>C. b(y)) = A\" ",
        "proof": "using assms by blast\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2500
    },
    "2252": {
        "type": "lemma",
        "text": "text\\<open>The union af all values of a constant meta-function belongs to \nthe same set as the constant.\\<close>\n",
        "assumes": "assumes A1:\"C\\<noteq>0\" and A2: \"\\<forall>x\\<in>C. b(x) \\<in> A\" \n  and A3: \"\\<forall>x y. x\\<in>C \\<and> y\\<in>C \\<longrightarrow> b(x) = b(y)\"\n  ",
        "using": [
            "ZF1_1_L1"
        ],
        "statement": "lemma ZF1_1_L2: assumes A1:\"C\\<noteq>0\" and A2: \"\\<forall>x\\<in>C. b(x) \\<in> A\" \n  and A3: \"\\<forall>x y. x\\<in>C \\<and> y\\<in>C \\<longrightarrow> b(x) = b(y)\"\n  shows \"(\\<Union>x\\<in>C. b(x))\\<in>A\"\n",
        "proof": "proof -\n  from A1 obtain x where D1: \"x\\<in>C\" by auto\n  with A3 have \"\\<forall>y\\<in>C. b(y) = b(x)\" by blast\n  with A1 have \"(\\<Union>y\\<in>C. b(y)) = b(x)\" \n    using ZF1_1_L1 by simp\n  with D1 A2 show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2501
    },
    "2253": {
        "type": "lemma",
        "text": "text\\<open>If two meta-functions are the same on a cartesian product,\n  then the subsets defined by them are the same. I am surprised Isabelle\n  can not handle this automatically.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>X.\\<forall>y\\<in>Y. a(x,y) = b(x,y)\"\n  ",
        "using": [],
        "statement": "lemma ZF1_1_L4: assumes A1: \"\\<forall>x\\<in>X.\\<forall>y\\<in>Y. a(x,y) = b(x,y)\"\n  shows \"{a(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y} = {b(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\"\n",
        "proof": "proof\n  show \"{a(x, y). \\<langle>x,y\\<rangle> \\<in> X \\<times> Y} \\<subseteq> {b(x, y). \\<langle>x,y\\<rangle> \\<in> X \\<times> Y}\"\n  proof\n    fix z assume \"z \\<in> {a(x, y) . \\<langle>x,y\\<rangle> \\<in> X \\<times> Y}\"\n    with A1 show  \"z \\<in> {b(x,y).\\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\" by auto   \n  qed\n  show \"{b(x, y). \\<langle>x,y\\<rangle> \\<in> X \\<times> Y} \\<subseteq> {a(x, y). \\<langle>x,y\\<rangle> \\<in> X \\<times> Y}\"\n  proof\n    fix z assume \"z \\<in> {b(x, y). \\<langle>x,y\\<rangle> \\<in> X \\<times> Y}\"\n    with A1 show \"z \\<in> {a(x,y).\\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\" by auto\n  qed\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2502
    },
    "2254": {
        "type": "lemma",
        "text": "text\\<open>If two meta-functions are the same on a cartesian product,\n  then the subsets defined by them are the same. \n  This is similar to \\<open>ZF1_1_L4\\<close>, except that\n  the set definition varies over \\<open>p\\<in>X\\<times>Y\\<close> rather than \n  \\<open>\\<langle> x,y\\<rangle>\\<in>X\\<times>Y\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>X.\\<forall>y\\<in>Y. a(\\<langle> x,y\\<rangle>) = b(x,y)\"\n  ",
        "using": [],
        "statement": "lemma ZF1_1_L4A: assumes A1: \"\\<forall>x\\<in>X.\\<forall>y\\<in>Y. a(\\<langle> x,y\\<rangle>) = b(x,y)\"\n  shows \"{a(p). p \\<in> X\\<times>Y} = {b(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\"\n",
        "proof": "proof\n  { fix z assume \"z \\<in> {a(p). p\\<in>X\\<times>Y}\"\n    then obtain p where D1: \"z=a(p)\" \"p\\<in>X\\<times>Y\" by auto\n    let ?x = \"fst(p)\" let ?y = \"snd(p)\"\n    from A1 D1 have \"z \\<in> {b(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\" by auto\n  } then show \"{a(p). p \\<in> X\\<times>Y} \\<subseteq> {b(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\" by blast\nnext \n  { fix z assume \"z \\<in> {b(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y}\"\n    then obtain x y where D1: \"\\<langle>x,y\\<rangle> \\<in> X\\<times>Y\" \"z=b(x,y)\" by auto\n    let ?p = \"\\<langle> x,y\\<rangle>\" \n    from A1 D1 have \"?p\\<in>X\\<times>Y\" \"z = a(?p)\" by auto\n    then have \"z \\<in> {a(p). p \\<in> X\\<times>Y}\" by auto\n  } then show \"{b(x,y). \\<langle>x,y\\<rangle> \\<in> X\\<times>Y} \\<subseteq> {a(p). p \\<in> X\\<times>Y}\" by blast\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2503
    },
    "2255": {
        "type": "lemma",
        "text": "text\\<open>A lemma about inclusion in cartesian products. Included here to remember\n  that we need the $U\\times V \\neq \\emptyset$ assumption.\\<close>\n",
        "assumes": "assumes \"U\\<times>V\\<noteq>0\" \"U\\<times>V \\<subseteq> X\\<times>Y\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma prod_subset: assumes \"U\\<times>V\\<noteq>0\" \"U\\<times>V \\<subseteq> X\\<times>Y\" shows \"U\\<subseteq>X\" and \"V\\<subseteq>Y\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2504
    },
    "2256": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about sections in cartesian products.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> X\\<times>Y\" and \"U\\<times>V \\<subseteq> A\" and \"x \\<in> U\"  \"y \\<in> V\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma section_proj: assumes \"A \\<subseteq> X\\<times>Y\" and \"U\\<times>V \\<subseteq> A\" and \"x \\<in> U\"  \"y \\<in> V\"\n  shows \"U \\<subseteq> {t\\<in>X. \\<langle>t,y\\<rangle> \\<in> A}\" and \"V \\<subseteq> {t\\<in>Y. \\<langle>x,t\\<rangle> \\<in> A}\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2505
    },
    "2257": {
        "type": "lemma",
        "text": "text\\<open>If two meta-functions are the same on a set, then they define the same\n  set by separation.\\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>X. a(x) = b(x)\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma ZF1_1_L4B: assumes \"\\<forall>x\\<in>X. a(x) = b(x)\"\n  shows \"{a(x). x\\<in>X} = {b(x). x\\<in>X}\"\n  ",
        "proof": "using assms by simp\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2506
    },
    "2258": {
        "type": "lemma",
        "text": "text\\<open>A set defined by a constant meta-function is a singleton.\\<close>\n",
        "assumes": "assumes \"X\\<noteq>0\" and \"\\<forall>x\\<in>X. b(x) = c\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma ZF1_1_L5: assumes \"X\\<noteq>0\" and \"\\<forall>x\\<in>X. b(x) = c\"\n  shows \"{b(x). x\\<in>X} = {c}\" ",
        "proof": "using assms by blast\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2507
    },
    "2259": {
        "type": "lemma",
        "text": "text\\<open>Most of the time, \\<open>auto\\<close> does this job, but there are strange \n  cases when the next lemma is needed.\\<close>\n",
        "assumes": "assumes \"Y = {x\\<in>X. b(x)}\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma subset_with_property: assumes \"Y = {x\\<in>X. b(x)}\"\n  shows \"Y \\<subseteq> X\" \n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2508
    },
    "2260": {
        "type": "lemma",
        "text": "text\\<open>We can choose an element from a nonempty set.\\<close>\n",
        "assumes": "assumes \"X\\<noteq>0\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma nonempty_has_element: assumes \"X\\<noteq>0\" shows \"\\<exists>x. x\\<in>X\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2509
    },
    "2261": {
        "type": "lemma",
        "text": "text\\<open>In Isabelle/ZF the intersection of an empty family is \n  empty. This is exactly lemma \\<open>Inter_0\\<close> from Isabelle's\n  \\<open>equalities\\<close> theory. We repeat this lemma here as it is very\n  difficult to find. This is one reason we need comments before every \n  theorem: so that we can search for keywords.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma inter_empty_empty: shows \"\\<Inter>0 = 0\" by (rule Inter_0)\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2510
    },
    "2262": {
        "type": "lemma",
        "text": "text\\<open>If an intersection of a collection is not empty, then the collection is\n  not empty. We are (ab)using the fact the the intersection of empty collection \n  is defined to be empty.\\<close>\n",
        "assumes": "assumes \"\\<Inter>A \\<noteq> 0\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma inter_nempty_nempty: assumes \"\\<Inter>A \\<noteq> 0\" shows \"A\\<noteq>0\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2511
    },
    "2263": {
        "type": "lemma",
        "text": "text\\<open>An intersection of subsets is a subset.\\<close>\n",
        "assumes": "assumes A1: \"I\\<noteq>0\" and A2: \"\\<forall>i\\<in>I. P(i) \\<subseteq> X\"\n  ",
        "using": [],
        "statement": "lemma ZF1_1_L7: assumes A1: \"I\\<noteq>0\" and A2: \"\\<forall>i\\<in>I. P(i) \\<subseteq> X\"\n  shows \"( \\<Inter>i\\<in>I. P(i) ) \\<subseteq> X\"\n",
        "proof": "proof -\n  from A1 obtain i\\<^sub>0 where \"i\\<^sub>0 \\<in> I\" by auto\n  with A2 have \"( \\<Inter>i\\<in>I. P(i) ) \\<subseteq> P(i\\<^sub>0)\" and \"P(i\\<^sub>0) \\<subseteq> X\"\n    by auto\n  thus \"( \\<Inter>i\\<in>I. P(i) ) \\<subseteq> X\" by auto\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2514
    },
    "2264": {
        "type": "lemma",
        "text": "text\\<open>Isabelle/ZF has a \"THE\" construct that allows to define an element\n  if there is only one such that is satisfies given predicate.\n  In pure ZF we can express something similar using the indentity proven below.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma ZF1_1_L8: shows \"\\<Union> {x} = x\" by auto\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2515
    },
    "2265": {
        "type": "lemma",
        "text": "text\\<open>Some properties of singletons.\\<close>\n",
        "assumes": "assumes A1: \"\\<exists>! x. x\\<in>A \\<and> \\<phi>(x)\"\n  ",
        "using": [],
        "statement": "lemma ZF1_1_L9: assumes A1: \"\\<exists>! x. x\\<in>A \\<and> \\<phi>(x)\"\n  shows \n  \"\\<exists>a. {x\\<in>A. \\<phi>(x)} = {a}\"\n  \"\\<Union> {x\\<in>A. \\<phi>(x)} \\<in> A\"\n  \"\\<phi>(\\<Union> {x\\<in>A. \\<phi>(x)})\"\n",
        "proof": "proof -\n  from A1 show \"\\<exists>a. {x\\<in>A. \\<phi>(x)} = {a}\" by auto\n  then obtain a where I: \"{x\\<in>A. \\<phi>(x)} = {a}\" by auto\n  then have \"\\<Union> {x\\<in>A. \\<phi>(x)} = a\" by auto\n  moreover\n  from I have \"a \\<in> {x\\<in>A. \\<phi>(x)}\" by simp\n  hence \"a\\<in>A\" and \"\\<phi>(a)\" by auto\n  ultimately show \"\\<Union> {x\\<in>A. \\<phi>(x)} \\<in> A\" and \"\\<phi>(\\<Union> {x\\<in>A. \\<phi>(x)})\"\n    by auto\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2516
    },
    "2266": {
        "type": "corollary",
        "text": "text\\<open>A simple version of \\<open> ZF1_1_L9\\<close>.\\<close>\n",
        "assumes": "assumes  \"\\<exists>! x. x\\<in>A\"\n  ",
        "using": [],
        "statement": "corollary singleton_extract: assumes  \"\\<exists>! x. x\\<in>A\"\n  shows \"(\\<Union> A) \\<in> A\"\n",
        "proof": "proof -\n  from assms have \"\\<exists>! x. x\\<in>A \\<and> True\" by simp\n  then have \"\\<Union> {x\\<in>A. True} \\<in> A\" by (rule ZF1_1_L9)\n  thus \"(\\<Union> A) \\<in> A\" by simp\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2517
    },
    "2267": {
        "type": "lemma",
        "text": "text\\<open>Adding an element of a set to that set does not change the set.\\<close>\n",
        "assumes": "assumes \"x\\<in>X\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma set_elem_add: assumes \"x\\<in>X\" shows \"X \\<union> {x} = X\" ",
        "proof": "using assms \n  by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2519
    },
    "2268": {
        "type": "definition",
        "text": "text\\<open>Here we define a restriction of a collection of sets to a given set. \n  In romantic math this is typically denoted $X\\cap M$ and means \n  $\\{X\\cap A : A\\in M \\} $. Note there is also restrict$(f,A)$ \n  defined for relations in ZF.thy.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  RestrictedTo (infixl \"{restricted to}\" 70) where\n  \"M {restricted to} X \\<equiv> {X \\<inter> A . A \\<in> M}\"\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2520
    },
    "2269": {
        "type": "lemma",
        "text": "text\\<open>Next we show a technical identity that is used to prove sufficiency \n  of some condition for a collection of sets to be a base for a topology.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>U\\<in>C. \\<exists>A\\<in>B. U = \\<Union>A\" \n  ",
        "using": [],
        "statement": "lemma ZF1_1_L10: assumes A1: \"\\<forall>U\\<in>C. \\<exists>A\\<in>B. U = \\<Union>A\" \n  shows \"\\<Union>\\<Union> {\\<Union>{A\\<in>B. U = \\<Union>A}. U\\<in>C} = \\<Union>C\"\n",
        "proof": "proof\n  show \"\\<Union>(\\<Union>U\\<in>C. \\<Union>{A \\<in> B . U = \\<Union>A}) \\<subseteq> \\<Union>C\" by blast\n  show \"\\<Union>C \\<subseteq> \\<Union>(\\<Union>U\\<in>C. \\<Union>{A \\<in> B . U = \\<Union>A})\"\n  proof\n    fix x assume \"x \\<in> \\<Union>C\" \n    show \"x \\<in> \\<Union>(\\<Union>U\\<in>C. \\<Union>{A \\<in> B . U = \\<Union>A})\"\n    proof -\n      from \\<open>x \\<in> \\<Union>C\\<close> obtain U where \"U\\<in>C \\<and> x\\<in>U\" by auto\n      with A1 obtain A where \"A\\<in>B \\<and> U = \\<Union>A\" by auto\n      from \\<open>U\\<in>C \\<and> x\\<in>U\\<close> \\<open>A\\<in>B \\<and> U = \\<Union>A\\<close> show \"x\\<in> \\<Union>(\\<Union>U\\<in>C. \\<Union>{A \\<in> B . U = \\<Union>A})\" \n\tby auto\n    qed\n  qed\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2522
    },
    "2270": {
        "type": "lemma",
        "text": "text\\<open>Standard Isabelle uses a notion of \\<open>cons(A,a)\\<close> that can be thought \n  of as $A\\cup \\{a\\}$.\\<close>\n",
        "assumes": "",
        "using": [
            "cons_def"
        ],
        "statement": "lemma consdef: shows \"cons(a,A) = A \\<union> {a}\"\n  ",
        "proof": "using cons_def by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2523
    },
    "2271": {
        "type": "lemma",
        "text": "text\\<open>If a difference between a set and a singleton is empty, then\n  the set is empty or it is equal to the singleton.\\<close>\n",
        "assumes": "assumes \"A - {x} = 0\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma singl_diff_empty: assumes \"A - {x} = 0\"\n  shows \"A = 0 \\<or> A = {x}\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2524
    },
    "2272": {
        "type": "lemma",
        "text": "text\\<open>If a difference between a set and a singleton is the set, \n  then the only element of the singleton is not in the set.\\<close>\n",
        "assumes": "assumes A1: \"A - {x} = A\"\n  ",
        "using": [],
        "statement": "lemma singl_diff_eq: assumes A1: \"A - {x} = A\"\n  shows \"x \\<notin> A\"\n",
        "proof": "proof -\n  have \"x \\<notin> A - {x}\" by auto\n  with A1 show \"x \\<notin> A\" by simp\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2525
    },
    "2273": {
        "type": "lemma",
        "text": "text\\<open>Simple substitution in membership, has to be used by rule\n  in very rare cases.\\<close>\n",
        "assumes": "assumes \"x\\<in>A\" and \"y=x\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma eq_mem: assumes \"x\\<in>A\" and \"y=x\" shows \"y\\<in>A\" \n  ",
        "proof": "using assms by simp\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2526
    },
    "2274": {
        "type": "lemma",
        "text": "text\\<open>A basic property of sets defined by comprehension.\\<close>\n",
        "assumes": "assumes \"a \\<in> {x\\<in>X. p(x)}\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma comprehension: assumes \"a \\<in> {x\\<in>X. p(x)}\"\n  shows \"a\\<in>X\" and \"p(a)\" ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2527
    },
    "2275": {
        "type": "lemma",
        "text": "text\\<open>A basic property of a set defined by another type of comprehension.\\<close>\n",
        "assumes": "assumes \"y \\<in> {p(x). x\\<in>X}\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma comprehension_repl: assumes \"y \\<in> {p(x). x\\<in>X}\"\n  shows \"\\<exists>x\\<in>X. y = p(x)\" ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2528
    },
    "2276": {
        "type": "lemma",
        "text": "text\\<open>The inverse of the \\<open>comprehension\\<close> lemma.\\<close>\n",
        "assumes": "assumes \"\\<phi>(c)\" and \"c\\<in>X\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma mem_cond_in_set: assumes \"\\<phi>(c)\" and \"c\\<in>X\"\n  shows \"c \\<in> {x\\<in>X. \\<phi>(x)}\" ",
        "proof": "using assms by blast\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2529
    },
    "2277": {
        "type": "lemma",
        "text": "text\\<open> A technical lemma about relations: if $x$ is in its image by a relation $U$\n  and that image is contained in some set $C$, then the image of the singleton\n  $\\{ x\\}$ by the relation $U \\cup C\\times C$ equals $C$. \\<close>\n",
        "assumes": "assumes  \"x \\<in> U``{x}\"  and \"U``{x} \\<subseteq> C\"\n  ",
        "using": [
            "assms",
            "image_Un_left"
        ],
        "statement": "lemma image_greater_rel: \n  assumes  \"x \\<in> U``{x}\"  and \"U``{x} \\<subseteq> C\"\n  shows \"(U \\<union> C\\<times>C)``{x} = C\"\n  ",
        "proof": "using assms image_Un_left by blast \n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2531
    },
    "2278": {
        "type": "lemma",
        "text": "text\\<open>Reformulation of the definition of composition of two relations: \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma rel_compdef: \n  shows \"\\<langle>x,z\\<rangle> \\<in> r O s  \\<longleftrightarrow>  (\\<exists>y. \\<langle>x,y\\<rangle> \\<in> s \\<and> \\<langle>y,z\\<rangle> \\<in> r)\" \n  unfolding comp_def by auto\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2532
    },
    "2279": {
        "type": "lemma",
        "text": "text\\<open>Domain and range of the relation of the form $\\bigcup \\{U\\times U : U\\in P\\}$\n  is $\\bigcup P$: \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma domain_range_sym: shows \"domain(\\<Union>{U\\<times>U. U\\<in>P}) = \\<Union>P\" and \"range(\\<Union>{U\\<times>U. U\\<in>P}) = \\<Union>P\" \n  by auto\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2533
    },
    "2280": {
        "type": "lemma",
        "text": "text\\<open>An identity for the square (in the sense of composition) of a symmetric relation.\\<close>\n",
        "assumes": "assumes \"converse(r) = r\" \n  ",
        "using": [
            "rel_compdef"
        ],
        "statement": "lemma symm_sq_prod_image: assumes \"converse(r) = r\" \n  shows \"r O r = \\<Union>{(r``{x})\\<times>(r``{x}). x \\<in> domain(r)}\"\n",
        "proof": "proof\n  { fix p assume \"p \\<in> r O r\"\n    then obtain y z where \"\\<langle>y,z\\<rangle> = p\" by auto\n    with \\<open>p \\<in> r O r\\<close> obtain x where \"\\<langle>y,x\\<rangle> \\<in> r\" and \"\\<langle>x,z\\<rangle> \\<in> r\"\n      using rel_compdef by auto\n    from \\<open>\\<langle>y,x\\<rangle> \\<in> r\\<close> have \"\\<langle>x,y\\<rangle> \\<in> converse(r)\" by simp\n    with assms \\<open>\\<langle>x,z\\<rangle> \\<in> r\\<close> \\<open>\\<langle>y,z\\<rangle> = p\\<close> have \"\\<exists>x\\<in>domain(r). p \\<in> (r``{x})\\<times>(r``{x})\"\n      by auto\n  } thus \"r O r \\<subseteq> (\\<Union>{(r``{x})\\<times>(r``{x}). x \\<in> domain(r)})\"\n    by blast\n  { fix x assume \"x \\<in> domain(r)\"\n    have \"(r``{x})\\<times>(r``{x}) \\<subseteq> r O r\"\n    proof -\n      { fix p assume \"p \\<in> (r``{x})\\<times>(r``{x})\"\n        then obtain y z where \"\\<langle>y,z\\<rangle> = p\" \"y \\<in> r``{x}\" \"z \\<in> r``{x}\"\n          by auto\n        from \\<open>y \\<in> r``{x}\\<close> have \"\\<langle>x,y\\<rangle> \\<in> r\" by auto\n        then have \"\\<langle>y,x\\<rangle> \\<in> converse(r)\" by simp\n        with assms \\<open>z \\<in> r``{x}\\<close> \\<open>\\<langle>y,z\\<rangle> = p\\<close> have \"p \\<in> r O r\" by auto\n      } thus ?thesis  by auto\n    qed\n  } thus \"(\\<Union>{(r``{x})\\<times>(r``{x}). x \\<in> domain(r)}) \\<subseteq> r O r\" \n    by blast\nqed \n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2534
    },
    "2281": {
        "type": "lemma",
        "text": "text\\<open>A reflexive relation is contained in the union of products of its singleton images. \\<close>\n",
        "assumes": "assumes \"A \\<subseteq> X\\<times>X\" and \"id(X)\\<subseteq>A\" ",
        "using": [],
        "statement": "lemma refl_union_singl_image: \n  assumes \"A \\<subseteq> X\\<times>X\" and \"id(X)\\<subseteq>A\" shows \"A \\<subseteq> \\<Union>{A``{x}\\<times>A``{x}. x \\<in> X}\" \n",
        "proof": "proof -\n  { fix p assume \"p\\<in>A\"\n    with assms(1) obtain x y where \"x\\<in>X\" \"y\\<in>X\" and \"p=\\<langle>x,y\\<rangle>\" by auto\n    with assms(2) \\<open>p\\<in>A\\<close> have \"\\<exists>x\\<in>X. p \\<in> A``{x}\\<times>A``{x}\" by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2535
    },
    "2282": {
        "type": "lemma",
        "text": "text\\<open>If the cartesian product of the images of $x$ and $y$ by a \n  symmetric relation $W$ has a nonempty intersection with $R$\n  then $x$ is in relation $W\\circ (R\\circ W)$ with $y$. \\<close>\n",
        "assumes": "assumes \"W=converse(W)\" and \"(W``{x})\\<times>(W``{y}) \\<inter> R \\<noteq> 0\"\n  ",
        "using": [],
        "statement": "lemma sym_rel_comp: \n  assumes \"W=converse(W)\" and \"(W``{x})\\<times>(W``{y}) \\<inter> R \\<noteq> 0\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> (W O (R O W))\" \n",
        "proof": "proof -\n  from assms(2) obtain s t where \"s\\<in>W``{x}\" \"t\\<in>W``{y}\" and \"\\<langle>s,t\\<rangle>\\<in>R\"\n    by blast\n  then have \"\\<langle>x,s\\<rangle> \\<in> W\" and \"\\<langle>y,t\\<rangle> \\<in> W\" by auto\n  from \\<open>\\<langle>x,s\\<rangle> \\<in> W\\<close> \\<open>\\<langle>s,t\\<rangle> \\<in> R\\<close> have \"\\<langle>x,t\\<rangle> \\<in> R O W\" by auto\n  from \\<open>\\<langle>y,t\\<rangle> \\<in> W\\<close> have \"\\<langle>t,y\\<rangle> \\<in> converse(W)\" by blast\n  with assms(1) \\<open>\\<langle>x,t\\<rangle> \\<in> R O W\\<close> show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2536
    },
    "2283": {
        "type": "lemma",
        "text": "text\\<open> It's hard to believe but there are cases where we have to reference this rule. \\<close>\n",
        "assumes": "assumes \"x\\<in>A\" \"A=B\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma set_mem_eq: assumes \"x\\<in>A\" \"A=B\" shows \"x\\<in>B\" ",
        "proof": "using assms by simp\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2537
    },
    "2284": {
        "type": "lemma",
        "text": "text\\<open>The family itself is in its supersets. \\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\" \"A\\<in>\\<A>\" ",
        "using": [
            "assms",
            "Supersets_def"
        ],
        "statement": "lemma superset_gen: assumes \"A\\<subseteq>X\" \"A\\<in>\\<A>\" shows \"A \\<in> Supersets(X,\\<A>)\"\n  ",
        "proof": "using assms unfolding Supersets_def by auto \n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2539
    },
    "2285": {
        "type": "lemma",
        "text": "text\\<open>This can be done by the auto method, but sometimes takes a long time. \\<close>\n",
        "assumes": "assumes \"x\\<in>X\" and \"\\<phi>(x)\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma witness_exists: assumes \"x\\<in>X\" and \"\\<phi>(x)\" shows \"\\<exists>x\\<in>X. \\<phi>(x)\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2540
    },
    "2286": {
        "type": "lemma",
        "text": "text\\<open>Another lemma that concludes existence of some set.\\<close>\n",
        "assumes": "assumes \"x\\<in>X\" \"\\<phi>(x)\" \"\\<psi>(x)\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma witness_exists1: assumes \"x\\<in>X\" \"\\<phi>(x)\" \"\\<psi>(x)\"\n  shows \"\\<exists>x\\<in>X. \\<phi>(x) \\<and> \\<psi>(x)\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2541
    },
    "2287": {
        "type": "lemma",
        "text": "text\\<open>The next lemma has to be used as a rule in some rare cases. \\<close>\n",
        "assumes": "assumes \"\\<forall>x. x\\<in>A \\<longrightarrow> \\<phi>(x)\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma exists_in_set: assumes \"\\<forall>x. x\\<in>A \\<longrightarrow> \\<phi>(x)\" shows \"\\<forall>x\\<in>A. \\<phi>(x)\"\n  ",
        "proof": "using assms by simp\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2542
    },
    "2288": {
        "type": "lemma",
        "text": "text\\<open>If $x$ belongs to a set where a property holds, then the property holds\n  for $x$. This has to be used as rule in rare cases. \\<close>\n",
        "assumes": "assumes \"\\<forall>t\\<in>X. \\<phi>(t)\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma property_holds: assumes \"\\<forall>t\\<in>X. \\<phi>(t)\" and \"x\\<in>X\"\n  shows \"\\<phi>(x)\" ",
        "proof": "using assms by simp\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2543
    },
    "2289": {
        "type": "lemma",
        "text": "text\\<open>Set comprehensions defined by equal expressions are the equal. \n  The second assertion is actually about functions, which are sets of pairs \n  as illustrated in lemma \\<open>fun_is_set_of_pairs\\<close> in \\<open>func1.thy\\<close>  \\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>X. p(x) = q(x)\" \n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma set_comp_eq: assumes \"\\<forall>x\\<in>X. p(x) = q(x)\" \n  shows \"{p(x). x\\<in>X} = {q(x). x\\<in>X}\" and \"{\\<langle>x,p(x)\\<rangle>. x\\<in>X} = {\\<langle>x,q(x)\\<rangle>. x\\<in>X}\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2544
    },
    "2290": {
        "type": "lemma",
        "text": "text\\<open>If $z$ is a pair, then the cartesian product of the singletons of its \n  elements is the same as the singleton $\\{ z\\}$.\\<close> \n",
        "assumes": "assumes \"z = \\<langle>x,y\\<rangle>\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma pair_prod: assumes \"z = \\<langle>x,y\\<rangle>\" shows \"{x}\\<times>{y} = {z}\"\n  ",
        "proof": "using assms by blast\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2545
    },
    "2291": {
        "type": "definition",
        "text": "text\\<open>We define the notion of function that preserves a collection here.\n  Given two collection of sets a function preserves the collections if \n  the inverse image of sets in one collection belongs to the second one.\n  This notion does not have a name in romantic math. It is used to define \n  continuous functions in \\<open>Topology_ZF_2\\<close> theory. \n  We define it here so that we can \n  use it for other purposes, like defining measurable functions.\n  Recall that \\<open>f-``(A)\\<close> means the inverse image of the set $A$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"PresColl(f,S,T) \\<equiv> \\<forall> A\\<in>T. f-``(A)\\<in>S\"\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2546
    },
    "2292": {
        "type": "definition",
        "text": "text\\<open>A definition that allows to get the first factor of the\n  domain of a binary function $f: X\\times Y \\rightarrow Z$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"fstdom(f) \\<equiv> domain(domain(f))\"\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2547
    },
    "2293": {
        "type": "lemma",
        "text": "text\\<open>If a function maps $A$ into another set, then $A$ is the \n  domain of the function.\\<close>\n",
        "assumes": "assumes \"f:A\\<rightarrow>C\" ",
        "using": [
            "assms",
            "domain_of_fun"
        ],
        "statement": "lemma func1_1_L1: assumes \"f:A\\<rightarrow>C\" shows \"domain(f) = A\"\n  ",
        "proof": "using assms domain_of_fun by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2548
    },
    "2294": {
        "type": "lemma",
        "text": "text\\<open>Standard Isabelle defines a \\<open>function(f)\\<close> predicate.\n  The next lemma shows that our functions satisfy that predicate. \n  It is a special version of Isabelle's \\<open>fun_is_function\\<close>.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" ",
        "using": [
            "assms",
            "fun_is_function"
        ],
        "statement": "lemma fun_is_fun: assumes \"f:X\\<rightarrow>Y\" shows \"function(f)\"\n  ",
        "proof": "using assms fun_is_function by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2549
    },
    "2295": {
        "type": "lemma",
        "text": "text\\<open>A lemma explains what \\<open>fstdom\\<close> is for.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<times>Y \\<rightarrow> Z\" and A2: \"Y\\<noteq>0\" \n  ",
        "using": [
            "func1_1_L1"
        ],
        "statement": "lemma fstdomdef: assumes A1: \"f: X\\<times>Y \\<rightarrow> Z\" and A2: \"Y\\<noteq>0\" \n  shows \"fstdom(f) = X\"\n",
        "proof": "proof -\n  from A1 have \"domain(f) = X\\<times>Y\" using func1_1_L1\n    by simp\n  with A2 show \"fstdom(f) = X\" unfolding fstdom_def by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2550
    },
    "2296": {
        "type": "lemma",
        "text": "text\\<open>A version of the \\<open>Pi_type\\<close> lemma from the standard Isabelle/ZF library.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"\\<forall>x\\<in>X. f`(x) \\<in> Z\"\n  ",
        "using": [],
        "statement": "lemma func1_1_L1A: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"\\<forall>x\\<in>X. f`(x) \\<in> Z\"\n  shows \"f:X\\<rightarrow>Z\"\n",
        "proof": "proof -\n  { fix x assume \"x\\<in>X\" \n    with A2 have \"f`(x) \\<in> Z\" by simp }\n  with A1 show \"f:X\\<rightarrow>Z\" by (rule Pi_type)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2551
    },
    "2297": {
        "type": "lemma",
        "text": "text\\<open>A variant of \\<open>func1_1_L1A\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"Y\\<subseteq>Z\"\n  ",
        "using": [
            "apply_funtype",
            "func1_1_L1A"
        ],
        "statement": "lemma func1_1_L1B: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"Y\\<subseteq>Z\"\n  shows \"f:X\\<rightarrow>Z\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<forall>x\\<in>X. f`(x) \\<in> Z\"\n    using apply_funtype by auto\n  with A1 show  \"f:X\\<rightarrow>Z\" using func1_1_L1A by blast\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2552
    },
    "2298": {
        "type": "lemma",
        "text": "text\\<open>There is a value for each argument.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\"  \"x\\<in>X\" \n  ",
        "using": [
            "apply_type",
            "apply_Pair"
        ],
        "statement": "lemma func1_1_L2: assumes A1: \"f:X\\<rightarrow>Y\"  \"x\\<in>X\" \n  shows \"\\<exists>y\\<in>Y. \\<langle>x,y\\<rangle> \\<in> f\"  \n",
        "proof": "proof-\n  from A1 have \"f`(x) \\<in> Y\" using apply_type by simp\n  moreover from A1 have \"\\<langle> x,f`(x)\\<rangle>\\<in> f\" using apply_Pair by simp\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2553
    },
    "2299": {
        "type": "lemma",
        "text": "text\\<open>The image is the inverse image of converse.\\<close>\n",
        "assumes": "",
        "using": [
            "vimage_iff",
            "image_iff",
            "converse_iff"
        ],
        "statement": "lemma image_converse: shows \"converse(r)-``(A) = r``(A)\"\n  ",
        "proof": "using vimage_iff image_iff converse_iff by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2555
    },
    "2300": {
        "type": "lemma",
        "text": "text\\<open>The inverse image by a composition is the composition of inverse images.\\<close>\n",
        "assumes": "",
        "using": [
            "vimage_converse",
            "converse_comp",
            "image_comp",
            "image_converse"
        ],
        "statement": "lemma vimage_comp: shows \"(r O s)-``(A) = s-``(r-``(A))\"\n  ",
        "proof": "using vimage_converse converse_comp image_comp image_converse by simp \n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2556
    },
    "2301": {
        "type": "lemma",
        "text": "text\\<open>A version of \\<open>vimage_comp\\<close> for three functions.\\<close>\n",
        "assumes": "",
        "using": [
            "vimage_comp"
        ],
        "statement": "lemma vimage_comp3: shows \"(r O s O t)-``(A) = t-``(s-``(r-``(A)))\"\n  ",
        "proof": "using vimage_comp by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2557
    },
    "2302": {
        "type": "lemma",
        "text": "text\\<open>Inverse image of any set is contained in the domain.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" ",
        "using": [
            "vimage_iff",
            "domain_iff",
            "func1_1_L1"
        ],
        "statement": "lemma func1_1_L3: assumes A1: \"f:X\\<rightarrow>Y\" shows \"f-``(D) \\<subseteq> X\"\n",
        "proof": "proof-\n   have \"\\<forall>x. x\\<in>f-``(D) \\<longrightarrow> x \\<in> domain(f)\"\n      using  vimage_iff domain_iff by auto\n    with A1 have \"\\<forall>x. (x \\<in> f-``(D)) \\<longrightarrow> (x\\<in>X)\" using func1_1_L1 by simp\n    then show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2558
    },
    "2303": {
        "type": "lemma",
        "text": "text\\<open>The arguments belongs to the domain and values to the range.\\<close>\n",
        "assumes": "assumes A1: \"\\<langle> x,y\\<rangle> \\<in> f\" and A2: \"f:X\\<rightarrow>Y\"  \n  ",
        "using": [
            "apply_iff",
            "apply_type"
        ],
        "statement": "lemma func1_1_L5: \n  assumes A1: \"\\<langle> x,y\\<rangle> \\<in> f\" and A2: \"f:X\\<rightarrow>Y\"  \n  shows \"x\\<in>X \\<and> y\\<in>Y\" \n",
        "proof": "proof\n  from A1 A2 show \"x\\<in>X\" using apply_iff by simp\n  with A2 have \"f`(x)\\<in> Y\" using apply_type by simp\n  with A1 A2 show \"y\\<in>Y\" using apply_iff by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2560
    },
    "2304": {
        "type": "lemma",
        "text": "text\\<open>Function is a subset of cartesian product.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" ",
        "using": [
            "Pi_memberD",
            "func1_1_L5"
        ],
        "statement": "lemma fun_subset_prod: assumes A1: \"f:X\\<rightarrow>Y\" shows \"f \\<subseteq> X\\<times>Y\"\n",
        "proof": "proof\n  fix p assume \"p \\<in> f\"\n  with A1 have \"\\<exists>x\\<in>X. p = \\<langle>x, f`(x)\\<rangle>\"\n    using Pi_memberD by simp\n  then obtain x where I: \"p = \\<langle>x, f`(x)\\<rangle>\"\n    by auto\n  with A1 \\<open>p \\<in> f\\<close> have \"x\\<in>X \\<and> f`(x) \\<in> Y\"\n    using func1_1_L5 by blast\n  with I show \"p \\<in> X\\<times>Y\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2561
    },
    "2305": {
        "type": "lemma",
        "text": "text\\<open>The (argument, value) pair belongs to the graph of the function.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\"  \"x\\<in>X\"  \"y = f`(x)\"\n  ",
        "using": [
            "apply_Pair",
            "rangeI"
        ],
        "statement": "lemma func1_1_L5A: \n  assumes A1: \"f:X\\<rightarrow>Y\"  \"x\\<in>X\"  \"y = f`(x)\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> f\"  \"y \\<in> range(f)\" \n",
        "proof": "proof -\n  from A1 show \"\\<langle>x,y\\<rangle> \\<in> f\" using apply_Pair by simp\n  then show \"y \\<in> range(f)\" using rangeI by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2562
    },
    "2306": {
        "type": "theorem",
        "text": "text\\<open>The next theorem illustrates the meaning of the concept of \n  function in ZF.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "func1_1_L5A",
            "fun_subset_prod",
            "apply_equality"
        ],
        "statement": "theorem fun_is_set_of_pairs: assumes A1: \"f:X\\<rightarrow>Y\"\n  shows \"f = {\\<langle>x, f`(x)\\<rangle>. x \\<in> X}\"\n",
        "proof": "proof\n  from A1 show \"{\\<langle>x, f`(x)\\<rangle>. x \\<in> X} \\<subseteq> f\" using func1_1_L5A\n    by auto\nnext\n  { fix p assume \"p \\<in> f\"\n    with A1 have \"p \\<in> X\\<times>Y\" using fun_subset_prod\n      by auto\n    with A1 \\<open>p \\<in> f\\<close> have \"p \\<in> {\\<langle>x, f`(x)\\<rangle>. x \\<in> X}\" \n      using apply_equality by auto\n  } thus \"f \\<subseteq> {\\<langle>x, f`(x)\\<rangle>. x \\<in> X}\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2563
    },
    "2307": {
        "type": "lemma",
        "text": "text\\<open>The range of function that maps $X$ into $Y$ is contained in $Y$.\\<close>\n",
        "assumes": "assumes  A1: \"f:X\\<rightarrow>Y\" ",
        "using": [
            "range_def",
            "converse_def",
            "domain_def",
            "func1_1_L5"
        ],
        "statement": "lemma func1_1_L5B: \n  assumes  A1: \"f:X\\<rightarrow>Y\" shows \"range(f) \\<subseteq> Y\"\n",
        "proof": "proof\n  fix y assume \"y \\<in> range(f)\"\n  then obtain x where \"\\<langle> x,y\\<rangle> \\<in> f\"\n    using range_def converse_def domain_def by auto\n  with A1 show \"y\\<in>Y\" using func1_1_L5 by blast\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2564
    },
    "2308": {
        "type": "lemma",
        "text": "text\\<open>The image of any set is contained in the range.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" \n  ",
        "using": [
            "image_iff",
            "rangeI",
            "func1_1_L5B"
        ],
        "statement": "lemma func1_1_L6: assumes A1: \"f:X\\<rightarrow>Y\" \n  shows \"f``(B) \\<subseteq> range(f)\" and \"f``(B) \\<subseteq> Y\"\n",
        "proof": "proof -\n  show \"f``(B) \\<subseteq> range(f)\" using image_iff rangeI by auto\n  with A1 show \"f``(B) \\<subseteq> Y\" using func1_1_L5B by blast\nqed  \n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2565
    },
    "2309": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of any set is contained in the domain.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" ",
        "using": [
            "vimage_iff",
            "func1_1_L5"
        ],
        "statement": "lemma func1_1_L6A: assumes A1: \"f:X\\<rightarrow>Y\" shows \"f-``(A)\\<subseteq>X\"\n",
        "proof": "proof\n  fix x\n  assume A2: \"x\\<in>f-``(A)\" then obtain y where \"\\<langle> x,y\\<rangle> \\<in> f\" \n    using vimage_iff by auto\n  with A1 show  \"x\\<in>X\" using func1_1_L5 by fast\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2566
    },
    "2310": {
        "type": "lemma",
        "text": "text\\<open>Image of a greater set is greater.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>B\"  ",
        "using": [
            "assms",
            "image_Un"
        ],
        "statement": "lemma func1_1_L8: assumes A1: \"A\\<subseteq>B\"  shows \"f``(A)\\<subseteq> f``(B)\"\n  ",
        "proof": "using assms image_Un by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2567
    },
    "2311": {
        "type": "lemma",
        "text": "text\\<open>A set is contained in the the inverse image of its image.\n  There is similar theorem in \\<open>equalities.thy\\<close>\n  (\\<open>function_image_vimage\\<close>)\n  which shows that the image of inverse image of a set \n  is contained in the set.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  ",
        "using": [
            "apply_Pair",
            "image_iff"
        ],
        "statement": "lemma func1_1_L9: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  shows \"A \\<subseteq> f-``(f``(A))\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<forall>x\\<in>A. \\<langle> x,f`(x)\\<rangle> \\<in> f\"  using apply_Pair by auto\n  then show ?thesis using image_iff by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2568
    },
    "2312": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of the image of the domain is the domain.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" ",
        "using": [
            "func1_1_L3",
            "func1_1_L9"
        ],
        "statement": "lemma inv_im_dom: assumes A1: \"f:X\\<rightarrow>Y\" shows \"f-``(f``(X)) = X\"\n",
        "proof": "proof\n  from A1 show \"f-``(f``(X)) \\<subseteq> X\" using func1_1_L3 by simp\n  from A1 show \"X \\<subseteq> f-``(f``(X))\" using func1_1_L9 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2569
    },
    "2313": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma needed to make the \\<open>func1_1_L11\\<close> \n  proof more clear.\\<close>\n",
        "assumes": "assumes A1: \"f \\<subseteq> X\\<times>Y\" and A2: \"\\<exists>!y. (y\\<in>Y \\<and> \\<langle>x,y\\<rangle> \\<in> f)\"\n  ",
        "using": [],
        "statement": "lemma func1_1_L10: \n  assumes A1: \"f \\<subseteq> X\\<times>Y\" and A2: \"\\<exists>!y. (y\\<in>Y \\<and> \\<langle>x,y\\<rangle> \\<in> f)\"\n  shows \"\\<exists>!y. \\<langle>x,y\\<rangle> \\<in> f\"\n",
        "proof": "proof\n  from A2 show \"\\<exists>y. \\<langle>x, y\\<rangle> \\<in> f\" by auto\n  fix y n assume \"\\<langle>x,y\\<rangle> \\<in> f\" and \"\\<langle>x,n\\<rangle> \\<in> f\"\n  with A1 A2 show \"y=n\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2570
    },
    "2314": {
        "type": "lemma",
        "text": "text\\<open>If $f\\subseteq X\\times Y$ and for every $x\\in X$ there is exactly \none $y\\in Y$ such that $(x,y)\\in f$ then $f$ maps $X$ to $Y$.\\<close>\n",
        "assumes": "assumes \"f \\<subseteq> X\\<times>Y\" and \"\\<forall>x\\<in>X. \\<exists>!y. y\\<in>Y \\<and> \\<langle>x,y\\<rangle> \\<in> f\"\n  ",
        "using": [
            "assms",
            "func1_1_L10",
            "Pi_iff_old"
        ],
        "statement": "lemma func1_1_L11: \n  assumes \"f \\<subseteq> X\\<times>Y\" and \"\\<forall>x\\<in>X. \\<exists>!y. y\\<in>Y \\<and> \\<langle>x,y\\<rangle> \\<in> f\"\n  shows \"f: X\\<rightarrow>Y\" ",
        "proof": "using assms func1_1_L10 Pi_iff_old by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2571
    },
    "2315": {
        "type": "lemma",
        "text": "text\\<open>The next lemma will replace \\<open>func1_1_L11A\\<close> one day.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>X. b(x) \\<in> Y\"\n  ",
        "using": [
            "func1_1_L11"
        ],
        "statement": "lemma ZF_fun_from_total: assumes A1: \"\\<forall>x\\<in>X. b(x) \\<in> Y\"\n  shows \"{\\<langle>x,b(x)\\<rangle>. x\\<in>X} : X\\<rightarrow>Y\"\n",
        "proof": "proof -\n  let ?f = \"{\\<langle>x,b(x)\\<rangle>. x\\<in>X}\"\n  { fix x assume A2: \"x\\<in>X\"\n    have \"\\<exists>!y. y\\<in>Y \\<and> \\<langle>x, y\\<rangle> \\<in> ?f\"\n    proof\n\tfrom A1 A2 show \"\\<exists>y. y\\<in>Y \\<and> \\<langle>x, y\\<rangle> \\<in> ?f\"\n\tby simp\n    next fix y y1 assume \"y\\<in>Y \\<and> \\<langle>x, y\\<rangle> \\<in> ?f\"\n\tand \"y1\\<in>Y \\<and> \\<langle>x, y1\\<rangle> \\<in> ?f\"\n      then show \"y = y1\" by simp\n    qed\n  } then have \"\\<forall>x\\<in>X. \\<exists>!y. y\\<in>Y \\<and> \\<langle> x,y\\<rangle> \\<in> ?f\"\n    by simp\n  moreover from A1 have \"?f \\<subseteq> X\\<times>Y\" by auto\n  ultimately show ?thesis using func1_1_L11\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2573
    },
    "2316": {
        "type": "lemma",
        "text": "text\\<open>The value of a function defined by a meta-function is this \n  meta-function (deprecated, use \\<open>ZF_fun_from_tot_val(1)\\<close> instead).\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\"   \"x\\<in>X\"\n  and A2: \"f = {\\<langle>x,y\\<rangle> \\<in> X\\<times>Y. b(x) = y}\"\n  ",
        "using": [
            "apply_iff"
        ],
        "statement": "lemma func1_1_L11B: \n  assumes A1: \"f:X\\<rightarrow>Y\"   \"x\\<in>X\"\n  and A2: \"f = {\\<langle>x,y\\<rangle> \\<in> X\\<times>Y. b(x) = y}\"\n  shows \"f`(x) = b(x)\"\n",
        "proof": "proof -\n  from A1 have \"\\<langle> x,f`(x)\\<rangle> \\<in> f\" using apply_iff by simp\n  with A2 show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2574
    },
    "2317": {
        "type": "lemma",
        "text": "text\\<open>Identical meaning as \\<open>ZF_fun_from_tot_val\\<close>, but\n  phrased a bit differently.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" and \"f = {\\<langle>x,b(x)\\<rangle>. x\\<in>X}\"\n  ",
        "using": [
            "assms",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma ZF_fun_from_tot_val0: \n  assumes \"f:X\\<rightarrow>Y\" and \"f = {\\<langle>x,b(x)\\<rangle>. x\\<in>X}\"\n  shows \"\\<forall>x\\<in>X. f`(x) = b(x)\"\n  ",
        "proof": "using assms ZF_fun_from_tot_val by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2576
    },
    "2318": {
        "type": "lemma",
        "text": "text\\<open>Another way of expressing that lambda expression is a function.\\<close>\n",
        "assumes": "assumes \"f={\\<langle>x,g(x)\\<rangle>. x\\<in>X}\"\n  ",
        "using": [],
        "statement": "lemma lam_is_fun_range: assumes \"f={\\<langle>x,g(x)\\<rangle>. x\\<in>X}\"\n  shows \"f:X\\<rightarrow>range(f)\"\n",
        "proof": "proof -\n  have \"\\<forall>x\\<in>X. g(x) \\<in> range({\\<langle>x,g(x)\\<rangle>. x\\<in>X})\" unfolding range_def \n    by auto\n  then have \"{\\<langle>x,g(x)\\<rangle>. x\\<in>X} : X\\<rightarrow>range({\\<langle>x,g(x)\\<rangle>. x\\<in>X})\" by (rule ZF_fun_from_total)\n  with assms show ?thesis by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2577
    },
    "2319": {
        "type": "lemma",
        "text": "text\\<open>Yet another way of expressing value of a function.\\<close>\n",
        "assumes": "assumes \"x\\<in>X\" ",
        "using": [
            "lam_is_fun_range",
            "ZF_fun_from_tot_val0"
        ],
        "statement": "lemma ZF_fun_from_tot_val1:\n  assumes \"x\\<in>X\" shows \"{\\<langle>x,b(x)\\<rangle>. x\\<in>X}`(x)=b(x)\"\n",
        "proof": "proof -\n  let ?f = \"{\\<langle>x,b(x)\\<rangle>. x\\<in>X}\"\n  have \"?f:X\\<rightarrow>range(?f)\" using lam_is_fun_range by simp\n  with assms show ?thesis using ZF_fun_from_tot_val0 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2578
    },
    "2320": {
        "type": "lemma",
        "text": "text\\<open>An hypotheses-free form of \\<open>ZF_fun_from_tot_val1\\<close>: the value of a function\n  $X\\ni x \\mapsto p(x)$ is $p(x)$ for all $x\\in X$. \\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma ZF_fun_from_tot_val2: shows \"\\<forall>x\\<in>X. {\\<langle>x,b(x)\\<rangle>. x\\<in>X}`(x) = b(x)\"\n  ",
        "proof": "using ZF_fun_from_tot_val1 by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2579
    },
    "2321": {
        "type": "lemma",
        "text": "text\\<open>The range of a function defined by set comprehension is the set of its values.\"\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma range_fun: shows \"range({\\<langle>x,b(x)\\<rangle>. x\\<in>X}) = {b(x). x\\<in>X}\" \n  by blast\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2580
    },
    "2322": {
        "type": "lemma",
        "text": "text\\<open>In Isabelle/ZF and Metamath if $x$ is not in the domain of a function $f$\n  then $f(x)$ is the empty set. This allows us to conclude that if $y\\in f(x)$, then\n  $x$ must be en element of the domain of $f$. \\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \"y\\<in>f`(x)\" ",
        "using": [
            "func1_1_L1",
            "apply_0"
        ],
        "statement": "lemma arg_in_domain: assumes \"f:X\\<rightarrow>Y\" \"y\\<in>f`(x)\" shows \"x\\<in>X\"\n",
        "proof": "proof -\n  { assume \"x\\<notin>X\"\n    with assms have False using func1_1_L1 apply_0 by simp\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2581
    },
    "2323": {
        "type": "lemma",
        "text": "text\\<open>We can extend a function by specifying its values on a set\n  disjoint with the domain.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"\\<forall>x\\<in>A. b(x)\\<in>B\"\n  and A3: \"X\\<inter>A = 0\" and Dg: \"g = f \\<union> {\\<langle>x,b(x)\\<rangle>. x\\<in>A}\"\n  ",
        "using": [
            "ZF_fun_from_total",
            "func1_1_L1",
            "fun_disjoint_apply2",
            "ZF_fun_from_tot_val",
            "fun_disjoint_apply1"
        ],
        "statement": "lemma func1_1_L11C: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"\\<forall>x\\<in>A. b(x)\\<in>B\"\n  and A3: \"X\\<inter>A = 0\" and Dg: \"g = f \\<union> {\\<langle>x,b(x)\\<rangle>. x\\<in>A}\"\n  shows \n  \"g : X\\<union>A \\<rightarrow> Y\\<union>B\"\n  \"\\<forall>x\\<in>X. g`(x) = f`(x)\"\n  \"\\<forall>x\\<in>A. g`(x) = b(x)\"\n",
        "proof": "proof -\n  let ?h = \"{\\<langle>x,b(x)\\<rangle>. x\\<in>A}\"\n  from A1 A2 A3 have \n    I: \"f:X\\<rightarrow>Y\"  \"?h : A\\<rightarrow>B\"  \"X\\<inter>A = 0\"\n    using ZF_fun_from_total by auto\n  then have \"f\\<union>?h : X\\<union>A \\<rightarrow> Y\\<union>B\"\n    by (rule fun_disjoint_Un)\n  with Dg show \"g : X\\<union>A \\<rightarrow> Y\\<union>B\" by simp\n  { fix x assume A4: \"x\\<in>A\"\n    with A1 A3 have \"(f\\<union>?h)`(x) = ?h`(x)\"\n      using func1_1_L1 fun_disjoint_apply2\n      by blast\n    moreover from I A4 have \"?h`(x) = b(x)\"\n      using ZF_fun_from_tot_val by simp\n    ultimately have \"(f\\<union>?h)`(x) = b(x)\"\n      by simp\n  } with Dg show \"\\<forall>x\\<in>A. g`(x) = b(x)\" by simp\n  { fix x assume A5: \"x\\<in>X\"\n    with A3 I have \"x \\<notin> domain(?h)\"\n      using func1_1_L1 by auto\n    then have \"(f\\<union>?h)`(x) = f`(x)\"\n      using fun_disjoint_apply1 by simp\n  } with Dg show \"\\<forall>x\\<in>X. g`(x) = f`(x)\" by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2582
    },
    "2324": {
        "type": "lemma",
        "text": "text\\<open>We can extend a function by specifying its value at a point that\n  does not belong to the domain.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"a\\<notin>X\"\n  and Dg: \"g = f \\<union> {\\<langle>a,b\\<rangle>}\"\n  ",
        "using": [],
        "statement": "lemma func1_1_L11D: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"a\\<notin>X\"\n  and Dg: \"g = f \\<union> {\\<langle>a,b\\<rangle>}\"\n  shows \n  \"g : X\\<union>{a} \\<rightarrow> Y\\<union>{b}\"\n  \"\\<forall>x\\<in>X. g`(x) = f`(x)\"\n  \"g`(a) = b\"\n",
        "proof": "proof -\n  let ?h = \"{\\<langle>a,b\\<rangle>}\"\n  from A1 A2 Dg have I:\n    \"f:X\\<rightarrow>Y\"  \"\\<forall>x\\<in>{a}. b\\<in>{b}\"  \"X\\<inter>{a} = 0\"  \"g = f \\<union> {\\<langle>x,b\\<rangle>. x\\<in>{a}}\"\n    by auto\n  then show \"g : X\\<union>{a} \\<rightarrow> Y\\<union>{b}\"\n    by (rule func1_1_L11C)\n  from I show \"\\<forall>x\\<in>X. g`(x) = f`(x)\"\n    by (rule func1_1_L11C)\n  from I have \"\\<forall>x\\<in>{a}. g`(x) = b\"\n    by (rule func1_1_L11C)\n  then show \"g`(a) = b\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2583
    },
    "2325": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about extending a function both by defining\n  on a set disjoint with the domain and on a point that does not belong\n  to any of those sets.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and \n  A2: \"\\<forall>x\\<in>A. b(x)\\<in>B\" and \n  A3: \"X\\<inter>A = 0\" and A4: \"a\\<notin> X\\<union>A\"\n  and Dg: \"g = f \\<union> {\\<langle>x,b(x)\\<rangle>. x\\<in>A} \\<union> {\\<langle>a,c\\<rangle>}\"\n  ",
        "using": [
            "func1_1_L11C",
            "func1_1_L11D"
        ],
        "statement": "lemma func1_1_L11E:\n  assumes A1: \"f:X\\<rightarrow>Y\" and \n  A2: \"\\<forall>x\\<in>A. b(x)\\<in>B\" and \n  A3: \"X\\<inter>A = 0\" and A4: \"a\\<notin> X\\<union>A\"\n  and Dg: \"g = f \\<union> {\\<langle>x,b(x)\\<rangle>. x\\<in>A} \\<union> {\\<langle>a,c\\<rangle>}\"\n  shows\n  \"g : X\\<union>A\\<union>{a} \\<rightarrow> Y\\<union>B\\<union>{c}\"\n  \"\\<forall>x\\<in>X. g`(x) = f`(x)\"\n  \"\\<forall>x\\<in>A. g`(x) = b(x)\"\n  \"g`(a) = c\"\n",
        "proof": "proof -\n  let ?h = \"f \\<union> {\\<langle>x,b(x)\\<rangle>. x\\<in>A}\"\n  from assms show \"g : X\\<union>A\\<union>{a} \\<rightarrow> Y\\<union>B\\<union>{c}\"\n    using func1_1_L11C func1_1_L11D by simp\n  from A1 A2 A3 have I:\n    \"f:X\\<rightarrow>Y\"  \"\\<forall>x\\<in>A. b(x)\\<in>B\"  \"X\\<inter>A = 0\"  \"?h = f \\<union> {\\<langle>x,b(x)\\<rangle>. x\\<in>A}\"\n    by auto\n  from assms have \n    II: \"?h : X\\<union>A \\<rightarrow> Y\\<union>B\"  \"a\\<notin> X\\<union>A\"  \"g = ?h \\<union> {\\<langle>a,c\\<rangle>}\"\n    using func1_1_L11C by auto\n  then have III: \"\\<forall>x\\<in>X\\<union>A. g`(x) = ?h`(x)\" by (rule func1_1_L11D)\n  moreover from I have  \"\\<forall>x\\<in>X. ?h`(x) = f`(x)\"\n    by (rule func1_1_L11C)\n  ultimately show \"\\<forall>x\\<in>X. g`(x) = f`(x)\" by simp\n  from I have \"\\<forall>x\\<in>A. ?h`(x) = b(x)\" by (rule func1_1_L11C)\n  with III show \"\\<forall>x\\<in>A. g`(x) = b(x)\" by simp\n  from II show \"g`(a) = c\" by (rule func1_1_L11D)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2584
    },
    "2326": {
        "type": "lemma",
        "text": "text\\<open>A way of defining a function on a union of two possibly overlapping sets. We decompose the \nunion into two differences and the intersection and define a function separately on each part.\\<close>\n",
        "assumes": "assumes \"\\<forall>x\\<in>A\\<inter>B. h(x) \\<in> Y\"  \"\\<forall>x\\<in>A-B. f(x) \\<in> Y\"  \"\\<forall>x\\<in>B-A. g(x) \\<in> Y\"\n  ",
        "using": [],
        "statement": "lemma fun_union_overlap: assumes \"\\<forall>x\\<in>A\\<inter>B. h(x) \\<in> Y\"  \"\\<forall>x\\<in>A-B. f(x) \\<in> Y\"  \"\\<forall>x\\<in>B-A. g(x) \\<in> Y\"\n  shows \"{\\<langle>x,if x\\<in>A-B then f(x) else if x\\<in>B-A then g(x) else h(x)\\<rangle>. x \\<in> A\\<union>B}: A\\<union>B \\<rightarrow> Y\"\n",
        "proof": "proof -\n  let ?F = \"{\\<langle>x,if x\\<in>A-B then f(x) else if x\\<in>B-A then g(x) else h(x)\\<rangle>. x \\<in> A\\<inter>B}\"\n  from assms have \"\\<forall>x\\<in>A\\<union>B. (if x\\<in>A-B then f(x) else if x\\<in>B-A then g(x) else h(x)) \\<in> Y\"\n    by auto\n  then show ?thesis by (rule ZF_fun_from_total)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2585
    },
    "2327": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of an intersection of a nonempty collection of sets \n  is the intersection of the \n  inverse images. This generalizes \\<open>invim_inter_inter_invim\\<close> \n  which is proven for the case of two sets.\\<close>\n",
        "assumes": "assumes A1: \"B \\<subseteq> Pow(Y)\" and A2: \"B\\<noteq>0\" and A3: \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "func1_1_L6A",
            "Pi_iff_old",
            "vimage_iff"
        ],
        "statement": "lemma func1_1_L12:\n  assumes A1: \"B \\<subseteq> Pow(Y)\" and A2: \"B\\<noteq>0\" and A3: \"f:X\\<rightarrow>Y\"\n  shows \"f-``(\\<Inter>B) = (\\<Inter>U\\<in>B. f-``(U))\"\n",
        "proof": "proof\n  from A2 show  \"f-``(\\<Inter>B) \\<subseteq> (\\<Inter>U\\<in>B. f-``(U))\" by blast\n  show \"(\\<Inter>U\\<in>B. f-``(U)) \\<subseteq> f-``(\\<Inter>B)\"\n  proof\n    fix x assume A4: \"x \\<in> (\\<Inter>U\\<in>B. f-``(U))\"\n    from A3 have \"\\<forall>U\\<in>B. f-``(U) \\<subseteq> X\" using func1_1_L6A by simp\n    with A4 have \"\\<forall>U\\<in>B. x\\<in>X\" by auto\n    with A2 have \"x\\<in>X\" by auto\n    with A3 have \"\\<exists>!y. \\<langle> x,y\\<rangle> \\<in> f\" using Pi_iff_old by simp\n    with A2 A4 show \"x \\<in> f-``(\\<Inter>B)\" using vimage_iff by blast\n  qed\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2587
    },
    "2328": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of a set does not change when we intersect\n  the set with the image of the domain.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \n  ",
        "using": [
            "assms",
            "invim_inter_inter_invim",
            "inv_im_dom",
            "func1_1_L6A"
        ],
        "statement": "lemma inv_im_inter_im: assumes \"f:X\\<rightarrow>Y\" \n  shows \"f-``(A \\<inter> f``(X)) = f-``(A)\"\n  ",
        "proof": "using assms invim_inter_inter_invim inv_im_dom func1_1_L6A\n  by blast\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2588
    },
    "2329": {
        "type": "lemma",
        "text": "text\\<open>If the inverse image of a set is not empty, then the set is not empty.\n  Proof by contradiction.\\<close>\n",
        "assumes": "assumes A1:\"f-``(A) \\<noteq> 0\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma func1_1_L13: assumes A1:\"f-``(A) \\<noteq> 0\" shows \"A\\<noteq>0\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2589
    },
    "2330": {
        "type": "lemma",
        "text": "text\\<open>If the image of a set is not empty, then the set is not empty.\n  Proof by contradiction.\\<close>\n",
        "assumes": "assumes A1: \"f``(A)\\<noteq>0\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma func1_1_L13A: assumes A1: \"f``(A)\\<noteq>0\" shows \"A\\<noteq>0\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2590
    },
    "2331": {
        "type": "lemma",
        "text": "text\\<open>What is the inverse image of a singleton?\\<close>\n",
        "assumes": "assumes \"f\\<in>X\\<rightarrow>Y\" \n  ",
        "using": [
            "assms",
            "func1_1_L6A",
            "vimage_singleton_iff",
            "apply_iff"
        ],
        "statement": "lemma func1_1_L14: assumes \"f\\<in>X\\<rightarrow>Y\" \n  shows \"f-``({y}) = {x\\<in>X. f`(x) = y}\" \n  ",
        "proof": "using assms func1_1_L6A vimage_singleton_iff apply_iff by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2591
    },
    "2332": {
        "type": "lemma",
        "text": "text\\<open>A lemma that can be used instead \\<open>fun_extension_iff\\<close>\n  to show that two functions are equal\\<close>\n",
        "assumes": "assumes \"f: X\\<rightarrow>Y\"  \"g: X\\<rightarrow>Z\"and  \"\\<forall>x\\<in>X. f`(x) = g`(x)\"\n  ",
        "using": [
            "assms",
            "fun_extension_iff"
        ],
        "statement": "lemma func_eq: \n  assumes \"f: X\\<rightarrow>Y\"  \"g: X\\<rightarrow>Z\"and  \"\\<forall>x\\<in>X. f`(x) = g`(x)\"\n  shows \"f = g\" ",
        "proof": "using assms fun_extension_iff by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2592
    },
    "2333": {
        "type": "lemma",
        "text": "text\\<open>An alternative syntax for defining a function: instead of writing \n  $\\{\\langle x,p(x)\\rangle. x\\in X\\}$ we can write $\\lambda x\\in X. p(x)$. \\<close>\n",
        "assumes": "",
        "using": [
            "lam_is_fun_range",
            "range_fun",
            "lam_funtype",
            "ZF_fun_from_tot_val1",
            "beta",
            "func_eq"
        ],
        "statement": "lemma lambda_fun_alt: shows \"{\\<langle>x,p(x)\\<rangle>. x\\<in>X} = (\\<lambda>x\\<in>X. p(x))\"\n",
        "proof": "proof -\n  let ?L = \"{\\<langle>x,p(x)\\<rangle>. x\\<in>X}\" \n  let ?R = \"\\<lambda>x\\<in>X. p(x)\"\n  have \"?L:X\\<rightarrow>range(?L)\" and \"?R:X\\<rightarrow>range(?L)\" \n    using lam_is_fun_range range_fun lam_funtype by simp_all\n  moreover have \"\\<forall>x\\<in>X. ?L`(x) = ?R`(x)\" using ZF_fun_from_tot_val1 beta by simp\n  ultimately show \"?L = ?R\" using func_eq by blast\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2593
    },
    "2334": {
        "type": "lemma",
        "text": "text\\<open>Function defined on a singleton is a single pair.\\<close>\n",
        "assumes": "assumes A1: \"f : {a}\\<rightarrow>X\"\n  ",
        "using": [
            "singleton_fun",
            "singleton_apply"
        ],
        "statement": "lemma func_singleton_pair: assumes A1: \"f : {a}\\<rightarrow>X\"\n  shows \"f = {\\<langle>a, f`(a)\\<rangle>}\"\n",
        "proof": "proof -\n  let ?g = \"{\\<langle>a, f`(a)\\<rangle>}\"\n  note A1\n  moreover have \"?g : {a} \\<rightarrow> {f`(a)}\" using singleton_fun by simp\n  moreover have \"\\<forall>x \\<in> {a}. f`(x) = ?g`(x)\" using singleton_apply\n    by simp\n  ultimately show \"f = ?g\" by (rule func_eq)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2595
    },
    "2335": {
        "type": "lemma",
        "text": "text\\<open>A single pair is a function on a singleton. This is\n  similar to \\<open>singleton_fun\\<close> from standard Isabelle/ZF.\\<close>\n",
        "assumes": "assumes A1: \"y \\<in> Y\"\n  ",
        "using": [
            "singleton_fun"
        ],
        "statement": "lemma pair_func_singleton: assumes A1: \"y \\<in> Y\"\n  shows \"{\\<langle>x,y\\<rangle>} : {x} \\<rightarrow> Y\"\n",
        "proof": "proof -\n  have \"{\\<langle>x,y\\<rangle>} : {x} \\<rightarrow> {y}\" using singleton_fun by simp\n  moreover from A1 have \"{y} \\<subseteq> Y\" by simp\n  ultimately show \"{\\<langle>x,y\\<rangle>} : {x} \\<rightarrow> Y\"\n    by (rule func1_1_L1B)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2596
    },
    "2336": {
        "type": "lemma",
        "text": "text\\<open>The value of a pair on the first element is the second one.\\<close>\n",
        "assumes": "",
        "using": [
            "singleton_fun",
            "apply_equality"
        ],
        "statement": "lemma pair_val: shows \"{\\<langle>x,y\\<rangle>}`(x) = y\"\n  ",
        "proof": "using singleton_fun apply_equality by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2597
    },
    "2337": {
        "type": "lemma",
        "text": "text\\<open>A more familiar definition of image.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  ",
        "using": [
            "image_iff",
            "apply_iff"
        ],
        "statement": "lemma func_imagedef: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  shows \"f``(A) = {f`(x). x \\<in> A}\"\n",
        "proof": "proof\n  from A1 show \"f``(A) \\<subseteq> {f`(x). x \\<in> A}\"\n    using image_iff apply_iff by auto\n  show \"{f`(x). x \\<in> A} \\<subseteq> f``(A)\"\n  proof\n    fix y assume \"y \\<in> {f`(x). x \\<in> A}\"\n    then obtain x where \"x\\<in>A\" and  \"y = f`(x)\"\n      by auto\n    with A1 A2 have \"\\<langle>x,y\\<rangle> \\<in> f\" using apply_iff by force  \n    with A1 A2 \\<open>x\\<in>A\\<close> show \"y \\<in> f``(A)\" using image_iff by auto\n  qed\nqed  \n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2599
    },
    "2338": {
        "type": "lemma",
        "text": "text\\<open> For two functions with the same domain $X$ and the codomain $Y,Z$ resp., we can define\n  a third one that maps $X$ to the cartesian product of $Y$ and $Z$. \\<close>\n",
        "assumes": "assumes \"{\\<langle>x,p(x)\\<rangle>. x\\<in>X}: X\\<rightarrow>Y\" \"{\\<langle>x,q(x)\\<rangle>. x\\<in>X}: X\\<rightarrow>Z\"\n  defines \"h \\<equiv> {\\<langle>x,\\<langle>p(x),q(x)\\<rangle>\\<rangle>. x\\<in>X}\"\n  ",
        "using": [
            "ZF_fun_from_tot_val(2)",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val0"
        ],
        "statement": "lemma prod_fun_val: \n  assumes \"{\\<langle>x,p(x)\\<rangle>. x\\<in>X}: X\\<rightarrow>Y\" \"{\\<langle>x,q(x)\\<rangle>. x\\<in>X}: X\\<rightarrow>Z\"\n  defines \"h \\<equiv> {\\<langle>x,\\<langle>p(x),q(x)\\<rangle>\\<rangle>. x\\<in>X}\"\n  shows \"h:X\\<rightarrow>Y\\<times>Z\" and \"\\<forall>x\\<in>X. h`(x) = \\<langle>p(x),q(x)\\<rangle>\"\n",
        "proof": "proof -\n  from assms(1,2) have \"\\<forall>x\\<in>X. \\<langle>p(x),q(x)\\<rangle> \\<in> Y\\<times>Z\"\n    using ZF_fun_from_tot_val(2) by auto\n  with assms(3) show \"h:X\\<rightarrow>Y\\<times>Z\" using ZF_fun_from_total by simp\n  with assms(3) show \"\\<forall>x\\<in>X. h`(x) = \\<langle>p(x),q(x)\\<rangle>\" using ZF_fun_from_tot_val0\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2601
    },
    "2339": {
        "type": "lemma",
        "text": "text\\<open>The image of a set contained in domain under identity is the same set.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\" ",
        "using": [
            "assms",
            "id_type",
            "id_conv"
        ],
        "statement": "lemma image_id_same: assumes \"A\\<subseteq>X\" shows \"id(X)``(A) = A\"\n  ",
        "proof": "using assms id_type id_conv by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2603
    },
    "2340": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of a set contained in domain under identity is the same set.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\" ",
        "using": [
            "assms",
            "id_type",
            "id_conv"
        ],
        "statement": "lemma vimage_id_same: assumes \"A\\<subseteq>X\" shows \"id(X)-``(A) = A\"\n  ",
        "proof": "using assms id_type id_conv by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2604
    },
    "2341": {
        "type": "lemma",
        "text": "text\\<open>If an element of the domain of a function belongs to a set, \n  then its value belongs to the image of that set.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\"  \"x\\<in>A\"  \"A\\<subseteq>X\"\n  ",
        "using": [
            "assms",
            "func_imagedef"
        ],
        "statement": "lemma func1_1_L15D: assumes \"f:X\\<rightarrow>Y\"  \"x\\<in>A\"  \"A\\<subseteq>X\"\n  shows \"f`(x) \\<in> f``(A)\"\n  ",
        "proof": "using assms func_imagedef by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2606
    },
    "2342": {
        "type": "lemma",
        "text": "text\\<open>The difference of images is contained in the image of difference.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  ",
        "using": [
            "func_imagedef",
            "func1_1_L15D"
        ],
        "statement": "lemma diff_image_diff: assumes A1: \"f: X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  shows \"f``(X) - f``(A) \\<subseteq> f``(X-A)\"\n",
        "proof": "proof\n  fix y assume \"y \\<in> f``(X) - f``(A)\"\n  hence \"y \\<in> f``(X)\" and I: \"y \\<notin> f``(A)\" by auto\n  with A1 obtain x where \"x\\<in>X\" and II: \"y = f`(x)\"\n    using func_imagedef by auto\n  with A1 A2 I have \"x\\<notin>A\"\n    using func1_1_L15D by auto\n  with \\<open>x\\<in>X\\<close> have \"x \\<in> X-A\" \"X-A \\<subseteq> X\" by auto\n  with A1 II show \"y \\<in> f``(X-A)\"\n    using func1_1_L15D by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2608
    },
    "2343": {
        "type": "lemma",
        "text": "text\\<open>The image of an intersection is contained in the \n  intersection of the images.\\<close>\n",
        "assumes": "assumes  A1: \"f:X\\<rightarrow>Y\" and\n  A2: \"I\\<noteq>0\" and A3: \"\\<forall>i\\<in>I. P(i) \\<subseteq> X\"\n  ",
        "using": [
            "ZF1_1_L7",
            "func_imagedef"
        ],
        "statement": "lemma image_of_Inter: assumes  A1: \"f:X\\<rightarrow>Y\" and\n  A2: \"I\\<noteq>0\" and A3: \"\\<forall>i\\<in>I. P(i) \\<subseteq> X\"\n  shows \"f``(\\<Inter>i\\<in>I. P(i)) \\<subseteq> ( \\<Inter>i\\<in>I. f``(P(i)) )\"\n",
        "proof": "proof\n  fix y assume A4: \"y \\<in> f``(\\<Inter>i\\<in>I. P(i))\"\n  from A1 A2 A3 have \"f``(\\<Inter>i\\<in>I. P(i)) = {f`(x). x \\<in> ( \\<Inter>i\\<in>I. P(i) )}\"\n    using ZF1_1_L7 func_imagedef by simp\n  with A4 obtain x where \"x \\<in> ( \\<Inter>i\\<in>I. P(i) )\" and \"y = f`(x)\"\n    by auto\n  with A1 A2 A3 show \"y \\<in> ( \\<Inter>i\\<in>I. f``(P(i)) )\" using func_imagedef\n    by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2609
    },
    "2344": {
        "type": "lemma",
        "text": "text\\<open>The image of union is the union of images.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"\\<forall>A\\<in>M. A\\<subseteq>X\"\n  ",
        "using": [
            "func_imagedef"
        ],
        "statement": "lemma image_of_Union: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"\\<forall>A\\<in>M. A\\<subseteq>X\"\n  shows \"f``(\\<Union>M) = \\<Union>{f``(A). A\\<in>M}\"\n",
        "proof": "proof\n  from A2 have \"\\<Union>M \\<subseteq> X\" by auto\n  { fix y assume \"y \\<in> f``(\\<Union>M)\"\n    with A1 \\<open>\\<Union>M \\<subseteq> X\\<close> obtain x where \"x\\<in>\\<Union>M\" and I: \"y = f`(x)\" \n      using func_imagedef by auto\n    then obtain A where \"A\\<in>M\" and \"x\\<in>A\" by auto\n    with assms I have \"y \\<in> \\<Union>{f``(A). A\\<in>M}\" using func_imagedef by auto\n  } thus \"f``(\\<Union>M) \\<subseteq> \\<Union>{f``(A). A\\<in>M}\" by auto\n  { fix y assume \"y \\<in> \\<Union>{f``(A). A\\<in>M}\"\n    then obtain A where \"A\\<in>M\" and \"y \\<in> f``(A)\" by auto\n    with assms \\<open>\\<Union>M \\<subseteq> X\\<close> have \"y \\<in> f``(\\<Union>M)\" using func_imagedef by auto\n  } thus \"\\<Union>{f``(A). A\\<in>M} \\<subseteq> f``(\\<Union>M)\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2610
    },
    "2345": {
        "type": "lemma",
        "text": "text\\<open>If the domain of a function is nonempty, then the codomain is as well.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \"X\\<noteq>0\" ",
        "using": [
            "assms",
            "apply_funtype"
        ],
        "statement": "lemma codomain_nonempty: assumes \"f:X\\<rightarrow>Y\" \"X\\<noteq>0\" shows \"Y\\<noteq>0\"\n  ",
        "proof": "using assms apply_funtype by blast\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2611
    },
    "2346": {
        "type": "lemma",
        "text": "text\\<open>The image of a nonempty subset of domain is nonempty.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\" and A3: \"A\\<noteq>0\"\n  ",
        "using": [
            "func_imagedef"
        ],
        "statement": "lemma func1_1_L15A: \n  assumes A1: \"f: X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\" and A3: \"A\\<noteq>0\"\n  shows \"f``(A) \\<noteq> 0\"\n",
        "proof": "proof -\n  from A3 obtain x where \"x\\<in>A\" by auto\n  with A1 A2 have \"f`(x) \\<in> f``(A)\"\n    using func_imagedef by auto\n  then show \"f``(A) \\<noteq> 0\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2612
    },
    "2347": {
        "type": "lemma",
        "text": "text\\<open>The next lemma allows to prove statements about the values in the\n  domain of a function given a statement about values in the range.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" and \"A\\<subseteq>X\" and \"\\<forall>y\\<in>f``(A). P(y)\"\n  ",
        "using": [
            "assms",
            "func_imagedef"
        ],
        "statement": "lemma func1_1_L15B: \n  assumes \"f:X\\<rightarrow>Y\" and \"A\\<subseteq>X\" and \"\\<forall>y\\<in>f``(A). P(y)\"\n  shows \"\\<forall>x\\<in>A. P(f`(x))\"\n  ",
        "proof": "using assms func_imagedef by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2613
    },
    "2348": {
        "type": "lemma",
        "text": "text\\<open>An image of an image is the image of a composition.\\<close>\n",
        "assumes": "assumes  A1: \"f:X\\<rightarrow>Y\" and A2: \"g:Y\\<rightarrow>Z\"\n  and A3: \"A\\<subseteq>X\"\n  ",
        "using": [
            "apply_funtype",
            "func_imagedef",
            "comp_fun_apply",
            "comp_fun"
        ],
        "statement": "lemma func1_1_L15C: assumes  A1: \"f:X\\<rightarrow>Y\" and A2: \"g:Y\\<rightarrow>Z\"\n  and A3: \"A\\<subseteq>X\"\n  shows \n  \"g``(f``(A)) =  {g`(f`(x)). x\\<in>A}\"\n  \"g``(f``(A)) = (g O f)``(A)\"\n",
        "proof": "proof -\n  from A1 A3 have \"{f`(x). x\\<in>A} \\<subseteq> Y\"\n    using apply_funtype by auto\n  with A2 have \"g``{f`(x). x\\<in>A} = {g`(f`(x)). x\\<in>A}\"\n    using func_imagedef by auto\n  with A1 A3 show I: \"g``(f``(A)) =  {g`(f`(x)). x\\<in>A}\" \n    using func_imagedef by simp\n  from A1 A3 have \"\\<forall>x\\<in>A. (g O f)`(x) = g`(f`(x))\"\n    using comp_fun_apply by auto\n  with I have \"g``(f``(A)) = {(g O f)`(x). x\\<in>A}\"\n    by simp\n  moreover from A1 A2 A3 have \"(g O f)``(A) = {(g O f)`(x). x\\<in>A}\"\n    using comp_fun func_imagedef by blast\n  ultimately show \"g``(f``(A)) = (g O f)``(A)\"\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2614
    },
    "2349": {
        "type": "lemma",
        "text": "text\\<open>What is the image of a set defined by a meta-fuction?\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> X\\<rightarrow>Y\" and A2: \"\\<forall>x\\<in>A. b(x) \\<in> X\"\n  ",
        "using": [
            "func_imagedef"
        ],
        "statement": "lemma func1_1_L17: \n  assumes A1: \"f \\<in> X\\<rightarrow>Y\" and A2: \"\\<forall>x\\<in>A. b(x) \\<in> X\"\n  shows \"f``({b(x). x\\<in>A}) = {f`(b(x)). x\\<in>A}\"\n",
        "proof": "proof -\n  from A2 have \"{b(x). x\\<in>A} \\<subseteq> X\" by auto\n  with A1 show ?thesis using func_imagedef by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2615
    },
    "2350": {
        "type": "lemma",
        "text": "text\\<open>What are the values of composition of three functions?\\<close>\n",
        "assumes": "assumes A1: \"f:A\\<rightarrow>B\"  \"g:B\\<rightarrow>C\"  \"h:C\\<rightarrow>D\"\n  and A2: \"x\\<in>A\"\n  ",
        "using": [
            "comp_fun",
            "apply_funtype",
            "comp_fun_apply"
        ],
        "statement": "lemma func1_1_L18: assumes A1: \"f:A\\<rightarrow>B\"  \"g:B\\<rightarrow>C\"  \"h:C\\<rightarrow>D\"\n  and A2: \"x\\<in>A\"\n  shows\n  \"(h O g O f)`(x) \\<in> D\"\n  \"(h O g O f)`(x) = h`(g`(f`(x)))\"  \n",
        "proof": "proof -\n  from A1 have \"(h O g O f) : A\\<rightarrow>D\"\n    using comp_fun by blast\n  with A2 show \"(h O g O f)`(x) \\<in> D\" using apply_funtype\n    by simp\n  from A1 A2 have \"(h O g O f)`(x) = h`( (g O f)`(x))\"\n    using comp_fun comp_fun_apply by blast\n  with A1 A2 show \"(h O g O f)`(x) = h`(g`(f`(x)))\"\n    using comp_fun_apply by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2616
    },
    "2351": {
        "type": "lemma",
        "text": "text\\<open>A composition of functions is a function. This is a slight\n  generalization of standard Isabelle's \\<open>comp_fun\\<close>\n\\<close>\n",
        "assumes": "assumes A1: \"g:A\\<rightarrow>B\"  and A2: \"f:C\\<rightarrow>D\" and A3: \"B \\<subseteq> C\"\n  ",
        "using": [
            "comp_fun"
        ],
        "statement": "lemma comp_fun_subset: \n  assumes A1: \"g:A\\<rightarrow>B\"  and A2: \"f:C\\<rightarrow>D\" and A3: \"B \\<subseteq> C\"\n  shows \"f O g : A \\<rightarrow> D\"\n",
        "proof": "proof -\n  from A1 A3 have \"g:A\\<rightarrow>C\" by (rule func1_1_L1B) \n  with A2 show \"f O g : A \\<rightarrow> D\" using comp_fun by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2617
    },
    "2352": {
        "type": "lemma",
        "text": "text\\<open>This lemma supersedes the lemma \\<open>comp_eq_id_iff\\<close> \n  in Isabelle/ZF. Contributed by Victor Porton.\\<close>\n",
        "assumes": "assumes A1: \"g: B\\<rightarrow>A\" and A2: \"f: A\\<rightarrow>C\"\n  ",
        "using": [
            "comp_fun",
            "id_type"
        ],
        "statement": "lemma comp_eq_id_iff1: assumes A1: \"g: B\\<rightarrow>A\" and A2: \"f: A\\<rightarrow>C\"\n  shows \"(\\<forall>y\\<in>B. f`(g`(y)) = y) \\<longleftrightarrow> f O g = id(B)\"\n",
        "proof": "proof -\n  from assms have \"f O g: B\\<rightarrow>C\" and \"id(B): B\\<rightarrow>B\"\n    using comp_fun id_type by auto\n  then have \"(\\<forall>y\\<in>B. (f O g)`y = id(B)`(y)) \\<longleftrightarrow> f O g = id(B)\" \n    by (rule fun_extension_iff)\n  moreover from A1 have \n    \"\\<forall>y\\<in>B. (f O g)`y = f`(g`y)\" and \"\\<forall>y\\<in>B. id(B)`(y) = y\"\n    by auto\n  ultimately show \"(\\<forall>y\\<in>B. f`(g`y) = y) \\<longleftrightarrow> f O g = id(B)\" by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2618
    },
    "2353": {
        "type": "lemma",
        "text": "text\\<open>A lemma about a value of a function that is a union of \n  some collection of functions.\\<close>\n",
        "assumes": "assumes A1: \"\\<Union>F : X\\<rightarrow>Y\" and \n  A2: \"f\\<in>F\" and A3: \"f:A\\<rightarrow>B\" and A4: \"x\\<in>A\"\n  ",
        "using": [
            "apply_Pair",
            "apply_equality"
        ],
        "statement": "lemma fun_Union_apply: assumes A1: \"\\<Union>F : X\\<rightarrow>Y\" and \n  A2: \"f\\<in>F\" and A3: \"f:A\\<rightarrow>B\" and A4: \"x\\<in>A\"\n  shows \"(\\<Union>F)`(x) = f`(x)\"\n",
        "proof": "proof -\n  from A3 A4 have \"\\<langle>x, f`(x)\\<rangle> \\<in> f\" using apply_Pair\n    by simp\n  with A2 have \"\\<langle>x, f`(x)\\<rangle> \\<in> \\<Union>F\" by auto\n  with A1 show \"(\\<Union>F)`(x) = f`(x)\" using apply_equality\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2619
    },
    "2354": {
        "type": "lemma",
        "text": "text\\<open>What is the inverse image of a set under a restricted fuction?\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"B\\<subseteq>X\"\n  ",
        "using": [
            "restrict_type2",
            "func1_1_L15",
            "restrict_if"
        ],
        "statement": "lemma func1_2_L1: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"B\\<subseteq>X\"\n  shows \"restrict(f,B)-``(A) = f-``(A) \\<inter> B\"\n",
        "proof": "proof -\n  let ?g = \"restrict(f,B)\"\n  from A1 A2 have \"?g:B\\<rightarrow>Y\" \n    using restrict_type2 by simp\n  with A2 A1 show \"?g-``(A) = f-``(A) \\<inter> B\"\n    using func1_1_L15 restrict_if by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2620
    },
    "2355": {
        "type": "lemma",
        "text": "text\\<open>A criterion for when one function is a restriction of another.\n  The lemma below provides a result useful in the actual proof of the \n  criterion and applications.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"g \\<in> A\\<rightarrow>Z\" \n  and A3: \"A\\<subseteq>X\" and A4: \"f \\<inter> A\\<times>Z = g\"\n  ",
        "using": [
            "apply_Pair",
            "apply_iff"
        ],
        "statement": "lemma func1_2_L2: \n  assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"g \\<in> A\\<rightarrow>Z\" \n  and A3: \"A\\<subseteq>X\" and A4: \"f \\<inter> A\\<times>Z = g\"\n  shows \"\\<forall>x\\<in>A. g`(x) = f`(x)\"\n",
        "proof": "proof\n  fix x assume \"x\\<in>A\"\n  with A2 have \"\\<langle>x,g`(x)\\<rangle> \\<in> g\" using apply_Pair by simp\n  with A4 A1 show \"g`(x) = f`(x)\"  using apply_iff by auto \nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2621
    },
    "2356": {
        "type": "lemma",
        "text": "text\\<open>Here is the actual criterion.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"g:A\\<rightarrow>Z\" \n  and A3: \"A\\<subseteq>X\" and A4: \"f \\<inter> A\\<times>Z = g\"\n  ",
        "using": [
            "restrict_iff",
            "apply_iff",
            "func1_2_L2",
            "apply_Pair"
        ],
        "statement": "lemma func1_2_L3: \n  assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"g:A\\<rightarrow>Z\" \n  and A3: \"A\\<subseteq>X\" and A4: \"f \\<inter> A\\<times>Z = g\"\n  shows \"g = restrict(f,A)\"\n",
        "proof": "proof\n  from A4 show \"g \\<subseteq> restrict(f, A)\" using restrict_iff by auto\n  show \"restrict(f, A) \\<subseteq> g\"\n  proof\n    fix z assume A5:\"z \\<in> restrict(f,A)\"\n    then obtain x y where D1:\"z\\<in>f \\<and> x\\<in>A  \\<and> z = \\<langle>x,y\\<rangle>\"\n      using restrict_iff by auto\n    with A1 have \"y = f`(x)\" using apply_iff by auto\n    with A1 A2 A3 A4 D1 have \"y = g`(x)\" using func1_2_L2 by simp\n    with A2 D1 show \"z\\<in>g\" using apply_Pair by simp\n  qed\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2622
    },
    "2357": {
        "type": "lemma",
        "text": "text\\<open>Which function space a restricted function belongs to?\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\" and A3: \"\\<forall>x\\<in>A. f`(x) \\<in> Z\"\n  ",
        "using": [
            "restrict_type2",
            "restrict"
        ],
        "statement": "lemma func1_2_L4: \n  assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\" and A3: \"\\<forall>x\\<in>A. f`(x) \\<in> Z\"\n  shows \"restrict(f,A) : A\\<rightarrow>Z\"\n",
        "proof": "proof -\n  let ?g = \"restrict(f,A)\"\n  from A1 A2 have \"?g : A\\<rightarrow>Y\" \n    using restrict_type2 by simp\n  moreover { \n    fix x assume \"x\\<in>A\" \n    with A1 A3 have \"?g`(x) \\<in> Z\" using restrict by simp}\n  ultimately show ?thesis by (rule Pi_type)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2623
    },
    "2358": {
        "type": "corollary",
        "text": "text\\<open>A simpler case of \\<open>func1_2_L4\\<close>, where\n  the range of the original and restricted function are the same.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  ",
        "using": [
            "apply_funtype",
            "func1_2_L4"
        ],
        "statement": "corollary restrict_fun: assumes A1: \"f:X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  shows \"restrict(f,A) : A \\<rightarrow> Y\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>x\\<in>A. f`(x) \\<in> Y\" using apply_funtype\n    by auto\n  with assms show ?thesis using func1_2_L4 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2624
    },
    "2359": {
        "type": "lemma",
        "text": "text\\<open>A function restricted to its domain is itself.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "restrict",
            "func_eq",
            "restrict_fun"
        ],
        "statement": "lemma restrict_domain: assumes \"f:X\\<rightarrow>Y\"\n  shows \"restrict(f,X) = f\"\n",
        "proof": "proof - \n  have \"\\<forall>x\\<in>X. restrict(f,X)`(x) = f`(x)\" using restrict by simp\n  with assms show ?thesis using func_eq restrict_fun by blast\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2625
    },
    "2360": {
        "type": "lemma",
        "text": "text\\<open>Suppose a function $f:X\\rightarrow Y$ is defined by an expression $q$, i.e.\n  $f = \\{\\langle x,y\\rangle : x\\in X\\}$. Then a function that is defined by the same expression,\n   but on a smaller set is the same as the restriction of $f$ to that smaller set.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>X\"\n  ",
        "using": [
            "ZF_fun_from_total",
            "restrict_fun",
            "restrict",
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma restrict_def_alt: assumes \"A\\<subseteq>X\"\n  shows \"restrict({\\<langle>x,q(x)\\<rangle>. x\\<in>X},A) = {\\<langle>x,q(x)\\<rangle>. x\\<in>A}\"\n",
        "proof": "proof -\n  let ?Y = \"{q(x). x\\<in>X}\"\n  let ?f = \"{\\<langle>x,q(x)\\<rangle>. x\\<in>X}\"\n  have \"\\<forall>x\\<in>X. q(x)\\<in>?Y\" by blast\n  with assms have \"?f:X\\<rightarrow>?Y\" using ZF_fun_from_total by simp\n  with assms have \"restrict(?f,A):A\\<rightarrow>?Y\" using restrict_fun by simp\n  moreover \n  from assms have \"\\<forall>x\\<in>A. q(x)\\<in>?Y\" by blast\n  then have \"{\\<langle>x,q(x)\\<rangle>. x\\<in>A}:A\\<rightarrow>?Y\" using ZF_fun_from_total by simp\n  moreover from assms have \n    \"\\<forall>x\\<in>A. restrict(?f,A)`(x) = {\\<langle>x,q(x)\\<rangle>. x\\<in>A}`(x)\"  \n    using restrict ZF_fun_from_tot_val1 by auto\n  ultimately show ?thesis by (rule func_eq)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2626
    },
    "2361": {
        "type": "lemma",
        "text": "text\\<open>A composition of two functions is the same as \n  composition with a restriction.\\<close>\n",
        "assumes": "assumes A1: \"f : A\\<rightarrow>B\" and A2: \"g : X \\<rightarrow> C\" and A3: \"B\\<subseteq>X\"\n  ",
        "using": [
            "comp_fun_subset",
            "restrict_fun",
            "comp_fun",
            "comp_fun_apply",
            "apply_funtype",
            "restrict"
        ],
        "statement": "lemma comp_restrict: \n  assumes A1: \"f : A\\<rightarrow>B\" and A2: \"g : X \\<rightarrow> C\" and A3: \"B\\<subseteq>X\"\n  shows \"g O f = restrict(g,B) O f\"\n",
        "proof": "proof -\n  from assms have \"g O f : A \\<rightarrow> C\" using comp_fun_subset\n    by simp\n  moreover from assms have \"restrict(g,B) O f : A \\<rightarrow> C\"\n    using restrict_fun comp_fun by simp\n  moreover from A1 have \n    \"\\<forall>x\\<in>A. (g O f)`(x) = (restrict(g,B) O f)`(x)\"\n    using comp_fun_apply apply_funtype restrict\n    by simp\n  ultimately show \"g O f = restrict(g,B) O f\"\n    by (rule func_eq)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2627
    },
    "2362": {
        "type": "lemma",
        "text": "text\\<open>A way to look at restriction. Contributed by Victor Porton.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma right_comp_id_any: shows \"r O id(C) = restrict(r,C)\"\n  unfolding restrict_def by auto\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2628
    },
    "2363": {
        "type": "definition",
        "text": "text\\<open>We define constant($=c$) functions on a set $X$ \n  in a natural way as ConstantFunction$(X,c)$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ConstantFunction(X,c) \\<equiv> X\\<times>{c}\"\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2629
    },
    "2364": {
        "type": "lemma",
        "text": "text\\<open>Constant function is a function (i.e. belongs to a function space).\\<close>\n",
        "assumes": "assumes A1: \"c\\<in>Y\" ",
        "using": [
            "func1_1_L11A",
            "ConstantFunction_def"
        ],
        "statement": "lemma func1_3_L1: \n  assumes A1: \"c\\<in>Y\" shows \"ConstantFunction(X,c) : X\\<rightarrow>Y\"\n",
        "proof": "proof -\n   from A1 have \"X\\<times>{c} = {\\<langle> x,y\\<rangle> \\<in> X\\<times>Y. c = y}\" \n     by auto\n   with A1 show ?thesis using func1_1_L11A ConstantFunction_def\n     by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2630
    },
    "2365": {
        "type": "lemma",
        "text": "text\\<open>Constant function is equal to the constant on its domain.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>X\"\n  ",
        "using": [
            "func1_3_L1",
            "ConstantFunction_def",
            "apply_iff"
        ],
        "statement": "lemma func1_3_L2: assumes A1: \"x\\<in>X\"\n  shows \"ConstantFunction(X,c)`(x) = c\"\n",
        "proof": "proof -\n  have \"ConstantFunction(X,c) \\<in> X\\<rightarrow>{c}\"\n    using func1_3_L1 by simp\n  moreover from A1 have \"\\<langle>x,c\\<rangle> \\<in> ConstantFunction(X,c)\"\n    using ConstantFunction_def by simp\n  ultimately show ?thesis using apply_iff by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2631
    },
    "2366": {
        "type": "lemma",
        "text": "text\\<open>Another way of looking at the constant function - it's a set of pairs\n  $\\langle x,c\\rangle$ as $x$ ranges over $X$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma const_fun_def_alt: shows \"ConstantFunction(X,c) = {\\<langle>x,c\\<rangle>. x\\<in>X}\"\n  unfolding ConstantFunction_def by auto\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2632
    },
    "2367": {
        "type": "lemma",
        "text": "text\\<open>If $c\\in A$ then the inverse image of $A$ by the constant function $x\\mapsto c$ \n  is the whole domain. \\<close>\n",
        "assumes": "assumes \"c\\<in>A\" \n  ",
        "using": [
            "func1_3_L1",
            "func1_1_L15",
            "func1_3_L2"
        ],
        "statement": "lemma const_vimage_domain: assumes \"c\\<in>A\" \n  shows \"ConstantFunction(X,c)-``(A) = X\"\n",
        "proof": "proof -\n  let ?C = \"ConstantFunction(X,c)\"\n  have \"?C-``(A) = {x\\<in>X. ?C`(x) \\<in> A}\" using func1_3_L1 func1_1_L15 \n    by blast\n  with assms show ?thesis using func1_3_L2 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2633
    },
    "2368": {
        "type": "lemma",
        "text": "text\\<open>If $c$ is not an element of $A$  then the inverse image of $A$ by the constant \n  function $x\\mapsto c$ is empty. \\<close>\n",
        "assumes": "assumes \"c\\<notin>A\"\n  ",
        "using": [
            "func1_3_L1",
            "func1_1_L15",
            "func1_3_L2"
        ],
        "statement": "lemma const_vimage_empty: assumes \"c\\<notin>A\"\n  shows \"ConstantFunction(X,c)-``(A) = 0\"\n",
        "proof": "proof -\n  let ?C = \"ConstantFunction(X,c)\"\n  have \"?C-``(A) = {x\\<in>X. ?C`(x) \\<in> A}\" using func1_3_L1 func1_1_L15 \n    by blast\n  with assms show ?thesis using func1_3_L2 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2634
    },
    "2369": {
        "type": "lemma",
        "text": "text\\<open>For injections the image a difference of two sets is\n  the difference of images\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> inj(A,B)\" and A2: \"C \\<subseteq> A\"\n  ",
        "using": [
            "inj_def",
            "func_imagedef",
            "diff_image_diff"
        ],
        "statement": "lemma inj_image_dif: \n  assumes A1: \"f \\<in> inj(A,B)\" and A2: \"C \\<subseteq> A\"\n  shows \"f``(A-C) = f``(A) - f``(C)\"\n",
        "proof": "proof\n  show \"f``(A - C) \\<subseteq> f``(A) - f``(C)\"\n  proof\n    fix y assume A3: \"y \\<in> f``(A - C)\"\n    from A1 have \"f:A\\<rightarrow>B\" using inj_def by simp\n    moreover have \"A-C \\<subseteq> A\" by auto\n    ultimately have \"f``(A-C) = {f`(x). x \\<in> A-C}\"\n      using func_imagedef by simp\n    with A3 obtain x where I: \"f`(x) = y\" and \"x \\<in> A-C\" \n      by auto\n    hence \"x\\<in>A\" by auto\n    with \\<open>f:A\\<rightarrow>B\\<close> I have \"y \\<in> f``(A)\"\n      using func_imagedef by auto\n    moreover have \"y \\<notin>  f``(C)\"\n    proof -\n      { assume \"y \\<in> f``(C)\"\n\twith A2 \\<open>f:A\\<rightarrow>B\\<close> obtain x\\<^sub>0 \n\t  where II: \"f`(x\\<^sub>0) = y\" and \"x\\<^sub>0 \\<in> C\"\n\t  using func_imagedef by auto\n\twith A1 A2 I \\<open>x\\<in>A\\<close> have\n\t  \"f \\<in> inj(A,B)\" \"f`(x) = f`(x\\<^sub>0)\"  \"x\\<in>A\" \"x\\<^sub>0 \\<in> A\"\n\t  by auto\n\tthen have \"x = x\\<^sub>0\" by (rule inj_apply_equality)\n\twith \\<open>x \\<in> A-C\\<close> \\<open>x\\<^sub>0 \\<in> C\\<close> have False by simp\n      } thus ?thesis by auto\n    qed\n    ultimately show \"y \\<in> f``(A) - f``(C)\" by simp\n  qed\n  from A1 A2 show \"f``(A) - f``(C) \\<subseteq> f``(A-C)\"\n    using inj_def diff_image_diff by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2635
    },
    "2370": {
        "type": "lemma",
        "text": "text\\<open>For injections the image of intersection is the intersection of images.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> inj(X,Y)\" and A2: \"A\\<subseteq>X\" \"B\\<subseteq>X\"\n  ",
        "using": [
            "image_Int_subset",
            "inj_def",
            "func_imagedef"
        ],
        "statement": "lemma inj_image_inter: assumes A1: \"f \\<in> inj(X,Y)\" and A2: \"A\\<subseteq>X\" \"B\\<subseteq>X\"\n  shows \"f``(A\\<inter>B) = f``(A) \\<inter> f``(B)\"\n",
        "proof": "proof\n  show \"f``(A\\<inter>B) \\<subseteq> f``(A) \\<inter> f``(B)\" using image_Int_subset by simp\n  { from A1 have \"f:X\\<rightarrow>Y\" using inj_def by simp \n    fix y assume \"y \\<in> f``(A) \\<inter> f``(B)\"\n    then have \"y \\<in> f``(A)\" and  \"y \\<in> f``(B)\" by auto\n    with A2 \\<open>f:X\\<rightarrow>Y\\<close> obtain x\\<^sub>A x\\<^sub>B where \n    \"x\\<^sub>A \\<in> A\" \"x\\<^sub>B \\<in> B\" and I: \"y = f`(x\\<^sub>A)\"  \"y = f`(x\\<^sub>B)\"\n      using func_imagedef by auto\n    with A2 have \"x\\<^sub>A \\<in> X\" \"x\\<^sub>B \\<in> X\" and \" f`(x\\<^sub>A) =  f`(x\\<^sub>B)\" by auto \n    with A1 have \"x\\<^sub>A = x\\<^sub>B\" using inj_def by auto\n    with \\<open>x\\<^sub>A \\<in> A\\<close> \\<open>x\\<^sub>B \\<in> B\\<close> have \"f`(x\\<^sub>A) \\<in> {f`(x). x \\<in> A\\<inter>B}\" by auto\n    moreover from A2 \\<open>f:X\\<rightarrow>Y\\<close> have \"f``(A\\<inter>B) = {f`(x). x \\<in> A\\<inter>B}\"\n      using func_imagedef by blast\n    ultimately have \"f`(x\\<^sub>A) \\<in> f``(A\\<inter>B)\" by simp \n    with I have \"y \\<in> f``(A\\<inter>B)\" by simp \n  } thus \"f``(A) \\<inter> f``(B) \\<subseteq> f``(A \\<inter> B)\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2636
    },
    "2371": {
        "type": "lemma",
        "text": "text\\<open>For surjection from $A$ to $B$ the image of \n  the domain is $B$.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> surj(A,B)\"\n  ",
        "using": [
            "surj_def",
            "range_image_domain",
            "surj_range"
        ],
        "statement": "lemma surj_range_image_domain: assumes A1: \"f \\<in> surj(A,B)\"\n  shows \"f``(A) = B\"\n",
        "proof": "proof -\n  from A1 have \"f``(A) = range(f)\" \n    using surj_def range_image_domain by auto\n  with A1 show \"f``(A) = B\"  using surj_range\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2637
    },
    "2372": {
        "type": "lemma",
        "text": "text\\<open>For injections the inverse image of an image is the same set.\\<close>\n",
        "assumes": "assumes \"f \\<in> inj(X,Y)\" and \"A\\<subseteq>X\"\n  ",
        "using": [
            "vimage_converse",
            "image_comp",
            "left_comp_inverse",
            "image_id_same"
        ],
        "statement": "lemma inj_vimage_image: assumes \"f \\<in> inj(X,Y)\" and \"A\\<subseteq>X\"\n  shows \"f-``(f``(A)) = A\"\n",
        "proof": "proof -\n  have \"f-``(f``(A)) = (converse(f) O f)``(A)\" \n    using vimage_converse image_comp by simp\n  with assms show ?thesis using left_comp_inverse image_id_same\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2638
    },
    "2373": {
        "type": "lemma",
        "text": "text\\<open>For surjections the image of an inverse image is the same set.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> surj(X,Y)\" and A2: \"A\\<subseteq>Y\"\n  ",
        "using": [
            "vimage_converse",
            "image_comp",
            "right_comp_inverse",
            "image_id_same"
        ],
        "statement": "lemma surj_image_vimage: assumes A1: \"f \\<in> surj(X,Y)\" and A2: \"A\\<subseteq>Y\"\n  shows \"f``(f-``(A)) = A\"\n",
        "proof": "proof -\n  have \"f``(f-``(A)) = (f O converse(f))``(A)\"\n    using vimage_converse image_comp by simp\n  with assms show ?thesis using right_comp_inverse image_id_same\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2639
    },
    "2374": {
        "type": "lemma",
        "text": "text\\<open>Restriction of an bijection to a set without a point\n  is a a bijection.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(A,B)\" and A2: \"a\\<in>A\"\n  ",
        "using": [
            "bij_def",
            "restrict_bij",
            "inj_image_dif",
            "surj_range_image_domain",
            "bij_is_fun",
            "singleton_image"
        ],
        "statement": "lemma bij_restrict_rem: \n  assumes A1: \"f \\<in> bij(A,B)\" and A2: \"a\\<in>A\"\n  shows \"restrict(f, A-{a}) \\<in> bij(A-{a}, B-{f`(a)})\"\n",
        "proof": "proof -\n  let ?C = \"A-{a}\"\n  from A1 have \"f \\<in> inj(A,B)\"  \"?C \\<subseteq> A\"\n    using bij_def by auto\n  then have \"restrict(f,?C) \\<in> bij(?C, f``(?C))\"\n    using restrict_bij by simp\n  moreover have \"f``(?C) =  B-{f`(a)}\"\n  proof -\n    from A2 \\<open>f \\<in> inj(A,B)\\<close> have \"f``(?C) = f``(A) - f``{a}\"\n      using inj_image_dif by simp\n    moreover from A1 have \"f``(A) = B\" \n      using bij_def surj_range_image_domain by auto\n    moreover from A1 A2 have \"f``{a} = {f`(a)}\"\n      using bij_is_fun singleton_image by blast\n    ultimately show \"f``(?C) =  B-{f`(a)}\" by simp\n  qed\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2641
    },
    "2375": {
        "type": "lemma",
        "text": "text\\<open>The domain of a bijection between $X$ and $Y$ is $X$.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(X,Y)\" ",
        "using": [
            "bij_is_fun",
            "func1_1_L1"
        ],
        "statement": "lemma domain_of_bij: \n  assumes A1: \"f \\<in> bij(X,Y)\" shows \"domain(f) = X\"\n",
        "proof": "proof -\n  from A1 have \"f:X\\<rightarrow>Y\" using bij_is_fun by simp\n  then show \"domain(f) = X\" using func1_1_L1 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2642
    },
    "2376": {
        "type": "lemma",
        "text": "text\\<open>The value of the inverse of an injection on a point of the image \n  of a set belongs to that set.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> inj(A,B)\" and A2: \"C\\<subseteq>A\" and A3: \"y \\<in> f``(C)\"\n  ",
        "using": [
            "inj_is_fun",
            "func_imagedef",
            "left_inverse",
            "func1_1_L5A",
            "right_inverse"
        ],
        "statement": "lemma inj_inv_back_in_set: \n  assumes A1: \"f \\<in> inj(A,B)\" and A2: \"C\\<subseteq>A\" and A3: \"y \\<in> f``(C)\"\n  shows \n  \"converse(f)`(y) \\<in> C\"\n  \"f`(converse(f)`(y)) = y\"\n",
        "proof": "proof -\n  from A1 have I: \"f:A\\<rightarrow>B\" using inj_is_fun by simp\n  with A2 A3 obtain x where II: \"x\\<in>C\"   \"y = f`(x)\"\n    using func_imagedef by auto\n  with A1 A2 show \"converse(f)`(y) \\<in> C\" using left_inverse\n    by auto\n  from A1 A2 I II show \"f`(converse(f)`(y)) = y\"\n    using func1_1_L5A right_inverse by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2643
    },
    "2377": {
        "type": "lemma",
        "text": "text\\<open>For injections if a value at a point \n  belongs to the image of a set, then the point\n  belongs to the set.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> inj(A,B)\" and A2: \"C\\<subseteq>A\" and\n  A3: \"x\\<in>A\" and A4: \"f`(x) \\<in> f``(C)\"\n  ",
        "using": [
            "inj_inv_back_in_set",
            "left_inverse_eq"
        ],
        "statement": "lemma inj_point_of_image: \n  assumes A1: \"f \\<in> inj(A,B)\" and A2: \"C\\<subseteq>A\" and\n  A3: \"x\\<in>A\" and A4: \"f`(x) \\<in> f``(C)\"\n  shows \"x \\<in> C\"\n",
        "proof": "proof -\n  from A1 A2 A4 have \"converse(f)`(f`(x)) \\<in> C\"\n    using inj_inv_back_in_set by simp\n  moreover from A1 A3 have \"converse(f)`(f`(x)) = x\"\n    using left_inverse_eq by simp\n  ultimately show \"x \\<in> C\" by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2644
    },
    "2378": {
        "type": "lemma",
        "text": "text\\<open>For injections the image of intersection is \n  the intersection of images.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> inj(A,B)\" and\n  A2: \"I\\<noteq>0\" and A3: \"\\<forall>i\\<in>I. P(i) \\<subseteq> A\"\n  ",
        "using": [
            "inj_is_fun",
            "image_of_Inter",
            "ZF1_1_L7",
            "func_imagedef",
            "func1_1_L6",
            "right_inverse",
            "inj_converse_fun",
            "apply_funtype",
            "inj_point_of_image"
        ],
        "statement": "lemma inj_image_of_Inter: assumes A1: \"f \\<in> inj(A,B)\" and\n  A2: \"I\\<noteq>0\" and A3: \"\\<forall>i\\<in>I. P(i) \\<subseteq> A\"\n  shows \"f``(\\<Inter>i\\<in>I. P(i)) = ( \\<Inter>i\\<in>I. f``(P(i)) )\"\n",
        "proof": "proof\n  from A1 A2 A3 show \"f``(\\<Inter>i\\<in>I. P(i)) \\<subseteq> ( \\<Inter>i\\<in>I. f``(P(i)) )\"\n    using inj_is_fun image_of_Inter by auto\n  from A1 A2 A3 have \"f:A\\<rightarrow>B\"  and \"( \\<Inter>i\\<in>I. P(i) ) \\<subseteq> A\"\n    using inj_is_fun ZF1_1_L7 by auto\n  then have I: \"f``(\\<Inter>i\\<in>I. P(i)) = { f`(x). x \\<in> ( \\<Inter>i\\<in>I. P(i) ) }\"\n    using func_imagedef by simp\n  { fix y assume A4: \"y \\<in> ( \\<Inter>i\\<in>I. f``(P(i)) )\"\n    let ?x = \"converse(f)`(y)\"\n    from A2 obtain i\\<^sub>0 where \"i\\<^sub>0 \\<in> I\" by auto\n    with A1 A4 have II: \"y \\<in> range(f)\" using inj_is_fun func1_1_L6\n      by auto\n    with A1 have III: \"f`(?x) = y\" using right_inverse by simp\n    from A1 II have IV: \"?x \\<in> A\" using inj_converse_fun apply_funtype \n      by blast\n    { fix i assume \"i\\<in>I\"\n      with A3 A4 III have \"P(i) \\<subseteq> A\" and \"f`(?x) \\<in>  f``(P(i))\" \n\tby auto\n      with A1 IV have \"?x \\<in> P(i)\" using inj_point_of_image\n\tby blast\n    } then have \"\\<forall>i\\<in>I. ?x \\<in> P(i)\" by simp\n    with A2 I have \"f`(?x) \\<in> f``( \\<Inter>i\\<in>I. P(i) )\"\n      by auto\n    with III have \"y \\<in>  f``( \\<Inter>i\\<in>I. P(i) )\" by simp\n  } then show \"( \\<Inter>i\\<in>I. f``(P(i)) ) \\<subseteq>  f``( \\<Inter>i\\<in>I. P(i) )\"\n    by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2645
    },
    "2379": {
        "type": "lemma",
        "text": "text\\<open>An injection is injective onto its range. Suggested by Victor Porton.\\<close>\n",
        "assumes": "assumes \"f \\<in> inj(A,B)\"\n  ",
        "using": [
            "assms",
            "inj_def",
            "range_of_fun"
        ],
        "statement": "lemma inj_inj_range: assumes \"f \\<in> inj(A,B)\"\n  shows \"f \\<in> inj(A,range(f))\"\n  ",
        "proof": "using assms inj_def range_of_fun by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2646
    },
    "2380": {
        "type": "lemma",
        "text": "text\\<open>An injection is a bijection on its range. Suggested by Victor Porton.\\<close>\n",
        "assumes": "assumes \"f \\<in> inj(A,B)\" \n  ",
        "using": [
            "inj_def",
            "fun_is_surj",
            "inj_inj_range",
            "bij_def"
        ],
        "statement": "lemma inj_bij_range: assumes \"f \\<in> inj(A,B)\" \n  shows \"f \\<in> bij(A,range(f))\"\n",
        "proof": "proof -\n  from assms have \"f \\<in> surj(A,range(f))\" using inj_def fun_is_surj\n    by auto\n  with assms show ?thesis using inj_inj_range bij_def by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2647
    },
    "2381": {
        "type": "lemma",
        "text": "text\\<open>A lemma about extending a surjection by one point.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> surj(X,Y)\" and A2: \"a\\<notin>X\" and\n  A3: \"g = f \\<union> {\\<langle>a,b\\<rangle>}\"\n  ",
        "using": [
            "surj_def",
            "func1_1_L11D"
        ],
        "statement": "lemma surj_extend_point: \n  assumes A1: \"f \\<in> surj(X,Y)\" and A2: \"a\\<notin>X\" and\n  A3: \"g = f \\<union> {\\<langle>a,b\\<rangle>}\"\n  shows \"g \\<in> surj(X\\<union>{a},Y\\<union>{b})\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \"g : X\\<union>{a} \\<rightarrow> Y\\<union>{b}\"\n    using surj_def func1_1_L11D by simp\n  moreover have \"\\<forall>y \\<in> Y\\<union>{b}. \\<exists>x \\<in> X\\<union>{a}. y = g`(x)\"\n  proof\n    fix y assume \"y \\<in>  Y \\<union> {b}\"\n    then have \"y \\<in> Y \\<or> y = b\" by auto\n    moreover\n    { assume \"y \\<in> Y\"\n      with A1 obtain x where \"x\\<in>X\" and \"y = f`(x)\"\n\tusing surj_def by auto\n      with A1 A2 A3 have \"x \\<in>  X\\<union>{a}\" and \"y = g`(x)\"\n\tusing surj_def func1_1_L11D by auto\n      then have \"\\<exists>x \\<in> X\\<union>{a}. y = g`(x)\" by auto }\n    moreover\n    { assume \"y = b\"\n      with A1 A2 A3 have \"y = g`(a)\"\n\tusing surj_def func1_1_L11D by auto\n      then have \"\\<exists>x \\<in> X\\<union>{a}. y = g`(x)\" by auto }\n    ultimately show \"\\<exists>x \\<in> X\\<union>{a}. y = g`(x)\"\n      by auto\n  qed\n  ultimately show \"g \\<in> surj(X\\<union>{a},Y\\<union>{b})\"\n    using surj_def by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2648
    },
    "2382": {
        "type": "lemma",
        "text": "text\\<open>A lemma about extending an injection by one point. \n  Essentially the same as standard Isabelle's \\<open>inj_extend\\<close>.\n\\<close>\n",
        "assumes": "assumes \"f \\<in> inj(X,Y)\" \"a\\<notin>X\" \"b\\<notin>Y\"\n  ",
        "using": [
            "assms",
            "inj_extend"
        ],
        "statement": "lemma inj_extend_point: assumes \"f \\<in> inj(X,Y)\" \"a\\<notin>X\" \"b\\<notin>Y\"\n  shows \"(f \\<union> {\\<langle>a,b\\<rangle>}) \\<in> inj(X\\<union>{a},Y\\<union>{b})\"\n",
        "proof": "proof -\n  from assms have \"cons(\\<langle>a,b\\<rangle>,f) \\<in> inj(cons(a, X), cons(b, Y))\"\n    using assms inj_extend by simp\n  moreover have \"cons(\\<langle>a,b\\<rangle>,f) = f \\<union> {\\<langle>a,b\\<rangle>}\" and\n    \"cons(a, X) = X\\<union>{a}\" and \"cons(b, Y) = Y\\<union>{b}\"\n    by auto\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2649
    },
    "2383": {
        "type": "lemma",
        "text": "text\\<open>A lemma about extending a bijection by one point.\\<close>\n",
        "assumes": "assumes \"f \\<in> bij(X,Y)\" \"a\\<notin>X\" \"b\\<notin>Y\"\n  ",
        "using": [
            "assms",
            "surj_extend_point",
            "inj_extend_point",
            "bij_def"
        ],
        "statement": "lemma bij_extend_point: assumes \"f \\<in> bij(X,Y)\" \"a\\<notin>X\" \"b\\<notin>Y\"\n  shows \"(f \\<union> {\\<langle>a,b\\<rangle>}) \\<in> bij(X\\<union>{a},Y\\<union>{b})\"\n  ",
        "proof": "using assms surj_extend_point inj_extend_point bij_def\n  by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2650
    },
    "2384": {
        "type": "lemma",
        "text": "text\\<open>A quite general form of the $a^{-1}b = 1$ \n  implies $a=b$ law.\\<close>\n",
        "assumes": "assumes A1: \"converse(b) O a = id(A)\" and\n  A2: \"a \\<subseteq> A\\<times>B\" \"b \\<in> surj(A,B)\"\n  ",
        "using": [
            "comp_assoc",
            "right_comp_inverse",
            "surj_def",
            "fun_subset_prod",
            "left_comp_id",
            "right_comp_id"
        ],
        "statement": "lemma comp_inv_id_eq: \n  assumes A1: \"converse(b) O a = id(A)\" and\n  A2: \"a \\<subseteq> A\\<times>B\" \"b \\<in> surj(A,B)\"\n  shows \"a = b\"\n",
        "proof": "proof -\n  from A1 have \"(b O converse(b)) O a = b O id(A)\"\n    using comp_assoc by simp\n  with A2 have \"id(B) O a = b O id(A)\" \n    using right_comp_inverse by simp\n  moreover\n  from A2 have \"a \\<subseteq> A\\<times>B\" and \"b \\<subseteq> A\\<times>B\"\n    using surj_def fun_subset_prod\n    by auto\n  then have \"id(B) O a = a\" and \"b O id(A) = b\"\n    using left_comp_id right_comp_id by auto\n  ultimately show \"a = b\" by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2651
    },
    "2385": {
        "type": "lemma",
        "text": "text\\<open>A special case of \\<open>comp_inv_id_eq\\<close> - \n  the $a^{-1}b = 1$ implies $a=b$ law for bijections.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> bij(A,B)\" \"b \\<in> bij(A,B)\" and\n  A2: \"converse(b) O a = id(A)\"\n  ",
        "using": [
            "bij_def",
            "surj_def",
            "fun_subset_prod"
        ],
        "statement": "lemma comp_inv_id_eq_bij: \n  assumes A1: \"a \\<in> bij(A,B)\" \"b \\<in> bij(A,B)\" and\n  A2: \"converse(b) O a = id(A)\"\n  shows \"a = b\"\n",
        "proof": "proof -\n  from A1 have  \"a \\<subseteq> A\\<times>B\" and \"b \\<in> surj(A,B)\"\n    using bij_def surj_def fun_subset_prod\n    by auto\n  with A2 show \"a = b\" by (rule comp_inv_id_eq)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2652
    },
    "2386": {
        "type": "lemma",
        "text": "text\\<open>Converse of a converse of a bijection is the same bijection. \nThis is a special case of \\<open>converse_converse\\<close> from standard Isabelle's \n\\<open>equalities\\<close> theory where it is proved for relations.\\<close>\n",
        "assumes": "assumes \"a \\<in> bij(A,B)\" \n  ",
        "using": [
            "bij_def",
            "surj_def",
            "fun_subset_prod",
            "converse_converse"
        ],
        "statement": "lemma bij_converse_converse: assumes \"a \\<in> bij(A,B)\" \n  shows \"converse(converse(a)) = a\"\n",
        "proof": "proof -\n  from assms have \"a \\<subseteq> A\\<times>B\" using bij_def surj_def fun_subset_prod by simp\n  then show ?thesis using converse_converse by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2653
    },
    "2387": {
        "type": "lemma",
        "text": "text\\<open>If a composition of bijections is identity, then one is the inverse\n  of the other.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> bij(A,B)\" \"b \\<in> bij(B,A)\" and\n  A2: \"b O a = id(A)\"\n  ",
        "using": [
            "bij_converse_bij",
            "bij_converse_converse"
        ],
        "statement": "lemma comp_id_conv: assumes A1: \"a \\<in> bij(A,B)\" \"b \\<in> bij(B,A)\" and\n  A2: \"b O a = id(A)\"\n  shows \"a = converse(b)\" and \"b = converse(a)\"\n",
        "proof": "proof -\n  from A1 have \"a \\<in> bij(A,B)\" and \"converse(b) \\<in> bij(A,B)\" using bij_converse_bij \n    by auto\n  moreover from assms have \"converse(converse(b)) O a = id(A)\" \n    using bij_converse_converse by simp\n  ultimately show \"a = converse(b)\" by (rule comp_inv_id_eq_bij)\n  with assms show \"b = converse(a)\" using bij_converse_converse by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2654
    },
    "2388": {
        "type": "lemma",
        "text": "text\\<open>A version of \\<open>comp_id_conv\\<close> with weaker assumptions.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> bij(A,B)\" and A2: \"b:B\\<rightarrow>A\" and\n  A3: \"\\<forall>x\\<in>A. b`(a`(x)) = x\"\n  ",
        "using": [
            "bij_def",
            "inj_def",
            "apply_funtype",
            "surj_def",
            "comp_eq_id_iff1",
            "comp_id_conv"
        ],
        "statement": "lemma comp_conv_id: assumes A1: \"a \\<in> bij(A,B)\" and A2: \"b:B\\<rightarrow>A\" and\n  A3: \"\\<forall>x\\<in>A. b`(a`(x)) = x\"\n  shows \"b \\<in> bij(B,A)\" and  \"a = converse(b)\" and \"b = converse(a)\"\n",
        "proof": "proof -\n  have \"b \\<in> surj(B,A)\"\n  proof -\n    have \"\\<forall>x\\<in>A. \\<exists>y\\<in>B. b`(y) = x\"\n    proof -\n      { fix x assume \"x\\<in>A\"\n        let ?y = \"a`(x)\"\n        from A1 A3 \\<open>x\\<in>A\\<close> have \"?y\\<in>B\" and \"b`(?y) = x\" \n          using bij_def inj_def apply_funtype by auto\n        hence \"\\<exists>y\\<in>B. b`(y) = x\" by auto\n      } thus ?thesis by simp \n    qed\n    with A2 show \"b \\<in> surj(B,A)\" using surj_def by simp\n  qed\n  moreover have \"b \\<in> inj(B,A)\"\n  proof -\n    have \"\\<forall>w\\<in>B.\\<forall>y\\<in>B. b`(w) = b`(y) \\<longrightarrow> w=y\"\n    proof -\n      { fix w y assume \"w\\<in>B\"  \"y\\<in>B\" and I: \"b`(w) = b`(y)\"\n        from A1 have \"a \\<in> surj(A,B)\" unfolding bij_def by simp\n        with \\<open>w\\<in>B\\<close> obtain x\\<^sub>w where \"x\\<^sub>w \\<in> A\" and II: \"a`(x\\<^sub>w) = w\"\n          using surj_def by auto\n        with I have \"b`(a`(x\\<^sub>w)) = b`(y)\" by simp \n        moreover from \\<open>a \\<in> surj(A,B)\\<close> \\<open>y\\<in>B\\<close> obtain x\\<^sub>y where \n          \"x\\<^sub>y \\<in> A\" and III: \"a`(x\\<^sub>y) = y\"\n          using surj_def by auto\n        moreover from A3 \\<open>x\\<^sub>w \\<in> A\\<close>  \\<open>x\\<^sub>y \\<in> A\\<close> have \"b`(a`(x\\<^sub>w)) = x\\<^sub>w\" and  \"b`(a`(x\\<^sub>y)) = x\\<^sub>y\"\n          by auto\n        ultimately have \"x\\<^sub>w = x\\<^sub>y\" by simp\n        with II III have \"w=y\" by simp \n      } thus ?thesis by auto  \n    qed\n    with A2 show \"b \\<in> inj(B,A)\" using inj_def by auto\n  qed\n  ultimately show \"b \\<in> bij(B,A)\" using bij_def by simp\n  from assms have \"b O a = id(A)\" using bij_def inj_def comp_eq_id_iff1 by auto\n  with A1 \\<open>b \\<in> bij(B,A)\\<close> show \"a = converse(b)\" and \"b = converse(a)\"\n    using comp_id_conv by auto\nqed  \n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2655
    },
    "2389": {
        "type": "lemma",
        "text": "text\\<open>For a surjection the union if images of singletons\n  is the whole range.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> surj(X,Y)\"\n  ",
        "using": [
            "surj_def",
            "apply_funtype"
        ],
        "statement": "lemma surj_singleton_image: assumes A1: \"f \\<in> surj(X,Y)\"\n  shows \"(\\<Union>x\\<in>X. {f`(x)}) = Y\"\n",
        "proof": "proof\n  from A1 show \"(\\<Union>x\\<in>X. {f`(x)}) \\<subseteq> Y\"\n    using surj_def apply_funtype by auto\nnext \n  { fix y assume \"y \\<in> Y\"\n    with A1 have \"y \\<in> (\\<Union>x\\<in>X. {f`(x)})\"\n      using surj_def by auto\n  } then show  \"Y \\<subseteq> (\\<Union>x\\<in>X. {f`(x)})\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2656
    },
    "2390": {
        "type": "lemma",
        "text": "text\\<open>We can create functions of two variables by combining functions of one variable.\\<close>\n",
        "assumes": "assumes \"f\\<^sub>1:X\\<^sub>1\\<rightarrow>Y\\<^sub>1\"  \"f\\<^sub>2:X\\<^sub>2\\<rightarrow>Y\\<^sub>2\" and\n  \"g = {\\<langle>p,\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> X\\<^sub>1\\<times>X\\<^sub>2}\"\n  ",
        "using": [
            "assms",
            "apply_funtype",
            "ZF_fun_from_total"
        ],
        "statement": "lemma cart_prod_fun: assumes \"f\\<^sub>1:X\\<^sub>1\\<rightarrow>Y\\<^sub>1\"  \"f\\<^sub>2:X\\<^sub>2\\<rightarrow>Y\\<^sub>2\" and\n  \"g = {\\<langle>p,\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> X\\<^sub>1\\<times>X\\<^sub>2}\"\n  shows \"g: X\\<^sub>1\\<times>X\\<^sub>2 \\<rightarrow> Y\\<^sub>1\\<times>Y\\<^sub>2\" ",
        "proof": "using assms apply_funtype  ZF_fun_from_total by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2657
    },
    "2391": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of \\<open>cart_prod_fun\\<close> above in a sligtly different notation.\\<close>\n",
        "assumes": "assumes \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\"  \"g:X\\<^sub>3\\<rightarrow>X\\<^sub>4\"\n  ",
        "using": [
            "cart_prod_fun"
        ],
        "statement": "lemma prod_fun:\n  assumes \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\"  \"g:X\\<^sub>3\\<rightarrow>X\\<^sub>4\"\n  shows \"{\\<langle>\\<langle>x,y\\<rangle>,\\<langle>f`x,g`y\\<rangle>\\<rangle>. \\<langle>x,y\\<rangle>\\<in>X\\<^sub>1\\<times>X\\<^sub>3}:X\\<^sub>1\\<times>X\\<^sub>3\\<rightarrow>X\\<^sub>2\\<times>X\\<^sub>4\" \n",
        "proof": "proof -\n  have \"{\\<langle>\\<langle>x,y\\<rangle>,\\<langle>f`x,g`y\\<rangle>\\<rangle>. \\<langle>x,y\\<rangle>\\<in>X\\<^sub>1\\<times>X\\<^sub>3} = {\\<langle>p,\\<langle>f`(fst(p)),g`(snd(p))\\<rangle>\\<rangle>. p \\<in> X\\<^sub>1\\<times>X\\<^sub>3}\"\n    by auto\n  with assms show ?thesis using cart_prod_fun by simp \nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2658
    },
    "2392": {
        "type": "theorem",
        "text": "text\\<open>Product of two surjections is a surjection.\\<close>\n",
        "assumes": "assumes \"f\\<in>surj(A,B)\" \"g\\<in>surj(C,D)\"\n  ",
        "using": [
            "prod_fun",
            "apply_equality"
        ],
        "statement": "theorem prod_functions_surj:\n  assumes \"f\\<in>surj(A,B)\" \"g\\<in>surj(C,D)\"\n  shows \"{\\<langle>\\<langle>a1,a2\\<rangle>,\\<langle>f`a1,g`a2\\<rangle>\\<rangle>.\\<langle>a1,a2\\<rangle>\\<in>A\\<times>C} \\<in> surj(A\\<times>C,B\\<times>D)\"\n",
        "proof": "proof -\n  let ?h = \"{\\<langle>\\<langle>x, y\\<rangle>, f`(x), g`(y)\\<rangle> . \\<langle>x,y\\<rangle> \\<in> A \\<times> C}\"\n  from assms have fun: \"f:A\\<rightarrow>B\"\"g:C\\<rightarrow>D\" unfolding surj_def by auto\n  then have pfun: \"?h : A \\<times> C \\<rightarrow> B \\<times> D\" using prod_fun by auto\n  {\n    fix b assume \"b\\<in>B\\<times>D\"\n    then obtain b1 b2 where \"b=\\<langle>b1,b2\\<rangle>\" \"b1\\<in>B\" \"b2\\<in>D\" by auto\n    with assms obtain a1 a2 where \"f`(a1)=b1\" \"g`(a2)=b2\" \"a1\\<in>A\" \"a2\\<in>C\" \n      unfolding surj_def by blast\n    hence \"\\<langle>\\<langle>a1,a2\\<rangle>,\\<langle>b1,b2\\<rangle>\\<rangle> \\<in> ?h\" by auto\n    with pfun have \"?h`\\<langle>a1,a2\\<rangle>=\\<langle>b1,b2\\<rangle>\" using apply_equality by auto\n    with \\<open>b=\\<langle>b1,b2\\<rangle>\\<close> \\<open>a1\\<in>A\\<close> \\<open>a2\\<in>C\\<close> have \"\\<exists>a\\<in>A\\<times>C. ?h`(a)=b\" \n      by auto\n  } hence \"\\<forall>b\\<in>B\\<times>D. \\<exists>a\\<in>A\\<times>C. ?h`(a) = b\" by auto\n  with pfun show ?thesis unfolding surj_def by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2659
    },
    "2393": {
        "type": "lemma",
        "text": "text\\<open>For a function of two variables created from functions of one variable as in \n  \\<open>cart_prod_fun\\<close> above, the inverse image of a cartesian product of sets is the \n  cartesian product of inverse images.\\<close>\n",
        "assumes": "assumes \"f\\<^sub>1:X\\<^sub>1\\<rightarrow>Y\\<^sub>1\"  \"f\\<^sub>2:X\\<^sub>2\\<rightarrow>Y\\<^sub>2\" and\n  \"g = {\\<langle>p,\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> X\\<^sub>1\\<times>X\\<^sub>2}\"\n  ",
        "using": [
            "cart_prod_fun",
            "func1_1_L15",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma cart_prod_fun_vimage: assumes \"f\\<^sub>1:X\\<^sub>1\\<rightarrow>Y\\<^sub>1\"  \"f\\<^sub>2:X\\<^sub>2\\<rightarrow>Y\\<^sub>2\" and\n  \"g = {\\<langle>p,\\<langle>f\\<^sub>1`(fst(p)),f\\<^sub>2`(snd(p))\\<rangle>\\<rangle>. p \\<in> X\\<^sub>1\\<times>X\\<^sub>2}\"\n  shows \"g-``(A\\<^sub>1\\<times>A\\<^sub>2) = f\\<^sub>1-``(A\\<^sub>1) \\<times> f\\<^sub>2-``(A\\<^sub>2)\"\n",
        "proof": "proof -\n  from assms have \"g: X\\<^sub>1\\<times>X\\<^sub>2 \\<rightarrow> Y\\<^sub>1\\<times>Y\\<^sub>2\" using cart_prod_fun \n    by simp\n  then have \"g-``(A\\<^sub>1\\<times>A\\<^sub>2) = {p \\<in> X\\<^sub>1\\<times>X\\<^sub>2. g`(p) \\<in> A\\<^sub>1\\<times>A\\<^sub>2}\" using func1_1_L15 \n    by simp\n  with assms \\<open>g: X\\<^sub>1\\<times>X\\<^sub>2 \\<rightarrow> Y\\<^sub>1\\<times>Y\\<^sub>2\\<close> show \"g-``(A\\<^sub>1\\<times>A\\<^sub>2) = f\\<^sub>1-``(A\\<^sub>1) \\<times> f\\<^sub>2-``(A\\<^sub>2)\" \n    using ZF_fun_from_tot_val func1_1_L15 by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2660
    },
    "2394": {
        "type": "definition",
        "text": "text\\<open>For a function of two variables defined on $X\\times Y$, if we fix an \n  $x\\in X$ we obtain a function on $Y$.\n  Note that if \\<open>domain(f)\\<close> is $X\\times Y$, \\<open>range(domain(f))\\<close> \n  extracts $Y$ from $X\\times Y$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Fix1stVar(f,x) \\<equiv> {\\<langle>y,f`\\<langle>x,y\\<rangle>\\<rangle>. y \\<in> range(domain(f))}\"\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2661
    },
    "2395": {
        "type": "definition",
        "text": "text\\<open>For every $y\\in Y$ we can fix the second variable in a binary function\n  $f: X\\times Y \\rightarrow Z$ to get a function on $X$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Fix2ndVar(f,y) \\<equiv> {\\<langle>x,f`\\<langle>x,y\\<rangle>\\<rangle>. x \\<in> domain(domain(f))}\"\n",
        "proof": "",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2662
    },
    "2396": {
        "type": "lemma",
        "text": "text\\<open>We defined \\<open>Fix1stVar\\<close> and \\<open>Fix2ndVar\\<close> so that\n  the domain of the function is not listed in the arguments, but is recovered \n  from the function. The next lemma is a technical fact that makes it easier\n  to use this definition.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\"\n  ",
        "using": [
            "func1_1_L1",
            "Fix1stVar_def",
            "Fix2ndVar_def"
        ],
        "statement": "lemma fix_var_fun_domain: assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\"\n  shows\n  \"x\\<in>X \\<longrightarrow> Fix1stVar(f,x) = {\\<langle>y,f`\\<langle>x,y\\<rangle>\\<rangle>. y \\<in> Y}\"\n  \"y\\<in>Y \\<longrightarrow> Fix2ndVar(f,y) = {\\<langle>x,f`\\<langle>x,y\\<rangle>\\<rangle>. x \\<in> X}\"\n",
        "proof": "proof -\n  from A1 have I: \"domain(f) = X\\<times>Y\" using func1_1_L1 by simp\n  { assume \"x\\<in>X\"\n    with I have \"range(domain(f)) = Y\" by auto\n    then have \"Fix1stVar(f,x) = {\\<langle>y,f`\\<langle>x,y\\<rangle>\\<rangle>. y \\<in> Y}\"\n      using Fix1stVar_def by simp\n  } then show \"x\\<in>X \\<longrightarrow> Fix1stVar(f,x) = {\\<langle>y,f`\\<langle>x,y\\<rangle>\\<rangle>. y \\<in> Y}\"\n    by simp\n  { assume \"y\\<in>Y\"\n    with I have \"domain(domain(f)) = X\" by auto\n    then have \"Fix2ndVar(f,y) = {\\<langle>x,f`\\<langle>x,y\\<rangle>\\<rangle>. x \\<in> X}\"\n      using Fix2ndVar_def by simp\n  } then show \"y\\<in>Y \\<longrightarrow> Fix2ndVar(f,y) = {\\<langle>x,f`\\<langle>x,y\\<rangle>\\<rangle>. x \\<in> X}\"\n    by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2663
    },
    "2397": {
        "type": "lemma",
        "text": "text\\<open>If we fix the first variable, we get a function of the second variable.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"x\\<in>X\"\n  ",
        "using": [
            "apply_funtype",
            "ZF_fun_from_total",
            "fix_var_fun_domain"
        ],
        "statement": "lemma fix_1st_var_fun: assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"x\\<in>X\"\n  shows \"Fix1stVar(f,x) : Y \\<rightarrow> Z\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<forall>y\\<in>Y. f`\\<langle>x,y\\<rangle> \\<in> Z\"\n    using apply_funtype by simp\n  then have \"{\\<langle>y,f`\\<langle>x,y\\<rangle>\\<rangle>. y \\<in> Y} :  Y \\<rightarrow> Z\" using ZF_fun_from_total by simp\n  with A1 A2 show \"Fix1stVar(f,x) : Y \\<rightarrow> Z\" using fix_var_fun_domain by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2664
    },
    "2398": {
        "type": "lemma",
        "text": "text\\<open>If we fix the second variable, we get a function of the first\n  variable.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"y\\<in>Y\"\n  ",
        "using": [
            "apply_funtype",
            "ZF_fun_from_total",
            "fix_var_fun_domain"
        ],
        "statement": "lemma fix_2nd_var_fun: assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"y\\<in>Y\"\n  shows \"Fix2ndVar(f,y) : X \\<rightarrow> Z\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<forall>x\\<in>X. f`\\<langle>x,y\\<rangle> \\<in> Z\"\n    using apply_funtype by simp\n  then have \"{\\<langle>x,f`\\<langle>x,y\\<rangle>\\<rangle>. x \\<in> X} :  X \\<rightarrow> Z\"\n    using ZF_fun_from_total by simp\n  with A1 A2 show \"Fix2ndVar(f,y) : X \\<rightarrow> Z\"\n    using fix_var_fun_domain by simp \nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2665
    },
    "2399": {
        "type": "lemma",
        "text": "text\\<open>What is the value of \\<open>Fix1stVar(f,x)\\<close> at $y\\in Y$\n  and the value of \\<open>Fix2ndVar(f,y)\\<close> at $x\\in X$\"?\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"x\\<in>X\"  \"y\\<in>Y\"\n  ",
        "using": [
            "fix_var_fun_domain",
            "fix_1st_var_fun",
            "fix_2nd_var_fun",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma fix_var_val: \n  assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"x\\<in>X\"  \"y\\<in>Y\"\n  shows \n  \"Fix1stVar(f,x)`(y) = f`\\<langle>x,y\\<rangle>\"\n  \"Fix2ndVar(f,y)`(x) = f`\\<langle>x,y\\<rangle>\"\n",
        "proof": "proof -\n  let ?f\\<^sub>1 = \"{\\<langle>y,f`\\<langle>x,y\\<rangle>\\<rangle>. y \\<in> Y}\"\n  let ?f\\<^sub>2 = \"{\\<langle>x,f`\\<langle>x,y\\<rangle>\\<rangle>. x \\<in> X}\"\n  from A1 A2 have I:\n    \"Fix1stVar(f,x) = ?f\\<^sub>1\"\n    \"Fix2ndVar(f,y) = ?f\\<^sub>2\"\n    using fix_var_fun_domain by auto\n  moreover from A1 A2 have\n    \"Fix1stVar(f,x) : Y \\<rightarrow> Z\"\n    \"Fix2ndVar(f,y) : X \\<rightarrow> Z\"\n    using fix_1st_var_fun fix_2nd_var_fun by auto\n  ultimately have \"?f\\<^sub>1 : Y \\<rightarrow> Z\" and  \"?f\\<^sub>2 : X \\<rightarrow> Z\"\n    by auto\n  with A2 have \"?f\\<^sub>1`(y) = f`\\<langle>x,y\\<rangle>\" and \"?f\\<^sub>2`(x) = f`\\<langle>x,y\\<rangle>\"\n    using ZF_fun_from_tot_val by auto\n  with I show\n    \"Fix1stVar(f,x)`(y) = f`\\<langle>x,y\\<rangle>\"\n    \"Fix2ndVar(f,y)`(x) = f`\\<langle>x,y\\<rangle>\"\n    by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2666
    },
    "2400": {
        "type": "lemma",
        "text": "text\\<open>Fixing the second variable commutes with restrictig the domain.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"y\\<in>Y\" and A3: \"X\\<^sub>1 \\<subseteq> X\"\n  ",
        "using": [
            "restrict_type2",
            "fix_2nd_var_fun",
            "restrict",
            "fix_var_val"
        ],
        "statement": "lemma fix_2nd_var_restr_comm: \n  assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"y\\<in>Y\" and A3: \"X\\<^sub>1 \\<subseteq> X\"\n  shows \"Fix2ndVar(restrict(f,X\\<^sub>1\\<times>Y),y) = restrict(Fix2ndVar(f,y),X\\<^sub>1)\"\n",
        "proof": "proof -\n  let ?g = \"Fix2ndVar(restrict(f,X\\<^sub>1\\<times>Y),y)\"\n  let ?h = \"restrict(Fix2ndVar(f,y),X\\<^sub>1)\"\n  from A3 have I: \"X\\<^sub>1\\<times>Y \\<subseteq> X\\<times>Y\" by auto\n  with A1 have II: \"restrict(f,X\\<^sub>1\\<times>Y) : X\\<^sub>1\\<times>Y \\<rightarrow> Z\"\n    using restrict_type2 by simp\n  with A2 have \"?g : X\\<^sub>1 \\<rightarrow> Z\"\n    using fix_2nd_var_fun by simp\n  moreover\n  from A1 A2 have III: \"Fix2ndVar(f,y) : X \\<rightarrow> Z\"\n    using fix_2nd_var_fun by simp\n  with A3 have \"?h : X\\<^sub>1 \\<rightarrow> Z\"\n    using restrict_type2 by simp\n  moreover\n  { fix z assume A4: \"z \\<in> X\\<^sub>1\"\n    with A2 I II have \"?g`(z) = f`\\<langle>z,y\\<rangle>\"\n      using restrict fix_var_val by simp\n    also from A1 A2 A3 A4 have \"f`\\<langle>z,y\\<rangle> = ?h`(z)\"\n      using restrict fix_var_val by auto\n    finally have \"?g`(z) = ?h`(z)\" by simp\n  } then have \"\\<forall>z \\<in> X\\<^sub>1. ?g`(z) = ?h`(z)\" by simp\n  ultimately show \"?g = ?h\" by (rule func_eq)\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2667
    },
    "2401": {
        "type": "lemma",
        "text": "text\\<open>The next lemma expresses the inverse image of a set by function with fixed \nfirst variable in terms of the original function.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"x\\<in>X\" \n  ",
        "using": [
            "fix_1st_var_fun",
            "func1_1_L15",
            "fix_var_val"
        ],
        "statement": "lemma fix_1st_var_vimage:\n  assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"x\\<in>X\" \n  shows \"Fix1stVar(f,x)-``(A) = {y\\<in>Y. \\<langle>x,y\\<rangle> \\<in> f-``(A)}\"\n",
        "proof": "proof -\n  from assms have \"Fix1stVar(f,x)-``(A) = {y\\<in>Y. Fix1stVar(f,x)`(y) \\<in> A}\"\n    using fix_1st_var_fun func1_1_L15 by blast\n  with assms show ?thesis using fix_var_val func1_1_L15 by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2668
    },
    "2402": {
        "type": "lemma",
        "text": "text\\<open>The next lemma expresses the inverse image of a set by function with fixed \nsecond variable in terms of the original function.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"y\\<in>Y\" \n  ",
        "using": [
            "fix_2nd_var_fun",
            "func1_1_L15",
            "fix_var_val"
        ],
        "statement": "lemma fix_2nd_var_vimage:\n  assumes A1: \"f : X\\<times>Y \\<rightarrow> Z\" and A2: \"y\\<in>Y\" \n  shows \"Fix2ndVar(f,y)-``(A) = {x\\<in>X. \\<langle>x,y\\<rangle> \\<in> f-``(A)}\"\n",
        "proof": "proof -\n  from assms have I: \"Fix2ndVar(f,y)-``(A) = {x\\<in>X. Fix2ndVar(f,y)`(x) \\<in> A}\"\n    using fix_2nd_var_fun func1_1_L15 by blast\n  with assms show ?thesis using fix_var_val func1_1_L15 by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2669
    },
    "2403": {
        "type": "definition",
        "text": "text\\<open>Since we are writing in generic set notation, \n  the definition below is a bit complicated. Here it what it says:\n  Given a set $X$ and another set $f$ (that represents a binary function on $X$) \n  we are defining $f$ lifted to function space over $X$\n  as the binary function (a set of pairs) on the space \n  $F = X \\rightarrow \\textrm{range}(f)$ such that the value of this function\n  on pair $\\langle a,b \\rangle$ of functions on $X$ is another function $c$ on $X$\n  with values defined by $c(x) = f\\langle a(x), b(x)\\rangle$. \n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\nLift2FcnSpce (infix \"{lifted to function space over}\" 65) where\n \"f {lifted to function space over} X \\<equiv> \n  {\\<langle> p,{\\<langle>x,f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\\<rangle>. x \\<in> X}\\<rangle>. \n  p \\<in> (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2670
    },
    "2404": {
        "type": "lemma",
        "text": "text\\<open>The result of the lift belongs to the function space.\\<close>\n",
        "assumes": "assumes A1: \"f : Y\\<times>Y\\<rightarrow>Y\" \n  and A2: \"p \\<in>(X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\"\n  ",
        "using": [
            "apply_type",
            "func1_1_L5B",
            "apply_Pair",
            "rangeI",
            "ZF_fun_from_total"
        ],
        "statement": "lemma func_ZF_1_L1: \n  assumes A1: \"f : Y\\<times>Y\\<rightarrow>Y\" \n  and A2: \"p \\<in>(X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\"\n  shows \n  \"{\\<langle>x,f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\\<rangle>. x \\<in> X} : X\\<rightarrow>range(f)\"\n  ",
        "proof": "proof -\n    have \"\\<forall>x\\<in>X. f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle> \\<in> range(f)\"\n    proof\n      fix x assume \"x\\<in>X\"\n      let ?p = \"\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\"\n      from A2 \\<open>x\\<in>X\\<close> have \n\t\"fst(p)`(x) \\<in> range(f)\"  \"snd(p)`(x) \\<in> range(f)\"\n\tusing apply_type by auto\n      with A1 have \"?p \\<in> Y\\<times>Y\"\n\tusing func1_1_L5B by blast\n      with A1 have \"\\<langle>?p, f`(?p)\\<rangle> \\<in> f\"\n\tusing apply_Pair by simp\n      with A1 show \n\t\"f`(?p) \\<in> range(f)\"\n\tusing rangeI by simp\n    qed\n    then show ?thesis using ZF_fun_from_total by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2671
    },
    "2405": {
        "type": "theorem",
        "text": "text\\<open>The values of the lift are defined by the values of the liftee in\n  the natural way.\\<close>\n",
        "assumes": "assumes A1: \"f : Y\\<times>Y\\<rightarrow>Y\"\n  and A2: \"F = f {lifted to function space over} X\"\n  and A3: \"s:X\\<rightarrow>range(f)\" \"r:X\\<rightarrow>range(f)\"  \n  and A4: \"x\\<in>X\"\n  ",
        "using": [
            "func_ZF_1_L3",
            "Lift2FcnSpce_def",
            "ZF_fun_from_tot_val"
        ],
        "statement": "theorem func_ZF_1_L4: \n  assumes A1: \"f : Y\\<times>Y\\<rightarrow>Y\"\n  and A2: \"F = f {lifted to function space over} X\"\n  and A3: \"s:X\\<rightarrow>range(f)\" \"r:X\\<rightarrow>range(f)\"  \n  and A4: \"x\\<in>X\"\n  shows \"(F`\\<langle>s,r\\<rangle>)`(x) = f`\\<langle>s`(x),r`(x)\\<rangle>\"\n",
        "proof": "proof -\n  let ?p = \"\\<langle>s,r\\<rangle>\"\n  let ?P = \"{\\<langle>x,f`\\<langle>fst(?p)`(x),snd(?p)`(x)\\<rangle>\\<rangle>. x \\<in> X}\" \n  from A1 A3 A4 have\n    \"f : Y\\<times>Y\\<rightarrow>Y\"  \"?p \\<in> (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\"\n    \"x\\<in>X\"  \"?P = {\\<langle>x,f`\\<langle>fst(?p)`(x),snd(?p)`(x)\\<rangle>\\<rangle>. x \\<in> X}\" \n    by auto\n  then have \"?P`(x) = f`\\<langle>fst(?p)`(x),snd(?p)`(x)\\<rangle>\"\n    by (rule func_ZF_1_L2)\n  hence \"?P`(x) = f`\\<langle>s`(x),r`(x)\\<rangle>\" by auto\n  moreover have \"?P = F`\\<langle>s,r\\<rangle>\"\n  proof -\n    from A1 A2 have \"F : (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\\<rightarrow>(X\\<rightarrow>range(f))\"\n      using func_ZF_1_L3 by simp\n    moreover from A3 have \"?p \\<in> (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\"\n      by auto\n    moreover from A2 have\n      \"F = {\\<langle>p,{\\<langle>x,f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\\<rangle>. x \\<in> X}\\<rangle>. \n      p \\<in> (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))}\"\n      using Lift2FcnSpce_def by simp\n    ultimately show ?thesis using ZF_fun_from_tot_val\n      by simp\n  qed\n  ultimately show \"(F`\\<langle>s,r\\<rangle>)`(x) = f`\\<langle>s`(x),r`(x)\\<rangle>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2674
    },
    "2406": {
        "type": "definition",
        "text": "text\\<open>Typically we say that a binary operation \"$\\cdot $\" \n  on a set $G$ is ''associative''\n  if $(x\\cdot y)\\cdot z = x\\cdot (y\\cdot z)$ for all $x,y,z \\in G$.\n  Our actual definition below does not use the multiplicative notation\n  so that we can apply it equally to the additive notation $+$ \n  or whatever infix symbol we may want to use. \n  Instead, we use the generic set theory notation\n  and write $P\\langle x,y \\rangle$ to denote the value of the operation\n  $P$ on a pair $\\langle x,y \\rangle \\in G\\times G$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  IsAssociative (infix \"{is associative on}\" 65) where\n  \"P {is associative on} G \\<equiv> P : G\\<times>G\\<rightarrow>G \\<and> \n  (\\<forall> x \\<in> G. \\<forall> y \\<in> G. \\<forall> z \\<in> G. \n  ( P`(\\<langle>P`(\\<langle>x,y\\<rangle>),z\\<rangle>) = P`( \\<langle>x,P`(\\<langle>y,z\\<rangle>)\\<rangle> )))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2675
    },
    "2407": {
        "type": "definition",
        "text": "text\\<open>A binary function $f: X\\times X \\rightarrow Y$ is commutative\n  if $f\\langle x,y \\rangle = f\\langle y,x \\rangle$. Note that\n  in the definition of associativity above we talk about binary\n  ''operation'' and here we say use the term binary ''function''. \n  This is not set in stone, but usually the word \"operation\" is used \n  when the range is a factor of the domain, while the word \"function\"\n  allows the range to be a completely unrelated set.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsCommutative (infix \"{is commutative on}\" 65) where\n  \"f {is commutative on} G \\<equiv> \\<forall>x\\<in>G. \\<forall>y\\<in>G. f`\\<langle>x,y\\<rangle> = f`\\<langle>y,x\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2676
    },
    "2408": {
        "type": "lemma",
        "text": "text\\<open>The lift of a commutative function is commutative.\\<close>\n",
        "assumes": "assumes A1: \"f : G\\<times>G\\<rightarrow>G\"\n  and A2: \"F = f {lifted to function space over} X\"\n  and A3: \"s : X\\<rightarrow>range(f)\" \"r : X\\<rightarrow>range(f)\" \n  and A4: \"f {is commutative on} G\"\n  ",
        "using": [
            "func_ZF_1_L3",
            "apply_type",
            "func1_1_L5B",
            "func_ZF_1_L4",
            "IsCommutative_def",
            "fun_extension_iff"
        ],
        "statement": "lemma func_ZF_2_L1:\n  assumes A1: \"f : G\\<times>G\\<rightarrow>G\"\n  and A2: \"F = f {lifted to function space over} X\"\n  and A3: \"s : X\\<rightarrow>range(f)\" \"r : X\\<rightarrow>range(f)\" \n  and A4: \"f {is commutative on} G\"\n  shows \"F`\\<langle>s,r\\<rangle> = F`\\<langle>r,s\\<rangle>\" \n",
        "proof": "proof -\n  from A1 A2 have \n    \"F : (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\\<rightarrow>(X\\<rightarrow>range(f))\"\n    using func_ZF_1_L3 by simp \n  with A3 have \n    \"F`\\<langle>s,r\\<rangle> : X\\<rightarrow>range(f)\" and \"F`\\<langle>r,s\\<rangle> : X\\<rightarrow>range(f)\"\n    using apply_type by auto\n  moreover have \n    \"\\<forall>x\\<in>X. (F`\\<langle>s,r\\<rangle>)`(x) = (F`\\<langle>r,s\\<rangle>)`(x)\"\n  proof\n    fix x assume \"x\\<in>X\"\n    from A1 have \"range(f)\\<subseteq>G\"\n      using func1_1_L5B by simp\n    with A3 \\<open>x\\<in>X\\<close> have \"s`(x) \\<in> G\" and \"r`(x) \\<in> G\"\n      using apply_type by auto\n    with A1 A2 A3 A4 \\<open>x\\<in>X\\<close> show \n      \"(F`\\<langle>s,r\\<rangle>)`(x) = (F`\\<langle>r,s\\<rangle>)`(x)\"\n      using func_ZF_1_L4 IsCommutative_def by simp\n  qed\n  ultimately show ?thesis using fun_extension_iff\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2677
    },
    "2409": {
        "type": "lemma",
        "text": "text\\<open>The lift of a commutative function is commutative \n  on the function space.\\<close>\n",
        "assumes": "assumes \"f : G\\<times>G\\<rightarrow>G\"\n  and \"f {is commutative on} G\"\n  and \"F = f {lifted to function space over} X\"\n  ",
        "using": [
            "assms",
            "IsCommutative_def",
            "func_ZF_2_L1"
        ],
        "statement": "lemma func_ZF_2_L2:\n  assumes \"f : G\\<times>G\\<rightarrow>G\"\n  and \"f {is commutative on} G\"\n  and \"F = f {lifted to function space over} X\"\n  shows \"F {is commutative on} (X\\<rightarrow>range(f))\"\n  ",
        "proof": "using assms IsCommutative_def func_ZF_2_L1 by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2678
    },
    "2410": {
        "type": "lemma",
        "text": "text\\<open>The lift of an associative function is associative.\\<close>\n",
        "assumes": "assumes A2: \"F = f {lifted to function space over} X\"\n  and A3: \"s : X\\<rightarrow>range(f)\" \"r : X\\<rightarrow>range(f)\" \"q : X\\<rightarrow>range(f)\"\n  and A4: \"f {is associative on} G\"\n  ",
        "using": [
            "IsAssociative_def",
            "func_ZF_1_L3",
            "apply_type",
            "func1_1_L5B",
            "func_ZF_1_L4",
            "fun_extension_iff"
        ],
        "statement": "lemma func_ZF_2_L3:\n  assumes A2: \"F = f {lifted to function space over} X\"\n  and A3: \"s : X\\<rightarrow>range(f)\" \"r : X\\<rightarrow>range(f)\" \"q : X\\<rightarrow>range(f)\"\n  and A4: \"f {is associative on} G\"\n  shows \"F`\\<langle>F`\\<langle>s,r\\<rangle>,q\\<rangle> = F`\\<langle>s,F`\\<langle>r,q\\<rangle>\\<rangle>\"\n",
        "proof": "proof -\n  from A4 A2 have \n    \"F : (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\\<rightarrow>(X\\<rightarrow>range(f))\"\n    using IsAssociative_def func_ZF_1_L3 by auto\n  with A3 have I:\n    \"F`\\<langle>s,r\\<rangle> : X\\<rightarrow>range(f)\"\n    \"F`\\<langle>r,q\\<rangle> : X\\<rightarrow>range(f)\"\n    \"F`\\<langle>F`\\<langle>s,r\\<rangle>,q\\<rangle> : X\\<rightarrow>range(f)\"\n    \"F`\\<langle>s,F`\\<langle>r,q\\<rangle>\\<rangle>: X\\<rightarrow>range(f)\"\n    using apply_type by auto\n  moreover have\n    \"\\<forall>x\\<in>X. (F`\\<langle>F`\\<langle>s,r\\<rangle>,q\\<rangle>)`(x) = (F`\\<langle>s,F`\\<langle>r,q\\<rangle>\\<rangle>)`(x)\"\n  proof\n    fix x assume \"x\\<in>X\"\n    from A4 have \"f:G\\<times>G\\<rightarrow>G\"\n      using IsAssociative_def by simp\n    then have \"range(f)\\<subseteq>G\"\n      using func1_1_L5B by simp\n    with A3 \\<open>x\\<in>X\\<close> have \n      \"s`(x) \\<in> G\" \"r`(x) \\<in> G\" \"q`(x) \\<in> G\"\n      using apply_type by auto\n    with A2 I A3 A4 \\<open>x\\<in>X\\<close> \\<open>f:G\\<times>G\\<rightarrow>G\\<close> show \n      \"(F`\\<langle>F`\\<langle>s,r\\<rangle>,q\\<rangle>)`(x) = (F`\\<langle>s,F`\\<langle>r,q\\<rangle>\\<rangle>)`(x)\"\n      using func_ZF_1_L4 IsAssociative_def by simp\n  qed\n  ultimately show ?thesis using fun_extension_iff\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2679
    },
    "2411": {
        "type": "lemma",
        "text": "text\\<open>The lift of an associative function is associative \n  on the function space.\\<close>\n",
        "assumes": "assumes A1: \"f {is associative on} G\"\n  and A2: \"F = f {lifted to function space over} X\"\n  ",
        "using": [
            "IsAssociative_def",
            "func_ZF_1_L3",
            "func_ZF_2_L3"
        ],
        "statement": "lemma func_ZF_2_L4:\n  assumes A1: \"f {is associative on} G\"\n  and A2: \"F = f {lifted to function space over} X\"\n  shows \"F {is associative on} (X\\<rightarrow>range(f))\"\n",
        "proof": "proof -\n  from A1 A2 have\n    \"F : (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\\<rightarrow>(X\\<rightarrow>range(f))\"\n    using IsAssociative_def func_ZF_1_L3 by auto\n  moreover from A1 A2 have\n    \"\\<forall>s \\<in> X\\<rightarrow>range(f). \\<forall> r \\<in> X\\<rightarrow>range(f). \\<forall>q \\<in> X\\<rightarrow>range(f).\n    F`\\<langle>F`\\<langle>s,r\\<rangle>,q\\<rangle> = F`\\<langle>s,F`\\<langle>r,q\\<rangle>\\<rangle>\"\n    using func_ZF_2_L3 by simp\n  ultimately show ?thesis using IsAssociative_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2680
    },
    "2412": {
        "type": "lemma",
        "text": "text\\<open>The commutativity is inherited when restricting a function to a set.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<times>X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  and A3: \"f {is commutative on} X\"\n  ",
        "using": [
            "IsCommutative_def",
            "restrict_if"
        ],
        "statement": "lemma func_ZF_4_L1: \n  assumes A1: \"f:X\\<times>X\\<rightarrow>Y\" and A2: \"A\\<subseteq>X\"\n  and A3: \"f {is commutative on} X\"\n  shows \"restrict(f,A\\<times>A) {is commutative on} A\"\n",
        "proof": "proof -\n  { fix x y assume \"x\\<in>A\" and \"y\\<in>A\"\n    with A2 have \"x\\<in>X\" and \"y\\<in>X\" by auto\n    with A3 \\<open>x\\<in>A\\<close> \\<open>y\\<in>A\\<close> have \n      \"restrict(f,A\\<times>A)`\\<langle>x,y\\<rangle> = restrict(f,A\\<times>A)`\\<langle>y,x\\<rangle>\"\n      using IsCommutative_def restrict_if by simp }\n  then show ?thesis using IsCommutative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2681
    },
    "2413": {
        "type": "definition",
        "text": "text\\<open>Next we define what it means that a set is closed with \n  respect to an operation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsOpClosed (infix \"{is closed under}\" 65) where\n  \"A {is closed under} f \\<equiv> \\<forall>x\\<in>A. \\<forall>y\\<in>A. f`\\<langle>x,y\\<rangle> \\<in> A\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2682
    },
    "2414": {
        "type": "lemma",
        "text": "text\\<open>Associative operation restricted to a set that is closed with\n  resp. to this operation is associative.\\<close>\n",
        "assumes": "assumes A1: \"f {is associative on} X\"\n  and A2: \"A\\<subseteq>X\" and A3: \"A {is closed under} f\"\n  and A4: \"x\\<in>A\" \"y\\<in>A\" \"z\\<in>A\"\n  and A5: \"g = restrict(f,A\\<times>A)\"\n  ",
        "using": [
            "IsOpClosed_def",
            "restrict_if",
            "IsAssociative_def"
        ],
        "statement": "lemma func_ZF_4_L2:assumes A1: \"f {is associative on} X\"\n  and A2: \"A\\<subseteq>X\" and A3: \"A {is closed under} f\"\n  and A4: \"x\\<in>A\" \"y\\<in>A\" \"z\\<in>A\"\n  and A5: \"g = restrict(f,A\\<times>A)\"\n  shows \"g`\\<langle>g`\\<langle>x,y\\<rangle>,z\\<rangle> = g`\\<langle>x,g`\\<langle>y,z\\<rangle>\\<rangle>\"\n",
        "proof": "proof - \n  from A4 A2 have I: \"x\\<in>X\" \"y\\<in>X\" \"z\\<in>X\"\n    by auto\n  from A3 A4 A5 have\n    \"g`\\<langle>g`\\<langle>x,y\\<rangle>,z\\<rangle> = f`\\<langle>f`\\<langle>x,y\\<rangle>,z\\<rangle>\"\n    \"g`\\<langle>x,g`\\<langle>y,z\\<rangle>\\<rangle> = f`\\<langle>x,f`\\<langle>y,z\\<rangle>\\<rangle>\"\n    using IsOpClosed_def restrict_if by auto\n  moreover from A1 I have\n    \"f`\\<langle>f`\\<langle>x,y\\<rangle>,z\\<rangle> = f`\\<langle>x,f`\\<langle>y,z\\<rangle>\\<rangle>\"\n    using IsAssociative_def by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2683
    },
    "2415": {
        "type": "lemma",
        "text": "text\\<open>An associative operation restricted to a set that is closed with\n  resp. to this operation is associative on the set.\\<close>\n",
        "assumes": "assumes A1: \"f {is associative on} X\"\n  and A2: \"A\\<subseteq>X\" and A3: \"A {is closed under} f\"\n  ",
        "using": [
            "IsAssociative_def",
            "IsOpClosed_def",
            "restrict_if",
            "func1_2_L4",
            "func_ZF_4_L2"
        ],
        "statement": "lemma func_ZF_4_L3: assumes A1: \"f {is associative on} X\"\n  and A2: \"A\\<subseteq>X\" and A3: \"A {is closed under} f\"\n  shows \"restrict(f,A\\<times>A) {is associative on} A\"\n",
        "proof": "proof -\n  let ?g = \"restrict(f,A\\<times>A)\"\n  from A1 have \"f:X\\<times>X\\<rightarrow>X\"\n    using IsAssociative_def by simp\n  moreover from A2 have \"A\\<times>A \\<subseteq> X\\<times>X\" by auto\n  moreover from A3 have \"\\<forall>p \\<in> A\\<times>A. ?g`(p) \\<in> A\"\n    using IsOpClosed_def restrict_if by auto\n  ultimately have \"?g : A\\<times>A\\<rightarrow>A\"\n    using func1_2_L4 by simp\n  moreover from  A1 A2 A3 have\n    \"\\<forall> x \\<in> A. \\<forall> y \\<in> A. \\<forall> z \\<in> A.\n    ?g`\\<langle>?g`\\<langle>x,y\\<rangle>,z\\<rangle> = ?g`\\<langle> x,?g`\\<langle>y,z\\<rangle>\\<rangle>\"\n    using func_ZF_4_L2 by simp\n  ultimately show ?thesis \n    using IsAssociative_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2684
    },
    "2416": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that if a set $A$ is closed \n  with respect to an operation, \n  then it is closed under this operation restricted \n  to any superset of $A$.\\<close>\n",
        "assumes": "assumes \"A {is closed under} f\"\n  and \"A\\<subseteq>B\" and \"x\\<in>A\"  \"y\\<in>A\" and \"g = restrict(f,B\\<times>B)\"\n  ",
        "using": [
            "assms",
            "IsOpClosed_def",
            "restrict"
        ],
        "statement": "lemma func_ZF_4_L4: assumes \"A {is closed under} f\"\n  and \"A\\<subseteq>B\" and \"x\\<in>A\"  \"y\\<in>A\" and \"g = restrict(f,B\\<times>B)\"\n  shows \"g`\\<langle>x,y\\<rangle> \\<in> A\"\n  ",
        "proof": "using assms IsOpClosed_def restrict by auto\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2685
    },
    "2417": {
        "type": "lemma",
        "text": "text\\<open>If a set $A$ is closed under an operation, \n  then it is closed under this operation restricted \n  to any superset of $A$.\\<close>\n",
        "assumes": "assumes A1: \"A {is closed under} f\"\n  and A2: \"A\\<subseteq>B\"\n  ",
        "using": [
            "func_ZF_4_L4",
            "IsOpClosed_def"
        ],
        "statement": "lemma func_ZF_4_L5: \n  assumes A1: \"A {is closed under} f\"\n  and A2: \"A\\<subseteq>B\"\n  shows \"A {is closed under} restrict(f,B\\<times>B)\"\n",
        "proof": "proof -\n  let ?g = \"restrict(f,B\\<times>B)\"\n  from A1 A2 have \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. ?g`\\<langle>x,y\\<rangle> \\<in> A\"\n    using func_ZF_4_L4 by simp\n  then show ?thesis using IsOpClosed_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2686
    },
    "2418": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that intersection of sets that are\n  closed with respect to an operation is closed with respect \n  to the operation.\\<close>\n",
        "assumes": "assumes \"A {is closed under} f\" \n  and \"B {is closed under} f\"\n  and \"x \\<in> A\\<inter>B\" \"y\\<in> A\\<inter>B\"\n  ",
        "using": [
            "assms",
            "IsOpClosed_def"
        ],
        "statement": "lemma func_ZF_4_L6:\n  assumes \"A {is closed under} f\" \n  and \"B {is closed under} f\"\n  and \"x \\<in> A\\<inter>B\" \"y\\<in> A\\<inter>B\"\n  shows \"f`\\<langle>x,y\\<rangle> \\<in> A\\<inter>B\" ",
        "proof": "using assms IsOpClosed_def by auto\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2687
    },
    "2419": {
        "type": "lemma",
        "text": "text\\<open>Intersection of sets that are\n  closed with respect to an operation is closed under \n  the operation.\\<close>\n",
        "assumes": "assumes \"A {is closed under} f\"\n  \"B {is closed under} f\"\n  ",
        "using": [
            "assms",
            "IsOpClosed_def"
        ],
        "statement": "lemma func_ZF_4_L7:\n  assumes \"A {is closed under} f\"\n  \"B {is closed under} f\"\n  shows \"A\\<inter>B {is closed under} f\"\n  ",
        "proof": "using assms IsOpClosed_def by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2688
    },
    "2420": {
        "type": "definition",
        "text": "text\\<open>We define the notion of composition on the set $X$ as the\n  binary operation on the function space $X\\rightarrow X$\n  that takes two functions and creates the their composition.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Composition(X) \\<equiv> \n  {\\<langle>p,fst(p) O snd(p)\\<rangle>. p \\<in> (X\\<rightarrow>X)\\<times>(X\\<rightarrow>X)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2689
    },
    "2421": {
        "type": "lemma",
        "text": "text\\<open>Composition operation is a function that maps \n  $(X\\rightarrow X)\\times (X\\rightarrow X)$ into $X\\rightarrow X$.\\<close>\n",
        "assumes": "",
        "using": [
            "comp_fun",
            "Composition_def",
            "ZF_fun_from_total"
        ],
        "statement": "lemma func_ZF_5_L1: shows \"Composition(X) : (X\\<rightarrow>X)\\<times>(X\\<rightarrow>X)\\<rightarrow>(X\\<rightarrow>X)\"\n  ",
        "proof": "using comp_fun Composition_def ZF_fun_from_total by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2690
    },
    "2422": {
        "type": "lemma",
        "text": "text\\<open>The value of the composition operation is the composition of arguments.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>X\" and \"g:X\\<rightarrow>X\"\n  ",
        "using": [
            "func_ZF_5_L1",
            "Composition_def",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma func_ZF_5_L2: assumes \"f:X\\<rightarrow>X\" and \"g:X\\<rightarrow>X\"\n  shows \"Composition(X)`\\<langle>f,g\\<rangle> = f O g\" \n",
        "proof": "proof -\n  from assms have \n    \"Composition(X) : (X\\<rightarrow>X)\\<times>(X\\<rightarrow>X)\\<rightarrow>(X\\<rightarrow>X)\"\n    \"\\<langle>f,g\\<rangle> \\<in> (X\\<rightarrow>X)\\<times>(X\\<rightarrow>X)\"\n    \"Composition(X) = {\\<langle>p,fst(p) O snd(p)\\<rangle>. p \\<in> (X\\<rightarrow>X)\\<times>(X\\<rightarrow>X)}\"\n    using  func_ZF_5_L1 Composition_def by auto\n  then show \"Composition(X)`\\<langle>f,g\\<rangle> = f O g\"\n    using  ZF_fun_from_tot_val by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2691
    },
    "2423": {
        "type": "lemma",
        "text": "text\\<open>What is the value of a composition on an argument?\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>X\" and \"g:X\\<rightarrow>X\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "func_ZF_5_L2",
            "comp_fun_apply"
        ],
        "statement": "lemma func_ZF_5_L3: assumes \"f:X\\<rightarrow>X\" and \"g:X\\<rightarrow>X\" and \"x\\<in>X\"\n  shows \"(Composition(X)`\\<langle>f,g\\<rangle>)`(x) = f`(g`(x))\"\n  ",
        "proof": "using assms func_ZF_5_L2 comp_fun_apply by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2692
    },
    "2424": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that composition is associative.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>X\" \"g:X\\<rightarrow>X\" \"h:X\\<rightarrow>X\"\n  and A2: \"C = Composition(X)\"\n  ",
        "using": [
            "func_ZF_5_L1",
            "apply_funtype",
            "func_ZF_5_L3",
            "fun_extension_iff"
        ],
        "statement": "lemma func_ZF_5_L4: assumes A1: \"f:X\\<rightarrow>X\" \"g:X\\<rightarrow>X\" \"h:X\\<rightarrow>X\"\n  and A2: \"C = Composition(X)\"\n  shows \"C`\\<langle>C`\\<langle>f,g\\<rangle>,h\\<rangle> = C`\\<langle> f,C`\\<langle>g,h\\<rangle>\\<rangle>\"\n",
        "proof": "proof - \n  from A2 have \"C : ((X\\<rightarrow>X)\\<times>(X\\<rightarrow>X))\\<rightarrow>(X\\<rightarrow>X)\"\n    using func_ZF_5_L1 by simp\n  with A1 have I:\n    \"C`\\<langle>f,g\\<rangle> : X\\<rightarrow>X\"\n    \"C`\\<langle>g,h\\<rangle> : X\\<rightarrow>X\"\n    \"C`\\<langle>C`\\<langle>f,g\\<rangle>,h\\<rangle> : X\\<rightarrow>X\"\n    \"C`\\<langle> f,C`\\<langle>g,h\\<rangle>\\<rangle> : X\\<rightarrow>X\"\n    using apply_funtype by auto\n  moreover have \n    \"\\<forall> x \\<in> X. C`\\<langle>C`\\<langle>f,g\\<rangle>,h\\<rangle>`(x) = C`\\<langle>f,C`\\<langle>g,h\\<rangle>\\<rangle>`(x)\"\n  proof\n    fix x assume \"x\\<in>X\"\n    with A1 A2 I have \n      \"C`\\<langle>C`\\<langle>f,g\\<rangle>,h\\<rangle> ` (x) = f`(g`(h`(x)))\"\n      \"C`\\<langle> f,C`\\<langle>g,h\\<rangle>\\<rangle>`(x) = f`(g`(h`(x)))\"\n      using func_ZF_5_L3 apply_funtype by auto\n    then show \"C`\\<langle>C`\\<langle>f,g\\<rangle>,h\\<rangle>`(x) = C`\\<langle> f,C`\\<langle>g,h\\<rangle>\\<rangle>`(x)\"\n      by simp\n    qed\n  ultimately show ?thesis using fun_extension_iff by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2693
    },
    "2425": {
        "type": "lemma",
        "text": "text\\<open>Composition is an associative operation on $X\\rightarrow X$ (the space\n  of functions that map $X$ into itself).\\<close>\n",
        "assumes": "",
        "using": [
            "func_ZF_5_L4",
            "func_ZF_5_L1",
            "IsAssociative_def"
        ],
        "statement": "lemma func_ZF_5_L5: shows \"Composition(X) {is associative on} (X\\<rightarrow>X)\"\n",
        "proof": "proof -\n  let ?C = \"Composition(X)\"\n  have \"\\<forall>f\\<in>X\\<rightarrow>X. \\<forall>g\\<in>X\\<rightarrow>X. \\<forall>h\\<in>X\\<rightarrow>X.\n    ?C`\\<langle>?C`\\<langle>f,g\\<rangle>,h\\<rangle> = ?C`\\<langle>f,?C`\\<langle>g,h\\<rangle>\\<rangle>\"\n    using func_ZF_5_L4 by simp\n  then show ?thesis using func_ZF_5_L1 IsAssociative_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2694
    },
    "2426": {
        "type": "lemma",
        "text": "text\\<open>A function that maps every point to itself is the identity on its domain.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" and A2:\"\\<forall>x\\<in>X. f`(x)=x\"\n  ",
        "using": [
            "id_type",
            "id_conv"
        ],
        "statement": "lemma indentity_fun: assumes A1: \"f:X\\<rightarrow>Y\" and A2:\"\\<forall>x\\<in>X. f`(x)=x\"\n  shows \"f = id(X)\"\n",
        "proof": "proof -\n  from assms have \"f:X\\<rightarrow>Y\" and \"id(X):X\\<rightarrow>X\" and \"\\<forall>x\\<in>X. f`(x) = id(X)`(x)\"\n    using id_type id_conv by auto \n  then show ?thesis by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2695
    },
    "2427": {
        "type": "lemma",
        "text": "text\\<open>Composing a function with identity does not change the function.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<rightarrow>X\"\n  ",
        "using": [
            "func_ZF_5_L1",
            "id_type",
            "apply_funtype",
            "func_ZF_5_L3",
            "id_conv",
            "fun_extension_iff"
        ],
        "statement": "lemma func_ZF_6_L1A: assumes A1: \"f : X\\<rightarrow>X\"\n  shows \"Composition(X)`\\<langle>f,id(X)\\<rangle> = f\"\n  \"Composition(X)`\\<langle>id(X),f\\<rangle> = f\"\n",
        "proof": "proof -\n  have \"Composition(X) : (X\\<rightarrow>X)\\<times>(X\\<rightarrow>X)\\<rightarrow>(X\\<rightarrow>X)\"\n    using func_ZF_5_L1 by simp\n  with A1 have \"Composition(X)`\\<langle>id(X),f\\<rangle> : X\\<rightarrow>X\"\n    \"Composition(X)`\\<langle>f,id(X)\\<rangle> : X\\<rightarrow>X\"\n    using id_type apply_funtype by auto\n  moreover note A1\n  moreover from A1 have \n    \"\\<forall>x\\<in>X. (Composition(X)`\\<langle>id(X),f\\<rangle>)`(x) = f`(x)\"\n    \"\\<forall>x\\<in>X. (Composition(X)`\\<langle>f,id(X)\\<rangle>)`(x) = f`(x)\"\n    using id_type func_ZF_5_L3 apply_funtype id_conv\n    by auto\n  ultimately show \"Composition(X)`\\<langle>id(X),f\\<rangle> = f\"\n    \"Composition(X)`\\<langle>f,id(X)\\<rangle> = f\"\n    using fun_extension_iff by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2696
    },
    "2428": {
        "type": "lemma",
        "text": "text\\<open>Another trivial fact: identity is the only bijection of a singleton\n  with itself.\\<close>\n",
        "assumes": "",
        "using": [
            "id_bij",
            "bij_is_fun",
            "singleton_fun_id"
        ],
        "statement": "lemma single_bij_id: shows \"bij({x},{x}) = {id({x})}\"\n",
        "proof": "proof\n  show \"{id({x})} \\<subseteq> bij({x},{x})\" using id_bij\n    by simp\n  { fix f assume \"f \\<in> bij({x},{x})\"\n    then have \"f : {x} \\<rightarrow> {x}\" using bij_is_fun\n      by simp\n    then have \"f \\<in> {id({x})}\" using singleton_fun_id\n      by simp\n  } then show \"bij({x},{x}) \\<subseteq> {id({x})}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2698
    },
    "2429": {
        "type": "lemma",
        "text": "text\\<open>A kind of induction for the identity: if a function\n  $f$ is the identity on a set with a fixpoint of $f$\n  removed, then it is the indentity on the whole set.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>X\" and\n  A2: \"p\\<in>X\" and A3: \"f`(p) = p\" and \n  A4: \"restrict(f, X-{p}) = id(X-{p})\"\n  ",
        "using": [
            "id_def",
            "restrict"
        ],
        "statement": "lemma id_fixpoint_rem: assumes A1: \"f:X\\<rightarrow>X\" and\n  A2: \"p\\<in>X\" and A3: \"f`(p) = p\" and \n  A4: \"restrict(f, X-{p}) = id(X-{p})\"\n  shows \"f = id(X)\"\n",
        "proof": "proof -\n  from A1 have \"f: X\\<rightarrow>X\" and \"id(X) : X\\<rightarrow>X\"\n    using id_def by auto\n  moreover\n  { fix x assume \"x\\<in>X\"\n    { assume \"x \\<in> X-{p}\"\n      then have \"f`(x) = restrict(f, X-{p})`(x)\"\n\tusing restrict by simp\n      with A4 \\<open>x \\<in> X-{p}\\<close> have \"f`(x) = x\"\n\tusing id_def by simp }\n    with A2 A3 \\<open>x\\<in>X\\<close> have \"f`(x) = x\" by auto\n  } then have \"\\<forall>x\\<in>X. f`(x) = id(X)`(x)\"\n    using id_def by simp\n  ultimately show \"f = id(X)\" by (rule func_eq)\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2699
    },
    "2430": {
        "type": "definition",
        "text": "text\\<open>The next definition describes the notion of a binary operation\n  lifted to subsets. It is written in a way that might be a bit unexpected,\n  but really it is the same as the intuitive definition, but shorter.\n  In the definition we take a pair $p \\in Pow(X)\\times Pow(X)$, say\n  $p = \\langle A, B\\rangle $, where $A,B \\subseteq X$. \n  Then we assign this pair of sets the set \n  $\\{f\\langle x,y \\rangle : x\\in A, y\\in B \\} = \\{ f(x'): x' \\in A\\times B\\}$\n  The set on the right hand side is the same as the image\n  of $A\\times B$ under $f$. In the definition we don't use $A$ and $B$ symbols,\n  but write \\<open>fst(p)\\<close> and \\<open>snd(p)\\<close>, resp. Recall that in Isabelle/ZF\n  \\<open>fst(p)\\<close> and  \\<open>snd(p)\\<close> denote the first and second components\n  of an ordered pair $p$.\n  See the lemma \\<open>lift_subsets_explained\\<close> for a more intuitive\n  notation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  Lift2Subsets (infix \"{lifted to subsets of}\" 65) where\n  \"f {lifted to subsets of} X \\<equiv> \n  {\\<langle>p, f``(fst(p)\\<times>snd(p))\\<rangle>. p \\<in> Pow(X)\\<times>Pow(X)}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2700
    },
    "2431": {
        "type": "lemma",
        "text": "text\\<open>The definition of the lift to subsets rewritten in a more intuitive\n  notation. We would like to write the last assertion as\n  \\<open>F`\\<langle>A,B\\<rangle> = {f`\\<langle>x,y\\<rangle>. x \\<in> A, y \\<in> B}\\<close>, but Isabelle/ZF does not allow\n  such syntax.\\<close>\n",
        "assumes": "assumes A1: \"f : X\\<times>X \\<rightarrow> Y\"\n  and A2: \"A \\<subseteq> X\"  \"B \\<subseteq> X\" and A3: \"F = f {lifted to subsets of} X\"\n  ",
        "using": [
            "lift_subsets_binop",
            "ZF_fun_from_tot_val",
            "apply_funtype"
        ],
        "statement": "lemma lift_subsets_explained: assumes A1: \"f : X\\<times>X \\<rightarrow> Y\"\n  and A2: \"A \\<subseteq> X\"  \"B \\<subseteq> X\" and A3: \"F = f {lifted to subsets of} X\"\n  shows \n  \"F`\\<langle>A,B\\<rangle> \\<subseteq> Y\" and\n  \"F`\\<langle>A,B\\<rangle> = f``(A\\<times>B)\"\n  \"F`\\<langle>A,B\\<rangle> = {f`(p). p \\<in> A\\<times>B}\"\n  \"F`\\<langle>A,B\\<rangle> = {f`\\<langle>x,y\\<rangle> . \\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n",
        "proof": "proof -\n  let ?p = \"\\<langle>A,B\\<rangle>\"\n  from assms have \n    I: \"F : Pow(X) \\<times> Pow(X) \\<rightarrow> Pow(Y)\" and  \"?p \\<in> Pow(X) \\<times> Pow(X)\"\n    using lift_subsets_binop by auto\n  moreover from A3 have \"F = {\\<langle>p, f``(fst(p)\\<times>snd(p))\\<rangle>. p \\<in> Pow(X)\\<times>Pow(X)}\"\n    unfolding  Lift2Subsets_def by simp\n  ultimately show \"F`\\<langle>A,B\\<rangle> =  f``(A\\<times>B)\"\n    using  ZF_fun_from_tot_val by auto\n  also\n  from A1 A2 have \"A\\<times>B \\<subseteq> X\\<times>X\" by auto\n  with A1 have \"f``(A\\<times>B) = {f`(p). p \\<in> A\\<times>B}\"\n    by (rule func_imagedef)\n  finally show  \"F`\\<langle>A,B\\<rangle> = {f`(p) . p \\<in> A\\<times>B}\" by simp\n  also\n  have \"\\<forall>x\\<in>A. \\<forall>y \\<in> B. f`\\<langle>x,y\\<rangle> = f`\\<langle>x,y\\<rangle>\" by simp\n  then have \"{f`(p). p \\<in> A\\<times>B} = {f`\\<langle>x,y\\<rangle>.  \\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n    by (rule ZF1_1_L4A)\n  finally show \"F`\\<langle>A,B\\<rangle> = {f`\\<langle>x,y\\<rangle> . \\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n    by simp\n  from A2 I show \"F`\\<langle>A,B\\<rangle> \\<subseteq> Y\" using apply_funtype by blast\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2702
    },
    "2432": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for a point to belong to a result of\n  lifting to subsets.\\<close>\n",
        "assumes": "assumes A1: \"f : X \\<times> X \\<rightarrow> Y\" and \n  A2: \"A \\<subseteq> X\"  \"B \\<subseteq> X\" and A3: \"x\\<in>A\" \"y\\<in>B\" and\n  A4: \"F = f {lifted to subsets of} X\"\n  ",
        "using": [
            "lift_subsets_explained"
        ],
        "statement": "lemma lift_subset_suff:  assumes A1: \"f : X \\<times> X \\<rightarrow> Y\" and \n  A2: \"A \\<subseteq> X\"  \"B \\<subseteq> X\" and A3: \"x\\<in>A\" \"y\\<in>B\" and\n  A4: \"F = f {lifted to subsets of} X\"\n  shows \"f`\\<langle>x,y\\<rangle> \\<in> F`\\<langle>A,B\\<rangle>\"\n",
        "proof": "proof -\n  from A3 have \"f`\\<langle>x,y\\<rangle> \\<in> {f`(p) . p \\<in> A\\<times>B}\" by auto\n  moreover from A1 A2 A4 have \"{f`(p). p \\<in> A\\<times>B} = F`\\<langle>A,B\\<rangle> \"\n    using lift_subsets_explained by simp\n  ultimately show \"f`\\<langle>x,y\\<rangle> \\<in> F`\\<langle>A,B\\<rangle>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2703
    },
    "2433": {
        "type": "lemma",
        "text": "text\\<open>A kind of converse of \\<open>lift_subset_apply\\<close>, providing\n  a necessary condition for a point to be in the result of lifting to \n  subsets.\\<close>\n",
        "assumes": "assumes A1: \"f : X \\<times> X \\<rightarrow> Y\" and \n  A2: \"A \\<subseteq> X\"  \"B \\<subseteq> X\" and \n  A3: \"F = f {lifted to subsets of} X\" and\n  A4: \"z \\<in> F`\\<langle>A,B\\<rangle>\"\n  ",
        "using": [
            "lift_subsets_explained"
        ],
        "statement": "lemma lift_subset_nec: assumes A1: \"f : X \\<times> X \\<rightarrow> Y\" and \n  A2: \"A \\<subseteq> X\"  \"B \\<subseteq> X\" and \n  A3: \"F = f {lifted to subsets of} X\" and\n  A4: \"z \\<in> F`\\<langle>A,B\\<rangle>\"\n  shows \"\\<exists>x y. x\\<in>A \\<and> y\\<in>B \\<and> z = f`\\<langle>x,y\\<rangle>\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \"F`\\<langle>A,B\\<rangle> = {f`(p). p \\<in> A\\<times>B}\"\n    using lift_subsets_explained by simp\n  with A4 show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2704
    },
    "2434": {
        "type": "lemma",
        "text": "text\\<open>Lifting to subsets inherits commutativity.\\<close>\n",
        "assumes": "assumes A1: \"f : X \\<times> X \\<rightarrow> Y\" and \n  A2: \"f {is commutative on} X\" and\n  A3: \"F = f {lifted to subsets of} X\"\n  ",
        "using": [
            "lift_subset_nec",
            "IsCommutative_def",
            "lift_subset_suff"
        ],
        "statement": "lemma lift_subset_comm: assumes A1: \"f : X \\<times> X \\<rightarrow> Y\" and \n  A2: \"f {is commutative on} X\" and\n  A3: \"F = f {lifted to subsets of} X\"\n  shows \"F {is commutative on} Pow(X)\"\n",
        "proof": "proof -\n  have \"\\<forall>A \\<in> Pow(X). \\<forall>B \\<in> Pow(X). F`\\<langle>A,B\\<rangle> = F`\\<langle>B,A\\<rangle>\"\n  proof -\n    { fix A assume \"A \\<in> Pow(X)\"\n      fix B assume \"B \\<in> Pow(X)\"\n      have  \"F`\\<langle>A,B\\<rangle> = F`\\<langle>B,A\\<rangle>\"\n      proof -\n\thave \"\\<forall>z \\<in>  F`\\<langle>A,B\\<rangle>. z \\<in>  F`\\<langle>B,A\\<rangle>\"\n\tproof\n\t  fix z assume I: \"z \\<in> F`\\<langle>A,B\\<rangle>\"\n\t  with A1 A3 \\<open>A \\<in> Pow(X)\\<close> \\<open>B \\<in> Pow(X)\\<close> have \n\t    \"\\<exists>x y. x\\<in>A \\<and> y\\<in>B \\<and> z = f`\\<langle>x,y\\<rangle>\"\n\t    using lift_subset_nec by simp\n\t  then obtain x y where \"x\\<in>A\" and \"y\\<in>B\" and \"z = f`\\<langle>x,y\\<rangle>\"\n\t    by auto\n\t  with A2 \\<open>A \\<in> Pow(X)\\<close> \\<open>B \\<in> Pow(X)\\<close> have \"z = f`\\<langle>y,x\\<rangle>\"\n\t    using IsCommutative_def by auto\n\t  with A1 A3 I \\<open>A \\<in> Pow(X)\\<close> \\<open>B \\<in> Pow(X)\\<close> \\<open>x\\<in>A\\<close> \\<open>y\\<in>B\\<close> \n\t  show \"z \\<in> F`\\<langle>B,A\\<rangle>\" using lift_subset_suff by simp\n\tqed\n\tmoreover have \"\\<forall>z \\<in>  F`\\<langle>B,A\\<rangle>. z \\<in>  F`\\<langle>A,B\\<rangle>\"\n\tproof\n\t  fix z assume I: \"z \\<in> F`\\<langle>B,A\\<rangle>\"\n\t  with A1 A3 \\<open>A \\<in> Pow(X)\\<close> \\<open>B \\<in> Pow(X)\\<close> have \n\t    \"\\<exists>x y. x\\<in>B \\<and> y\\<in>A \\<and> z = f`\\<langle>x,y\\<rangle>\"\n\t    using lift_subset_nec by simp\n\t  then obtain x y where \"x\\<in>B\" and \"y\\<in>A\" and \"z = f`\\<langle>x,y\\<rangle>\"\n\t    by auto\n\t  with A2 \\<open>A \\<in> Pow(X)\\<close> \\<open>B \\<in> Pow(X)\\<close> have \"z = f`\\<langle>y,x\\<rangle>\"\n\t    using IsCommutative_def by auto\n\t  with A1 A3 I \\<open>A \\<in> Pow(X)\\<close> \\<open>B \\<in> Pow(X)\\<close> \\<open>x\\<in>B\\<close> \\<open>y\\<in>A\\<close> \n\t  show \"z \\<in> F`\\<langle>A,B\\<rangle>\" using lift_subset_suff by simp\n\tqed\n\tultimately show \"F`\\<langle>A,B\\<rangle> = F`\\<langle>B,A\\<rangle>\" by auto\n      qed\n    } thus ?thesis by auto\n  qed\n  then show \"F {is commutative on} Pow(X)\" \n    unfolding IsCommutative_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2705
    },
    "2435": {
        "type": "lemma",
        "text": "text\\<open>Lifting to subsets inherits associativity. \n  To show that \n  $F\\langle \\langle A,B\\rangle C\\rangle = F\\langle A,F\\langle B,C\\rangle\\rangle$ \n  we prove two inclusions and the proof of the second inclusion is very similar\n  to the proof of the first one.\\<close>\n",
        "assumes": "assumes  \n  A1: \"f {is associative on} X\" and A2: \"F = f {lifted to subsets of} X\"\n  ",
        "using": [
            "lift_subsets_binop",
            "apply_funtype",
            "lift_subset_nec",
            "IsAssociative_def",
            "lift_subset_suff"
        ],
        "statement": "lemma lift_subset_assoc:  assumes  \n  A1: \"f {is associative on} X\" and A2: \"F = f {lifted to subsets of} X\"\n  shows \"F {is associative on} Pow(X)\"\n",
        "proof": "proof -\n  from A1 have \"f : X\\<times>X \\<rightarrow> X\" unfolding IsAssociative_def by simp \n  with A2 have \"F : Pow(X)\\<times>Pow(X) \\<rightarrow> Pow(X)\"\n    using lift_subsets_binop by simp\n  moreover have \"\\<forall>A \\<in> Pow(X).\\<forall>B \\<in> Pow(X). \\<forall>C \\<in> Pow(X). \n    F`\\<langle>F`\\<langle>A,B\\<rangle>,C\\<rangle> = F`\\<langle>A,F`\\<langle>B,C\\<rangle>\\<rangle>\"\n  proof -\n    { fix A B C\n      assume \"A \\<in> Pow(X)\"  \"B \\<in> Pow(X)\"  \"C \\<in> Pow(X)\"\n      have \"F`\\<langle>F`\\<langle>A,B\\<rangle>,C\\<rangle> \\<subseteq> F`\\<langle>A,F`\\<langle>B,C\\<rangle>\\<rangle>\"\n      proof\n\tfix z assume I: \"z \\<in> F`\\<langle>F`\\<langle>A,B\\<rangle>,C\\<rangle>\"\n\tfrom \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>A \\<in> Pow(X)\\<close>  \\<open>B \\<in> Pow(X)\\<close>\n\thave \"F`\\<langle>A,B\\<rangle> \\<in> Pow(X)\"\n\t  using lift_subsets_binop apply_funtype by blast\n\twith \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>C \\<in> Pow(X)\\<close> I have\n\t  \"\\<exists>x y. x \\<in> F`\\<langle>A,B\\<rangle> \\<and> y \\<in> C \\<and> z = f`\\<langle>x,y\\<rangle>\"\n\t  using lift_subset_nec by simp\n\tthen obtain x y where \n\t  II: \"x \\<in> F`\\<langle>A,B\\<rangle>\" and \"y \\<in> C\" and III: \"z = f`\\<langle>x,y\\<rangle>\"\n\t  by auto\n\tfrom \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>A \\<in> Pow(X)\\<close>  \\<open>B \\<in> Pow(X)\\<close> II have\n\t  \"\\<exists> s t. s \\<in> A \\<and> t \\<in> B \\<and> x = f`\\<langle>s,t\\<rangle>\"\n\t  using lift_subset_nec by auto\n\tthen obtain s t where \"s\\<in>A\" and \"t\\<in>B\" and \"x = f`\\<langle>s,t\\<rangle>\"\n\t  by auto\n\twith A1 \\<open>A \\<in> Pow(X)\\<close>  \\<open>B \\<in> Pow(X)\\<close> \\<open>C \\<in> Pow(X)\\<close> III \n\t  \\<open>s\\<in>A\\<close> \\<open>t\\<in>B\\<close> \\<open>y\\<in>C\\<close> have IV: \"z = f`\\<langle>s, f`\\<langle>t,y\\<rangle>\\<rangle>\"\n\t  using IsAssociative_def by blast\n\tfrom \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>B \\<in> Pow(X)\\<close>  \\<open>C \\<in> Pow(X)\\<close>  \\<open>t\\<in>B\\<close>  \\<open>y\\<in>C\\<close>\n\thave \"f`\\<langle>t,y\\<rangle> \\<in> F`\\<langle>B,C\\<rangle>\" using lift_subset_suff by simp\n\tmoreover from \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>B \\<in> Pow(X)\\<close>  \\<open>C \\<in> Pow(X)\\<close>\n\thave \"F`\\<langle>B,C\\<rangle> \\<subseteq> X\" using lift_subsets_binop apply_funtype \n\t  by blast\n\tmoreover note \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>A \\<in> Pow(X)\\<close> \\<open>s\\<in>A\\<close> IV\n\tultimately show \"z \\<in> F`\\<langle>A,F`\\<langle>B,C\\<rangle>\\<rangle>\"\n\t  using lift_subset_suff by simp\n      qed\n      moreover have \"F`\\<langle>A,F`\\<langle>B,C\\<rangle>\\<rangle> \\<subseteq> F`\\<langle>F`\\<langle>A,B\\<rangle>,C\\<rangle>\"\n      proof\n\tfix z assume I: \"z \\<in> F`\\<langle>A,F`\\<langle>B,C\\<rangle>\\<rangle>\"\n\tfrom \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>B \\<in> Pow(X)\\<close> \\<open>C \\<in> Pow(X)\\<close>\n\thave \"F`\\<langle>B,C\\<rangle> \\<in> Pow(X)\"\n\t  using lift_subsets_binop apply_funtype by blast\n\twith \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>A \\<in> Pow(X)\\<close> I have\n\t  \"\\<exists>x y. x \\<in> A \\<and> y \\<in> F`\\<langle>B,C\\<rangle> \\<and> z = f`\\<langle>x,y\\<rangle>\"\n\t  using lift_subset_nec by simp\n\tthen obtain x y where \n\t  \"x \\<in> A\" and II: \"y \\<in> F`\\<langle>B,C\\<rangle>\" and III: \"z = f`\\<langle>x,y\\<rangle>\"\n\t  by auto\n\tfrom \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>B \\<in> Pow(X)\\<close>  \\<open>C \\<in> Pow(X)\\<close> II have\n\t  \"\\<exists> s t. s \\<in> B \\<and> t \\<in> C \\<and> y = f`\\<langle>s,t\\<rangle>\"\n\t  using lift_subset_nec by auto\n\tthen obtain s t where \"s\\<in>B\" and \"t\\<in>C\" and \"y = f`\\<langle>s,t\\<rangle>\"\n\t  by auto\n\twith III have \"z = f`\\<langle>x,f`\\<langle>s,t\\<rangle>\\<rangle>\" by simp\n\tmoreover from A1 \\<open>A \\<in> Pow(X)\\<close>  \\<open>B \\<in> Pow(X)\\<close>  \\<open>C \\<in> Pow(X)\\<close>\n\t  \\<open>x\\<in>A\\<close> \\<open>s\\<in>B\\<close> \\<open>t\\<in>C\\<close> have \"f`\\<langle>f`\\<langle>x,s\\<rangle>,t\\<rangle> = f`\\<langle>x,f`\\<langle>s,t\\<rangle>\\<rangle>\"\n\t  using IsAssociative_def by blast\n\tultimately have IV: \"z = f`\\<langle>f`\\<langle>x,s\\<rangle>,t\\<rangle>\" by simp\n\tfrom \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>A \\<in> Pow(X)\\<close>  \\<open>B \\<in> Pow(X)\\<close>  \\<open>x\\<in>A\\<close>  \\<open>s\\<in>B\\<close>\n\thave \"f`\\<langle>x,s\\<rangle> \\<in> F`\\<langle>A,B\\<rangle>\" using lift_subset_suff by simp\n\tmoreover from \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>A \\<in> Pow(X)\\<close>  \\<open>B \\<in> Pow(X)\\<close>\n\thave \"F`\\<langle>A,B\\<rangle> \\<subseteq> X\" using lift_subsets_binop apply_funtype \n\t  by blast\n\tmoreover note \\<open>f:X\\<times>X \\<rightarrow> X\\<close> A2 \\<open>C \\<in> Pow(X)\\<close> \\<open>t\\<in>C\\<close> IV\n\tultimately show \"z \\<in> F`\\<langle>F`\\<langle>A,B\\<rangle>,C\\<rangle>\"\n\t  using lift_subset_suff by simp\n      qed\n      ultimately have \"F`\\<langle>F`\\<langle>A,B\\<rangle>,C\\<rangle> = F`\\<langle>A,F`\\<langle>B,C\\<rangle>\\<rangle>\" by auto\n    } thus ?thesis by auto\n  qed\n  ultimately show ?thesis unfolding IsAssociative_def\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2706
    },
    "2436": {
        "type": "definition",
        "text": "text\\<open>We define distributivity as a statement about three sets. The first \n  set is the set on which the operations act. The second set is the \n  additive operation (a ZF function) and the third is the multiplicative\n  operation.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsDistributive(X,A,M) \\<equiv> (\\<forall>a\\<in>X.\\<forall>b\\<in>X.\\<forall>c\\<in>X.\n  M`\\<langle>a,A`\\<langle>b,c\\<rangle>\\<rangle> = A`\\<langle>M`\\<langle>a,b\\<rangle>,M`\\<langle>a,c\\<rangle>\\<rangle> \\<and> \n  M`\\<langle>A`\\<langle>b,c\\<rangle>,a\\<rangle> = A`\\<langle>M`\\<langle>b,a\\<rangle>,M`\\<langle>c,a\\<rangle> \\<rangle>)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2707
    },
    "2437": {
        "type": "lemma",
        "text": "text\\<open>The essential condition to show that distributivity is preserved by \n  restrictions to sets that are closed with\n  respect to both operations.\\<close>\n",
        "assumes": "assumes A1: \"IsDistributive(X,A,M)\"\n  and A2: \"Y\\<subseteq>X\"\n  and A3: \"Y {is closed under} A\"  \"Y {is closed under} M\"\n  and A4: \"A\\<^sub>r = restrict(A,Y\\<times>Y)\" \"M\\<^sub>r = restrict(M,Y\\<times>Y)\"\n  and A5: \"a\\<in>Y\"  \"b\\<in>Y\"  \"c\\<in>Y\"\n  ",
        "using": [
            "IsOpClosed_def",
            "restrict",
            "IsDistributive_def"
        ],
        "statement": "lemma func_ZF_7_L1: \n  assumes A1: \"IsDistributive(X,A,M)\"\n  and A2: \"Y\\<subseteq>X\"\n  and A3: \"Y {is closed under} A\"  \"Y {is closed under} M\"\n  and A4: \"A\\<^sub>r = restrict(A,Y\\<times>Y)\" \"M\\<^sub>r = restrict(M,Y\\<times>Y)\"\n  and A5: \"a\\<in>Y\"  \"b\\<in>Y\"  \"c\\<in>Y\"\n  shows \"M\\<^sub>r`\\<langle> a,A\\<^sub>r`\\<langle>b,c\\<rangle> \\<rangle>  = A\\<^sub>r`\\<langle> M\\<^sub>r`\\<langle>a,b\\<rangle>,M\\<^sub>r`\\<langle>a,c\\<rangle> \\<rangle>  \\<and> \n  M\\<^sub>r`\\<langle> A\\<^sub>r`\\<langle>b,c\\<rangle>,a \\<rangle> = A\\<^sub>r`\\<langle> M\\<^sub>r`\\<langle>b,a\\<rangle>, M\\<^sub>r`\\<langle>c,a\\<rangle> \\<rangle>\"\n",
        "proof": "proof -\n  from A3 A5 have \"A`\\<langle>b,c\\<rangle> \\<in> Y\"  \"M`\\<langle>a,b\\<rangle> \\<in> Y\"  \"M`\\<langle>a,c\\<rangle> \\<in> Y\"\n    \"M`\\<langle>b,a\\<rangle> \\<in> Y\"  \"M`\\<langle>c,a\\<rangle> \\<in> Y\" using IsOpClosed_def by auto\n  with A5 A4 have \n    \"A\\<^sub>r`\\<langle>b,c\\<rangle> \\<in> Y\"  \"M\\<^sub>r`\\<langle>a,b\\<rangle> \\<in> Y\"  \"M\\<^sub>r`\\<langle>a,c\\<rangle> \\<in> Y\"\n    \"M\\<^sub>r`\\<langle>b,a\\<rangle> \\<in> Y\"  \"M\\<^sub>r`\\<langle>c,a\\<rangle> \\<in> Y\"\n    using restrict by auto\n  with A1 A2 A4 A5 show ?thesis\n    using restrict IsDistributive_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2708
    },
    "2438": {
        "type": "lemma",
        "text": "text\\<open>If every value of a function on a set is bounded below by\n  a constant, then the image of the set is bounded below.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" and \"A\\<subseteq>X\" and \"\\<forall>x\\<in>A. \\<langle>L,f`(x)\\<rangle> \\<in> r\"\n  ",
        "using": [
            "func_imagedef"
        ],
        "statement": "lemma func_ZF_8_L1: \n  assumes \"f:X\\<rightarrow>Y\" and \"A\\<subseteq>X\" and \"\\<forall>x\\<in>A. \\<langle>L,f`(x)\\<rangle> \\<in> r\"\n  shows \"IsBoundedBelow(f``(A),r)\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>y \\<in> f``(A). \\<langle>L,y\\<rangle> \\<in> r\"\n    using func_imagedef by simp\n  then show \"IsBoundedBelow(f``(A),r)\" \n    by (rule Order_ZF_3_L9)\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2710
    },
    "2439": {
        "type": "lemma",
        "text": "text\\<open>If every value of a function on a set is bounded above by\n  a constant, then the image of the set is bounded above.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" and \"A\\<subseteq>X\" and \"\\<forall>x\\<in>A. \\<langle>f`(x),U\\<rangle> \\<in> r\"\n  ",
        "using": [
            "func_imagedef"
        ],
        "statement": "lemma func_ZF_8_L2:  \n  assumes \"f:X\\<rightarrow>Y\" and \"A\\<subseteq>X\" and \"\\<forall>x\\<in>A. \\<langle>f`(x),U\\<rangle> \\<in> r\"\n  shows \"IsBoundedAbove(f``(A),r)\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>y \\<in> f``(A). \\<langle>y,U\\<rangle> \\<in> r\"\n    using func_imagedef by simp\n  then show \"IsBoundedAbove(f``(A),r)\" \n    by (rule Order_ZF_3_L10)\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2711
    },
    "2440": {
        "type": "lemma",
        "text": "text\\<open>Identity is an order isomorphism.\\<close>\n",
        "assumes": "",
        "using": [
            "id_bij",
            "id_def",
            "ord_iso_def"
        ],
        "statement": "lemma id_ord_iso: shows \"id(X) \\<in> ord_iso(X,r,X,r)\"\n  ",
        "proof": "using id_bij id_def ord_iso_def by simp\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2712
    },
    "2441": {
        "type": "lemma",
        "text": "text\\<open>Identity is the only order automorphism \n  of a singleton.\\<close>\n",
        "assumes": "",
        "using": [
            "id_ord_iso",
            "ord_iso_def",
            "single_bij_id"
        ],
        "statement": "lemma id_ord_auto_singleton: \n  shows \"ord_iso({x},r,{x},r) = {id({x})}\"\n  ",
        "proof": "using id_ord_iso ord_iso_def single_bij_id\n  by auto \n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2713
    },
    "2442": {
        "type": "lemma",
        "text": "text\\<open>The image of a maximum by an order isomorphism\n  is a maximum. Note that from the fact the $r$ is \n  antisymmetric and $f$ is an order isomorphism between\n  $(A,r)$ and $(B,R)$ we can not conclude that $R$ is\n  antisymmetric (we can only show that $R\\cap (B\\times B)$ is).\n\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"antisym(R)\" and \n  A3: \"f \\<in> ord_iso(A,r,B,R)\" and\n  A4: \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "Order_ZF_4_L3",
            "ord_iso_def",
            "bij_is_fun",
            "apply_funtype",
            "ord_iso_sym",
            "ord_iso_apply",
            "right_inverse_bij",
            "HasAmaximum_def"
        ],
        "statement": "lemma max_image_ord_iso: \n  assumes A1: \"antisym(r)\" and A2: \"antisym(R)\" and \n  A3: \"f \\<in> ord_iso(A,r,B,R)\" and\n  A4: \"HasAmaximum(r,A)\"\n  shows \"HasAmaximum(R,B)\" and \"Maximum(R,B) = f`(Maximum(r,A))\"\n",
        "proof": "proof -\n  let ?M = \"Maximum(r,A)\"\n  from A1 A4 have \"?M \\<in> A\" using Order_ZF_4_L3 by simp\n  from A3 have \"f:A\\<rightarrow>B\" using ord_iso_def bij_is_fun\n    by simp\n  with \\<open>?M \\<in> A\\<close> have I: \"f`(?M) \\<in> B\"\n    using apply_funtype by simp\n  { fix y assume \"y \\<in> B\"\n    let ?x = \"converse(f)`(y)\" \n    from A3 have \"converse(f) \\<in> ord_iso(B,R,A,r)\"\n      using ord_iso_sym by simp\n    then have \"converse(f): B \\<rightarrow> A\"\n      using ord_iso_def bij_is_fun by simp\n    with \\<open>y \\<in> B\\<close> have \"?x \\<in> A\"\n      by simp\n    with A1 A3 A4 \\<open>?x \\<in> A\\<close> \\<open>?M \\<in> A\\<close> have \"\\<langle>f`(?x), f`(?M)\\<rangle> \\<in> R\"\n      using Order_ZF_4_L3 ord_iso_apply by simp\n    with A3 \\<open>y \\<in> B\\<close> have \"\\<langle>y, f`(?M)\\<rangle> \\<in> R\"\n      using right_inverse_bij ord_iso_def by auto\n  } then have II: \"\\<forall>y \\<in> B. \\<langle>y, f`(?M)\\<rangle> \\<in> R\" by simp\n  with A2 I show \"Maximum(R,B) = f`(?M)\"\n    by (rule Order_ZF_4_L14)\n  from I II show \"HasAmaximum(R,B)\"\n    using HasAmaximum_def by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2714
    },
    "2443": {
        "type": "lemma",
        "text": "text\\<open>Maximum is a fixpoint of order automorphism.\\<close>\n",
        "assumes": "assumes \"antisym(r)\" and \"f \\<in> ord_iso(A,r,A,r)\"\n  and \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "assms",
            "max_image_ord_iso"
        ],
        "statement": "lemma max_auto_fixpoint: \n  assumes \"antisym(r)\" and \"f \\<in> ord_iso(A,r,A,r)\"\n  and \"HasAmaximum(r,A)\"\n  shows \"Maximum(r,A) = f`(Maximum(r,A))\"\n  ",
        "proof": "using assms max_image_ord_iso by blast      \n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2715
    },
    "2444": {
        "type": "lemma",
        "text": "text\\<open>If two sets are order isomorphic and \n  we remove $x$ and $f(x)$, respectively, from the sets, \n  then they are still order isomorphic.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and A2: \"a \\<in> A\"\n  ",
        "using": [
            "ord_iso_restrict_image",
            "ord_iso_def",
            "bij_def",
            "inj_image_dif",
            "surj_range_image_domain",
            "bij_is_fun",
            "singleton_image"
        ],
        "statement": "lemma ord_iso_rem_point: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and A2: \"a \\<in> A\"\n  shows \"restrict(f,A-{a}) \\<in> ord_iso(A-{a},r,B-{f`(a)},R)\"\n",
        "proof": "proof -\n  let ?f\\<^sub>0 = \"restrict(f,A-{a})\"\n  have \"A-{a} \\<subseteq> A\" by auto\n  with A1 have \"?f\\<^sub>0 \\<in> ord_iso(A-{a},r,f``(A-{a}),R)\"\n    using ord_iso_restrict_image by simp\n  moreover \n  from A1 have \"f \\<in> inj(A,B)\" \n    using ord_iso_def bij_def by simp\n  with A2  have \"f``(A-{a}) = f``(A) - f``{a}\"\n    using inj_image_dif by simp\n  moreover from A1 have \"f``(A) = B\" \n    using ord_iso_def bij_def surj_range_image_domain \n    by auto\n  moreover \n  from A1 have \"f: A\\<rightarrow>B\"\n    using ord_iso_def bij_is_fun by simp\n  with A2 have \"f``{a} = {f`(a)}\"\n    using singleton_image by simp\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2716
    },
    "2445": {
        "type": "corollary",
        "text": "text\\<open>If two sets are order isomorphic and \n  we remove maxima from the sets, then they are still\n  order isomorphic.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and \"f \\<in> ord_iso(A,r,B,R)\" and\n  A4: \"HasAmaximum(r,A)\" and  A5: \"M = Maximum(r,A)\"\n  ",
        "using": [
            "assms",
            "Order_ZF_4_L3",
            "ord_iso_rem_point"
        ],
        "statement": "corollary ord_iso_rem_max: \n  assumes A1: \"antisym(r)\" and \"f \\<in> ord_iso(A,r,B,R)\" and\n  A4: \"HasAmaximum(r,A)\" and  A5: \"M = Maximum(r,A)\"\n  shows \"restrict(f,A-{M}) \\<in> ord_iso(A-{M}, r, B-{f`(M)},R)\"\n  ",
        "proof": "using assms Order_ZF_4_L3 ord_iso_rem_point by simp\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2717
    },
    "2446": {
        "type": "lemma",
        "text": "text\\<open>Lemma about extending order isomorphisms by adding one point\n  to the domain.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and\n  A2: \"M\\<^sub>A \\<notin> A\" \"M\\<^sub>B \\<notin> B\" and\n  A3: \"\\<forall>a\\<in>A. \\<langle>a, M\\<^sub>A\\<rangle> \\<in> r\"  \"\\<forall>b\\<in>B. \\<langle>b, M\\<^sub>B\\<rangle> \\<in> R\" and\n  A4: \"antisym(r)\"  \"antisym(R)\" and\n  A5: \"\\<langle>M\\<^sub>A,M\\<^sub>A\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>M\\<^sub>B,M\\<^sub>B\\<rangle> \\<in> R\"  \n  ",
        "using": [
            "ord_iso_def",
            "bij_def",
            "inj_def",
            "func1_1_L11D",
            "bij_extend_point",
            "apply_funtype",
            "antisym_def"
        ],
        "statement": "lemma ord_iso_extend:  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and\n  A2: \"M\\<^sub>A \\<notin> A\" \"M\\<^sub>B \\<notin> B\" and\n  A3: \"\\<forall>a\\<in>A. \\<langle>a, M\\<^sub>A\\<rangle> \\<in> r\"  \"\\<forall>b\\<in>B. \\<langle>b, M\\<^sub>B\\<rangle> \\<in> R\" and\n  A4: \"antisym(r)\"  \"antisym(R)\" and\n  A5: \"\\<langle>M\\<^sub>A,M\\<^sub>A\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>M\\<^sub>B,M\\<^sub>B\\<rangle> \\<in> R\"  \n  shows \"f \\<union> {\\<langle> M\\<^sub>A,M\\<^sub>B\\<rangle>} \\<in> ord_iso(A\\<union>{M\\<^sub>A} ,r,B\\<union>{M\\<^sub>B} ,R)\"\n",
        "proof": "proof -\n  let ?g = \"f \\<union> {\\<langle> M\\<^sub>A,M\\<^sub>B\\<rangle>}\"\n  from A1 A2 have\n    \"?g : A\\<union>{M\\<^sub>A} \\<rightarrow> B\\<union>{M\\<^sub>B}\" and\n    I: \"\\<forall>x\\<in>A. ?g`(x) = f`(x)\" and II: \"?g`(M\\<^sub>A) = M\\<^sub>B\"\n    using ord_iso_def bij_def inj_def func1_1_L11D\n    by auto\n  from A1 A2 have \"?g \\<in> bij(A\\<union>{M\\<^sub>A},B\\<union>{M\\<^sub>B}) \"\n    using ord_iso_def bij_extend_point by simp\n  moreover have \"\\<forall>x \\<in> A\\<union>{M\\<^sub>A}. \\<forall> y \\<in> A\\<union>{M\\<^sub>A}.\n    \\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\"\n  proof -\n    { fix x y\n      assume \"x \\<in> A\\<union>{M\\<^sub>A}\" and \"y \\<in> A\\<union>{M\\<^sub>A}\"\n      then have \"x\\<in>A \\<and> y \\<in> A \\<or> x\\<in>A \\<and> y = M\\<^sub>A \\<or>\n\tx = M\\<^sub>A \\<and> y \\<in> A \\<or> x = M\\<^sub>A \\<and> y = M\\<^sub>A\"\n\tby auto\n      moreover\n      { assume \"x\\<in>A \\<and> y \\<in> A\"\n\twith A1 I have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\" \n\t  using ord_iso_def by simp }\n      moreover\n      { assume \"x\\<in>A \\<and> y = M\\<^sub>A\"\n\twith A1 A3 I II have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\" \n\t  using ord_iso_def bij_def inj_def apply_funtype\n\t  by auto }\n      moreover\n      { assume \"x = M\\<^sub>A \\<and> y \\<in> A\"\n\twith A2 A3 A4 have \"\\<langle>x,y\\<rangle> \\<notin> r\"\n\t  using antisym_def by auto\n\tmoreover\n\t{ assume A6: \"\\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\"\n\t  from A1 I II \\<open>x = M\\<^sub>A \\<and> y \\<in> A\\<close> have \n\t    III: \"?g`(y) \\<in> B\"  \"?g`(x) = M\\<^sub>B\"\n\t    using ord_iso_def bij_def inj_def apply_funtype\n\t    by auto\n\t  with A3 have \"\\<langle>?g`(y), ?g`(x)\\<rangle> \\<in> R\" by simp\n\t  with A4 A6 have \"?g`(y) = ?g`(x)\" using antisym_def\n\t    by auto\n\t  with A2 III have False by simp\n\t} hence \"\\<langle>?g`(x), ?g`(y)\\<rangle> \\<notin> R\" by auto\n\tultimately have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\" \n\tby simp }\n      moreover\n      { assume \"x = M\\<^sub>A \\<and> y = M\\<^sub>A\"\n\twith A5 II have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\" \n\t  by simp }\n      ultimately have \"\\<langle>x,y\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?g`(x), ?g`(y)\\<rangle> \\<in> R\" \n\tby auto\n    } thus ?thesis by auto\n  qed \n  ultimately show ?thesis using ord_iso_def\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2718
    },
    "2447": {
        "type": "definition",
        "text": "text\\<open>There is a natural bijection etween $X=Y\\times \\{ y\\}$ (a \"slice\")\n  and $Y$. \n  We will call this the \\<open>SliceProjection(Y\\<times>{y})\\<close>. \n  This is really the ZF equivalent of the meta-function \\<open>fst(x)\\<close>.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"SliceProjection(X) \\<equiv> {\\<langle>p,fst(p)\\<rangle>. p \\<in> X }\"\n",
        "proof": "",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2720
    },
    "2448": {
        "type": "lemma",
        "text": "text\\<open>A slice projection is a bijection between $X\\times\\{ y\\}$ and $X$.\\<close>\n",
        "assumes": "",
        "using": [
            "ZF_fun_from_tot_val",
            "SliceProjection_def",
            "inj_def",
            "surj_def",
            "bij_def",
            "func1_1_L1"
        ],
        "statement": "lemma slice_proj_bij: shows \n  \"SliceProjection(X\\<times>{y}): X\\<times>{y} \\<rightarrow> X\"\n  \"domain(SliceProjection(X\\<times>{y})) = X\\<times>{y}\"\n  \"\\<forall>p\\<in>X\\<times>{y}. SliceProjection(X\\<times>{y})`(p) = fst(p)\"\n  \"SliceProjection(X\\<times>{y}) \\<in> bij(X\\<times>{y},X)\"\n",
        "proof": "proof -\n  let ?P = \"SliceProjection(X\\<times>{y})\"\n  have  \"\\<forall>p \\<in> X\\<times>{y}. fst(p) \\<in> X\" by simp\n  moreover from this have \n    \"{\\<langle>p,fst(p)\\<rangle>. p \\<in> X\\<times>{y} } : X\\<times>{y} \\<rightarrow> X\"\n    by (rule ZF_fun_from_total)\n  ultimately show \n    I: \"?P: X\\<times>{y} \\<rightarrow> X\" and II: \"\\<forall>p\\<in>X\\<times>{y}. ?P`(p) = fst(p)\"\n    using ZF_fun_from_tot_val SliceProjection_def by auto\n  hence\n    \"\\<forall>a \\<in> X\\<times>{y}. \\<forall> b \\<in> X\\<times>{y}. ?P`(a) = ?P`(b) \\<longrightarrow> a=b\"\n    by auto\n  with I have \"?P \\<in> inj(X\\<times>{y},X)\" using inj_def \n    by simp\n  moreover from II have \"\\<forall>x\\<in>X. \\<exists>p\\<in>X\\<times>{y}. ?P`(p) = x\" \n    by simp\n  with I have \"?P \\<in> surj(X\\<times>{y},X)\" using surj_def\n    by simp\n  ultimately show \"?P \\<in> bij(X\\<times>{y},X)\"\n    using bij_def by simp\n  from I show \"domain(SliceProjection(X\\<times>{y})) = X\\<times>{y}\"\n    using func1_1_L1 by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2721
    },
    "2449": {
        "type": "definition",
        "text": "text\\<open> Given 2 functions $f:A\\to B$ and $g:C\\to D$ , we can consider a function $h:A\\times C \\to B\\times D$\nsuch that $h(x,y)=\\langle f(x),g(y)\\rangle$ \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  ProdFunction where\n  \"ProdFunction(f,g) \\<equiv> {\\<langle>z,\\<langle>f`(fst(z)),g`(snd(z))\\<rangle>\\<rangle>. z\\<in>domain(f)\\<times>domain(g)}\"\n",
        "proof": "",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2722
    },
    "2450": {
        "type": "lemma",
        "text": "text\\<open> For given functions $f:A\\to B$ and $g:C\\to D$ the function \\<open>ProdFunction(f,g)\\<close>\n  maps $A\\times C$ to $B\\times D$. \\<close>\n",
        "assumes": "assumes \"f:A\\<rightarrow>B\" \"g:C\\<rightarrow>D\"\n  ",
        "using": [
            "func1_1_L1",
            "apply_type",
            "ZF_fun_from_total"
        ],
        "statement": "lemma prodFunction:\n  assumes \"f:A\\<rightarrow>B\" \"g:C\\<rightarrow>D\"\n  shows \"ProdFunction(f,g):(A\\<times>C)\\<rightarrow>(B\\<times>D)\"\n",
        "proof": "proof-\n  from assms have \"\\<forall>z \\<in> domain(f)\\<times>domain(g). \\<langle>f`(fst(z)),g`(snd(z))\\<rangle> \\<in> B\\<times>D\" \n    using func1_1_L1 apply_type by auto \n  with assms show ?thesis unfolding ProdFunction_def using func1_1_L1 ZF_fun_from_total\n    by simp \nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2723
    },
    "2451": {
        "type": "lemma",
        "text": "text\\<open> For given functions $f:A\\to B$ and $g:C\\to D$ and points $x\\in A$, $y\\in C$ the value of the \n  function \\<open>ProdFunction(f,g)\\<close> on $\\langle x,y \\rangle$ is $\\langle f(x),g(y) \\rangle$. \\<close>\n",
        "assumes": "assumes \"f:A\\<rightarrow>B\" \"g:C\\<rightarrow>D\" \"x\\<in>A\" \"y\\<in>C\"\n  ",
        "using": [
            "prodFunction",
            "func1_1_L1",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma prodFunctionApp:\n  assumes \"f:A\\<rightarrow>B\" \"g:C\\<rightarrow>D\" \"x\\<in>A\" \"y\\<in>C\"\n  shows \"ProdFunction(f,g)`\\<langle>x,y\\<rangle> = \\<langle>f`(x),g`(y)\\<rangle>\"\n",
        "proof": "proof -\n  let ?z = \"\\<langle>x,y\\<rangle>\"\n  from assms have \"?z \\<in> A\\<times>C\" and \"ProdFunction(f,g):(A\\<times>C)\\<rightarrow>(B\\<times>D)\"\n    using prodFunction by auto \n  moreover from assms(1,2) have \"ProdFunction(f,g) = {\\<langle>z,\\<langle>f`(fst(z)),g`(snd(z))\\<rangle>\\<rangle>. z\\<in>A\\<times>C}\"\n    unfolding ProdFunction_def using func1_1_L1 by blast\n  ultimately show ?thesis using ZF_fun_from_tot_val by auto \nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2724
    },
    "2452": {
        "type": "lemma",
        "text": "text\\<open>Somewhat technical lemma about inverse image of a set by a \\<open>ProdFunction(f,f)\\<close>. \\<close>\n",
        "assumes": "assumes \"x\\<in>X\" \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "prodFunction",
            "func1_1_L15",
            "prodFunctionApp"
        ],
        "statement": "lemma prodFunVimage: assumes \"x\\<in>X\" \"f:X\\<rightarrow>Y\"\n  shows \"\\<langle>x,t\\<rangle> \\<in> ProdFunction(f,f)-``(V) \\<longleftrightarrow> t\\<in>X \\<and> \\<langle>f`x,f`t\\<rangle> \\<in> V\"\n",
        "proof": "proof -\n  from assms(2) have T:\"ProdFunction(f,f)-``(V) = {z \\<in> X\\<times>X. ProdFunction(f,f)`(z) \\<in> V}\"\n    using prodFunction func1_1_L15 by blast \n  with assms show ?thesis using prodFunctionApp by auto \nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2725
    },
    "2453": {
        "type": "definition",
        "text": "text\\<open>We call the relation created by a relation on $Y$ and a mapping\n  $f:X\\rightarrow Y$ the \\<open>InducedRelation(f,R)\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"InducedRelation(f,R) \\<equiv> \n  {p \\<in> domain(f)\\<times>domain(f). \\<langle>f`(fst(p)),f`(snd(p))\\<rangle> \\<in> R}\"\n",
        "proof": "",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2726
    },
    "2454": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of the definition of the relation induced by\n  a function.\\<close>\n",
        "assumes": "assumes \"\\<langle>x,y\\<rangle> \\<in> InducedRelation(f,R)\"\n  ",
        "using": [
            "assms",
            "InducedRelation_def"
        ],
        "statement": "lemma def_of_ind_relA: \n  assumes \"\\<langle>x,y\\<rangle> \\<in> InducedRelation(f,R)\"\n  shows \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\"\n  ",
        "proof": "using assms InducedRelation_def by simp\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2727
    },
    "2455": {
        "type": "lemma",
        "text": "text\\<open>A property of order isomorphisms that is missing from\n  standard Isabelle's \\<open>Order.thy\\<close>.\\<close>\n",
        "assumes": "assumes \"f \\<in> ord_iso(A,r,B,R)\" and\n  \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\" and \"x\\<in>A\"  \"y\\<in>A\"\n  ",
        "using": [
            "assms",
            "ord_iso_def"
        ],
        "statement": "lemma ord_iso_apply_conv: \n  assumes \"f \\<in> ord_iso(A,r,B,R)\" and\n  \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\" and \"x\\<in>A\"  \"y\\<in>A\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms ord_iso_def by simp\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2729
    },
    "2456": {
        "type": "lemma",
        "text": "text\\<open>The next lemma tells us where the induced relation is defined\\<close>\n",
        "assumes": "assumes  \"R \\<subseteq> B\\<times>B\" and \"f:A\\<rightarrow>B\"\n  ",
        "using": [
            "assms",
            "func1_1_L1",
            "InducedRelation_def"
        ],
        "statement": "lemma ind_rel_domain: \n  assumes  \"R \\<subseteq> B\\<times>B\" and \"f:A\\<rightarrow>B\"\n  shows \"InducedRelation(f,R) \\<subseteq> A\\<times>A\"\n  ",
        "proof": "using assms func1_1_L1 InducedRelation_def\n  by auto\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2730
    },
    "2457": {
        "type": "lemma",
        "text": "text\\<open>A bijection is an order homomorphisms between a relation\n  and the induced one.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(A,B)\"\n  ",
        "using": [
            "def_of_ind_relA",
            "bij_is_fun",
            "def_of_ind_relB",
            "ord_isoI"
        ],
        "statement": "lemma bij_is_ord_iso: assumes A1: \"f \\<in> bij(A,B)\"\n  shows \"f \\<in> ord_iso(A,InducedRelation(f,R),B,R)\"\n",
        "proof": "proof -\n  let ?r = \"InducedRelation(f,R)\"\n  { fix x y assume A2: \"x\\<in>A\"  \"y\\<in>A\"\n    have \"\\<langle>x,y\\<rangle> \\<in> ?r \\<longleftrightarrow> \\<langle>f`(x),f`(y)\\<rangle> \\<in> R\" \n    proof\n      assume \"\\<langle>x,y\\<rangle> \\<in> ?r\" then show \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\" \n\tusing def_of_ind_relA by simp\n    next assume \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\"\n      with A1 A2 show \"\\<langle>x,y\\<rangle> \\<in> ?r\"\n\tusing bij_is_fun def_of_ind_relB by blast \n    qed }\n  with A1 show \"f \\<in> ord_iso(A,InducedRelation(f,R),B,R)\"\n    using ord_isoI by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2731
    },
    "2458": {
        "type": "lemma",
        "text": "text\\<open>An order isomoprhism preserves antisymmetry.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\" and A3: \"antisym(R)\"\n  ",
        "using": [
            "ord_iso_is_bij",
            "bij_is_inj",
            "ord_iso_apply",
            "imp_conj",
            "antisym_def"
        ],
        "statement": "lemma ord_iso_pres_antsym: assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\" and A3: \"antisym(R)\"\n  shows \"antisym(r)\"\n",
        "proof": "proof -\n  { fix x y\n    assume A4: \"\\<langle>x,y\\<rangle> \\<in> r\"   \"\\<langle>y,x\\<rangle> \\<in> r\"\n    from A1 have \"f \\<in> inj(A,B)\"\n      using ord_iso_is_bij bij_is_inj by simp\n    moreover\n    from A1 A2 A4 have \n      \"\\<langle>f`(x), f`(y)\\<rangle> \\<in> R\" and \"\\<langle>f`(y), f`(x)\\<rangle> \\<in> R\"\n      using ord_iso_apply by auto\n    with A3 have \"f`(x) = f`(y)\" by (rule Fol1_L4)\n    moreover from A2 A4 have \"x\\<in>A\"  \"y\\<in>A\" by auto\n    ultimately have \"x=y\" by (rule inj_apply_equality)\n  } then have \"\\<forall>x y. \\<langle>x,y\\<rangle> \\<in> r \\<and> \\<langle>y,x\\<rangle> \\<in> r \\<longrightarrow> x=y\" by auto\n  then show \"antisym(r)\" using imp_conj antisym_def\n    by simp\nqed      \n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2732
    },
    "2459": {
        "type": "lemma",
        "text": "text\\<open>Order isomoprhisms preserve transitivity.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\" and A3: \"trans(R)\"\n  ",
        "using": [
            "ord_iso_apply",
            "ord_iso_apply_conv"
        ],
        "statement": "lemma ord_iso_pres_trans: assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\" and A3: \"trans(R)\"\n  shows \"trans(r)\"\n",
        "proof": "proof -\n  { fix x y z\n    assume A4: \"\\<langle>x, y\\<rangle> \\<in> r\"   \"\\<langle>y, z\\<rangle> \\<in> r\"\n    note A1\n    moreover\n    from A1 A2 A4 have \n      \"\\<langle>f`(x), f`(y)\\<rangle> \\<in> R \\<and> \\<langle>f`(y), f`(z)\\<rangle> \\<in> R\"\n      using ord_iso_apply by auto\n    with A3 have \"\\<langle>f`(x),f`(z)\\<rangle> \\<in> R\" by (rule Fol1_L3)\n    moreover from A2 A4 have \"x\\<in>A\"  \"z\\<in>A\" by auto\n    ultimately have \"\\<langle>x, z\\<rangle> \\<in> r\" using ord_iso_apply_conv\n      by simp\n  } then have  \"\\<forall> x y z. \\<langle>x, y\\<rangle> \\<in> r \\<and> \\<langle>y, z\\<rangle> \\<in> r \\<longrightarrow> \\<langle>x, z\\<rangle> \\<in> r\"\n    by blast\n  then show \"trans(r)\" by (rule Fol1_L2)\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2733
    },
    "2460": {
        "type": "lemma",
        "text": "text\\<open>Order isomorphisms preserve totality.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\" and A3: \"R  {is total on} B\"\n  ",
        "using": [
            "ord_iso_apply_conv",
            "ord_iso_is_bij",
            "bij_is_fun",
            "apply_funtype",
            "IsTotal_def"
        ],
        "statement": "lemma ord_iso_pres_tot: assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\" and A3: \"R  {is total on} B\"\n  shows \"r  {is total on} A\"\n",
        "proof": "proof -\n  { fix x y\n    assume \"x\\<in>A\"  \"y\\<in>A\"  \"\\<langle>x,y\\<rangle> \\<notin> r\"  \n    with A1 have \"\\<langle>f`(x),f`(y)\\<rangle> \\<notin> R\" using ord_iso_apply_conv\n      by auto\n    moreover \n    from A1 have \"f:A\\<rightarrow>B\" using ord_iso_is_bij bij_is_fun \n      by simp\n    with A3 \\<open>x\\<in>A\\<close>  \\<open>y\\<in>A\\<close> have \n      \"\\<langle>f`(x),f`(y)\\<rangle> \\<in>  R \\<or> \\<langle>f`(y),f`(x)\\<rangle> \\<in>  R\"\n      using apply_funtype IsTotal_def by simp\n    ultimately have \"\\<langle>f`(y),f`(x)\\<rangle> \\<in>  R\" by simp\n    with A1 \\<open>x\\<in>A\\<close>  \\<open>y\\<in>A\\<close> have \"\\<langle>y,x\\<rangle> \\<in> r\" \n      using ord_iso_apply_conv  by simp\n  } then have \"\\<forall>x\\<in>A. \\<forall>y\\<in>A. \\<langle>x,y\\<rangle> \\<in> r \\<or>  \\<langle>y,x\\<rangle> \\<in> r\"\n    by blast\n  then show \"r  {is total on} A\" using IsTotal_def\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2734
    },
    "2461": {
        "type": "lemma",
        "text": "text\\<open>Order isomorphisms preserve linearity.\\<close>\n",
        "assumes": "assumes \"f \\<in> ord_iso(A,r,B,R)\" and \n  \"r \\<subseteq> A\\<times>A\" and \"IsLinOrder(B,R)\"\n  ",
        "using": [
            "assms",
            "ord_iso_pres_antsym",
            "ord_iso_pres_trans",
            "ord_iso_pres_tot",
            "IsLinOrder_def"
        ],
        "statement": "lemma ord_iso_pres_lin: assumes \"f \\<in> ord_iso(A,r,B,R)\" and \n  \"r \\<subseteq> A\\<times>A\" and \"IsLinOrder(B,R)\"\n  shows \"IsLinOrder(A,r)\"\n  ",
        "proof": "using assms ord_iso_pres_antsym ord_iso_pres_trans ord_iso_pres_tot\n    IsLinOrder_def by simp\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2735
    },
    "2462": {
        "type": "lemma",
        "text": "text\\<open>If a relation is a linear order, then the relation induced\n  on another set by a bijection is also a linear order.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(A,B)\" and A2: \"IsLinOrder(B,R)\"\n  ",
        "using": [
            "bij_is_ord_iso",
            "domain_of_bij",
            "InducedRelation_def",
            "ord_iso_pres_lin"
        ],
        "statement": "lemma ind_rel_pres_lin: \n  assumes A1: \"f \\<in> bij(A,B)\" and A2: \"IsLinOrder(B,R)\"\n  shows \"IsLinOrder(A,InducedRelation(f,R))\"\n",
        "proof": "proof -\n  let ?r = \"InducedRelation(f,R)\"\n  from A1 have \"f \\<in> ord_iso(A,?r,B,R)\" and \"?r \\<subseteq> A\\<times>A\"\n    using bij_is_ord_iso domain_of_bij InducedRelation_def \n    by auto\n  with A2 show \"IsLinOrder(A,?r)\" using ord_iso_pres_lin \n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2736
    },
    "2463": {
        "type": "lemma",
        "text": "text\\<open>The image by an order isomorphism \n  of a bounded above and nonempty set is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and A2: \"r \\<subseteq> A\\<times>A\" and\n  A3: \"IsBoundedAbove(C,r)\"   \"C\\<noteq>0\"\n  ",
        "using": [
            "IsBoundedAbove_def",
            "ord_iso_is_bij",
            "bij_is_fun",
            "Order_ZF_3_L1A",
            "func_imagedef",
            "ord_iso_apply",
            "func1_1_L15A"
        ],
        "statement": "lemma ord_iso_pres_bound_above: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and A2: \"r \\<subseteq> A\\<times>A\" and\n  A3: \"IsBoundedAbove(C,r)\"   \"C\\<noteq>0\"\n  shows \"IsBoundedAbove(f``(C),R)\"   \"f``(C) \\<noteq> 0\"\n",
        "proof": "proof -\n  from A3 obtain u where I: \"\\<forall>x\\<in>C. \\<langle>x,u\\<rangle> \\<in> r\"\n    using IsBoundedAbove_def by auto\n  from A1 have \"f:A\\<rightarrow>B\" using ord_iso_is_bij bij_is_fun\n    by simp\n  from A2 A3 have \"C\\<subseteq>A\" using Order_ZF_3_L1A by blast\n  from A3 obtain x where \"x\\<in>C\" by auto\n  with A2 I have \"u\\<in>A\" by auto\n  { fix y assume \"y \\<in> f``(C)\"\n    with \\<open>f:A\\<rightarrow>B\\<close> \\<open>C\\<subseteq>A\\<close> obtain x where \"x\\<in>C\" and \"y = f`(x)\"\n      using func_imagedef by auto\n    with A1 I \\<open>C\\<subseteq>A\\<close>  \\<open>u\\<in>A\\<close> have \"\\<langle>y,f`(u)\\<rangle> \\<in> R\"\n      using ord_iso_apply by auto\n  } then have \"\\<forall>y \\<in> f``(C).  \\<langle>y,f`(u)\\<rangle> \\<in> R\" by simp\n  then show \"IsBoundedAbove(f``(C),R)\" by (rule Order_ZF_3_L10)\n  from A3 \\<open>f:A\\<rightarrow>B\\<close> \\<open>C\\<subseteq>A\\<close> show \"f``(C) \\<noteq> 0\" using func1_1_L15A\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2737
    },
    "2464": {
        "type": "lemma",
        "text": "text\\<open>Order isomorphisms preserve the property of having a minimum.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  A2: \"r \\<subseteq> A\\<times>A\" and \n  A3: \"C\\<subseteq>A\" and A4: \"HasAminimum(R,f``(C))\"\n  ",
        "using": [
            "HasAminimum_def",
            "ord_iso_is_bij",
            "bij_is_fun",
            "bij_is_inj",
            "inj_inv_back_in_set",
            "func_imagedef",
            "ord_iso_apply_conv"
        ],
        "statement": "lemma ord_iso_pres_has_min: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  A2: \"r \\<subseteq> A\\<times>A\" and \n  A3: \"C\\<subseteq>A\" and A4: \"HasAminimum(R,f``(C))\"\n  shows \"HasAminimum(r,C)\"\n",
        "proof": "proof -\n  from A4 obtain m where \n    I: \"m \\<in> f``(C)\" and II: \"\\<forall>y \\<in> f``(C). \\<langle>m,y\\<rangle> \\<in> R\"\n    using HasAminimum_def by auto\n  let ?k = \"converse(f)`(m)\"\n  from A1 have \"f:A\\<rightarrow>B\" using ord_iso_is_bij bij_is_fun\n    by simp\n  from A1 have \"f \\<in> inj(A,B)\" using ord_iso_is_bij bij_is_inj\n    by simp\n  with A3 I have \"?k \\<in> C\" and III: \"f`(?k) = m\" \n    using inj_inv_back_in_set by auto\n  moreover\n  { fix x assume A5: \"x\\<in>C\"\n    with A3 II \\<open>f:A\\<rightarrow>B\\<close> \\<open>?k \\<in> C\\<close> III have\n      \"?k \\<in> A\"   \"x\\<in>A\"  \"\\<langle>f`(?k),f`(x)\\<rangle> \\<in> R\"\n      using func_imagedef by auto\n    with A1 have \"\\<langle>?k,x\\<rangle> \\<in> r\" using ord_iso_apply_conv\n      by simp\n  } then have \"\\<forall>x\\<in>C.  \\<langle>?k,x\\<rangle> \\<in> r\" by simp\n  ultimately show \"HasAminimum(r,C)\" using HasAminimum_def by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2738
    },
    "2465": {
        "type": "lemma",
        "text": "text\\<open>Order isomorhisms preserve the images of relations.\n  In other words taking the image of a point by a relation\n  commutes with the function.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  \n  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and \n  A3: \"a\\<in>A\"\n  ",
        "using": [
            "ord_iso_is_bij",
            "bij_is_fun",
            "func_imagedef",
            "ord_iso_apply",
            "ord_iso_converse",
            "left_inverse_bij",
            "right_inverse_bij"
        ],
        "statement": "lemma ord_iso_pres_rel_image: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  \n  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and \n  A3: \"a\\<in>A\"\n  shows \"f``(r``{a}) = R``{f`(a)}\"\n",
        "proof": "proof\n  from A1 have \"f:A\\<rightarrow>B\" using ord_iso_is_bij bij_is_fun\n    by simp\n  moreover from A2 A3 have I: \"r``{a} \\<subseteq> A\" by auto\n  ultimately have I: \"f``(r``{a}) = {f`(x). x \\<in> r``{a} }\"\n    using func_imagedef by simp\n  { fix y assume A4: \"y \\<in> f``(r``{a})\" \n    with I obtain x where \n      \"x \\<in> r``{a}\" and II: \"y = f`(x)\"\n      by auto\n    with A1 A2 have \"\\<langle>f`(a),f`(x)\\<rangle> \\<in> R\" using ord_iso_apply\n      by auto\n    with II have \"y \\<in>  R``{f`(a)}\" by auto\n  } then show  \"f``(r``{a}) \\<subseteq> R``{f`(a)}\" by auto\n  { fix y assume A5: \"y \\<in> R``{f`(a)}\" \n    let ?x = \"converse(f)`(y)\"\n    from A2 A5 have \n      \"\\<langle>f`(a),y\\<rangle> \\<in> R\"  \"f`(a) \\<in> B\"  and IV: \"y\\<in>B\"\n      by auto\n    with A1 have III: \"\\<langle>converse(f)`(f`(a)),?x\\<rangle> \\<in> r\"\n      using ord_iso_converse by simp\n    moreover from A1 A3 have \"converse(f)`(f`(a)) = a\"\n      using ord_iso_is_bij left_inverse_bij by blast\n    ultimately have \"f`(?x) \\<in> {f`(x). x \\<in>  r``{a} }\"\n      by auto\n    moreover from A1 IV have \"f`(?x) = y\"\n      using ord_iso_is_bij right_inverse_bij by blast\n    moreover from A1 I have \"f``(r``{a}) = {f`(x). x \\<in>  r``{a} }\"\n      using ord_iso_is_bij bij_is_fun func_imagedef by blast\n    ultimately have \"y \\<in> f``(r``{a})\" by simp\n  } then show \"R``{f`(a)} \\<subseteq> f``(r``{a})\" by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2739
    },
    "2466": {
        "type": "lemma",
        "text": "text\\<open>Order isomorphisms preserve collections of upper bounds.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  \n  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and \n  A3: \"C\\<subseteq>A\" \n  ",
        "using": [
            "ord_iso_is_bij",
            "bij_is_fun",
            "ord_iso_pres_rel_image",
            "func_imagedef"
        ],
        "statement": "lemma ord_iso_pres_up_bounds: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  \n  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and \n  A3: \"C\\<subseteq>A\" \n  shows \"{f``(r``{a}). a\\<in>C} = {R``{b}. b \\<in> f``(C)}\"\n",
        "proof": "proof\n  from A1 have \"f:A\\<rightarrow>B\"\n      using ord_iso_is_bij bij_is_fun by simp\n  { fix Y assume \"Y \\<in> {f``(r``{a}). a\\<in>C}\"\n    then obtain a where \"a\\<in>C\" and I: \"Y = f``(r``{a})\"\n      by auto\n    from A3 \\<open>a\\<in>C\\<close> have \"a\\<in>A\" by auto\n    with A1 A2 have \"f``(r``{a}) = R``{f`(a)}\"\n      using ord_iso_pres_rel_image by simp\n    moreover from A3 \\<open>f:A\\<rightarrow>B\\<close> \\<open>a\\<in>C\\<close> have \"f`(a) \\<in> f``(C)\"\n      using func_imagedef by auto\n    ultimately have \"f``(r``{a}) \\<in> { R``{b}. b \\<in> f``(C) }\"\n      by auto\n    with I have \"Y \\<in> { R``{b}. b \\<in> f``(C) }\" by simp\n  } then show \"{f``(r``{a}). a\\<in>C} \\<subseteq> {R``{b}. b \\<in> f``(C)}\"\n    by blast\n  { fix Y assume \"Y \\<in> {R``{b}. b \\<in> f``(C)}\"\n    then obtain b where \"b \\<in> f``(C)\" and II: \"Y = R``{b}\"\n      by auto\n    with A3 \\<open>f:A\\<rightarrow>B\\<close> obtain a where \"a\\<in>C\" and \"b = f`(a)\"\n      using func_imagedef by auto\n    with A3 II have \"a\\<in>A\" and \"Y = R``{f`(a)}\" by auto \n    with A1 A2 have \"Y = f``(r``{a})\"\n      using ord_iso_pres_rel_image by simp\n    with \\<open>a\\<in>C\\<close> have \"Y \\<in> {f``(r``{a}). a\\<in>C}\" by auto\n  } then show \"{R``{b}. b \\<in> f``(C)} \\<subseteq> {f``(r``{a}). a\\<in>C}\"\n    by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2740
    },
    "2467": {
        "type": "lemma",
        "text": "text\\<open>The image of the set of upper bounds is the set of upper bounds\n  of the image.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and \n  A3: \"C\\<subseteq>A\" and A4: \"C\\<noteq>0\"\n  ",
        "using": [
            "ord_iso_is_bij",
            "bij_is_inj",
            "inj_image_of_Inter",
            "ord_iso_pres_up_bounds"
        ],
        "statement": "lemma ord_iso_pres_min_up_bounds: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and \n  A3: \"C\\<subseteq>A\" and A4: \"C\\<noteq>0\"\n  shows \"f``(\\<Inter>a\\<in>C. r``{a}) = (\\<Inter>b\\<in>f``(C). R``{b})\"\n",
        "proof": "proof -\n  from A1 have \"f \\<in> inj(A,B)\"\n    using ord_iso_is_bij bij_is_inj by simp\n  moreover note A4\n  moreover from A2 A3 have \"\\<forall>a\\<in>C. r``{a} \\<subseteq> A\" by auto\n  ultimately have \n    \"f``(\\<Inter>a\\<in>C. r``{a}) = ( \\<Inter>a\\<in>C. f``(r``{a}) )\"\n    using inj_image_of_Inter by simp\n  also from A1 A2 A3 have\n    \"( \\<Inter>a\\<in>C. f``(r``{a}) ) = ( \\<Inter>b\\<in>f``(C). R``{b} )\"\n    using ord_iso_pres_up_bounds by simp\n  finally show \"f``(\\<Inter>a\\<in>C. r``{a}) = (\\<Inter>b\\<in>f``(C). R``{b})\"\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2741
    },
    "2468": {
        "type": "lemma",
        "text": "text\\<open>Order isomorphisms preserve completeness.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and A3: \"R {is complete}\"\n  ",
        "using": [
            "ord_iso_pres_bound_above",
            "IsComplete_def",
            "Order_ZF_3_L1A",
            "ord_iso_pres_min_up_bounds",
            "ZF1_1_L7",
            "ord_iso_pres_has_min"
        ],
        "statement": "lemma ord_iso_pres_compl: \n  assumes A1: \"f \\<in> ord_iso(A,r,B,R)\" and \n  A2: \"r \\<subseteq> A\\<times>A\"  \"R \\<subseteq> B\\<times>B\" and A3: \"R {is complete}\"\n  shows \"r {is complete}\"\n",
        "proof": "proof -\n  { fix C\n    assume A4: \"IsBoundedAbove(C,r)\"  \"C\\<noteq>0\"\n    with A1 A2 A3 have \n      \"HasAminimum(R,\\<Inter>b \\<in> f``(C). R``{b})\"\n      using ord_iso_pres_bound_above IsComplete_def\n      by simp\n    moreover\n    from A2 \\<open>IsBoundedAbove(C,r)\\<close> have I: \"C \\<subseteq> A\" using Order_ZF_3_L1A\n      by blast\n    with A1 A2 \\<open>C\\<noteq>0\\<close> have \"f``(\\<Inter>a\\<in>C. r``{a}) = (\\<Inter>b\\<in>f``(C). R``{b})\"\n      using ord_iso_pres_min_up_bounds by simp\n    ultimately have \"HasAminimum(R,f``(\\<Inter>a\\<in>C. r``{a}))\"\n      by simp\n    moreover\n    from A2 have \"\\<forall>a\\<in>C. r``{a} \\<subseteq> A\" \n      by auto\n    with \\<open>C\\<noteq>0\\<close> have \"( \\<Inter>a\\<in>C. r``{a} ) \\<subseteq> A\" using ZF1_1_L7 \n      by simp\n    moreover note A1 A2 \n    ultimately have \"HasAminimum(r, \\<Inter>a\\<in>C. r``{a} )\"\n      using ord_iso_pres_has_min by simp\n  } then show \"r {is complete}\" using IsComplete_def\n    by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2742
    },
    "2469": {
        "type": "lemma",
        "text": "text\\<open>If the original relation is complete, then the induced\n  one is complete.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(A,B)\"\n  and A2: \"R \\<subseteq> B\\<times>B\" and A3: \"R {is complete}\"\n  ",
        "using": [
            "bij_is_ord_iso",
            "bij_is_fun",
            "ind_rel_domain",
            "ord_iso_pres_compl"
        ],
        "statement": "lemma ind_rel_pres_compl: assumes A1: \"f \\<in> bij(A,B)\"\n  and A2: \"R \\<subseteq> B\\<times>B\" and A3: \"R {is complete}\"\n  shows \"InducedRelation(f,R) {is complete}\"\n",
        "proof": "proof -\n  let ?r = \"InducedRelation(f,R)\"\n  from A1 have \"f \\<in> ord_iso(A,?r,B,R)\"\n    using bij_is_ord_iso by simp\n  moreover from A1 A2 have \"?r \\<subseteq> A\\<times>A\"\n    using bij_is_fun ind_rel_domain by simp\n  moreover note A2 A3\n  ultimately show \"?r {is complete}\"\n    using ord_iso_pres_compl by simp \nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2743
    }
}