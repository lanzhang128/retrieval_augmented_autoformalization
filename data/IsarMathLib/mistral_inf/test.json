{
    "0": {
        "type": "lemma",
        "text": "text\\<open>Sum of two group elements is in the group.\\<close>\n",
        "assumes": "assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"\n  ",
        "using": [
            "assms",
            "group_op_closed"
        ],
        "statement": "lemma (in topgroup) group_op_closed_add:  assumes \"x\\<^sub>1 \\<in> G\"  \"x\\<^sub>2 \\<in> G\"\n  shows \"x\\<^sub>1\\<ra>x\\<^sub>2 \\<in> G\" \n  ",
        "proof": "using assms group_op_closed by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1925,
        "informal": " In the group G, if x1 and x2 are both elements, then their sum x1 + x2 is also an element."
    },
    "1": {
        "type": "lemma",
        "text": "text\\<open>Rerrangement about adding linear functions.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"  \"x\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_2_L3"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L14:\n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"  \"x\\<in>\\<int>\"\n  shows \"(a\\<cdot>x \\<ra> b) \\<ra> (c\\<cdot>x \\<ra> d) = (a\\<ra>c)\\<cdot>x \\<ra> (b\\<ra>d)\"\n  ",
        "proof": "using assms Int_ZF_1_1_L2 ring0.Ring_ZF_2_L3 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 744,
        "informal": " If a, b, c, d, and x are integers, then their dot products and right shifts follow the distributive property: (a dot x right-shift b) plus (c dot x right-shift d) equals (a right-shift c) dot x right-shift (b right-shift d)."
    },
    "2": {
        "type": "theorem",
        "text": "text\\<open>In the following proof, we have chosen an infinite cardinal\nto be able to apply the equation @{prop \"Q\\<times>Q\\<approx>Q\"}. For finite cardinals;\nboth, the assumption and the axiom of choice, are always true.\\<close>\n",
        "assumes": "assumes \"\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> ((\\<Union>T){is compact of cardinal}csucc(Q){in}T)\" \n  and \"InfCard(Q)\"\n  ",
        "using": [
            "lepoll_def"
        ],
        "statement": "theorem second_imp_compact_imp_Q_choice_PowQ:\n  assumes \"\\<forall>T. (T{is a topology} \\<and> (T{is of second type of cardinal}csucc(Q))) \\<longrightarrow> ((\\<Union>T){is compact of cardinal}csucc(Q){in}T)\" \n  and \"InfCard(Q)\"\n  shows \"{the axiom of} Q {choice holds for subsets} (Pow(Q))\"\nproof-\n  {\n    fix N M\n    assume AS:\"M \\<lesssim>Q \\<and>  (\\<forall>t\\<in>M. N`t\\<noteq>0 \\<and> N`t\\<subseteq>Pow(Q))\"\n    then obtain h where \"h\\<in>inj(M,Q)\" ",
        "proof": "using lepoll_def by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2368,
        "informal": " This theorem statement in Isabelle/ZF is defining a property about a second-type topology Q and is using the axiom of choice for subsets of its power set. Here's a natural language version of the theorem statement:\n\nAssume that for every topology T that is of second type with cardinality larger than Q and has the property that the union of its subsets is compact with cardinality greater than or equal to Q, then the axiom of choice holds for subsets of the power set of Q.\n\nProof:\n\nBy fixed point assumption, let N and M be given such that:\n\n1. M is a subset of Q with cardinality strictly less than Q, and\n2. Every element t in M is a non-empty subset of Pow(Q) (the power set of Q) with the property that N intersect t is not empty and is a subset of Pow(Q).\n\nBy the injunctive axiom (injectivity axiom) for the pair (M, Q), there exists a unique h in Pow(Q) such that the subset {x | h ∈ x ∧ x ∈ M} of Pow(Q) is equal to M.\n\nThis shows that the axiom of choice holds for subsets of Pow(Q) in the context of this theorem."
    },
    "3": {
        "type": "lemma",
        "text": "text\\<open>Sets that are bounded below are contained in the domain of \n  the relation.\\<close>\n",
        "assumes": "assumes \"r \\<subseteq> X\\<times>X\" \n  and \"IsBoundedBelow(A,r)\"\n  ",
        "using": [
            "assms",
            "IsBoundedBelow_def"
        ],
        "statement": "lemma Order_ZF_3_L1B: assumes \"r \\<subseteq> X\\<times>X\" \n  and \"IsBoundedBelow(A,r)\"\n  shows \"A\\<subseteq>X\" ",
        "proof": "using assms IsBoundedBelow_def by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1244,
        "informal": " Assuming \"r is a subset of X cross X\" and \"A is boundedly below r,\" we have \"A is a subset of X.\""
    },
    "4": {
        "type": "lemma",
        "text": "text\\<open>Adding a positive integer increases integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L22"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L7A: assumes \"a\\<in>\\<int>\"  \"b \\<in> \\<int>\\<^sub>+\"\n  shows \"a \\<lsq> a\\<ra>b\"  \"a \\<noteq> a\\<ra>b\"  \"a\\<ra>b \\<in> \\<int>\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L22\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 820,
        "informal": " Given integers a and b, where a is in the set of integers and b is a positive integer, show that:\n\n1. a is less than b.\n2. a is not equal to b.\n3. The result of adding b to a is a valid integer."
    },
    "5": {
        "type": "lemma",
        "text": "text\\<open>Taking negative on both sides reverses the inequality, a case with\n  an inverse on one side. Property of ordered groups.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\" and A2: \"(\\<rm>a) \\<lsq> b\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L5AG"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L13: \n  assumes A1: \"a\\<in>\\<real>\" and A2: \"(\\<rm>a) \\<lsq> b\"\n  shows \"(\\<rm>b) \\<lsq> a\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L5AG\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1679,
        "informal": " If a is a real number and a is less than b, then b is less than a."
    },
    "6": {
        "type": "lemma",
        "text": "text\\<open>A bunch of definitions converted to lemmas.\\<close>\n",
        "assumes": "",
        "using": [
            "two_def"
        ],
        "statement": "lemma (in MMIsar0) MMI_df_2: shows \"\\<two> = \\<one>\\<ca>\\<one>\"\n  ",
        "proof": "using two_def by simp\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1086,
        "informal": " \"In the MMISar0 theory, the two constants 'two' and 'one' are equal to each other's successor\"\n\nor more succinctly:\n\n\"In MMISar0: two = succ(one)\" \n\nHere, \"succ(x)\" denotes the successor of a natural number x."
    },
    "7": {
        "type": "lemma",
        "text": "text\\<open> The next lemma shows that open sets are members of (what we will prove later to be)\n   the natural neighborhood system on $X=\\bigcup T$. \\<close>\n",
        "assumes": "assumes \"U\\<in>T\" \"x\\<in>U\"\n  ",
        "using": [
            "assms"
        ],
        "statement": "lemma open_are_neighs:\n  assumes \"U\\<in>T\" \"x\\<in>U\"\n  shows \"x \\<in> \\<Union>T\" and \"U \\<in> {V\\<in>Pow(\\<Union>T).\\<exists>U\\<in>T.(x\\<in>U \\<and> U\\<subseteq>V)}\"\n  ",
        "proof": "using assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2183,
        "informal": " Given that U is an element of set T and x is an element of U, it holds that x is an element of the union of T and U is an element of the set of all subsets of the union of T that contain U. In other words, x belongs to the union of T and U, and U is a subset of one of the subsets of the union of T that contains U."
    },
    "8": {
        "type": "lemma",
        "text": "text\\<open>Taking absolute value does not change nonnegative integers.\\<close>\n",
        "assumes": "assumes \"\\<zero>\\<lsq>m\" ",
        "using": [
            "assms",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L2",
            "group3.OrderedGroup_ZF_3_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L16:\n  assumes \"\\<zero>\\<lsq>m\" shows  \"m\\<in>\\<int>\\<^sup>+\" and \"abs(m) = m\"\n  ",
        "proof": "using assms Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L2 \n    group3.OrderedGroup_ZF_3_L2 by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1004,
        "informal": " Assuming m is zero, we have m is a natural number and abs(m) equals m."
    },
    "9": {
        "type": "lemma",
        "text": "text\\<open>What is the image of a singleton?\\<close>\n",
        "assumes": "assumes \"f\\<in>X\\<rightarrow>Y\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "func_imagedef"
        ],
        "statement": "lemma singleton_image: \n  assumes \"f\\<in>X\\<rightarrow>Y\" and \"x\\<in>X\"\n  shows \"f``{x} = {f`(x)}\"\n  ",
        "proof": "using assms func_imagedef by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2605,
        "informal": " If function f is an element of X -> Y and x is an element of X, then the image of x under f is the set containing the image of x under f.\n\nIn simpler terms, the image of x under a function f is a set with exactly one element, which is f(x)."
    },
    "10": {
        "type": "lemma",
        "text": "text\\<open>A base defines topology uniquely.\\<close>\n",
        "assumes": "assumes \"B {is a base for} T\" and \"B {is a base for} S\" \n  ",
        "using": [
            "assms",
            "IsAbaseFor_def"
        ],
        "statement": "lemma same_base_same_top: \n  assumes \"B {is a base for} T\" and \"B {is a base for} S\" \n  shows \"T = S\"\n  ",
        "proof": "using assms IsAbaseFor_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2041,
        "informal": " If B is a base for both set T and set S, then T and S are equal."
    },
    "11": {
        "type": "lemma",
        "text": "text\\<open>Absolute value maps $G$ into $G$.\\<close>\n",
        "assumes": "",
        "using": [
            "id_type",
            "OrderedGroup_ZF_1_L4E",
            "fun_weaken_type",
            "IsAnOrdGroup_def",
            "group0_2_T2",
            "restrict_type2",
            "AbsoluteValue_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L1: \n  shows \"AbsoluteValue(G,P,r) : G\\<rightarrow>G\"\n",
        "proof": "proof -\n  let ?f = \"id(G\\<^sup>+)\"\n  let ?g = \"restrict(GroupInv(G,P),G-G\\<^sup>+)\"\n  have \"?f : G\\<^sup>+\\<rightarrow>G\\<^sup>+\" using id_type by simp\n  then have \"?f : G\\<^sup>+\\<rightarrow>G\" using OrderedGroup_ZF_1_L4E fun_weaken_type\n    by blast\n  moreover have \"?g : G-G\\<^sup>+\\<rightarrow>G\"\n  proof -\n    from ordGroupAssum have \"GroupInv(G,P) : G\\<rightarrow>G\" \n      using IsAnOrdGroup_def group0_2_T2 by simp\n    moreover have \"G-G\\<^sup>+ \\<subseteq> G\" by auto\n    ultimately show ?thesis using restrict_type2 by simp\n  qed\n  moreover have \"G\\<^sup>+\\<inter>(G-G\\<^sup>+) = 0\" by blast\n  ultimately have \"?f \\<union> ?g : G\\<^sup>+\\<union>(G-G\\<^sup>+)\\<rightarrow>G\\<union>G\" \n    by (rule fun_disjoint_Un)\n  moreover have \"G\\<^sup>+\\<union>(G-G\\<^sup>+) = G\" using OrderedGroup_ZF_1_L4E\n    by auto\n  ultimately show \"AbsoluteValue(G,P,r) : G\\<rightarrow>G\" \n    using AbsoluteValue_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1450,
        "informal": " In the group3 theory, we have the following lemma:\n\n\"For all G, P in G, and r in Real, AbsoluteValue of G, P, r is a function from G to G.\""
    },
    "12": {
        "type": "lemma",
        "text": "text\\<open>If a real number is less than another, then the second one can not\n  be less or equal that the first.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" ",
        "using": [
            "Real_ZF_1_2_L10"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L29: \n  assumes \"a\\<ls>b\" shows \"\\<not>(b\\<lsq>a)\"\n",
        "proof": "proof -\n  from assms have\n    \"group3(\\<real>,RealAddition,OrderOnReals)\"\n    \"\\<langle>a,b\\<rangle> \\<in> OrderOnReals\"  \"a\\<noteq>b\"\n    using Real_ZF_1_2_L10 by auto\n  then have \"\\<langle>b,a\\<rangle> \\<notin> OrderOnReals\"\n    by (rule group3.OrderedGroup_ZF_1_L8AA)\n  then show \"\\<not>(b\\<lsq>a)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1703,
        "informal": " In the real number theory context of Isabelle/ZF:\n\nAssumption: a < b\nConclusion: b < a is false."
    },
    "13": {
        "type": "theorem",
        "text": "text\\<open>Suppose that we take any nonempty collection $C$ of subsets of some set $X$. \nThen this collection is a base filter for the collection of all supersets (in $X$) of sets from $C$.\n\\<close>\n",
        "assumes": "assumes \"C \\<subseteq> Pow(X)\" and \"C\\<noteq>0\"\n  ",
        "using": [
            "assms(1)",
            "IsBaseFilter_def"
        ],
        "statement": "theorem base_unique_filter_set1:\n  assumes \"C \\<subseteq> Pow(X)\" and \"C\\<noteq>0\"\n  shows \"C {is a base filter} {A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}\" and \"\\<Union>{A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}=X\"\n",
        "proof": "proof-\n  from assms(1) have \"C\\<subseteq>{A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}\" by auto\n  moreover\n  from assms(2) obtain D where \"D\\<in>C\" by auto\n  then have \"D\\<subseteq>X\" using assms(1) by auto\n  with \\<open>D\\<in>C\\<close> have \"X\\<in>{A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}\" by auto\n  then show \"\\<Union>{A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}=X\" by auto\n  ultimately\n  show \"C {is a base filter} {A\\<in>Pow(X). \\<exists>D\\<in>C. D\\<subseteq>A}\" using IsBaseFilter_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2159,
        "informal": " Given a subset C of the power set of X that is proper and not empty, C is a base filter and the union of all A in the power set of X such that there exists a D in C that is a subset of A, equals X."
    },
    "14": {
        "type": "lemma",
        "text": "text\\<open>A lemma on a union of a restriction of a collection\n  to a set.\\<close>\n",
        "assumes": "",
        "using": [
            "RestrictedTo_def"
        ],
        "statement": "lemma union_restrict: \n  shows \"\\<Union>(M {restricted to} X) = (\\<Union>M) \\<inter> X\"\n  ",
        "proof": "using RestrictedTo_def by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2521,
        "informal": " The lemma `union_restrict` asserts that the union of a set `M` restricted to subset `X` is equal to the intersection of the set `M`'s union and set `X`. In simpler terms, the union of a set with respect to a subset equals the subset of the union intersected with that subset."
    },
    "15": {
        "type": "lemma",
        "text": "text\\<open>Positive slopes are functions (of course.)\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\\<^sub>+\" ",
        "using": [
            "assms",
            "AlmostHoms_def",
            "PositiveSet_def"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L1: assumes A1: \"f\\<in>\\<S>\\<^sub>+\" shows \"f:\\<int>\\<rightarrow>\\<int>\"\n  ",
        "proof": "using assms AlmostHoms_def PositiveSet_def by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 893,
        "informal": " Assuming a set S contains only plus-integers (natural numbers), and function f is a member of this set, then f is a function from integers to integers."
    },
    "16": {
        "type": "lemma",
        "text": "text\\<open>A relation orders a set iff the converse relation orders a set. Going\n  one way we can use the the lemma \\<open>tot_od_converse\\<close> from the standard \n  Isabelle's \\<open>Order.thy\\<close>.The other way is a bit more complicated (note that\n  in Isabelle for \\<open>converse(converse(r)) = r\\<close> one needs $r$ to consist\n  of ordered pairs, which does not follow from the \\<open>StrictOrder\\<close> \n  definition above).\\<close>\n",
        "assumes": "",
        "using": [
            "orders_imp_tot_ord",
            "tot_ord_converse",
            "tot_ord_imp_orders",
            "StrictOrder_def"
        ],
        "statement": "lemma cnvso: shows \"R Orders A \\<longleftrightarrow> converse(R) Orders A\"\n",
        "proof": "proof\n  let ?r = \"converse(R)\"\n  assume \"R Orders A\"\n  then have \"tot_ord(A,?r)\" using orders_imp_tot_ord tot_ord_converse\n    by simp\n  then show \"?r Orders A\" using tot_ord_imp_orders\n    by simp\nnext\n  let ?r = \"converse(R)\"\n  assume \"?r Orders A\"\n  then have A2: \"\\<forall>x y z. (x\\<in>A \\<and> y\\<in>A \\<and> z\\<in>A) \\<longrightarrow> \n    (\\<langle>x,y\\<rangle> \\<in> ?r \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> ?r)) \\<and> \n    (\\<langle>x,y\\<rangle> \\<in> ?r \\<and> \\<langle>y,z\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> ?r)\"\n    using StrictOrder_def by simp\n  { fix x y z\n    assume \"x\\<in>A \\<and> y\\<in>A \\<and> z\\<in>A\"\n    with A2 have\n      I: \"\\<langle>y,x\\<rangle> \\<in> ?r \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>x,y\\<rangle> \\<in> ?r)\" and\n      II: \"\\<langle>y,x\\<rangle> \\<in> ?r \\<and> \\<langle>z,y\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>z,x\\<rangle> \\<in> ?r\"\n      by auto\n    from I have \"\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)\"\n      by auto\n    moreover from II have \"\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R\"\n      by auto\n    ultimately have \"(\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)) \\<and> \n      (\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R)\" by simp\n  } then have  \"\\<forall>x y z. (x\\<in>A \\<and> y\\<in>A \\<and> z\\<in>A) \\<longrightarrow> \n      (\\<langle>x,y\\<rangle> \\<in> R \\<longleftrightarrow> \\<not>(x=y \\<or> \\<langle>y,x\\<rangle> \\<in> R)) \\<and> \n      (\\<langle>x,y\\<rangle> \\<in> R \\<and> \\<langle>y,z\\<rangle> \\<in> R \\<longrightarrow> \\<langle>x,z\\<rangle> \\<in> R)\"\n    by auto\n  then show \"R Orders A\" using StrictOrder_def by simp\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Order_ZF_1.thy",
        "id": 1267,
        "informal": " A relation R orders element A if and only if the converse relation of R orders A."
    },
    "17": {
        "type": "definition",
        "text": "text\\<open>We define the image filter as the collections of supersets of of images of sets from a filter.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  ImageFilter (\"_[_].._\" 98)\n  where \"\\<FF> {is a filter on} X \\<Longrightarrow> f:X\\<rightarrow>Y \\<Longrightarrow> f[\\<FF>]..Y \\<equiv> {A\\<in>Pow(Y). \\<exists>D\\<in>{f``(B) .B\\<in>\\<FF>}. D\\<subseteq>A}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_4",
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_6.thy",
        "id": 2227,
        "informal": " A filter on a set X, together with a function f:X->Y, forms an image filter if the image of the filter under f (i.e., the set of images of filter elements under f) is equal to the set of subsets of Y that contain at least one element in common with the image of some filter element. In other words, for all filters _[...]_ on X and all functions f:X->Y, f[_[...]_] (the image of the filter under f) is equal to the set of subsets A of Y that have an element in common with some element in the domain of f (i.e., in the filter)."
    },
    "18": {
        "type": "definition",
        "text": "text\\<open>We also define \n  the absolute value as a ZF-function that is the \n  identity on $G^+$ and the group inverse on the rest of the group.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"AbsoluteValue(G,P,r) \\<equiv> id(Nonnegative(G,P,r)) \\<union> \n  restrict(GroupInv(G,P),G - Nonnegative(G,P,r))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1352,
        "informal": " The predicate \"AbsoluteValue(G, P, r)\" holds if and only if the element \"r\" belongs to the set \"G\" and is either nonnegative or is in the complement of the nonnegative elements in \"G\" with respect to the group operation \"P\". In other words, \"AbsoluteValue(G, P, r)\" is true if and only if \"r\" is an element of the group \"G\" with group operation \"P\" and its absolute value with respect to this operation is in the group."
    },
    "19": {
        "type": "theorem",
        "text": "text\\<open>The collection of open sets $U$ such that $f$ restricted to \n$U$ is continuous, is a topology.\\<close>\n",
        "assumes": "",
        "using": [
            "pasting_lemma1",
            "tau1_is_top",
            "IsATopology_def",
            "cont_inter_cont"
        ],
        "statement": "theorem (in two_top_spaces0) pasting_theorem:\n  shows \"{U \\<in> \\<tau>\\<^sub>1. restrict(f,U) {is continuous}} {is a topology}\"\n",
        "proof": "proof -\n  let ?T = \"{U \\<in> \\<tau>\\<^sub>1. restrict(f,U) {is continuous}}\"\n  have \"\\<forall>M\\<in>Pow(?T). \\<Union>M \\<in> ?T\" \n  proof\n    fix M assume \"M \\<in> Pow(?T)\"\n    then have \"restrict(f,\\<Union>M) {is continuous}\"\n      using pasting_lemma1 by auto\n    with \\<open>M \\<in> Pow(?T)\\<close> show \"\\<Union>M \\<in> ?T\"\n      using tau1_is_top IsATopology_def by auto\n  qed\n  moreover have \"\\<forall>U\\<in>?T.\\<forall>V\\<in>?T. U\\<inter>V \\<in> ?T\"\n    using cont_inter_cont tau1_is_top IsATopology_def by auto\n  ultimately show ?thesis using IsATopology_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2127,
        "informal": " \"The restriction of function f to set U, in the topological space \\<tau>1, is a continuous function and forms a topology.\""
    },
    "20": {
        "type": "definition",
        "text": "text\\<open>The full reduction is conceived as one of those possible\npaths reaching a final state.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  NFSASatisfy (\"_ <-N '(_,_,_,_'){in alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an NFSA for alphabet}\\<Sigma> \\<Longrightarrow> i\\<in>Lists(\\<Sigma>) \\<Longrightarrow> \n  i <-N (S,s\\<^sub>0,t,F){in alphabet}\\<Sigma> \\<equiv> (\\<exists>q\\<in>Pow(S). (q\\<inter>F\\<noteq>0 \\<and> \\<langle>\\<langle>i,{s\\<^sub>0}\\<rangle>,\\<langle>0,q\\<rangle>\\<rangle>\\<in> ({reduce N-relation}(S,s\\<^sub>0,t){in alphabet}\\<Sigma>)^*)) \\<or> (i = 0 \\<and> s\\<^sub>0\\<in>F)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 305,
        "informal": " A relation NFSASatisfy holds between a non-finite state automaton (NFA) S with state set Σ, initial state s0, transition function t, and final state set F, and an element i from the alphabet Σ, if i is in the NFA's language or i is the initial state and s0 is in the set of final states. \n\nFormally, for all NFA (S, s0, t, F) over alphabet Σ, and all i in Σ:\n\ni is in the language of NFA (S, s0, t, F) (defined by the relation N-relation) with respect to the input sequence {i} and the initial state s0, or i = 0 and s0 is a final state."
    },
    "21": {
        "type": "lemma",
        "text": "text\\<open>The next formula restates the definition of the homomorphism \n  difference to express the value an almost homomorphism on a sum.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_1_L2",
            "AlmostHoms_def",
            "Int_ZF_2_1_L3",
            "Int_ZF_1_L3",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_L1"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L3A: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"f`(m\\<ra>n) = f`(m)\\<ra>(f`(n)\\<ra>\\<delta>(f,m,n))\"\n",
        "proof": "proof -\n  from A1 A2 have\n    T: \"f`(m)\\<in> \\<int>\"  \"f`(n) \\<in> \\<int>\"  \"\\<delta>(f,m,n) \\<in> \\<int>\" and\n    \"HomDiff(\\<int>,IntegerAddition,f,\\<langle> m,n\\<rangle>) = \\<delta>(f,m,n)\"  \n    using Int_ZF_2_1_L2 AlmostHoms_def Int_ZF_2_1_L3 by auto\n  with A1 A2 show  \"f`(m\\<ra>n) = f`(m)\\<ra>(f`(n)\\<ra>\\<delta>(f,m,n))\" \n    using Int_ZF_2_1_L3 Int_ZF_1_L3 \n      Int_ZF_2_1_L1 group1.Group_ZF_3_4_L1 \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 845,
        "informal": " Given integers m, n, and a function f belonging to a set S, if m and n are in the domain of f, then the function application of f to the result of applying the addition operation on m and n, is equal to the product of the function application of f to m, and the function application of f to n.\n\nIn simpler terms, if both m and n are valid inputs for the function f and S is the set of functions to which f belongs, then f(m + n) equals f(m) * f(n)."
    },
    "22": {
        "type": "lemma",
        "text": "text\\<open>The first lemma states that we indeeed talk about topological group\n  in the context of \\<open>topgroup\\<close> locale.\\<close>\n",
        "assumes": "",
        "using": [
            "topSpaceAssum",
            "Ggroup",
            "fcon",
            "inv_cont",
            "IsAtopologicalGroup_def"
        ],
        "statement": "lemma (in topgroup) topGroup: shows \"IsAtopologicalGroup(T,f)\"\n  ",
        "proof": "using topSpaceAssum Ggroup fcon inv_cont IsAtopologicalGroup_def \n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1919,
        "informal": " In the context of the topology `topgroup`, it is proved that `T` with function `f` forms a topological group."
    },
    "23": {
        "type": "lemma",
        "text": "text\\<open>The values of the lift are defined by the value of the liftee in a \n  natural way.\\<close>\n",
        "assumes": "assumes A1: \"f : Y\\<times>Y\\<rightarrow>Y\" \n  and A2: \"p \\<in> (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\" and A3: \"x\\<in>X\"\n  and A4: \"P = {\\<langle>x,f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\\<rangle>. x \\<in> X}\"\n  ",
        "using": [
            "func_ZF_1_L1",
            "ZF_fun_from_tot_val"
        ],
        "statement": "lemma func_ZF_1_L2: \n  assumes A1: \"f : Y\\<times>Y\\<rightarrow>Y\" \n  and A2: \"p \\<in> (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\" and A3: \"x\\<in>X\"\n  and A4: \"P = {\\<langle>x,f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\\<rangle>. x \\<in> X}\"\n  shows \"P`(x) = f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\" \n",
        "proof": "proof -\n  from A1 A2 have \n    \"{\\<langle>x,f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\\<rangle>. x \\<in> X} : X \\<rightarrow> range(f)\"\n    using func_ZF_1_L1 by simp\n  with A4 have \"P :  X \\<rightarrow> range(f)\" by simp\n  with  A3 A4 show \"P`(x) = f`\\<langle>fst(p)`(x),snd(p)`(x)\\<rangle>\"\n    using ZF_fun_from_tot_val by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2672,
        "informal": " Given a function `f` from `Y` to `Y`, an element `p` in the product of `X` to `range(f)` and `X` to `range(f)`, and an element `x` in `X`, a set `P` is defined as the set of pairs `<x, y>` with `x` in `X` and `y` equal to `<f (fst p (x)), snd p (x)>`. Therefore, `P(x)` equals `<f (fst p (x)), snd p (x)>`."
    },
    "24": {
        "type": "lemma",
        "text": "text\\<open>Type information related to the situation of three almost\n  homomorphisms.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"  \"q\\<in>AH\" and A2: \"n\\<in>G\"\n  ",
        "using": [
            "AlmostHoms_def",
            "apply_type",
            "group0_2_L1",
            "monoid0.group0_1_L1",
            "inverse_in_group",
            "Group_ZF_3_2_L4A"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L8: \n  assumes A1: \"s\\<in>AH\"  \"r\\<in>AH\"  \"q\\<in>AH\" and A2: \"n\\<in>G\"\n  shows \n  \"q`(n)\\<in>G\"\n  \"s`(r`(n)) \\<in> G\"\n  \"r`(n)\\<cdot>(q`(n))\\<inverse> \\<in> G\"\n  \"s`(r`(n)\\<cdot>(q`(n))\\<inverse>) \\<in> G\"\n  \"\\<delta>(s,\\<langle> q`(n),r`(n)\\<cdot>(q`(n))\\<inverse>\\<rangle>) \\<in> G\"\n",
        "proof": "proof -\n  from A1 A2 show \n    \"q`(n)\\<in> G\"  \"s`(r`(n)) \\<in> G\" \"r`(n)\\<cdot>(q`(n))\\<inverse> \\<in> G\"\n    using AlmostHoms_def apply_type  \n      group0_2_L1 monoid0.group0_1_L1 inverse_in_group\n    by auto\n  with A1 A2 show \"s`(r`(n)\\<cdot>(q`(n))\\<inverse>) \\<in> G\"\n    \"\\<delta>(s,\\<langle> q`(n),r`(n)\\<cdot>(q`(n))\\<inverse>\\<rangle>) \\<in> G\"\n    using AlmostHoms_def apply_type Group_ZF_3_2_L4A\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 607,
        "informal": " In the group AH, if elements s, r, q are present and n is an element of the group G, then:\n\n- q^n is an element of G\n- s^(r^n) is an element of G\n- r^n * (q^n)^-1 is an element of G\n- s^(r^n * (q^n)^-1) is an element of G\n- the substitute (s, (q^n, r^n * (q^n)^-1)) is contained in G."
    },
    "25": {
        "type": "lemma",
        "text": "text\\<open>Some sources (like Wikipedia) use a bit different definition of neighborhood systems\nwhere the $U$ is required to be contained in $N$. The next lemma shows that this stronger version \ncan be recovered from our definition. \\<close>\n",
        "assumes": "assumes \"\\<M> {is a neighborhood system on} X\" and \"x\\<in>X\" and \"N\\<in>\\<M>`(x)\"\n  ",
        "using": [
            "IsNeighSystem_def"
        ],
        "statement": "lemma neigh_def_stronger:\n  assumes \"\\<M> {is a neighborhood system on} X\" and \"x\\<in>X\" and \"N\\<in>\\<M>`(x)\"\n  shows \"\\<exists>U\\<in>\\<M>`(x).U\\<subseteq>N \\<and> (\\<forall>y\\<in>U.(N\\<in>\\<M>`(y)))\" \n",
        "proof": "proof -\n  from assms obtain W where \"W\\<in>\\<M>`(x)\" and areNeigh:\"\\<forall>y\\<in>W.(N\\<in>\\<M>`(y))\"\n    using  IsNeighSystem_def by blast\n  let ?U = \"N\\<inter>W\"\n  from assms \\<open>W\\<in>\\<M>`(x)\\<close> have \"?U \\<in> \\<M>`(x)\" \n    unfolding IsNeighSystem_def IsFilter_def by blast \n  moreover have \"?U\\<subseteq>N\" by blast\n  moreover from areNeigh have \"\\<forall>y\\<in>?U.(N\\<in>\\<M>`(y))\" by auto \n  ultimately show ?thesis by auto \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2177,
        "informal": " If M is a neighborhood system on X and x is an element of X, then there exists a neighborhood U in M of x such that U is a subset of N and every element y in U is also a member of some neighborhood in M."
    },
    "26": {
        "type": "lemma",
        "text": "text\\<open>Some identities about the homomorphism difference of odd functions.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"\\<forall>x\\<in>\\<int>. (\\<rm>f`(\\<rm>x)) = f`(x)\"\n  and A3: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_2_L3",
            "Int_ZF_2_1_L18",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_5_L13"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L19: \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"\\<forall>x\\<in>\\<int>. (\\<rm>f`(\\<rm>x)) = f`(x)\"\n  and A3: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows\n  \"abs(\\<delta>(f,\\<rm>m,m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n  \"abs(\\<delta>(f,\\<rm>n,m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n  \"\\<delta>(f,n,\\<rm>(m\\<ra>n)) = \\<delta>(f,m,n)\"\n  \"\\<delta>(f,m,\\<rm>(m\\<ra>n)) = \\<delta>(f,m,n)\"\n  \"abs(\\<delta>(f,\\<rm>m,\\<rm>n)) = abs(\\<delta>(f,m,n))\"\n",
        "proof": "proof -\n  from A1 A2 A3 show \n    \"abs(\\<delta>(f,\\<rm>m,m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n    \"abs(\\<delta>(f,\\<rm>n,m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n    using Int_ZF_1_2_L3 Int_ZF_2_1_L18 by auto\n  from A3 have T: \"m\\<ra>n \\<in> \\<int>\" using Int_ZF_1_1_L5 by simp\n  from A1 A2 have I: \"\\<forall>x\\<in>\\<int>. f`(\\<rm>x) = (\\<rm>f`(x))\"\n    using Int_ZF_1_5_L13 by simp\n  with A1 A2 A3 T show \n    \"\\<delta>(f,n,\\<rm>(m\\<ra>n)) = \\<delta>(f,m,n)\"\n    \"\\<delta>(f,m,\\<rm>(m\\<ra>n)) = \\<delta>(f,m,n)\"\n    using Int_ZF_1_2_L3 Int_ZF_2_1_L18 by auto\n  from A3 have \n    \"abs(\\<delta>(f,\\<rm>m,\\<rm>n)) = abs(f`(\\<rm>(m\\<ra>n)) \\<rs> f`(\\<rm>m) \\<rs> f`(\\<rm>n))\"\n    using Int_ZF_1_1_L5 by simp\n  also from A1 A2 A3 T I have \"\\<dots> = abs(\\<delta>(f,m,n))\"\n    using Int_ZF_2_1_L18 by simp\n  finally show \"abs(\\<delta>(f,\\<rm>m,\\<rm>n)) = abs(\\<delta>(f,m,n))\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 870,
        "informal": " Given a function f : int -> int that is equal to its application to any argument, and integers m and n, the absolute differences between f and m, f and n, and between f and the result of applying m and n with the \"ra>\" right-associative arrow operator, are all equal."
    },
    "27": {
        "type": "lemma",
        "text": "text\\<open>We can add sides of two inequalities\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\"  \"c\\<lsq>d\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "group3.OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L18: assumes \"a\\<lsq>b\"  \"c\\<lsq>d\"\n  shows \"a\\<ra>c \\<lsq> b\\<ra>d\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 group3.OrderedGroup_ZF_1_L5B\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1687,
        "informal": " In the real numbers: if a is less than b and c is less than d, then a is to the left of c and b is to the left of d. (Or, more succinctly: less than is transitive for real numbers.)"
    },
    "28": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>append_props\\<close>: appending to a nonempty\n  list does not change the head (first element) of the list.\\<close>\n",
        "assumes": "assumes \"n\\<in> nat\" and \"a: succ(n) \\<rightarrow> X\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "append_props",
            "empty_in_every_succ"
        ],
        "statement": "corollary head_of_append: \n  assumes \"n\\<in> nat\" and \"a: succ(n) \\<rightarrow> X\" and \"x\\<in>X\"\n  shows \"Append(a,x)`(0) = a`(0)\"\n  ",
        "proof": "using assms append_props empty_in_every_succ by auto\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 239,
        "informal": " Given a natural number n, a successor function a that maps each natural number to an element of set X, and an element x in X, the head of the append of a and x is equal to the head of a."
    },
    "29": {
        "type": "lemma",
        "text": "text\\<open>What is $-G_+$, really?\\<close>\n",
        "assumes": "",
        "using": [
            "IsAnOrdGroup_def",
            "group0_2_T2",
            "PositiveSet_def",
            "func_imagedef",
            "func1_1_L6"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L25: shows \n  \"(\\<sm>G\\<^sub>+) = {a\\<inverse>. a\\<in>G\\<^sub>+}\"\n  \"(\\<sm>G\\<^sub>+) \\<subseteq> G\"\n",
        "proof": "proof -\n  from ordGroupAssum have I: \"GroupInv(G,P) : G\\<rightarrow>G\"\n    using IsAnOrdGroup_def group0_2_T2 by simp\n  moreover have \"G\\<^sub>+ \\<subseteq> G\" using PositiveSet_def by auto\n  ultimately show \n    \"(\\<sm>G\\<^sub>+) = {a\\<inverse>. a\\<in>G\\<^sub>+}\"\n    \"(\\<sm>G\\<^sub>+) \\<subseteq> G\"\n    using func_imagedef func1_1_L6 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1431,
        "informal": " In the group3 theory, the sum operation (+) in the group G is equal to the set of inverses of elements in G followed by their sums, and this set is a subset of G."
    },
    "30": {
        "type": "lemma",
        "text": "text\\<open>The next lemma will replace \\<open>func1_1_L11B\\<close> one day.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\"   \"x\\<in>X\"\n  and \"f = {\\<langle>x,b(x)\\<rangle>. x\\<in>X}\"\n  ",
        "using": [
            "apply_iff"
        ],
        "statement": "lemma ZF_fun_from_tot_val: \n  assumes \"f:X\\<rightarrow>Y\"   \"x\\<in>X\"\n  and \"f = {\\<langle>x,b(x)\\<rangle>. x\\<in>X}\"\n  shows \"f`(x) = b(x)\" and \"b(x)\\<in>Y\"\n",
        "proof": "proof -\n  from assms(1,2) have \"\\<langle>x,f`(x)\\<rangle> \\<in> f\" using apply_iff by simp\n  with assms(3) show \"f`(x) = b(x)\" by simp\n  from assms(1,2) have \"f`(x)\\<in>Y\" by (rule apply_funtype)\n  with \\<open>f`(x) = b(x)\\<close> show \"b(x)\\<in>Y\" by simp \nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2575,
        "informal": " Given a function f from X to Y, and assuming x is an element of X, if the function f is defined as the total relation {<xy>. x is in X and y is b(x)}, then f(x) equals b(x), and b(x) is an element of Y."
    },
    "31": {
        "type": "lemma",
        "text": "text\\<open>Reals form a field.\\<close>\n",
        "assumes": "",
        "using": [
            "real1.reals_are_ord_field",
            "OrdField_ZF_1_L1A"
        ],
        "statement": "lemma reals_are_field: \n  shows \"IsAfield(RealNumbers,RealAddition,RealMultiplication)\"\n  ",
        "proof": "using real1.reals_are_ord_field OrdField_ZF_1_L1A\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1706,
        "informal": " The Real Numbers form a field under the addition and multiplication operations denoted by RealAddition and RealMultiplication, respectively."
    },
    "32": {
        "type": "corollary",
        "text": "text\\<open>Another way of expressing the fact that the product dos not depend\n  on the order.\\<close>\n",
        "assumes": "assumes \"f {is commutative on} G\" and\n  \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and\n  \"b \\<in> bij(|A|,A)\" \"c \\<in> bij(|A|,A)\"\n  ",
        "using": [
            "assms",
            "prod_order_irr"
        ],
        "statement": "corollary (in semigr1) prod_bij_same: \n  assumes \"f {is commutative on} G\" and\n  \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and\n  \"b \\<in> bij(|A|,A)\" \"c \\<in> bij(|A|,A)\"\n  shows \"(\\<Prod> (a O b)) = (\\<Prod> (a O c))\"\n  ",
        "proof": "using assms prod_order_irr by simp\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1908,
        "informal": " If function f is commutative on set G, and sets A (a non-empty subset of X) and b, c are two bijections (i.e., bijective functions) from set |A| to A, then the pointwise product of function a with b and the pointwise product of function a with c are equal."
    },
    "33": {
        "type": "lemma",
        "text": "text\\<open>The next lemma shows a somewhat more explicit way of defining the product \n  of two subsets of a group.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \n  ",
        "using": [
            "assms",
            "group_oper_fun",
            "lift_subsets_explained"
        ],
        "statement": "lemma (in group4) interval_prod: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \n  shows \"A\\<sdot>B =  {x\\<cdot>y. \\<langle>x,y\\<rangle> \\<in> A\\<times>B}\"\n  ",
        "proof": "using assms group_oper_fun lift_subsets_explained by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 508,
        "informal": " Assuming \"A is a subset of G\" and \"B is a subset of G\" in the context of group4, the product of A and B equals the set of all pairwise products of elements from A and B that belong to the Cartesian product of A and B."
    },
    "34": {
        "type": "definition",
        "text": "text\\<open>We also define a composition (binary) operator on almost homomorphisms in \n  a natural way. We call that operator \\<open>AlHomOp2\\<close> - the second operation \n  on almost homomorphisms. Composition of almost homomorphisms is \n  used to define multiplication of real numbers in \\<open>Real_ZF\\<close> series.\n\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"AlHomOp2(G,f) \\<equiv> \n  restrict(Composition(G),AlmostHoms(G,f)\\<times>AlmostHoms(G,f))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 569,
        "informal": " \"AlHomOp2(G, f) holds if and only if the composition of G is included in the product of two sets of almost homomorphisms of G with respect to f.\" \n\nOr in a more condensed form: \"AlHomOp2(G, f) iff composition(G) ⊆ almost_homomorphisms(G, f) × almost_homomorphisms(G, f)\" \n\nNote: The notation and definitions used in the Isabelle/ZF code might not align perfectly with standard mathematical notation or definitions without additional context. The natural language version provided here is an interpretation based on the given code."
    },
    "35": {
        "type": "lemma",
        "text": "text\\<open>We can multiply strict inequality by a positive element.\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\" and \"c\\<in>R\\<^sub>+\"\n  ",
        "using": [
            "assms",
            "OrdField_ZF_1_L1B",
            "field0.field_has_no_zero_divs",
            "OrdRing_ZF_3_L13"
        ],
        "statement": "lemma (in field1) OrdField_ZF_2_L1: \n  assumes \"a\\<ls>b\" and \"c\\<in>R\\<^sub>+\"\n  shows \"a\\<cdot>c \\<ls> b\\<cdot>c\"\n  ",
        "proof": "using assms OrdField_ZF_1_L1B field0.field_has_no_zero_divs\n    OrdRing_ZF_3_L13\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1339,
        "informal": " In the `field1` context, if `a` is less than `b` and `c` is an element of `R+`, then `a * c` is less than or equal to `b * c`."
    },
    "36": {
        "type": "lemma",
        "text": "text\\<open>Kind of inverse of \\<open>bisec_props\\<close>: a pair of nonempty\n  disjoint sets form a bisection of their union.\\<close>\n",
        "assumes": "assumes \"A\\<noteq>0\"  \"B\\<noteq>0\"  \"A \\<inter> B = 0\" \n  ",
        "using": [
            "assms",
            "Bisections_def"
        ],
        "statement": "lemma is_bisec: \n  assumes \"A\\<noteq>0\"  \"B\\<noteq>0\"  \"A \\<inter> B = 0\" \n  shows \"\\<langle>A,B\\<rangle> \\<in> Bisections(A\\<union>B)\" ",
        "proof": "using assms Bisections_def\n  by auto\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.FiniteSeq_ZF"
        ],
        "source": "IsarMathLib/Partitions_ZF.thy",
        "id": 1598,
        "informal": " If A and B are non-empty sets and their intersection is empty, then the pair <A, B> is an element of the set of bisections of A union B."
    },
    "37": {
        "type": "lemma",
        "text": "text\\<open>Ordered group (carrier) is not empty. This is a property of\n  monoids, but it is good to have it handy in the \\<open>group3\\<close> context.\\<close>\n",
        "assumes": "",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L1",
            "monoid0.group0_1_L3A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L1A: shows \"G\\<noteq>0\"\n  ",
        "proof": "using OrderedGroup_ZF_1_L1 group0.group0_2_L1 monoid0.group0_1_L3A\n  by blast\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1355,
        "informal": " In the group3 theory, there is a lemma stating that the group G is not equal to the empty set."
    },
    "38": {
        "type": "lemma",
        "text": "text\\<open>If $a$ is not greater than $b$, then $1$ is not greater than\n  $b\\cdot a^{-1}$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" ",
        "using": [
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L9A"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L12A:\n  assumes A1: \"a\\<lsq>b\" shows \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\"\n",
        "proof": "proof -\n  from A1 have T: \"\\<one> \\<in> G\"  \"a\\<in>G\"  \"b\\<in>G\" \n    using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by auto\n  with A1 have \"\\<one>\\<cdot>a \\<lsq> b\" \n    using OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by simp\n  with T show \"\\<one> \\<lsq> b\\<cdot>a\\<inverse>\" using OrderedGroup_ZF_1_L9A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1414,
        "informal": " In the group3 theory, given that a is less than b, we have the inverse of b * a is the one element."
    },
    "39": {
        "type": "lemma",
        "text": "text\\<open>For every integer there is one in \\<open>\\<int>\\<^sub>+\\<close> that is greater or \n  equal.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "int_not_trivial",
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L23"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L9: assumes \"a\\<in>\\<int>\"\n  shows \"\\<exists>b\\<in>\\<int>\\<^sub>+. a\\<lsq>b\"\n  ",
        "proof": "using assms int_not_trivial Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L23\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 823,
        "informal": " Assuming `a` is an integer, there exists an integer `b` such that `a + b` holds."
    },
    "40": {
        "type": "lemma",
        "text": "text\\<open>In fields square of a nonzero element is positive.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "OrdField_ZF_1_L1B",
            "field0.field_has_no_zero_divs",
            "OrdRing_ZF_3_L15"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L6: assumes \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"\n  shows \"a\\<^sup>2 \\<in> R\\<^sub>+\"\n  ",
        "proof": "using assms OrdField_ZF_1_L1B field0.field_has_no_zero_divs\n    OrdRing_ZF_3_L15 by simp\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1333,
        "informal": " Assuming `a` is an element in the set `R` and `a` is not equal to zero, the square of `a` is also an element in the set `R`."
    },
    "41": {
        "type": "lemma",
        "text": "text\\<open>A lemma about adding one to floor.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "int_0_1_are_real_zero_one",
            "int0.int_zero_one_are_int",
            "Real_ZF_1_4_L7",
            "Real_ZF_1_4_L1A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L17A: assumes A1: \"a\\<in>\\<real>\"\n  shows \"\\<one> \\<ra> \\<lfloor>a\\<rfloor>\\<^sup>R = (\\<one>\\<^sub>Z \\<za> \\<lfloor>a\\<rfloor>)\\<^sup>R\"\n",
        "proof": "proof -\n  have \"\\<one> \\<ra> \\<lfloor>a\\<rfloor>\\<^sup>R = \\<one>\\<^sub>Z\\<^sup>R \\<ra> \\<lfloor>a\\<rfloor>\\<^sup>R\"\n    using int_0_1_are_real_zero_one by simp\n  with A1 show \"\\<one> \\<ra> \\<lfloor>a\\<rfloor>\\<^sup>R = (\\<one>\\<^sub>Z \\<za> \\<lfloor>a\\<rfloor>)\\<^sup>R\"\n    using int0.int_zero_one_are_int Real_ZF_1_4_L7 Real_ZF_1_4_L1A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1748,
        "informal": " Given a real number `a`, the square root of the rounddown of `a` in the real numbers is equal to the square root of one less than the rounddown of `a` in the integers."
    },
    "42": {
        "type": "lemma",
        "text": "text\\<open>We can multiply a right hand side of an inequality between\n  positive real numbers by a number that is greater than one.\\<close>\n",
        "assumes": "assumes \"b \\<in> \\<real>\\<^sub>+\" and \"a\\<lsq>b\" and \"\\<one>\\<ls>c\"\n  ",
        "using": [
            "assms",
            "reals_are_ord_ring",
            "Real_ZF_1_2_L10",
            "ring1.OrdRing_ZF_3_L17"
        ],
        "statement": "lemma (in real1) Real_ZF_1_2_L25: \n  assumes \"b \\<in> \\<real>\\<^sub>+\" and \"a\\<lsq>b\" and \"\\<one>\\<ls>c\"\n  shows \"a\\<ls>b\\<cdot>c\"\n  ",
        "proof": "using assms reals_are_ord_ring Real_ZF_1_2_L10 ring1.OrdRing_ZF_3_L17\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1697,
        "informal": " Assuming b is a real number, a is less than b, and c is one, show that the product of a and b multiplied by c is equal to the product of a and b."
    },
    "43": {
        "type": "lemma",
        "text": "text\\<open>Supremum is less or equal than any upper bound. \\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"HasAsupremum(r,A)\" \"\\<forall>a\\<in>A. \\<langle>a,u\\<rangle> \\<in> r\"\n  ",
        "using": [
            "image_singleton_iff",
            "set_sup_not_empty",
            "Order_ZF_4_L4"
        ],
        "statement": "lemma sup_leq_up_bnd: assumes \"antisym(r)\" \"HasAsupremum(r,A)\" \"\\<forall>a\\<in>A. \\<langle>a,u\\<rangle> \\<in> r\"\n  shows \"\\<langle>Supremum(r,A),u\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  let ?U = \"\\<Inter>a\\<in>A. r``{a}\"\n  from assms(3) have  \"\\<forall>a\\<in>A. u \\<in> r``{a}\" using image_singleton_iff by simp\n  with assms(2) have \"u\\<in>?U\" using set_sup_not_empty by auto\n  with assms(1,2) show \"\\<langle>Supremum(r,A),u\\<rangle> \\<in> r\" \n    unfolding HasAsupremum_def Supremum_def using Order_ZF_4_L4 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1296,
        "informal": " Given a binary relation `r` that is antisymmetric and has a supremum `u` for the set `A`, such that every element `a` in `A` is related to `u`, it follows that the supremum `Supremum(r,A)` is also related to `u`."
    },
    "44": {
        "type": "lemma",
        "text": "text\\<open>In the following, we offer another lemma about the closure of a set \n  given a basis for a topology. This lemma is based on \\<open>cl_inter_neigh\\<close> and \\<open>inter_neigh_cl\\<close>. \n  It states that it is only necessary to check the sets of the base, not all the open sets.\\<close>\n",
        "assumes": "assumes \"U {is a base for} Q\" \"Q{is a topology}\" \"A\\<subseteq>\\<Union>Q\"\n  ",
        "using": [
            "topology0_def",
            "topology0.Top_3_L11(1)",
            "base_sets_open",
            "topology0.cl_inter_neigh",
            "IsAbaseFor_def",
            "assms(2,3)",
            "topology0.inter_neigh_cl"
        ],
        "statement": "lemma closure_set_base_topology:\n  assumes \"U {is a base for} Q\" \"Q{is a topology}\" \"A\\<subseteq>\\<Union>Q\"\n  shows \"Closure(A,Q) = {x\\<in>\\<Union>Q. \\<forall>T\\<in>U. x\\<in>T\\<longrightarrow>A\\<inter>T\\<noteq>0}\"\n",
        "proof": "proof\n  {\n    fix x\n    assume A:\"x\\<in>Closure(A,Q)\"\n    with assms(2,3) have B:\"x\\<in>\\<Union>Q\" using topology0_def topology0.Top_3_L11(1)\n      by blast\n    moreover\n    {\n      fix T\n      assume \"T\\<in>U\" \"x\\<in>T\"\n      with assms(1) have \"T\\<in>Q\"\"x\\<in>T\" using base_sets_open by auto\n      with assms(2,3) A have \"A\\<inter>T \\<noteq> 0\" using topology0_def topology0.cl_inter_neigh\n        by auto\n    }\n    hence \"\\<forall>T\\<in>U. x\\<in>T\\<longrightarrow>A\\<inter>T\\<noteq>0\" by auto\n    ultimately have \"x\\<in>{x\\<in>\\<Union>Q. \\<forall>T\\<in>U. x\\<in>T\\<longrightarrow>A\\<inter>T\\<noteq>0}\" by auto\n  }\n  thus \"Closure(A, Q) \\<subseteq>{x\\<in>\\<Union>Q. \\<forall>T\\<in>U. x\\<in>T\\<longrightarrow>A\\<inter>T\\<noteq>0}\"\n    by auto\n  {                     \n    fix x\n    assume AS:\"x\\<in>{x \\<in> \\<Union>Q . \\<forall>T\\<in>U. x \\<in> T \\<longrightarrow> A \\<inter> T \\<noteq> 0}\"\n    hence \"x\\<in>\\<Union>Q\" by blast\n    moreover\n    {\n      fix R\n      assume \"R\\<in>Q\"                     \n      with assms(1) obtain W where RR:\"W\\<subseteq>U\" \"R=\\<Union>W\" using\n        IsAbaseFor_def by auto\n      {\n        assume \"x\\<in>R\"\n        with RR(2) obtain WW where TT:\"WW\\<in>W\"\"x\\<in>WW\" by auto\n        {\n          assume \"R\\<inter>A=0\"\n          with RR(2) TT(1) have \"WW\\<inter>A=0\"  by auto\n           with TT(1) RR(1) have \"WW\\<in>U\" \"WW\\<inter>A=0\" by auto\n          with AS have \"x\\<in>\\<Union>Q-WW\" by auto\n          with TT(2) have \"False\" by auto\n        }\n        hence \"R\\<inter>A\\<noteq>0\" by auto\n      }\n    }\n    hence \"\\<forall>U\\<in>Q. x\\<in>U \\<longrightarrow> U\\<inter>A\\<noteq>0\" by auto\n    ultimately have \"x\\<in>Closure(A,Q)\" using assms(2,3) topology0_def topology0.inter_neigh_cl \n      by auto\n  }\n  then show \"{x \\<in> \\<Union>Q . \\<forall>T\\<in>U. x \\<in> T \\<longrightarrow> A \\<inter> T \\<noteq> 0} \\<subseteq> Closure(A,Q)\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2325,
        "informal": " Given a base U for the topology Q and a set A that is a subset of the union of Q, show that the closure of A in Q is equal to the set of x in the union of Q such that for all T in U, x is in the intersection of A and T and A intersect T is not empty."
    },
    "45": {
        "type": "lemma",
        "text": "text\\<open>Type information related to $\\gamma$.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_2_1_L3B",
            "int_zero_one_are_int",
            "apply_funtype",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L25: \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"\\<delta>(f,m,\\<rm>n) \\<in> \\<int>\"\n  \"\\<delta>(f,n,\\<rm>n) \\<in> \\<int>\"\n  \"(\\<rm>\\<delta>(f,n,\\<rm>n)) \\<in> \\<int>\"\n  \"f`(\\<zero>) \\<in> \\<int>\"\n  \"\\<gamma>(f,m,n)  \\<in> \\<int>\"\n",
        "proof": "proof -\n  from A1 A2 show T1:\n    \"\\<delta>(f,m,\\<rm>n) \\<in> \\<int>\"  \"f`(\\<zero>) \\<in> \\<int>\"\n    using Int_ZF_1_1_L4 Int_ZF_2_1_L3B int_zero_one_are_int apply_funtype\n    by auto\n  from A2 have \"(\\<rm>n) \\<in> \\<int>\"\n    using Int_ZF_1_1_L4 by simp\n  with A1 A2 show \"\\<delta>(f,n,\\<rm>n) \\<in> \\<int>\"\n    using Int_ZF_2_1_L3B by simp\n  then show \"(\\<rm>\\<delta>(f,n,\\<rm>n)) \\<in> \\<int>\"\n    using Int_ZF_1_1_L4 by simp\n  with T1 show \"\\<gamma>(f,m,n)  \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 by simp\nqed \n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 876,
        "informal": " Given a function `f` from integers to integers and integers `m` and `n`, we have:\n- The application of `f` to `m` and the result, `δ(f, m, n)`, is an integer.\n- The application of `f` to `n` and the result are integers.\n- The application of `f` to itself with `n` (i.e., `f(f(n)) = δ(f, n, n)`) is an integer.\n- The value `f` of the function at zero is an integer.\n- The value `γ(f, m, n)` of the 3-ary relation `γ` for the given function and arguments `m` and `n` is an integer."
    },
    "46": {
        "type": "lemma",
        "text": "text\\<open>An identity with three real numbers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "real_mult_commutative",
            "Real_ZF_1_L3",
            "ring0.Ring_ZF_2_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_1_L9: assumes \"a\\<in>\\<real>\"  \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\"\n  shows \"a\\<cdot>(b\\<cdot>c) = a\\<cdot>c\\<cdot>b\"\n  ",
        "proof": "using assms real_mult_commutative Real_ZF_1_L3 ring0.Ring_ZF_2_L4\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1666,
        "informal": " Assuming `a`, `b`, and `c` are real numbers, shows that `a * (b * c) = a * c * b`."
    },
    "47": {
        "type": "lemma",
        "text": "text\\<open>Embedding of $1$ is the identity slope and embedding of zero is a \n  finite range function.\\<close>\n",
        "assumes": "",
        "using": [
            "id_def",
            "Int_ZF_1_1_L4",
            "int_zero_one_are_int",
            "Int_ZF_2_5_L1",
            "int_not_empty",
            "Finite1_L16",
            "AlmostHoms_def",
            "Finite1_L19"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L7: shows \n  \"\\<one>\\<^sup>S = id(\\<int>)\"\n  \"\\<zero>\\<^sup>S \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n",
        "proof": "proof -\n  have \"id(\\<int>) = {\\<langle>x,x\\<rangle>. x\\<in>\\<int>}\"\n    using id_def by blast\n  then show \"\\<one>\\<^sup>S = id(\\<int>)\" using Int_ZF_1_1_L4 by simp\n  have \"{\\<zero>\\<^sup>S`(n). n\\<in>\\<int>} = {\\<zero>\\<cdot>n. n\\<in>\\<int>}\"\n    using int_zero_one_are_int Int_ZF_2_5_L1 by simp\n  also have \"\\<dots> = {\\<zero>}\" using Int_ZF_1_1_L4 int_not_empty\n    by simp\n  finally have \"{\\<zero>\\<^sup>S`(n). n\\<in>\\<int>} = {\\<zero>}\" by simp\n  then have \"{\\<zero>\\<^sup>S`(n). n\\<in>\\<int>} \\<in> Fin(\\<int>)\"\n    using int_zero_one_are_int Finite1_L16 by simp\n  moreover have \"\\<zero>\\<^sup>S: \\<int>\\<rightarrow>\\<int>\" \n    using int_zero_one_are_int Int_ZF_2_5_L1 AlmostHoms_def \n    by simp\n  ultimately show \"\\<zero>\\<^sup>S \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n    using Finite1_L19 by simp  \nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 938,
        "informal": " In the int1 theory, we have:\n\nLemma Int_ZF_2_5_L7: The set S under the one-successor function is identical to the identity function on integers, and S is an element of FinRangeFunctions, which maps integers to integers."
    },
    "48": {
        "type": "lemma",
        "text": "text\\<open>For any integer $m$ the function $k\\mapsto m\\cdot k$ has an infinite limit\n  (or negative of that). This is why we put some properties of these functions \n  here, even though they properly belong to a (yet nonexistent) section on \n  homomorphisms. The next lemma shows that the set $\\{a\\cdot x: x\\in Z\\}$\n  can finite only if $a=0$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\" and A2: \"{a\\<cdot>x. x\\<in>\\<int>} \\<in> Fin(\\<int>)\"\n  ",
        "using": [
            "Int_ZF_1_3_L6C",
            "int_zero_not_one",
            "Int_ZF_1_3_T1",
            "ring1.OrdRing_ZF_3_L6",
            "ring1.OrdRing_ZF_3_L5"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L8: \n  assumes A1: \"a\\<in>\\<int>\" and A2: \"{a\\<cdot>x. x\\<in>\\<int>} \\<in> Fin(\\<int>)\"\n  shows \"a = \\<zero>\"\n",
        "proof": "proof -\n  from A1 have \"a=\\<zero> \\<or> (a \\<lsq> \\<rm>\\<one>) \\<or> (\\<one>\\<lsq>a)\"\n    using Int_ZF_1_3_L6C by simp\n  moreover\n  { assume \"a \\<lsq> \\<rm>\\<one>\"\n    then have \"{a\\<cdot>x. x\\<in>\\<int>} \\<notin> Fin(\\<int>)\"\n      using int_zero_not_one Int_ZF_1_3_T1 ring1.OrdRing_ZF_3_L6\n      by simp\n    with A2 have False by simp }\n  moreover\n  { assume \"\\<one>\\<lsq>a\" \n    then have \"{a\\<cdot>x. x\\<in>\\<int>} \\<notin> Fin(\\<int>)\"\n      using int_zero_not_one Int_ZF_1_3_T1 ring1.OrdRing_ZF_3_L5\n    by simp \n  with A2 have False by simp }\n  ultimately show  \"a = \\<zero>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 837,
        "informal": " Assuming `a` is an element of the integers and the set `{ax | x is an integer}` is a finite set, prove that `a` equals zero."
    },
    "49": {
        "type": "lemma",
        "text": "text\\<open>A really weird corner case - empty set is order isomorphic with itself. \\<close>\n",
        "assumes": "",
        "using": [
            "eqpoll_refl",
            "eqpoll_def",
            "ord_iso_def"
        ],
        "statement": "lemma empty_ord_iso: shows \"ord_iso(0,r,0,R) \\<noteq> 0\"\n",
        "proof": "proof -\n  have \"0 \\<approx> 0\" using eqpoll_refl by simp\n  then obtain f where \"f \\<in> bij(0,0)\"\n    using eqpoll_def by blast\n  then show ?thesis using ord_iso_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/FinOrd_ZF.thy",
        "id": 165,
        "informal": " The statement \"ord_iso(0, r, 0, R) \\<noteq> 0\" in the lemma empty_ord_iso does not have a direct natural language translation, as it involves Isabelle/ZF's built-in relation \"ord_iso\" and quantifiers. However, we can provide a brief explanation of the statement:\n\nThis lemma states that the identity function from the set of natural numbers {0} to itself cannot be an order isomorphism with respect to the usual ordering relation R on natural numbers, if the domains of the identity function are the empty sets {0} in both the domain and codomain. In simpler terms, there is no order isomorphism between the empty set and itself under the usual ordering relation."
    },
    "50": {
        "type": "lemma",
        "text": "text\\<open>If $f^{-1}(m)$ is positive and $n$ is a positive integer, then, \n  then $f^{-1}(m+n)-1$ is positive.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\" and \n  A3: \"f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "PositiveSet_def",
            "Int_ZF_1_5_L7A",
            "Int_ZF_2_4_L2",
            "Int_ZF_2_4_L5",
            "int_zero_one_are_int",
            "Int_ZF_1_1_L4",
            "int_ord_transl_inv",
            "Int_ZF_1_5_L7"
        ],
        "statement": "lemma (in int1) Int_ZF_2_4_L6: \n  assumes A1: \"f \\<in> \\<S>\\<^sub>+\" and A2: \"m\\<in>\\<int>\\<^sub>+\"  \"n\\<in>\\<int>\\<^sub>+\" and \n  A3: \"f\\<inverse>(m)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n  shows \"f\\<inverse>(m\\<ra>n)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \"f\\<inverse>(m)\\<rs>\\<one> \\<lsq>  f\\<inverse>(m\\<ra>n) \\<rs> \\<one>\"\n     using PositiveSet_def Int_ZF_1_5_L7A Int_ZF_2_4_L2 \n       Int_ZF_2_4_L5 int_zero_one_are_int Int_ZF_1_1_L4 \n       int_ord_transl_inv by simp\n  with A3 show \"f\\<inverse>(m\\<ra>n)\\<rs>\\<one> \\<in> \\<int>\\<^sub>+\" using Int_ZF_1_5_L7\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 922,
        "informal": " Given that `f` is an element of the set of functions `S+`, `m` and `n` are natural numbers, and `f(m)` is the inverse of a natural number `one`, it follows that `f(m * n)` is also a natural number."
    },
    "51": {
        "type": "lemma",
        "text": "text\\<open>Our \\<open>\\<real>\\<close> symbol is the real axis on the complex plane.\\<close>\n",
        "assumes": "",
        "using": [
            "ComplexReals_def"
        ],
        "statement": "lemma (in complex0) real_means_real_axis: shows \"\\<real> = ComplexReals(R,A)\"\n  ",
        "proof": "using ComplexReals_def by auto\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 79,
        "informal": " The lemma `real_means_real_axis` in `complex0` asserts that the set of reals is equal to the set of real parts of complex numbers in the given ring `R` and algebra `A`."
    },
    "52": {
        "type": "lemma",
        "text": "text\\<open> Join is idempotent. \\<close>\n",
        "assumes": "assumes \"x\\<in>L\" ",
        "using": [
            "joinLatt",
            "assms",
            "join_val(2)",
            "IsJoinSemilattice_def",
            "IsPartOrder_def",
            "sup_inf_singl(2)"
        ],
        "statement": "lemma (in join_semilatt) join_idempotent: assumes \"x\\<in>L\" shows \"x\\<squnion>x = x\" \n  ",
        "proof": "using joinLatt assms join_val(2) IsJoinSemilattice_def IsPartOrder_def sup_inf_singl(2)\n  by auto\n",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1060,
        "informal": " In the join semilattice, the idempotent property holds: for all x in L, x joined with x equals x."
    },
    "53": {
        "type": "theorem",
        "text": "text\\<open>Every order topology is Hausdorff.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\" \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  ",
        "using": [
            "union_ordtopology[OF",
            "assms(1)",
            "assms(2)]",
            "inter_lray_rray[OF",
            "z(3)",
            "assms(1)]",
            "IntervalX_def",
            "Order_ZF_2_L4[OF",
            "total_is_refl",
            "_",
            "z(3)]",
            "IsLinOrder_def",
            "base_sets_open[OF",
            "Ordtopology_is_a_topology(2)[OF",
            "assms(1)]]",
            "AS"
        ],
        "statement": "theorem order_top_T2:\n  assumes \"IsLinOrder(X,r)\" \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  shows \"(OrdTopology X r){is T\\<^sub>2}\"\n",
        "proof": "proof-\n  {\n    fix x y assume A1:\"x\\<in>\\<Union>(OrdTopology X r)\"\"y\\<in>\\<Union>(OrdTopology X r)\"\"x\\<noteq>y\"\n    then have AS:\"x\\<in>X\"\"y\\<in>X\"\"x\\<noteq>y\" using union_ordtopology[OF assms(1) assms(2)] by auto\n    {\n      assume A2:\"\\<exists>z\\<in>X-{x,y}. (\\<langle>x,y\\<rangle>\\<in>r\\<longrightarrow>\\<langle>x,z\\<rangle>\\<in>r\\<and>\\<langle>z,y\\<rangle>\\<in>r)\\<and>(\\<langle>y,x\\<rangle>\\<in>r\\<longrightarrow>\\<langle>y,z\\<rangle>\\<in>r\\<and>\\<langle>z,x\\<rangle>\\<in>r)\"\n      from AS(1,2) assms(1) have \"\\<langle>x,y\\<rangle>\\<in>r\\<or>\\<langle>y,x\\<rangle>\\<in>r\" unfolding IsLinOrder_def IsTotal_def by auto moreover\n      {\n        assume \"\\<langle>x,y\\<rangle>\\<in>r\"\n        with AS A2 obtain z where z:\"\\<langle>x,z\\<rangle>\\<in>r\"\"\\<langle>z,y\\<rangle>\\<in>r\"\"z\\<in>X\"\"z\\<noteq>x\"\"z\\<noteq>y\" by auto\n        with AS(1,2) have \"x\\<in>LeftRayX(X,r,z)\"\"y\\<in>RightRayX(X,r,z)\" unfolding LeftRayX_def RightRayX_def\n          by auto moreover\n        have \"LeftRayX(X,r,z)\\<inter>RightRayX(X,r,z)=0\" using inter_lray_rray[OF z(3) z(3) assms(1)]\n          unfolding IntervalX_def using Order_ZF_2_L4[OF total_is_refl _ z(3)] assms(1) unfolding IsLinOrder_def\n          by auto moreover\n        have \"LeftRayX(X,r,z)\\<in>(OrdTopology X r)\"\"RightRayX(X,r,z)\\<in>(OrdTopology X r)\"\n          using z(3) base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n        ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n      }\n      moreover\n      {\n        assume \"\\<langle>y,x\\<rangle>\\<in>r\"\n        with AS A2 obtain z where z:\"\\<langle>y,z\\<rangle>\\<in>r\"\"\\<langle>z,x\\<rangle>\\<in>r\"\"z\\<in>X\"\"z\\<noteq>x\"\"z\\<noteq>y\" by auto\n        with AS(1,2) have \"y\\<in>LeftRayX(X,r,z)\"\"x\\<in>RightRayX(X,r,z)\" unfolding LeftRayX_def RightRayX_def\n          by auto moreover\n        have \"LeftRayX(X,r,z)\\<inter>RightRayX(X,r,z)=0\" using inter_lray_rray[OF z(3) z(3) assms(1)]\n          unfolding IntervalX_def using Order_ZF_2_L4[OF total_is_refl _ z(3)] assms(1) unfolding IsLinOrder_def\n          by auto moreover\n        have \"LeftRayX(X,r,z)\\<in>(OrdTopology X r)\"\"RightRayX(X,r,z)\\<in>(OrdTopology X r)\"\n          using z(3) base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] by auto\n        ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n      }\n      ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n    }\n    moreover\n    {\n      assume A2:\"\\<forall>z\\<in>X - {x, y}. (\\<langle>x, y\\<rangle> \\<in> r \\<and> (\\<langle>x, z\\<rangle> \\<notin> r \\<or> \\<langle>z, y\\<rangle> \\<notin> r)) \\<or> (\\<langle>y, x\\<rangle> \\<in> r \\<and> (\\<langle>y, z\\<rangle> \\<notin> r \\<or> \\<langle>z, x\\<rangle> \\<notin> r))\"\n      from AS(1,2) assms(1) have disj:\"\\<langle>x,y\\<rangle>\\<in>r\\<or>\\<langle>y,x\\<rangle>\\<in>r\" unfolding IsLinOrder_def IsTotal_def by auto moreover\n      {\n        assume TT:\"\\<langle>x,y\\<rangle>\\<in>r\"\n        with AS assms(1) have T:\"\\<langle>y,x\\<rangle>\\<notin>r\" unfolding IsLinOrder_def antisym_def by auto\n        from TT AS(1-3) have \"x\\<in>LeftRayX(X,r,y)\"\"y\\<in>RightRayX(X,r,x)\" unfolding LeftRayX_def RightRayX_def\n          by auto moreover\n        {\n          fix z assume \"z\\<in>LeftRayX(X,r,y)\\<inter>RightRayX(X,r,x)\"\n          then have \"\\<langle>z,y\\<rangle>\\<in>r\"\"\\<langle>x,z\\<rangle>\\<in>r\"\"z\\<in>X-{x,y}\" unfolding RightRayX_def LeftRayX_def by auto\n          with A2 T have \"False\" by auto\n        }\n        then have \"LeftRayX(X,r,y)\\<inter>RightRayX(X,r,x)=0\" by auto moreover\n        have \"LeftRayX(X,r,y)\\<in>(OrdTopology X r)\"\"RightRayX(X,r,x)\\<in>(OrdTopology X r)\"\n          using base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] AS by auto\n        ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n      }\n      moreover\n      {\n        assume TT:\"\\<langle>y,x\\<rangle>\\<in>r\"\n        with AS assms(1) have T:\"\\<langle>x,y\\<rangle>\\<notin>r\" unfolding IsLinOrder_def antisym_def by auto\n        from TT AS(1-3) have \"y\\<in>LeftRayX(X,r,x)\"\"x\\<in>RightRayX(X,r,y)\" unfolding LeftRayX_def RightRayX_def\n          by auto moreover\n        {\n          fix z assume \"z\\<in>LeftRayX(X,r,x)\\<inter>RightRayX(X,r,y)\"\n          then have \"\\<langle>z,x\\<rangle>\\<in>r\"\"\\<langle>y,z\\<rangle>\\<in>r\"\"z\\<in>X-{x,y}\" unfolding RightRayX_def LeftRayX_def by auto\n          with A2 T have \"False\" by auto\n        }\n        then have \"LeftRayX(X,r,x)\\<inter>RightRayX(X,r,y)=0\" by auto moreover\n        have \"LeftRayX(X,r,x)\\<in>(OrdTopology X r)\"\"RightRayX(X,r,y)\\<in>(OrdTopology X r)\"\n          using base_sets_open[OF Ordtopology_is_a_topology(2)[OF assms(1)]] AS by auto\n        ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n      }\n      ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n    }\n    ultimately have \"\\<exists>U\\<in>(OrdTopology X r). \\<exists>V\\<in>(OrdTopology X r). x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\" by auto\n  }\n  then show ?thesis unfolding isT2_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2071,
        "informal": " Assuming that X is a lined order with no two identical elements, the order topology r over X satisfies the T2 (or separatedness) property."
    },
    "54": {
        "type": "lemma",
        "text": "text\\<open>A sufficient condition for the supremum to be in the space.\\<close>\n",
        "assumes": "assumes \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n  ",
        "using": [
            "set_sup_not_empty",
            "HasAsupremum_def",
            "Order_ZF_4_L4",
            "Order_ZF_5_L1"
        ],
        "statement": "lemma sup_in_space: \n  assumes \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"HasAminimum(r,\\<Inter>a\\<in>A. r``{a})\"\n  shows \"Supremum(r,A) \\<in> X\" and \"\\<forall>x\\<in>A. \\<langle>x,Supremum(r,A)\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from assms(3) have \"A\\<noteq>0\" using set_sup_not_empty unfolding HasAsupremum_def by simp\n  then obtain a where \"a\\<in>A\" by auto\n  with assms(1,2,3) show \"Supremum(r,A) \\<in> X\" unfolding Supremum_def \n    using Order_ZF_4_L4 Order_ZF_5_L1 by blast\n  from assms(2,3) show \"\\<forall>x\\<in>A. \\<langle>x,Supremum(r,A)\\<rangle> \\<in> r\" unfolding Supremum_def\n    using Order_ZF_4_L4 by blast\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1307,
        "informal": " If r is a relation that is a subset of X times X, is antisymmetric, and has a minimum in the intersection of its domain A, then the supremum of r with respect to A is an element in X, and for every x in A, the ordered pair of x and the supremum is in r."
    },
    "55": {
        "type": "definition",
        "text": "text\\<open>Since a partition is a base of a topology, and this topology\nis uniquely determined; we can built it. In the definition\nwe have to make sure that we have a partition.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  PartitionTopology (\"PTopology _ _\" 50) where\n  \"(U {is a partition of} X) \\<Longrightarrow> PTopology X U \\<equiv> TopologyBase U\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2335,
        "informal": " A relation `PTopology` of type \"partition of X -> Prop\" is defined as an equivalence relation over partitions of a set X, such that a given partition U of X implies that `PTopology` of U is equivalent to the topology base of U."
    },
    "56": {
        "type": "lemma",
        "text": "text\\<open>For any real numbers there is an integer whose real version is\n  greater or equal.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"\n  ",
        "using": [
            "Real_ZF_1_1_L3A",
            "int1.Int_ZF_2_5_L2",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def",
            "SlopeEquivalenceRel_def",
            "PositiveIntegers_def",
            "PositiveSlopes_def",
            "Real_ZF_1_1_L5A",
            "Real_ZF_1_2_L12"
        ],
        "statement": "lemma (in real1) Real_ZF_1_4_L2: assumes A1: \"a\\<in>\\<real>\"\n  shows \"\\<exists>m\\<in>int. a \\<lsq> m\\<^sup>R\"\n",
        "proof": "proof -\n  from A1 obtain f where I: \"f\\<in>\\<S>\" and II: \"a = [f]\"\n    using Real_ZF_1_1_L3A by auto\n  then have \"\\<exists>m\\<in>int. \\<exists>g\\<in>\\<S>.\n    {\\<langle>n,m\\<zmu>n\\<rangle> . n \\<in> int} \\<sim> g \\<and> (f\\<sim>g \\<or> (g \\<fp> (\\<fm>f)) \\<in> \\<S>\\<^sub>+)\"\n    using int1.Int_ZF_2_5_L2 Slopes_def SlopeOp1_def \n      BoundedIntMaps_def SlopeEquivalenceRel_def \n      PositiveIntegers_def PositiveSlopes_def\n    by simp\n  then obtain m g where III: \"m\\<in>int\" and IV: \"g\\<in>\\<S>\" and\n   \"{\\<langle>n,m\\<zmu>n\\<rangle> . n \\<in> int} \\<sim> g \\<and> (f\\<sim>g \\<or> (g \\<fp> (\\<fm>f)) \\<in> \\<S>\\<^sub>+)\"\n    by auto\n  then have \"m\\<^sup>R = [g]\" and \"f \\<sim> g \\<or> (g \\<fp> (\\<fm>f)) \\<in> \\<S>\\<^sub>+\"\n    using Real_ZF_1_1_L5A by auto\n  with I II IV have \"a \\<lsq> m\\<^sup>R\" using Real_ZF_1_2_L12\n    by simp\n  with III show \"\\<exists>m\\<in>int. a \\<lsq> m\\<^sup>R\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1724,
        "informal": " Assuming `a` is a real number, there exists an integer `m` such that `a` is less than `m`."
    },
    "57": {
        "type": "lemma",
        "text": "text\\<open>The union of the product collection of collections $S,T$ is the \n  cartesian product of $\\bigcup S$ and  $\\bigcup T$.\\<close>\n",
        "assumes": "",
        "using": [
            "ProductCollection_def"
        ],
        "statement": "lemma ZF1_1_L6: shows \"\\<Union> ProductCollection(S,T) = \\<Union>S \\<times> \\<Union>T\"\n  ",
        "proof": "using ProductCollection_def by auto\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2513,
        "informal": " The set of all pairs, where the first element is from set S and the second element is from set T (i.e, the cartesian product of S and T), is equal to the set of all elements that are in set S or in set T (i.e, the union of sets S and T)."
    },
    "58": {
        "type": "lemma",
        "text": "text\\<open>Multiplying different group elements by the same factor results\n  in different group elements.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and A2: \"a\\<noteq>b\"\n  ",
        "using": [
            "inv_cancel_two"
        ],
        "statement": "lemma (in group0) group0_2_L19: \n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and A2: \"a\\<noteq>b\"\n  shows \"a\\<cdot>c \\<noteq> b\\<cdot>c\" and \"c\\<cdot>a \\<noteq> c\\<cdot>b\"\n",
        "proof": "proof -\n  { assume \"a\\<cdot>c = b\\<cdot>c \\<or> c\\<cdot>a =c\\<cdot>b\"\n    then have \"a\\<cdot>c\\<cdot>c\\<inverse> = b\\<cdot>c\\<cdot>c\\<inverse> \\<or> c\\<inverse>\\<cdot>(c\\<cdot>a) = c\\<inverse>\\<cdot>(c\\<cdot>b)\"\n      by auto\n    with A1 A2 have False using inv_cancel_two by simp\n  } then show \"a\\<cdot>c \\<noteq> b\\<cdot>c\" and \"c\\<cdot>a \\<noteq> c\\<cdot>b\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 458,
        "informal": " In the group0 theory, if elements a, b, and c are in the group, and a is not equal to b, then a * c is not equal to b * c, and conversely, c * a is not equal to c * b."
    },
    "59": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is just to see the definition of the nonnegative set\n  in our notation.\\<close>\n",
        "assumes": "",
        "using": [
            "ordGroupAssum",
            "IsAnOrdGroup_def",
            "Nonnegative_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L2: \n  shows \"g\\<in>G\\<^sup>+ \\<longleftrightarrow> \\<one>\\<lsq>g\"\n  ",
        "proof": "using ordGroupAssum IsAnOrdGroup_def Nonnegative_def \n  by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1356,
        "informal": " In the group \"group3\", if g is an element of G, then g raises to the power of plus (i.e., g concatenated with itself) is ordered with the identity element one. In other words, g \\* g is either smaller than or equal to one, or equal to g."
    },
    "60": {
        "type": "theorem",
        "text": "text\\<open>Function lifted to a function space results in  function space \n  operator.\\<close>\n",
        "assumes": "assumes \"f : Y\\<times>Y\\<rightarrow>Y\"\n  and \"F = f {lifted to function space over} X\"\n  ",
        "using": [
            "assms",
            "Lift2FcnSpce_def",
            "func_ZF_1_L1",
            "ZF_fun_from_total"
        ],
        "statement": "theorem func_ZF_1_L3: \n  assumes \"f : Y\\<times>Y\\<rightarrow>Y\"\n  and \"F = f {lifted to function space over} X\"\n  shows \"F : (X\\<rightarrow>range(f))\\<times>(X\\<rightarrow>range(f))\\<rightarrow>(X\\<rightarrow>range(f))\"\n  ",
        "proof": "using assms Lift2FcnSpce_def func_ZF_1_L1 ZF_fun_from_total \n  by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2673,
        "informal": " Assuming function `f` from `Y` to `Y` and `F` being its functional lift to the product space over `X`, show that `F` is a function from `(X` to `range(f))` times `(X` to `range(f))` to `(X` to `range(f))`."
    },
    "61": {
        "type": "lemma",
        "text": "text\\<open> An identity similar to \\<open>rel_square_starr\\<close> but with \\<open>Star\\<close> on the left side of the Cartesian \n  product: \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "lemma rel_square_starl: shows \n  \"(\\<Union>{U\\<times>U. U\\<in>P}) O (\\<Union>{U\\<times>U. U\\<in>P}) = \\<Union>{Star(U,P)\\<times>U. U\\<in>P}\"\n  unfolding Star_def by blast\n",
        "proof": "",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2485,
        "informal": " The lemma states that the union of all pairs of elements in a set P, where each element is in P, is equal to the union of all stars (i.e., successors in the reflexive transitive closure) of each element in P, together with that element itself, also being in P. \n\nMore briefly, if U is a set of elements in P, then the set obtained by taking the union of all pairs of elements in U and the union of all stars of elements in U, and restricting both sets to elements in P, is equal to the union of all stars of elements in U along with those elements themselves in P."
    },
    "62": {
        "type": "definition",
        "text": "text\\<open>This defines the set of positive integers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"PositiveIntegers \\<equiv> PositiveSet(int,IntegerAddition,IntegerOrder)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 944,
        "informal": " The set of PositiveIntegers is defined as the PositiveSet in Isabelle/ZF, where int is the sort of integers, IntegerAddition is the given addition function on integers, and IntegerOrder is the given ordering on integers."
    },
    "63": {
        "type": "lemma",
        "text": "text\\<open>The next lemma interprets the order definition one way.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\" \"n\\<in>\\<int>\" and A2: \"m $\\<le> n\"\n  ",
        "using": [
            "IntegerOrder_def"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L1: \n  assumes A1: \"m\\<in>\\<int>\" \"n\\<in>\\<int>\" and A2: \"m $\\<le> n\"\n  shows \"m \\<lsq> n\"\n",
        "proof": "proof -\n  from A1 A2 have \"\\<langle> m,n\\<rangle> \\<in> {x\\<in>\\<int>\\<times>\\<int>. fst(x) $\\<le> snd(x)}\" \n    by simp\n  then show ?thesis using IntegerOrder_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 966,
        "informal": " If integers m and n belong to the set of integers and m is less than or equal to n, then m is less than n."
    },
    "64": {
        "type": "theorem",
        "text": "text\\<open>For commutative operations taking the product of a sequence \n  is distributive with respect to the operation.\n  This version will probably not be used in applications,\n  it is formulated in a way that is easier to prove by induction.\n  For a more convenient formulation see \\<open>prod_comm_distrib\\<close>.\n  The proof by induction on the length of the sequence.\\<close>\n",
        "assumes": "assumes A1: \"f {is commutative on} G\" and A2: \"n\\<in>nat\" \n  ",
        "using": [
            "prod_of_1elem",
            "Fold1_def",
            "shorter_seq",
            "prod_distr_ind_step",
            "init_props",
            "prod_type",
            "apply_funtype",
            "rearr4elems"
        ],
        "statement": "theorem (in semigr0) prod_comm_distr: \n  assumes A1: \"f {is commutative on} G\" and A2: \"n\\<in>nat\" \n  shows \"\\<forall> a b c. \n  (a : succ(n)\\<rightarrow>G \\<and> b : succ(n)\\<rightarrow>G \\<and> c : succ(n)\\<rightarrow>G \\<and> \n  (\\<forall>j\\<in>succ(n). c`(j) = a`(j) \\<cdot> b`(j))) \\<longrightarrow>\n  (\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\"\n",
        "proof": "proof -\n  note A2\n  moreover have \"\\<forall> a b c. \n    (a : succ(0)\\<rightarrow>G \\<and> b : succ(0)\\<rightarrow>G \\<and> c : succ(0)\\<rightarrow>G \\<and> \n    (\\<forall>j\\<in>succ(0). c`(j) = a`(j) \\<cdot> b`(j))) \\<longrightarrow>\n    (\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\"\n  proof -\n    { fix a b c \n      assume \"a : succ(0)\\<rightarrow>G \\<and> b : succ(0)\\<rightarrow>G \\<and> c : succ(0)\\<rightarrow>G \\<and> \n\t(\\<forall>j\\<in>succ(0). c`(j) = a`(j) \\<cdot> b`(j))\"\n      then have\n\tI: \"a : 1\\<rightarrow>G\"  \"b : 1\\<rightarrow>G\"  \"c : 1\\<rightarrow>G\" and\n\tII: \"c`(0) = a`(0) \\<cdot> b`(0)\" by auto\n      from I have\n\t\"(\\<Prod> a) = a`(0)\" and \"(\\<Prod> b) = b`(0)\" and \"(\\<Prod> c) = c`(0)\"\n\tusing prod_of_1elem by auto\n      with II have \"(\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\" by simp\n    } then show ?thesis using Fold1_def by simp\n  qed\n  moreover have \"\\<forall>k \\<in> nat. \n    (\\<forall> a b c. \n    (a : succ(k)\\<rightarrow>G \\<and> b : succ(k)\\<rightarrow>G \\<and> c : succ(k)\\<rightarrow>G \\<and> \n    (\\<forall>j\\<in>succ(k). c`(j) = a`(j) \\<cdot> b`(j))) \\<longrightarrow>\n    (\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)) \\<longrightarrow>\n    (\\<forall> a b c. \n    (a : succ(succ(k))\\<rightarrow>G \\<and> b : succ(succ(k))\\<rightarrow>G \\<and> c : succ(succ(k))\\<rightarrow>G \\<and> \n    (\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j))) \\<longrightarrow>\n    (\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b))\"\n  proof\n    fix k assume \"k \\<in> nat\"\n    show \"(\\<forall>a b c.\n      a \\<in> succ(k) \\<rightarrow> G \\<and>\n      b \\<in> succ(k) \\<rightarrow> G \\<and> c \\<in> succ(k) \\<rightarrow> G \\<and> \n      (\\<forall>j\\<in>succ(k). c`(j) = a`(j) \\<cdot> b`(j)) \\<longrightarrow>\n      (\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)) \\<longrightarrow>\n      (\\<forall>a b c.\n      a \\<in> succ(succ(k)) \\<rightarrow> G \\<and>\n      b \\<in> succ(succ(k)) \\<rightarrow> G \\<and>\n      c \\<in> succ(succ(k)) \\<rightarrow> G \\<and> \n      (\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j)) \\<longrightarrow>\n      (\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b))\"\n    proof\n      assume A3: \"\\<forall>a b c.\n\ta \\<in> succ(k) \\<rightarrow> G \\<and>\n\tb \\<in> succ(k) \\<rightarrow> G \\<and> c \\<in> succ(k) \\<rightarrow> G \\<and> \n\t(\\<forall>j\\<in>succ(k). c`(j) = a`(j) \\<cdot> b`(j)) \\<longrightarrow>\n\t(\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\"\n      show \"\\<forall>a b c.\n\ta \\<in> succ(succ(k)) \\<rightarrow> G \\<and>\n\tb \\<in> succ(succ(k)) \\<rightarrow> G \\<and>\n\tc \\<in> succ(succ(k)) \\<rightarrow> G \\<and> \n\t(\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j)) \\<longrightarrow>\n\t(\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\"\n      proof -\n\t{ fix a b c \n\t  assume \n\t    \"a \\<in> succ(succ(k)) \\<rightarrow> G \\<and>\n\t    b \\<in> succ(succ(k)) \\<rightarrow> G \\<and>\n\t    c \\<in> succ(succ(k)) \\<rightarrow> G \\<and> \n\t    (\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j))\"\n\t  with \\<open>k \\<in> nat\\<close> have I:\n\t    \"a : succ(succ(k)) \\<rightarrow> G\"\n\t    \"b : succ(succ(k)) \\<rightarrow> G\"\n\t    \"c : succ(succ(k)) \\<rightarrow> G\"\n\t    and II: \"\\<forall>j\\<in>succ(succ(k)). c`(j) = a`(j) \\<cdot> b`(j)\"\n\t    by auto   \n\t  let ?x = \"Init(a)\"\n          let ?y = \"Init(b)\"\n          let ?z = \"Init(c)\"\n\t  from \\<open>k \\<in> nat\\<close> I have III:\n\t    \"(\\<Prod> a) = (\\<Prod> ?x) \\<cdot> a`(succ(k))\"\n\t    \"(\\<Prod> b) = (\\<Prod> ?y) \\<cdot> b`(succ(k))\" and\n\t    IV: \"(\\<Prod> c) = (\\<Prod> ?z) \\<cdot> c`(succ(k))\"\n\t    using  shorter_seq by auto\n\t  moreover\n\t  from  \\<open>k \\<in> nat\\<close> I II have\n\t    \"?x : succ(k) \\<rightarrow> G\"\n\t    \"?y : succ(k) \\<rightarrow> G\"\n\t    \"?z : succ(k) \\<rightarrow> G\" and\n\t    \"\\<forall>j\\<in>succ(k). ?z`(j) = ?x`(j) \\<cdot> ?y`(j)\"\n\t    using prod_distr_ind_step by auto\n\t  with A3 II IV have\n\t    \"(\\<Prod> c) = (\\<Prod> ?x)\\<cdot>(\\<Prod> ?y)\\<cdot>(a`(succ(k)) \\<cdot> b`(succ(k)))\"\n\t    by simp\n\t  moreover from A1 \\<open>k \\<in> nat\\<close> I III have\n\t    \"(\\<Prod> ?x)\\<cdot>(\\<Prod> ?y)\\<cdot>(a`(succ(k)) \\<cdot> b`(succ(k)))=\n\t    (\\<Prod> a) \\<cdot> (\\<Prod> b)\" \n\t    using init_props prod_type apply_funtype \n\t      rearr4elems by simp\n\t  ultimately have \"(\\<Prod> c) = (\\<Prod> a) \\<cdot> (\\<Prod> b)\"\n\t    by simp\n\t} thus ?thesis by auto\n      qed\n    qed\n  qed\n  ultimately show ?thesis by (rule ind_on_nat)\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1901,
        "informal": " If function f is commutative over set G and n is a natural number, then for all a, b, and c in the successor of n, if the product of c and b equals the product of a and b for all elements in the successor of n, then the product of c, a, and b are commutative and equal to the product of a, b, and the product of c."
    },
    "65": {
        "type": "definition",
        "text": "text\\<open>The next definition describes how we construct an order relation\n  from the prescribed set of positive elements.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"OrderFromPosSet(G,P,H) \\<equiv> \n  {p \\<in> G\\<times>G. fst(p) = snd(p) \\<or> P`\\<langle>GroupInv(G,P)`(fst(p)),snd(p)\\<rangle> \\<in> H }\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1497,
        "informal": " The binary relation OrderFromPosSet(G, P, H) holds between two elements p in the cartesian product G x G if:\n\n1. p is an element of G x G.\n2. Either p's first component is equal to its second component, or\n3. The inverse of the group element P using the group G, and the pair (p's first component, p's second component), belong to the set H."
    },
    "66": {
        "type": "lemma",
        "text": "text\\<open>Essential condition to show that every subgroup of an abelian group \n  is normal.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\" \n  and A2: \"IsAsubgroup(H,P)\"\n  and A3: \"g\\<in>G\"  \"h\\<in>H\" \n  ",
        "using": [
            "group0_3_L2",
            "inverse_in_group",
            "group0_4_L4A",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L5:\n  assumes A1: \"P {is commutative on} G\" \n  and A2: \"IsAsubgroup(H,P)\"\n  and A3: \"g\\<in>G\"  \"h\\<in>H\" \n  shows \"g\\<cdot>h\\<cdot>g\\<inverse> \\<in> H\"\n",
        "proof": "proof -\n  from A2 A3 have T1:\"h\\<in>G\" \"g\\<inverse> \\<in> G\" \n    using group0_3_L2 inverse_in_group by auto\n  with A3 A1 have \"g\\<cdot>h\\<cdot>g\\<inverse> = g\\<inverse>\\<cdot>g\\<cdot>h\"\n    using group0_4_L4A by simp\n  with A3 T1 show ?thesis using\n    group0_2_L6 group0_2_L2\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 557,
        "informal": " In group zero, if P is a commutative subgroup of G and g is an element of G and h is an element of the subgroup H, then g * h * g^-1 is also an element of H."
    },
    "67": {
        "type": "lemma",
        "text": "text\\<open>If an image of a set defined by separation \n  by a function with infinite positive limit \n  is bounded above, then the set itself is bounded above.\\<close>\n",
        "assumes": "assumes A1: \"X\\<noteq>0\" and A2: \"f: \\<int>\\<rightarrow>\\<int>\" and \n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and\n  A4: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int>  \\<and> f`(b(x)) \\<lsq> U\"\n  ",
        "using": [
            "int_not_trivial",
            "Int_ZF_2_T1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_6_L2: assumes A1: \"X\\<noteq>0\" and A2: \"f: \\<int>\\<rightarrow>\\<int>\" and \n  A3: \"\\<forall>a\\<in>\\<int>.\\<exists>b\\<in>\\<int>\\<^sub>+.\\<forall>x. b\\<lsq>x \\<longrightarrow> a \\<lsq> f`(x)\" and\n  A4: \"\\<forall>x\\<in>X. b(x) \\<in> \\<int>  \\<and> f`(b(x)) \\<lsq> U\"\n  shows \"\\<exists>u.\\<forall>x\\<in>X. b(x) \\<lsq> u\"\n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?P = \"IntegerAddition\"\n  let ?r = \"IntegerOrder\"\n  from A1 A2 A3 A4 have \n    \"group3(?G, ?P, ?r)\" \n    \"?r {is total on} ?G\" \n    \"?G \\<noteq> {TheNeutralElement(?G, ?P)}\"\n    \"X\\<noteq>0\"  \"f: ?G\\<rightarrow>?G\"\n    \"\\<forall>a\\<in>?G. \\<exists>b\\<in>PositiveSet(?G, ?P, ?r). \\<forall>y. \\<langle>b, y\\<rangle> \\<in> ?r \\<longrightarrow> \\<langle>a, f`(y)\\<rangle> \\<in> ?r\"\n    \"\\<forall>x\\<in>X. b(x) \\<in> ?G \\<and> \\<langle>f`(b(x)), U\\<rangle> \\<in> ?r\"\n    using int_not_trivial Int_ZF_2_T1 by auto\n  then have \"\\<exists>u. \\<forall>x\\<in>X. \\<langle>b(x), u\\<rangle> \\<in> ?r\" by (rule group3.OrderedGroup_ZF_7_L2)\n  thus ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 831,
        "informal": " Given an non-zero set X, a function f from integers to integers, and for all a in integers, there exists a b such that for all x, if b x is preceded by x then a is preceded by f(x), and for all x in X, b(x) is an integer and f(b(x)) is a predecessor of some set U. Then, there exists a number u such that for all x in X, b(x) is a predecessor of u.\n\nIn simpler terms, if X is a non-empty set of integers, There is a function f that preserves the predecessor relation between any pair of integers, and for each integer in X, b(x) is an integer that maps to a predecessor of some set U, then there exists a number u such that all integers in X have b(x) as a predecessor of u."
    },
    "68": {
        "type": "definition",
        "text": "text\\<open>The \\<open>PositiveSet(L,A,r)\\<close> is a set similar to  \\<open>Nonnegative(L,A,r)\\<close>, but without the neutral element.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"PositiveSet(L,A,r) \\<equiv> \n  {x\\<in>L. \\<langle> TheNeutralElement(L,A),x\\<rangle> \\<in> r \\<and> TheNeutralElement(L,A)\\<noteq> x}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/OrderedLoop_ZF.thy",
        "id": 1510,
        "informal": " A set L with respect to the binary relation r and element A in L is positive if and only if the neutral element of A in L is in r and is different from A itself."
    },
    "69": {
        "type": "lemma",
        "text": "text\\<open>Closure of a subset of the carrier is a subset of the carrier and closure\n  of the complement is the complement of the interior.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<Union>T\" \n  ",
        "using": [
            "Top_3_L1",
            "Closure_def",
            "ClosedCovers_def",
            "Top_2_L1",
            "top_closure_mono",
            "Top_2_L2",
            "Top_3_L9",
            "Top_3_L8",
            "cl_contains_set",
            "cl_is_closed",
            "IsClosed_def",
            "Top_2_L5"
        ],
        "statement": "lemma (in topology0) Top_3_L11: assumes A1: \"A \\<subseteq> \\<Union>T\" \n  shows \n  \"cl(A) \\<subseteq> \\<Union>T\"\n  \"cl(\\<Union>T - A) = \\<Union>T - int(A)\"\n",
        "proof": "proof -\n  from A1 show \"cl(A) \\<subseteq> \\<Union>T\" using Top_3_L1 Closure_def ClosedCovers_def\n    by auto\n  from A1 have \"\\<Union>T - A \\<subseteq> \\<Union>T - int(A)\" using Top_2_L1\n    by auto\n  moreover have I: \"\\<Union>T - int(A) \\<subseteq> \\<Union>T\"   \"\\<Union>T - A \\<subseteq> \\<Union>T\" by auto\n  ultimately have \"cl(\\<Union>T - A) \\<subseteq> cl(\\<Union>T - int(A))\"\n    using top_closure_mono by simp\n  moreover\n  from I have \"(\\<Union>T - int(A)) {is closed in} T\"\n    using Top_2_L2 Top_3_L9 by simp\n  with I have \"cl((\\<Union>T) - int(A)) = \\<Union>T - int(A)\"\n    using Top_3_L8 by simp\n  ultimately have \"cl(\\<Union>T - A) \\<subseteq> \\<Union>T - int(A)\" by simp\n  moreover\n  from I have \"\\<Union>T - A \\<subseteq> cl(\\<Union>T - A)\" using cl_contains_set by simp\n  hence \"\\<Union>T - cl(\\<Union>T - A) \\<subseteq> A\" and \"\\<Union>T - A \\<subseteq> \\<Union>T\"  by auto\n  then have \"\\<Union>T - cl(\\<Union>T - A) \\<subseteq> int(A)\"\n    using cl_is_closed IsClosed_def Top_2_L5 by simp\n  hence \"\\<Union>T - int(A) \\<subseteq>  cl(\\<Union>T - A)\" by auto\n  ultimately show \"cl(\\<Union>T - A) = \\<Union>T - int(A)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2020,
        "informal": " Assuming A is a subset of the union T in the context of topology0, the closed set of A is also a subset of T, and the difference between T and A equals the interior of A removed from T."
    },
    "70": {
        "type": "theorem",
        "text": "text\\<open>The cocountable topology on $\\mathbb{N}^+$ or \\<open>csucc(nat)\\<close> is also $T_1$,\nperfect and luzin; but defined on a set not in the spectrum.\\<close>\n",
        "assumes": "",
        "using": [
            "lt_csucc[OF",
            "Ord_nat]",
            "union_cocardinal",
            "noE",
            "Cocountable_def",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "lesspoll_imp_lepoll",
            "Card_less_csucc_eq_le[OF",
            "Card_nat]",
            "less_less_imp_un_less[OF",
            "_",
            "InfCard_csucc[OF",
            "InfCard_nat]]",
            "xn"
        ],
        "statement": "theorem cocountable_csucc_nat_perfect:\n  shows \"(CoCountable csucc(nat)){is perfect}\"\n",
        "proof": "proof-\n  have noE:\"csucc(nat)\\<noteq>0\" using lt_csucc[OF Ord_nat] by auto \n  {\n    fix x assume x:\"x\\<in>\\<Union>(CoCountable csucc(nat))\" \"{x}\\<in>(CoCountable csucc(nat))\"\n    then have xn:\"x\\<in>csucc(nat)\" using union_cocardinal noE unfolding Cocountable_def by auto\n    with x(2) have \"csucc(nat)-{x}\\<prec>csucc(nat)\" unfolding Cocountable_def CoCardinal_def by auto\n    moreover have \"Finite({x})\" by auto\n    then have \"{x}\\<prec>nat\" unfolding Finite_def using n_lesspoll_nat eq_lesspoll_trans by auto\n    then have \"{x}\\<lesssim>nat\" using lesspoll_imp_lepoll by auto\n    then have \"{x}\\<prec>csucc(nat)\" using Card_less_csucc_eq_le[OF Card_nat] by auto\n    ultimately have \"(csucc(nat)-{x})\\<union>{x}\\<prec>csucc(nat)\" using less_less_imp_un_less[OF _ _ InfCard_csucc[OF InfCard_nat]] by auto\n    moreover have \"(csucc(nat)-{x})\\<union>{x}=csucc(nat)\" using xn by auto\n    ultimately have \"False\" by auto\n  }\n  then show ?thesis unfolding IsPerf_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2439,
        "informal": " Statement in natural language:\n\nThe set C of natural numbers obtainable by successor operation (csucc) from a countable set c is perfect."
    },
    "71": {
        "type": "lemma",
        "text": "text\\<open>A set defined by a lambda-type expression is a fuction. There is a \n  similar lemma in func.thy, but I had problems with lambda expressions syntax\n  so I could not apply it. This lemma is a workaround for this. Besides, lambda\n  expressions are not readable.\n\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>x\\<in>X. b(x) \\<in> Y\"\n  ",
        "using": [
            "func1_1_L11"
        ],
        "statement": "lemma func1_1_L11A: assumes A1: \"\\<forall>x\\<in>X. b(x) \\<in> Y\"\n  shows \"{\\<langle>x,y\\<rangle> \\<in> X\\<times>Y. b(x) = y} : X\\<rightarrow>Y\"\n",
        "proof": "proof -\n  let ?f = \"{\\<langle> x,y\\<rangle> \\<in> X\\<times>Y. b(x) = y}\"\n  have \"?f \\<subseteq> X\\<times>Y\" by auto\n  moreover have \"\\<forall>x\\<in>X. \\<exists>!y. y\\<in>Y \\<and> \\<langle> x,y\\<rangle> \\<in> ?f\"\n  proof\n    fix x assume A2: \"x\\<in>X\"\n    show \"\\<exists>!y. y\\<in>Y \\<and> \\<langle>x, y\\<rangle> \\<in> {\\<langle>x,y\\<rangle> \\<in> X\\<times>Y . b(x) = y}\"\n    proof\n      from A2 A1 show \n        \"\\<exists>y. y\\<in>Y \\<and> \\<langle>x, y\\<rangle> \\<in> {\\<langle>x,y\\<rangle> \\<in> X\\<times>Y . b(x) = y}\"\n\tby simp\n    next\n      fix y y1\n      assume \"y\\<in>Y \\<and> \\<langle>x, y\\<rangle> \\<in> {\\<langle>x,y\\<rangle> \\<in> X\\<times>Y . b(x) = y}\"\n\tand \"y1\\<in>Y \\<and> \\<langle>x, y1\\<rangle> \\<in> {\\<langle>x,y\\<rangle> \\<in> X\\<times>Y . b(x) = y}\"\n      then show \"y = y1\" by simp\n    qed\n  qed\n  ultimately show \"{\\<langle> x,y\\<rangle> \\<in> X\\<times>Y. b(x) = y} : X\\<rightarrow>Y\" \n    using func1_1_L11 by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2572,
        "informal": " If for all x in X, b(x) is in Y, then the relation {<(x,y)> | x in X and b(x) = y} is a subset of X times Y."
    },
    "72": {
        "type": "lemma",
        "text": "text\\<open>Homomorphism difference commutes with the inverse for almost\n  homomorphisms.\\<close>\n",
        "assumes": "assumes A1:\"s \\<in> AH\" and A2:\"x\\<in>G\\<times>G\"\n  ",
        "using": [
            "HomDiff_def",
            "Group_ZF_3_2_L4B",
            "Group_ZF_3_2_L5",
            "group0_4_L4A"
        ],
        "statement": "lemma (in group1) Group_ZF_3_2_L6:  \n  assumes A1:\"s \\<in> AH\" and A2:\"x\\<in>G\\<times>G\"\n  shows \"\\<delta>(\\<sim>s,x) = (\\<delta>(s,x))\\<inverse>\"\n",
        "proof": "proof -\n  let ?m = \"fst(x)\"\n  let ?n = \"snd(x)\"\n  have \"\\<delta>(\\<sim>s,x) = (\\<sim>s)`(?m\\<cdot>?n)\\<cdot>((\\<sim>s)`(?m)\\<cdot>(\\<sim>s)`(?n))\\<inverse>\"\n    using HomDiff_def by simp\n  from A1 A2 isAbelian show ?thesis\n    using Group_ZF_3_2_L4B HomDiff_def \n      Group_ZF_3_2_L5 group0_4_L4A\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 579,
        "informal": " In the group1 theory, if an element s belongs to the set AH and x is an element in the Cartesian product of two groups G, then the delta operation applied to (s, x) is equal to the inverse of the delta operation applied to (s, x). \n\nOr in simpler terms, if s is an element of AH and x is an element in the product of two groups G, then swapping s and x using the delta operation gives the inverse of the original delta operation application."
    },
    "73": {
        "type": "lemma",
        "text": "text\\<open>In a loop $G$ right and left inverses are functions on $G$. \\<close>\n",
        "assumes": "",
        "using": [
            "neut_props_loop",
            "lrdiv_props(1,4)",
            "ZF1_1_L9",
            "ZF_fun_from_total"
        ],
        "statement": "lemma (in loop0) lr_inv_fun: shows \"LeftInv(G,A):G\\<rightarrow>G\" \"RightInv(G,A):G\\<rightarrow>G\"\n  unfolding LeftInv_def RightInv_def\n  ",
        "proof": "using neut_props_loop lrdiv_props(1,4) ZF1_1_L9 ZF_fun_from_total\n  by auto\n",
        "imports": [
            "IsarMathLib.Quasigroup_ZF"
        ],
        "source": "IsarMathLib/Loop_ZF.thy",
        "id": 1072,
        "informal": " In the context of the \"loop0\" theory, prove that functions G from G to G satisfy the properties of being left-inverse and right-inverse for relation A."
    },
    "74": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open> OrdRing_ZF_3_L9\\<close>: in nontrivial\n  rings adding one to $a$ increases $a$.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"a\\<in>R\"\n  ",
        "using": [
            "assms",
            "ordring_one_is_pos",
            "OrdRing_ZF_3_L9"
        ],
        "statement": "corollary (in ring1) OrdRing_ZF_3_L10: assumes A1: \"\\<zero>\\<noteq>\\<one>\" and A2: \"a\\<in>R\"\n  shows \"a \\<lsq> a\\<ra>\\<one>\"  \"a \\<noteq> a\\<ra>\\<one>\"\n  ",
        "proof": "using assms ordring_one_is_pos OrdRing_ZF_3_L9\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1586,
        "informal": " In the ring1 context, assuming A1: <zero> is not equal to <one> and A2: a is an element of R, we have a < less than > a + 1 and a is not equal to a + 1."
    },
    "75": {
        "type": "lemma",
        "text": "text\\<open>The inverse image is the image of converse. True for relations as well.\\<close>\n",
        "assumes": "",
        "using": [
            "vimage_iff",
            "image_iff",
            "converse_iff"
        ],
        "statement": "lemma vimage_converse: shows \"r-``(A) = converse(r)``(A)\"\n  ",
        "proof": "using vimage_iff image_iff converse_iff by auto\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2554,
        "informal": " The image of a set A under the relation r is equal to the converse of relation r applied to set A."
    },
    "76": {
        "type": "lemma",
        "text": "text\\<open>We can cancel the same element on both sides of an inequality.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and A2: \"a\\<cdot>b \\<lsq> a\\<cdot>c\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L1",
            "group0.inverse_in_group",
            "IsAnOrdGroup_def",
            "group0.inv_cancel_two"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AE:\n  assumes A1: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\" and A2: \"a\\<cdot>b \\<lsq> a\\<cdot>c\"\n  shows \"b\\<lsq>c\"\n",
        "proof": "proof -\n  from ordGroupAssum A1 A2 have \"a\\<inverse>\\<cdot>(a\\<cdot>b) \\<lsq> a\\<inverse>\\<cdot>(a\\<cdot>c)\"\n    using OrderedGroup_ZF_1_L1 group0.inverse_in_group IsAnOrdGroup_def \n    by simp\n  with A1 show \"b\\<lsq>c\" \n    using OrderedGroup_ZF_1_L1 group0.inv_cancel_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1381,
        "informal": " In the group G, if a, b, and c are elements, and a * b is less than a * c, then b is less than c."
    },
    "77": {
        "type": "lemma",
        "text": "text\\<open>The positive set is contained in the nonnegative set, hence in the group.\\<close>\n",
        "assumes": "",
        "using": [
            "OrderedGroup_ZF_1_L2A",
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_1_L4E"
        ],
        "statement": "lemma (in group3) pos_set_in_gr: shows \"G\\<^sub>+ \\<subseteq> G\\<^sup>+\" and \"G\\<^sub>+ \\<subseteq> G\"\n  ",
        "proof": "using OrderedGroup_ZF_1_L2A OrderedGroup_ZF_1_L2 OrderedGroup_ZF_1_L4E\n  by auto  \n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1374,
        "informal": " In the group3 theory, it holds that the positive semigroup G+ is a subset of both the extended group G+, and the original group G."
    },
    "78": {
        "type": "theorem",
        "text": "text\\<open>A better looking reformulation of \\<open>prod_bisect\\<close>.\n\\<close>\n",
        "assumes": "assumes\n  A1: \"f {is commutative on} G\"  and \n  A2: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and\n  A3: \"B \\<in> FinPow(X)\" \"B \\<noteq> 0\" and\n  A4: \"A \\<inter> B = 0\"\n  ",
        "using": [
            "is_bisec",
            "a_is_fun",
            "union_finpow",
            "prod_bisect"
        ],
        "statement": "theorem (in semigr1) prod_disjoint: assumes\n  A1: \"f {is commutative on} G\"  and \n  A2: \"A \\<in> FinPow(X)\" \"A \\<noteq> 0\" and\n  A3: \"B \\<in> FinPow(X)\" \"B \\<noteq> 0\" and\n  A4: \"A \\<inter> B = 0\"\n  shows \"\\<pr>(A\\<union>B,a) = (\\<pr>(A,a))\\<cdot>(\\<pr>(B,a))\"\n",
        "proof": "proof -\n  from A2 A3 A4 have \"\\<langle>A,B\\<rangle> \\<in> Bisections(A\\<union>B)\"\n    using is_bisec by simp\n  with A1 A2 A3 show ?thesis\n    using a_is_fun union_finpow prod_bisect by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1904,
        "informal": " Given a commutative function `f` over a group `G`, and sets `A` and `B` in the power set of a set `X`, neither equal to the empty set, and `A` intersects `B` is empty, then the product of `f` applied to `A` and `B` at an element `a` is equal to the sum of `f` applied to `A` and `B` at `a`."
    },
    "79": {
        "type": "lemma",
        "text": "text\\<open>The function generating rows of the Pascal's triangle is indeed a function that maps\n  nonempty lists of natural numbers into nonempty lists of natural numbers. \\<close>\n",
        "assumes": "",
        "using": [
            "func1_1_L1",
            "ZF_fun_from_total",
            "GenBinom_def"
        ],
        "statement": "lemma gen_binom_fun: shows \"GenBinom: NELists(nat) \\<rightarrow> NELists(nat)\"\n",
        "proof": "proof -\n  { fix r assume \"r \\<in> NELists(nat)\"\n    then obtain n where \"n\\<in>nat\" and \"r:succ(n)\\<rightarrow>nat\" \n      unfolding NELists_def by auto\n    then have \"domain(r) = succ(n)\" using func1_1_L1 by simp\n    let ?r\\<^sub>1 = \"{\\<langle>k,BinomElem(r,k)\\<rangle>. k\\<in>succ(domain(r))}\"\n    have \"\\<forall>k\\<in>succ(domain(r)). BinomElem(r,k) \\<in> nat\"\n      unfolding BinomElem_def by simp\n    then have \"?r\\<^sub>1: succ(domain(r))\\<rightarrow>nat\"\n      by (rule ZF_fun_from_total)\n    with \\<open>n\\<in>nat\\<close> \\<open>domain(r) = succ(n)\\<close> have \"?r\\<^sub>1\\<in>NELists(nat)\"\n      unfolding NELists_def by auto\n  } then show ?thesis using ZF_fun_from_total unfolding GenBinom_def \n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 695,
        "informal": " The function GenBinom, which maps lists of natural numbers to lists of natural numbers, is a well-defined function."
    },
    "80": {
        "type": "theorem",
        "text": "text\\<open>The group structure can be projected to the quotient space.\\<close>\n",
        "assumes": "assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,P)\"\n  ",
        "using": [
            "IsAgroup_def",
            "monoid0_def",
            "monoid0.Group_ZF_2_2_T1",
            "quotient_def",
            "inverse_in_group",
            "quotientI",
            "Group_ZF_2_2_L3"
        ],
        "statement": "theorem (in group0) Group_ZF_3_T2:\n  assumes A1: \"equiv(G,r)\" and A2: \"Congruent2(r,P)\"\n  shows \"IsAgroup(G//r,ProjFun2(G,r,P))\"\n",
        "proof": "proof -\n  let ?F = \"ProjFun2(G,r,P)\"\n  let ?E = \"TheNeutralElement(G//r,?F)\"\n  from groupAssum A1 A2 have \"IsAmonoid(G//r,?F)\"\n    using IsAgroup_def monoid0_def monoid0.Group_ZF_2_2_T1\n    by simp\n  moreover have\n    \"\\<forall>c\\<in>G//r. \\<exists>b\\<in>G//r. ?F`\\<langle> c,b\\<rangle> = ?E\"\n  proof\n    fix c assume A3: \"c \\<in> G//r\"\n    then obtain g where D1: \"g\\<in>G\"  \"c = r``{g}\"\n      using quotient_def by auto\n    let ?b = \"r``{g\\<inverse>}\"\n    from D1 have \"?b \\<in> G//r\"\n      using inverse_in_group quotientI\n      by simp\n    moreover from A1 A2 D1 have \n      \"?F`\\<langle> c,?b\\<rangle> = ?E\"\n      using Group_ZF_2_2_L3 by simp\n    ultimately show \"\\<exists>b\\<in>G//r. ?F`\\<langle> c,b\\<rangle> = ?E\"\n      by auto\n  qed\n  ultimately show ?thesis\n    using IsAgroup_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 540,
        "informal": " assuming G is an equivalence relation represented by r, and r is congruent to relation P, prove that G/r (the quotient of G by r) is a group under the projection function ProjFun2(G,r,P)."
    },
    "81": {
        "type": "lemma",
        "text": "text\\<open>The group order is reflexive.\\<close>\n",
        "assumes": "assumes \"g\\<in>G\"\n  ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "refl_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L3: assumes \"g\\<in>G\"\n  shows \"g\\<lsq>g\"\n  ",
        "proof": "using ordGroupAssum assms IsAnOrdGroup_def IsPartOrder_def refl_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1359,
        "informal": " Assuming `g` is an element of group `G`, it holds that `g` is less than or equal to `g`. \n\nOr more succinctly, for all `g` in `G`, `g` is a subset of or equal to `g`. This is not exactly accurate as the original Isabelle/ZF code is stating that `g` is less than or equal to `g` in the context of an ordered group, but the natural language version should hopefully be understandable without requiring a deep understanding of the formal logic behind it."
    },
    "82": {
        "type": "lemma",
        "text": "text\\<open>The value of an integer function at a sum expressed in \n  terms of \\<open>\\<delta>\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "apply_funtype",
            "Int_ZF_1_2_L15"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L3C: assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"f`(m\\<ra>n) = \\<delta>(f,m,n) \\<ra> f`(n) \\<ra> f`(m)\"\n",
        "proof": "proof -\n  from A1 A2 have T:\n    \"\\<delta>(f,m,n) \\<in> \\<int>\"  \"f`(m\\<ra>n) \\<in> \\<int>\"  \"f`(m) \\<in> \\<int>\"  \"f`(n) \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 apply_funtype by auto\n  then show \"f`(m\\<ra>n) = \\<delta>(f,m,n) \\<ra> f`(n) \\<ra> f`(m)\"\n    using Int_ZF_1_2_L15 by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 847,
        "informal": " Given a function f from integers to integers, and integers m and n, if m and n are in the domain of the function, then the function value of f applied to the sum of m and n is equal to the sum of the function value of f applied to m, the function value of f applied to n, and the difference between the function value of f applied to m and n."
    },
    "83": {
        "type": "corollary",
        "text": "text\\<open>A corollary is then that the cofinite topology is locally compact; since every subspace\nof a cofinite space is cofinite.\\<close>\n",
        "assumes": "",
        "using": [
            "CoCar_is_topology",
            "InfCard_nat",
            "Cofinite_def",
            "topology0_def",
            "topology0.Top_2_L3[OF",
            "cof]",
            "subspace_cocardinal",
            "cofinite_compact",
            "union_cocardinal",
            "compact_subspace_imp_compact"
        ],
        "statement": "corollary cofinite_locally_compact:\n  shows \"(CoFinite X){is locally-compact}\"\n",
        "proof": "proof-\n  have cof:\"topology0(CoFinite X)\" and cof1:\"(CoFinite X){is a topology}\" \n    using CoCar_is_topology InfCard_nat Cofinite_def unfolding topology0_def by auto\n  {\n    fix x B assume \"x\\<in>\\<Union>(CoFinite X)\" \"B\\<in>(CoFinite X)\" \"x\\<in>B\"\n    then have \"x\\<in>Interior(B,CoFinite X)\" using topology0.Top_2_L3[OF cof] by auto moreover\n    from \\<open>B\\<in>(CoFinite X)\\<close> have \"B\\<subseteq>X\" unfolding Cofinite_def CoCardinal_def by auto\n    then have \"B\\<inter>X=B\" by auto\n    then have \"(CoFinite X){restricted to}B=CoFinite B\" using subspace_cocardinal unfolding Cofinite_def by auto\n    then have \"B{is compact in}((CoFinite X){restricted to}B)\" using cofinite_compact\n      union_cocardinal unfolding Cofinite_def by auto\n    then have \"B{is compact in}(CoFinite X)\" using compact_subspace_imp_compact by auto\n    ultimately have \"\\<exists>c\\<in>Pow(B). x\\<in>Interior(c,CoFinite X)\\<and> c{is compact in}(CoFinite X)\" by auto\n  }\n  then have \"(\\<forall>x\\<in>\\<Union>(CoFinite X). \\<forall>b\\<in>(CoFinite X). x\\<in>b \\<longrightarrow> (\\<exists>c\\<in>Pow(b). x\\<in>Interior(c,CoFinite X) \\<and> c{is compact in}(CoFinite X)))\"\n    by auto\n  then show ?thesis unfolding IsLocallyComp_def IsLocally_def[OF cof1] by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2379,
        "informal": " The cofinite topology on a set X makes X a locally compact space."
    },
    "84": {
        "type": "lemma",
        "text": "text\\<open>We can identify a set $X$ with lists of length one of elements of $X$.\\<close>\n",
        "assumes": "",
        "using": [
            "apply_funtype",
            "ZF_fun_from_tot_val",
            "list_singleton_pair",
            "list_len1_singleton",
            "pair_val",
            "inj_def",
            "surj_def",
            "bij_def"
        ],
        "statement": "lemma singleton_list_bij: shows \"{\\<langle>x,x`(0)\\<rangle>. x\\<in>1\\<rightarrow>X} \\<in> bij(1\\<rightarrow>X,X)\"\n",
        "proof": "proof -\n  let ?f = \"{\\<langle>x,x`(0)\\<rangle>. x\\<in>1\\<rightarrow>X}\"\n  have \"\\<forall>x\\<in>1\\<rightarrow>X. x`(0) \\<in> X\" using apply_funtype by simp\n  then have I: \"?f:(1\\<rightarrow>X)\\<rightarrow>X\" by (rule ZF_fun_from_total)\n  moreover have \"\\<forall>x\\<in>1\\<rightarrow>X.\\<forall>y\\<in>1\\<rightarrow>X. ?f`(x) = ?f`(y) \\<longrightarrow> x=y\"\n  proof -\n    { fix x y\n      assume \"x:1\\<rightarrow>X\" \"y:1\\<rightarrow>X\" and \"?f`(x) = ?f`(y)\"  \n      with I have \"x`(0) = y`(0)\" using ZF_fun_from_tot_val by auto\n      moreover from \\<open>x:1\\<rightarrow>X\\<close> \\<open>y:1\\<rightarrow>X\\<close> have \"x = {\\<langle>0,x`(0)\\<rangle>}\" and \"y = {\\<langle>0,y`(0)\\<rangle>}\" \n        using list_singleton_pair by auto\n      ultimately have \"x=y\" by simp \n    } thus ?thesis by auto \n  qed\n  moreover have \"\\<forall>y\\<in>X. \\<exists>x\\<in>1\\<rightarrow>X. ?f`(x)=y\"\n  proof\n    fix y assume \"y\\<in>X\"\n    let ?x = \"{\\<langle>0,y\\<rangle>}\"\n    from I \\<open>y\\<in>X\\<close> have \"?x:1\\<rightarrow>X\" and \"?f`(?x) = y\" \n      using list_len1_singleton ZF_fun_from_tot_val pair_val by auto \n    thus \"\\<exists>x\\<in>1\\<rightarrow>X. ?f`(x)=y\" by auto\n  qed\n  ultimately show ?thesis using inj_def surj_def bij_def by simp \nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 268,
        "informal": " The singleton list {<x, x>>. x ∈ 1 → X} is a bijection from 1 → X to X. \n\nIn simpler terms, for each x in the domain X, the singleton list {<x, x>>} maps x to itself and forms a bijection between the set 1 → X and X."
    },
    "85": {
        "type": "definition",
        "text": "text\\<open>Definition of \\<open>zf_move\\<close> - the ZF version of \\<open>zf_move_fun\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in generalization)\n  \"zf_move \\<equiv> {\\<langle>x,zf_move_fun(x)\\<rangle>. x\\<in>big}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 401,
        "informal": " In generalization, \"zf_move\" is defined as the equivalence relation such that for all x, x is related to zf_move(x) if and only if x is an element of the set big."
    },
    "86": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is sometimes called the \"quotient-reminder theorem\".\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_L2",
            "raw_zmod_zdiv_equality"
        ],
        "statement": "lemma (in int0) IntDiv_ZF_1_L1: assumes \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \"m = n\\<cdot>(m zdiv n) \\<ra> (m zmod n)\"\n  ",
        "proof": "using assms Int_ZF_1_L2 raw_zmod_zdiv_equality\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_1",
            "ZF.IntDiv"
        ],
        "source": "IsarMathLib/IntDiv_ZF_IML.thy",
        "id": 711,
        "informal": " Given integers m and n, m is equal to the product of n and the quotient of m divided by n, plus the remainder of m divided by n."
    },
    "87": {
        "type": "lemma",
        "text": "text\\<open>Some other rearrangements with four elements.\n  The algorithm for proof as in \\<open>group0_4_L2\\<close>\n  works very well here.\\<close>\n",
        "assumes": "assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "IsCommutative_def",
            "group_op_closed",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) rearr_ab_gr_4_elemA:\n  assumes A1: \"P {is commutative on} G\"\n  and A2: \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \n  \"a\\<cdot>b\\<cdot>c\\<cdot>d = a\\<cdot>d\\<cdot>b\\<cdot>c\"\n  \"a\\<cdot>b\\<cdot>c\\<cdot>d = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n",
        "proof": "proof -\n  from A1 A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d = d\\<cdot>(a\\<cdot>b\\<cdot>c)\"\n    using  IsCommutative_def group_op_closed\n    by simp\n  also from A2 have \"\\<dots> = d\\<cdot>a\\<cdot>b\\<cdot>c\"\n    using group_op_closed group_oper_assoc\n    by simp\n  also from A1 A2 have \"\\<dots> = a\\<cdot>d\\<cdot>b\\<cdot>c\"\n    using IsCommutative_def group_op_closed\n    by simp\n  finally show \"a\\<cdot>b\\<cdot>c\\<cdot>d = a\\<cdot>d\\<cdot>b\\<cdot>c\"\n    by simp\n  from A1 A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d = c\\<cdot>(a\\<cdot>b)\\<cdot>d\"\n    using IsCommutative_def group_op_closed\n    by simp\n  also from A2 have \"\\<dots> = c\\<cdot>a\\<cdot>b\\<cdot>d\"\n    using group_op_closed group_oper_assoc\n    by simp\n  also from A1 A2 have \"\\<dots> = a\\<cdot>c\\<cdot>b\\<cdot>d\"\n    using IsCommutative_def group_op_closed\n    by simp\n  also from A2 have \"\\<dots> = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n    using group_op_closed group_oper_assoc\n    by simp\n  finally show \"a\\<cdot>b\\<cdot>c\\<cdot>d = a\\<cdot>c\\<cdot>(b\\<cdot>d)\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 17,
        "informal": " In the group0 theory, if commutativity holds for a group G, and a, b, c, d are elements of G, then:\n\n1. The product of a, b, c, and d equals the product of d, b, c, and a.\n2. The product of a, b, c, and d equals the product of a and the product of c and the product of b and d."
    },
    "88": {
        "type": "lemma",
        "text": "text\\<open>The identity function ($I(x) = x$) on $G$ is an almost homomorphism.\\<close>\n",
        "assumes": "",
        "using": [
            "group0_2_L1",
            "monoid0.group0_1_L3A",
            "Group_ZF_3_4_L14",
            "group0_2_L2",
            "id_type",
            "AlmostHoms_def"
        ],
        "statement": "lemma (in group1) Group_ZF_3_4_L15: shows \"id(G) \\<in> AH\"\n",
        "proof": "proof -\n  have \"G\\<times>G \\<noteq> 0\" using group0_2_L1 monoid0.group0_1_L3A \n    by blast\n  then show ?thesis using Group_ZF_3_4_L14 group0_2_L2\n    id_type AlmostHoms_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 617,
        "informal": " In the group1 theory, it is shown that the identity element id(G) belongs to the subgroup AH."
    },
    "89": {
        "type": "lemma",
        "text": "text\\<open>The binomial term is $y^n$ when $k=n$.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"y\\<in>R\"\n  ",
        "using": [
            "assms",
            "binom_right_boundary",
            "mult_pow_zero(2)",
            "add_monoid.nat_mult_one",
            "Ring_ZF_1_L2(2)",
            "mult_pow_type(2)",
            "Ring_ZF_1_L3(6)"
        ],
        "statement": "lemma (in ring3) bt_at_right: assumes \"n\\<in>nat\" \"y\\<in>R\"\n  shows \"BT(n,n,x,y) = pow(n,y)\" \n  unfolding BT_def ",
        "proof": "using assms binom_right_boundary mult_pow_zero(2)\n    add_monoid.nat_mult_one Ring_ZF_1_L2(2) mult_pow_type(2) Ring_ZF_1_L3(6)\n  by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1794,
        "informal": " Assuming `n` is a natural number and `y` is an element in a ring `R`, the binary operator `BT` defined as:\n\n```isabelle\ndefinition BT (n m p q : nat) where\n  \"BT n m p q <- if m = 0 then p else (BT (n+1) (m-1) (pow n (p+q)) (BT n m p))\"\n```\n\nimplies `BT(n, n, x, y)` equals `x^y`:\n\nIn English:\n\nGiven a natural number `n` and an element `y` in a ring `R`, `BT(n, n, x, y)` is equal to `x` raised to the power of `y`."
    },
    "90": {
        "type": "lemma",
        "text": "text\\<open>If the difference is zero, the integers are equal.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" and A2: \"m\\<rs>n = \\<zero>\"\n  ",
        "using": [
            "Int_ZF_1_T2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_L15: \n  assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" and A2: \"m\\<rs>n = \\<zero>\"\n  shows \"m=n\" \n",
        "proof": "proof -\n  let ?G = \"\\<int>\"\n  let ?f = \"IntegerAddition\"\n  from A1 A2 have\n    \"group0(?G, ?f)\"\n    \"m \\<in> ?G\"  \"n \\<in> ?G\"\n    \"?f`\\<langle>m, GroupInv(?G, ?f)`(n)\\<rangle> = TheNeutralElement(?G, ?f)\"\n    using Int_ZF_1_T2 by auto\n  then show \"m=n\" by (rule group0.group0_2_L11A)\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 965,
        "informal": " Assuming m and n are integers, and their relation m relation r n is equal to zero, we can conclude that m equals n."
    },
    "91": {
        "type": "lemma",
        "text": "text\\<open>A linearly ordered group can be decomposed into $G_+$, $\\{1\\}$ and\n  $-G_+$\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} G\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L14",
            "OrderedGroup_ZF_1_L26",
            "OrderedGroup_ZF_1_L25",
            "PositiveSet_def",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2",
            "OrderedGroup_ZF_1_L15",
            "OrderedGroup_ZF_1_L27",
            "group0.group_inv_of_one",
            "OrderedGroup_ZF_1_L2A"
        ],
        "statement": "lemma (in group3) OrdGroup_decomp2: \n  assumes A1: \"r {is total on} G\"\n  shows \n  \"G = G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+)\\<union> {\\<one>}\"\n  \"G\\<^sub>+\\<inter>(\\<sm>G\\<^sub>+) = 0\"\n  \"\\<one> \\<notin> G\\<^sub>+\\<union>(\\<sm>G\\<^sub>+)\"\n",
        "proof": "proof -\n  { fix a assume A2: \"a\\<in>G\"\n    with A1 have \"a\\<in>G\\<^sub>+ \\<or> a\\<inverse>\\<in>G\\<^sub>+ \\<or> a=\\<one>\"\n      using OrderedGroup_ZF_1_L14 by auto\n    with A2 have \"a\\<in>G\\<^sub>+ \\<or> a\\<in>(\\<sm>G\\<^sub>+) \\<or> a=\\<one>\"\n      using OrderedGroup_ZF_1_L26 by auto\n    then have \"a \\<in> (G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+)\\<union> {\\<one>})\"\n      by auto\n  } then have \"G \\<subseteq> G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+)\\<union> {\\<one>}\"\n    by auto\n  moreover have \"G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+)\\<union> {\\<one>} \\<subseteq> G\"\n    using OrderedGroup_ZF_1_L25 PositiveSet_def\n      OrderedGroup_ZF_1_L1 group0.group0_2_L2\n    by auto\n  ultimately show \"G = G\\<^sub>+ \\<union> (\\<sm>G\\<^sub>+)\\<union> {\\<one>}\" by auto\n  { let ?A = \"G\\<^sub>+\\<inter>(\\<sm>G\\<^sub>+)\"\n    assume \"G\\<^sub>+\\<inter>(\\<sm>G\\<^sub>+) \\<noteq> 0\"\n    then have \"?A\\<noteq>0\" by simp\n    then obtain a where \"a\\<in>?A\" by blast\n    then have False using OrderedGroup_ZF_1_L15 OrderedGroup_ZF_1_L27\n      by auto\n  } then show \"G\\<^sub>+\\<inter>(\\<sm>G\\<^sub>+) = 0\" by auto\n  show \"\\<one> \\<notin> G\\<^sub>+\\<union>(\\<sm>G\\<^sub>+)\"\n    using OrderedGroup_ZF_1_L27\n      OrderedGroup_ZF_1_L1 group0.group_inv_of_one\n      OrderedGroup_ZF_1_L2A by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1434,
        "informal": " In the group \"group3\" of Isabelle/ZF:\n\nAssuming \"r\" is a total function over the group \"G\":\n\nThe group \"G\" can be decomposed as the direct sum of the subgroup \"G+\", the sum of the subgroup \"-G+\", and the set containing the identity element {\"1\"}:\n\nG = G+ ∪ (−G+ ∪ {1})\n\nThe subgroups \"G+\" and \"-G+\" intersect to form the zero subgroup:\n\nG+ ∩ (-G+) = {0}\n\nThe identity element \"1\" does not belong to the subgroup G+ ∪ (-G+):\n\n1 ∉ G+ ∪ (-G+)"
    },
    "92": {
        "type": "lemma",
        "text": "text\\<open>We aim at showing that $m\\mapsto m^S$ is an injection modulo\n  the relation of almost equality. To do that we first show that if\n  $m^S$ has finite range, then $m=0$.\\<close>\n",
        "assumes": "assumes \"m\\<in>\\<int>\" and \"m\\<^sup>S \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  ",
        "using": [
            "assms",
            "FinRangeFunctions_def",
            "Int_ZF_2_5_L1",
            "AlmostHoms_def",
            "func_imagedef",
            "Int_ZF_1_6_L8"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L5: \n  assumes \"m\\<in>\\<int>\" and \"m\\<^sup>S \\<in> FinRangeFunctions(\\<int>,\\<int>)\"\n  shows \"m=\\<zero>\"\n  ",
        "proof": "using assms FinRangeFunctions_def Int_ZF_2_5_L1 AlmostHoms_def \n    func_imagedef Int_ZF_1_6_L8 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 936,
        "informal": " Assuming m is an integer and m is a finite function over integers (belongs to FinRangeFunctions), we will show that m equals zero."
    },
    "93": {
        "type": "lemma",
        "text": "text\\<open>Nonempty set has non-zero cardinality. This is probably\n  true without the assumption that the set is finite, but\n  I couldn't derive it from standard Isabelle theorems.\n\\<close>\n",
        "assumes": "assumes \"A \\<in> FinPow(X)\" and \"A \\<noteq> 0\"\n  ",
        "using": [
            "card_non_empty_succ",
            "succ_not_0"
        ],
        "statement": "lemma card_non_empty_non_zero:\n  assumes \"A \\<in> FinPow(X)\" and \"A \\<noteq> 0\"\n  shows \"|A| \\<noteq> 0\"\n",
        "proof": "proof -\n  from assms obtain n where \"|A| = succ(n)\"\n    using card_non_empty_succ by auto\n  then show \"|A| \\<noteq> 0\" using succ_not_0\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Nat_ZF_IML",
            "ZF.Cardinal"
        ],
        "source": "IsarMathLib/Finite_ZF.thy",
        "id": 333,
        "informal": " If X is a finite set and A is a non-empty and non-zero subset of X, then the cardinality of A is not zero."
    },
    "94": {
        "type": "lemma",
        "text": "text\\<open>\\<open>\\<int>\\<^sup>+\\<close> is bounded below.\\<close>\n",
        "assumes": "",
        "using": [
            "Nonnegative_def",
            "PositiveSet_def",
            "IsBoundedBelow_def"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L1: shows \n  \"IsBoundedBelow(\\<int>\\<^sup>+,IntegerOrder)\"\n  \"IsBoundedBelow(\\<int>\\<^sub>+,IntegerOrder)\"\n  ",
        "proof": "using Nonnegative_def PositiveSet_def IsBoundedBelow_def by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 801,
        "informal": " In the Int0 theory of Isabelle/ZF, it is proved that the addition and subtraction operations on integers are bounded below with respect to the IntegerOrder."
    },
    "95": {
        "type": "lemma",
        "text": "text\\<open>If $k$ is a member of $succ(n)$ but is not $n$, then it must be the member of $n$.\\<close>\n",
        "assumes": "assumes \"k\\<in>succ(n)\" \"k\\<noteq>n\"\n  ",
        "using": [
            "assms",
            "succ_explained"
        ],
        "statement": "lemma mem_succ_not_eq: assumes \"k\\<in>succ(n)\" \"k\\<noteq>n\"\n  shows \"k\\<in>n\" ",
        "proof": "using assms succ_explained by simp\n",
        "imports": [
            "ZF.ArithSimp"
        ],
        "source": "IsarMathLib/Nat_ZF_IML.thy",
        "id": 1164,
        "informal": " Assuming `k` is a natural number that belongs to the successor of `n` (`succ(n)`) and is not equal to `n`, it cannot be the case that `k` belongs to `n`."
    },
    "96": {
        "type": "lemma",
        "text": "text\\<open>This shows how Isabelle's \\<open>$<\\<close> operator translates to IsarMathLib\n  notation.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  and A2: \"m $< n\"\n  ",
        "using": [
            "assms",
            "zle_def",
            "Int_ZF_2_L1"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L9AA: assumes A1: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  and A2: \"m $< n\"\n  shows \"m\\<lsq>n\"  \"m \\<noteq> n\"\n  ",
        "proof": "using assms zle_def Int_ZF_2_L1 by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 980,
        "informal": " Assuming integers m and n satisfy m is in the set of integers, n is in the set of integers, and m is less than n, we have m is less than or equal to n and m is not equal to n."
    },
    "97": {
        "type": "lemma",
        "text": "text\\<open> $a\\cdot b \\cdot (c\\cdot d) = a\\cdot (b \\cdot c) \\cdot d$ for\n  semigrouop elements $a,b,c,d \\in G$. The \\<open>Commutative semigroups\\<close> section\n  below contains a couple of rearrangements that need commutativity of the semigroup\n  operation, but this one uses only associativity, so it's here. \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  ",
        "using": [
            "semigr_closed",
            "semigr_assoc"
        ],
        "statement": "lemma (in semigr0) rearr4elem_assoc: \n  assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\"\n  shows \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>(b\\<cdot>c)\\<cdot>d\"\n",
        "proof": "proof -\n  from assms have \"a\\<cdot>b\\<cdot>(c\\<cdot>d) = a\\<cdot>b\\<cdot>c\\<cdot>d\" using semigr_closed semigr_assoc\n    by simp\n  with assms(1,2,3) show ?thesis using semigr_assoc by simp\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1888,
        "informal": " In the semigroup `G`, if elements `a`, `b`, `c`, and `d` are present, then `a` multiplied by the product of `b` and `c` equals the product of `a` multiplied by `b` and `c` multiplied by `d`."
    },
    "98": {
        "type": "lemma",
        "text": "text\\<open> Any uniformly continuous function is continuous when considering the topologies on the uniformities. \\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \"\\<Phi> {is a uniformity on} X \" \"\\<Gamma> {is a uniformity on} Y\" \n    \"f {is uniformly continuous between} \\<Phi> {and} \\<Gamma>\"\n  ",
        "using": [
            "func1_1_L3",
            "uniftop_def_alt",
            "apply_equality",
            "IsUniformlyCont_def",
            "image_def",
            "prodFunVimage",
            "func1_1_L15",
            "x"
        ],
        "statement": "lemma uniformly_cont_is_cont:\n  assumes \"f:X\\<rightarrow>Y\" \"\\<Phi> {is a uniformity on} X \" \"\\<Gamma> {is a uniformity on} Y\" \n    \"f {is uniformly continuous between} \\<Phi> {and} \\<Gamma>\"\n  shows \"IsContinuous(UniformTopology(\\<Phi>,X),UniformTopology(\\<Gamma>,Y),f)\"\n",
        "proof": "proof -\n  {  fix U assume op: \"U \\<in> UniformTopology(\\<Gamma>,Y)\"\n    have \"f-``(U) \\<in> UniformTopology(\\<Phi>,X)\"\n    proof -\n      from assms(1) have \"f-``(U) \\<subseteq> X\" using func1_1_L3 by simp\n      moreover \n      { fix x xa assume as:\"\\<langle>x,xa\\<rangle> \\<in> f\" \"xa \\<in> U\"\n        with assms(1) have x:\"x\\<in>X\" unfolding Pi_def by auto\n        from as(2) op have U:\"U \\<in> {\\<langle>t,{V``{t}.V\\<in>\\<Gamma>}\\<rangle>.t\\<in>Y}`(xa)\" using uniftop_def_alt by auto\n        from as(1) assms(1) have xa:\"xa \\<in> Y\" unfolding Pi_def by auto\n        have \"{\\<langle>t,{V``{t}.V\\<in>\\<Gamma>}\\<rangle>.t\\<in>Y} \\<in> Pi(Y,%t. {{V``{t}.V\\<in>\\<Gamma>}})\" unfolding Pi_def function_def \n          by auto\n        with U xa have \"U \\<in>{V``{xa}.V\\<in>\\<Gamma>}\" using apply_equality by auto\n        then obtain V where V:\"U = V``{xa}\" \"V\\<in>\\<Gamma>\" by auto\n        with assms have ent:\"(ProdFunction(f,f)-``(V))\\<in>\\<Phi>\" using IsUniformlyCont_def by simp\n        have \"\\<forall>t. t \\<in> (ProdFunction(f,f)-``V)``{x} <-> \\<langle>x,t\\<rangle> \\<in> ProdFunction(f,f)-``(V)\" \n          using image_def by auto\n        with assms(1) x have \"\\<forall>t. t: (ProdFunction(f,f)-``V)``{x} \\<longleftrightarrow> (t\\<in>X \\<and> \\<langle>f`x,f`t\\<rangle> \\<in> V)\" \n          using prodFunVimage by auto\n        with assms(1) as(1) have \"\\<forall>t. t \\<in> (ProdFunction(f,f)-``V)``{x} \\<longleftrightarrow> (t\\<in>X \\<and> \\<langle>xa,f`t\\<rangle>: V)\" \n          using apply_equality by auto\n        with V(1) have \"\\<forall>t. t \\<in> (ProdFunction(f,f)-``V)``{x} \\<longleftrightarrow> (t\\<in>X \\<and> f`(t) \\<in> U)\" by auto\n        with assms(1) U have \"\\<forall>t. t \\<in> (ProdFunction(f,f)-``V)``{x} \\<longleftrightarrow> t \\<in> f-``U\"\n          using func1_1_L15 by simp\n        hence \"f-``U = (ProdFunction(f,f)-``V)``{x}\" by blast\n        with ent have \"f-``(U) \\<in> {V``{x} . V \\<in> \\<Phi>}\" by auto \n        moreover\n        have \"{\\<langle>t,{V``{t}.V\\<in>\\<Phi>}\\<rangle>.t\\<in>X} \\<in> Pi(X,%t. {{V``{t}.V\\<in>\\<Phi>}})\" unfolding Pi_def function_def \n          by auto\n        ultimately have \"f-``(U) \\<in> {\\<langle>t, {V `` {t} . V \\<in> \\<Phi>}\\<rangle> . t \\<in> X}`(x)\" using x apply_equality \n          by auto\n      } \n      ultimately show \"f-``(U) \\<in> UniformTopology(\\<Phi>,X)\" using uniftop_def_alt by auto\n    qed\n  } then show ?thesis unfolding IsContinuous_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.UniformSpace_ZF",
            "IsarMathLib.Topology_ZF_2"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_1.thy",
        "id": 2464,
        "informal": " If function f from X to Y is uniformly continuous between the uniformities Φ and γ on X and Y, respectively, then f is a continuous function with respect to the uniform topologies generated by Φ and γ."
    },
    "99": {
        "type": "lemma",
        "text": "text\\<open>The next theorem\n  shows that of $a\\leq b$, then $a< b+1$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<real>\"   \"b\\<in>\\<real>\" and A3: \"a\\<lsq>b\"\n  ",
        "using": [
            "num_le_numplus1",
            "MMI_ax1re",
            "MMI_axaddrcl",
            "MMI_lelttr"
        ],
        "statement": "lemma (in MMIsar0) lsq_imp_ls_plus1: \n  assumes A1: \"a\\<in>\\<real>\"   \"b\\<in>\\<real>\" and A3: \"a\\<lsq>b\"\n  shows \"a \\<ls> b\\<ca>\\<one>\"\n",
        "proof": "proof -\n  from A1 have \"b \\<ls> b\\<ca>\\<one>\" using num_le_numplus1 by simp\n  with A1 A3 show \"a \\<ls> b\\<ca>\\<one>\" using MMI_ax1re MMI_axaddrcl MMI_lelttr\n    by blast\nqed\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets_1",
            "IsarMathLib.MMI_Complex_ZF_1",
            "IsarMathLib.InductiveSeq_ZF"
        ],
        "source": "IsarMathLib/MMI_Complex_ZF_2.thy",
        "id": 1079,
        "informal": " Assuming `a` and `b` are real numbers, if `a` is less than `b`, then `a` is strictly less than `b` plus one."
    },
    "100": {
        "type": "theorem",
        "text": "text\\<open>Sum is a continuous function in the product topology.\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\"\n  ",
        "using": [
            "semigr0_valid_in_tgroup",
            "semigr0.prod_of_1elem",
            "topSpaceAssum",
            "singleton_prod_top1",
            "IsAhomeomorphism_def",
            "sum_list_in_group",
            "ZF_fun_from_total",
            "init_props",
            "apply_funtype",
            "topgroup_f_binop",
            "comp_fun",
            "finite_top_prod_homeo",
            "seq_prod_top_is_top",
            "cart_prod_cont1",
            "fcon",
            "ZF_fun_from_tot_val1",
            "shorter_set_add",
            "func_eq",
            "comp_cont3"
        ],
        "statement": "theorem (in topgroup) sum_continuous: assumes \"n \\<in> nat\"\n  shows \"IsContinuous(SeqProductTopology(succ(n),T),T,{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(n)\\<rightarrow>G})\"\n  ",
        "proof": "proof -\n    note \\<open>n \\<in> nat\\<close>\n    moreover have \"IsContinuous(SeqProductTopology(succ(0),T),T,{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(0)\\<rightarrow>G})\"\n    proof -\n      have \"{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(0)\\<rightarrow>G} = {\\<langle>x,x`(0)\\<rangle>. x\\<in>1\\<rightarrow>G}\"\n        using semigr0_valid_in_tgroup semigr0.prod_of_1elem by simp\n      moreover have\n        \"IsAhomeomorphism(SeqProductTopology(1,T),T,{\\<langle>x,x`(0)\\<rangle>. x\\<in>1\\<rightarrow>\\<Union>T})\" using topSpaceAssum singleton_prod_top1\n          by simp\n      ultimately show ?thesis using IsAhomeomorphism_def by simp\n    qed\n    moreover have \"\\<forall>k\\<in>nat.\n      IsContinuous(SeqProductTopology(succ(k),T),T,{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(k)\\<rightarrow>G})\n      \\<longrightarrow>\n      IsContinuous(SeqProductTopology(succ(succ(k)),T),T,{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(succ(k))\\<rightarrow>G})\"\n      proof -\n        { fix k assume \"k \\<in> nat\"\n          let ?s = \"{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(k)\\<rightarrow>G}\"\n          let ?g = \"{\\<langle>p,\\<langle>?s`(fst(p)),snd(p)\\<rangle>\\<rangle>. p \\<in> (succ(k)\\<rightarrow>G)\\<times>G}\"\n          let ?h = \"{\\<langle>x,\\<langle>Init(x),x`(succ(k))\\<rangle>\\<rangle>. x \\<in> succ(succ(k))\\<rightarrow>G}\"\n          let ?\\<phi> = \"SeqProductTopology(succ(k),T)\"\n          let ?\\<psi> = \"SeqProductTopology(succ(succ(k)),T)\"\n          assume \"IsContinuous(?\\<phi>,T,?s)\"\n          from \\<open>k \\<in> nat\\<close> have \"?s: (succ(k)\\<rightarrow>G) \\<rightarrow> G\"\n            using sum_list_in_group ZF_fun_from_total by simp \n          have \"?h: (succ(succ(k))\\<rightarrow>G)\\<rightarrow>(succ(k)\\<rightarrow>G)\\<times>G\"\n          proof -\n            { fix x assume \"x \\<in> succ(succ(k))\\<rightarrow>G\"\n              with \\<open>k \\<in> nat\\<close> have \"Init(x) \\<in> (succ(k)\\<rightarrow>G)\"\n                using init_props by simp\n              with \\<open>k \\<in> nat\\<close> \\<open>x : succ(succ(k))\\<rightarrow>G\\<close> \n                have \"\\<langle>Init(x),x`(succ(k))\\<rangle> \\<in> (succ(k)\\<rightarrow>G)\\<times>G\" using apply_funtype\n                  by blast \n           } then show ?thesis using ZF_fun_from_total by simp\n          qed\n          moreover have \"?g:((succ(k)\\<rightarrow>G)\\<times>G)\\<rightarrow>(G\\<times>G)\"\n          proof -\n            { fix p assume \"p \\<in> (succ(k)\\<rightarrow>G)\\<times>G\"\n              hence \"fst(p): succ(k)\\<rightarrow>G\" and \"snd(p) \\<in> G\" by auto\n              with \\<open>?s: (succ(k)\\<rightarrow>G) \\<rightarrow> G\\<close> have \"\\<langle>?s`(fst(p)),snd(p)\\<rangle> \\<in> G\\<times>G\"\n                using apply_funtype by blast \n            } then show \"?g:((succ(k)\\<rightarrow>G)\\<times>G)\\<rightarrow>(G\\<times>G)\" using ZF_fun_from_total\n              by simp\n          qed\n          moreover have \"f : G\\<times>G \\<rightarrow> G\" using topgroup_f_binop by simp\n          ultimately have \"f O ?g O ?h :(succ(succ(k))\\<rightarrow>G)\\<rightarrow>G\" using comp_fun\n            by blast \n          from \\<open>k \\<in> nat\\<close> have \"IsContinuous(?\\<psi>,ProductTopology(?\\<phi>,T),?h)\"\n            using topSpaceAssum finite_top_prod_homeo IsAhomeomorphism_def\n            by simp\n          moreover have \"IsContinuous(ProductTopology(?\\<phi>,T),\\<tau>,?g)\"\n          proof -\n            from topSpaceAssum have \n               \"T {is a topology}\" \"?\\<phi> {is a topology}\" \"\\<Union>?\\<phi> = succ(k)\\<rightarrow>G\"\n               using seq_prod_top_is_top by auto\n            moreover from \\<open>\\<Union>?\\<phi> = succ(k)\\<rightarrow>G\\<close> \\<open>?s: (succ(k)\\<rightarrow>G) \\<rightarrow> G\\<close> \n              have \"?s:\\<Union>?\\<phi>\\<rightarrow>\\<Union>T\" by simp \n            moreover note \\<open>IsContinuous(?\\<phi>,T,?s)\\<close>\n            moreover from \\<open>\\<Union>?\\<phi> = succ(k)\\<rightarrow>G\\<close> \n              have \"?g = {\\<langle>p,\\<langle>?s`(fst(p)),snd(p)\\<rangle>\\<rangle>. p \\<in> \\<Union>?\\<phi>\\<times>\\<Union>T}\"\n              by simp\n            ultimately have \"IsContinuous(ProductTopology(?\\<phi>,T),ProductTopology(T,T),?g)\"\n              using cart_prod_cont1 by blast \n            thus ?thesis by simp\n          qed         \n          moreover have \"IsContinuous(\\<tau>,T,f)\" using fcon by simp\n          moreover have \"{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(succ(k))\\<rightarrow>G} = f O ?g O ?h\"\n          proof -\n            let ?d = \"{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(succ(k))\\<rightarrow>G}\"\n            from \\<open>k\\<in>nat\\<close> have \"\\<forall>x\\<in>succ(succ(k))\\<rightarrow>G. (\\<Sum>x) \\<in> G\"\n              using sum_list_in_group by blast \n            then have \"?d:(succ(succ(k))\\<rightarrow>G)\\<rightarrow>G\" \n              using sum_list_in_group ZF_fun_from_total by simp\n            moreover note \\<open>f O ?g O ?h :(succ(succ(k))\\<rightarrow>G)\\<rightarrow>G\\<close>\n            moreover have \"\\<forall>x\\<in>succ(succ(k))\\<rightarrow>G. ?d`(x) = (f O ?g O ?h)`(x)\"\n            proof\n              fix x assume \"x\\<in>succ(succ(k))\\<rightarrow>G\"\n              then have I: \"?h`(x) = \\<langle>Init(x),x`(succ(k))\\<rangle>\"\n                using ZF_fun_from_tot_val1 by simp\n              moreover from \\<open>k\\<in>nat\\<close> \\<open>x\\<in>succ(succ(k))\\<rightarrow>G\\<close> \n                have \"Init(x): succ(k)\\<rightarrow>G\" \n                using init_props by simp\n              moreover from \\<open>k\\<in>nat\\<close> \\<open>x:succ(succ(k))\\<rightarrow>G\\<close> \n                have II: \"x`(succ(k)) \\<in> G\"\n                using apply_funtype by blast\n              ultimately have \"?h`(x) \\<in> (succ(k)\\<rightarrow>G)\\<times>G\" by simp\n              then have \"?g`(?h`(x)) = \\<langle>?s`(fst(?h`(x))),snd(?h`(x))\\<rangle>\"\n                using ZF_fun_from_tot_val1 by simp\n              with I have \"?g`(?h`(x)) = \\<langle>?s`(Init(x)),x`(succ(k))\\<rangle>\"\n                by simp\n              with \\<open>Init(x): succ(k)\\<rightarrow>G\\<close> have \"?g`(?h`(x)) = \\<langle>\\<Sum>Init(x),x`(succ(k))\\<rangle>\"\n                using ZF_fun_from_tot_val1 by simp\n              with \\<open>k \\<in> nat\\<close> \\<open>x: succ(succ(k))\\<rightarrow>G\\<close> \n                have \"f`(?g`(?h`(x))) = (\\<Sum>x)\"\n                using shorter_set_add by simp\n              with \\<open>x \\<in> succ(succ(k))\\<rightarrow>G\\<close> have \"f`(?g`(?h`(x))) = ?d`(x)\"\n                using ZF_fun_from_tot_val1 by simp\n              moreover from \n                \\<open>?h: (succ(succ(k))\\<rightarrow>G)\\<rightarrow>(succ(k)\\<rightarrow>G)\\<times>G\\<close>\n                \\<open>?g:((succ(k)\\<rightarrow>G)\\<times>G)\\<rightarrow>(G\\<times>G)\\<close>\n                \\<open>f:(G\\<times>G)\\<rightarrow>G\\<close> \\<open>x\\<in>succ(succ(k))\\<rightarrow>G\\<close>\n                have \"(f O ?g O ?h)`(x) = f`(?g`(?h`(x)))\" by (rule func1_1_L18)\n              ultimately show \"?d`(x) = (f O ?g O ?h)`(x)\" by simp \n            qed\n            ultimately show \"{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(succ(k))\\<rightarrow>G} = f O ?g O ?h\" \n              using func_eq by simp\n          qed\n          moreover note \\<open>IsContinuous(\\<tau>,T,f)\\<close>\n          ultimately have \"IsContinuous(?\\<psi>,T,{\\<langle>x,\\<Sum>x\\<rangle>.x\\<in>succ(succ(k))\\<rightarrow>G})\"\n            using comp_cont3 by simp\n        } thus ?thesis by simp\n      qed\n    ultimately show ?thesis by (rule ind_on_nat)\n  qed\nend\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1974,
        "informal": " In the topological group, the sum function of a sequence of continuous functions, defined on the successor natural number and equipped with the product topology, is continuous."
    },
    "101": {
        "type": "corollary",
        "text": "text\\<open> Natural numbers are a directed set.\\<close>\n",
        "assumes": "",
        "using": [
            "linorder_imp_directed"
        ],
        "statement": "corollary Le_directs_nat:\n  shows \"IsLinOrder(nat,Le)\" \"Le directs nat\"\n",
        "proof": "proof -\n  show \"IsLinOrder(nat,Le)\"  by (rule NatOrder_ZF_1_L2) \n  then show \"Le directs nat\" using linorder_imp_directed by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF",
            "IsarMathLib.func1",
            "IsarMathLib.NatOrder_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_4.thy",
        "id": 2145,
        "informal": " In Isabelle/ZF, the statement:\n\ncorollary Le_directs_nat:\n  shows \"IsLinOrder(nat, Le)\" \"Le is a linear order that directs the natural numbers\"\n\nCan be translated into natural language as:\n\nThe relation Le is a linear order that entirely orders the natural numbers."
    },
    "102": {
        "type": "lemma",
        "text": "text\\<open>Combining \\<open>mult_elem_ring_type\\<close> and \\<open>sum_expr_ring_type\\<close> we obtain that\n  a (kind of) linear combination of expressions whose values belong to a ring\n  belongs to the ring. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"x\\<in>R\"  \"y\\<in>R\" \"\\<forall>k\\<in>n. q(k) \\<in> R\" \"\\<forall>k\\<in>n. p(k) \\<in> R\"\n  ",
        "using": [
            "mult_elem_ring_type(1)",
            "sum_expr_ring_type(1)",
            "add_monoid.sum_in_mono"
        ],
        "statement": "lemma (in ring3) lin_comb_expr_ring_type:\n  assumes \"n\\<in>nat\" \"x\\<in>R\"  \"y\\<in>R\" \"\\<forall>k\\<in>n. q(k) \\<in> R\" \"\\<forall>k\\<in>n. p(k) \\<in> R\"\n  shows \"\\<forall>k\\<in>n. q(k)\\<cdot>x\\<ra>p(k)\\<cdot>y \\<in> R\" and \n    \"(\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<ra>p(k)\\<cdot>y\\<rangle>. k\\<in>n}) \\<in> R\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>k\\<in>n. q(k)\\<cdot>x \\<in> R\" and \"\\<forall>k\\<in>n. p(k)\\<cdot>y \\<in> R\"\n    using mult_elem_ring_type(1) by simp_all\n  with assms(1) show \"\\<forall>k\\<in>n. q(k)\\<cdot>x\\<ra>p(k)\\<cdot>y \\<in> R\" \n    using sum_expr_ring_type(1) by simp\n  with assms(1) show \"(\\<Sum>{\\<langle>k,q(k)\\<cdot>x\\<ra>p(k)\\<cdot>y\\<rangle>. k\\<in>n}) \\<in> R\" \n    using add_monoid.sum_in_mono by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1785,
        "informal": " Given a natural number n, elements x, y in a ring R, and elements q(k) and p(k) in R for all k in n, the product of q(k) times x, ra, p(k) times y belongs to R for all k, and their linear combination, being the sum of these products over all k in n, also belongs to R."
    },
    "103": {
        "type": "lemma",
        "text": "text\\<open>A kind of converse to \\<open>ord_iso_rem_max\\<close>: if two\n  linearly ordered sets sets are order isomorphic \n  after removing the maxima, then they are order isomorphic.\\<close>\n",
        "assumes": "assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and \n  A2: \"HasAmaximum(r,X)\"  \"HasAmaximum(R,Y)\"\n  \"ord_iso(X - {Maximum(r,X)},r,Y - {Maximum(R,Y)},R) \\<noteq> 0\"\n  ",
        "using": [
            "IsLinOrder_def",
            "Order_ZF_4_L3",
            "total_is_refl",
            "refl_def",
            "ord_iso_extend"
        ],
        "statement": "lemma rem_max_ord_iso: \n  assumes A1: \"IsLinOrder(X,r)\"  \"IsLinOrder(Y,R)\" and \n  A2: \"HasAmaximum(r,X)\"  \"HasAmaximum(R,Y)\"\n  \"ord_iso(X - {Maximum(r,X)},r,Y - {Maximum(R,Y)},R) \\<noteq> 0\"\n  shows \"ord_iso(X,r,Y,R) \\<noteq> 0\"\n",
        "proof": "proof -\n  let ?M\\<^sub>A = \"Maximum(r,X)\"\n  let ?A = \"X - {?M\\<^sub>A}\"\n  let ?M\\<^sub>B = \"Maximum(R,Y)\"\n  let ?B = \"Y - {?M\\<^sub>B}\"\n  from A2 obtain f where \"f \\<in> ord_iso(?A,r,?B,R)\"\n    by auto\n  moreover have \"?M\\<^sub>A \\<notin> ?A\" and \"?M\\<^sub>B \\<notin> ?B\"\n    by auto\n  moreover from A1 A2 have \n    \"\\<forall>a\\<in>?A. \\<langle>a,?M\\<^sub>A\\<rangle> \\<in> r\" and \"\\<forall>b\\<in>?B. \\<langle>b,?M\\<^sub>B\\<rangle> \\<in> R\"\n    using IsLinOrder_def Order_ZF_4_L3 by auto\n  moreover from A1 have \"antisym(r)\" and \"antisym(R)\"\n    using IsLinOrder_def by auto\n  moreover from A1 A2 have \"\\<langle>?M\\<^sub>A,?M\\<^sub>A\\<rangle> \\<in> r \\<longleftrightarrow> \\<langle>?M\\<^sub>B,?M\\<^sub>B\\<rangle> \\<in> R\"\n    using IsLinOrder_def Order_ZF_4_L3 IsLinOrder_def \n      total_is_refl refl_def by auto\n  ultimately have \n    \"f \\<union> {\\<langle> ?M\\<^sub>A,?M\\<^sub>B\\<rangle>} \\<in> ord_iso(?A\\<union>{?M\\<^sub>A} ,r,?B\\<union>{?M\\<^sub>B} ,R)\"\n    by (rule ord_iso_extend)\n  moreover from A1 A2 have \n    \"?A\\<union>{?M\\<^sub>A} = X\" and \"?B\\<union>{?M\\<^sub>B} = Y\"\n  using IsLinOrder_def Order_ZF_4_L3 by auto\n  ultimately show \"ord_iso(X,r,Y,R) \\<noteq> 0\"\n    using ord_iso_extend by auto\nqed\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2719,
        "informal": " If X and Y are linearly ordered sets with maximum elements, and the ordering relations r on X and R on Y are isomorphic, then X with the maximum element removed is not isomorphic to Y with its maximum element removed. Therefore, X and Y are not isomorphic without their maximum elements."
    },
    "104": {
        "type": "lemma",
        "text": "text\\<open>Real order is translation invariant.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"c\\<in>\\<real>\"\n  ",
        "using": [
            "assms",
            "Real_ZF_1_2_L10",
            "IsAnOrdGroup_def"
        ],
        "statement": "lemma (in real1) real_ord_transl_inv: \n  assumes \"a\\<lsq>b\" and \"c\\<in>\\<real>\"\n  shows \"c\\<ra>a \\<lsq> c\\<ra>b\"\n  ",
        "proof": "using assms Real_ZF_1_2_L10 IsAnOrdGroup_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1699,
        "informal": " Given real numbers a < b and a real number c, c is to the left of a implies c is to the left of b."
    },
    "105": {
        "type": "lemma",
        "text": "text\\<open>If a word reaches the state @{term starts0},\nit does not move from it.\\<close>\n",
        "assumes": "assumes \"\\<langle>\\<langle>w,ends0\\<rangle>,\\<langle>u,y\\<rangle>\\<rangle>\\<in>r{0.*1}^*\"\n  ",
        "using": [
            "dfsaFrom0To1.DFSA_dest(3)",
            ".",
            "have",
            "\"snd(\\<langle>u,y\\<rangle>)",
            "=",
            "ends0\"",
            "proof(rule",
            "rtrancl_induct[of",
            "\"\\<langle>w,ends0\\<rangle>\"",
            "\"\\<langle>u,y\\<rangle>\"",
            "\"r{0.*1}\"",
            "\"\\<lambda>t.",
            "snd(t)",
            "ends0\"])",
            "show",
            "\"snd(\\<langle>w,",
            "ends0\\<rangle>)",
            "last_type",
            "apply_equality[OF",
            "_",
            "funT,",
            "of",
            "ends0]"
        ],
        "statement": "lemma invariant_state_3:\n  fixes w u y\n  assumes \"\\<langle>\\<langle>w,ends0\\<rangle>,\\<langle>u,y\\<rangle>\\<rangle>\\<in>r{0.*1}^*\"\n  shows \"y = ends0\"\n",
        "proof": "proof-\n  have finA:\"Finite(2)\" by auto\n  have funT:\"transFun:states\\<times>2\\<rightarrow> states\" \n    using dfsaFrom0To1.DFSA_dest(3) .\n  have \"snd(\\<langle>u,y\\<rangle>) = ends0\"\n  proof(rule rtrancl_induct[of \"\\<langle>w,ends0\\<rangle>\" \n        \"\\<langle>u,y\\<rangle>\" \"r{0.*1}\" \"\\<lambda>t. snd(t) = ends0\"])\n    show \"snd(\\<langle>w, ends0\\<rangle>) = ends0\" by auto\n    from assms show \"\\<langle>\\<langle>w, ends0\\<rangle>, u, y\\<rangle> \\<in> r{0.*1}^*\" .\n    {\n      fix y z assume as:\"\\<langle>\\<langle>w, ends0\\<rangle>, y\\<rangle> \\<in> r{0.*1}^*\" \"\\<langle>y, z\\<rangle> \\<in> r{0.*1}\" \"snd(y) = ends0\"\n      from as(3,2) obtain y1 where yy:\"y=\\<langle>y1,ends0\\<rangle>\" \"y1\\<in>NELists(2)\"\n        \"z=\\<langle>Init(y1),transFun`\\<langle>ends0,Last(y1)\\<rangle>\\<rangle>\" \n        unfolding DFSAExecutionRelation_def[OF finA dfsaFrom0To1.DFSA]\n        by auto\n      from yy(2) have \"Last(y1)\\<in>2\" using last_type by auto\n      then have \"\\<langle>\\<langle>ends0,Last(y1)\\<rangle>,ends0\\<rangle>\\<in>transFun\" by auto\n      then have \"transFun`\\<langle>ends0,Last(y1)\\<rangle> = ends0\" \n        using apply_equality[OF _ funT, of _ ends0] by auto \n      with yy(3) have \"z=\\<langle>Init(y1),ends0\\<rangle>\" by auto\n      then show \"snd(z) = ends0\" by auto\n    }\n  qed\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 290,
        "informal": " Given a relation `r` and elements `w`, `u`, and `y`, if `w` is the first element of a finite sequence in `r` and `u`, `y` is the last two elements of that sequence, then `y` is the end marker `ends0`."
    },
    "106": {
        "type": "lemma",
        "text": "text\\<open>Since there are some problems with applying the above lemma \n  (seems that simp and auto don't handle equivalence very well), we\n  split \\<open>Order_ZF_2_L1\\<close> into two lemmas.\\<close>\n",
        "assumes": "assumes \"x \\<in> Interval(r,a,b)\"\n  ",
        "using": [
            "assms",
            "Order_ZF_2_L1"
        ],
        "statement": "lemma Order_ZF_2_L1A: assumes \"x \\<in> Interval(r,a,b)\"\n  shows \"\\<langle> a,x\\<rangle> \\<in> r\"  \"\\<langle> x,b\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms  Order_ZF_2_L1 by auto\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1234,
        "informal": " Assuming x is an element of the interval [a, b] defined by real number r, then the ordered pairs <a, x> and <x, b> are both elements of relation r."
    },
    "107": {
        "type": "lemma",
        "text": "text\\<open>For reflexive and antisymmetric relations the interval with equal \n  endpoints consists only of that endpoint.\\<close>\n",
        "assumes": "assumes A1: \"refl(X,r)\" and A2: \"antisym(r)\" and A3: \"a\\<in>X\"\n  ",
        "using": [
            "refl_def",
            "Order_ZF_2_L2",
            "Order_ZF_2_L1A",
            "Fol1_L4"
        ],
        "statement": "lemma Order_ZF_2_L4: \n  assumes A1: \"refl(X,r)\" and A2: \"antisym(r)\" and A3: \"a\\<in>X\"\n  shows \"Interval(r,a,a) = {a}\"\n",
        "proof": "proof\n  from A1 A3 have \"\\<langle> a,a\\<rangle> \\<in> r\" using refl_def by simp\n  with A1 A3 show \"{a} \\<subseteq> Interval(r,a,a)\" using Order_ZF_2_L2 by simp\n  from A2 show \"Interval(r,a,a) \\<subseteq> {a}\" using Order_ZF_2_L1A Fol1_L4\n    by fast\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1239,
        "informal": " Given reflexivity, antisymmetry, and the element a in relation r, the interval [a, a] defined by that relation equals {a}."
    },
    "108": {
        "type": "lemma",
        "text": "text\\<open>A simple rearrangement of four monoid elements transferred from the \\<open>semigr0\\<close> locale: \\<close>\n",
        "assumes": "assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\" \n  ",
        "using": [
            "assms",
            "semigr0_valid_in_monoid0",
            "semigr0.rearr4elem_assoc"
        ],
        "statement": "lemma (in monoid0) rearr4elem_monoid: \n  assumes \"a\\<in>G\"  \"b\\<in>G\"  \"c\\<in>G\"  \"d\\<in>G\" \n  shows \"a\\<oplus>b\\<oplus>(c\\<oplus>d) = a\\<oplus>(b\\<oplus>c)\\<oplus>d\"\n  ",
        "proof": "using assms semigr0_valid_in_monoid0 semigr0.rearr4elem_assoc\n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF",
            "IsarMathLib.Loop_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF.thy",
        "id": 1140,
        "informal": " In the monoid0 theory, if elements a, b, c, and d belong to the set G, then the sum of a with the sum of b and c is equal to the sum of the sum of a and b with d. In other words, associativity of the \\oplus operation holds for the elements of set G."
    },
    "109": {
        "type": "lemma",
        "text": "text\\<open>The class of $a\\in G$ is the neutral \n  element of the quotient $G/H$ iff $a\\in H$.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,P,H)\" and \n  \"a\\<in>G\" and \"r = QuotientGroupRel(G,P,H)\" and \n  \"TheNeutralElement(G//r,QuotientGroupOp(G,P,H)) = e\"\n  ",
        "using": [
            "assms",
            "Group_ZF_2_4_L5C",
            "Group_ZF_2_4_L5D"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L5E: \n  assumes \"IsAnormalSubgroup(G,P,H)\" and \n  \"a\\<in>G\" and \"r = QuotientGroupRel(G,P,H)\" and \n  \"TheNeutralElement(G//r,QuotientGroupOp(G,P,H)) = e\"\n  shows \"r``{a} = e \\<longleftrightarrow> a\\<in>H\"\n  ",
        "proof": "using assms Group_ZF_2_4_L5C  Group_ZF_2_4_L5D\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 556,
        "informal": " Assume G is a group, P and H are subgroups of G such that P is normal in G and H is a subset of P, and a is an element of G. If a belongs to H, then the equivalence class of a in the quotient group G/P under relation r contains the neutral element e. Conversely, if the image of element a under relation r is equal to the neutral element, then a itself belongs to H."
    },
    "110": {
        "type": "definition",
        "text": "text\\<open>Choosing a singleton set, it is considered a point excluded\n  topology. In the following lemmas and theorems, when neccessary\n  it will be considered that \\<open>T\\<noteq>0\\<close> and \\<open>T\\<subseteq>X\\<close>. \n  These cases will appear in the special cases section.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IncludedPoint (\"IncludedPoint _ _\" 90) where\n  \"IncludedPoint X p \\<equiv> IncludedSet(X,{p})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2312,
        "informal": " A point P is included in a set X if and only if P is an element of X."
    },
    "111": {
        "type": "lemma",
        "text": "text\\<open>Distributivity is preserved by restrictions to sets that are closed with\n  respect to both operations.\\<close>\n",
        "assumes": "assumes \"IsDistributive(X,A,M)\"\n  and \"Y\\<subseteq>X\"\n  and \"Y {is closed under} A\" \n  \"Y {is closed under} M\"\n  and \"A\\<^sub>r = restrict(A,Y\\<times>Y)\" \"M\\<^sub>r = restrict(M,Y\\<times>Y)\"\n  ",
        "using": [
            "func_ZF_7_L1",
            "IsDistributive_def"
        ],
        "statement": "lemma func_ZF_7_L2: \n  assumes \"IsDistributive(X,A,M)\"\n  and \"Y\\<subseteq>X\"\n  and \"Y {is closed under} A\" \n  \"Y {is closed under} M\"\n  and \"A\\<^sub>r = restrict(A,Y\\<times>Y)\" \"M\\<^sub>r = restrict(M,Y\\<times>Y)\"\n  shows \"IsDistributive(Y,A\\<^sub>r,M\\<^sub>r)\"\n",
        "proof": "proof -\n  from assms have \"\\<forall>a\\<in>Y.\\<forall>b\\<in>Y.\\<forall>c\\<in>Y. \n    M\\<^sub>r`\\<langle> a,A\\<^sub>r`\\<langle>b,c\\<rangle> \\<rangle> = A\\<^sub>r`\\<langle> M\\<^sub>r`\\<langle>a,b\\<rangle>,M\\<^sub>r`\\<langle>a,c\\<rangle> \\<rangle> \\<and> \n    M\\<^sub>r`\\<langle> A\\<^sub>r`\\<langle>b,c\\<rangle>,a \\<rangle> = A\\<^sub>r`\\<langle> M\\<^sub>r`\\<langle>b,a\\<rangle>,M\\<^sub>r`\\<langle>c,a\\<rangle>\\<rangle>\"\n    using func_ZF_7_L1 by simp\n  then show ?thesis using IsDistributive_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2709,
        "informal": " If X is distributive over binary relations A and M, Y is a subset of X, Y is closed under A and M, and the restrictions of A and M to the cartesian product Y x Y are equal to A\\_r and M\\_r respectively, then Y is distributive over A\\_r and M\\_r."
    },
    "112": {
        "type": "lemma",
        "text": "text\\<open>Induction on integers, version with higher-order increment function.\\<close>\n",
        "assumes": "assumes A1: \"i\\<lsq>k\" and A2: \"Q(i)\"\n  and A3: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m $+ ($# 1))\"\n  ",
        "using": [
            "Int_ZF_3_L2",
            "Int_ZF_2_L1A",
            "zadd_int0"
        ],
        "statement": "lemma (in int0) Int_ZF_3_L7: \n  assumes A1: \"i\\<lsq>k\" and A2: \"Q(i)\"\n  and A3: \"\\<forall>m. i\\<lsq>m \\<and> Q(m) \\<longrightarrow> Q(m $+ ($# 1))\"\n  shows \"Q(k)\"\n",
        "proof": "proof -\n  from A1 obtain n where D1: \"n\\<in>nat\" and D2: \"k = i $+ $# n\"\n    using Int_ZF_3_L2 by auto\n  from A1 have T1: \"i\\<in>\\<int>\" using Int_ZF_2_L1A by simp\n  note \\<open>n\\<in>nat\\<close>\n  moreover from A1 A2 have \"Q(i $+ $#0)\" \n    using Int_ZF_2_L1A zadd_int0 by simp\n  moreover from T1 A3 have \n    \"\\<forall>k\\<in>nat. Q(i $+ ($# k)) \\<longrightarrow> Q(i $+ ($# succ(k)))\"\n    by (rule Int_ZF_3_L6)\n  ultimately have \"Q(i $+ ($# n))\" by (rule ind_on_nat) \n  with D2 show \"Q(k)\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1024,
        "informal": " If i is less than k, and Q(i) holds, and for all m, if i is less than m and Q(m) holds then Q(m + 1) also holds, then Q(k) holds."
    },
    "113": {
        "type": "definition",
        "text": "text\\<open>To define a group we take a monoid and add a requirement \n  that the right inverse needs to exist for every element of the group.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAgroup(G,f) \\<equiv> \n  (IsAmonoid(G,f) \\<and> (\\<forall>g\\<in>G. \\<exists>b\\<in>G. f`\\<langle>g,b\\<rangle> = TheNeutralElement(G,f)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 412,
        "informal": " A set G together with a binary operation f forms a group if and only if G is a monoid under f and for every element g in G, there exists an element b in G such that applying f to g and b yields the neutral element in G."
    },
    "114": {
        "type": "lemma",
        "text": "text\\<open> $T_1$ topological spaces are exactly those in which all singletons are closed.\\<close>\n",
        "assumes": "",
        "using": [
            "Top_3_L9"
        ],
        "statement": "lemma (in topology0) t1_def_alt:\n  shows \"T {is T\\<^sub>1} \\<longleftrightarrow> (\\<forall>x\\<in>\\<Union>T. {x} {is closed in} T)\"\n",
        "proof": "proof\n  let ?X = \"\\<Union>T\"\n  assume T1: \"T {is T\\<^sub>1}\"\n  { fix x assume \"x\\<in>?X\"\n    let ?U = \"?X-{x}\"\n    have \"?U \\<in> T\"\n    proof -\n      let ?W = \"\\<Union>y\\<in>?U.\\<Union>{V\\<in>T. y\\<in>V \\<and> x\\<notin>V}\" \n      { fix y assume \"y\\<in>?U\"\n        with topSpaceAssum have \"(\\<Union>{V\\<in>T. y\\<in>V \\<and> x\\<notin>V}) \\<in> T\"\n          unfolding IsATopology_def by blast\n      } hence \"\\<forall>y\\<in>?U. (\\<Union>{V\\<in>T. y\\<in>V \\<and> x\\<notin>V}) \\<in> T\" by blast\n      with topSpaceAssum have \"?W\\<in>T\" by (rule union_indexed_open)\n      have \"?U = ?W\"\n      proof\n        show \"?W\\<subseteq>?U\" by auto\n        { fix y assume \"y\\<in>?U\"\n          hence \"y\\<in>?X\" and \"y\\<noteq>x\" by auto\n          with T1 \\<open>x\\<in>?X\\<close> have  \"y \\<in> \\<Union>{V\\<in>T. y\\<in>V \\<and> x\\<notin>V}\"\n            unfolding isT1_def by blast\n          hence \"y\\<in>?W\" by blast\n        } thus \"?U \\<subseteq> ?W\" by blast\n      qed\n      with \\<open>?W\\<in>T\\<close> show \"?U\\<in>T\" by simp\n    qed\n    with \\<open>x\\<in>?X\\<close> have \"(?X-?U) {is closed in} T\" and \"?X-?U = {x}\"\n      using Top_3_L9 by auto\n    hence \"{x} {is closed in} T\" by simp\n  } thus \"\\<forall>x\\<in>?X. {x} {is closed in} T\" by blast\nnext\n  let ?X = \"\\<Union>T\" \n  assume scl: \"\\<forall>x\\<in>\\<Union>T. {x} {is closed in} T\"\n  { fix x y assume \"x\\<in>?X\" \"y\\<in>?X\" \"x\\<noteq>y\"\n    let ?U = \"?X-{y}\"\n    from scl \\<open>x\\<in>?X\\<close> \\<open>y\\<in>?X\\<close> \\<open>x\\<noteq>y\\<close> have \"?U \\<in> T\" \"x\\<in>?U \\<and> y\\<notin>?U\"\n      unfolding IsClosed_def by auto\n    then have \"\\<exists>U\\<in>T. (x\\<in>U \\<and> y\\<notin>U)\" by (rule witness_exists)\n  } then show \"T {is T\\<^sub>1}\" unfolding isT1_def by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2028,
        "informal": " A set T is T1 in topology0 if and only if every point in the union of T belongs to the closed set containing that point within T."
    },
    "115": {
        "type": "lemma",
        "text": "text\\<open>The next lemma is Lemma 3 in the Arthan's paper.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"D \\<in> \\<int>\\<^sub>+\"\n  ",
        "using": [
            "Int_ZF_1_5_L3",
            "Int_ZF_2_1_L8",
            "Int_ZF_2_L1A",
            "Int_ZF_2_L15D",
            "int_two_three_are_int",
            "PositiveSet_def",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_5_L2A",
            "Int_ZF_2_3_L1A",
            "Int_ZF_1_1_L4",
            "int_zero_one_are_int",
            "Int_ZF_2_1_L7",
            "Int_ZF_2_L16C",
            "Int_ZF_1_3_L19A",
            "int_ineq_add_sides",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_2_L11",
            "Int_ZF_2_1_L13",
            "Int_ZF_1_3_L13A"
        ],
        "statement": "lemma (in int1) Arthan_Lem_3: \n  assumes A1: \"f\\<in>\\<S>\\<^sub>+\" and A2: \"D \\<in> \\<int>\\<^sub>+\"\n  shows \"\\<exists>M\\<in>\\<int>\\<^sub>+. \\<forall>m\\<in>\\<int>\\<^sub>+. (m\\<ra>\\<one>)\\<cdot>D \\<lsq> f`(m\\<cdot>M)\" \n",
        "proof": "proof -\n  let ?E = \"max\\<delta>(f) \\<ra> D\"\n  let ?A = \"f``(\\<int>\\<^sub>+) \\<inter> \\<int>\\<^sub>+\"\n  from A1 A2 have I: \"D\\<lsq>?E\"\n    using Int_ZF_1_5_L3 Int_ZF_2_1_L8 Int_ZF_2_L1A Int_ZF_2_L15D\n    by simp\n  from A1 A2 have \"?A \\<subseteq> \\<int>\\<^sub>+\"  \"?A \\<notin> Fin(\\<int>)\"  \"\\<two>\\<cdot>?E \\<in> \\<int>\" \n    using int_two_three_are_int Int_ZF_2_1_L8 PositiveSet_def Int_ZF_1_1_L5\n    by auto\n  with A1 have \"\\<exists>M\\<in>\\<int>\\<^sub>+.  \\<two>\\<cdot>?E \\<lsq> f`(M)\"\n    using Int_ZF_1_5_L2A Int_ZF_2_3_L1A by simp\n  then obtain M where II: \"M\\<in>\\<int>\\<^sub>+\"  and III: \"\\<two>\\<cdot>?E \\<lsq> f`(M)\"\n    by auto\n  { fix m assume \"m\\<in>\\<int>\\<^sub>+\" then have A4: \"\\<one>\\<lsq>m\"\n      using Int_ZF_1_5_L3 by simp\n    moreover from II III have \"(\\<one>\\<ra>\\<one>) \\<cdot>?E \\<lsq> f`(\\<one>\\<cdot>M)\"\n      using PositiveSet_def Int_ZF_1_1_L4 by simp\n    moreover have \"\\<forall>k. \n      \\<one>\\<lsq>k \\<and> (k\\<ra>\\<one>)\\<cdot>?E \\<lsq> f`(k\\<cdot>M) \\<longrightarrow> (k\\<ra>\\<one>\\<ra>\\<one>)\\<cdot>?E \\<lsq> f`((k\\<ra>\\<one>)\\<cdot>M)\"\n    proof -\n      { fix k assume A5: \"\\<one>\\<lsq>k\"  and A6: \"(k\\<ra>\\<one>)\\<cdot>?E \\<lsq> f`(k\\<cdot>M)\"\n\twith A1 A2 II have T:\n\t  \"k\\<in>\\<int>\"  \"M\\<in>\\<int>\"  \"k\\<ra>\\<one> \\<in> \\<int>\"  \"?E\\<in>\\<int>\"  \"(k\\<ra>\\<one>)\\<cdot>?E \\<in> \\<int>\"  \"\\<two>\\<cdot>?E \\<in> \\<int>\"\n\t  using Int_ZF_2_L1A PositiveSet_def int_zero_one_are_int \n\t    Int_ZF_1_1_L5 Int_ZF_2_1_L8 by auto\n\tfrom A1 A2 A5 II have \n\t  \"\\<delta>(f,k\\<cdot>M,M) \\<in> \\<int>\"   \"abs(\\<delta>(f,k\\<cdot>M,M)) \\<lsq> max\\<delta>(f)\"   \"\\<zero>\\<lsq>D\"\n\t  using Int_ZF_2_L1A PositiveSet_def Int_ZF_1_1_L5 \n\t    Int_ZF_2_1_L7 Int_ZF_2_L16C by auto\n\twith III A6 have \n\t  \"(k\\<ra>\\<one>)\\<cdot>?E \\<ra> (\\<two>\\<cdot>?E \\<rs> ?E) \\<lsq> f`(k\\<cdot>M) \\<ra> (f`(M) \\<ra> \\<delta>(f,k\\<cdot>M,M))\"\n\t  using Int_ZF_1_3_L19A int_ineq_add_sides by simp\n\twith A1 T have \"(k\\<ra>\\<one>\\<ra>\\<one>)\\<cdot>?E \\<lsq> f`((k\\<ra>\\<one>)\\<cdot>M)\"\n\t  using Int_ZF_1_1_L1 int_zero_one_are_int Int_ZF_1_1_L4 \n\t    Int_ZF_1_2_L11 Int_ZF_2_1_L13 by simp\n      } then show ?thesis by simp\n    qed\n    ultimately have \"(m\\<ra>\\<one>)\\<cdot>?E \\<lsq> f`(m\\<cdot>M)\" by (rule Induction_on_int)\n    with A4 I have \"(m\\<ra>\\<one>)\\<cdot>D \\<lsq> f`(m\\<cdot>M)\" using Int_ZF_1_3_L13A\n      by simp\n  } then have \"\\<forall>m\\<in>\\<int>\\<^sub>+.(m\\<ra>\\<one>)\\<cdot>D \\<lsq> f`(m\\<cdot>M)\" by simp\n  with II show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 895,
        "informal": " Assuming functions f belongs to the subset of positive integers and D is a positive integer, there exists a positive integer M such that for all positive integers m, the product of m raised to one and D is less than or equal to f applied to the product of m and M."
    },
    "116": {
        "type": "lemma",
        "text": "text\\<open>Text expended version of the fact that the set of positive integers \n  is closed under addition\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\\<^sub>+\"  \"b\\<in>\\<int>\\<^sub>+\"  ",
        "using": [
            "assms",
            "pos_int_closed_add",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in int0) pos_int_closed_add_unfolded: \n  assumes \"a\\<in>\\<int>\\<^sub>+\"  \"b\\<in>\\<int>\\<^sub>+\"  shows \"a\\<ra>b \\<in> \\<int>\\<^sub>+\"\n  ",
        "proof": "using assms pos_int_closed_add IsOpClosed_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 800,
        "informal": " Given that both `a` and `b` are natural numbers, it follows that their sum `a + b` is also a natural number."
    },
    "117": {
        "type": "lemma",
        "text": "text\\<open>If a ring has no zero divisors, the square of a nonzero\n  element is positive.\\<close>\n",
        "assumes": "assumes \"HasNoZeroDivs(R,A,M)\" and \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L10",
            "Ring_ZF_1_L12",
            "OrdRing_ZF_3_L14"
        ],
        "statement": "lemma (in ring1) OrdRing_ZF_3_L15: \n  assumes \"HasNoZeroDivs(R,A,M)\" and \"a\\<in>R\"  \"a\\<noteq>\\<zero>\"\n  shows \"\\<zero> \\<lsq> a\\<^sup>2\"  \"a\\<^sup>2 \\<noteq> \\<zero>\"  \"a\\<^sup>2 \\<in> R\\<^sub>+\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L10 Ring_ZF_1_L12 OrdRing_ZF_3_L14\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1591,
        "informal": " If a ring R without zero divisors contains an element a distinct from zero, then a's square is positive and an element of the positive part of the ring."
    },
    "118": {
        "type": "lemma",
        "text": "text\\<open>Properties that require two integers.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_1_L2",
            "ring0.Ring_ZF_1_L4",
            "ring0.Ring_ZF_1_L9",
            "ring0.Ring_ZF_1_L7",
            "ring0.Ring_ZF_1_L7A",
            "Int_ZF_1_L4"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L5: assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \n  \"a\\<ra>b \\<in> \\<int>\" \n  \"a\\<rs>b \\<in> \\<int>\" \n  \"a\\<cdot>b \\<in> \\<int>\"\n  \"a\\<ra>b = b\\<ra>a\" \n  \"a\\<cdot>b = b\\<cdot>a\" \n  \"(\\<rm>b)\\<rs>a = (\\<rm>a)\\<rs>b\" \n  \"(\\<rm>(a\\<ra>b)) = (\\<rm>a)\\<rs>b\"  \n  \"(\\<rm>(a\\<rs>b)) = ((\\<rm>a)\\<ra>b)\"\n  \"(\\<rm>a)\\<cdot>b = \\<rm>(a\\<cdot>b)\" \n  \"a\\<cdot>(\\<rm>b) = \\<rm>(a\\<cdot>b)\"\n  \"(\\<rm>a)\\<cdot>(\\<rm>b) = a\\<cdot>b\"\n  ",
        "proof": "using assms Int_ZF_1_1_L2 ring0.Ring_ZF_1_L4 ring0.Ring_ZF_1_L9\n    ring0.Ring_ZF_1_L7 ring0.Ring_ZF_1_L7A Int_ZF_1_L4 by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 721,
        "informal": " Assuming a and b are integers, it holds that:\n\na > b implies a - b is an integer\na < b implies b - a is an integer\na * b is an integer\na > b if and only if b < a\na * b = b * a\nb * a = a * b\na * (b + c) = (a * b) + (a * c)\na * 1 = a\na * (-b) = -(a * b)\n\nHere, > represents the greater-than relation, * represents multiplication, and in denotes the set membership property."
    },
    "119": {
        "type": "lemma",
        "text": "text\\<open>If a function is continuous, then its restriction is continous in relative\n  topology.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> X\\<^sub>1\" and A2: \"f {is continuous}\"\n  ",
        "using": [
            "IsContinuous_def",
            "fmapAssum",
            "func1_2_L1",
            "RestrictedTo_def"
        ],
        "statement": "lemma (in two_top_spaces0) restr_cont:\n  assumes A1: \"A \\<subseteq> X\\<^sub>1\" and A2: \"f {is continuous}\"\n  shows \"IsContinuous(\\<tau>\\<^sub>1 {restricted to} A, \\<tau>\\<^sub>2,restrict(f,A))\"\n",
        "proof": "proof -\n  let ?g = \"restrict(f,A)\"\n  { fix U assume \"U \\<in> \\<tau>\\<^sub>2\"\n    with A2 have \"f-``(U) \\<in> \\<tau>\\<^sub>1\" using IsContinuous_def by simp\n    moreover from A1 have \"?g-``(U) = f-``(U) \\<inter> A\"\n      using fmapAssum func1_2_L1 by simp\n    ultimately have \"?g-``(U) \\<in> (\\<tau>\\<^sub>1 {restricted to} A)\"\n      using RestrictedTo_def by auto\n  } then show ?thesis using IsContinuous_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2110,
        "informal": " Assuming A is a subset of X1 and f is continuous, the restriction of the continuous function f to subset A is continuous when considered as a function from A to X2 under the two topologies τ1 and τ2."
    },
    "120": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma involving a projection of the set of positive slopes\n  and a logical epression with exclusive or.\\<close>\n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\"\n  and A2: \"R = {AlEqRel``{s}. s\\<in>\\<S>\\<^sub>+}\"\n  and A3: \"(f\\<in>\\<S>\\<^sub>+) Xor (g\\<in>\\<S>\\<^sub>+)\"\n  ",
        "using": [
            "pos_slopes_saturated",
            "Int_ZF_2_1_L9B"
        ],
        "statement": "lemma (in int1) Int_ZF_2_3_L10:\n  assumes A1: \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\"\n  and A2: \"R = {AlEqRel``{s}. s\\<in>\\<S>\\<^sub>+}\"\n  and A3: \"(f\\<in>\\<S>\\<^sub>+) Xor (g\\<in>\\<S>\\<^sub>+)\"\n  shows \"(AlEqRel``{f} \\<in> R) Xor (AlEqRel``{g} \\<in> R)\"\n",
        "proof": "proof -\n  from A1 A2 A3 have \n    \"equiv(\\<S>,AlEqRel)\" \n    \"IsSaturated(AlEqRel,\\<S>\\<^sub>+)\"\n    \"\\<S>\\<^sub>+ \\<subseteq> \\<S>\"\n    \"f\\<in>\\<S>\"  \"g\\<in>\\<S>\"\n    \"R = {AlEqRel``{s}. s\\<in>\\<S>\\<^sub>+}\"\n    \"(f\\<in>\\<S>\\<^sub>+) Xor (g\\<in>\\<S>\\<^sub>+)\"\n    using pos_slopes_saturated Int_ZF_2_1_L9B by auto\n  then show ?thesis by (rule EquivClass_3_L7)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 914,
        "informal": " Assuming `f` and `g` are elements of a set `S`, and `R` is the relation of algebraic equivalence over `S`, if `f` Xor `g` is in `S`, then the algebraic equivalence relations of `f` and `g` are in `R`, and their algebraic equivalence relations are different if and only if `f` and `g` are different.\n\nIn other words, `(AlEqRel {f} in R) xor (AlEqRel {g} in R)` if and only if `f` Xor `g` is in `S`."
    },
    "121": {
        "type": "lemma",
        "text": "text\\<open> Infimum of the set of infima of a collection of sets is infimum of the union. \\<close>\n",
        "assumes": "assumes \n    \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"trans(r)\" \n    \"\\<forall>T\\<in>\\<T>. HasAnInfimum(r,T)\"\n    \"HasAnInfimum(r,{Infimum(r,T).T\\<in>\\<T>})\"\n  ",
        "using": [
            "set_inf_not_empty",
            "inf_in_space(2)",
            "inf_geq_lo_bnd"
        ],
        "statement": "lemma inf_inf:\n  assumes \n    \"r \\<subseteq> X\\<times>X\" \"antisym(r)\" \"trans(r)\" \n    \"\\<forall>T\\<in>\\<T>. HasAnInfimum(r,T)\"\n    \"HasAnInfimum(r,{Infimum(r,T).T\\<in>\\<T>})\"\n  shows \n    \"HasAnInfimum(r,\\<Union>\\<T>)\" and \"Infimum(r,{Infimum(r,T).T\\<in>\\<T>}) = Infimum(r,\\<Union>\\<T>)\"\n",
        "proof": "proof -\n  let ?i = \"Infimum(r,{Infimum(r,T).T\\<in>\\<T>})\"\n  note assms(2)\n  moreover from assms(4,5) have \"\\<Union>\\<T> \\<noteq> 0\" using set_inf_not_empty by blast\n  moreover\n  have \"\\<forall>T\\<in>\\<T>.\\<forall>t\\<in>T. \\<langle>?i,t\\<rangle> \\<in> r\"\n  proof -\n    { fix T t assume \"T\\<in>\\<T>\" \"t\\<in>T\"\n      with assms(1,2,4) have \"\\<langle>Infimum(r,T),t\\<rangle> \\<in> r\"\n        unfolding HasAnInfimum_def using inf_in_space(2) by blast\n      moreover from assms(1,2,5) \\<open>T\\<in>\\<T>\\<close> have \"\\<langle>?i,Infimum(r,T)\\<rangle> \\<in> r\"\n        unfolding HasAnInfimum_def using inf_in_space(2) by blast\n      moreover note assms(3)\n      ultimately have \"\\<langle>?i,t\\<rangle> \\<in> r\" unfolding trans_def by blast\n    } thus ?thesis by simp\n  qed\n  hence I: \"\\<forall>t\\<in>\\<Union>\\<T>. \\<langle>?i,t\\<rangle> \\<in> r\" by auto\n  moreover have J: \"\\<forall>y. (\\<forall>x\\<in>\\<Union>\\<T>. \\<langle>y,x\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>y,?i\\<rangle> \\<in> r\"\n  proof -\n    { fix y x assume A: \"\\<forall>x\\<in>\\<Union>\\<T>. \\<langle>y,x\\<rangle> \\<in> r\"\n      with assms(2,4) have \"\\<forall>a\\<in>{Infimum(r,T).T\\<in>\\<T>}. \\<langle>y,a\\<rangle> \\<in> r\" using inf_geq_lo_bnd\n        by simp\n      with assms(2,5) have \"\\<langle>y,?i\\<rangle> \\<in> r\" by (rule inf_geq_lo_bnd)\n    } thus ?thesis by simp\n  qed \n  ultimately have \"HasAmaximum(r,\\<Inter>a\\<in>\\<Union>\\<T>. r-``{a})\" by (rule inf_glb)\n  then show \"HasAnInfimum(r,\\<Union>\\<T>)\" unfolding HasAnInfimum_def by simp\n  from assms(2) \\<open>\\<Union>\\<T> \\<noteq> 0\\<close> I J show \"?i = Infimum(r,\\<Union>\\<T>)\" by (rule inf_glb)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1310,
        "informal": " Assuming a binary relation `r` is a subsets of the Cartesian product of a set `X` with itself, is antisymmetric and transitive, and has an infimum in every subset `T`, the infimum of `r` over the union of all such subsets also exists, and equals the infimum over all subsets."
    },
    "122": {
        "type": "lemma",
        "text": "text\\<open>The absolute value of the unit is the unit. In the \n  additive totation that would be $|0| = 0$.\\<close>\n",
        "assumes": "",
        "using": [
            "OrderedGroup_ZF_1_L3A",
            "OrderedGroup_ZF_3_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L2A: \n  shows \"\\<bar>\\<one>\\<bar> = \\<one>\" ",
        "proof": "using OrderedGroup_ZF_1_L3A OrderedGroup_ZF_3_L2\n  by simp\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1452,
        "informal": " In the group3 theory of Isabelle/ZF, we have the following lemma:\n\nThe identity element is equal to itself."
    },
    "123": {
        "type": "lemma",
        "text": "text\\<open>A function has the same support as its negative.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>M\"\n  ",
        "using": [
            "fungroup0_valid",
            "group0.inverse_in_group",
            "func1_1_L1",
            "Supp_def",
            "group0_valid",
            "group0.lift_gr_inv_val",
            "group0.group0_2_L8C",
            "group0.group0_2_L8B"
        ],
        "statement": "lemma (in finsupp1) finsupp_neg: assumes A1: \"f: X\\<rightarrow>M\"\n  shows \"supp(f) = supp(GroupInv(X\\<rightarrow>M,\\<A>)`(f))\"\n",
        "proof": "proof -\n  let ?g = \"GroupInv(X\\<rightarrow>M,\\<A>)`(f)\"\n  from A1 have I: \"?g : X\\<rightarrow>M\" \n    using fungroup0_valid group0.inverse_in_group \n    by simp\n  have \"supp(?g) \\<subseteq> supp(f)\"\n  proof -\n    { fix x assume \"x \\<in> supp(?g)\"\n      with I have \"x\\<in>X\" and \"?g`(x) \\<noteq> \\<zero>\"\n\tusing func1_1_L1 Supp_def by auto\n      with A1 have \"x \\<in> supp(f)\"\n\tusing group0_valid group0.lift_gr_inv_val\n\t  group0.group0_2_L8C func1_1_L1 Supp_def\n\tby simp \n    } thus \"supp(?g) \\<subseteq> supp(f)\" by auto\n  qed\n  moreover from A1 I have \"supp(f) \\<subseteq> supp(?g)\"\n    using func1_1_L1 Supp_def group0_valid \n      group0.group0_2_L8B group0.lift_gr_inv_val\n    by auto \n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Group_ZF_2"
        ],
        "source": "IsarMathLib/FinSupp_ZF.thy",
        "id": 186,
        "informal": " Given a function `f` from set `X` to set `M`, the support sets of `f` and its group inverse are equal."
    },
    "124": {
        "type": "theorem",
        "text": "text\\<open>This previous results give us another equivalence of the axiom of \\<open>Q\\<close> choice\nthat is apparently weaker (easier to check) to the previous one.\\<close>\n",
        "assumes": "assumes \"InfCard(Q)\"\n  ",
        "using": [
            "Q_choice_Pow_eq_secon_imp_comp",
            "Q_csuccQ_comp_eq_Q_choice_Pow",
            "Q_disc_is_second_card_csuccQ",
            "Pow_is_top[of",
            "\"Q\"]"
        ],
        "statement": "theorem Q_disc_comp_csuccQ_eq_Q_choice_csuccQ:\n  assumes \"InfCard(Q)\"\n  shows \"(Q{is compact of cardinal}csucc(Q){in}(Pow(Q))) \\<longleftrightarrow> ({the axiom of}Q{choice holds for subsets}(Pow(Q)))\"\n  ",
        "proof": "proof\n  assume \"Q{is compact of cardinal}csucc(Q) {in}Pow(Q)\"\n  with assms show \"{the axiom of}Q{choice holds for subsets}(Pow(Q))\" using Q_choice_Pow_eq_secon_imp_comp Q_csuccQ_comp_eq_Q_choice_Pow\n    by auto\n  next\n  assume \"{the axiom of}Q{choice holds for subsets}(Pow(Q))\"\n  with assms show \"Q{is compact of cardinal}csucc(Q){in}(Pow(Q))\" using Q_disc_is_second_card_csuccQ Q_choice_Pow_eq_secon_imp_comp Pow_is_top[of \"Q\"]\n    by force\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_examples",
            "IsarMathLib.Topology_ZF_examples_1"
        ],
        "source": "IsarMathLib/Topology_ZF_properties.thy",
        "id": 2371,
        "informal": " Assuming Q is an infinite cardinality set, the set Q with the compact element added (Q with a new element being the supremum of all elements in Q) is equal to the set obtained by applying the choice function to the power set of Q."
    },
    "125": {
        "type": "lemma",
        "text": "text\\<open>Note that in the previous definition, it is necessary to state\n $Y$ as the final set because $f$ is also a function to every superset of its range.\n$X$ can be changed by \\<open>domain(f)\\<close> without any change in the definition.\\<close>\n",
        "assumes": "assumes \"\\<FF> {is a filter on} X\" \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "assms(1)",
            "IsFilter_def",
            "image_fun",
            "assms(2)",
            "SatisfiesFilterBase_def",
            "apply_funtype",
            "base_unique_filter_set2",
            "ImageFilter_def",
            "basic_filter",
            "assms"
        ],
        "statement": "lemma base_image_filter:\n  assumes \"\\<FF> {is a filter on} X\" \"f:X\\<rightarrow>Y\"\n  shows \"{f``B .B\\<in>\\<FF>} {is a base filter} (f[\\<FF>]..Y)\" and \"(f[\\<FF>]..Y) {is a filter on} Y\"\n",
        "proof": "proof-\n  {\n    assume \"0 \\<in> {f``B .B\\<in>\\<FF>}\"\n    then obtain B where \"B\\<in>\\<FF>\" and f_B:\"f``B=0\" by auto\n    then have \"B\\<in>Pow(X)\" using assms(1) IsFilter_def by auto\n    then have \"f``B={f`b. b\\<in>B}\" using image_fun assms(2) by auto\n    with f_B have \"{f`b. b\\<in>B}=0\" by auto\n    then have \"B=0\" by auto\n    with \\<open>B\\<in>\\<FF>\\<close> have \"False\" using IsFilter_def assms(1) by auto\n  }\n  then have \"0\\<notin>{f``B .B\\<in>\\<FF>}\" by auto\n  moreover\n  from assms(1) obtain S where \"S\\<in>\\<FF>\" using IsFilter_def by auto\n  then have \"f``S\\<in>{f``B .B\\<in>\\<FF>}\" by auto\n  then have nA:\"{f``B .B\\<in>\\<FF>}\\<noteq>0\" by auto\n  moreover\n  {\n    fix A B\n    assume \"A\\<in>{f``B .B\\<in>\\<FF>}\" and \"B\\<in>{f``B .B\\<in>\\<FF>}\"\n    then obtain AB BB where \"A=f``AB\" \"B=f``BB\" \"AB\\<in>\\<FF>\" \"BB\\<in>\\<FF>\" by auto\n    then have \"A\\<inter>B=(f``AB)\\<inter>(f``BB)\" by auto\n    then have I: \"f``(AB\\<inter>BB)\\<subseteq>A\\<inter>B\" by auto\n    moreover\n    from assms(1) I \\<open>AB\\<in>\\<FF>\\<close>\\<open>BB\\<in>\\<FF>\\<close> have \"AB\\<inter>BB\\<in>\\<FF>\" using IsFilter_def by auto\n    ultimately have \"\\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D\\<subseteq>A\\<inter>B\" by auto\n  }\n  then have \"\\<forall>A\\<in>{f``B .B\\<in>\\<FF>}. \\<forall>B\\<in>{f``B .B\\<in>\\<FF>}. \\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D\\<subseteq>A\\<inter>B\" by auto\n  ultimately have sbc:\"{f``B .B\\<in>\\<FF>} {satisfies the filter base condition}\" \n    using SatisfiesFilterBase_def by auto\n  moreover\n  {\n    fix t\n    assume \"t\\<in>{f``B . B\\<in>\\<FF>}\"\n    then obtain B where \"B\\<in>\\<FF>\" and im_def:\"f``B=t\" by auto\n    with assms(1) have \"B\\<in>Pow(X)\" unfolding IsFilter_def by auto\n    with im_def assms(2) have \"t={f`x. x\\<in>B}\" using image_fun by auto\n    with assms(2) \\<open>B\\<in>Pow(X)\\<close> have \"t\\<subseteq>Y\" using apply_funtype by auto\n    }\n  then have nB:\"{f``B . B\\<in>\\<FF>}\\<subseteq>Pow(Y)\" by auto\n  ultimately\n  have \"(({f``B .B\\<in>\\<FF>} {is a base filter} {A \\<in> Pow(Y) . \\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D \\<subseteq> A}) \\<and> (\\<Union>{A \\<in> Pow(Y) . \\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D \\<subseteq> A}=Y))\" using base_unique_filter_set2 \n    by force\n  then have \"{f``B .B\\<in>\\<FF>} {is a base filter} {A \\<in> Pow(Y) . \\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D \\<subseteq> A}\" by auto\n  with assms show \"{f``B .B\\<in>\\<FF>} {is a base filter} (f[\\<FF>]..Y)\" using ImageFilter_def  by auto\n  moreover\n  note sbc\n  moreover\n  {\n    from nA obtain D where I: \"D\\<in>{f``B .B\\<in>\\<FF>}\" by blast\n    moreover from I nB have \"D\\<subseteq>Y\" by auto\n    ultimately have \"Y\\<in>{A\\<in>Pow(Y). \\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D\\<subseteq>A}\" by auto\n  }\n  then have \"\\<Union>{A\\<in>Pow(Y). \\<exists>D\\<in>{f``B .B\\<in>\\<FF>}. D\\<subseteq>A}=Y\" by auto\n  ultimately show \"(f[\\<FF>]..Y) {is a filter on} Y\" using basic_filter\n    ImageFilter_def assms by auto \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4",
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_6.thy",
        "id": 2228,
        "informal": " If X has a filter F and function f maps X to Y, then the image filter {f(B) | B is in F} of F under f is a base filter of Y, and f(F) is a filter on Y."
    },
    "126": {
        "type": "corollary",
        "text": "text\\<open>A special case of \\<open>OrdRing_ZF_1_L4A\\<close> when one of the\n  constants is $0$. This is useful for many proofs by cases.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>R\" \n  ",
        "using": [
            "Ring_ZF_1_L2"
        ],
        "statement": "corollary (in ring1) ord_ring_split2: assumes A1: \"a\\<in>R\" \n  shows \"a\\<lsq>\\<zero> \\<or> (\\<zero>\\<lsq>a \\<and> a\\<noteq>\\<zero>)\"\n",
        "proof": "proof -\n  { from A1 have  I: \"a\\<in>R\"  \"\\<zero>\\<in>R\"\n      using Ring_ZF_1_L2 by auto \n    moreover assume A2: \"\\<not>(a\\<lsq>\\<zero>)\"\n    ultimately have \"\\<zero>\\<lsq>a\" by (rule OrdRing_ZF_1_L4A)\n    moreover from I A2 have \"a\\<noteq>\\<zero>\" by (rule OrdRing_ZF_1_L4A)\n    ultimately have \"\\<zero>\\<lsq>a \\<and> a\\<noteq>\\<zero>\" by simp}\n  then show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1544,
        "informal": " In the ring `ring1`, if an element `a` is a member of the ring, then `a` is less than zero or zero is less than `a` but `a` is not equal to zero."
    },
    "127": {
        "type": "lemma",
        "text": "text\\<open>If a function is equal to an expression $b(x)$ on $X$, then it has to be\n  of the form $\\{ \\langle x, b(x)\\rangle | x\\in X\\}$. \\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \"\\<forall>x\\<in>X. f`(x) = b(x)\"\n  ",
        "using": [
            "fun_is_set_of_pairs"
        ],
        "statement": "lemma func_eq_set_of_pairs: assumes \"f:X\\<rightarrow>Y\" \"\\<forall>x\\<in>X. f`(x) = b(x)\"\n  shows \"f = {\\<langle>x, b(x)\\<rangle>. x \\<in> X}\" \n",
        "proof": "proof -\n  from assms(1) have \"f = {\\<langle>x, f`(x)\\<rangle>. x \\<in> X}\" using fun_is_set_of_pairs\n    by simp\n  with assms(2) show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2594,
        "informal": " If function `f` from `X` to `Y` assigns the same value `b(x)` to every `x` in `X`, then `f` is equal to the set of pairs `{<xy>. x in X}` where the `xy`-th element is `x` and the corresponding value is `b(x)`."
    },
    "128": {
        "type": "theorem",
        "text": "text\\<open>The union of two regular languages\nis a regular language.\\<close>\n",
        "assumes": "assumes \"Finite(\\<Sigma>)\"\n  and \"L1{is a regular language on}\\<Sigma>\"\n  and \"L2{is a regular language on}\\<Sigma>\"\n",
        "using": [
            "regular_is_language[OF",
            "assms(1)]",
            "assms(2,3)",
            "IsALanguage_def[OF",
            "regular_opp[OF",
            "assms(1,2)].",
            "have",
            "B:\"(Lists(\\<Sigma>)-L2)",
            "{is",
            "a",
            "regular",
            "language",
            "on}\\<Sigma>\"",
            "assms(1,3)].",
            "from",
            "A",
            "B",
            "\"((Lists(\\<Sigma>)-L1)\\<inter>(Lists(\\<Sigma>)-L2))",
            "regular_intersect[OF"
        ],
        "statement": "theorem regular_union:\n  assumes \"Finite(\\<Sigma>)\"\n  and \"L1{is a regular language on}\\<Sigma>\"\n  and \"L2{is a regular language on}\\<Sigma>\"\nshows \"(L1\\<union>L2) {is a regular language on}\\<Sigma>\"\n",
        "proof": "proof-\n  have \"L1\\<union>L2 = Lists(\\<Sigma>)-((Lists(\\<Sigma>)-L1)\\<inter>(Lists(\\<Sigma>)-L2))\" using regular_is_language[OF assms(1)]\n    assms(2,3) unfolding IsALanguage_def[OF assms(1)] by auto\n  moreover\n  have A:\"(Lists(\\<Sigma>)-L1) {is a regular language on}\\<Sigma>\" using regular_opp[OF assms(1,2)].\n  have B:\"(Lists(\\<Sigma>)-L2) {is a regular language on}\\<Sigma>\" using regular_opp[OF assms(1,3)].\n  from A B have \"((Lists(\\<Sigma>)-L1)\\<inter>(Lists(\\<Sigma>)-L2)) {is a regular language on}\\<Sigma>\" using regular_intersect[OF assms(1)] by auto\n  then have \"(Lists(\\<Sigma>)-((Lists(\\<Sigma>)-L1)\\<inter>(Lists(\\<Sigma>)-L2))) {is a regular language on}\\<Sigma>\" using regular_opp[OF assms(1)] by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 300,
        "informal": " If $\\Sigma$ is finite and $L_1$ and $L_2$ are regular languages over $\\Sigma$, then $L_1 \\cup L_2$ is a regular language over $\\Sigma$."
    },
    "129": {
        "type": "lemma",
        "text": "text\\<open>Composition of left translations is a left translation by the product.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" \"h\\<in>G\" \"a\\<in>G\" and \n  A2: \"T\\<^sub>g = LeftTranslation(G,P,g)\"  \"T\\<^sub>h = LeftTranslation(G,P,h)\"\n  ",
        "using": [
            "group_oper_fun",
            "apply_funtype",
            "group0_5_L2",
            "group_oper_assoc"
        ],
        "statement": "lemma (in group0) group0_5_L4: assumes A1: \"g\\<in>G\" \"h\\<in>G\" \"a\\<in>G\" and \n  A2: \"T\\<^sub>g = LeftTranslation(G,P,g)\"  \"T\\<^sub>h = LeftTranslation(G,P,h)\"\n  shows \n  \"T\\<^sub>g`(T\\<^sub>h`(a)) = g\\<cdot>h\\<cdot>a\"\n  \"T\\<^sub>g`(T\\<^sub>h`(a)) = LeftTranslation(G,P,g\\<cdot>h)`(a)\"\n",
        "proof": "proof -\n  from A1 have I: \"h\\<cdot>a\\<in>G\"  \"g\\<cdot>h\\<in>G\"\n    using group_oper_fun apply_funtype by auto\n  with A1 A2 show \"T\\<^sub>g`(T\\<^sub>h`(a)) = g\\<cdot>h\\<cdot>a\"\n    using group0_5_L2 group_oper_assoc by simp\n  with A1 A2 I show \n    \"T\\<^sub>g`(T\\<^sub>h`(a)) = LeftTranslation(G,P,g\\<cdot>h)`(a)\"\n    using group0_5_L2 group_oper_assoc by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 485,
        "informal": " Given that all items are elements of a group G, and g and h have left translations T\\_g and T\\_h respectively, then T\\_g applied to T\\_h(a) is equal to g * h * a, and also equivalent to the left translation of g * h on a."
    },
    "130": {
        "type": "lemma",
        "text": "text\\<open>Another technical condition for the composition of a slope and \n  an integer (embedding) to be \"less  or equal\" (in the sense apriopriate \n  for slopes) than embedding of another integer.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> \\<int>\"  \"M \\<in> \\<int>\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+.  f`(N\\<cdot>n) \\<lsq> M\\<cdot>n \"\n  ",
        "using": [
            "Int_ZF_2_5_L1",
            "Int_ZF_2_1_L11",
            "PositiveSet_def",
            "Int_ZF_2_1_L10",
            "Int_ZF_2_3_L4C"
        ],
        "statement": "lemma (in int1) Int_ZF_2_5_L9: \n  assumes A1: \"f \\<in> \\<S>\" and A2: \"N \\<in> \\<int>\"  \"M \\<in> \\<int>\" and\n  A3: \"\\<forall>n\\<in>\\<int>\\<^sub>+.  f`(N\\<cdot>n) \\<lsq> M\\<cdot>n \"\n  shows \"f\\<circ>(N\\<^sup>S) \\<sim> (M\\<^sup>S) \\<or> (M\\<^sup>S) \\<fp> (\\<fm>(f\\<circ>(N\\<^sup>S))) \\<in> \\<S>\\<^sub>+\"\n",
        "proof": "proof -\n  from A1 A2 have \"f\\<circ>(N\\<^sup>S) \\<in> \\<S>\"  \"M\\<^sup>S \\<in> \\<S>\"  \n    using Int_ZF_2_5_L1 Int_ZF_2_1_L11 by auto\n  moreover from A1 A2 A3 have \"\\<forall>n\\<in>\\<int>\\<^sub>+. (f\\<circ>(N\\<^sup>S))`(n) \\<lsq> (M\\<^sup>S)`(n) \"\n    using Int_ZF_2_5_L1 PositiveSet_def Int_ZF_2_1_L10\n    by simp\n  ultimately show ?thesis using Int_ZF_2_3_L4C\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 940,
        "informal": " Given a function f in set S, an integer N, and an integer M such that:\n1. f belongs to set S,\n2. N, M are integers,\n3. For all n in integers, f(N * n) is less than or equal to M * n\n\nThen, the following holds true in the set of integers:\n\neither (f^S = M^S) or (M^S is the successor of (f^S) applied to itself) belongs to the negation of set S."
    },
    "131": {
        "type": "lemma",
        "text": "text\\<open>Formula for the tail of a list defined by an expression:\\<close>\n",
        "assumes": "assumes \"n \\<in> nat\" and \"\\<forall>k \\<in> n #+ 1. q(k) \\<in> X\"\n  ",
        "using": [
            "tail_as_set",
            "succ_ineq1",
            "elem_nat_is_nat(2)",
            "succ_add_one(1)"
        ],
        "statement": "lemma tail_formula: assumes \"n \\<in> nat\" and \"\\<forall>k \\<in> n #+ 1. q(k) \\<in> X\"\n  shows \"Tail({\\<langle>k,q(k)\\<rangle>. k \\<in> n #+ 1}) = {\\<langle>k,q(k #+ 1)\\<rangle>. k \\<in> n}\"\n",
        "proof": "proof -\n  let ?a = \"{\\<langle>k,q(k)\\<rangle>. k \\<in> n #+ 1}\"\n  from assms(2) have \"?a : n #+ 1 \\<rightarrow> X\"\n    by (rule ZF_fun_from_total)\n  with assms(1) have \"Tail(?a) = {\\<langle>k,?a`(k #+ 1)\\<rangle>. k\\<in>n}\"\n    using tail_as_set by simp\n  moreover have \"\\<forall>k\\<in>n. ?a`(k #+ 1) = q(k #+ 1)\"\n  proof - \n    { fix k assume \"k\\<in>n\"\n      with assms(1) have \"k #+ 1 \\<in> n #+ 1\"\n        using succ_ineq1 elem_nat_is_nat(2) succ_add_one(1) \n        by simp\n      then have \"?a`(k #+ 1) = q(k #+ 1)\"\n        by (rule ZF_fun_from_tot_val1)\n    } thus ?thesis by simp\n  qed\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 228,
        "informal": " Given a natural number n and a relation X such that for all k in the successor of n, q(k) is an element of X, then the tail of the list [(k, q(k)) | k <= n + 1] is equivalent to the list [(k, q(k + 1)) | k <= n]."
    },
    "132": {
        "type": "lemma",
        "text": "text\\<open>Having two continuous mappings $f,g$ we can construct a third one with values\n  in the cartesian product of the codomains of $f,g$, \n  defined by $x\\mapsto \\langle f(x),g(x) \\rangle$. \\<close>\n",
        "assumes": "assumes \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"g:X\\<^sub>1\\<rightarrow>X\\<^sub>3\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>3,g)\"\n  defines \"h \\<equiv> {\\<langle>x,\\<langle>f`(x),g`(x)\\<rangle>\\<rangle>. x\\<in>X\\<^sub>1}\"\n  ",
        "using": [
            "vimage_prod",
            "Top_1_4_T1(1,3)",
            "two_top_spaces0_def",
            "Top_1_4_T1(2)"
        ],
        "statement": "lemma (in prod_top_spaces0) cont_funcs_prod: \n  assumes \"f:X\\<^sub>1\\<rightarrow>X\\<^sub>2\" \"g:X\\<^sub>1\\<rightarrow>X\\<^sub>3\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>3,g)\"\n  defines \"h \\<equiv> {\\<langle>x,\\<langle>f`(x),g`(x)\\<rangle>\\<rangle>. x\\<in>X\\<^sub>1}\"\n  shows \"IsContinuous(\\<tau>\\<^sub>1,ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3),h)\"\n",
        "proof": "proof -\n  let ?B = \"ProductCollection(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3)\"\n  have \n    \"two_top_spaces0(\\<tau>\\<^sub>1,ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3),h)\"\n    \"?B {is a base for} ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3)\"\n     \"\\<forall>W\\<in>?B. h-``(W) \\<in> \\<tau>\\<^sub>1\"\n  proof -\n    from tau1_is_top tau2_is_top tau3_is_top assms(1,2,5)\n      show \"two_top_spaces0(\\<tau>\\<^sub>1,ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3),h)\"\n        using vimage_prod Top_1_4_T1(1,3) unfolding two_top_spaces0_def \n        by simp\n    from tau2_is_top tau3_is_top show\"?B {is a base for} ProductTopology(\\<tau>\\<^sub>2,\\<tau>\\<^sub>3)\"\n      using Top_1_4_T1(2) by simp\n    from tau1_is_top assms show \"\\<forall>W\\<in>?B. h-``(W) \\<in> \\<tau>\\<^sub>1\"\n      unfolding ProductCollection_def IsContinuous_def IsATopology_def\n      using vimage_prod by simp\n  qed\n  then show ?thesis by (rule two_top_spaces0.Top_ZF_2_1_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2120,
        "informal": " Assumes that:\n- f and g are continuous functions from X₁ to X₂ and X₁ to X₃, respectively.\n- <tau>₁ is a topology on X₁.\n- <tau>₂ and <tau>₃ are topologies on X₂ and X₃, respectively.\n\nDefines h as: the product of f and g, i.e., the function that maps each element x from X₁ to the pair <(f(x), g(x))>.\n\nConclude that:\n- The function h is continuous from X₁ with the topology <tau>₁ to the product topology <tau>₂ × <tau>₃ on X₂ × X₃."
    },
    "133": {
        "type": "lemma",
        "text": "text\\<open> The product of sets operation is associative.\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"C\\<subseteq>G\"\n  ",
        "using": [
            "lift_subset_assoc"
        ],
        "statement": "lemma (in group4) interval_prod_assoc: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"C\\<subseteq>G\"\n  shows \"A\\<sdot>B\\<sdot>C = A\\<sdot>(B\\<sdot>C)\"\n",
        "proof": "proof -\n  from groupAssum have \"(P {lifted to subsets of} G) {is associative on} Pow(G)\" \n    unfolding IsAgroup_def IsAmonoid_def using lift_subset_assoc by simp\n  with assms show ?thesis unfolding IsAssociative_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 513,
        "informal": " In the group4 theory, if sets A, B, and C are all subsets of set G, then the product of sets A and the product of sets B and C are equal to the product of sets A and the set obtained by taking the product of sets B and C."
    },
    "134": {
        "type": "lemma",
        "text": "text\\<open>What are the values of a sum of slopes?\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" and \"m\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L12"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L12B: assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\" and \"m\\<in>\\<int>\"\n  shows \"(s\\<fp>r)`(m) = s`(m) \\<ra> r`(m)\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_2_L12\n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 861,
        "informal": " if s and r are elements of a set S, and m is an integer, then s applied to m functionally composes with r applied to m, resulting in the same value as applying s directly to m."
    },
    "135": {
        "type": "lemma",
        "text": "text\\<open>A technical lemma about graphs of functions: if we have two disjoint sets $A$ and $B$\n  then the cartesian product of the inverse image of $A$ and $B$ is disjoint\n  with (the graph of) $f$.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \"A\\<inter>B = 0\"\n  ",
        "using": [
            "fun_is_set_of_pairs",
            "func1_1_L15"
        ],
        "statement": "lemma vimage_prod_dis_graph: assumes \"f:X\\<rightarrow>Y\" \"A\\<inter>B = 0\"\n  shows \"f-``(A)\\<times>B \\<inter> f = 0\"\n",
        "proof": "proof -\n  { assume \"f-``(A)\\<times>B \\<inter> f \\<noteq> 0\"\n    then obtain p where \"p \\<in> f-``(A)\\<times>B\" and \"p\\<in>f\" by blast\n    from assms(1) \\<open>p\\<in>f\\<close> have \"p \\<in> {\\<langle>x, f`(x)\\<rangle>. x \\<in> X}\" \n      using fun_is_set_of_pairs by simp\n    then obtain x where \"p = \\<langle>x, f`(x)\\<rangle>\" by blast\n    with assms \\<open>p \\<in> f-``(A)\\<times>B\\<close> have False using func1_1_L15 by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2600,
        "informal": " If function f from X to Y and sets A and B intersect to empty, then the image of A under f multiplied by B intersects with the image of f empty."
    },
    "136": {
        "type": "lemma",
        "text": "text\\<open>A criterion for when a set defined by comprehension is a singleton.\\<close>\n",
        "assumes": "assumes A1: \"y\\<in>X\" and A2: \"\\<forall>x\\<in>X. \\<forall>y\\<in>X. P(x) = P(y)\"\n  ",
        "using": [],
        "statement": "lemma singleton_comprehension: \n  assumes A1: \"y\\<in>X\" and A2: \"\\<forall>x\\<in>X. \\<forall>y\\<in>X. P(x) = P(y)\"\n  shows \"(\\<Union>{P(x). x\\<in>X}) = P(y)\"\n",
        "proof": "proof - \n  let ?A = \"{P(x). x\\<in>X}\"\n  have \"\\<exists>! c. c \\<in> ?A\"\n  proof\n    from A1 show \"\\<exists>c. c \\<in> ?A\" by auto\n  next\n    fix a b assume \"a \\<in> ?A\" and \"b \\<in> ?A\"\n    then obtain x t where \n      \"x \\<in> X\" \"a = P(x)\" and \"t \\<in> X\" \"b = P(t)\"\n      by auto\n    with A2 show \"a=b\" by blast\n  qed\n  then have \"(\\<Union>?A) \\<in> ?A\" by (rule singleton_extract)\n  then obtain x where \"x \\<in> X\" and \"(\\<Union>?A) = P(x)\"\n    by auto\n  from A1 A2 \\<open>x \\<in> X\\<close> have \"P(x) = P(y)\"\n    by blast\n  with \\<open>(\\<Union>?A) = P(x)\\<close> show \"(\\<Union>?A) = P(y)\" by simp\nqed\n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2518,
        "informal": " If an element y is in a set X, and for all x in X, the element x shares the same property P with y, then the singleton set {x | P(x) = P(y)} equals the property P applied to y."
    },
    "137": {
        "type": "lemma",
        "text": "text\\<open>If exactly one of $p,q,r$ holds and $p$ is not true, then\n  $q$ or $r$.\\<close>\n",
        "assumes": "assumes A1: \"\\<not>p\" and A2: \"Exactly_1_of_3_holds(p,q,r)\" \n  ",
        "using": [],
        "statement": "lemma Fol1_L6: \n  assumes A1: \"\\<not>p\" and A2: \"Exactly_1_of_3_holds(p,q,r)\" \n  shows \"q\\<or>r\"\n",
        "proof": "proof -\n  from A2 have  \n    \"(p\\<or>q\\<or>r) \\<and> (p \\<longrightarrow> \\<not>q \\<and> \\<not>r) \\<and> (q \\<longrightarrow> \\<not>p \\<and> \\<not>r) \\<and> (r \\<longrightarrow> \\<not>p \\<and> \\<not>q)\"\n    unfolding Exactly_1_of_3_holds_def by fast\n  hence \"p \\<or> q \\<or> r\" by blast\n  with A1 show \"q \\<or> r\" by simp\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 359,
        "informal": " If not p and exactly one of p, q, r holds, then q or r."
    },
    "138": {
        "type": "corollary",
        "text": "text\\<open>The product of closed sets, is closed in the product topology.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\" \"S{is a topology}\" \"A{is closed in}T\"\"B{is closed in}S\"\n  ",
        "using": [
            "Top_1_4_T1(3)",
            "assms(1,2)",
            "topology0.Top_3_L8",
            "topology0_def",
            "cl_product",
            "sub",
            "sub1",
            "Top_1_4_T1(1)"
        ],
        "statement": "corollary closed_product:\n  assumes \"T{is a topology}\" \"S{is a topology}\" \"A{is closed in}T\"\"B{is closed in}S\"\n  shows \"(A\\<times>B) {is closed in}ProductTopology(T,S)\"\n",
        "proof": "proof-\n  from assms(3,4) have sub:\"A\\<subseteq>\\<Union>T\"\"B\\<subseteq>\\<Union>S\" unfolding IsClosed_def by auto\n  then have \"A\\<times>B\\<subseteq>\\<Union>T\\<times>\\<Union>S\" by auto\n  then have sub1:\"A\\<times>B\\<subseteq>\\<Union>ProductTopology(T,S)\" using Top_1_4_T1(3) assms(1,2) by auto\n  from sub assms have \"Closure(A,T)=A\"\"Closure(B,S)=B\" using topology0.Top_3_L8\n    unfolding topology0_def by auto\n  then have \"Closure(A\\<times>B,ProductTopology(T,S))=A\\<times>B\" using cl_product\n    assms(1,2) sub by auto\n  then show ?thesis using topology0.Top_3_L8 unfolding topology0_def\n    using sub1 Top_1_4_T1(1) assms(1,2) by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2064,
        "informal": " If T and S are topology spaces, and A is a closed set in T and B is a closed set in S, then the product A × B is a closed set in the product topology of T and S."
    },
    "139": {
        "type": "lemma",
        "text": "text\\<open>The next lemma interprets the definition the other way.\\<close>\n",
        "assumes": "assumes A1: \"m \\<lsq> n\" \n  ",
        "using": [
            "IntegerOrder_def"
        ],
        "statement": "lemma (in int0) Int_ZF_2_L1A: assumes A1: \"m \\<lsq> n\" \n  shows \"m $\\<le> n\" \"m\\<in>\\<int>\" \"n\\<in>\\<int>\"\n",
        "proof": "proof -\n  from A1 have \"\\<langle> m,n\\<rangle> \\<in> {p\\<in>\\<int>\\<times>\\<int>. fst(p) $\\<le> snd(p)}\"\n    using IntegerOrder_def by simp\n  thus \"m $\\<le> n\"  \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 967,
        "informal": " Assuming m is less than n, show that m and n are natural numbers. Furthermore, m is less than or equal to n."
    },
    "140": {
        "type": "lemma",
        "text": "text\\<open>Interior is open.\\<close>\n",
        "assumes": "",
        "using": [
            "IsATopology_def",
            "Interior_def"
        ],
        "statement": "lemma (in topology0) Top_2_L2: shows \"int(A) \\<in> T\"\n",
        "proof": "proof -\n  have \"{U\\<in>T. U\\<subseteq>A} \\<in> Pow(T)\" by auto\n  with topSpaceAssum show \"int(A) \\<in> T\" \n    using IsATopology_def Interior_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 1999,
        "informal": " In the context of the `topology0` theory, the statement \"`int(A) \\<in> T`\" holds, where `int(A)` denotes the interior of set `A` and `T` is a topology. Therefore, the interior of set `A` is an element of the topology `T`."
    },
    "141": {
        "type": "corollary",
        "text": "text\\<open>Since $T_2$ is an hereditary property, we can apply the previous lemma.\\<close>\n",
        "assumes": "",
        "using": [
            "subspace_of_subspace",
            "s(2)",
            "s(1)",
            "T2_here"
        ],
        "statement": "corollary (in topology0) loc_T2:\n  shows \"(T{is locally-T\\<^sub>2}) \\<longleftrightarrow> (\\<forall>x\\<in>\\<Union>T. \\<exists>A\\<in>T. x\\<in>A\\<and>(T{restricted to}A){is T\\<^sub>2})\"\n",
        "proof": "proof-\n  {\n    fix TT B A assume TT:\"TT{is a topology}\" \"(TT{restricted to}B){is T\\<^sub>2}\" \"A\\<in>TT\"\"B\\<in>Pow(\\<Union>TT)\"\n    then have s:\"B\\<inter>A\\<subseteq>B\"\"B\\<subseteq>\\<Union>TT\" by auto\n    then have \"(TT{restricted to}(B\\<inter>A))=(TT{restricted to}B){restricted to}(B\\<inter>A)\" using subspace_of_subspace\n      by auto moreover\n    have \"\\<Union>(TT{restricted to}B)=B\" unfolding RestrictedTo_def using s(2) by auto\n    then have \"B\\<inter>A\\<subseteq>\\<Union>(TT{restricted to}B)\" using s(1) by auto moreover\n    note TT(2) ultimately have \"(TT{restricted to}(B\\<inter>A)){is T\\<^sub>2}\" using T2_here\n      by auto\n  }\n  then have \"\\<forall>TT. \\<forall>B\\<in>Pow(\\<Union>TT). \\<forall>A\\<in>TT. TT{is a topology}\\<and>(TT{restricted to}B){is T\\<^sub>2} \\<longrightarrow> (TT{restricted to}(B\\<inter>A)){is T\\<^sub>2}\"\n    by auto\n  with her_P_is_loc_P[where P=\"\\<lambda>A. \\<lambda>TT. (TT{restricted to}A){is T\\<^sub>2}\"] show ?thesis unfolding IsLocallyT2_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2391,
        "informal": " In the topology0 theory, a set T is locally T2 if and only if for every x in the union of T, there exists an A in T such that x is in A and the sub-set A restricted to A itself is a T2 set."
    },
    "142": {
        "type": "theorem",
        "text": "text\\<open>The first element of the inductive sequence starting at $x$ and generated by $f$\n  is indeed $x$.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"\n  ",
        "using": [
            "fin_indseq_props",
            "restrict_if",
            "indseq_restr_eq"
        ],
        "statement": "theorem indseq_valat0: assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"\n  shows \"InductiveSequence(x,f)`(0) = x\"\n",
        "proof": "proof -\n  let ?a = \"InductiveSequence(x,f)\"\n  let ?b = \"InductiveSequenceN(x,f,0)\"\n  have T: \"0\\<in>nat\"  \"0 \\<in> succ(0)\" by auto\n  with A1 A2 have \"?b`(0) = x\" \n    using fin_indseq_props by simp\n  moreover from T have \"restrict(?a,succ(0))`(0) = ?a`(0)\"\n    using restrict_if by simp\n  moreover from A1 A2 T have \n    \"restrict(?a,succ(0)) = ?b\"\n    using indseq_restr_eq by simp\n  ultimately show \"?a`(0) = x\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 676,
        "informal": " Given a function `f: X -> X` and an element `x in X`, the value of the `0`th step of the induction sequence `InductiveSequence(x,f)` is equal to `x`."
    },
    "143": {
        "type": "lemma",
        "text": "text\\<open>First we will consider the question of existence and uniqueness \n  of finite inductive sequences. The proof\n  is by induction and the next lemma is the $P(0)$ step. To understand the notation\n  recall that for natural numbers in set theory we have $n = \\{0,1,..,n-1\\}$ and\n  \\<open>succ(n)\\<close>$ = \\{0,1,..,n\\}$.\\<close>\n",
        "assumes": "assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"\n  ",
        "using": [
            "func_singleton_pair",
            "singleton_fun",
            "func1_1_L1B",
            "singleton_apply"
        ],
        "statement": "lemma indseq_exun0: assumes A1: \"f: X\\<rightarrow>X\" and A2: \"x\\<in>X\"\n  shows \n  \"\\<exists>! a. a: succ(0) \\<rightarrow> X \\<and> a`(0) = x \\<and> ( \\<forall>k\\<in>0. a`(succ(k)) = f`(a`(k)) )\"\n",
        "proof": "proof\n  fix a b\n  assume A3:  \n    \"a: succ(0) \\<rightarrow> X \\<and> a`(0) = x \\<and> ( \\<forall>k\\<in>0. a`(succ(k)) = f`(a`(k)) )\"\n    \"b: succ(0) \\<rightarrow> X \\<and> b`(0) = x \\<and> ( \\<forall>k\\<in>0. b`(succ(k)) = f`(b`(k)) )\"\n  moreover have \"succ(0) = {0}\" by auto\n  ultimately have \"a: {0} \\<rightarrow> X\"  \"b: {0} \\<rightarrow> X\" by auto\n  then have \"a = {\\<langle>0, a`(0)\\<rangle>}\"   \"b = {\\<langle>0, b`(0)\\<rangle>}\" using func_singleton_pair\n    by auto\n  with A3 show \"a=b\" by simp\nnext \n  let ?a = \"{\\<langle>0,x\\<rangle>}\"\n  have \"?a : {0} \\<rightarrow> {x}\" using singleton_fun by simp\n  moreover from A1 A2 have \"{x} \\<subseteq> X\" by simp\n  ultimately have \"?a : {0} \\<rightarrow> X\"\n    using func1_1_L1B by blast\n  moreover have \"{0} = succ(0)\" by auto\n  ultimately have \"?a : succ(0) \\<rightarrow> X\" by simp\n  with A1 show \n    \"\\<exists> a. a: succ(0) \\<rightarrow> X \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>0. a`(succ(k)) = f`(a`(k)))\"\n    using singleton_apply by auto\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 663,
        "informal": " Given a function `f: X -> X` and an element `x in X`, there exists a sequence `a` starting from `succ(0)` such that the first element is `x` and each subsequent element is the image of the previous element under `f`. \n\nNote that `succ(0)` represents the natural number `1`. The statement also allows for an empty sequence as a possibility, which could be achieved by allowing `a` to be the constant `x` itself. For clarity, it might be better to explicitly state this possibility or restrict `a` to non-empty sequences. The asterisk `*` below indicates optional elements in the sequence.\n\nIn a more mathematical way, this statement translates as:\n\nGiven `f: X -> X` and `x in X`, there exists a sequence `a: (succ(0) * X)` such that:\n1. `a(0) = x`\n2. For all `k in nat`, `a(succ(k)) = f(a(k))`."
    },
    "144": {
        "type": "lemma",
        "text": "text\\<open>Another workaround for the problem of Isabelle simplifier looping when \n  the transitivity definition is used.\\<close>\n",
        "assumes": "assumes A1: \"trans(r)\" and A2: \"\\<langle> a,b\\<rangle> \\<in> r  \\<and> \\<langle> b,c\\<rangle> \\<in> r\"\n  ",
        "using": [
            "imp_conj"
        ],
        "statement": "lemma Fol1_L3: assumes A1: \"trans(r)\" and A2: \"\\<langle> a,b\\<rangle> \\<in> r  \\<and> \\<langle> b,c\\<rangle> \\<in> r\"\n  shows \"\\<langle> a,c\\<rangle> \\<in> r\"\n",
        "proof": "proof -\n  from A1 have  \"\\<forall>x y z. \\<langle>x, y\\<rangle> \\<in> r \\<longrightarrow> \\<langle>y, z\\<rangle> \\<in> r \\<longrightarrow> \\<langle>x, z\\<rangle> \\<in> r\"\n   unfolding trans_def by blast\n  with A2 show ?thesis using imp_conj by fast\nqed\n",
        "imports": [
            "ZF.Trancl"
        ],
        "source": "IsarMathLib/Fol1.thy",
        "id": 355,
        "informal": "Assuming relation `r` is transitive and both `<a,b>` and `<b,c>` are in `r`, it follows that `<a,c>` is also in `r`. In words, if `r` connects `a` to `b` and `b` to `c`, then `r` connects `a` to `c`."
    },
    "145": {
        "type": "lemma",
        "text": "text\\<open>The image of a set by a greater relation is greater. \\<close>\n",
        "assumes": "assumes \"r\\<subseteq>s\" ",
        "using": [
            "assms"
        ],
        "statement": "lemma image_rel_mono: assumes \"r\\<subseteq>s\" shows \"r``(A) \\<subseteq> s``(A)\" \n  ",
        "proof": "using assms by auto \n",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2530,
        "informal": " If relation r is a subset of relation s, then the image of set A under relation r is a subset of the image of set A under relation s."
    },
    "146": {
        "type": "lemma",
        "text": "text\\<open>See the comment to \\<open>group0_2_L7\\<close>.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" and A3: \"a\\<cdot>b = b\"\n  ",
        "using": [
            "inverse_in_group",
            "group_oper_assoc",
            "group0_2_L6",
            "group0_2_L2"
        ],
        "statement": "lemma (in group0) group0_2_L8: \n  assumes A1: \"a\\<in>G\" and A2: \"b\\<in>G\" and A3: \"a\\<cdot>b = b\"\n  shows \"a=\\<one>\"\n",
        "proof": "proof -\n  from A3 have \"(a\\<cdot>b)\\<cdot>b\\<inverse>  = b\\<cdot>b\\<inverse>\" by simp\n  with A1 A2 have \"a\\<cdot>(b\\<cdot>b\\<inverse>)  = b\\<cdot>b\\<inverse>\" using\n    inverse_in_group group_oper_assoc by simp\n  with A1 A2 show ?thesis \n    using group0_2_L6 group0_2_L2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 427,
        "informal": " Given that `a` and `b` are elements of group `G` and `a * b = b`, it can be concluded that `a = one`."
    },
    "147": {
        "type": "lemma",
        "text": "text\\<open>The trivial topology is perfect, if it is defined over a set with more than one point.\\<close>\n",
        "assumes": "assumes \"\\<exists>x y. x\\<in>X \\<and> y\\<in>X \\<and> x\\<noteq>y\"\n  ",
        "using": [],
        "statement": "lemma trivial_is_perfect:\n  assumes \"\\<exists>x y. x\\<in>X \\<and> y\\<in>X \\<and> x\\<noteq>y\"\n  shows \"{0,X}{is perfect}\"\n",
        "proof": "proof-\n  {\n    fix r assume \"{r}\\<in>{0,X}\"\n    then have \"X={r}\" by auto\n    with assms have \"False\" by auto\n  }\n  then show ?thesis unfolding IsPerf_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2433,
        "informal": " If there exist distinct elements x and y in set X, then X is perfect. (A perfect set in ZF set theory is an uncountable set that contains a subset with the same cardinality as itself.)\n\nHowever, the given Isabelle/ZF code lacks the uncountability assumption. Uncountability is typically conveyed by using the Axiom of Choice or its equivalent in Isabelle. If you intended to prove that an uncountable set is perfect, it would be essential to include this assumption in the statement.\n\nThe current lemma seems to prove that a set with distinct elements is perfect under some unstated assumption, making the natural language statement not precise enough. To get a more accurate statement, please provide additional context or clarifications from the original Isabelle/ZF code."
    },
    "148": {
        "type": "definition",
        "text": "text\\<open>Choosing a singleton set, it is considered a point in excluded topology.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ExcludedPoint(X,p) \\<equiv> ExcludedSet(X,{p})\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2300,
        "informal": " \"Excluded Point: A point p is an excluded point for a set X if and only if p belongs to the set of excluded elements for X.\"\n\nOr more succinctly, \"ExcludedPoint(p,X) iff p in ExcludedSet(X)\""
    },
    "149": {
        "type": "lemma",
        "text": "text\\<open>Every cover star-refines the trivial cover $\\{ X\\}$. \\<close>\n",
        "assumes": "assumes \"P \\<in> Covers(X)\" ",
        "using": [
            "assms",
            "Star_def",
            "IsStarRefinement_def",
            "Covers_def"
        ],
        "statement": "lemma cover_stref_triv: assumes \"P \\<in> Covers(X)\" shows \"P <\\<^sup>* {X}\"\n  ",
        "proof": "using assms unfolding Star_def IsStarRefinement_def Covers_def by auto\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2475,
        "informal": " If event P is a cover for set X, then the intersection of P and all its iterates contains X."
    },
    "150": {
        "type": "lemma",
        "text": "text\\<open>Inverse image of intersection is the intersection of inverse images.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "assms",
            "fun_is_fun",
            "function_vimage_Int"
        ],
        "statement": "lemma invim_inter_inter_invim: assumes \"f:X\\<rightarrow>Y\"\n  shows \"f-``(A\\<inter>B) = f-``(A) \\<inter> f-``(B)\"\n  ",
        "proof": "using assms fun_is_fun function_vimage_Int by simp\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2586,
        "informal": " Assuming `f` is a function from set `X` to set `Y`, the image of the intersection of sets `A` and `B` under `f` equals the intersection of the images of sets `A` and `B` under `f`."
    },
    "151": {
        "type": "lemma",
        "text": "text\\<open>The values of congruent functions of two variables are in the space.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"C\\<^sub>1 \\<in> A//r\" and A3: \"C\\<^sub>2 \\<in> A//r\"\n  and A4: \"z \\<in> C\\<^sub>1\\<times>C\\<^sub>2\" and A5: \"Congruent2(r,f)\"\n  ",
        "using": [
            "EquivClass_1_L1",
            "equiv_def",
            "refl_def",
            "Congruent2_def",
            "equiv_type"
        ],
        "statement": "lemma EquivClass_1_L8:\n  assumes A1: \"equiv(A,r)\" and A2: \"C\\<^sub>1 \\<in> A//r\" and A3: \"C\\<^sub>2 \\<in> A//r\"\n  and A4: \"z \\<in> C\\<^sub>1\\<times>C\\<^sub>2\" and A5: \"Congruent2(r,f)\"\n  shows \"f`(z) \\<in> A\"\n",
        "proof": "proof -\n  from A4 obtain x y where \"x\\<in>C\\<^sub>1\" and \"y\\<in>C\\<^sub>2\" and \"z = \\<langle>x,y\\<rangle>\"  \n    by auto\n  with A1 A2 A3 have \"x\\<in>A\" and \"y\\<in>A\" \n    using EquivClass_1_L1 by auto\n  with A1 A4 have \"\\<langle>x,x\\<rangle> \\<in> r\" and \"\\<langle>y,y\\<rangle> \\<in> r\"\n    using equiv_def refl_def by auto\n  with A5 have \"\\<langle>f`\\<langle>x,y\\<rangle>, f`\\<langle>x,y\\<rangle> \\<rangle> \\<in> r\"\n    using Congruent2_def by simp\n  with A1 \\<open>z = \\<langle>x,y\\<rangle>\\<close> show ?thesis using equiv_type by auto\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 123,
        "informal": " If A is an equivalence relation on a set, C1 and C2 are its classes, z is an element in the intersection of C1 and C2, and congruence relation f is compatible with A (via the congruence relation R), then f(z) is an element in the equivalence class A that contains z."
    },
    "152": {
        "type": "theorem",
        "text": "text\\<open>The cofinite space over $\\mathbb{N}$ is a $T_1$, perfect and luzin space.\\<close>\n",
        "assumes": "",
        "using": [
            "union_cocardinal",
            "Cofinite_def",
            "n_lesspoll_nat",
            "eq_lesspoll_trans",
            "less_less_imp_un_less[OF",
            "_",
            "InfCard_nat]",
            "xn"
        ],
        "statement": "theorem cofinite_nat_perfect:\n  shows \"(CoFinite nat){is perfect}\"\n",
        "proof": "proof-\n  {\n    fix x assume x:\"x\\<in>\\<Union>(CoFinite nat)\" \"{x}\\<in>(CoFinite nat)\"\n    then have xn:\"x\\<in>nat\" using union_cocardinal unfolding Cofinite_def by auto\n    with x(2) have \"nat-{x}\\<prec>nat\" unfolding Cofinite_def CoCardinal_def by auto\n    moreover have \"Finite({x})\" by auto\n    then have \"{x}\\<prec>nat\" unfolding Finite_def using n_lesspoll_nat eq_lesspoll_trans by auto\n    ultimately have \"(nat-{x})\\<union>{x}\\<prec>nat\" using less_less_imp_un_less[OF _ _ InfCard_nat] by auto\n    moreover have \"(nat-{x})\\<union>{x}=nat\" using xn by auto\n    ultimately have \"False\" by auto\n  }\n  then show ?thesis unfolding IsPerf_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2438,
        "informal": " The theorem \"cofinale_nat_perfect\" asserts that the collection of cofinite subsets of natural numbers forms a perfect set. In other words, every finite subset of natural numbers has a complement with the same cardinality, making the collection of cofinite subsets equivalent in size to the collection of finite subsets of natural numbers. Therefore, the cofinite subsets of natural numbers form a perfect set in the sense of Zermelo-Fraenkel set theory."
    },
    "153": {
        "type": "lemma",
        "text": "text\\<open>The group inverse is onto.\\<close>\n",
        "assumes": "",
        "using": [
            "group_inv_bij",
            "bij_def",
            "surj_range_image_domain"
        ],
        "statement": "lemma (in group0) group_inv_surj: shows \"GroupInv(G,P)``(G) = G\"\n  ",
        "proof": "using group_inv_bij bij_def surj_range_image_domain by auto\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 442,
        "informal": " The lemma `group_inv_surj` in the theory `group0` states that the image of the group `G` under the group inverse operation `GroupInv(G,P)` is equal to the original group `G`."
    },
    "154": {
        "type": "lemma",
        "text": "text\\<open>The boundary of a set is empty if $A$ and $X-A$ are closed,\n \\<open>X\\<close> if not $A$ neither $X-A$ are closed and; if only one is closed,\nthen the closed one is its boundary.\\<close>\n",
        "assumes": "assumes \"T\\<noteq>0\"\"A\\<subseteq>X\"\n  ",
        "using": [
            "closure_set_cocardinal",
            "Boundary_def",
            "union_cocardinal"
        ],
        "statement": "lemma boundary_cocardinal:\n  assumes \"T\\<noteq>0\"\"A\\<subseteq>X\"\n  shows \"Boundary(A,CoCardinal(X,T)) = (if A\\<prec> T then (if  (X-A)\\<prec> T then 0 else A) else (if  (X-A)\\<prec> T then X-A else X))\"\n",
        "proof": "proof-\n  from assms(2) have \"X-A \\<subseteq> X\" by auto\n  {\n    assume AS: \"A\\<prec>T\" \"X-A \\<prec> T\"\n    with assms \\<open>X-A \\<subseteq> X\\<close> have\n      \"Closure(X-A,CoCardinal(X,T)) = X-A\" and \"Closure(A,CoCardinal(X,T)) = A\"\n      using closure_set_cocardinal by auto\n    with assms(1) have \"Boundary(A,CoCardinal(X,T)) = 0\"  \n      using Boundary_def  union_cocardinal by auto\n  }\n  moreover\n  {\n    assume AS: \"~(A\\<prec>T)\" \"X-A \\<prec> T\"\n    with assms \\<open>X-A \\<subseteq> X\\<close> have\n      \"Closure(X-A,CoCardinal(X,T)) = X-A\" and \"Closure(A,CoCardinal(X,T)) = X\"\n      using closure_set_cocardinal by auto \n    with assms(1) have \"Boundary(A,CoCardinal(X,T))=X-A\" using Boundary_def\n      union_cocardinal by auto\n  }\n  moreover\n  {\n    assume AS:\"~(A\\<prec>T)\" \"~(X-A \\<prec> T)\"\n    with assms \\<open>X-A \\<subseteq> X\\<close> have\n      \"Closure(X-A,CoCardinal(X,T))=X\" and \"Closure(A,CoCardinal(X,T))=X\"\n      using closure_set_cocardinal by auto \n    with assms(1) have \"Boundary(A,CoCardinal(X,T))=X\" using Boundary_def union_cocardinal\n      by auto\n  }\n  moreover\n  {\n    assume AS:\"A\\<prec> T\" \"~(X-A\\<prec>T)\"\n    with assms \\<open>X-A \\<subseteq> X\\<close> have \n      \"Closure(X-A,CoCardinal(X,T))=X\" and \"Closure(A,CoCardinal(X,T)) = A\"\n      using closure_set_cocardinal by auto\n    with assms have \"Boundary(A,CoCardinal(X,T))=A\" using Boundary_def union_cocardinal\n      by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2293,
        "informal": " Assuming T is a non-empty set and A is a subset of X: The boundary of A with respect to the co-cardinality of X with respect to T equals the set derived as follows:\n\n1. If A is a proper subset of T, then the boundary contains:\n   a. An empty set if (X-A) is a proper subset of T.\n   b. The set A itself if (X-A) is not a proper subset of T.\n\n2. If A is not a proper subset of T, then the boundary is equal to X."
    },
    "155": {
        "type": "lemma",
        "text": "text\\<open>Another rearrangement with two integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\" \"b\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "int_zero_one_are_int",
            "Int_ZF_1_T2",
            "group0.group0_4_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L8: \n  assumes A1: \"a\\<in>\\<int>\" \"b\\<in>\\<int>\"\n  shows \"a\\<ra>\\<one>\\<ra>(b\\<ra>\\<one>) = b\\<ra>a\\<ra>\\<two>\"\n  ",
        "proof": "using assms int_zero_one_are_int Int_ZF_1_T2 group0.group0_4_L8\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 736,
        "informal": " Given integers a and b, the product of their successor functions is equal to the successor of the product of their original values."
    },
    "156": {
        "type": "lemma",
        "text": "text\\<open>If a function is continuous, then it is continuous at every point.\\<close>\n",
        "assumes": "assumes \"x\\<in>\\<Union>\\<tau>\\<^sub>1\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"f:(\\<Union>\\<tau>\\<^sub>1)\\<rightarrow>(\\<Union>\\<tau>\\<^sub>2)\" \"x\\<in>\\<Union>\\<tau>\\<^sub>1\"\n  ",
        "using": [
            "assms(2)",
            "IsContinuous_def",
            "function_image_vimage",
            "fun_is_fun",
            "func1_1_L15"
        ],
        "statement": "lemma cont_global_imp_continuous_x:\n  assumes \"x\\<in>\\<Union>\\<tau>\\<^sub>1\" \"IsContinuous(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\" \"f:(\\<Union>\\<tau>\\<^sub>1)\\<rightarrow>(\\<Union>\\<tau>\\<^sub>2)\" \"x\\<in>\\<Union>\\<tau>\\<^sub>1\"\n  shows \"\\<forall>U\\<in>\\<tau>\\<^sub>2. f`(x)\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``(V)\\<subseteq>U)\"\n",
        "proof": "proof-\n  {\n    fix U\n    assume AS:\"U\\<in>\\<tau>\\<^sub>2\" \"f`(x)\\<in>U\"\n    then have \"f-``(U)\\<in>\\<tau>\\<^sub>1\" using assms(2) IsContinuous_def by auto\n    moreover\n    from assms(3) have \"f``(f-``(U))\\<subseteq>U\" using function_image_vimage fun_is_fun \n      by auto\n    moreover\n    from assms(3) assms(4) AS(2) have \"x\\<in>f-``(U)\" using func1_1_L15 by auto\n    ultimately have \"\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``V\\<subseteq>U\" by auto\n  }\n  then show \"\\<forall>U\\<in>\\<tau>\\<^sub>2. f`(x)\\<in>U \\<longrightarrow> (\\<exists>V\\<in>\\<tau>\\<^sub>1. x\\<in>V \\<and> f``(V)\\<subseteq>U)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4",
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_6.thy",
        "id": 2229,
        "informal": " If x is an element of the union of all open sets in a topology tau1 and the function f is continuous from tau1 to tau2, then for any open set U in tau2, if the image of x under f is an element of U, there exists an open set V in tau1 containing x such that the image of V under f is contained in U."
    },
    "157": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum and all its elements are less or equal than \n  $M$, then the maximum of the set is less or equal than $M$.\\<close>\n",
        "assumes": "assumes \"antisym(r)\" and \"HasAmaximum(r,A)\" and \"\\<forall>a\\<in>A. \\<langle>a,M\\<rangle> \\<in> r\"\n  ",
        "using": [
            "assms",
            "Order_ZF_4_L3"
        ],
        "statement": "lemma Order_ZF_4_L13: \n  assumes \"antisym(r)\" and \"HasAmaximum(r,A)\" and \"\\<forall>a\\<in>A. \\<langle>a,M\\<rangle> \\<in> r\"\n  shows \"\\<langle>Maximum(r,A),M\\<rangle> \\<in> r\"\n  ",
        "proof": "using assms Order_ZF_4_L3 by simp\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1289,
        "informal": " If relation r is antisymmetric and has a maximum element in set A, which is an element of r for all a in A, then the maximum element and the maximum value are themselves in the relation r."
    },
    "158": {
        "type": "lemma",
        "text": "text\\<open>Another useful rearrangement.\\<close>\n",
        "assumes": "assumes A1:\"P {is commutative on} G\" \n  and A2: \"a\\<in>G\"  \"b\\<in>G\" and A3: \"c\\<in>G\"  \"d\\<in>G\"  \"E\\<in>G\"  \"F\\<in>G\"\n  ",
        "using": [
            "inverse_in_group",
            "group_op_closed",
            "group_oper_assoc",
            "group_inv_of_two",
            "group0_4_L2"
        ],
        "statement": "lemma (in group0) group0_4_L3:\n  assumes A1:\"P {is commutative on} G\" \n  and A2: \"a\\<in>G\"  \"b\\<in>G\" and A3: \"c\\<in>G\"  \"d\\<in>G\"  \"E\\<in>G\"  \"F\\<in>G\"\n  shows \"a\\<cdot>b\\<cdot>((c\\<cdot>d)\\<inverse>\\<cdot>(E\\<cdot>F)\\<inverse>) = (a\\<cdot>(E\\<cdot>c)\\<inverse>)\\<cdot>(b\\<cdot>(F\\<cdot>d)\\<inverse>)\"\n",
        "proof": "proof -\n  from A3 have T1:\n    \"c\\<inverse>\\<in>G\" \"d\\<inverse>\\<in>G\" \"E\\<inverse>\\<in>G\" \"F\\<inverse>\\<in>G\" \"(c\\<cdot>d)\\<inverse>\\<in>G\" \"(E\\<cdot>F)\\<inverse>\\<in>G\"\n    using inverse_in_group group_op_closed \n    by auto\n  from A2 T1 have \n    \"a\\<cdot>b\\<cdot>((c\\<cdot>d)\\<inverse>\\<cdot>(E\\<cdot>F)\\<inverse>) = a\\<cdot>b\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(E\\<cdot>F)\\<inverse>\"\n    using group_op_closed group_oper_assoc\n    by simp\n  also from A2 A3 have \n    \"a\\<cdot>b\\<cdot>(c\\<cdot>d)\\<inverse>\\<cdot>(E\\<cdot>F)\\<inverse> = (a\\<cdot>b)\\<cdot>(d\\<inverse>\\<cdot>c\\<inverse>)\\<cdot>(F\\<inverse>\\<cdot>E\\<inverse>)\"\n    using group_inv_of_two by simp\n   also from A1 A2 T1 have \n    \"(a\\<cdot>b)\\<cdot>(d\\<inverse>\\<cdot>c\\<inverse>)\\<cdot>(F\\<inverse>\\<cdot>E\\<inverse>) = (a\\<cdot>(c\\<inverse>\\<cdot>E\\<inverse>))\\<cdot>(b\\<cdot>(d\\<inverse>\\<cdot>F\\<inverse>))\"\n    using group0_4_L2 by simp\n  also from A2 A3 have \n    \"(a\\<cdot>(c\\<inverse>\\<cdot>E\\<inverse>))\\<cdot>(b\\<cdot>(d\\<inverse>\\<cdot>F\\<inverse>)) = (a\\<cdot>(E\\<cdot>c)\\<inverse>)\\<cdot>(b\\<cdot>(F\\<cdot>d)\\<inverse>)\"\n    using group_inv_of_two by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 1,
        "informal": " In group `G`, if `P` is commutative and `a`, `b`, `c`, `d`, `E`, and `F` are all elements of `G`, then `a * b * ((c * d)^-1 * (E * F)^-1)` equals `(a * (E * c)^-1) * (b * (F * d)^-1)`."
    },
    "159": {
        "type": "lemma",
        "text": "text\\<open>If the neutral element belongs to a set, then an element of group belongs\n  the translation of that set.\\<close>\n",
        "assumes": "assumes A1: \"A\\<subseteq>G\" \"g\\<in>G\" and A2: \"\\<one>\\<in>A\" \n  ",
        "using": [
            "ltrans_image",
            "group0_2_L2",
            "rtrans_image"
        ],
        "statement": "lemma (in group0) neut_trans_elem: \n  assumes A1: \"A\\<subseteq>G\" \"g\\<in>G\" and A2: \"\\<one>\\<in>A\" \n  shows \"g \\<in> LeftTranslation(G,P,g)``(A)\" \"g \\<in> RightTranslation(G,P,g)``(A)\"\n",
        "proof": "proof -\n  from assms have \"g\\<cdot>\\<one> \\<in> LeftTranslation(G,P,g)``(A)\"\n    using ltrans_image by auto\n  with A1 show \"g \\<in> LeftTranslation(G,P,g)``(A)\" using group0_2_L2 by simp\n  from assms have \"\\<one>\\<cdot>g \\<in> RightTranslation(G,P,g)``(A)\"\n    using rtrans_image by auto\n  with A1 show \"g \\<in> RightTranslation(G,P,g)``(A)\" using group0_2_L2 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 503,
        "informal": " In the group0 theory, if A is a subset of the group G and g is an element of G, with one element in A, then g is an element of both the left and right translations of A by g."
    },
    "160": {
        "type": "lemma",
        "text": "text\\<open>The zero's multiple of a monoid element is its neutral element.\\<close>\n",
        "assumes": "",
        "using": [
            "sum_empty"
        ],
        "statement": "lemma (in monoid1) nat_mult_zero: shows \"0\\<cdot>x = \\<zero>\" ",
        "proof": "using sum_empty by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Monoid_ZF_1.thy",
        "id": 1150,
        "informal": " In the monoid1 theory, we have the lemma stating that multiplication of 0 with any element x results in 0. In English: The product of 0 and any element x is equal to 0."
    },
    "161": {
        "type": "lemma",
        "text": "text\\<open>To avoid using an axiom of choice, we define the projection using \n  the expression $\\bigcup _{x\\in C} r(\\{f(x)\\})$. \n  The next lemma shows that for\n  congruent function this is in the quotient space $A/r$.\\<close>\n",
        "assumes": "assumes A1: \"equiv(A,r)\" and A2: \"Congruent(r,f)\" \n  and A3: \"C \\<in> A//r\"\n  ",
        "using": [
            "EquivClass_1_L5",
            "EquivClass_1_L4",
            "quotientI",
            "EquivClass_1_L3"
        ],
        "statement": "lemma EquivClass_1_L6:\n  assumes A1: \"equiv(A,r)\" and A2: \"Congruent(r,f)\" \n  and A3: \"C \\<in> A//r\"\n  shows \"(\\<Union>x\\<in>C. r``{f`(x)}) \\<in> A//r\"\n",
        "proof": "proof -\n  from A1 have \"refl(A,r)\" unfolding equiv_def by simp\n  with A3 have \"C\\<noteq>0\" using EquivClass_1_L5 by simp\n  moreover from A2 A3 A1 have \"\\<forall>x\\<in>C. r``{f`(x)} \\<in> A//r\"\n    using EquivClass_1_L4 quotientI by auto\n  moreover from A1 A2 A3 have \n    \"\\<forall>x y. x\\<in>C \\<and> y\\<in>C \\<longrightarrow> r``{f`(x)} = r``{f`(y)}\" \n    using EquivClass_1_L3 by blast\n  ultimately show ?thesis by (rule ZF1_1_L2)\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 118,
        "informal": " If A is an equivalence relation on a set C with respect to the relation r, Congruence(r, f), and C is a subset of the equivalence class A/r of an element x, then the set {y | r(y, f(x)) is defined and y is in C} is a subset of the equivalence class A/r."
    },
    "162": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement with four integers. Property of groups.\\<close>\n",
        "assumes": "assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_1_T2",
            "group0.group0_4_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L16:\n  assumes \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \"d\\<in>\\<int>\"\n  shows \"a\\<ra>(b\\<rs>c)\\<ra>d = a\\<ra>b\\<ra>d\\<rs>c\"\n  ",
        "proof": "using assms Int_ZF_1_T2 group0.group0_4_L8 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 746,
        "informal": " If a and b are integers, and c is another integer, then the result of raising a to the power of the product of b and c is equal to the result of raising a to the power of b and then raising the result to the power of c."
    },
    "163": {
        "type": "lemma",
        "text": "text\\<open>The last element of a list of length at least 2 is the same as the last element\n  of the tail of that list.\\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"a: succ(succ(n)) \\<rightarrow> X\"\n  ",
        "using": [
            "tail_props(1)",
            "last_seq_elem",
            "tail_props(2)"
        ],
        "statement": "lemma last_tail_last: assumes \"n\\<in>nat\" \"a: succ(succ(n)) \\<rightarrow> X\"\n  shows \"Last(Tail(a)) = Last(a)\"\n",
        "proof": "proof -\n  from assms have \"Last(Tail(a)) = Tail(a)`(n)\"\n    using tail_props(1) last_seq_elem by blast\n  also from assms have \"Tail(a)`(n) = a`(succ(n))\" using tail_props(2) \n    by blast\n  also from assms(2) have \"a`(succ(n)) = Last(a)\" using last_seq_elem \n    by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 251,
        "informal": " Given a natural number `n` and a relation `X` such that `a` is in `X` when `a` is a successor of a successor of `n`, then the last element of the tail of `a` is equal to the last element of `a`."
    },
    "164": {
        "type": "lemma",
        "text": "text\\<open>The notation for the inverse means what it is supposed to mean.\\<close>\n",
        "assumes": "assumes A1: \"x\\<in>G\" ",
        "using": [
            "group0_2_T2",
            "apply_Pair",
            "GroupInv_def",
            "inverse_in_group",
            "group0_2_T1"
        ],
        "statement": "lemma (in group0) group0_2_L6: \n  assumes A1: \"x\\<in>G\" shows \"x\\<cdot>x\\<inverse> = \\<one> \\<and> x\\<inverse>\\<cdot>x = \\<one>\"\n",
        "proof": "proof\n  from groupAssum have \"GroupInv(G,P) : G\\<rightarrow>G\" \n    using group0_2_T2 by simp \n  with A1 have \"\\<langle>x,x\\<inverse>\\<rangle> \\<in>  GroupInv(G,P)\" \n    using apply_Pair by simp\n  then show \"x\\<cdot>x\\<inverse> = \\<one>\" using GroupInv_def by simp\n  with A1 show \"x\\<inverse>\\<cdot>x = \\<one>\" using inverse_in_group group0_2_T1 \n    by blast \nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 425,
        "informal": " If an element x belongs to group G, then x multiplied by its inverse equals the identity element, and their inverses multiplied together also equal the identity element."
    },
    "165": {
        "type": "lemma",
        "text": "text\\<open>Suppose we have two functions $f:X\\rightarrow Y$ and $g:X\\rightarrow Z$ and \n  the third one is defined as $h:X\\rightarrow Y\\times Z$, $x\\mapsto \\langle f(x),g(x)\\rangle$.\n  Given two sets $U$, $V$ we have $h^{-1}(U\\times V) = (f^{-1}(U)) \\cap (g^{-1}(V))$. \n  We also show that the set where the function $f,g$ are equal is the same as \n  $h^{-1}(\\{ \\langle y,y\\rangle : y\\in X\\}$. \n  It is a bit surprising that we get the last identity without the assumption that $Y=Z$. \\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" \"g:X\\<rightarrow>Z\" \n  defines \"h \\<equiv> {\\<langle>x,\\<langle>f`(x),g`(x)\\<rangle>\\<rangle>. x\\<in>X}\"\n  ",
        "using": [
            "apply_funtype",
            "ZF_fun_from_total",
            "ZF_fun_from_tot_val",
            "func1_1_L15"
        ],
        "statement": "lemma vimage_prod: \n  assumes \"f:X\\<rightarrow>Y\" \"g:X\\<rightarrow>Z\" \n  defines \"h \\<equiv> {\\<langle>x,\\<langle>f`(x),g`(x)\\<rangle>\\<rangle>. x\\<in>X}\"\n  shows \n    \"h:X\\<rightarrow>Y\\<times>Z\" \n    \"\\<forall>x\\<in>X. h`(x) = \\<langle>f`(x),g`(x)\\<rangle>\" \n    \"h-``(U\\<times>V) = f-``(U) \\<inter> g-``(V)\"\n    \"{x\\<in>X. f`(x) = g`(x)} = h-``({\\<langle>y,y\\<rangle>. y\\<in>Y})\"\n",
        "proof": "proof - \n  from assms show \"h:X\\<rightarrow>Y\\<times>Z\" using apply_funtype ZF_fun_from_total\n    by simp\n  with assms(3) show I: \"\\<forall>x\\<in>X. h`(x) = \\<langle>f`(x),g`(x)\\<rangle>\" \n    using ZF_fun_from_tot_val by simp\n  with assms(1,2) \\<open>h:X\\<rightarrow>Y\\<times>Z\\<close> show \"h-``(U\\<times>V) = f-``(U) \\<inter> g-``(V)\"\n    using func1_1_L15 by auto\n  from assms(1) I \\<open>h:X\\<rightarrow>Y\\<times>Z\\<close> show \"{x\\<in>X. f`(x) = g`(x)} = h-``({\\<langle>y,y\\<rangle>. y\\<in>Y})\"\n    using apply_funtype func1_1_L15 by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2602,
        "informal": " Assuming functions f: X -> Y and g: X -> Z, define h: X -> X \\* Y \\* Z as the set of triples (x, f(x), g(x)). Then, h is a function from X to the Cartesian product of Y and Z, and for all x in X, h(x) = <f(x), g(x)>; the image of the product of sets U \\* V under h is equal to the intersection of the images of U under f and V under g; and if for all x in X, f(x) = g(x), then h maps X to the diagonal set {<y,y> | y in Y}."
    },
    "166": {
        "type": "lemma",
        "text": "text\\<open>The inverse image of the range is the domain.\\<close>\n",
        "assumes": "assumes \"f:X\\<rightarrow>Y\" ",
        "using": [
            "assms",
            "func1_1_L3",
            "func1_1_L2",
            "vimage_iff"
        ],
        "statement": "lemma func1_1_L4: assumes \"f:X\\<rightarrow>Y\" shows \"f-``(Y) = X\"\n  ",
        "proof": "using assms func1_1_L3 func1_1_L2 vimage_iff by blast\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2559,
        "informal": " Assuming that function f maps X to Y, it holds that the dominated set of Y equals X."
    },
    "167": {
        "type": "definition",
        "text": "text\\<open>Given some family $\\mathcal{A}$ of subsets of $X$ we can define the family of supersets of\n  $\\mathcal{A}$. \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Supersets(X,\\<A>) \\<equiv> {B\\<in>Pow(X). \\<exists>A\\<in>\\<A>. A\\<subseteq>B}\"\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2538,
        "informal": " \"The set A is a superset of X if and only if there exists a set B in the power set of X such that A is a subset of B.\""
    },
    "168": {
        "type": "lemma",
        "text": "text\\<open>What is the value of a negative of a slope?\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\" and \"m\\<in>\\<int>\" ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_2_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L12A: \n  assumes \"s\\<in>\\<S>\" and \"m\\<in>\\<int>\" shows \"(\\<fm>s)`(m) = \\<rm>(s`(m))\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_2_L5\n  by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 860,
        "informal": " Assuming \"s is an element of set S\" and \"m is an integer,\" it holds that \"the value of function fm at m equals the value of function rm at the image of m under function s.\""
    },
    "169": {
        "type": "definition",
        "text": "text\\<open>We will say that a topological space is locally @term{\"P\"} iff every point has a neighbourhood basis\nof subsets that have the property @term{\"P\"} as subspaces.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  IsLocally (\"_{is locally}_\" 90)\n  where \"T{is a topology} \\<Longrightarrow> T{is locally}P \\<equiv> (\\<forall>x\\<in>\\<Union>T. \\<forall>b\\<in>T. x\\<in>b \\<longrightarrow> (\\<exists>c\\<in>Pow(b). x\\<in>Interior(c,T) \\<and> P(c,T)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_11"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_2.thy",
        "id": 2372,
        "informal": " A topology T is locally P if and only if for all x in the union of T and for all b in T, if x is in b then there exists a subset c of the power set of b such that x is in the interior of c with respect to T and P holds for c and T."
    },
    "170": {
        "type": "lemma",
        "text": "text\\<open>A useful estimate for the value of a slope at $0$, plus some type information\n  for slopes.\\<close>\n",
        "assumes": "assumes A1: \"s\\<in>\\<S>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_2_1_L2B",
            "int_abs_nonneg",
            "Int_ZF_1_1_L4",
            "Int_ZF_2_L17",
            "Int_ZF_2_1_L7",
            "Int_ZF_2_L1A",
            "Int_ZF_1_1_L5"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L8: assumes A1: \"s\\<in>\\<S>\"\n  shows \n  \"abs(s`(\\<zero>)) \\<lsq> max\\<delta>(s)\"\n  \"\\<zero> \\<lsq> max\\<delta>(s)\"  \n  \"abs(s`(\\<zero>)) \\<in> \\<int>\"   \"max\\<delta>(s) \\<in> \\<int>\"\n  \"abs(s`(\\<zero>)) \\<ra> max\\<delta>(s) \\<in> \\<int>\"\n",
        "proof": "proof -\n  from A1 have \"s`(\\<zero>) \\<in> \\<int>\" \n    using int_zero_one_are_int Int_ZF_2_1_L2B by simp\n  then have I: \"\\<zero> \\<lsq> abs(s`(\\<zero>))\"  \n    and \"abs(\\<delta>(s,\\<zero>,\\<zero>)) = abs(s`(\\<zero>))\" \n    using int_abs_nonneg int_zero_one_are_int Int_ZF_1_1_L4 \n      Int_ZF_2_L17 by auto\n  moreover from A1 have \"abs(\\<delta>(s,\\<zero>,\\<zero>)) \\<lsq> max\\<delta>(s)\"\n    using int_zero_one_are_int Int_ZF_2_1_L7 by simp\n  ultimately show II: \"abs(s`(\\<zero>)) \\<lsq> max\\<delta>(s)\"\n    by simp\n  with I show \"\\<zero>\\<lsq>max\\<delta>(s)\" by (rule Int_order_transitive)\n  with II show \n    \"max\\<delta>(s) \\<in> \\<int>\"   \"abs(s`(\\<zero>)) \\<in> \\<int>\" \n    \"abs(s`(\\<zero>)) \\<ra> max\\<delta>(s) \\<in> \\<int>\"\n    using Int_ZF_2_L1A Int_ZF_1_1_L5 by auto\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 851,
        "informal": " Given an element `s` in a set `S`, the following statements hold:\n\n1. The absolute value of the identity function of `s` (i.e., `abs(s(0))`) is less than or equal to the maximum difference in elements of `s`.\n2. Zero is less than or equal to the maximum difference in elements of `s`.\n3. The absolute value of the identity function of `s` and the maximum difference in elements of `s` are both natural numbers.\n4. The absolute value of the identity function of `s` is less than or equal to the maximum difference in elements of `s` plus one (i.e., the absolute value is within one of the maximum difference)."
    },
    "171": {
        "type": "lemma",
        "text": "text\\<open>A lemma about how a surjection maps collections of subsets in domain and range.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> surj(X,Y)\" and A2: \"B \\<subseteq> Pow(Y)\"\n  ",
        "using": [
            "surj_image_vimage"
        ],
        "statement": "lemma surj_subsets: assumes A1: \"f \\<in> surj(X,Y)\" and A2: \"B \\<subseteq> Pow(Y)\"\n  shows \"{ f``(U). U \\<in> {f-``(V). V\\<in>B} } = B\"\n",
        "proof": "proof\n  { fix W assume \"W \\<in> { f``(U). U \\<in> {f-``(V). V\\<in>B} }\"\n    then obtain U where I: \"U \\<in> {f-``(V). V\\<in>B}\" and II: \"W = f``(U)\" by auto\n    then obtain V where \"V\\<in>B\" and \"U = f-``(V)\" by auto\n    with II have \"W = f``(f-``(V))\" by simp\n    moreover from assms \\<open>V\\<in>B\\<close> have \"f \\<in> surj(X,Y)\" and \"V\\<subseteq>Y\" by auto \n    ultimately have \"W=V\" using surj_image_vimage by simp\n    with \\<open>V\\<in>B\\<close> have \"W \\<in> B\" by simp \n  } thus \"{ f``(U). U \\<in> {f-``(V). V\\<in>B} } \\<subseteq> B\" by auto\n  { fix W assume \"W\\<in>B\"\n    let ?U = \"f-``(W)\"\n    from \\<open>W\\<in>B\\<close> have \"?U \\<in> {f-``(V). V\\<in>B}\" by auto\n    moreover from A1 A2 \\<open>W\\<in>B\\<close> have \"W = f``(?U)\" using surj_image_vimage by auto  \n    ultimately have \"W \\<in> { f``(U). U \\<in> {f-``(V). V\\<in>B} }\" by auto \n  } thus \"B \\<subseteq> { f``(U). U \\<in> {f-``(V). V\\<in>B} }\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2640,
        "informal": " Assuming function `f` is surjective from set `X` to `Y`, and `B` is a subset of the power set of `Y`, then the set of images of elements in set `U`, `{ f``(U) : U \\in U}`, is equal to `B`. In other words, every element in `B` is the image of some element in the preimage set `U`."
    },
    "172": {
        "type": "lemma",
        "text": "text\\<open>Some statements about intervals centered at $0$.\\<close>\n",
        "assumes": "assumes A1: \"m\\<in>\\<int>\"\n  ",
        "using": [
            "int_abs_nonneg",
            "Int_ZF_1_3_L16",
            "int_ord_is_refl",
            "Int_ZF_2_L1A",
            "Order_ZF_2_L2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L17: assumes A1: \"m\\<in>\\<int>\"\n  shows \n  \"(\\<rm>abs(m)) \\<lsq> abs(m)\"\n  \"(\\<rm>abs(m))..abs(m) \\<noteq> 0\"\n",
        "proof": "proof -\n  from A1 have \"(\\<rm>abs(m)) \\<lsq> \\<zero>\"  \"\\<zero> \\<lsq> abs(m)\" \n    using int_abs_nonneg Int_ZF_1_3_L16 by auto\n  then show \"(\\<rm>abs(m)) \\<lsq> abs(m)\" by (rule Int_order_transitive)\n  then have \"abs(m) \\<in> (\\<rm>abs(m))..abs(m)\"\n    using int_ord_is_refl Int_ZF_2_L1A Order_ZF_2_L2 by simp\n  thus \"(\\<rm>abs(m))..abs(m) \\<noteq> 0\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 778,
        "informal": " Assuming m is an integer, the absolute value of m is non-negative and equals its positive value."
    },
    "173": {
        "type": "lemma",
        "text": "text\\<open>We can decompose proofs into three cases: $a=b$, $a\\leq b-1b$ or \n  $a\\geq b+1b$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_2_T1",
            "group3.OrderedGroup_ZF_1_L31",
            "no_int_between1"
        ],
        "statement": "lemma (in int0) Int_ZF_1_3_L6B: assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"\n  shows \"a=b \\<or> (a \\<lsq> b\\<rs>\\<one>) \\<or> (b\\<ra>\\<one> \\<lsq>a)\"\n",
        "proof": "proof -\n  from A1 have \"a=b \\<or> (a\\<lsq>b \\<and> a\\<noteq>b) \\<or> (b\\<lsq>a \\<and> b\\<noteq>a)\"\n    using Int_ZF_2_T1 group3.OrderedGroup_ZF_1_L31\n    by simp\n  then show ?thesis using no_int_between1\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 762,
        "informal": " Given integers a and b, if a is not equal to b, then either a is less than b plus one, or b is greater than a plus one."
    },
    "174": {
        "type": "lemma",
        "text": "text\\<open>Let's recall that $f$ is a binary operation on $G$ in this context.\\<close>\n",
        "assumes": "",
        "using": [
            "Ggroup",
            "group0_def",
            "group0.group_oper_fun"
        ],
        "statement": "lemma (in topgroup) topgroup_f_binop: shows \"f : G\\<times>G \\<rightarrow> G\"\n  ",
        "proof": "using Ggroup group0_def group0.group_oper_fun by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_3",
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/TopologicalGroup_ZF.thy",
        "id": 1937,
        "informal": " In the context of the topgroup hypothesis, we have a function f defined over the cartesian product of group G with itself, with the output being an element of group G."
    },
    "175": {
        "type": "lemma",
        "text": "text\\<open>For total and transitive relations if we add an element to a set \n  that has a maximum, the set still has a maximum.\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<subseteq>X\" and A4: \"a\\<in>X\" and A5: \"HasAmaximum(r,A)\"\n  ",
        "using": [
            "Order_ZF_1_L4",
            "total_is_refl",
            "Order_ZF_4_L8"
        ],
        "statement": "lemma Order_ZF_4_L9: \n  assumes A1: \"r {is total on} X\" and A2: \"trans(r)\"\n  and A3: \"A\\<subseteq>X\" and A4: \"a\\<in>X\" and A5: \"HasAmaximum(r,A)\"\n  shows \"HasAmaximum(r,A\\<union>{a})\"\n",
        "proof": "proof -\n  from A3 A4 have \"A\\<union>{a} \\<subseteq> X\" by auto\n  with A1 have \"r {is total on} (A\\<union>{a})\"\n    using Order_ZF_1_L4 by blast\n  moreover from A1 A2 A4 A5 have\n    \"trans(r)\" \"HasAmaximum(r,A)\" by auto\n  moreover from A1 A4 have \"HasAmaximum(r,{a})\"\n    using total_is_refl Order_ZF_4_L8 by blast\n  ultimately show \"HasAmaximum(r,A\\<union>{a})\" by (rule Order_ZF_4_L5)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1284,
        "informal": " Assuming relation r is total on set X, transitive, and a maxima set for A (a subset of X), show that A ∪ {a} is also a maxima set for r."
    },
    "176": {
        "type": "lemma",
        "text": "text\\<open>In the \\<open>metric_space\\<close> locale $d$ is a metric.\\<close>\n",
        "assumes": "",
        "using": [
            "pmetricAssum",
            "ident_indisc",
            "IsAmetric_def"
        ],
        "statement": "lemma (in metric_space) d_metric: shows \"IsAmetric(d,X,L,A,r)\"\n  ",
        "proof": "using pmetricAssum ident_indisc unfolding IsAmetric_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1117,
        "informal": " In a metric space, the function d satisfies the properties of a metric: it is reflexive, symmetric, and obeys the triangular inequality for all elements in X and real numbers L, A, and r."
    },
    "177": {
        "type": "lemma",
        "text": "text\\<open>Since the map is surjective, the image is also an ideal\\<close>\n",
        "assumes": "assumes \"J\\<triangleleft>R\\<^sub>o\" \"f\\<in>surj(R,S)\"\n  ",
        "using": [
            "origin_ring.ringAssum",
            "IsAring_def",
            "fun",
            ".",
            "show",
            "\"IsAsubgroup(J,A)\"",
            "assms",
            "origin_ring.Ideal_def",
            "homomorphism",
            "ringHomomor_def[OF",
            "origin",
            "target]",
            "target_ring.ringAssum",
            "func_imagedef",
            "origin_ring.ideal_dest_subset[OF",
            "assms(1)]",
            "assms(2)",
            "surj_range_image_domain",
            "homomor_dest_mult[of",
            "s",
            "j]",
            "j",
            "s]",
            "x(2)",
            "y(2)",
            "origin_ring.ideal_dest_mult[OF"
        ],
        "statement": "lemma (in ring_homo) image_ideal_surj:\n  assumes \"J\\<triangleleft>R\\<^sub>o\" \"f\\<in>surj(R,S)\"\n  shows \"(f``J) \\<triangleleft>R\\<^sub>t\" unfolding target_ring.Ideal_def\n",
        "proof": "proof\n  show \"IsAsubgroup(f``J,U)\"\n  proof (rule image_subgroup)\n    show \"IsAgroup(R,A)\" using origin_ring.ringAssum unfolding IsAring_def by auto\n    show \"f : R \\<rightarrow> S\" using fun .\n    show \"IsAsubgroup(J,A)\" using assms unfolding origin_ring.Ideal_def by auto\n    show \"Homomor(f,R,A,S,U)\" using homomorphism\n      unfolding ringHomomor_def[OF origin target]\n      by auto\n    show \"IsAgroup(S,U)\" using target_ring.ringAssum\n      unfolding IsAring_def by auto\n  qed\n  {\n    fix x y assume xy:\"x\\<in>f``J\" \"y\\<in>S\"\n    from xy(1) obtain j where x:\"x=f`j\" \"j\\<in>J\" using func_imagedef\n      fun origin_ring.ideal_dest_subset[OF assms(1)] by auto\n    from xy(2) have \"y\\<in>f``R\" using assms(2) surj_range_image_domain\n      by auto\n    then obtain s where y:\"y=f`s\" \"s\\<in>R\" using func_imagedef\n      origin_ring.ideal_dest_subset[OF assms(1)] \n      fun by auto\n    from x(1) y(1) have \"V`\\<langle>x,y\\<rangle> = V`\\<langle>f`j,f`s\\<rangle>\"\n      \"V`\\<langle>y,x\\<rangle> = V`\\<langle>f`s,f`j\\<rangle>\" by auto\n    then have \"V`\\<langle>x,y\\<rangle> = f`(M`\\<langle>j,s\\<rangle>)\" \"V`\\<langle>y,x\\<rangle> = f`(M`\\<langle>s,j\\<rangle>)\"\n      using homomor_dest_mult[of s j]\n        homomor_dest_mult[of j s]\n        x(2) y(2) origin_ring.ideal_dest_subset[OF assms(1)] by auto\n    moreover have \"j\\<cdot>\\<^sub>Rs\\<in>J\" \"s\\<cdot>\\<^sub>Rj\\<in>J\" using origin_ring.ideal_dest_mult[OF assms(1)]\n      x(2) y(2) by auto\n    ultimately have \"(x\\<cdot>\\<^sub>Sy)\\<in>f``J\" \"(y\\<cdot>\\<^sub>Sx)\\<in>f``J\"\n      using func_imagedef fun origin_ring.ideal_dest_subset[OF assms(1)]\n      by auto\n  }\n  then show \"\\<forall>x\\<in>f `` J. \\<forall>y\\<in>S. (y\\<cdot>\\<^sub>Sx) \\<in> f `` J \\<and> (x\\<cdot>\\<^sub>Sy) \\<in> f `` J\"\n    by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Group_ZF_5"
        ],
        "source": "IsarMathLib/Ring_ZF_3.thy",
        "id": 1859,
        "informal": " If an ideal J in ring R is contained in the image of homomorphism f from ring R to ring S, and f is surjective, then the image of J under f is contained in the ring R's subset Rt (target ring)."
    },
    "178": {
        "type": "lemma",
        "text": "text\\<open>A more familiar definition of inverse image.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\"\n  ",
        "using": [
            "func1_1_L14"
        ],
        "statement": "lemma func1_1_L15: assumes A1: \"f:X\\<rightarrow>Y\"\n  shows \"f-``(A) = {x\\<in>X. f`(x) \\<in> A}\"\n",
        "proof": "proof -\n  have \"f-``(A) = (\\<Union>y\\<in>A . f-``{y})\" \n    by (rule vimage_eq_UN)\n  with A1 show ?thesis using func1_1_L14 by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2598,
        "informal": " Given a function f from X to Y (A1), the preimage of set A under f is equal to the set of x in X such that the image of x under f is an element of A.\n\nIn simpler terms, if f maps the element x in X to y in Y, then x is in the preimage of A under f if and only if y is in A."
    },
    "179": {
        "type": "definition",
        "text": "text\\<open>We say that three sets $(R,A,M)$ form a ring if $(R,A)$ is an abelian \n  group, $(R,M)$ is a monoid and $A$ is distributive with respect to $M$ on \n  $R$. $A$ represents the additive operation on $R$. \n  As such it is a subset of $(R\\times R)\\times R$ (recall that in ZF set theory\n  functions are sets).\n  Similarly $M$ represents the multiplicative operation on $R$ and is also\n  a subset of $(R\\times R)\\times R$.\n  We  don't require the multiplicative operation to be commutative in the \n  definition of a ring.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsAring(R,A,M) \\<equiv> IsAgroup(R,A) \\<and> (A {is commutative on} R) \\<and> \n  IsAmonoid(R,M) \\<and> IsDistributive(R,A,M)\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1798,
        "informal": " \"R with multiplication M is an associative ring with respect to multiplication A if and only if R is a group under A, A is commutative under R, R is an abelian monoid under M, and multiplication A is distributive over the monoid M.\" \n\nOr more succinctly: \"R with multiplication M is an associative ring if and only if it is a group under A, commutative under A, an abelian monoid under M, and multiplication distributes over monoid M.\""
    },
    "180": {
        "type": "lemma",
        "text": "text\\<open>If $f$ is a slope, then \n  $|f(p\\cdot q)-p\\cdot f(q)|\\leq (|p|+1)\\cdot$\\<open>max\\<delta>\\<close>$(f)$.\n  Proof by cases on $0 \\leq p$.\\<close> \n",
        "assumes": "assumes A1: \"f\\<in>\\<S>\" and A2: \"p\\<in>\\<int>\" \"q\\<in>\\<int>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_2_1_L2B",
            "Int_ZF_1_1_L4",
            "Int_ZF_2_1_L8",
            "Int_ZF_2_L18",
            "Int_ZF_2_2_L2",
            "Int_ZF_2_L19A",
            "Int_ZF_2_2_L3"
        ],
        "statement": "lemma (in int1) Int_ZF_2_2_L4: \n  assumes A1: \"f\\<in>\\<S>\" and A2: \"p\\<in>\\<int>\" \"q\\<in>\\<int>\"\n  shows \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n",
        "proof": "proof -\n  { assume \"\\<zero>\\<lsq>p\"\n    moreover from A1 A2 have \"abs(f`(\\<zero>\\<cdot>q)\\<rs>\\<zero>\\<cdot>f`(q)) \\<lsq> (abs(\\<zero>)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n      using int_zero_one_are_int Int_ZF_2_1_L2B Int_ZF_1_1_L4 \n\tInt_ZF_2_1_L8 Int_ZF_2_L18 by simp\n    moreover from A1 A2 have \n      \"\\<forall>p. \\<zero>\\<lsq>p \\<and> abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f) \\<longrightarrow>\n      abs(f`((p\\<ra>\\<one>)\\<cdot>q)\\<rs>(p\\<ra>\\<one>)\\<cdot>f`(q)) \\<lsq> (abs(p\\<ra>\\<one>)\\<ra> \\<one>)\\<cdot>max\\<delta>(f)\"\n      using Int_ZF_2_2_L2 by simp\n    ultimately have \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\" \n      by (rule Induction_on_int) }\n  moreover\n  { assume \"\\<not>(\\<zero>\\<lsq>p)\"\n    with A2 have \"p\\<lsq>\\<zero>\" using Int_ZF_2_L19A by simp\n    moreover from A1 A2 have \"abs(f`(\\<zero>\\<cdot>q)\\<rs>\\<zero>\\<cdot>f`(q)) \\<lsq> (abs(\\<zero>)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\"\n      using int_zero_one_are_int Int_ZF_2_1_L2B Int_ZF_1_1_L4\n\tInt_ZF_2_1_L8 Int_ZF_2_L18 by simp\n    moreover from A1 A2 have \n      \"\\<forall>p. p\\<lsq>\\<zero> \\<and> abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f) \\<longrightarrow>\n      abs(f`((p\\<rs>\\<one>)\\<cdot>q)\\<rs>(p\\<rs>\\<one>)\\<cdot>f`(q)) \\<lsq> (abs(p\\<rs>\\<one>)\\<ra> \\<one>)\\<cdot>max\\<delta>(f)\"\n      using Int_ZF_2_2_L3 by simp\n    ultimately have \"abs(f`(p\\<cdot>q)\\<rs>p\\<cdot>f`(q)) \\<lsq> (abs(p)\\<ra>\\<one>)\\<cdot>max\\<delta>(f)\" \n      by (rule Back_induct_on_int) }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 889,
        "informal": " Assuming function f is an element of set S and p, q are integers, the absolute value of the product of f applied to p and q, and p itself, is less than or equal to the maximum of one times the absolute value of p and the absolute value of f."
    },
    "181": {
        "type": "lemma",
        "text": "text\\<open>\\<open>RealAddition\\<close> is defined as the projection of the\n  first operation on slopes (that is, slope addition) on the quotient \n  (slopes divided by the \"almost equal\" relation. The next lemma plays with\n  definitions to show that this is the same as the operation induced on the \n  appriopriate quotient group. The names \\<open>AH\\<close>, \\<open>Op1\\<close> \n  and \\<open>FR\\<close> are used in \\<open>group1\\<close> context to denote almost \n  homomorphisms, the first operation on \\<open>AH\\<close> and finite range \n  functions resp.\\<close>\n",
        "assumes": "assumes\n  \"AH = AlmostHoms(int,IntegerAddition)\" and\n  \"Op1 = AlHomOp1(int,IntegerAddition)\" and\n  \"FR = FinRangeFunctions(int,int)\"\n  ",
        "using": [
            "assms",
            "RealAddition_def",
            "SlopeEquivalenceRel_def",
            "QuotientGroupOp_def",
            "Slopes_def",
            "SlopeOp1_def",
            "BoundedIntMaps_def"
        ],
        "statement": "lemma Real_ZF_1_L8: assumes\n  \"AH = AlmostHoms(int,IntegerAddition)\" and\n  \"Op1 = AlHomOp1(int,IntegerAddition)\" and\n  \"FR = FinRangeFunctions(int,int)\"\n  shows \"RealAddition = QuotientGroupOp(AH,Op1,FR)\"\n  ",
        "proof": "using assms RealAddition_def SlopeEquivalenceRel_def\n    QuotientGroupOp_def Slopes_def SlopeOp1_def BoundedIntMaps_def\n  by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1639,
        "informal": " Given that `AH` is the almost homeomorphism from integers to integers for addition, `Op1` is the homeomorphism operation for integer addition, and `FR` is the finite range functions for integers to integers, it can be shown that RealAddition is equal to the quotient group operation with respect to `AH`, `Op1`, and `FR`."
    },
    "182": {
        "type": "theorem",
        "text": "text\\<open>In the file @{file \"Topology_ZF_properties.thy\"}, it is proven that $\\mathbb{N}$ is\nlindeloef if and only if the axiom of countable choice holds for subsets of $Pow(\\mathbb{N})$.\nNow we check that, in ZF, this space is always anti-lindeloef.\\<close>\n",
        "assumes": "",
        "using": [
            "subset_imp_lepoll",
            "eqpoll_sym",
            "func1_1_L3",
            "f",
            "T(1)",
            "Pow_is_top",
            "bij_def",
            "inj_def",
            "two_top_spaces0.cont_image_com",
            "lin",
            "IsLindeloef_def"
        ],
        "statement": "theorem nat_anti_lindeloef:\n  shows \"Pow(nat){is anti-lindeloef}\"\n",
        "proof": "proof-\n  {\n   fix A assume A:\"A\\<in>Pow(\\<Union>Pow(nat))\" \"(\\<Union>(Pow(nat){restricted to}A)){is lindeloef in}(Pow(nat){restricted to}A)\"\n    from A(1) have \"A\\<subseteq>nat\" by auto\n    then have \"Pow(nat){restricted to}A=Pow(A)\" unfolding RestrictedTo_def by blast\n    with A(2) have lin:\"A{is lindeloef in}Pow(A)\" using subset_imp_lepoll by auto\n    {\n      fix T assume T:\"T{is a topology}\" \"\\<Union>T\\<approx>A\"\n      then have \"A\\<approx>\\<Union>T\" using eqpoll_sym by auto\n      then obtain f where f:\"f\\<in>bij(A,\\<Union>T)\" unfolding eqpoll_def by auto\n      then have \"f\\<in>surj(A,\\<Union>T)\" unfolding bij_def by auto\n      moreover then have \"IsContinuous(Pow(A),T,f)\" unfolding IsContinuous_def\n        surj_def using func1_1_L3 by blast\n      moreover have \"two_top_spaces0(Pow(A),T,f)\" unfolding two_top_spaces0_def\n        using f T(1) Pow_is_top unfolding bij_def inj_def by auto\n      ultimately have \"(\\<Union>T){is lindeloef in}T\" using two_top_spaces0.cont_image_com\n        lin unfolding IsLindeloef_def by auto\n    }\n    then have \"A{is in the spectrum of} (\\<lambda>T. ((\\<Union>T){is lindeloef in}T))\" unfolding Spec_def by auto\n  }\n  then show ?thesis unfolding IsAntiLin_def antiProperty_def by auto   \nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2401,
        "informal": " The statement \"Pow(nat){is anti-lindeloef}\" in Isabelle/ZF can be translated to natural language as:\n\n\"The powerset of natural numbers has no anti-Lindelöf property.\" \n\nIn other words, the powerset of natural numbers cannot be covered by a countable collection of sets, each of which has the property of being a \"large set\" with regard to another property. This concept is opposite to the Lindelöf property, where every open cover of a topological space has a countable subcover."
    },
    "183": {
        "type": "lemma",
        "text": "text\\<open>The first examples of ideals are the whole ring and the zero ring:\\<close>\nlemma (in ring0) R_ideal:\n  shows \"R \\<triangleleft>R\" unfolding Ideal_def apply simp\n  using add_group.group0_3_T3[of R]\n  Ring_ZF_1_L3(1) Ring_ZF_1_L2(1) unfolding IsOpClosed_def\n  using Ring_ZF_1_L4(1,3) by auto\n",
        "assumes": "",
        "using": [
            "Ring_ZF_1_L6",
            "add_group.unit_singl_subgr"
        ],
        "statement": "lemma (in ring0) zero_ideal:\n  shows \"{\\<zero>} \\<triangleleft>R\" unfolding Ideal_def\n  ",
        "proof": "using\n   Ring_ZF_1_L6 add_group.unit_singl_subgr by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Finite1",
            "IsarMathLib.Cardinal_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF_2.thy",
        "id": 1838,
        "informal": " In the ring0 context, the set of zero elements forms an ideal."
    },
    "184": {
        "type": "lemma",
        "text": "text\\<open>We can put a positive factor on the other side of an inequality, \n  changing it to its inverse, version with the product\n  initially on the right hand side.\\<close>\n",
        "assumes": "assumes A1: \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\\<^sub>+\" and A2: \"a \\<lsq> b\\<cdot>c\"\n  ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L5A"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L4B: \n  assumes A1: \"b\\<in>\\<real>\"  \"c\\<in>\\<real>\\<^sub>+\" and A2: \"a \\<lsq> b\\<cdot>c\"\n  shows \"a\\<cdot>c\\<inverse> \\<lsq> b\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L5A\n  by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1713,
        "informal": " Assuming `b` and `c` are real numbers with `b` in the reals and `c` being positive, if `a` is less than `b` multiplied by `c`, then `a` is less than the reciprocal of `b` multiplied by `c`."
    },
    "185": {
        "type": "lemma",
        "text": "text\\<open>The trivial topology is resolvable, if it is defined over a set with more than one point.\\<close>\n",
        "assumes": "assumes \"\\<exists>x y. x\\<in>X \\<and> y\\<in>X \\<and> x\\<noteq>y\"\n  ",
        "using": [
            "indiscrete_partition",
            "xy(1)",
            "topology0_ptopology",
            "indiscrete_ptopology[of",
            "\"X\"]",
            "topology0.cl_contains_set",
            "topology0.cl_is_closed",
            "top0",
            "topology0.Top_3_L11(1)",
            "xy(2)",
            "xy(1,2)",
            "IsRes_def"
        ],
        "statement": "lemma trivial_is_resolvable:\n  assumes \"\\<exists>x y. x\\<in>X \\<and> y\\<in>X \\<and> x\\<noteq>y\"\n  shows \"{0,X}{is resolvable}\"\n",
        "proof": "proof-\n  from assms obtain x y where xy:\"x\\<in>X\" \"y\\<in>X\" \"x\\<noteq>y\" by auto\n  {\n    fix A assume A:\"A{is closed in}{0,X}\" \"A\\<subseteq>X\"\n    then have \"X-A\\<in>{0,X}\" unfolding IsClosed_def by auto\n    then have \"X-A=0\\<or>X-A=X\" by auto\n    with A(2) have \"A=X\\<or>X-A=X\" by auto moreover\n    {\n      assume \"X-A=X\"\n      then have \"X-(X-A)=0\" by auto\n      with A(2) have \"A=0\" by auto\n    }\n    ultimately have \"A=X\\<or>A=0\" by auto\n    then have \"A=0\\<or>A=X\" by auto\n  }\n  then have cl:\"\\<forall>A\\<in>Pow(X). A{is closed in}{0,X} \\<longrightarrow> A=0\\<or>A=X\" by auto\n  from xy(3) have \"{x}\\<inter>{y}=0\" by auto moreover\n  {\n    have \"{X}{is a partition of}X\" using indiscrete_partition xy(1) by auto\n    then have top:\"topology0(PTopology X {X})\" using topology0_ptopology by auto\n    have \"X\\<noteq>0\" using xy(1) by auto\n    then have \"(PTopology X {X})={0,X}\" using indiscrete_ptopology[of \"X\"] by auto\n    with top have top0:\"topology0({0,X})\" by auto\n    then have \"x\\<in>Closure({x},{0,X})\" using topology0.cl_contains_set xy(1) by auto moreover\n    have \"Closure({x},{0,X}) {is closed in}{0,X}\" using topology0.cl_is_closed top0 xy(1) by auto\n    moreover note cl\n    moreover have \"Closure({x},{0,X})\\<subseteq>X\" using topology0.Top_3_L11(1) top0 xy(1) by auto\n    ultimately have \"Closure({x},{0,X})=X\" by auto\n  }\n  moreover\n  {\n    have \"{X}{is a partition of}X\" using indiscrete_partition xy(1) by auto\n    then have top:\"topology0(PTopology X {X})\" using topology0_ptopology by auto\n    have \"X\\<noteq>0\" using xy(1) by auto\n    then have \"(PTopology X {X})={0,X}\" using indiscrete_ptopology[of \"X\"] by auto\n    with top have top0:\"topology0({0,X})\" by auto\n    then have \"y\\<in>Closure({y},{0,X})\" using topology0.cl_contains_set xy(2) by auto moreover\n    have \"Closure({y},{0,X}) {is closed in}{0,X}\" using topology0.cl_is_closed top0 xy(2) by auto\n    moreover note cl\n    moreover have \"Closure({y},{0,X})\\<subseteq>X\" using topology0.Top_3_L11(1) top0 xy(2) by auto\n    ultimately have \"Closure({y},{0,X})=X\" by auto\n  } \n  ultimately show ?thesis using xy(1,2) unfolding IsRes_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.Topology_ZF_1b",
            "IsarMathLib.Topology_ZF_9",
            "IsarMathLib.Topology_ZF_properties_2",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_properties_3.thy",
        "id": 2434,
        "informal": " Given a set X with distinct elements x and y, the set {0, X} is resolvable."
    },
    "186": {
        "type": "lemma",
        "text": "text\\<open>The quotient group relation is symmetric.\\<close>\n",
        "assumes": "assumes A1:\"IsAsubgroup(H,P)\"\n  ",
        "using": [
            "QuotientGroupRel_def",
            "group0_3_T3A",
            "group0_2_L12",
            "symI"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L2:\n  assumes A1:\"IsAsubgroup(H,P)\"\n  shows \"sym(QuotientGroupRel(G,P,H))\"\n",
        "proof": "proof -\n  {  \n    fix a b assume A2: \"\\<langle> a,b\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n    with A1 have \"(a\\<cdot>b\\<inverse>)\\<inverse> \\<in> H\" \n      using QuotientGroupRel_def group0_3_T3A\n      by simp\n    moreover from A2 have \"(a\\<cdot>b\\<inverse>)\\<inverse> =  b\\<cdot>a\\<inverse>\"\n      using QuotientGroupRel_def group0_2_L12\n      by simp\n    ultimately have \"b\\<cdot>a\\<inverse> \\<in> H\" by simp\n    with A2 have \"\\<langle> b,a\\<rangle> \\<in> QuotientGroupRel(G,P,H)\"\n      using QuotientGroupRel_def by simp \n  }\n  then show ?thesis using symI by simp\nqed\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 547,
        "informal": " Assuming H is a subgroup of a group G with respect to relation P, show that the symmetry holds for the quotient relation of G and P over H."
    },
    "187": {
        "type": "lemma",
        "text": "text\\<open>Composition of slopes is a slope.\\<close>\n",
        "assumes": "assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  ",
        "using": [
            "assms",
            "Int_ZF_2_1_L1",
            "group1.Group_ZF_3_4_T1"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L11:\n  assumes \"s\\<in>\\<S>\"  \"r\\<in>\\<S>\"\n  shows \"s\\<circ>r \\<in> \\<S>\"\n  ",
        "proof": "using assms Int_ZF_2_1_L1 group1.Group_ZF_3_4_T1 by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 858,
        "informal": " If s and r are in set S, then the composition s cir c r is also in set S."
    },
    "188": {
        "type": "theorem",
        "text": "text\\<open>The image of a subgroup is a subgroup\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \n    \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\" \"IsAsubgroup(K,P)\"\n  ",
        "using": [
            "group0.group0_3_L2",
            "group0_def",
            "func_imagedef",
            "sub",
            "apply_type",
            "group0.group0_3_L5",
            "image_inv",
            "group0.group0_3_T3A",
            "homomor_eq",
            "group0.group0_3_L6",
            "assms(4)",
            "group0.group0_3_T3"
        ],
        "statement": "theorem image_subgroup:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \n    \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\" \"IsAsubgroup(K,P)\"\n  shows \"IsAsubgroup(f``K,F)\"\n",
        "proof": "proof - \n  from assms(1,5) have sub: \"K\\<subseteq>G\" using group0.group0_3_L2 \n    unfolding group0_def by simp\n  from assms(2) have \"group0(H,F)\" unfolding group0_def by simp\n  moreover from assms(4) have \"f``(K) \\<subseteq> H\" \n    using func_imagedef sub apply_type by auto\n  moreover\n  from assms(1,4,5) sub have \"f`(TheNeutralElement(G,P)) \\<in> f``(K)\"\n    using group0.group0_3_L5 func_imagedef unfolding group0_def \n    by auto\n  hence \"f``(K) \\<noteq> 0\" by blast\n  moreover\n  { fix x assume \"x\\<in>f``(K)\"\n    with assms(4) sub obtain q where q: \"q\\<in>K\" \"x=f`(q)\" \n      using func_imagedef by auto\n    with assms(1-4) sub have \"GroupInv(H,F)`(x) = f`(GroupInv(G,P)`q)\" \n      using image_inv by auto\n    with assms(1,4,5) q(1) sub have \"GroupInv(H,F)`(x) \\<in> f``(K)\" \n      using group0.group0_3_T3A func_imagedef unfolding group0_def \n      by auto\n  } hence \"\\<forall>x\\<in>f``(K). GroupInv(H, F)`(x) \\<in> f``(K)\" by auto\n  moreover \n  { fix x y assume \"x\\<in>f``(K)\" \"y\\<in>f``(K)\"\n    with assms(4) sub obtain q\\<^sub>x q\\<^sub>y where \n      q: \"q\\<^sub>x\\<in>K\" \"x=f`(q\\<^sub>x)\" \"q\\<^sub>y\\<in>K\" \"y=f`(q\\<^sub>y)\" \n      using func_imagedef by auto\n    with assms(1-3) sub have \"F`\\<langle>x,y\\<rangle> = f`(P`\\<langle>q\\<^sub>x,q\\<^sub>y\\<rangle>)\" \n      using homomor_eq by force\n    moreover from assms(1,5) q(1,3) have \"P`\\<langle>q\\<^sub>x,q\\<^sub>y\\<rangle> \\<in> K\" \n      using group0.group0_3_L6 unfolding group0_def by simp\n    ultimately have \"F`\\<langle>x,y\\<rangle>  \\<in> f``(K)\" \n      using assms(4) sub func_imagedef by auto\n  } then have  \"f``(K) {is closed under} F\" unfolding IsOpClosed_def \n    by simp\n  ultimately show ?thesis using group0.group0_3_T3 by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 656,
        "informal": " Given groups G with respect to operation P, H with respect to operation F, a homomorphism f from G to H, and a subgroup K of G with respect to operation P, the image of subgroup K under homomorphism f is a subgroup of H with respect to operation F."
    },
    "189": {
        "type": "lemma",
        "text": "text\\<open>For antisymmetric relations minimum of a set is unique if it exists.\\<close>\n",
        "assumes": "assumes A1: \"antisym(r)\" and A2: \"HasAminimum(r,A)\"\n  ",
        "using": [
            "HasAminimum_def"
        ],
        "statement": "lemma Order_ZF_4_L2: assumes A1: \"antisym(r)\" and A2: \"HasAminimum(r,A)\"\n  shows \"\\<exists>!m. m\\<in>A \\<and> (\\<forall>x\\<in>A. \\<langle> m,x\\<rangle> \\<in> r)\"\n",
        "proof": "proof\n  from A2 show \"\\<exists>m. m \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>m, x\\<rangle> \\<in> r)\"\n    using HasAminimum_def by auto\n  fix m1 m2 assume \n    A2: \"m1 \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>m1, x\\<rangle> \\<in> r)\" \"m2 \\<in> A \\<and> (\\<forall>x\\<in>A. \\<langle>m2, x\\<rangle> \\<in> r)\"\n    then have \"\\<langle>m1,m2\\<rangle> \\<in> r\" \"\\<langle>m2,m1\\<rangle> \\<in> r\" by auto\n    with A1 show \"m1=m2\" by (rule Fol1_L4)\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1276,
        "informal": " Given that relation `r` is antisymmetric and has a minimum in set `A`, there exists an element `m` in `A` such that every element `x` in `A` is related to `m` by `r`."
    },
    "190": {
        "type": "lemma",
        "text": "text\\<open>We first show that we can use theorems proven in some proof contexts\n  (locales). The locale \\<open>group1\\<close> requires assumption that we deal with\n  an abelian group. The next lemma allows to use all theorems proven \n  in the context called \\<open>group1\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "group1_axioms.intro",
            "group1_def",
            "Int_ZF_1_T2"
        ],
        "statement": "lemma Real_ZF_1_L1: shows \"group1(int,IntegerAddition)\"\n  ",
        "proof": "using group1_axioms.intro group1_def Int_ZF_1_T2 by simp\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.Ring_ZF_1"
        ],
        "source": "IsarMathLib/Real_ZF.thy",
        "id": 1629,
        "informal": " \"In ZF set theory, integer adding is a group under the operation of function composition named 'group1'.\" \n\nOr simply: \"Integer addition forms a group under function composition, named 'group1' in ZF set theory.\""
    },
    "191": {
        "type": "lemma",
        "text": "text\\<open>Infinite subsets of $Z_+$ do not have a maximum - If $A\\subseteq Z_+$\n  then for every integer we can find one in the set that is not smaller.  \n  This is very similar to \\<open>Int_ZF_1_5_L2\\<close>, except we have \\<open>\\<int>\\<^sub>+\\<close>\n  instead of \\<open>\\<int>\\<^sup>+\\<close> here.\\<close>\n",
        "assumes": "assumes A1: \"A \\<subseteq> \\<int>\\<^sub>+\"  and A2: \"A \\<notin> Fin(\\<int>)\" and A3: \"D\\<in>\\<int>\"\n  ",
        "using": [
            "PositiveSet_def",
            "Int_ZF_2_L19",
            "Int_ZF_1_5_L1B",
            "IsBounded_def",
            "Int_bounded_iff_fin"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L2A:\n  assumes A1: \"A \\<subseteq> \\<int>\\<^sub>+\"  and A2: \"A \\<notin> Fin(\\<int>)\" and A3: \"D\\<in>\\<int>\"\n  shows \"\\<exists>n\\<in>A. D\\<lsq>n\"\n",
        "proof": "proof -\n{ assume \"\\<forall>n\\<in>A. \\<not>(D\\<lsq>n)\" \n    moreover from A1 A3 have \"D\\<in>\\<int>\"  \"\\<forall>n\\<in>A. n\\<in>\\<int>\" \n      using PositiveSet_def by auto\n    ultimately have \"\\<forall>n\\<in>A. n\\<lsq>D\"\n      using Int_ZF_2_L19 by blast\n    hence \"\\<forall>n\\<in>A. \\<langle>n,D\\<rangle> \\<in> IntegerOrder\" by simp\n    then have \"IsBoundedAbove(A,IntegerOrder)\"\n      by (rule Order_ZF_3_L10)\n    with A1 have \"IsBounded(A,IntegerOrder)\"\n      using Int_ZF_1_5_L1B IsBounded_def by simp\n    with A2 have False using Int_bounded_iff_fin by auto\n  } thus ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 806,
        "informal": " If A is a subset of the integers and not a finite set, and D is an element of the integers, then there exists a natural number in A less than or equal to D."
    },
    "192": {
        "type": "lemma",
        "text": "text\\<open>A rearrangement with four integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"d\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L5",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L6",
            "Int_ZF_1_2_L3",
            "int_zero_one_are_int"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L6: \n  assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\"  \"d\\<in>\\<int>\"\n  shows \n  \"a\\<rs>(b\\<rs>\\<one>)\\<cdot>c = (d\\<rs>b\\<cdot>c)\\<rs>(d\\<rs>a\\<rs>c)\"\n",
        "proof": "proof -\n  from A1 have T1: \n    \"(d\\<rs>b\\<cdot>c) \\<in> \\<int>\" \"d\\<rs>a \\<in> \\<int>\" \"(\\<rm>(b\\<cdot>c)) \\<in> \\<int>\"\n    using Int_ZF_1_1_L5 Int_ZF_1_1_L4 by auto   \n  with A1 have \n    \"(d\\<rs>b\\<cdot>c)\\<rs>(d\\<rs>a\\<rs>c) = (\\<rm>(b\\<cdot>c))\\<ra>a\\<ra>c\"\n    using Int_ZF_1_1_L6 Int_ZF_1_2_L3 by simp\n  also from A1 T1 have \"(\\<rm>(b\\<cdot>c))\\<ra>a\\<ra>c = a\\<rs>(b\\<rs>\\<one>)\\<cdot>c\" \n    using int_zero_one_are_int Int_ZF_1_1_L6 Int_ZF_1_1_L4 Int_ZF_1_1_L5\n    by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 734,
        "informal": " Given integers a, b, c, and d, if a, b, c, and d are in the set of integers, then a * (b + 1) * c equals (d * b) * c * (d * a * c)."
    },
    "193": {
        "type": "lemma",
        "text": "text\\<open>If $b$ is greater than both $a$ and $a^{-1}$, then $b$ is greater than\n  $|a|$.\\<close>\n",
        "assumes": "assumes A1: \"a\\<lsq>b\" and A2: \"a\\<inverse>\\<lsq> b\" \n  ",
        "using": [
            "OrderedGroup_ZF_3_L2",
            "OrderedGroup_ZF_1_L4",
            "OrderedGroup_ZF_3_L3"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_3_L4: \n  assumes A1: \"a\\<lsq>b\" and A2: \"a\\<inverse>\\<lsq> b\" \n  shows \"\\<bar>a\\<bar>\\<lsq> b\"\n",
        "proof": "proof -\n  { assume \"a\\<in>G\\<^sup>+\" \n    with A1 have \"\\<bar>a\\<bar>\\<lsq> b\" using OrderedGroup_ZF_3_L2 by simp }\n  moreover\n  { assume \"a\\<notin>G\\<^sup>+\"\n    with A1 A2 have \"\\<bar>a\\<bar>\\<lsq> b\" \n      using OrderedGroup_ZF_1_L4 OrderedGroup_ZF_3_L3 by simp }\n  ultimately show \"\\<bar>a\\<bar>\\<lsq> b\" by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1460,
        "informal": " In the group3 theory of Isabelle/ZF, if a relates less than b and the inverse of a also relates less than b, then the negation of a relates less than b holds."
    },
    "194": {
        "type": "lemma",
        "text": "text\\<open>The D operator values can be obtained by considering only ideals.\nThis is useful as we have operations on ideals that we do not have on subsets.\\<close>\n",
        "assumes": "assumes \"T\\<subseteq>R\"\n  ",
        "using": [
            "generated_ideal_contains_set",
            "assms",
            "generated_ideal_is_ideal[OF",
            "assms]",
            "ideal_dest_subset",
            "openBasic_def",
            "generated_ideal_small"
        ],
        "statement": "lemma (in ring0) D_operator_only_ideals:\n  assumes \"T\\<subseteq>R\"\n  shows \"D(T) = D(\\<langle>T\\<rangle>\\<^sub>I)\"\n",
        "proof": "proof\n  have T:\"T\\<subseteq>\\<langle>T\\<rangle>\\<^sub>I\" \"\\<langle>T\\<rangle>\\<^sub>I \\<subseteq>R\" using generated_ideal_contains_set assms\n    generated_ideal_is_ideal[OF assms] ideal_dest_subset by auto\n  with D_operator_preserve_subset show \"D(T) \\<subseteq> D(\\<langle>T\\<rangle>\\<^sub>I)\"\n    by auto\n  {\n    fix t assume \"t\\<in>D(\\<langle>T\\<rangle>\\<^sub>I)\"\n    with T(2) have t:\"t\\<in>Spec\" \"\\<not>(\\<langle>T\\<rangle>\\<^sub>I \\<subseteq>t)\" using openBasic_def by auto\n    {\n      assume as:\"T \\<subseteq> t\"\n      from t(1) have \"t\\<triangleleft>R\" unfolding Spec_def primeIdeal_def by auto\n      with as have \"\\<langle>T\\<rangle>\\<^sub>I \\<subseteq>t\" using generated_ideal_small by auto\n      with t(2) have False by auto\n    }\n    then have \"\\<not>(T \\<subseteq> t)\" by auto\n    with t(1) have \"t\\<in>D(T)\" using openBasic_def assms by auto\n  }\n  then show \"D(\\<langle>T\\<rangle>\\<^sub>I) \\<subseteq> D(T)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF_2",
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Ring_Zariski_ZF.thy",
        "id": 1865,
        "informal": " In the ring0 context, if T is a subset of R, then the difference operator D applied to T is equal to the difference operator D applied to the ideal generated by T."
    },
    "195": {
        "type": "lemma",
        "text": "text\\<open>A sum of complex numbers is complex.\\<close>\n",
        "assumes": "assumes \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  ",
        "using": [
            "assms",
            "axaddopr",
            "apply_funtype"
        ],
        "statement": "lemma (in complex0) axaddcl: assumes \"a \\<in> \\<complex>\"  \"b \\<in> \\<complex>\"\n  shows \"a\\<ca>b \\<in> \\<complex>\"\n  ",
        "proof": "using assms axaddopr apply_funtype by simp\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 60,
        "informal": " Assuming that both `a` and `b` are complex numbers, we have that their sum `a + b` is also a complex number."
    },
    "196": {
        "type": "lemma",
        "text": "text\\<open>The image of a set under a composition of translations is the same as\n  the image under translation by a product.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" \"h\\<in>G\" and\n  A2: \"T\\<^sub>g = LeftTranslation(G,P,g)\"  \"T\\<^sub>h = LeftTranslation(G,P,h)\"\n",
        "using": [
            "image_comp",
            "trans_comp"
        ],
        "statement": "lemma (in group0) trans_comp_image: assumes A1: \"g\\<in>G\" \"h\\<in>G\" and\n  A2: \"T\\<^sub>g = LeftTranslation(G,P,g)\"  \"T\\<^sub>h = LeftTranslation(G,P,h)\"\nshows \"T\\<^sub>g``(T\\<^sub>h``(A)) = LeftTranslation(G,P,g\\<cdot>h)``(A)\"\n",
        "proof": "proof -\n  from A2 have \"T\\<^sub>g``(T\\<^sub>h``(A)) = (T\\<^sub>g O T\\<^sub>h)``(A)\"\n    using image_comp by simp\n  with assms show ?thesis using trans_comp by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 488,
        "informal": " Given that g and h are elements of group G, and the translations T\\_g and T\\_h are left translations with respect to element P and g, and P respectively, it holds that the composition of these translations results in a left translation with respect to the group G and element g \\* h. In symbols: T\\_g (T\\_h(A)) = LeftTranslation(G,P,g \\* h)(A)."
    },
    "197": {
        "type": "lemma",
        "text": "text\\<open>The nonnegative set is contained in the group.\\<close>\n",
        "assumes": "",
        "using": [
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_1_L4"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L4E: shows \"G\\<^sup>+ \\<subseteq> G\"\n  ",
        "proof": "using OrderedGroup_ZF_1_L2 OrderedGroup_ZF_1_L4 by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1373,
        "informal": " In group3, it is shown that the identity element closure (G^+) is a subset of group G."
    },
    "198": {
        "type": "lemma",
        "text": "text\\<open>Another lemma about cancelling with two elements.\\<close>\n",
        "assumes": "assumes \"P {is commutative on} G\" and \"a\\<in>G\"  \"b\\<in>G\"\n  ",
        "using": [
            "assms",
            "inverse_in_group",
            "group0_4_L6AB",
            "group_inv_of_inv"
        ],
        "statement": "lemma (in group0) group0_4_L6AC: \n  assumes \"P {is commutative on} G\" and \"a\\<in>G\"  \"b\\<in>G\"\n  shows \"a\\<cdot>(a\\<cdot>b\\<inverse>)\\<inverse> = b\"\n  ",
        "proof": "using assms inverse_in_group group0_4_L6AB group_inv_of_inv\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 11,
        "informal": " In the group0 theory, if P is a commutative relation on a group G, and a and b are elements in G, then a * (a * b^(-1))^(-1) equals b."
    },
    "199": {
        "type": "lemma",
        "text": "text\\<open>The set of positive slopes is saturated with respect to the relation of \n  equivalence of slopes.\\<close>\n",
        "assumes": "",
        "using": [
            "Int_ZF_2_1_L9B",
            "Int_ZF_2_3_L9"
        ],
        "statement": "lemma (in int1) pos_slopes_saturated: shows \"IsSaturated(AlEqRel,\\<S>\\<^sub>+)\"\n",
        "proof": "proof -\n  have \n    \"equiv(\\<S>,AlEqRel)\" \n    \"AlEqRel \\<subseteq> \\<S> \\<times> \\<S>\"\n    using Int_ZF_2_1_L9B by auto\n  moreover have \"\\<S>\\<^sub>+ \\<subseteq> \\<S>\" by auto\n  moreover have \"\\<forall>f\\<in>\\<S>\\<^sub>+. \\<forall>g\\<in>\\<S>. \\<langle>f,g\\<rangle> \\<in> AlEqRel \\<longrightarrow> g \\<in> \\<S>\\<^sub>+\"\n    using Int_ZF_2_3_L9 by blast\n  ultimately show \"IsSaturated(AlEqRel,\\<S>\\<^sub>+)\"\n    by (rule EquivClass_3_L3)\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_2"
        ],
        "source": "IsarMathLib/Int_ZF_3.thy",
        "id": 913,
        "informal": " In theint1 theory, we have a lemma (called pos_slopes_saturated) stating that the AlEqRel relation, when raised to the power of a sum sign (represented by <S>&plussign;), is a saturated relation with respect to IsSaturated predicate."
    },
    "200": {
        "type": "corollary",
        "text": "text\\<open>The whole space in a densely ordered set is infinite.\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\"  \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  ",
        "using": [
            "\\<open>b\\<in>X\\<close>\\<open>c\\<in>X\\<close>",
            "Order_ZF_2_L1",
            "dense_order_inf_intervals[OF",
            "assms(1)",
            "_",
            "\\<open>c\\<in>X\\<close>\\<open>b\\<in>X\\<close>",
            "assms(2)]",
            "subset_Finite",
            "lesspoll_nat_is_Finite"
        ],
        "statement": "corollary dense_order_infinite:\n  assumes \"IsLinOrder(X,r)\"  \"X{is dense with respect to}r\"\n    \"\\<exists>x y. x\\<noteq>y\\<and>x\\<in>X\\<and>y\\<in>X\"\n  shows \"\\<not>(X\\<prec>nat)\"\n",
        "proof": "proof-\n  from assms(3) obtain b c where B:\"b\\<in>X\"\"c\\<in>X\"\"b\\<noteq>c\" by auto\n  {\n    assume \"\\<langle>b,c\\<rangle>\\<notin>r\"\n    with assms(1) have \"\\<langle>c,b\\<rangle>\\<in>r\" unfolding IsLinOrder_def IsTotal_def using \\<open>b\\<in>X\\<close>\\<open>c\\<in>X\\<close> by auto\n    with assms(2) B obtain z where \"z\\<in>X-{b,c}\"\"\\<langle>c,z\\<rangle>\\<in>r\"\"\\<langle>z,b\\<rangle>\\<in>r\" unfolding IsDense_def by auto\n    then have \"IntervalX(X,r,c,b)\\<noteq>0\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n    then have \"\\<not>(Finite(IntervalX(X,r,c,b)))\" using dense_order_inf_intervals[OF assms(1) _ \\<open>c\\<in>X\\<close>\\<open>b\\<in>X\\<close> assms(2)]\n      by auto moreover\n    have \"IntervalX(X,r,c,b)\\<subseteq>X\" unfolding IntervalX_def by auto\n    ultimately have \"\\<not>(Finite(X))\" using subset_Finite by auto\n    then have \"\\<not>(X\\<prec>nat)\" using lesspoll_nat_is_Finite by auto\n  }\n  moreover\n  {\n    assume \"\\<langle>b,c\\<rangle>\\<in>r\"\n    with assms(2) B obtain z where \"z\\<in>X-{b,c}\"\"\\<langle>b,z\\<rangle>\\<in>r\"\"\\<langle>z,c\\<rangle>\\<in>r\" unfolding IsDense_def by auto\n    then have \"IntervalX(X,r,b,c)\\<noteq>0\" unfolding IntervalX_def using Order_ZF_2_L1 by auto\n    then have \"\\<not>(Finite(IntervalX(X,r,b,c)))\" using dense_order_inf_intervals[OF assms(1) _ \\<open>b\\<in>X\\<close>\\<open>c\\<in>X\\<close> assms(2)]\n      by auto moreover\n    have \"IntervalX(X,r,b,c)\\<subseteq>X\" unfolding IntervalX_def by auto\n    ultimately have \"\\<not>(Finite(X))\" using subset_Finite by auto\n    then have \"\\<not>(X\\<prec>nat)\" using lesspoll_nat_is_Finite by auto\n  }\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7",
            "IsarMathLib.Finite_ZF_1"
        ],
        "source": "IsarMathLib/Topology_ZF_11.thy",
        "id": 2076,
        "informal": " If X is a linearly ordered set with the dense property (every subset has an element between any two distinct elements), then X is not a subset of natural numbers."
    },
    "201": {
        "type": "lemma",
        "text": "text\\<open>We can multiply a strict inequality by a positive number or its inverse.\n\\<close>\n",
        "assumes": "assumes \"a\\<ls>b\"  and \"c\\<in>\\<real>\\<^sub>+\" ",
        "using": [
            "assms",
            "field_cntxts_ok",
            "field1.OrdField_ZF_2_L4"
        ],
        "statement": "lemma (in real1) Real_ZF_1_3_L7:\n  assumes \"a\\<ls>b\"  and \"c\\<in>\\<real>\\<^sub>+\" shows \n  \"a\\<cdot>c \\<ls> b\\<cdot>c\"\n  \"c\\<cdot>a \\<ls> c\\<cdot>b\"\n  \"a\\<cdot>c\\<inverse> \\<ls> b\\<cdot>c\\<inverse>\"\n  ",
        "proof": "using assms field_cntxts_ok field1.OrdField_ZF_2_L4\n  by auto\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1717,
        "informal": " Given real numbers a < a b and some positive real number c, we have:\n\n- ac < bc\n- ca < cb\n- 1 / (ac) > 1 / (bc)\n\nThis is equivalent to saying that ac is smaller than bc, ca is smaller than cb, and the reciprocal of ac is less than the reciprocal of bc."
    },
    "202": {
        "type": "lemma",
        "text": "text\\<open>An intuitively clear, but surprisingly nontrivial fact: identity is the only function from \n  a singleton to itself.\\<close>\n",
        "assumes": "",
        "using": [
            "id_def",
            "apply_funtype"
        ],
        "statement": "lemma singleton_fun_id: shows \"({x} \\<rightarrow> {x}) = {id({x})}\"\n",
        "proof": "proof\n  show \"{id({x})} \\<subseteq> ({x} \\<rightarrow> {x})\"\n    using id_def by simp\n  { let ?g = \"id({x})\"\n    fix f assume \"f : {x} \\<rightarrow> {x}\"\n    then have \"f : {x} \\<rightarrow> {x}\" and \"?g : {x} \\<rightarrow> {x}\"\n      using id_def by auto\n    moreover from \\<open>f : {x} \\<rightarrow> {x}\\<close> have \"\\<forall>x \\<in> {x}. f`(x) = ?g`(x)\"\n      using apply_funtype id_def by auto\n    ultimately have \"f = ?g\" by (rule func_eq)\n  } then show  \"({x} \\<rightarrow> {x}) \\<subseteq> {id({x})}\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2697,
        "informal": " The statement \"singleton_fun_id\" in Isabelle/ZF asserts that the function from a set to itself, where each element maps to itself (i.e., the identity function), is equal to the set of elements application, which maps each element to itself as well. In natural language, \"The identity function is equal to the set of elements each mapped to itself.\""
    },
    "203": {
        "type": "lemma",
        "text": "text\\<open>$a/(a^2) = 1/a $ .\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>K\"  \"a\\<noteq>\\<zero>\"\n  ",
        "using": [
            "Field_ZF_1_L5",
            "Ring_ZF_1_L11",
            "Field_ZF_1_L6",
            "Ring_ZF_1_L3"
        ],
        "statement": "lemma (in field0) Field_ZF_2_L1: assumes A1: \"a\\<in>K\"  \"a\\<noteq>\\<zero>\"\n  shows \"a\\<cdot>(a\\<inverse>)\\<^sup>2 = a\\<inverse>\"\n",
        "proof": "proof -\n  have \"a\\<cdot>(a\\<inverse>)\\<^sup>2 = a\\<cdot>(a\\<inverse>\\<cdot>a\\<inverse>)\" by simp\n  also from A1 have \"\\<dots> =  (a\\<cdot>a\\<inverse>)\\<cdot>a\\<inverse>\" \n    using Field_ZF_1_L5 Ring_ZF_1_L11 \n    by simp\n  also from A1 have \"\\<dots> = a\\<inverse>\" \n    using Field_ZF_1_L6 Field_ZF_1_L5 Ring_ZF_1_L3\n    by simp\n  finally show \"a\\<cdot>(a\\<inverse>)\\<^sup>2 = a\\<inverse>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 153,
        "informal": " Assuming that `a` is an element in the field `K` and `a` is not equal to zero, then `a` multiplied by the inverse of `a` squared equals the inverse of `a`."
    },
    "204": {
        "type": "lemma",
        "text": "text\\<open>A couple of formulae involving $f(m-n)$ and $\\gamma(f,m,n)$.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "Int_ZF_1_1_L4",
            "Int_ZF_2_1_L25",
            "apply_funtype",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_1_L3C",
            "Int_ZF_2_1_L14A",
            "Int_ZF_1_2_L16",
            "Int_ZF_1_1_L7",
            "Int_ZF_1_2_L18"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L26: \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"f`(m\\<rs>n) = \\<gamma>(f,m,n) \\<ra> f`(m) \\<rs> f`(n)\"\n  \"f`(m\\<rs>n) = \\<gamma>(f,m,n) \\<ra> (f`(m) \\<rs> f`(n))\"\n  \"f`(m\\<rs>n) \\<ra> (f`(n) \\<rs> \\<gamma>(f,m,n)) = f`(m)\"\n",
        "proof": "proof -\n  from A1 A2 have T:\n    \"(\\<rm>n) \\<in> \\<int>\"  \"\\<delta>(f,m,\\<rm>n) \\<in> \\<int>\"  \n    \"f`(\\<zero>) \\<in> \\<int>\"  \"f`(m) \\<in> \\<int>\"  \"f`(n) \\<in> \\<int>\"  \"(\\<rm>f`(n)) \\<in> \\<int>\"\n    \"(\\<rm>\\<delta>(f,n,\\<rm>n)) \\<in> \\<int>\"  \n    \"(\\<rm>\\<delta>(f,n,\\<rm>n))  \\<ra> f`(\\<zero>) \\<in> \\<int>\"\n    \"\\<gamma>(f,m,n) \\<in> \\<int>\"\n    using  Int_ZF_1_1_L4 Int_ZF_2_1_L25 apply_funtype Int_ZF_1_1_L5 \n    by auto\n   with A1 A2 have \"f`(m\\<rs>n) = \n    \\<delta>(f,m,\\<rm>n) \\<ra> ((\\<rm>\\<delta>(f,n,\\<rm>n)) \\<ra> f`(\\<zero>) \\<rs> f`(n)) \\<ra> f`(m)\"\n    using Int_ZF_2_1_L3C Int_ZF_2_1_L14A by simp\n  with T have \"f`(m\\<rs>n) =\n    \\<delta>(f,m,\\<rm>n) \\<ra> ((\\<rm>\\<delta>(f,n,\\<rm>n)) \\<ra> f`(\\<zero>)) \\<ra> f`(m) \\<rs> f`(n)\"\n    using Int_ZF_1_2_L16 by simp\n  moreover from T have \n    \"\\<delta>(f,m,\\<rm>n) \\<ra> ((\\<rm>\\<delta>(f,n,\\<rm>n)) \\<ra> f`(\\<zero>)) = \\<gamma>(f,m,n)\"\n    using Int_ZF_1_1_L7 by simp\n  ultimately show  I: \"f`(m\\<rs>n) = \\<gamma>(f,m,n) \\<ra> f`(m) \\<rs> f`(n)\"\n    by simp\n  then have \"f`(m\\<rs>n) \\<ra> (f`(n) \\<rs> \\<gamma>(f,m,n)) = \n    (\\<gamma>(f,m,n) \\<ra> f`(m) \\<rs> f`(n)) \\<ra> (f`(n) \\<rs> \\<gamma>(f,m,n))\"\n    by simp\n  moreover from T have \"\\<dots> = f`(m)\" using Int_ZF_1_2_L18 \n    by simp\n  ultimately show \"f`(m\\<rs>n) \\<ra> (f`(n) \\<rs> \\<gamma>(f,m,n)) = f`(m)\"\n    by simp\n  from T have \"\\<gamma>(f,m,n) \\<in> \\<int>\"  \"f`(m) \\<in> \\<int>\"  \"(\\<rm>f`(n)) \\<in> \\<int>\"\n    by auto\n  then have \n    \"\\<gamma>(f,m,n) \\<ra> f`(m) \\<ra> (\\<rm>f`(n)) =  \\<gamma>(f,m,n) \\<ra> (f`(m) \\<ra> (\\<rm>f`(n)))\"\n    by (rule Int_ZF_1_1_L7)\n  with I show  \"f`(m\\<rs>n) = \\<gamma>(f,m,n) \\<ra> (f`(m) \\<rs> f`(n))\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 877,
        "informal": " Given functions f from integers to integers and integers m and n, the following equalities hold:\n\n1. f(m ∧ n) = γ(f, m, n) ∧ f(m) ∧ f(n)\n2. f(m ∧ n) = γ(f, m, n) ∧ (f(m) ∧ f(n))\n3. f(m) ∧ (f(n) ∧ γ(f, m, n)) = f(m) \n\nwhere γ is some function or operation defined elsewhere. \n\nNote that in Isabelle/ZF code, \"∧\" represents the infix logical and operator, and \"<rs>\" represents the infix infixless or right shift operator (successor). Also, \"<in>\" represents the element of set membership relation, and \"<ra>\" represents the right associativity of the infix operator."
    },
    "205": {
        "type": "lemma",
        "text": "text\\<open>If $\\Phi$ is a (diagonal) uniformity on $X$, then covers of the form \n  $\\{ W\\{ x\\} : x\\in X\\}$ are members of \\<open>UniCovFromUniformity(X,\\<Phi>)\\<close>. \\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \n  ",
        "using": [
            "entourage_props(1)",
            "neigh_not_empty(2)"
        ],
        "statement": "lemma cover_image: \n  assumes \"\\<Phi> {is a uniformity on} X\" \"W\\<in>\\<Phi>\" \n  shows \"{W``{x}. x\\<in>X} \\<in> UniCovFromUniformity(X,\\<Phi>)\"\n",
        "proof": "proof -\n  let ?P = \"{W``{x}. x\\<in>X}\"\n  have \"?P \\<in> Covers(X)\"\n  proof -\n    from assms have \"W \\<subseteq> X\\<times>X\" and \"?P \\<in> Pow(Pow(X))\" \n      using entourage_props(1) by auto\n    moreover have \"\\<Union>?P = X\"\n    proof\n      from \\<open>W \\<subseteq> X\\<times>X\\<close> show \"\\<Union>?P \\<subseteq> X\" by auto\n      from assms show \"X \\<subseteq> \\<Union>?P\" using neigh_not_empty(2) by auto\n    qed\n    ultimately show ?thesis unfolding Covers_def by simp\n  qed\n  moreover from assms(2) have \"\\<exists>W\\<in>\\<Phi>. \\<forall>x\\<in>X. \\<exists>A\\<in>?P. W``{x} \\<subseteq> A\" \n    by auto\n  ultimately show ?thesis unfolding UniCovFromUniformity_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.UniformSpace_ZF"
        ],
        "source": "IsarMathLib/UniformSpace_ZF_2.thy",
        "id": 2492,
        "informal": " If `Φ` is a uniformity on `X` and `W` is an element of `Φ`, then the set of points in `X` contained in the interiors of elements of the `W`-cover of `X` (i.e., the elements of `X` intersecting the interior of every set in `W`) belongs to the union of covers coming from `Φ`. \n\nOr in simpler terms, if `Φ` is a uniformity on a set `X` and `W` is a member of `Φ`, then the set of points in `X` that are covered by all the members of `W` is itself a member of the union of all covers derived from `Φ`."
    },
    "206": {
        "type": "lemma",
        "text": "text\\<open>A product of two products over disjoint sets of indices is the \n  product over the union.\\<close>\n",
        "assumes": "assumes  A1: \"f {is commutative on} G\"  and A2: \"\\<Lambda> \\<in> FinPow(X)\"\n  ",
        "using": [
            "linord",
            "bisec_empty",
            "singleton_in_finpow",
            "union_finpow",
            "bisect_fin",
            "bisec_is_pair",
            "Bisections_def",
            "a_is_fun",
            "setprod_type",
            "IsLinOrder_def",
            "total_is_refl",
            "FinPow_def",
            "bisec_add_point",
            "set_point_bisec",
            "gen_prod_append",
            "gen_prod_singleton",
            "point_set_bisec",
            "IsCommutative_def",
            "apply_funtype",
            "bisec_add_point_case3",
            "bisec_props",
            "semigr_assoc",
            "gen_product_rem_point",
            "rearr3elems"
        ],
        "statement": "lemma (in semigr1) prod_bisect:\n  assumes  A1: \"f {is commutative on} G\"  and A2: \"\\<Lambda> \\<in> FinPow(X)\"\n  shows \n  \"\\<forall>P \\<in>  Bisections(\\<Lambda>). \\<pr>(\\<Lambda>,a) = (\\<pr>(fst(P),a))\\<cdot>(\\<pr>(snd(P),a))\"\n",
        "proof": "proof -\n  have \"IsLinOrder(X,r)\" using linord by simp\n  moreover have \n    \"\\<forall>P \\<in>  Bisections(0). \\<pr>(0,a) = (\\<pr>(fst(P),a))\\<cdot>(\\<pr>(snd(P),a))\"\n    using bisec_empty by simp\n  moreover have \"\\<forall> A \\<in> FinPow(X). \n    ( \\<forall> n \\<in> X - A. \n    (\\<forall>P \\<in>  Bisections(A). \\<pr>(A,a) = (\\<pr>(fst(P),a))\\<cdot>(\\<pr>(snd(P),a))) \n    \\<and> (\\<forall>k\\<in>A. \\<langle>k,n\\<rangle> \\<in> r ) \\<longrightarrow> \n    (\\<forall>Q \\<in>  Bisections(A \\<union> {n}). \n    \\<pr>(A \\<union> {n},a) = (\\<pr>(fst(Q),a))\\<cdot>(\\<pr>(snd(Q),a))))\"\n  proof -\n    { fix A assume \"A \\<in> FinPow(X)\"\n      fix n assume \"n \\<in> X - A\"\n      have \"( \\<forall>P \\<in> Bisections(A). \n\t\\<pr>(A,a) = (\\<pr>(fst(P),a))\\<cdot>(\\<pr>(snd(P),a))) \n\t\\<and> (\\<forall>k\\<in>A. \\<langle>k,n\\<rangle> \\<in> r )  \\<longrightarrow> \n\t(\\<forall>Q \\<in>  Bisections(A \\<union> {n}). \n\t\\<pr>(A \\<union> {n},a) = (\\<pr>(fst(Q),a))\\<cdot>(\\<pr>(snd(Q),a)))\"\n      proof -\n\t{ assume I:\n\t  \"\\<forall>P \\<in> Bisections(A). \\<pr>(A,a) = (\\<pr>(fst(P),a))\\<cdot>(\\<pr>(snd(P),a))\"\n\t  and II: \"\\<forall>k\\<in>A. \\<langle>k,n\\<rangle> \\<in> r\"\n\t  have \"\\<forall>Q \\<in>  Bisections(A \\<union> {n}). \n\t    \\<pr>(A \\<union> {n},a) = (\\<pr>(fst(Q),a))\\<cdot>(\\<pr>(snd(Q),a))\"\n\t  proof -\n\t    { fix Q assume \"Q \\<in>  Bisections(A \\<union> {n})\"\n\t      let ?Q\\<^sub>0 = \"fst(Q)\"\n\t      let ?Q\\<^sub>1 = \"snd(Q)\"\t      \n\t      from \\<open>A \\<in> FinPow(X)\\<close> \\<open>n \\<in> X - A\\<close> have \"A \\<union> {n} \\<in> FinPow(X)\"\n\t\tusing singleton_in_finpow union_finpow by auto\n\t      with \\<open>Q \\<in>  Bisections(A \\<union> {n})\\<close> have\n\t\t\"?Q\\<^sub>0 \\<in> FinPow(X)\" \"?Q\\<^sub>0 \\<noteq> 0\" and \"?Q\\<^sub>1 \\<in> FinPow(X)\" \"?Q\\<^sub>1 \\<noteq> 0\"\n\t\tusing bisect_fin bisec_is_pair Bisections_def by auto\n\t      then have \"\\<pr>(?Q\\<^sub>0,a) \\<in> G\" and \"\\<pr>(?Q\\<^sub>1,a) \\<in> G\"\n\t\tusing a_is_fun setprod_type by auto\n\t      from \\<open>Q \\<in> Bisections(A \\<union> {n})\\<close> \\<open>A \\<in> FinPow(X)\\<close> \\<open>n \\<in> X-A\\<close>\n\t      have \"refl(X,r)\"  \"?Q\\<^sub>0 \\<subseteq> A \\<union> {n}\"  \"?Q\\<^sub>1 \\<subseteq> A \\<union> {n}\" \n\t\t\"A \\<subseteq> X\" and \"n \\<in> X\"\n\t\tusing linord IsLinOrder_def total_is_refl Bisections_def\n\t\tFinPow_def by auto\n\t      from \\<open>refl(X,r)\\<close>  \\<open>?Q\\<^sub>0 \\<subseteq> A \\<union> {n}\\<close>  \\<open>A \\<subseteq> X\\<close> \\<open>n \\<in> X\\<close> II \n\t      have III: \"\\<forall>k \\<in> ?Q\\<^sub>0. \\<langle>k, n\\<rangle> \\<in> r\" by (rule refl_add_point)\n\t      from \\<open>refl(X,r)\\<close>  \\<open>?Q\\<^sub>1 \\<subseteq> A \\<union> {n}\\<close>  \\<open>A \\<subseteq> X\\<close> \\<open>n \\<in> X\\<close> II \n\t      have  IV: \"\\<forall>k \\<in> ?Q\\<^sub>1. \\<langle>k, n\\<rangle> \\<in> r\" by (rule refl_add_point)\n\t      from \\<open>n \\<in> X - A\\<close> \\<open>Q \\<in>  Bisections(A \\<union> {n})\\<close> have\n\t\t\"?Q\\<^sub>0 = {n} \\<or> ?Q\\<^sub>1 = {n} \\<or> \\<langle>?Q\\<^sub>0 - {n},?Q\\<^sub>1-{n}\\<rangle> \\<in>  Bisections(A)\"\n\t\tusing bisec_is_pair bisec_add_point by simp\n\t      moreover\n\t      { assume \"?Q\\<^sub>1 = {n}\"\n\t\tfrom \\<open>n \\<in> X - A\\<close> have \"n \\<notin> A\" by auto\n\t\tmoreover \n\t\tfrom  \\<open>Q \\<in>  Bisections(A \\<union> {n})\\<close> \n\t\thave \"\\<langle>?Q\\<^sub>0,?Q\\<^sub>1 \\<rangle> \\<in>  Bisections(A \\<union> {n})\"\n\t\t  using bisec_is_pair by simp\n\t\twith \\<open>?Q\\<^sub>1 = {n}\\<close> have \"\\<langle>?Q\\<^sub>0, {n}\\<rangle> \\<in>  Bisections(A \\<union> {n})\"\n\t\t  by simp\n\t\tultimately have \"?Q\\<^sub>0 = A\" and \"A \\<noteq> 0\" \n\t\t  using set_point_bisec by auto\n\t\twith \\<open>A \\<in> FinPow(X)\\<close> \\<open>n \\<in> X - A\\<close> II \\<open>?Q\\<^sub>1 = {n}\\<close> \n\t\thave \"\\<pr>(A \\<union> {n},a) = (\\<pr>(?Q\\<^sub>0,a))\\<cdot>\\<pr>(?Q\\<^sub>1,a)\"\n\t\t  using a_is_fun gen_prod_append gen_prod_singleton \n\t\t  by simp }\n\t      moreover\n\t      { assume \"?Q\\<^sub>0 = {n}\"\n\t\tfrom \\<open>n \\<in> X - A\\<close> have \"n \\<in> X\" by auto\n\t\tthen have \"{n} \\<in> FinPow(X)\" and \"{n} \\<noteq> 0\"\n\t\t  using singleton_in_finpow by auto\n\t\tfrom \\<open>n \\<in> X - A\\<close> have \"n \\<notin> A\" by auto\n\t\tmoreover \n\t\tfrom  \\<open>Q \\<in> Bisections(A \\<union> {n})\\<close>\n\t\thave \"\\<langle>?Q\\<^sub>0, ?Q\\<^sub>1\\<rangle> \\<in>  Bisections(A \\<union> {n})\"\n\t\t  using bisec_is_pair by simp\n\t\twith \\<open>?Q\\<^sub>0 = {n}\\<close> have \"\\<langle>{n}, ?Q\\<^sub>1\\<rangle> \\<in>  Bisections(A \\<union> {n})\"\n\t\t  by simp\n\t\tultimately have \"?Q\\<^sub>1 = A\" and \"A \\<noteq> 0\" using point_set_bisec\n\t\t  by auto\n\t\twith A1 \\<open>A \\<in> FinPow(X)\\<close> \\<open>n \\<in> X - A\\<close> II\n\t\t  \\<open>{n} \\<in> FinPow(X)\\<close>  \\<open>{n} \\<noteq> 0\\<close> \\<open>?Q\\<^sub>0 = {n}\\<close>\n\t\thave \"\\<pr>(A \\<union> {n},a) = (\\<pr>(?Q\\<^sub>0,a))\\<cdot>(\\<pr>(?Q\\<^sub>1,a))\"\n\t\t  using a_is_fun gen_prod_append gen_prod_singleton \n\t\t    setprod_type IsCommutative_def by auto }\n\t      moreover\n\t      { assume A4: \"\\<langle>?Q\\<^sub>0 - {n},?Q\\<^sub>1 - {n}\\<rangle> \\<in>  Bisections(A)\"\n\t\twith \\<open>A \\<in> FinPow(X)\\<close> have \n\t\t  \"?Q\\<^sub>0 - {n} \\<in> FinPow(X)\" \"?Q\\<^sub>0 - {n} \\<noteq> 0\" and \n\t\t  \"?Q\\<^sub>1 - {n} \\<in> FinPow(X)\" \"?Q\\<^sub>1 - {n} \\<noteq> 0\"\n\t\t  using FinPow_def Bisections_def by auto\n\t\twith \\<open>n \\<in> X - A\\<close> have \n\t\t  \"\\<pr>(?Q\\<^sub>0 - {n},a) \\<in> G\"  \"\\<pr>(?Q\\<^sub>1 - {n},a) \\<in> G\"  and\n\t\t  T: \"a`(n) \\<in> G\"\n\t\t  using a_is_fun setprod_type apply_funtype by auto\n\t\tfrom \\<open>Q \\<in> Bisections(A \\<union> {n})\\<close> A4 have\n\t\t  \"(\\<langle>?Q\\<^sub>0, ?Q\\<^sub>1 - {n}\\<rangle> \\<in> Bisections(A) \\<and> n \\<in> ?Q\\<^sub>1) \\<or> \n\t\t  (\\<langle>?Q\\<^sub>0 - {n}, ?Q\\<^sub>1\\<rangle> \\<in> Bisections(A) \\<and> n \\<in> ?Q\\<^sub>0) \"\n\t\t  using bisec_is_pair bisec_add_point_case3 by auto\n\t\tmoreover\n\t\t{ assume \"\\<langle>?Q\\<^sub>0, ?Q\\<^sub>1 - {n}\\<rangle> \\<in> Bisections(A)\" and \"n \\<in> ?Q\\<^sub>1\"\n\t\t  then have \"A \\<noteq> 0\" using bisec_props by simp\n\t\t  with A2 \\<open>A \\<in> FinPow(X)\\<close> \\<open>n \\<in> X - A\\<close> I II T IV\n\t\t    \\<open>\\<langle>?Q\\<^sub>0, ?Q\\<^sub>1 - {n}\\<rangle> \\<in> Bisections(A)\\<close> \\<open>\\<pr>(?Q\\<^sub>0,a) \\<in> G\\<close> \n\t\t    \\<open>\\<pr>(?Q\\<^sub>1 - {n},a) \\<in> G\\<close> \\<open>?Q\\<^sub>1 \\<in> FinPow(X)\\<close> \n\t\t    \\<open>n \\<in> ?Q\\<^sub>1\\<close> \\<open>?Q\\<^sub>1 - {n} \\<noteq> 0\\<close>\n\t\t  have \"\\<pr>(A \\<union> {n},a) = (\\<pr>(?Q\\<^sub>0,a))\\<cdot>(\\<pr>(?Q\\<^sub>1,a))\"\n\t\t    using gen_prod_append semigr_assoc gen_product_rem_point \n\t\t    by simp }\n\t\tmoreover\n\t\t{ assume \"\\<langle>?Q\\<^sub>0 - {n}, ?Q\\<^sub>1\\<rangle> \\<in> Bisections(A)\" and \"n \\<in> ?Q\\<^sub>0\"\n\t\t  then have \"A \\<noteq> 0\" using bisec_props by simp\n\t\t  with A1 A2 \\<open>A \\<in> FinPow(X)\\<close> \\<open>n \\<in> X - A\\<close> I II III T \n\t\t    \\<open>\\<langle>?Q\\<^sub>0 - {n}, ?Q\\<^sub>1\\<rangle>\\<in>Bisections(A)\\<close> \\<open>\\<pr>(?Q\\<^sub>0 - {n},a)\\<in>G\\<close> \n\t\t    \\<open>\\<pr>(?Q\\<^sub>1,a) \\<in> G\\<close> \\<open>?Q\\<^sub>0 \\<in> FinPow(X)\\<close> \\<open>n \\<in> ?Q\\<^sub>0\\<close> \\<open>?Q\\<^sub>0-{n}\\<noteq>0\\<close>\n\t\t  have \"\\<pr>(A \\<union> {n},a) = (\\<pr>(?Q\\<^sub>0,a))\\<cdot>(\\<pr>(?Q\\<^sub>1,a))\"\n\t\t    using gen_prod_append rearr3elems gen_product_rem_point \n\t\t      by simp }\n\t\tultimately have\n\t\t  \"\\<pr>(A \\<union> {n},a) = (\\<pr>(?Q\\<^sub>0,a))\\<cdot>(\\<pr>(?Q\\<^sub>1,a))\"\n\t\t  by auto }\n\t      ultimately have \"\\<pr>(A \\<union> {n},a) = (\\<pr>(?Q\\<^sub>0,a))\\<cdot>(\\<pr>(?Q\\<^sub>1,a))\"\n\t\tby auto\t\n\t    } thus ?thesis by simp\n\t  qed\n\t} thus ?thesis by simp\n      qed\n    } thus ?thesis by simp\n  qed  \n  moreover note A2\n  ultimately show ?thesis by (rule fin_ind_add_max)\nqed\n",
        "imports": [
            "IsarMathLib.Partitions_ZF",
            "IsarMathLib.Fold_ZF",
            "IsarMathLib.Enumeration_ZF"
        ],
        "source": "IsarMathLib/Semigroup_ZF.thy",
        "id": 1903,
        "informal": " Given that function `f` is commutative over set `G` and `\\Lambda` is an element of the finite power set of `X`, for every `P` in the set of bisections of `\\Lambda`, the product of the right projection of `P` and `a` equals the product of the projections of `P` on `fst(P)` and `a` separately."
    },
    "207": {
        "type": "theorem",
        "text": "text\\<open>The product of quotient topologies is a quotient topology given that the\n  quotient map is open. This isn't true in general.\\<close>\n",
        "assumes": "assumes \"equiv(\\<Union>T,r)\" \"\\<forall>A\\<in>T. {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}``(A) \\<in> ({quotient by} r)\"\n  ",
        "using": [
            "product_quo_fun",
            "IsContinuous_def",
            "Top_1_4_T1(3)",
            "equiv_quo_is_top",
            "total_quo_equi",
            "topology0.QuotientTop_def",
            "Top_1_4_T1(1)",
            "topSpaceAssum",
            "prod_equiv_rel_surj",
            "topology0_def",
            "vimage_iff",
            "prod_top_point_neighb",
            "prod_open_open_prod",
            "image_iff",
            "product_equiv_rel_fun",
            "Pi_def",
            "function_def",
            "topology0.open_neigh_open",
            "Top_1_4_T1",
            "assms"
        ],
        "statement": "theorem (in topology0) prod_quotient:\n  assumes \"equiv(\\<Union>T,r)\" \"\\<forall>A\\<in>T. {\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}``(A) \\<in> ({quotient by} r)\"\n  shows \"(({quotient by} r)\\<times>\\<^sub>t{quotient by} r) = \n  ({quotient topology in} (((\\<Union>T)//r)\\<times>((\\<Union>T)//r)) {by} ({\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}) {from} (T\\<times>\\<^sub>tT))\"\n",
        "proof": "proof\n  let ?T\\<^sub>r = \"{quotient by} r\"\n  let ?R = \"({quotient topology in} (((\\<Union>T)//r)\\<times>((\\<Union>T)//r)) {by} ({\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}) {from} (T\\<times>\\<^sub>tT))\"\n  { fix A assume A: \"A\\<in>?T\\<^sub>r\\<times>\\<^sub>t?T\\<^sub>r\"\n    with assms(1) have \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}-``(A) \\<in> T\\<times>\\<^sub>tT\"\n      using product_quo_fun unfolding IsContinuous_def by auto\n    moreover \n    from A have \"A\\<subseteq>\\<Union>((?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r))\" by auto\n    with assms(1) have \"A\\<in>Pow(((\\<Union>T)//r)\\<times>((\\<Union>T)//r))\"\n      using Top_1_4_T1(3) equiv_quo_is_top total_quo_equi by auto\n    ultimately have \"A\\<in>?R\"\n      using topology0.QuotientTop_def Top_1_4_T1(1) topSpaceAssum prod_equiv_rel_surj \n      unfolding topology0_def by auto\n  } thus \"(?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r) \\<subseteq> ?R\" by auto\n  { fix A assume \"A\\<in>?R\"\n    with assms(1) have \n      A: \"A \\<subseteq> ((\\<Union>T)//r)\\<times>((\\<Union>T)//r)\" \"{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}-``(A) \\<in> T\\<times>\\<^sub>tT\"\n      using topology0.QuotientTop_def Top_1_4_T1(1) topSpaceAssum prod_equiv_rel_surj \n      unfolding topology0_def by auto\n    { fix C assume \"C\\<in>A\"\n      with A(1) obtain C\\<^sub>1 C\\<^sub>2 where CC: \"C=\\<langle>C\\<^sub>1,C\\<^sub>2\\<rangle>\" \"C\\<^sub>1\\<in>((\\<Union>T)//r)\" \"C\\<^sub>2\\<in>((\\<Union>T)//r)\" by auto\n      then obtain c\\<^sub>1 c\\<^sub>2 where CC1: \"c\\<^sub>1\\<in>\\<Union>T\" \"c\\<^sub>2\\<in>\\<Union>T\" and CC2: \"C\\<^sub>1=r``{c\\<^sub>1}\" \"C\\<^sub>2=r``{c\\<^sub>2}\" \n        unfolding quotient_def by auto\n      with \\<open>C\\<in>A\\<close> CC have \"\\<langle>c\\<^sub>1,c\\<^sub>2\\<rangle>\\<in>{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}-``(A)\"\n        using vimage_iff by auto\n      with A(2) have \n        \"\\<exists>V W. V\\<in>T \\<and> W\\<in>T \\<and> V\\<times>W \\<subseteq> {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}-``(A) \\<and> \\<langle>c\\<^sub>1,c\\<^sub>2\\<rangle> \\<in> V\\<times>W\"\n         using prod_top_point_neighb topSpaceAssum by blast\n       then obtain V W where \n         VW: \"V\\<in>T\" \"W\\<in>T\" \"V\\<times>W \\<subseteq> {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}-``(A)\" \"c\\<^sub>1\\<in>V\" \"c\\<^sub>2\\<in>W\" \n         by blast\n       let ?V\\<^sub>r = \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}``(V)\"\n       let ?W\\<^sub>r = \"{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}``(W)\"\n       from VW assms have P: \"(?V\\<^sub>r\\<times>?W\\<^sub>r) \\<in> (?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r)\" \n          using prod_open_open_prod equiv_quo_is_top by auto\n       { fix S assume \"S\\<in>(?V\\<^sub>r\\<times>?W\\<^sub>r)\"\n         then obtain s\\<^sub>1 s\\<^sub>2 where S: \"S=\\<langle>s\\<^sub>1,s\\<^sub>2\\<rangle>\" \"s\\<^sub>1\\<in>?V\\<^sub>r\" \"s\\<^sub>2\\<in>?W\\<^sub>r\" \n           by blast\n         then obtain t\\<^sub>1 t\\<^sub>2 where \n           T: \"\\<langle>t\\<^sub>1,s\\<^sub>1\\<rangle>\\<in>{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\" \"\\<langle>t\\<^sub>2,s\\<^sub>2\\<rangle>\\<in>{\\<langle>b,r``{b}\\<rangle>. b\\<in>\\<Union>T}\" \"t\\<^sub>1\\<in>V\" \"t\\<^sub>2\\<in>W\" \n           using image_iff by auto\n         with VW(3) have \"\\<exists>S\\<^sub>0\\<in>A. \\<langle>\\<langle>t\\<^sub>1,t\\<^sub>2\\<rangle>,S\\<^sub>0\\<rangle>\\<in>{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\" \n           using vimage_iff by auto\n         then obtain S\\<^sub>0 where \"S\\<^sub>0\\<in>A\" and \n           \"\\<langle>\\<langle>t\\<^sub>1,t\\<^sub>2\\<rangle>,S\\<^sub>0\\<rangle>\\<in>{\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\" \n           by auto \n         moreover from S(1) T VW(1,2) have \n           \"\\<langle>\\<langle>t\\<^sub>1,t\\<^sub>2\\<rangle>,S\\<rangle> \\<in> {\\<langle>\\<langle>b,c\\<rangle>,\\<langle>r``{b},r``{c}\\<rangle>\\<rangle>. \\<langle>b,c\\<rangle>\\<in>\\<Union>T\\<times>\\<Union>T}\"\n            by auto\n         ultimately have \"S\\<in>A\" \n            using product_equiv_rel_fun unfolding Pi_def function_def\n            by auto\n        } hence sub: \"?V\\<^sub>r\\<times>?W\\<^sub>r \\<subseteq> A\" by blast\n        from CC CC2 CC1 \\<open>c\\<^sub>1\\<in>V\\<close> \\<open>c\\<^sub>2\\<in>W\\<close> have \"C \\<in> ?V\\<^sub>r\\<times>?W\\<^sub>r\"\n          using image_iff by auto\n        with P sub have \"\\<exists>U\\<in>(?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r). U\\<subseteq>A \\<and> C\\<in>U  \"\n          by (rule witness_exists1)\n      } hence \"\\<forall>C\\<in>A. \\<exists>U\\<in>(?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r). C\\<in>U \\<and> U\\<subseteq>A\" \n          by blast\n      with assms(1) have \"A\\<in>(?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r)\" \n        using topology0.open_neigh_open Top_1_4_T1 equiv_quo_is_top assms\n        unfolding topology0_def by auto\n  } thus \"?R \\<subseteq> (?T\\<^sub>r)\\<times>\\<^sub>t(?T\\<^sub>r)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2271,
        "informal": " Given a topology `topology0` and an equivalence relation `r` on the union of a collection of sets `T`, if every element in `T` contains all its equivalence classes under `r` and if every equivalence class is a subset of some set in the union of `T`, then the quotient topology of `T` by `r` satisfies the product property, that is, the product of the quotient topology and its subspace topology is equal to the quotient topology of the product of `T` and itself."
    },
    "208": {
        "type": "lemma",
        "text": "text\\<open>If a topology is $T_2$ then it is $T_1$.\\<close>\n",
        "assumes": "assumes A1: \"T {is T\\<^sub>2}\" ",
        "using": [
            "isT2_def",
            "isT1_def"
        ],
        "statement": "lemma T2_is_T1: assumes A1: \"T {is T\\<^sub>2}\" shows \"T {is T\\<^sub>1}\"\n",
        "proof": "proof -\n  { fix x y assume \"x \\<in> \\<Union>T\"  \"y \\<in> \\<Union>T\"  \"x\\<noteq>y\"\n    with A1 have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V=0\"\n      using isT2_def by auto\n    then have \"\\<exists>U\\<in>T. x\\<in>U \\<and> y\\<notin>U\" by auto\n  } then have \"\\<forall> x y. x \\<in> \\<Union>T \\<and> y \\<in> \\<Union>T \\<and>  x\\<noteq>y \\<longrightarrow> \n      (\\<exists>U\\<in>T. x\\<in>U \\<and> y\\<notin>U)\" by simp\n  then show \"T {is T\\<^sub>1}\" using isT1_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2033,
        "informal": " Assuming that T is an instance of T\\_2, prove that T is an instance of T\\_1."
    },
    "209": {
        "type": "definition",
        "text": "text\\<open>In the literature, there exists a class of spaces called sober spaces; where the only non-empty closed\nhyperconnected subspaces are the closures of points and closures of different singletons\nare different.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition IsSober (\"_{is sober}\"90)\n  where \"T{is sober} \\<equiv> \\<forall>A\\<in>Pow(\\<Union>T)-{0}. (A{is closed in}T \\<and> ((T{restricted to}A){is hyperconnected})) \\<longrightarrow> (\\<exists>x\\<in>\\<Union>T. A=Closure({x},T) \\<and> (\\<forall>y\\<in>\\<Union>T. A=Closure({y},T) \\<longrightarrow> y=x) )\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_5"
        ],
        "source": "IsarMathLib/Topology_ZF_7.thy",
        "id": 2241,
        "informal": " A set T is sober if and only if every non-empty subset A of T is both closed and hyperconnected in T, and the unique point in T that belongs to A is the only element mapable to A under the closure operation."
    },
    "210": {
        "type": "lemma",
        "text": "text\\<open>If the set defined by a meta-function is finite, then every set \n  defined by a composition of this meta function with another one is finite.\\<close>\n",
        "assumes": "assumes A1: \"\\<forall>y\\<in>Y. b(y) \\<in> Z\" and A2: \"{a(x). x\\<in>X} \\<in> Fin(Y)\"\n  ",
        "using": [],
        "statement": "lemma Finite1_L6C: \n  assumes A1: \"\\<forall>y\\<in>Y. b(y) \\<in> Z\" and A2: \"{a(x). x\\<in>X} \\<in> Fin(Y)\"\n  shows \"{b(a(x)).x\\<in>X} \\<in> Fin(Z)\"\n",
        "proof": "proof -\n  let ?N = \"{a(x). x\\<in>X}\"\n  from A1 A2 have \"{b(y). y \\<in> ?N} \\<in> Fin(Z)\"\n    by (rule fin_image_fin)\n  moreover have \"{b(a(x)). x\\<in>X} = {b(y). y\\<in> ?N}\" \n    by auto\n  ultimately show ?thesis by simp\nqed\n",
        "imports": [
            "ZF.EquivClass",
            "ZF.Finite",
            "IsarMathLib.func1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/Finite1.thy",
        "id": 204,
        "informal": " If every element in set Y has property b, and the set of functions from X to Y is finite, then the set of images under function a with property b is finite and a subset of set Z."
    },
    "211": {
        "type": "lemma",
        "text": "text\\<open>Let's recall basic properties of the real line. \\<close>\n",
        "assumes": "",
        "using": [
            "OrdRing_ZF_1_L4(2,3)"
        ],
        "statement": "lemma (in reals) basic_props: shows  \"ROrd {is total on} \\<real>\" and \"Add {is commutative on} \\<real>\"\n  ",
        "proof": "using OrdRing_ZF_1_L4(2,3) by auto \n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1767,
        "informal": " In the real numbers, the relation \"ROrd\" is shown to be total and \"Add\" is commutative."
    },
    "212": {
        "type": "lemma",
        "text": "text\\<open>$1$ is nonnegative.\\<close>\n",
        "assumes": "",
        "using": [
            "OrderedGroup_ZF_1_L2",
            "OrderedGroup_ZF_1_L3",
            "OrderedGroup_ZF_1_L1",
            "group0.group0_2_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L3A: shows \"\\<one>\\<in>G\\<^sup>+\"\n  ",
        "proof": "using OrderedGroup_ZF_1_L2 OrderedGroup_ZF_1_L3\n    OrderedGroup_ZF_1_L1 group0.group0_2_L2 by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1360,
        "informal": " In the group3 theory, there is a lemma (named OrderedGroup_ZF_1_L3A) that proves that one belongs to the group's identity element set."
    },
    "213": {
        "type": "definition",
        "text": "text\\<open>A helper expression representing the real part\n  of the sum of two complex numbers.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ReCxAdd(R,A,a,b) \\<equiv> A`\\<langle>fst(a),fst(b)\\<rangle>\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Complex_ZF.thy",
        "id": 43,
        "informal": " \"ReCxAdd(R, A, a, b) holds if and only if the first components of pairs a and b are equal in relation R.\""
    },
    "214": {
        "type": "lemma",
        "text": "text\\<open>A constant function is continuous.\\<close>\n",
        "assumes": "assumes \"T {is a topology}\"\n  ",
        "using": [
            "carr_open",
            "const_vimage_domain",
            "empty_open",
            "const_vimage_empty"
        ],
        "statement": "lemma const_cont: assumes \"T {is a topology}\"\n  shows \"IsContinuous(T,\\<tau>,ConstantFunction(\\<Union>T,c))\"\n",
        "proof": "proof -\n   let ?C = \"ConstantFunction(\\<Union>T,c)\"\n   { fix U assume \"U\\<in>\\<tau>\"\n    have \"?C-``(U) \\<in> T\"\n    proof -\n      { assume \"c\\<in>U\"\n        with assms have \"?C-``(U) \\<in> T\"  using carr_open const_vimage_domain \n          by simp\n      }\n      moreover\n      { assume \"c\\<notin>U\"\n        with assms have \"?C-``(U) \\<in> T\" using empty_open const_vimage_empty \n          by simp\n      }\n      ultimately show \"?C-``(U) \\<in> T\" by auto\n    qed\n  } then show ?thesis unfolding IsContinuous_def\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2088,
        "informal": " Assuming T is a topology, the constant function from the union of T to a constant value c is continuous with respect to T."
    },
    "215": {
        "type": "lemma",
        "text": "text\\<open>We can multiply the sides of one inequality by inverse of another.\\<close>\n",
        "assumes": "assumes \"a\\<lsq>b\" and \"c\\<lsq>d\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L5B"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5I: \n  assumes \"a\\<lsq>b\" and \"c\\<lsq>d\"\n  shows \"a\\<cdot>d\\<inverse> \\<lsq> b\\<cdot>c\\<inverse>\"\n  ",
        "proof": "using assms OrderedGroup_ZF_1_L5 OrderedGroup_ZF_1_L5B\n  by simp\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1392,
        "informal": " If a is less than b and c is less than d in a group, then a times the inverse of d is less than or equal to the inverse of b times c."
    },
    "216": {
        "type": "theorem",
        "text": "text\\<open>We apply previous results to this topology.\\<close>\n",
        "assumes": "assumes \"equiv(\\<Union>T,r)\"\n  ",
        "using": [
            "total_quo_func",
            "quotient_proj_surj",
            "EquivQuo_def",
            "assms"
        ],
        "statement": "theorem (in topology0) total_quo_equi:\n  assumes \"equiv(\\<Union>T,r)\"\n  shows \"\\<Union>({quotient by}r)=(\\<Union>T)//r\"\n  ",
        "proof": "using total_quo_func quotient_proj_surj EquivQuo_def assms by auto\n",
        "imports": [
            "IsarMathLib.Topology_ZF_6",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Topology_ZF_8.thy",
        "id": 2265,
        "informal": " Given a relation `r` on a set `T`, if `r` is an equivalence relation, then the set of equivalence classes of `T` under `r` is equal to the quotient of `T` by `r`."
    },
    "217": {
        "type": "definition",
        "text": "text\\<open> A partially ordered $(L,r)$ set is a meet-semilattice if each two-element subset of $L$\n  has an infimum (i.e. the greatest lower bound). \\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"IsMeetSemilattice(L,r) \\<equiv> \n    r\\<subseteq>L\\<times>L \\<and> IsPartOrder(L,r) \\<and> (\\<forall>x\\<in>L. \\<forall>y\\<in>L. HasAnInfimum(r,{x,y}))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Lattice_ZF.thy",
        "id": 1047,
        "informal": " A binary relation r over aset L is an Meet semilattice if it is a subset of L x L, a part order, and every pair of elements x and y in L has an infimum in r."
    },
    "218": {
        "type": "lemma",
        "text": "text\\<open>A reformulation of the definition of the relation induced by\n  a function, kind of converse of \\<open>def_of_ind_relA\\<close>.\\<close>\n",
        "assumes": "assumes \"f:A\\<rightarrow>B\" and \n  \"x\\<in>A\"  \"y\\<in>A\" and \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\"\n  ",
        "using": [
            "assms",
            "func1_1_L1",
            "InducedRelation_def"
        ],
        "statement": "lemma def_of_ind_relB: assumes \"f:A\\<rightarrow>B\" and \n  \"x\\<in>A\"  \"y\\<in>A\" and \"\\<langle>f`(x),f`(y)\\<rangle> \\<in> R\"\n  shows \"\\<langle>x,y\\<rangle> \\<in> InducedRelation(f,R)\"\n  ",
        "proof": "using assms func1_1_L1 InducedRelation_def by simp\n",
        "imports": [
            "ZF.Order",
            "IsarMathLib.Order_ZF_1a",
            "IsarMathLib.func_ZF"
        ],
        "source": "IsarMathLib/func_ZF_1.thy",
        "id": 2728,
        "informal": " If function `f` maps elements of set `A` to elements of `B` and `x`, `y` are in `A` with their images being related in relation `R`, then `x` and `y` are in the indented relation generated by `f` and `R`."
    },
    "219": {
        "type": "theorem",
        "text": "text\\<open>Endomoprhisms of a group form a monoid with composition as the binary operation,\n  with the identity map as the neutral element.\\<close>\n",
        "assumes": "",
        "using": [
            "group_op_closed",
            "eq_endomor",
            "Group_ZF_2_5_L2(2)",
            "end_composition",
            "IsOpClosed_def",
            "monoid0.group0_1_T1",
            "Group_ZF_2_5_L2(1)",
            "monoid0_def",
            "group0_1_L6"
        ],
        "statement": "theorem (in group0) end_comp_monoid:\n  shows \"IsAmonoid(End(G,P),InEnd(Composition(G),G,P))\"\n  and \"TheNeutralElement(End(G,P),InEnd(Composition(G),G,P))=id(G)\"\n",
        "proof": "proof -\n  let ?C\\<^sub>0 = \"InEnd(Composition(G),G,P)\"\n  have fun: \"id(G):G\\<rightarrow>G\" unfolding id_def by auto\n  { fix g h assume \"g\\<in>G\"\"h\\<in>G\"\n    then have \"id(G)`(g\\<cdot>h)=(id(G)`g)\\<cdot>(id(G)`h)\"\n      using group_op_closed by simp\n  } \n  with groupAssum fun have \"id(G) \\<in> End(G,P)\" using eq_endomor by simp \n  moreover  have A0: \"id(G)=TheNeutralElement(G \\<rightarrow> G, Composition(G))\" \n    using Group_ZF_2_5_L2(2) by auto \n  ultimately have A1: \"TheNeutralElement(G \\<rightarrow> G, Composition(G)) \\<in> End(G,P)\" by auto \n  moreover have A2: \"End(G,P) \\<subseteq> G\\<rightarrow>G\" unfolding End_def by blast \n  moreover have A3: \"End(G,P) {is closed under} Composition(G)\" \n    using end_composition unfolding IsOpClosed_def by blast\n  ultimately show \"IsAmonoid(End(G,P),?C\\<^sub>0)\" \n    using monoid0.group0_1_T1 Group_ZF_2_5_L2(1) unfolding monoid0_def\n    by blast\n  have \"IsAmonoid(G\\<rightarrow>G,Composition(G))\" using Group_ZF_2_5_L2(1) by auto\n  with A0 A1 A2 A3 show \"TheNeutralElement(End(G,P),?C\\<^sub>0) = id(G)\"\n    using group0_1_L6 by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 645,
        "informal": " In the group0 theory, end_comp_monoid states that the endomorphism algebra End(G, P) of a monoid G under operation P, together with the composition End(G, P) defined on this algebra, forms a monoid with the identity element id(G)."
    },
    "220": {
        "type": "lemma",
        "text": "text\\<open>For the group inverse the image is the same as inverse image.\\<close>\n",
        "assumes": "",
        "using": [
            "group_inv_bij",
            "vimage_converse"
        ],
        "statement": "lemma (in group0) inv_image_vimage: shows \"GroupInv(G,P)``(V) = GroupInv(G,P)-``(V)\"\n  ",
        "proof": "using group_inv_bij vimage_converse by simp\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 440,
        "informal": " In the group0 theory, the inverse image of a set under the image of a group operation is equal to the difference of the inverse image and the fixed set."
    },
    "221": {
        "type": "theorem",
        "text": "text\\<open>Finally, we are ready to formulate the main result: that the \n  construction of real numbers from the additive group of integers\n  results in a complete ordered field. \n  This theorem completes the construction. It was fun.\\<close>\n",
        "assumes": "",
        "using": [
            "real1.reals_are_ord_field",
            "real1.real_order_complete",
            "IsComplete_def",
            "IsAmodelOfReals_def"
        ],
        "statement": "theorem eudoxus_reals_are_reals: shows \n  \"IsAmodelOfReals(RealNumbers,RealAddition,RealMultiplication,OrderOnReals)\"\n  ",
        "proof": "using real1.reals_are_ord_field real1.real_order_complete \n    IsComplete_def IsAmodelOfReals_def by simp\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1765,
        "informal": " The Real Numbers, equipped with addition, multiplication, and the order relation, form a model of the real numbers in ZF set theory."
    },
    "222": {
        "type": "definition",
        "text": "text\\<open>A finite automaton defines transitions on pairs of\nwords and states. Two pairs are transition related\nif the second word is equal to the first except it is\nmissing the last symbol, and the second state is\ngenerated by this symbol and the first state by way\nof the transition function.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  DFSAExecutionRelation (\"{reduce D-relation}'(_,_,_'){in alphabet}_\") where\n  \"Finite(\\<Sigma>) \\<Longrightarrow> (S,s\\<^sub>0,t,F){is an DFSA for alphabet}\\<Sigma> \\<Longrightarrow> \n  {reduce D-relation}(S,s\\<^sub>0,t){in alphabet}\\<Sigma> \\<equiv> {\\<langle>\\<langle>w,s\\<rangle>,\\<langle>Init(w),t`\\<langle>s,Last(w)\\<rangle>\\<rangle>\\<rangle>. \\<langle>w,s\\<rangle>\\<in>NELists(\\<Sigma>)\\<times>S}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.Finite1",
            "ZF.CardinalArith"
        ],
        "source": "IsarMathLib/Finite_State_Machines_ZF.thy",
        "id": 276,
        "informal": " Given a finite alphabet Σ, if (S, s0, t, F) is a DFA for alphabet Σ, then the relation {reduce D-relation} on S x NELists(Σ) (the set of all lists of symbols in Σ together with the empty list) is equal to the relation Γ defined as follows: Γ is the set of all pairs of the form <⟨w, s⟩, <Init(w), t′, s', Last(w)>>, where w is a list of symbols in Σ, s is a state in S, Init(w) is the initial state of the DFA for the input string w, t′ is the next state function, s' is the state reached from state s with input symbol Last(w), and Last(w) is the last symbol in the list w."
    },
    "223": {
        "type": "lemma",
        "text": "text\\<open>Definition of a normal subgroup in a more readable notation.\\<close>\n",
        "assumes": "assumes \"IsAnormalSubgroup(G,P,H)\"\n  and \"g\\<in>G\" \"n\\<in>H\"\n  ",
        "using": [
            "assms",
            "IsAnormalSubgroup_def"
        ],
        "statement": "lemma (in group0) Group_ZF_2_4_L0: \n  assumes \"IsAnormalSubgroup(G,P,H)\"\n  and \"g\\<in>G\" \"n\\<in>H\"\n  shows \"g\\<cdot>n\\<cdot>g\\<inverse> \\<in> H\"\n  ",
        "proof": "using assms IsAnormalSubgroup_def by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.func_ZF",
            "IsarMathLib.EquivClass1"
        ],
        "source": "IsarMathLib/Group_ZF_2.thy",
        "id": 545,
        "informal": " Given a group G, subgroup P, and H as a normal subgroup of P, if g is an element of G and n is an element of H, then g * n * g^(-1) (multiplication and inverse in group G) is also an element of subgroup H."
    },
    "224": {
        "type": "lemma",
        "text": "text\\<open>The next lemma provides the condition to show that addition is \n  distributive with respect to multiplication.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \n  ",
        "using": [
            "assms",
            "Int_ZF_1_L2",
            "zadd_zmult_distrib",
            "zadd_zmult_distrib2"
        ],
        "statement": "lemma (in int0) Int_ZF_1_1_L1: assumes A1: \"a\\<in>\\<int>\"  \"b\\<in>\\<int>\"  \"c\\<in>\\<int>\" \n  shows \n  \"a\\<cdot>(b\\<ra>c) = a\\<cdot>b \\<ra> a\\<cdot>c\" \n  \"(b\\<ra>c)\\<cdot>a = b\\<cdot>a \\<ra> c\\<cdot>a\"\n  ",
        "proof": "using assms Int_ZF_1_L2 zadd_zmult_distrib zadd_zmult_distrib2\n  by auto\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 716,
        "informal": " Given integers a, b, and c, their dot product satisfies the following properties:\n\na . (b * c) = a . b * a . c\n(b * c). a = b . a * c . a.\n\nIn other words, distributing the dot product over multiplication holds for integers. This is also known as the distributive property."
    },
    "225": {
        "type": "lemma",
        "text": "text\\<open>If a list is an order isomorphism then it must be the enumeration.\n\\<close>\n",
        "assumes": "assumes A1: \"A \\<in> FinPow(X)\" and\n  A2: \"n \\<in> nat\" and A3: \"f \\<in> ord_iso(n,Le,A,r)\"\n  ",
        "using": [
            "ord_iso_def",
            "eqpoll_def",
            "ord_iso_nat_fin",
            "enum_props",
            "card_card"
        ],
        "statement": "lemma (in enums) ord_iso_enum: assumes A1: \"A \\<in> FinPow(X)\" and\n  A2: \"n \\<in> nat\" and A3: \"f \\<in> ord_iso(n,Le,A,r)\"\n  shows \"f = \\<sigma>(A)\"\n",
        "proof": "proof -\n  from A3 have \"n \\<approx> A\" using ord_iso_def eqpoll_def\n    by auto\n  then have \"A \\<approx> n\" by (rule eqpoll_sym)\n  with A1 A2 have \"\\<exists>!f. f \\<in> ord_iso(n,Le,A,r)\"\n    using ord_iso_nat_fin by simp\n  with assms \\<open>A \\<approx> n\\<close> show \"f = \\<sigma>(A)\"\n    using enum_props card_card by blast\nqed\n",
        "imports": [
            "IsarMathLib.NatOrder_ZF",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/Enumeration_ZF.thy",
        "id": 103,
        "informal": " Given an enumeration A of a set X, an order isomorphism f of length n with respect to the natural order Le, and assuming A is a finite power set of X, show that f is equal to the enumeration function \\sigma for A."
    },
    "226": {
        "type": "lemma",
        "text": "text\\<open>Taking negative on both sides reverses the inequality, another case with\n  an inverse on one side.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> G\" and A2: \"a\\<inverse>\\<lsq>b\"\n  ",
        "using": [
            "OrderedGroup_ZF_1_L5",
            "OrderedGroup_ZF_1_L1",
            "group0.group_inv_of_inv"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_1_L5AG:\n  assumes A1: \"a \\<in> G\" and A2: \"a\\<inverse>\\<lsq>b\"\n  shows \"b\\<inverse> \\<lsq> a\"\n",
        "proof": "proof -\n  from A2 have \"b\\<inverse> \\<lsq> (a\\<inverse>)\\<inverse>\"\n    using OrderedGroup_ZF_1_L5 by simp\n  with A1 show \"b\\<inverse> \\<lsq> a\"\n    using OrderedGroup_ZF_1_L1 group0.group_inv_of_inv\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_1",
            "IsarMathLib.AbelianGroup_ZF",
            "IsarMathLib.Finite_ZF_1",
            "IsarMathLib.OrderedLoop_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF.thy",
        "id": 1384,
        "informal": " In the group `G` of ZF set theory, if `a` is an element and `a` is the inverse of `b`, then `b` is the inverse of `a`."
    },
    "227": {
        "type": "lemma",
        "text": "text\\<open>If for every element of $X$ we can find one in $A$ \n  that is greater, then the $A$ can not be bounded above.\n  Works for relations that are total, transitive and antisymmetric,\n  (i.e. for linear order relations).\\<close>\n",
        "assumes": "assumes A1: \"r {is total on} X\" \n  and A2: \"trans(r)\" and A3: \"antisym(r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\" and A5: \"X\\<noteq>0\" \n  and A6: \"\\<forall>x\\<in>X. \\<exists>a\\<in>A. x\\<noteq>a \\<and> \\<langle>x,a\\<rangle> \\<in> r\"\n  ",
        "using": [
            "IsBounded_def",
            "IsBoundedAbove_def"
        ],
        "statement": "lemma Order_ZF_3_L14:  \n  assumes A1: \"r {is total on} X\" \n  and A2: \"trans(r)\" and A3: \"antisym(r)\"\n  and A4: \"r \\<subseteq> X\\<times>X\" and A5: \"X\\<noteq>0\" \n  and A6: \"\\<forall>x\\<in>X. \\<exists>a\\<in>A. x\\<noteq>a \\<and> \\<langle>x,a\\<rangle> \\<in> r\"\n  shows \"\\<not>IsBoundedAbove(A,r)\"\n",
        "proof": "proof -\n  { from A5 A6 have I: \"A\\<noteq>0\" by auto\n    moreover assume \"IsBoundedAbove(A,r)\"\n    ultimately obtain u where II: \"\\<forall>x\\<in>A. \\<langle> x,u\\<rangle> \\<in> r\"\n      using IsBounded_def IsBoundedAbove_def by auto\n    with A4 I have \"u\\<in>X\" by auto\n    with A6 obtain b where \"b\\<in>A\" and III: \"u\\<noteq>b\" and \"\\<langle>u,b\\<rangle> \\<in> r\"\n      by auto\n    with II have \"\\<langle>b,u\\<rangle> \\<in> r\"  \"\\<langle>u,b\\<rangle> \\<in> r\" by auto\n    with A3 have \"b=u\" by (rule Fol1_L4)\n    with III have False by simp\n  } thus \"\\<not>IsBoundedAbove(A,r)\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Order_ZF.thy",
        "id": 1259,
        "informal": " Assuming r is a total relation over a non-empty set X, transitive and antisymmetric, and where every element in X is related to some distinct element not in itself, we cannot have an upper bound for the set A under relation r."
    },
    "228": {
        "type": "lemma",
        "text": "text\\<open>There are no integers between $k$ and $k+1$.\\<close>\n",
        "assumes": "assumes A1: \"k\\<in>\\<int>\" \"m\\<in>\\<int>\" \"n\\<in>nat\" and A2: \"k $+ $#1 = m $+ $#n\"\n  ",
        "using": [
            "zadd_int0",
            "Nat_ZF_1_L3",
            "Int_ZF_2_L13"
        ],
        "statement": "lemma (in int0) Int_ZF_4_L1: \n  assumes A1: \"k\\<in>\\<int>\" \"m\\<in>\\<int>\" \"n\\<in>nat\" and A2: \"k $+ $#1 = m $+ $#n\"\n  shows \"m =  k $+ $#1 \\<or> m \\<lsq> k\"\n",
        "proof": "proof -\n  { assume \"n=0\" \n    with A1 A2 have \"m =  k $+ $#1 \\<or> m \\<lsq> k\" \n      using zadd_int0 by simp }\n  moreover\n  { assume \"n\\<noteq>0\" \n    with A1 obtain j where D1: \"j\\<in>nat\" \"n = succ(j)\"\n      using Nat_ZF_1_L3 by auto\n    with A1 A2 D1 have \"m =  k $+ $#1 \\<or> m \\<lsq> k\" \n      using Int_ZF_2_L13 by simp }\n  ultimately show ?thesis by blast\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 1033,
        "informal": " Given integers k and m, and a natural number n, if k and m differ by exactly n, then m is either equal to k plus one, or less than k."
    },
    "229": {
        "type": "definition",
        "text": "text\\<open>A topology is $T_1$ if for every such pair there exist an open set that \n  contains the first point but not the second.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  isT1 (\"_ {is T\\<^sub>1}\" [90] 91) where\n  \"T {is T\\<^sub>1} \\<equiv> \\<forall> x y. ((x \\<in> \\<Union>T \\<and> y \\<in> \\<Union>T \\<and>  x\\<noteq>y) \\<longrightarrow> \n  (\\<exists>U\\<in>T. (x\\<in>U \\<and> y\\<notin>U)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_1.thy",
        "id": 2027,
        "informal": " A set T is an T1 set if and only if for all x and y in T, if x is different from y then there exists a subset U of T such that x belongs to U and y does not belong to U."
    },
    "230": {
        "type": "definition",
        "text": "text\\<open>First we define a helper notion of the sequence defined inductively up to a \n  given natural number $n$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"InductiveSequenceN(x,f,n) \\<equiv> \n  THE a. a: succ(n) \\<rightarrow> domain(f) \\<and> a`(0) = x \\<and> (\\<forall>k\\<in>n. a`(succ(k)) = f`(a`(k)))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.FiniteSeq_ZF",
            "IsarMathLib.FinOrd_ZF"
        ],
        "source": "IsarMathLib/InductiveSeq_ZF.thy",
        "id": 661,
        "informal": " An inductive sequence of length n+1, starting with x, is a sequence a such that:\n1. The sequence has length n+1.\n2. Each element after the first is in the domain of function f.\n3. The first element is x.\n4. For all k from 0 to n-1, the successive element is the result of applying function f to the preceding element."
    },
    "231": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum and minimum, then the greater of the \n  absolute value of the maximum and minimum belongs to the image of the set \n  by the absolute value function.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> G\"\n  and \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  and \"M = GreaterOf(r,\\<bar>Minimum(r,A)\\<bar>,\\<bar>Maximum(r,A)\\<bar>)\"\n  ",
        "using": [
            "ordGroupAssum",
            "assms",
            "IsAnOrdGroup_def",
            "IsPartOrder_def",
            "Order_ZF_4_L3",
            "Order_ZF_4_L4",
            "OrderedGroup_ZF_3_L1",
            "func_imagedef",
            "GreaterOf_def"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_4_L1:\n  assumes \"A \\<subseteq> G\"\n  and \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  and \"M = GreaterOf(r,\\<bar>Minimum(r,A)\\<bar>,\\<bar>Maximum(r,A)\\<bar>)\"\n  shows \"M \\<in> AbsoluteValue(G,P,r)``(A)\"\n  ",
        "proof": "using ordGroupAssum assms IsAnOrdGroup_def IsPartOrder_def \n    Order_ZF_4_L3 Order_ZF_4_L4 OrderedGroup_ZF_3_L1 \n    func_imagedef GreaterOf_def by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1486,
        "informal": " In the group3 theory, if a non-empty set A is a subset of a group G, and r is a binary relation on A with both a minimum and maximum element, then the greater of the minimum and the maximum of r in A belongs to the absolute value of G with respect to the relation r applied to A."
    },
    "232": {
        "type": "definition",
        "text": "text\\<open>Definition of left uniformity\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition (in topgroup) leftUniformity\n where \"leftUniformity \\<equiv> {V\\<in>Pow(G\\<times>G).\\<exists>U\\<in> \\<N>\\<^sub>0. {\\<langle>s,t\\<rangle>\\<in>G\\<times>G. (\\<rm>s)\\<ra>t \\<in>U} \\<subseteq> V}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.TopologicalGroup_ZF",
            "IsarMathLib.UniformSpace_ZF_1"
        ],
        "source": "IsarMathLib/TopologicalGroup_Uniformity_ZF.thy",
        "id": 1909,
        "informal": " A left uniformity on a group G is a subset of its power set (U), such that for every s and t in G, the left translation of s by t (s \\* t) belongs to U. That is, for all s,t in G, there exists a natural number N with the property that the set V containing all such pairs (s,t) satisfies the condition that the subset U is included in V."
    },
    "233": {
        "type": "lemma",
        "text": "text\\<open>$0\\cdot x = 0$ and $x^0=1$. It is a bit surprising that we do not need to assume\n  that $x\\in R$ (i.e. $x$ is an element of the ring). These properties are really proven in the \\<open>Monoid_ZF_1\\<close> \n  theory where there is no assumption that $x$ is an element of the monoid. \\<close>\n",
        "assumes": "",
        "using": [
            "add_monoid.nat_mult_zero",
            "mul_monoid.nat_mult_zero"
        ],
        "statement": "lemma (in ring3) mult_pow_zero: shows \"0\\<nm>x = \\<zero>\" and \"pow(0,x) = \\<one>\"\n  ",
        "proof": "using add_monoid.nat_mult_zero mul_monoid.nat_mult_zero by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1777,
        "informal": " In the ring3 context, the following statements hold: \n\n1. The product of zero and any element x is the zero element.\n2. The power of zero, raised to the exponent x, equals the identity element (one)."
    },
    "234": {
        "type": "lemma",
        "text": "text\\<open>Closure of a set is closed, hence the complement of the closure is open.\\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<Union>T\"\n  ",
        "using": [
            "assms",
            "Top_3_L3",
            "Top_3_L4",
            "Closure_def",
            "ClosedCovers_def",
            "IsClosed_def"
        ],
        "statement": "lemma (in topology0) cl_is_closed: assumes \"A \\<subseteq> \\<Union>T\"\n  shows \"cl(A) {is closed in} T\" and \"\\<Union>T - cl(A) \\<in> T\"\n  ",
        "proof": "using assms Top_3_L3 Top_3_L4 Closure_def ClosedCovers_def IsClosed_def\n  by auto\n",
        "imports": [
            "IsarMathLib.ZF1",
            "IsarMathLib.Finite_ZF",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF.thy",
        "id": 2014,
        "informal": " If A is a subset of the union of a collection T in the given topology, then the closure of A is a closed set in T, and the complement of the closure of A in T belongs to T."
    },
    "235": {
        "type": "definition",
        "text": "text\\<open>For two collections $S,T$ of sets we define the product collection\n  as the collections of cartesian products $A\\times B$, where $A\\in S, B\\in T$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"ProductCollection(T,S) \\<equiv> \\<Union>U\\<in>T.{U\\<times>V. V\\<in>S}\"\n",
        "proof": "",
        "imports": [
            "ZF.Perm"
        ],
        "source": "IsarMathLib/ZF1.thy",
        "id": 2512,
        "informal": " The predicate \"ProductCollection(T,S)\" holds if and only if the union of T contains all the pairs whose first elements are in T and whose second elements are in S. In other words, ProductCollection(T,S) is the collection of all products of elements from T and S."
    },
    "236": {
        "type": "lemma",
        "text": "text\\<open>Some properties of the inverse of a positive element.\\<close>\n",
        "assumes": "assumes A1: \"a \\<in> R\\<^sub>+\"\n  ",
        "using": [
            "PositiveSet_def",
            "OrdField_ZF_1_L1B",
            "field0.Field_ZF_1_L5",
            "OrdField_ZF_1_L6",
            "OrdField_ZF_1_L5",
            "IsOpClosed_def",
            "field0.Field_ZF_2_L1",
            "OrdField_ZF_1_L7"
        ],
        "statement": "lemma (in field1) OrdField_ZF_1_L8: assumes A1: \"a \\<in> R\\<^sub>+\"\n  shows \"a\\<inverse> \\<in> R\\<^sub>+\"  \"a\\<cdot>(a\\<inverse>) = \\<one>\"  \"(a\\<inverse>)\\<cdot>a = \\<one>\"\n",
        "proof": "proof -\n  from A1 have I: \"a\\<in>R\"  \"a\\<noteq>\\<zero>\" using PositiveSet_def \n    by auto\n  with A1 have \"a\\<cdot>(a\\<inverse>)\\<^sup>2 \\<in> R\\<^sub>+\" \n    using OrdField_ZF_1_L1B field0.Field_ZF_1_L5 OrdField_ZF_1_L6\n      OrdField_ZF_1_L5 IsOpClosed_def by simp\n  with I show \"a\\<inverse> \\<in> R\\<^sub>+\"\n    using OrdField_ZF_1_L1B field0.Field_ZF_2_L1\n    by simp\n  from I show  \"a\\<cdot>(a\\<inverse>) = \\<one>\"  \"(a\\<inverse>)\\<cdot>a = \\<one>\"\n    using OrdField_ZF_1_L7 by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedRing_ZF",
            "IsarMathLib.Field_ZF"
        ],
        "source": "IsarMathLib/OrderedField_ZF.thy",
        "id": 1336,
        "informal": " In the field `field1`, if `a` is an element of `R+`, then `a^{-1}`, the multiplicative inverse of `a`, is also an element of `R`, and `a * a^{-1}` and `a^{-1} * a` are both equal to the multiplicative identity `1`."
    },
    "237": {
        "type": "corollary",
        "text": "text\\<open>The kernel of an homomorphism is a normal subgroup.\\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  ",
        "using": [
            "assms",
            "preimage_normal_subgroup",
            "group0.trivial_normal_subgroup",
            "group0_def"
        ],
        "statement": "corollary kernel_normal_sub:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\"\n  shows \"IsAnormalSubgroup(G,P,f-``{TheNeutralElement(H,F)})\"\n  ",
        "proof": "using assms preimage_normal_subgroup group0.trivial_normal_subgroup \n  unfolding group0_def by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 655,
        "informal": " If group G with respect to operation P, group H with respect to operation F, and homomorphism f from G to H are given, then the kernel of f, which is the set of elements in G mapped to the neutral element in H, is a normal subgroup of G with respect to operation P."
    },
    "238": {
        "type": "lemma",
        "text": "text\\<open>A lemma with two field elements and cancelling.\\<close>\n",
        "assumes": "assumes \"a\\<in>K\" \"b\\<in>K\" \"b\\<noteq>\\<zero>\"\n  ",
        "using": [
            "assms",
            "Field_ZF_1_L5",
            "Ring_ZF_1_L11",
            "Field_ZF_1_L6",
            "Ring_ZF_1_L3"
        ],
        "statement": "lemma (in field0) Field_ZF_1_L7: assumes \"a\\<in>K\" \"b\\<in>K\" \"b\\<noteq>\\<zero>\"\n  shows \n  \"a\\<cdot>b\\<cdot>b\\<inverse> = a\"\n  \"a\\<cdot>b\\<inverse>\\<cdot>b = a\"\n  ",
        "proof": "using assms Field_ZF_1_L5 Ring_ZF_1_L11 Field_ZF_1_L6 Ring_ZF_1_L3\n  by auto\n",
        "imports": [
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Field_ZF.thy",
        "id": 152,
        "informal": " If `a` and `b` are elements of a field `K`, and `b` is non-zero, then:\n\n1. `a * b * b^-1 = a`\n2. `a * b^-1 * b = a`\n\nwhere `*` represents multiplication and `^-1` represents inverse."
    },
    "239": {
        "type": "lemma",
        "text": "text\\<open>A lemma demonstrating what is the right translation of a set\\<close>\n",
        "assumes": "assumes A1: \"V\\<subseteq>G\" and A2: \"x\\<in>G\"\n  ",
        "using": [
            "group0_5_L1",
            "func_imagedef",
            "group0_5_L2"
        ],
        "statement": "lemma (in group0) rtrans_image: assumes A1: \"V\\<subseteq>G\" and A2: \"x\\<in>G\"\n  shows \"RightTranslation(G,P,x)``(V) = {v\\<cdot>x. v\\<in>V}\"\n",
        "proof": "proof -\n  from assms have \"RightTranslation(G,P,x)``(V) = {RightTranslation(G,P,x)`(v). v\\<in>V}\"\n    using group0_5_L1 func_imagedef by blast\n  moreover from assms have \"\\<forall>v\\<in>V. RightTranslation(G,P,x)`(v) = v\\<cdot>x\"\n    using group0_5_L2 by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 498,
        "informal": " In the group0 theory, given a subset V of a group G and an element x in G, the image of V under the right translation by x is equal to the set of elements obtained by multiplying each element in V by x."
    },
    "240": {
        "type": "lemma",
        "text": "text\\<open>If a set has a maximum and minimum, then the greater of the \n  absolute value of the maximum and minimum bounds absolute values of all \n  elements of the set. In this lemma the absolute values of ekements of a \n  set are represented as the elements of the image of the set by the absolute\n  value function.\\<close>\n",
        "assumes": "assumes \"r {is total on} G\" and \"A \\<subseteq> G\"\n  and \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  and \"b \\<in> AbsoluteValue(G,P,r)``(A)\"\n  ",
        "using": [
            "assms",
            "OrderedGroup_ZF_3_L1",
            "func_imagedef",
            "OrderedGroup_ZF_4_L2"
        ],
        "statement": "lemma (in group3) OrderedGroup_ZF_4_L3: \n  assumes \"r {is total on} G\" and \"A \\<subseteq> G\"\n  and \"HasAmaximum(r,A)\" \"HasAminimum(r,A)\"\n  and \"b \\<in> AbsoluteValue(G,P,r)``(A)\"\n  shows \"b\\<lsq> GreaterOf(r,\\<bar>Minimum(r,A)\\<bar>,\\<bar>Maximum(r,A)\\<bar>)\"\n  ",
        "proof": "using assms OrderedGroup_ZF_3_L1 func_imagedef OrderedGroup_ZF_4_L2\n  by auto\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF"
        ],
        "source": "IsarMathLib/OrderedGroup_ZF_1.thy",
        "id": 1488,
        "informal": " In the group G under relation r, if A is a non-empty subset with minimum and maximum elements, and b is an element in the absolute value of A under r, then b is greater than the minimum of A under r and less than or equal to the maximum of A under r."
    },
    "241": {
        "type": "lemma",
        "text": "text\\<open>Floor of (real) two is (integer) two.\\<close>\n",
        "assumes": "",
        "using": [
            "int0.int_two_three_are_int",
            "Real_ZF_1_4_L14",
            "int_two_is_real_two"
        ],
        "statement": "lemma (in real1) floor_2_is_two: shows \"\\<lfloor>\\<two>\\<rfloor> = \\<two>\\<^sub>Z\"\n",
        "proof": "proof -\n  have \"\\<lfloor>(\\<two>\\<^sub>Z)\\<^sup>R\\<rfloor> = \\<two>\\<^sub>Z\" \n    using int0.int_two_three_are_int Real_ZF_1_4_L14 \n    by simp\n  then show \"\\<lfloor>\\<two>\\<rfloor> = \\<two>\\<^sub>Z\" using int_two_is_real_two\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.Real_ZF",
            "IsarMathLib.Int_ZF_3",
            "IsarMathLib.OrderedField_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_1.thy",
        "id": 1743,
        "informal": " The lemma \"floor_2_is_two\" in the theory \"real1\" of Isabelle/ZF asserts that the floor of the number 2 is equal to the number 2 raised to the power of zero."
    },
    "242": {
        "type": "lemma",
        "text": "text\\<open>Range is the image of the domain. Isabelle/ZF defines\n  \\<open>range(f)\\<close> as \\<open>domain(converse(f))\\<close>,\n  and that's why we have something to prove here.\\<close>\n",
        "assumes": "assumes A1: \"f:X\\<rightarrow>Y\" ",
        "using": [
            "image_def",
            "func1_1_L5",
            "func_imagedef",
            "apply_equality"
        ],
        "statement": "lemma range_image_domain: \n  assumes A1: \"f:X\\<rightarrow>Y\" shows \"f``(X) = range(f)\"\n",
        "proof": "proof\n  show \"f``(X) \\<subseteq> range(f)\" using image_def by auto\n  { fix y assume \"y \\<in> range(f)\"\n    then obtain x where \"\\<langle>y,x\\<rangle> \\<in> converse(f)\" by auto\n    with A1 have \"x\\<in>X\" using func1_1_L5 by blast\n    with A1 have \"f`(x) \\<in> f``(X)\" using func_imagedef\n      by auto\n    with A1  \\<open>\\<langle>y,x\\<rangle> \\<in> converse(f)\\<close> have \"y \\<in> f``(X)\"\n      using apply_equality by auto\n  } then show \"range(f) \\<subseteq> f``(X)\" by auto\nqed\n",
        "imports": [
            "ZF.func",
            "IsarMathLib.Fol1",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/func1.thy",
        "id": 2607,
        "informal": " If `f` is a function from `X` to `Y`, then the image of `f` is equal to the range of `f`."
    },
    "243": {
        "type": "lemma",
        "text": "text\\<open>Another rearrangement with three integers.\\<close>\n",
        "assumes": "assumes A1: \"a\\<in>\\<int>\" \"b\\<in>\\<int>\" \"c\\<in>\\<int>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "Int_ZF_1_1_L5",
            "Int_ZF_1_1_L1",
            "Int_ZF_1_2_L8"
        ],
        "statement": "lemma (in int0) Int_ZF_1_2_L10: \n  assumes A1: \"a\\<in>\\<int>\" \"b\\<in>\\<int>\" \"c\\<in>\\<int>\"\n  shows \"(a\\<ra>\\<one>)\\<cdot>b \\<ra> (c\\<ra>\\<one>)\\<cdot>b = (c\\<ra>a\\<ra>\\<two>)\\<cdot>b\"\n",
        "proof": "proof -\n  from A1 have \"a\\<ra>\\<one> \\<in> \\<int>\" \"c\\<ra>\\<one> \\<in> \\<int>\" \n    using int_zero_one_are_int Int_ZF_1_1_L5 by auto \n  with A1 have \n    \"(a\\<ra>\\<one>)\\<cdot>b \\<ra> (c\\<ra>\\<one>)\\<cdot>b = (a\\<ra>\\<one>\\<ra>(c\\<ra>\\<one>))\\<cdot>b\"\n    using Int_ZF_1_1_L1 by simp\n  also from A1 have \"\\<dots> = (c\\<ra>a\\<ra>\\<two>)\\<cdot>b\"\n    using Int_ZF_1_2_L8 by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 739,
        "informal": " Given integers a, b, and c, the product of the successor of a multiplied by b, and the product of the successor of c multiplied by b, are equal to the product of the successor of the integer obtained by adding a and c, multiplied by b."
    },
    "244": {
        "type": "lemma",
        "text": "text\\<open>First, we prove that the projection functions are open.\\<close>\n",
        "assumes": "assumes \"T{is a topology}\"\"S{is a topology}\"\"B\\<in>ProductTopology(T,S)\"\n  ",
        "using": [
            "prod_sec_open2",
            "assms",
            "topology0.open_neigh_open",
            "topology0_def",
            "assms(1)"
        ],
        "statement": "lemma projection_open:\n  assumes \"T{is a topology}\"\"S{is a topology}\"\"B\\<in>ProductTopology(T,S)\"\n  shows \"{y\\<in>\\<Union>T. \\<exists>x\\<in>\\<Union>S. \\<langle>y,x\\<rangle>\\<in>B}\\<in>T\"\n",
        "proof": "proof-\n  {\n    fix z assume \"z\\<in>{y\\<in>\\<Union>T. \\<exists>x\\<in>\\<Union>S. \\<langle>y,x\\<rangle>\\<in>B}\"\n    then obtain x where x:\"x\\<in>\\<Union>S\" and z:\"z\\<in>\\<Union>T\" and p:\"\\<langle>z,x\\<rangle>\\<in>B\" by auto\n    then have \"z\\<in>{y\\<in>\\<Union>T. \\<langle>y,x\\<rangle>\\<in>B}\" \"{y\\<in>\\<Union>T. \\<langle>y,x\\<rangle>\\<in>B}\\<subseteq>{y\\<in>\\<Union>T. \\<exists>x\\<in>\\<Union>S. \\<langle>y,x\\<rangle>\\<in>B}\" by auto moreover\n    from x have \"{y\\<in>\\<Union>T. \\<langle>y,x\\<rangle>\\<in>B}\\<in>T\" using prod_sec_open2 assms by auto\n    ultimately have \"\\<exists>V\\<in>T. z\\<in>V \\<and> V\\<subseteq>{y\\<in>\\<Union>T. \\<exists>x\\<in>\\<Union>S. \\<langle>y,x\\<rangle>\\<in>B}\" unfolding Bex_def by auto\n  }   \n  then show \"{y\\<in>\\<Union>T. \\<exists>x\\<in>\\<Union>S. \\<langle>y,x\\<rangle>\\<in>B}\\<in>T\" using topology0.open_neigh_open unfolding topology0_def\n    using assms(1) by blast\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_7"
        ],
        "source": "IsarMathLib/Topology_ZF_10.thy",
        "id": 2069,
        "informal": " If T and S are topologies, and B is the product topology on T and S, then the set of all y in the union of T such that there exists an x in the union of S with the tuple <y,x> in B is a subset of T."
    },
    "245": {
        "type": "lemma",
        "text": "text\\<open>\\<open>move\\<close> is an injection from \\<open>big\\<close> to \\<open>newbig\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "move_bij",
            "bij_is_inj"
        ],
        "statement": "lemma (in generalization1) move_inj: shows \"move\\<in>inj(big, newbig)\" \n  ",
        "proof": "using move_bij bij_is_inj by simp\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/Generalization_ZF.thy",
        "id": 390,
        "informal": " In the context of the lemma \"generalization1\", \"move\\_inj(big, newbig)\" holds, where \"move\\_inj\" is the injectivity of the \"move\\_in\" function for the arguments \"big\" and \"newbig\"."
    },
    "246": {
        "type": "definition",
        "text": "text\\<open>We define concatenation of two sequences as the union of the first sequence \n  with the shifted second sequence. The result of concatenating lists \n  $a$ and $b$ is called \\<open>Concat(a,b)\\<close>.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Concat(a,b) \\<equiv> a \\<union> ShiftedSeq(b,domain(a))\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Nat_ZF_IML",
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/FiniteSeq_ZF.thy",
        "id": 222,
        "informal": " The \"Concat(a, b)\" relation is defined to be equivalent to the union of sequence \"a\" and the shifted sequence of \"b\" with the domain of \"a\". \n\nIn other words, \"Concat(a, b)\" holds when the elements in the sequence \"a\" followed by the shifted sequence of \"b\" form a single sequence with no repetitions. \n\nThis definition can also be read as, \"The concatenation of sequences 'a' and 'b' is the sequence that results from appending 'b' to 'a' after shifting the elements of 'b' to align their indices with those of 'a'.\""
    },
    "247": {
        "type": "lemma",
        "text": "text\\<open>The lift to subsets defines a binary operation on the subsets.\\<close>\n",
        "assumes": "assumes A1: \"f : X \\<times> X \\<rightarrow> Y\"\n  ",
        "using": [
            "func1_1_L6"
        ],
        "statement": "lemma lift_subsets_binop: assumes A1: \"f : X \\<times> X \\<rightarrow> Y\"\n  shows \"(f {lifted to subsets of} X) : Pow(X) \\<times> Pow(X) \\<rightarrow> Pow(Y)\"\n",
        "proof": "proof -\n  let ?F = \"{\\<langle>p, f``(fst(p)\\<times>snd(p))\\<rangle>. p \\<in> Pow(X)\\<times>Pow(X)}\"\n  from A1 have \"\\<forall>p \\<in> Pow(X) \\<times> Pow(X). f``(fst(p)\\<times>snd(p)) \\<in> Pow(Y)\"\n    using func1_1_L6 by simp\n  then have \"?F : Pow(X) \\<times> Pow(X) \\<rightarrow> Pow(Y)\"\n    by (rule ZF_fun_from_total)\n  then show ?thesis unfolding Lift2Subsets_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.func1"
        ],
        "source": "IsarMathLib/func_ZF.thy",
        "id": 2701,
        "informal": " Given a function `f` from the Cartesian product of `X` with itself to `Y`, there is a functions `(f {lifted to subsets of} X)` from the power set of `X` with respect to Cartesian product to the power set of `Y`."
    },
    "248": {
        "type": "lemma",
        "text": "text\\<open>The sum of expressions whose values belong to a ring is an expression\n  whose value belongs to a ring. \\<close>\n",
        "assumes": "assumes \"n\\<in>nat\" \"\\<forall>k\\<in>n. q(k) \\<in> R\" \"\\<forall>k\\<in>n. p(k) \\<in> R\"\n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L4(1)",
            "add_monoid.sum_in_mono"
        ],
        "statement": "lemma (in ring3) sum_expr_ring_type: \n  assumes \"n\\<in>nat\" \"\\<forall>k\\<in>n. q(k) \\<in> R\" \"\\<forall>k\\<in>n. p(k) \\<in> R\"\n  shows \"\\<forall>k\\<in>n. q(k)\\<ra>p(k) \\<in> R\" and \"(\\<Sum>{\\<langle>k,q(k)\\<ra>p(k)\\<rangle>. k\\<in>n}) \\<in> R\"\n  ",
        "proof": "using assms Ring_ZF_1_L4(1) add_monoid.sum_in_mono by simp_all\n",
        "imports": [
            "IsarMathLib.Monoid_ZF_1",
            "IsarMathLib.Ring_ZF"
        ],
        "source": "IsarMathLib/Ring_Binomial_ZF.thy",
        "id": 1784,
        "informal": " If n is a natural number and q(k) and p(k) are in the ring R for all k in n, then the sum of q(k) times p(k) for all k in n is also in the ring R."
    },
    "249": {
        "type": "definition",
        "text": "text\\<open>First we define the notion of function that maps equivalent \n  elements to equivalent values. We use similar names as\n  in the Isabelle's standard \\<open>EquivClass\\<close> theory to indicate \n  the conceptual correspondence of the notions.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"Congruent(r,f) \\<equiv>\n  (\\<forall>x y. \\<langle>x,y\\<rangle> \\<in> r  \\<longrightarrow> \\<langle>f`(x),f`(y)\\<rangle> \\<in> r)\"\n",
        "proof": "",
        "imports": [
            "ZF.EquivClass",
            "IsarMathLib.func_ZF",
            "IsarMathLib.ZF1"
        ],
        "source": "IsarMathLib/EquivClass1.thy",
        "id": 107,
        "informal": " Two relations r and f are congruent if for all x and y, if <xy> is in r then <f(x)f(y)> is in r."
    },
    "250": {
        "type": "theorem",
        "text": "text\\<open>An ordered loop valued metric space is $T_2$ (i.e. Hausdorff).\\<close>\n",
        "assumes": "assumes \"r {down-directs} L\\<^sub>+\"\n    defines \"B \\<equiv> \\<Union>c\\<in>X. {disk(c,R). R\\<in>L\\<^sub>+}\" \n    defines \"T \\<equiv> {\\<Union>A. A \\<in> Pow(B)}\"\n    ",
        "using": [
            "pmetric_is_top(2)",
            "base_sets_open",
            "pmetric_is_top(3)",
            "dist_pos",
            "center_in_disk",
            "disk_definition",
            "ls_other_side(1)",
            "pmetric_properties(3)",
            "pmetric_loop_valued",
            "dist_pos(1)",
            "subtract_pos(2)",
            "ls_other_side",
            "posset_definition1"
        ],
        "statement": "theorem (in metric_space) metric_space_T2:\n    assumes \"r {down-directs} L\\<^sub>+\"\n    defines \"B \\<equiv> \\<Union>c\\<in>X. {disk(c,R). R\\<in>L\\<^sub>+}\" \n    defines \"T \\<equiv> {\\<Union>A. A \\<in> Pow(B)}\"\n    shows \"T {is T\\<^sub>2}\"\n",
        "proof": "proof -\n  { fix x y assume \"x\\<in>\\<Union>T\" \"y\\<in>\\<Union>T\" \"x\\<noteq>y\"\n    from assms have \"B\\<subseteq>T\" using pmetric_is_top(2) base_sets_open by auto\n    moreover have \"\\<exists>U\\<in>B. \\<exists>V\\<in>B. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V = 0\"\n    proof -\n      let ?R = \"d`\\<langle>x,y\\<rangle>\"\n      from assms have \"\\<Union>T = X\" using pmetric_is_top(3) by simp\n      with \\<open>x\\<in>\\<Union>T\\<close> \\<open>y\\<in>\\<Union>T\\<close> have \"x\\<in>X\" \"y\\<in>X\" by auto\n      with \\<open>x\\<noteq>y\\<close> have \"?R\\<in>L\\<^sub>+\" using dist_pos by simp\n      with assms(2) \\<open>x\\<in>X\\<close> \\<open>y\\<in>X\\<close> have \"disk(x,?R) \\<in> B\" and \"disk(y,?R) \\<in> B\"\n        by auto\n      { assume \"disk(x,?R) \\<inter> disk(y,?R) = 0\"\n        moreover from assms(2) \\<open>x\\<in>X\\<close> \\<open>y\\<in>X\\<close> \\<open>?R\\<in>L\\<^sub>+\\<close> have \n            \"disk(x,?R)\\<in>B\" \"disk(y,?R)\\<in>B\" \"x\\<in>disk(x,?R)\" \"y\\<in>disk(y,?R)\"\n          using center_in_disk by auto\n        ultimately have \"\\<exists>U\\<in>B. \\<exists>V\\<in>B. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V = 0\" by auto\n      }\n      moreover\n      { assume \"disk(x,?R) \\<inter> disk(y,?R) \\<noteq> 0\"\n        then obtain z where \"z \\<in> disk(x,?R)\" and \"z \\<in> disk(y,?R)\" \n          by auto\n        then have \"d`\\<langle>x,z\\<rangle> \\<ls> ?R\" using disk_definition by simp\n        then have \"\\<zero> \\<ls> \\<rm>d`\\<langle>x,z\\<rangle>\\<ad>?R\" using ls_other_side(1) by simp\n        let ?r = \"\\<rm>d`\\<langle>x,z\\<rangle>\\<ad>?R\"\n        have \"?r\\<ls>?R\"\n        proof -\n          from \\<open>z \\<in> disk(y,?R)\\<close> \\<open>x\\<in>X\\<close> \\<open>y\\<in>X\\<close> have \"z\\<in>X\" \"x\\<noteq>z\"\n            using disk_definition pmetric_properties(3) by auto\n          with \\<open>x\\<in>X\\<close> \\<open>y\\<in>X\\<close> \\<open>z\\<in>X\\<close> show ?thesis\n            using pmetric_loop_valued dist_pos(1) subtract_pos(2) by simp \n        qed\n        with \\<open>x\\<in>X\\<close> \\<open>y\\<in>X\\<close> have \"disk(x,?r)\\<inter>disk(y,\\<rm>?r\\<ad>?R) = 0\"\n          by (rule disjoint_disks)\n        moreover \n        from \\<open>\\<zero>\\<ls>?r\\<close> \\<open>?r\\<ls>?R\\<close> have \"?r\\<in>L\\<^sub>+\" \"(\\<rm>?r\\<ad>?R) \\<in> L\\<^sub>+\"\n          using ls_other_side posset_definition1 by auto\n        with assms(2) \\<open>x\\<in>X\\<close> \\<open>y\\<in>X\\<close> have \n            \"disk(x,?r)\\<in>B\" \"disk(y,\\<rm>?r\\<ad>(d`\\<langle>x,y\\<rangle>))\\<in>B\" and\n            \"x\\<in>disk(x,?r)\" \"y\\<in>disk(y,\\<rm>?r\\<ad>(d`\\<langle>x,y\\<rangle>))\"\n          using center_in_disk by auto\n        ultimately have \"\\<exists>U\\<in>B. \\<exists>V\\<in>B. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V = 0\" by auto\n      }\n      ultimately show ?thesis by auto\n    qed\n    ultimately have \"\\<exists>U\\<in>T. \\<exists>V\\<in>T. x\\<in>U \\<and> y\\<in>V \\<and> U\\<inter>V = 0\" by auto\n  } then show ?thesis unfolding isT2_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.OrderedLoop_ZF",
            "IsarMathLib.Lattice_ZF"
        ],
        "source": "IsarMathLib/MetricSpace_ZF.thy",
        "id": 1119,
        "informal": " In a metric space, if a collection of open balls with centers in the space and radii in a given length scale sequence has the property that any two points in the union of these balls can be connected by a sequence of points and balls in the collection, then the collection forms a T2 (or Hausdorff) space."
    },
    "251": {
        "type": "lemma",
        "text": "text\\<open>IntegerAddition and IntegerMultiplication are functions on \n  \\<open>int \\<times> int\\<close>.\\<close>\n",
        "assumes": "",
        "using": [
            "func1_1_L11A",
            "IntegerAddition_def",
            "IntegerMultiplication_def"
        ],
        "statement": "lemma Int_ZF_1_L1: shows\n  \"IntegerAddition : int\\<times>int \\<rightarrow> int\"\n  \"IntegerMultiplication : int\\<times>int \\<rightarrow> int\"\n",
        "proof": "proof -\n  have\n    \"{\\<langle> x,c\\<rangle> \\<in> (int\\<times>int)\\<times>int. fst(x) $+ snd(x) = c} \\<in> int\\<times>int\\<rightarrow>int\" \n    \"{\\<langle> x,c\\<rangle> \\<in> (int\\<times>int)\\<times>int. fst(x) $* snd(x) = c} \\<in> int\\<times>int\\<rightarrow>int\"\n    using func1_1_L11A by auto\n  then show \"IntegerAddition : int\\<times>int \\<rightarrow> int\" \n    \"IntegerMultiplication : int\\<times>int \\<rightarrow> int\"\n    using IntegerAddition_def IntegerMultiplication_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedGroup_ZF_1",
            "IsarMathLib.Finite_ZF_1",
            "ZF.Int",
            "IsarMathLib.Nat_ZF_IML"
        ],
        "source": "IsarMathLib/Int_ZF_IML.thy",
        "id": 945,
        "informal": " In Isabelle/ZF, we have the following lemmas:\n\n1. IntegerAddition: A function that takes two integers as input and returns an integer as output.\n2. IntegerMultiplication: A function that takes two integers as input and returns an integer as output."
    },
    "252": {
        "type": "definition",
        "text": "text\\<open>For an element $a\\in G$ the right translation is defined \n  a function (set of pairs) such that its value (the second element\n  of a pair) is the value of the group operation on the first element\n  of the pair and $g$. This looks a bit strange in the raw set notation, \n  when we write a function explicitely as a set of pairs and value of \n  the group operation on the pair $\\langle a,b \\rangle$ \n  as \\<open>P`\\<langle>a,b\\<rangle>\\<close> instead of the usual infix $a\\cdot b$\n  or $a + b$.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition\n  \"RightTranslation(G,P,g) \\<equiv> {\\<langle> a,b\\<rangle> \\<in> G\\<times>G. P`\\<langle>a,g\\<rangle> = b}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 481,
        "informal": " A binary relation G between elements a and b satisfies the right translation property P \\* g, if and only if the application of relation P to the pair (a, g) results in b."
    },
    "253": {
        "type": "lemma",
        "text": "text\\<open>The dual theorem to \\<open>Order_ZF_5_L5\\<close>: if $z$ is an lower bound for $A$ and is \n  greater or equal than any other lower bound, then $z$ is the infimum of $A$.\\<close>\n",
        "assumes": "assumes \"antisym(r)\" \"A\\<noteq>0\" \"\\<forall>x\\<in>A. \\<langle>z,x\\<rangle> \\<in> r\" \"\\<forall>y. (\\<forall>x\\<in>A. \\<langle>y,x\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>y,z\\<rangle> \\<in> r\"\n  ",
        "using": [
            "Order_ZF_4_L14",
            "Infimum_def"
        ],
        "statement": "lemma inf_glb: \n  assumes \"antisym(r)\" \"A\\<noteq>0\" \"\\<forall>x\\<in>A. \\<langle>z,x\\<rangle> \\<in> r\" \"\\<forall>y. (\\<forall>x\\<in>A. \\<langle>y,x\\<rangle> \\<in> r) \\<longrightarrow> \\<langle>y,z\\<rangle> \\<in> r\"\n  shows \n  \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\"\n  \"z = Infimum(r,A)\"\n",
        "proof": "proof -\n  let ?B = \"\\<Inter>a\\<in>A. r-``{a}\"\n  from assms(2,3,4) have I: \"z \\<in> ?B\"   \"\\<forall>y\\<in>?B. \\<langle>y,z\\<rangle> \\<in> r\"\n    by auto\n  then show \"HasAmaximum(r,\\<Inter>a\\<in>A. r-``{a})\"\n    unfolding HasAmaximum_def by auto\n  from assms(1) I show \"z = Infimum(r,A)\"\n    using Order_ZF_4_L14 Infimum_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Order_ZF_1a.thy",
        "id": 1300,
        "informal": " Assuming a relation `r` is antisymmetric, `A` is nonempty, and for every `x` in `A`, `(z,x)` and `(y,x)` are in `r` implies `(y,z)` is in `r`, the infimum of `r` with respect to `A` equals `z`. In other words, the set `A` has a maximum element with respect to `r` and that maximum element is `z`."
    },
    "254": {
        "type": "theorem",
        "text": "text\\<open>Next, let's compute the anti-$T_i$ for $i=1,\\ 2,\\ 3$ or $4$. Surprisingly, \nthey are all the same. Meaning, that the total negation of $T_1$ is enough\nto negate all of these axioms.\\<close>\n",
        "assumes": "",
        "using": [
            "\\<open>A\\<in>T\\<close>\\<open>B\\<in>T\\<close>\\<open>x\\<in>A\\<close>\\<open>y\\<in>B\\<close>",
            "\\<open>x\\<noteq>y\\<close>",
            "antiProperty_def",
            "T1_spectrum",
            "lepoll_1_is_sing[of",
            "\"{x,y}\"\"x\"]",
            "\\<open>x\\<in>A\\<close>\\<open>y\\<notin>A\\<close>",
            "IsTotal_def",
            "IsLinOrder_def",
            "empty_lepollI",
            "eq_lepoll_trans",
            "singleton_eqpoll_1",
            "eqpoll_imp_lepoll"
        ],
        "statement": "theorem anti_T1:\n  shows \"(T{is anti-}isT1) \\<longleftrightarrow> (IsLinOrder(T,{\\<langle>U,V\\<rangle>\\<in>Pow(\\<Union>T)\\<times>Pow(\\<Union>T). U\\<subseteq>V}))\"\n",
        "proof": "proof\n  assume \"T{is anti-}isT1\"\n  let ?r=\"{\\<langle>U,V\\<rangle>\\<in>Pow(\\<Union>T)\\<times>Pow(\\<Union>T). U\\<subseteq>V}\"\n  have \"antisym(?r)\" unfolding antisym_def by auto\n  moreover\n  have \"trans(?r)\" unfolding trans_def by auto\n  moreover\n  {\n    fix A B\n    assume \"A\\<in>T\"\"B\\<in>T\"\n    {\n      assume \"\\<not>(A\\<subseteq>B\\<or>B\\<subseteq>A)\"\n      then have \"A-B\\<noteq>0\"\"B-A\\<noteq>0\" by auto\n      then obtain x y where \"x\\<in>A\"\"x\\<notin>B\"\"y\\<in>B\"\"y\\<notin>A\" \"x\\<noteq>y\" by blast\n      then have \"{x,y}\\<inter>A={x}\"\"{x,y}\\<inter>B={y}\" by auto\n      moreover\n      from \\<open>A\\<in>T\\<close>\\<open>B\\<in>T\\<close> have \"{x,y}\\<inter>A\\<in>T{restricted to}{x,y}\"\"{x,y}\\<inter>B\\<in>T{restricted to}{x,y}\" unfolding\n        RestrictedTo_def by auto\n      ultimately have open_set:\"{x}\\<in>T{restricted to}{x,y}\"\"{y}\\<in>T{restricted to}{x,y}\" by auto\n      have \"x\\<in>\\<Union>T\"\"y\\<in>\\<Union>T\" using \\<open>A\\<in>T\\<close>\\<open>B\\<in>T\\<close>\\<open>x\\<in>A\\<close>\\<open>y\\<in>B\\<close> by auto\n      then have sub:\"{x,y}\\<in>Pow(\\<Union>T)\" by auto\n      then have tot:\"\\<Union>(T{restricted to}{x,y})={x,y}\" unfolding RestrictedTo_def by auto\n      {\n        fix s t\n        assume \"s\\<in>\\<Union>(T{restricted to}{x,y})\"\"t\\<in>\\<Union>(T{restricted to}{x,y})\"\"s\\<noteq>t\"\n        with tot have \"s\\<in>{x,y}\"\"t\\<in>{x,y}\"\"s\\<noteq>t\" by auto\n        then have \"(s=x\\<and>t=y)\\<or>(s=y\\<and>t=x)\" by auto\n        with open_set have \"\\<exists>U\\<in>(T{restricted to}{x,y}). s\\<in>U\\<and>t\\<notin>U\" using \\<open>x\\<noteq>y\\<close> by auto\n      }\n      then have \"(T{restricted to}{x,y}){is T\\<^sub>1}\" unfolding isT1_def by auto\n      with sub \\<open>T{is anti-}isT1\\<close> tot have \"{x,y} {is in the spectrum of}isT1\" using antiProperty_def\n        by auto\n      then have \"{x,y}\\<lesssim>1\" using T1_spectrum by auto\n      moreover\n      have \"x\\<in>{x,y}\" by auto\n      ultimately have \"{x}={x,y}\" using lepoll_1_is_sing[of \"{x,y}\"\"x\"] by auto\n      moreover\n      have \"y\\<in>{x,y}\" by auto\n      ultimately\n      have \"y\\<in>{x}\" by auto\n      then have \"x=y\" by auto\n      then have \"False\" using \\<open>x\\<in>A\\<close>\\<open>y\\<notin>A\\<close> by auto\n    }\n    then have \"A\\<subseteq>B\\<or>B\\<subseteq>A\" by auto\n  }\n  then have \"?r {is total on}T\" using IsTotal_def by auto\n  ultimately\n  show \"IsLinOrder(T,?r)\" using IsLinOrder_def by auto\nnext\n  assume \"IsLinOrder(T,{\\<langle>U,V\\<rangle>\\<in>Pow(\\<Union>T)\\<times>Pow(\\<Union>T). U\\<subseteq>V})\"\n  then have ordTot:\"\\<forall>S\\<in>T. \\<forall>B\\<in>T. S\\<subseteq>B\\<or>B\\<subseteq>S\" unfolding IsLinOrder_def IsTotal_def by auto\n  {\n    fix A\n    assume \"A\\<in>Pow(\\<Union>T)\" and T1:\"(T{restricted to}A) {is T\\<^sub>1}\"\n    then have tot:\"\\<Union>(T{restricted to}A)=A\" unfolding RestrictedTo_def by auto\n    {\n      fix U V\n      assume \"U\\<in>T{restricted to}A\"\"V\\<in>T{restricted to}A\"\n      then obtain AU AV where \"AU\\<in>T\"\"AV\\<in>T\"\"U=A\\<inter>AU\"\"V=A\\<inter>AV\" unfolding RestrictedTo_def by auto\n      with ordTot have \"U\\<subseteq>V\\<or>V\\<subseteq>U\" by auto\n    }\n    then have ordTotSub:\"\\<forall>S\\<in>T{restricted to}A. \\<forall>B\\<in>T{restricted to}A. S\\<subseteq>B\\<or>B\\<subseteq>S\" by auto\n    {\n      assume \"A=0\"\n      then have \"A\\<approx>0\" by auto\n      moreover\n      have \"0\\<lesssim>1\" using empty_lepollI by auto\n      ultimately have \"A\\<lesssim>1\" using eq_lepoll_trans by auto\n      then have \"A{is in the spectrum of}isT1\" using T1_spectrum by auto\n    }\n    moreover\n    {\n      assume \"A\\<noteq>0\"\n      then obtain t where \"t\\<in>A\" by blast\n      {\n        fix y\n        assume \"y\\<in>A\"\"y\\<noteq>t\"\n        with \\<open>t\\<in>A\\<close> tot T1 obtain U where \"U\\<in>(T{restricted to}A)\"\"y\\<in>U\"\"t\\<notin>U\" unfolding isT1_def\n          by auto\n        from \\<open>y\\<noteq>t\\<close> have \"t\\<noteq>y\" by auto\n        with \\<open>y\\<in>A\\<close>\\<open>t\\<in>A\\<close> tot T1 obtain V where \"V\\<in>(T{restricted to}A)\"\"t\\<in>V\"\"y\\<notin>V\" unfolding isT1_def\n          by auto\n        with \\<open>y\\<in>U\\<close>\\<open>t\\<notin>U\\<close> have \"\\<not>(U\\<subseteq>V\\<or>V\\<subseteq>U)\" by auto\n        with ordTotSub \\<open>U\\<in>(T{restricted to}A)\\<close>\\<open>V\\<in>(T{restricted to}A)\\<close> have \"False\" by auto\n      }\n      then have \"\\<forall>y\\<in>A. y=t\" by auto\n      with \\<open>t\\<in>A\\<close> have \"A={t}\" by blast\n      then have \"A\\<approx>1\" using singleton_eqpoll_1 by auto\n      then have \"A\\<lesssim>1\" using eqpoll_imp_lepoll by auto\n      then have \"A{is in the spectrum of}isT1\" using T1_spectrum by auto\n    }\n    ultimately\n    have \"A{is in the spectrum of}isT1\" by auto\n  }\n  then show \"T{is anti-}isT1\" using antiProperty_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_properties",
            "IsarMathLib.Topology_ZF_examples_1",
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_5.thy",
        "id": 2225,
        "informal": " The theorem \"anti_T1\" states that a relation T is anti-reflexive if and only if T is a linear order on its power set Union(T) x Union(T), where U is included in V."
    },
    "255": {
        "type": "lemma",
        "text": "text\\<open>A base doesn't need the empty set.\\<close>\n",
        "assumes": "",
        "using": [
            "IsAbaseFor_def"
        ],
        "statement": "lemma base_no_0:\n  shows \"B{is a base for}T \\<longleftrightarrow> (B-{0}){is a base for}T\"\n",
        "proof": "proof-\n  {\n    fix M\n    assume \"M\\<in>{\\<Union>A . A \\<in> Pow(B)}\"\n    then obtain Q where \"M=\\<Union>Q\"\"Q\\<in>Pow(B)\" by auto\n    hence \"M=\\<Union>(Q-{0})\"\"Q-{0}\\<in>Pow(B-{0})\" by auto\n    hence \"M\\<in>{\\<Union>A . A \\<in> Pow(B - {0})}\" by auto\n  }\n  hence \"{\\<Union>A . A \\<in> Pow(B)} \\<subseteq> {\\<Union>A . A \\<in> Pow(B - {0})}\" by blast\n  moreover\n  {\n    fix M\n    assume \"M\\<in>{\\<Union>A . A \\<in> Pow(B-{0})}\"\n    then obtain Q where \"M=\\<Union>Q\"\"Q\\<in>Pow(B-{0})\" by auto\n    hence \"M=\\<Union>(Q)\"\"Q\\<in>Pow(B)\" by auto\n    hence \"M\\<in>{\\<Union>A . A \\<in> Pow(B)}\" by auto\n  }\n  hence \" {\\<Union>A . A \\<in> Pow(B - {0})} \\<subseteq> {\\<Union>A . A \\<in> Pow(B)} \"\n    by auto\n  ultimately have \"{\\<Union>A . A \\<in> Pow(B - {0})} = {\\<Union>A . A \\<in> Pow(B)} \" by auto\n  then show \"B{is a base for}T \\<longleftrightarrow> (B-{0}){is a base for}T\" using IsAbaseFor_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2323,
        "informal": " A set B is a base for a binary relation T if and only if B, excluding the empty set, is a base for T."
    },
    "256": {
        "type": "lemma",
        "text": "text\\<open>The set of group valued finite range functions is closed with respect \n  to the lifted group operation.\\<close>\n",
        "assumes": "assumes A1: \"F = P {lifted to function space over} X\"\n  ",
        "using": [
            "Group_ZF_3_1_L1",
            "IsOpClosed_def"
        ],
        "statement": "lemma (in group0) Group_ZF_3_1_L2:\n  assumes A1: \"F = P {lifted to function space over} X\"\n  shows \"FinRangeFunctions(X,G) {is closed under} F\"\n",
        "proof": "proof -\n  let ?A = \"FinRangeFunctions(X,G)\"\n  from A1 have \"\\<forall>x\\<in>?A. \\<forall>y\\<in>?A. F`\\<langle> x,y\\<rangle> \\<in> ?A\"\n    using Group_ZF_3_1_L1 by simp\n  then show ?thesis using IsOpClosed_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_2",
            "IsarMathLib.Finite1"
        ],
        "source": "IsarMathLib/Group_ZF_3.thy",
        "id": 563,
        "informal": " In the group0 theory, given a function F from X to functions over X, the image of FinRangeFunctions(X,G) under F is still contained in FinRangeFunctions(X,G)."
    },
    "257": {
        "type": "lemma",
        "text": "text\\<open>Simple identities about (absolute value of) homomorphism differences.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  ",
        "using": [
            "apply_funtype",
            "Int_ZF_1_1_L4",
            "Int_ZF_1_1_L5",
            "Int_ZF_2_L17",
            "Int_ZF_1_2_L9A",
            "Int_ZF_1_2_L9"
        ],
        "statement": "lemma (in int1) Int_ZF_2_1_L18:  \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"m\\<in>\\<int>\"  \"n\\<in>\\<int>\"\n  shows \n  \"abs(f`(n) \\<ra> f`(m) \\<rs> f`(m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n  \"abs(f`(m) \\<ra> f`(n) \\<rs> f`(m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n  \"(\\<rm>(f`(m))) \\<rs> f`(n) \\<ra> f`(m\\<ra>n) = \\<delta>(f,m,n)\"\n  \"(\\<rm>(f`(n))) \\<rs> f`(m) \\<ra> f`(m\\<ra>n) = \\<delta>(f,m,n)\"\n  \"abs((\\<rm>f`(m\\<ra>n)) \\<ra> f`(m) \\<ra> f`(n)) = abs(\\<delta>(f,m,n))\"\n",
        "proof": "proof -\n  from A1 A2 have T: \n    \"f`(m\\<ra>n) \\<in> \\<int>\"  \"f`(m) \\<in> \\<int>\"  \"f`(n) \\<in> \\<int>\"\n    \"f`(m\\<ra>n) \\<rs> f`(m) \\<rs>  f`(n)  \\<in> \\<int>\"\n    \"(\\<rm>(f`(m))) \\<in> \\<int>\"\n    \"(\\<rm>f`(m\\<ra>n)) \\<ra> f`(m) \\<ra> f`(n) \\<in> \\<int>\"\n    using apply_funtype Int_ZF_1_1_L4 Int_ZF_1_1_L5 by auto\n  then have \n    \"abs(\\<rm>(f`(m\\<ra>n) \\<rs> f`(m) \\<rs>  f`(n))) = abs(f`(m\\<ra>n) \\<rs> f`(m) \\<rs>  f`(n))\"\n    using Int_ZF_2_L17 by simp\n  moreover from T have \n    \"(\\<rm>(f`(m\\<ra>n) \\<rs> f`(m) \\<rs>  f`(n))) = f`(n) \\<ra> f`(m) \\<rs> f`(m\\<ra>n)\"\n    using Int_ZF_1_2_L9A by simp\n  ultimately show \"abs(f`(n) \\<ra> f`(m) \\<rs> f`(m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n    by simp\n  moreover from T have \"f`(n) \\<ra> f`(m) = f`(m) \\<ra> f`(n)\"\n    using Int_ZF_1_1_L5 by simp\n  ultimately show \"abs(f`(m) \\<ra> f`(n) \\<rs> f`(m\\<ra>n)) = abs(\\<delta>(f,m,n))\"\n    by simp\n  from T show \n    \"(\\<rm>(f`(m))) \\<rs> f`(n) \\<ra> f`(m\\<ra>n) = \\<delta>(f,m,n)\"\n    \"(\\<rm>(f`(n))) \\<rs> f`(m) \\<ra> f`(m\\<ra>n) = \\<delta>(f,m,n)\"\n    using Int_ZF_1_2_L9 by auto\n  from T have \n    \"abs((\\<rm>f`(m\\<ra>n)) \\<ra> f`(m) \\<ra> f`(n)) =\n    abs(\\<rm>((\\<rm>f`(m\\<ra>n)) \\<ra> f`(m) \\<ra> f`(n)))\"\n    using Int_ZF_2_L17 by simp\n  also from T have \n    \"abs(\\<rm>((\\<rm>f`(m\\<ra>n)) \\<ra> f`(m) \\<ra> f`(n))) = abs(\\<delta>(f,m,n))\"\n    using Int_ZF_1_2_L9 by simp\n  finally show \"abs((\\<rm>f`(m\\<ra>n)) \\<ra> f`(m) \\<ra> f`(n)) = abs(\\<delta>(f,m,n))\"\n    by simp\nqed\n",
        "imports": [
            "IsarMathLib.func_ZF_1",
            "IsarMathLib.Int_ZF_1",
            "IsarMathLib.IntDiv_ZF_IML",
            "IsarMathLib.Group_ZF_3"
        ],
        "source": "IsarMathLib/Int_ZF_2.thy",
        "id": 869,
        "informal": " Given a function f from integers to integers and integers m and n, the absolute differences of f(m) and f(n), and of f(m) and f(m ras n), as well as those of m ras n and m, and n and m, are equal to the absolute difference of f between m and n. Similarly, the absolute values of the right multiplications of f(m) and f(n) by m ras n, and of f(m) by m and n, are also equal to the absolute difference of f between m and n."
    },
    "258": {
        "type": "lemma",
        "text": "text\\<open>Given a partition, \nthe complement of a union of a subfamily\nis a union of a subfamily.\\<close>\n",
        "assumes": "assumes \"R\\<subseteq>P\" \"P {is a partition of} X\"\n  ",
        "using": [
            "IsAPartition_def"
        ],
        "statement": "lemma diff_union_is_union_diff:\n  assumes \"R\\<subseteq>P\" \"P {is a partition of} X\"\n  shows \"X - \\<Union>R=\\<Union>(P-R)\"\n",
        "proof": "proof\n  {\n    fix x\n    assume \"x\\<in>X - \\<Union>R\"\n    hence P:\"x\\<in>X\"\"x\\<notin>\\<Union>R\" by auto\n    {\n      fix T\n      assume \"T\\<in>R\"\n      with P(2) have \"x\\<notin>T\" by auto\n    }\n    with P(1) assms(2) obtain Q where \"Q\\<in>(P-R)\"\"x\\<in>Q\" using IsAPartition_def by auto\n    hence \"x\\<in>\\<Union>(P-R)\" by auto\n  }\n  thus \"X - \\<Union>R\\<subseteq>\\<Union>(P-R)\" by auto\n  {\n    fix x\n    assume \"x\\<in>\\<Union>(P-R)\"\n    then obtain Q where \"Q\\<in>P-R\"\"x\\<in>Q\" by auto\n    hence C: \"Q\\<in>P\"\"Q\\<notin>R\"\"x\\<in>Q\" by auto\n    then have \"x\\<in>\\<Union>P\" by auto\n    with assms(2) have \"x\\<in>X\" using IsAPartition_def by auto\n    moreover\n    {\n      assume \"x\\<in>\\<Union>R\"\n      then obtain t where G:\"t\\<in>R\" \"x\\<in>t\" by auto\n      with C(3) assms(1) have \"t\\<inter>Q\\<noteq>0\"\"t\\<in>P\" by auto\n      with assms(2) C(1,3) have \"t=Q\" using IsAPartition_def\n        by blast\n      with C(2) G(1) have \"False\" by auto\n    }\n    hence \"x\\<notin>\\<Union>R\" by auto\n    ultimately have \"x\\<in>X-\\<Union>R\" by auto\n  }\n  thus \"\\<Union>(P-R)\\<subseteq>X - \\<Union>R\" by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2333,
        "informal": " If R is a subset of partition P of X, then X minus the union of R is equal to the union of the differences between each partition element and R."
    },
    "259": {
        "type": "lemma",
        "text": "text\\<open> The assumtions of the \\<open>field1\\<close> locale (that sets the context for ordered fields) \n  hold in the \\<open>reals\\<close> locale \\<close>\n",
        "assumes": "",
        "using": [
            "IsAmodelOfReals_def",
            "IsAnOrdField_def",
            "IsAnOrdRing_def"
        ],
        "statement": "lemma (in reals) field1_is_valid: shows \"field1(\\<real>, Add, Mul,ROrd)\"\n",
        "proof": "proof\n  from R_are_reals show \"IsAring(\\<real>, Add, Mul)\" and \"Mul {is commutative on} \\<real>\"\n    and \"ROrd \\<subseteq> \\<real> \\<times> \\<real>\" and \"IsLinOrder(\\<real>,  ROrd)\" \n    and \"\\<forall>x y. \\<forall>z\\<in>\\<real>. \\<langle>x, y\\<rangle> \\<in> ROrd \\<longrightarrow> \\<langle>Add`\\<langle>x, z\\<rangle>, Add`\\<langle>y, z\\<rangle>\\<rangle> \\<in> ROrd\"\n    and \"Nonnegative(\\<real>, Add, ROrd) {is closed under} Mul\"\n    and \"TheNeutralElement(\\<real>, Add) \\<noteq> TheNeutralElement(\\<real>, Mul)\"\n    and \"\\<forall>x\\<in>\\<real>. x \\<noteq> TheNeutralElement(\\<real>,Add) \\<longrightarrow> (\\<exists>y\\<in>\\<real>. Mul`\\<langle>x, y\\<rangle> = TheNeutralElement(\\<real>,Mul))\"\n    using IsAmodelOfReals_def IsAnOrdField_def IsAnOrdRing_def by auto\nqed\n",
        "imports": [
            "IsarMathLib.OrderedField_ZF",
            "IsarMathLib.MetricSpace_ZF"
        ],
        "source": "IsarMathLib/Real_ZF_2.thy",
        "id": 1766,
        "informal": " The lemma \"field1\\_is\\_valid\" asserts that the operation field1 is well-defined over the real numbers with respect to the addition, multiplication, and real order relation (ROrd)."
    },
    "260": {
        "type": "theorem",
        "text": "text\\<open>The definition of a group requires the existence of the right inverse.\n  We show that this is also the left inverse.\\<close>\n",
        "assumes": "assumes A1: \"g\\<in>G\" and A2: \"b\\<in>G\" and A3: \"g\\<cdot>b = \\<one>\"\n  ",
        "using": [
            "IsAgroup_def",
            "group0_2_L2",
            "group_op_closed",
            "group_oper_assoc"
        ],
        "statement": "theorem (in group0) group0_2_T1: \n  assumes A1: \"g\\<in>G\" and A2: \"b\\<in>G\" and A3: \"g\\<cdot>b = \\<one>\"\n  shows \"b\\<cdot>g = \\<one>\"\n",
        "proof": "proof -\n  from A2 groupAssum obtain c where I: \"c \\<in> G \\<and> b\\<cdot>c = \\<one>\" \n    using IsAgroup_def by auto\n  then have \"c\\<in>G\" by simp\n  have \"\\<one>\\<in>G\" using group0_2_L2 by simp\n  with A1 A2 I have \"b\\<cdot>g =  b\\<cdot>(g\\<cdot>(b\\<cdot>c))\"\n    using group_op_closed group0_2_L2 group_oper_assoc \n    by simp\n  also from  A1 A2 \\<open>c\\<in>G\\<close> have \"b\\<cdot>(g\\<cdot>(b\\<cdot>c)) = b\\<cdot>(g\\<cdot>b\\<cdot>c)\"\n    using group_oper_assoc by simp\n  also from A3 A2 I have \"b\\<cdot>(g\\<cdot>b\\<cdot>c)= \\<one>\" using group0_2_L2 by simp\n  finally show \"b\\<cdot>g = \\<one>\" by simp\nqed\n",
        "imports": [
            "IsarMathLib.Monoid_ZF"
        ],
        "source": "IsarMathLib/Group_ZF.thy",
        "id": 420,
        "informal": " In group `G`, if `g` and `b` are elements, and the product of `g` and `b` is the identity `one`, then the product of `b` and `g` is also the identity `one`."
    },
    "261": {
        "type": "lemma",
        "text": "text\\<open>A rephrasing of \\<open>filter_from_uniformity\\<close>: if $\\Phi$ is a uniformity on $X$, \n  then $\\{V(\\{ x\\}) | V\\in \\Phi\\}$ is a filter on $X$ for every $x\\in X$.\\<close>\n",
        "assumes": "assumes \"\\<Phi> {is a uniformity on} X\" and \"x\\<in>X\"\n  ",
        "using": [
            "assms",
            "filter_from_uniformity",
            "ZF_fun_from_tot_val1"
        ],
        "statement": "lemma unif_filter_at_point: \n  assumes \"\\<Phi> {is a uniformity on} X\" and \"x\\<in>X\"\n  shows \"{V``{x}.V\\<in>\\<Phi>} {is a filter on} X\"\n  ",
        "proof": "using assms filter_from_uniformity ZF_fun_from_tot_val1 \n  by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_2",
            "IsarMathLib.Topology_ZF_4a"
        ],
        "source": "IsarMathLib/UniformSpace_ZF.thy",
        "id": 2450,
        "informal": " If Φ is a uniformity on X and x is an element of X, then the set V of elements in X such that V is in Φ forms a filter on X."
    },
    "262": {
        "type": "lemma",
        "text": "text\\<open>This section continues \\<open>MMI_logic_and_sets\\<close>. \n  It exists only so that we  don't have all Metamath basic \n  theorems in one huge file.\\<close>\n",
        "assumes": "assumes A1: \"\\<phi> \\<longrightarrow> \\<psi> \\<and> ch\"   \n   ",
        "using": [
            "assms"
        ],
        "statement": "lemma MMI_pm3_27d: assumes A1: \"\\<phi> \\<longrightarrow> \\<psi> \\<and> ch\"   \n   shows \"\\<phi> \\<longrightarrow> ch\"\n   ",
        "proof": "using assms by auto\n",
        "imports": [
            "IsarMathLib.MMI_logic_and_sets"
        ],
        "source": "IsarMathLib/MMI_logic_and_sets_1.thy",
        "id": 1089,
        "informal": " If `phi` implies `psi` and a hypothesis `ch` holds, then `phi` implies `ch`."
    },
    "263": {
        "type": "lemma",
        "text": "text\\<open>The closed sets are the small subsets of $X$ and $X$ itself.\\<close>\n",
        "assumes": "assumes \"T\\<noteq>0\"\n  ",
        "using": [
            "CoCardinal_def",
            "IsClosed_def",
            "union_cocardinal"
        ],
        "statement": "lemma closed_sets_cocardinal:\n  assumes \"T\\<noteq>0\"\n  shows \"D {is closed in} CoCardinal(X,T) \\<longleftrightarrow> (D\\<in>Pow(X) \\<and> D\\<prec>T) \\<or> D=X\"\n",
        "proof": "proof-\n  {\n    assume A:\"D \\<subseteq> X\" \"X - D \\<in> CoCardinal(X,T) \"\" D \\<noteq> X\"\n    from A(1,3) have \"X-(X-D)=D\" \"X-D\\<noteq>0\" by auto\n    with A(2) have \"D\\<prec>T\" using CoCardinal_def by simp\n  }\n  with assms have \"D {is closed in} CoCardinal(X,T) \\<longrightarrow> (D\\<in>Pow(X) \\<and>  D\\<prec>T)\\<or> D=X\" using IsClosed_def\n    union_cocardinal by auto\n  moreover\n  {\n    assume A:\"D \\<prec> T\"\"D \\<subseteq> X\"\n    from A(2) have \"X-(X-D)=D\" by blast\n    with A(1) have \"X-(X-D)\\<prec> T\" by auto\n    then have \"X-D\\<in> CoCardinal(X,T)\" using CoCardinal_def by auto\n  }\n  with assms have \"(D\\<in>Pow(X) \\<and>  D\\<prec>T)\\<longrightarrow> D {is closed in} CoCardinal(X,T)\" using union_cocardinal\n    IsClosed_def by auto\n  moreover\n  have \"X-X=0\" by auto\n  then have \"X-X\\<in> CoCardinal(X,T)\"using CoCardinal_def by auto\n  with assms have \"X{is closed in} CoCardinal(X,T)\" using union_cocardinal\n    IsClosed_def by auto\n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF",
            "IsarMathLib.Cardinal_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples.thy",
        "id": 2289,
        "informal": " A set D is closed in the co-cardinality T of a set X if and only if D is a subset of X and either D is empty or D is the set T itself."
    },
    "264": {
        "type": "lemma",
        "text": "text\\<open>If $f:G\\rightarrow H$ is a homomorphism, then it commutes with the inverse \\<close>\n",
        "assumes": "assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\" \"g\\<in>G\"\n  ",
        "using": [
            "apply_type",
            "group0.inverse_in_group",
            "group0_def",
            "group0.group0_2_L6",
            "Homomor_def",
            "group0.group0_2_L9",
            "image_neutral"
        ],
        "statement": "lemma image_inv:\n  assumes \"IsAgroup(G,P)\" \"IsAgroup(H,F)\" \"Homomor(f,G,P,H,F)\" \"f:G\\<rightarrow>H\" \"g\\<in>G\"\n  shows \"f`(GroupInv(G,P)`(g)) = GroupInv(H,F)`(f`(g))\"\n",
        "proof": "proof-\n  from assms(4,5) have im: \"f`(g)\\<in>H\" using apply_type by simp\n  from assms(1,5) have inv: \"GroupInv(G,P)`(g)\\<in>G\" \n    using group0.inverse_in_group unfolding group0_def by simp\n  with assms(4) have inv2: \"f`(GroupInv(G,P)`g)\\<in>H\" using apply_type by simp\n  from assms(1,5) have \n    \"f`(TheNeutralElement(G,P)) = f`(P`\\<langle>g,GroupInv(G,P)`(g)\\<rangle>)\" \n    using group0.group0_2_L6 unfolding group0_def by simp\n  also from assms(1,2,3,5) inv have \"\\<dots> = F`\\<langle>f`(g),f`(GroupInv(G,P)`(g))\\<rangle>\" \n    using Homomor_def by simp\n  finally have \"f`(TheNeutralElement(G,P)) = F`\\<langle>f`(g),f`(GroupInv(G,P)`(g))\\<rangle>\"\n    by simp\n  with assms(1-4) im inv2 show ?thesis \n    using group0.group0_2_L9 image_neutral unfolding group0_def by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF_4",
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.Semigroup_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_5.thy",
        "id": 652,
        "informal": " Given groups G with operation P, H with operation F, a homomorphism f from G to H, and an element g in G, the image of the inverse element of g under f is equal to the inverse of the image of g under f."
    },
    "265": {
        "type": "lemma",
        "text": "text\\<open>Proving the facts about associative and commutative operations is \n  quite tedious in formalized mathematics. To a human the thing is simple:\n  we can arrange the elements in any order and put parantheses wherever we \n  want, it is all the same. However, formalizing this statement would be \n  rather difficult (I think). The next lemma attempts a quasi-algorithmic\n  approach to this type of problem. To prove that two expressions are equal, \n  we first strip one from parantheses, then rearrange the elements in proper \n  order, then put the parantheses where we want them to be. The algorithm for \n  rearrangement is easy to describe: we keep putting the first element \n  (from the right) that is in the wrong place at the left-most position\n  until we get the proper arrangement. \n  As far removing parantheses is concerned Isabelle does its job \n  automatically.\\<close>\n",
        "assumes": "assumes A1:\"P {is commutative on} G\"\n  and A2:\"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\" \"d\\<in>G\" \"E\\<in>G\" \"F\\<in>G\"\n  ",
        "using": [
            "group_op_closed",
            "group_oper_assoc",
            "IsCommutative_def"
        ],
        "statement": "lemma (in group0) group0_4_L2:\n  assumes A1:\"P {is commutative on} G\"\n  and A2:\"a\\<in>G\" \"b\\<in>G\" \"c\\<in>G\" \"d\\<in>G\" \"E\\<in>G\" \"F\\<in>G\"\n  shows \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<cdot>(E\\<cdot>F) = (a\\<cdot>(d\\<cdot>F))\\<cdot>(b\\<cdot>(c\\<cdot>E))\"\n",
        "proof": "proof -\n  from A2 have \"(a\\<cdot>b)\\<cdot>(c\\<cdot>d)\\<cdot>(E\\<cdot>F) = a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E\\<cdot>F\"\n    using group_op_closed group_oper_assoc\n    by simp\n  also have  \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E\\<cdot>F = a\\<cdot>d\\<cdot>F\\<cdot>b\\<cdot>c\\<cdot>E\"\n  proof -\n    from A1 A2 have \"a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E\\<cdot>F = F\\<cdot>(a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E)\"\n      using IsCommutative_def group_op_closed \n      by simp\n    also from A2 have \"F\\<cdot>(a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E) = F\\<cdot>a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E\"\n      using group_op_closed group_oper_assoc\n      by simp\n    also from A1 A2 have \"F\\<cdot>a\\<cdot>b\\<cdot>c\\<cdot>d\\<cdot>E = d\\<cdot>(F\\<cdot>a\\<cdot>b\\<cdot>c)\\<cdot>E\"\n      using IsCommutative_def group_op_closed\n      by simp\n    also from A2 have \"d\\<cdot>(F\\<cdot>a\\<cdot>b\\<cdot>c)\\<cdot>E = d\\<cdot>F\\<cdot>a\\<cdot>b\\<cdot>c\\<cdot>E\"\n      using group_op_closed group_oper_assoc\n      by simp\n    also from A1 A2 have \" d\\<cdot>F\\<cdot>a\\<cdot>b\\<cdot>c\\<cdot>E = a\\<cdot>(d\\<cdot>F)\\<cdot>b\\<cdot>c\\<cdot>E\"\n      using IsCommutative_def group_op_closed\n      by simp\n    also from A2 have \"a\\<cdot>(d\\<cdot>F)\\<cdot>b\\<cdot>c\\<cdot>E = a\\<cdot>d\\<cdot>F\\<cdot>b\\<cdot>c\\<cdot>E\" \n      using group_op_closed group_oper_assoc\n      by simp\n    finally show ?thesis by simp\n  qed\n  also from A2 have \"a\\<cdot>d\\<cdot>F\\<cdot>b\\<cdot>c\\<cdot>E = (a\\<cdot>(d\\<cdot>F))\\<cdot>(b\\<cdot>(c\\<cdot>E))\"\n    using group_op_closed group_oper_assoc\n    by simp\n  finally show ?thesis by simp\nqed\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/AbelianGroup_ZF.thy",
        "id": 0,
        "informal": " In the group0 theory, given a commutative group G and elements a, b, c, d, E, F in G, we have the equality: (a * b) * (c * d) * (E * F) = (a * (d * F)) * (b * (c * E))\n\nHere's a more detailed version:\n\nIn the Group0 theory, let assumptions be as follows: \n1. The group G is commutative. (Symbolically represented as P {is commutative on} G)\n2. a, b, c, d, E, and F are elements within the group G. (Symbolically represented as a ∈ G, b ∈ G, c ∈ G, d ∈ G, E ∈ G, and F ∈ G)\n\nWe want to establish that the following equation holds true:\n\n(a * b) * (c * d) * (E * F) = (a * (d * F)) * (b * (c * E))\n\nWherein * represents the group operation."
    },
    "266": {
        "type": "lemma",
        "text": "text\\<open>A continuous bijection that maps base to open sets is a homeomorphism.\\<close>\n",
        "assumes": "assumes A1: \"f \\<in> bij(X\\<^sub>1,X\\<^sub>2)\" and A2: \"\\<B> {is a base for} \\<tau>\\<^sub>1\"  and A3: \"\\<C> {is a base for} \\<tau>\\<^sub>2\" and\n  A4: \"\\<forall>U\\<in>\\<C>. f-``(U) \\<in> \\<tau>\\<^sub>1\" and A5: \"\\<forall>V\\<in>\\<B>. f``(V) \\<in> \\<tau>\\<^sub>2\"\n  ",
        "using": [
            "assms",
            "tau2_is_top",
            "tau1_is_top",
            "bij_converse_bij",
            "bij_is_fun",
            "two_top_spaces0_def",
            "image_converse",
            "two_top_spaces0.Top_ZF_2_1_L5",
            "IsAhomeomorphism_def"
        ],
        "statement": "lemma (in two_top_spaces0) bij_base_open_homeo:\n  assumes A1: \"f \\<in> bij(X\\<^sub>1,X\\<^sub>2)\" and A2: \"\\<B> {is a base for} \\<tau>\\<^sub>1\"  and A3: \"\\<C> {is a base for} \\<tau>\\<^sub>2\" and\n  A4: \"\\<forall>U\\<in>\\<C>. f-``(U) \\<in> \\<tau>\\<^sub>1\" and A5: \"\\<forall>V\\<in>\\<B>. f``(V) \\<in> \\<tau>\\<^sub>2\"\n  shows \"IsAhomeomorphism(\\<tau>\\<^sub>1,\\<tau>\\<^sub>2,f)\"\n  ",
        "proof": "using assms tau2_is_top tau1_is_top bij_converse_bij bij_is_fun two_top_spaces0_def \n  image_converse two_top_spaces0.Top_ZF_2_1_L5 IsAhomeomorphism_def by simp \n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.func1",
            "IsarMathLib.Fol1"
        ],
        "source": "IsarMathLib/Topology_ZF_2.thy",
        "id": 2106,
        "informal": " Given that:\n1. f is a bijection from X₁ to X₂,\n2. B is a base for topology τsub1,\n3. C is a base for topology τsub2,\n4. For every U in C, the image of U under f is in τsub1,\n5. For every V in B, the preimage of V under f is in τsub2.\n\nThen, (τsub1, τsub2, f) is a homeomorphism."
    },
    "267": {
        "type": "lemma",
        "text": "text\\<open>Product of elements of subsets of the group is in the set product of those subsets\\<close>\n",
        "assumes": "assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"x\\<in>A\" \"y\\<in>B\"\n  ",
        "using": [
            "assms",
            "interval_prod"
        ],
        "statement": "lemma (in group4) interval_prod_el: assumes \"A\\<subseteq>G\" \"B\\<subseteq>G\" \"x\\<in>A\" \"y\\<in>B\"\n  shows \"x\\<cdot>y \\<in> A\\<sdot>B\"\n  ",
        "proof": "using assms interval_prod by auto\n",
        "imports": [
            "IsarMathLib.Group_ZF"
        ],
        "source": "IsarMathLib/Group_ZF_1.thy",
        "id": 509,
        "informal": " If A is a subset of G, B is a subset of G, x is an element of A, and y is an element of B, then the product x yield y belongs to the cartesian product A times B."
    },
    "268": {
        "type": "lemma",
        "text": "text\\<open>We can make a function smaller than any constant on a given interval\n  of positive integers by adding another constant.\\<close>\n",
        "assumes": "assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"K\\<in>\\<int>\" \"N\\<in>\\<int>\"\n  ",
        "using": [
            "int_zero_one_are_int",
            "no_int_between",
            "Int_ZF_1_5_L3",
            "Int_ZF_1_1_L4",
            "int_ord_transl_inv",
            "Int_ZF_1_2_L3",
            "Int_ZF_1_4_L2",
            "Int_ZF_1_1_L5",
            "PositiveSet_def",
            "Int_ZF_1_3_L6A",
            "Interval_def",
            "Int_ZF_1_2_L3AA"
        ],
        "statement": "lemma (in int0) Int_ZF_1_5_L4: \n  assumes A1: \"f:\\<int>\\<rightarrow>\\<int>\" and A2: \"K\\<in>\\<int>\" \"N\\<in>\\<int>\"\n  shows \"\\<exists>C\\<in>\\<int>. \\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> C \\<longrightarrow> N\\<lsq>n\"\n",
        "proof": "proof -\n  from A2 have \"N\\<lsq>\\<one> \\<or> \\<two>\\<lsq>N\"\n    using int_zero_one_are_int no_int_between\n    by simp\n  moreover\n  { assume A3: \"N\\<lsq>\\<one>\"\n    let ?C = \"\\<zero>\"\n    have \"?C \\<in> \\<int>\" using int_zero_one_are_int\n      by simp\n    moreover\n    { fix n assume \"n\\<in>\\<int>\\<^sub>+\"\n      then have \"\\<one> \\<lsq> n\" using Int_ZF_1_5_L3\n\tby simp\t\n      with A3 have \"N\\<lsq>n\" by (rule Int_order_transitive)\n    } then have  \"\\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> ?C \\<longrightarrow> N\\<lsq>n\"\n      by auto\n    ultimately have \"\\<exists>C\\<in>\\<int>. \\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> C \\<longrightarrow> N\\<lsq>n\"\n      by auto }\n  moreover\n  { let ?C = \"K \\<rs> \\<one> \\<rs> maxf(f,\\<one>..(N\\<rs>\\<one>))\"\n    assume \"\\<two>\\<lsq>N\"\n    then have \"\\<two>\\<rs>\\<one> \\<lsq> N\\<rs>\\<one>\"\n      using int_zero_one_are_int Int_ZF_1_1_L4 int_ord_transl_inv\n      by simp\n    then have I: \"\\<one> \\<lsq> N\\<rs>\\<one>\"\n      using int_zero_one_are_int Int_ZF_1_2_L3 by simp\n    with A1 A2 have T: \n      \"maxf(f,\\<one>..(N\\<rs>\\<one>)) \\<in> \\<int>\"  \"K\\<rs>\\<one> \\<in> \\<int>\"  \"?C \\<in> \\<int>\"\n      using Int_ZF_1_4_L2 Int_ZF_1_1_L5 int_zero_one_are_int\n      by auto\n    moreover\n    { fix n assume A4: \"n\\<in>\\<int>\\<^sub>+\" \n      { assume A5: \"K \\<lsq> f`(n) \\<ra> ?C\" and \"\\<not>(N\\<lsq>n)\"\n\twith A2 A4 have \"n \\<lsq> N\\<rs>\\<one>\"  \n\t  using PositiveSet_def Int_ZF_1_3_L6A by simp\n\twith A4 have \"n \\<in> \\<one>..(N\\<rs>\\<one>)\"\n\t  using Int_ZF_1_5_L3 Interval_def by auto\n\twith A1 I T have \"f`(n)\\<ra>?C \\<lsq> maxf(f,\\<one>..(N\\<rs>\\<one>)) \\<ra> ?C\"\n\t  using Int_ZF_1_4_L2 int_ord_transl_inv by simp\n\twith T have \"f`(n)\\<ra>?C \\<lsq> K\\<rs>\\<one>\"\n\t  using Int_ZF_1_2_L3 by simp\n\twith A5 have \"K \\<lsq>  K\\<rs>\\<one>\"\n\t  by (rule Int_order_transitive)\n\twith A2 have False using Int_ZF_1_2_L3AA by simp\n      } then have \"K \\<lsq> f`(n) \\<ra> ?C \\<longrightarrow> N\\<lsq>n\"\n\tby auto \n    } then have \"\\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> ?C \\<longrightarrow> N\\<lsq>n\"\n      by simp\n    ultimately have \"\\<exists>C\\<in>\\<int>. \\<forall>n\\<in>\\<int>\\<^sub>+. K \\<lsq> f`(n) \\<ra> C \\<longrightarrow> N\\<lsq>n\" \n      by auto } \n  ultimately show ?thesis by auto\nqed\n",
        "imports": [
            "IsarMathLib.Int_ZF_IML",
            "IsarMathLib.OrderedRing_ZF"
        ],
        "source": "IsarMathLib/Int_ZF_1.thy",
        "id": 814,
        "informal": " Given a function f from integers to integers and integers K and N, there exists an integer C such that for all n, if K is less than the sum of n and the value of f at n, then N is less than or equal to n."
    },
    "269": {
        "type": "lemma",
        "text": "text\\<open>Double nonnegative is nonnegative.\\<close>\n",
        "assumes": "assumes A1: \"\\<zero>\\<lsq>a\"\n  ",
        "using": [
            "assms",
            "OrdRing_ZF_1_L4",
            "group3.OrderedGroup_ZF_1_L5G",
            "OrdRing_ZF_1_L3",
            "Ring_ZF_1_L3"
        ],
        "statement": "lemma (in  ring1) OrdRing_ZF_1_L5A: assumes A1: \"\\<zero>\\<lsq>a\"\n  shows \"\\<zero>\\<lsq>\\<two>\\<cdot>a\"\n  ",
        "proof": "using assms OrdRing_ZF_1_L4 group3.OrderedGroup_ZF_1_L5G\n  OrdRing_ZF_1_L3 Ring_ZF_1_L3 by simp\n",
        "imports": [
            "IsarMathLib.Ring_ZF",
            "IsarMathLib.OrderedGroup_ZF_1"
        ],
        "source": "IsarMathLib/OrderedRing_ZF.thy",
        "id": 1547,
        "informal": " Assuming `a` is a non-zero element in a ring (according to the hypotheses in `ring1`), it can be shown that `2 * a` is also non-zero."
    },
    "270": {
        "type": "lemma",
        "text": "text\\<open>The value of the set neighborhood system of $T$ at subset $A$ of $\\bigcup T$\n  is the collection of subsets $N$ of $\\bigcup T$ for which exists an open subset\n  $U\\subseteq N$ that contains $A$. \\<close>\n",
        "assumes": "assumes \"A \\<subseteq> \\<Union>T\"\n  ",
        "using": [
            "assms",
            "ZF_fun_from_tot_val1",
            "SetNeighSystem_def"
        ],
        "statement": "lemma nei_val: assumes \"A \\<subseteq> \\<Union>T\"\n  shows\n  \"({set neighborhood system of} T)`(A) = {N\\<in>Pow(\\<Union>T). \\<exists>U\\<in>T. (A\\<subseteq>U \\<and> U\\<subseteq>N)}\"\n  ",
        "proof": "using assms ZF_fun_from_tot_val1 unfolding SetNeighSystem_def by simp\n",
        "imports": [
            "IsarMathLib.Topology_ZF_4"
        ],
        "source": "IsarMathLib/Topology_ZF_4a.thy",
        "id": 2192,
        "informal": " If A is a subset of the union of a set T, then the neighborhood system of T with respect to A equals the set of neighborhoods N such that there exists U in T with A being a subset of U and U being a subset of N."
    },
    "271": {
        "type": "lemma",
        "text": "text\\<open>The topology is defined in the set $X$, when $X$ has more than \none point\\<close>\n",
        "assumes": "assumes \"IsLinOrder(X,r)\"\"\\<exists>x y. x\\<noteq>y \\<and> x\\<in>X\\<and> y\\<in>X\"\n  ",
        "using": [
            "Ordtopology_is_a_topology(2)",
            "assms(1)",
            "LeftRayX_def",
            "RightRayX_def",
            "IsLinOrder_def",
            "IsTotal_def",
            "T",
            "Top_1_2_L5",
            "base",
            "x",
            "IntervalX_def"
        ],
        "statement": "lemma union_ordtopology:\n  assumes \"IsLinOrder(X,r)\"\"\\<exists>x y. x\\<noteq>y \\<and> x\\<in>X\\<and> y\\<in>X\"\n  shows \"\\<Union>(OrdTopology X r)=X\"\n",
        "proof": "proof\n  let ?B=\"{IntervalX(X,r,b,c). \\<langle>b,c\\<rangle>\\<in>X\\<times>X}\\<union>{LeftRayX(X,r,b). b\\<in>X}\\<union>{RightRayX(X,r,b). b\\<in>X}\"\n  have base:\"?B {is a base for} (OrdTopology X r)\" using Ordtopology_is_a_topology(2) assms(1)\n    by auto\n  from assms(2) obtain x y where T:\"x\\<noteq>y \\<and> x\\<in>X\\<and> y\\<in>X\" by auto\n  then have B:\"x\\<in>LeftRayX(X,r,y)\\<or>x\\<in>RightRayX(X,r,y)\" using LeftRayX_def RightRayX_def\n    assms(1) IsLinOrder_def IsTotal_def by auto\n  then have \"x\\<in>\\<Union>?B\" using T by auto\n  then have x:\"x\\<in>\\<Union>(OrdTopology X r)\" using Top_1_2_L5 base by auto\n  {\n    fix z\n    assume z:\"z\\<in>X\"\n    {\n      assume \"x=z\"\n      then have \"z\\<in>\\<Union>(OrdTopology X r)\" using x by auto\n    }\n    moreover\n    {\n      assume \"x\\<noteq>z\"\n      with z T have \"z\\<in>LeftRayX(X,r,x)\\<or>z\\<in>RightRayX(X,r,x)\"\"x\\<in>X\" using LeftRayX_def RightRayX_def\n        assms(1) IsLinOrder_def IsTotal_def by auto\n      then have \"z\\<in>\\<Union>?B\" by auto\n      then have \"z\\<in>\\<Union>(OrdTopology X r)\" using Top_1_2_L5 base by auto\n    }\n    ultimately have \"z\\<in>\\<Union>(OrdTopology X r)\" by auto\n  }\n  then show \"X\\<subseteq>\\<Union>(OrdTopology X r)\" by auto\n  have \"\\<Union>?B\\<subseteq>X\" using IntervalX_def LeftRayX_def RightRayX_def by auto\n  then show \"\\<Union>(OrdTopology X r)\\<subseteq>X\" using Top_1_2_L5 base by auto\nqed\n",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2347,
        "informal": " If X is linearly ordered by relation r and there exist distinct elements x and y in X, then the union of the ordinal topology on X generated by r equals X."
    },
    "272": {
        "type": "lemma",
        "text": "text\\<open>Rearrangements with two elements of a ring.\\<close>\n",
        "assumes": "assumes \"a\\<in>R\" \"b\\<in>R\" \n  ",
        "using": [
            "assms",
            "Ring_ZF_1_L2",
            "ring_oper_distr",
            "Ring_ZF_1_L3",
            "Ring_ZF_1_L4"
        ],
        "statement": "lemma (in ring0) Ring_ZF_2_L1: assumes \"a\\<in>R\" \"b\\<in>R\" \n  shows \"a\\<ra>b\\<cdot>a = (b\\<ra>\\<one>)\\<cdot>a\"\n  ",
        "proof": "using assms Ring_ZF_1_L2 ring_oper_distr Ring_ZF_1_L3 Ring_ZF_1_L4\n  by simp\n",
        "imports": [
            "IsarMathLib.AbelianGroup_ZF"
        ],
        "source": "IsarMathLib/Ring_ZF.thy",
        "id": 1825,
        "informal": " Assuming `a` and `b` are elements of a ring `R`, it holds that `a * b * a = b ^ 1 * a`."
    },
    "273": {
        "type": "definition",
        "text": "text\\<open>Since the intervals and rays form a base of a topology, and this topology\nis uniquely determined; we can built it. In the definition\nwe have to make sure that we have a totally ordered set.\\<close>\n",
        "assumes": "",
        "using": [],
        "statement": "definition \n  OrderTopology (\"OrdTopology _ _\" 50) where\n  \"IsLinOrder(X,r) \\<Longrightarrow> OrdTopology X r \\<equiv> TopologyBase {IntervalX(X,r,b,c). \\<langle>b,c\\<rangle>\\<in>X\\<times>X}\\<union>{LeftRayX(X,r,b). b\\<in>X}\\<union>{RightRayX(X,r,b). b\\<in>X}\"\n",
        "proof": "",
        "imports": [
            "IsarMathLib.Topology_ZF_1",
            "IsarMathLib.Order_ZF"
        ],
        "source": "IsarMathLib/Topology_ZF_examples_1.thy",
        "id": 2346,
        "informal": " A binary relation \"r\" on a linearly ordered set \"X\" defines an order topology if and only if the collection of sets formed by the intervals with endpoints from \"X\" and the left and right rays with base point from \"X\" defines a topology base for \"X x X\". Here, an interval is the set of ordered pairs with endpoints in \"X\" under relation \"r\", while a ray is the set of ordered pairs with one endpoint in \"X\" and the other endpoint being any element in \"X\" under relation \"r\"."
    }
}